
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "~booksC/-\r\n" ) ; //U:: TO FIND A BUG

    THREADmODE3rESTORE

    }
        //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal4S::_processGlobal4I_IF().heap.cNewF()-processGlobal4S::_processGlobal4I_IF().heap.cDelF() , "    psttFindLike\r\n" ) ;
        ((tin123S&)tin0P).pEther->delF( tin0P , psttFindLike ) ;
        //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal4S::_processGlobal4I_IF().heap.cNewF()-processGlobal4S::_processGlobal4I_IF().heap.cDelF() , "    \r\n" ) ;
        }
            //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal4S::_processGlobal4I_IF().heap.cNewF()-processGlobal4S::_processGlobal4I_IF().heap.cDelF() , "    \r\n" ) ;
            }
                if( !bDoneAll  ) ((tin123S&)tin0P).pEther->traceF( tin0P , T("~booksC / could not delete some badking files and am abandoning the effort because this process has been fired") ) ;
                }
                    if( !cFail ) bDoneAll = 1 ;
                    while( ~hFind && !cFail ) ;
                    }
                        DEL( pInfo ) ;
                        }
                            }
                                }
                                    ((tin123S&)tin0P).pEther->traceF( tin0P , T("~booksC / could not delete ; will retry several times [like,path,short]:    ")+T(psttFindLike)+tb4+T(fnLike.pathF())+(!pInfo?T(""):tb4+T(pInfo->psttIfoName)) ) ;
                                    POOPRqUIET ;
                                {
                                else
                                if( !POOP ) bDoneWo = 1 ;

                                ((tin123S&)tin0P).pEtScratch->diskFileOrDirDeleteF( tin0P , pInfo->psttIfoName ) ;
                            {
                            while( !bDoneWo )
                            ZE( boolT , bDoneWo ) ;
                            ZE( boolT , bDoneAll ) ;

                            //((tin123S&)tin0P).pEther->traceF( tin0P , T("~booksC / deleting [short]:    ")+T(pInfo->psttIfoName) ) ;
                        {
                        if( pInfo && !( F(pInfo->flags) & flFILEaTTR1_DIRECTORY ) )

                        }
                            ((tin123S&)tin0P).pEther->traceF( tin0P , T("~booksC / impotence while finding a file [like,path,short]:    ")+T(psttFindLike)+tb4+T(fnLike.pathF())+(!pInfo?T(""):tb4+T(pInfo->psttIfoName)) ) ;
                            cFail ++ ;
                            POOPRqUIET ;
                        {
                        if( POOP )
                        ((tin123S&)tin0P).pEtScratch->diskFindFileOrDirF( tin0P , pInfo , hFind , fnLike.pathF() , &pat ) ; ___( pInfo ) ;
                        ZE( infoFileS* , pInfo ) ;
                    {
                    do
                    handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                    ZE( countT , cFail ) ;
                {
                while( cTries -- && !bDoneAll )
                countT cTries = etherC::etPrimeIF() ? 0x10 : TUCK ;     // etherC::etPrimeIF() WILL ALWAYS EXIST SINCE etScratch EXISTS
                ZE( boolT , bDoneAll ) ;

                SCOOPS
            {
            IFsCRATCH
            TN( tb4 , "    " ) ;
            //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal4S::_processGlobal4I_IF().heap.cNewF()-processGlobal4S::_processGlobal4I_IF().heap.cDelF() , "    \r\n" ) ;

            patternC pat( tin0P , *((tin123S&)tin0P).pEther , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

            //((tin123S&)tin0P).pEther->traceF( tin0P , T("[fnLike.pathF()]:    ")+T(fnLike.pathF()) ) ;
            //((tin123S&)tin0P).pEther->traceF( tin0P , T("        [fnLike]:    ")+T(fnLike) ) ;
            //((tin123S&)tin0P).pEther->traceF( tin0P , T("  [psttFindLike]:    ")+T(psttFindLike) ) ;
            fileNameC fnLike( tin0P , *((tin123S&)tin0P).pEther , psttFindLike ) ;
        {
        if( F(flagsCt) & flBOOKSc_PURGEoNdT && ((tin123S&)tin0P).pEther )
    {
    else
    }
        }
            while( ~hFind ) ;
            }
                thirdC::dosDeleteIF( tin0P , postName ) ;

                }
                    break ;
                    __( ~hFind ) ;
                {
                if( !postName[ 0 ] )
                thirdC::dosFindFileOrDirSimpleIF( tin0P , postName , sizeof postName , hFind , postFindLike ) ;
                postName[ 0 ] = 0 ;
                osTextT postName[ TUCK << 1 ] ;
            {
            do
            handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        {
        if( F(flagsCt) & flBOOKSc_PURGEoNdT )
    {
    if( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE ) //BOTH FLAVORS ARE RETAINED IN ORDER TO HAVE TRUE UNLIMITED CAPACITY WHEN PUSE EXISTS
    //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal4S::_processGlobal4I_IF().heap.cNewF()-processGlobal4S::_processGlobal4I_IF().heap.cDelF() , "    \r\n" ) ;

    processGlobal4I.heap.delF( tin0P , *(byteT**)&ppcpIdBook           ) ;
    processGlobal4I.heap.delF( tin0P , *(byteT**)&pcpIdBookScratchMax  ) ;
    processGlobal4I.heap.delF( tin0P , *(byteT**)&pcpIdBookScratchMin  ) ;
    processGlobal4I.heap.delF( tin0P , *(byteT**)&pcpIdBookScratch1    ) ;
    processGlobal4I.heap.delF( tin0P , pbFlagsiBookBackCt              ) ;
    processGlobal4I.heap.delF( tin0P , pbBookBack                      ) ;
    processGlobal4I.heap.delF( tin0P , postBookNameScratch             ) ;

    }
        DELzOMBIE( pfDoomed ) ;
        DELzOMBIE( pnDoomed ) ;
        fileC*   pfDoomed = (fileC*)pbFileReadCursor ;
        napkinC* pnDoomed = (napkinC*)pbNapReadCursor ;
    {
    if( *(countT*)pbNapReadCursor )

    }
        DELzOMBIEbOOKbACKnOWiF
        processGlobal4I.heap.delF( tin0P , *(byteT**)&ppcpIdBook[ offBookBackNow ] ) ;
    {
    for( offBookBackNow = 0 ; offBookBackNow < CbOOKsLOTS ; offBookBackNow ++ )

    else if( this == &processGlobal4I.bksWords        ) processGlobal2I.flDt |= flCTdTg_bksWords        ;
    else if( this == &processGlobal4I.bksWord         ) processGlobal2I.flDt |= flCTdTg_bksWord         ;
    else if( this == &processGlobal4I.bksTelemetryApp ) processGlobal2I.flDt |= flCTdTg_bksTelemetryApp ;
         if( this == &processGlobal4I.bksTelemetrySys ) processGlobal2I.flDt |= flCTdTg_bksTelemetrySys ;

    //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal4S::_processGlobal4I_IF().heap.cNewF()-processGlobal4S::_processGlobal4I_IF().heap.cDelF() , "    \r\n" ) ;

    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )

    //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "~booksC/+\r\n" ) ; //U:: TO FIND A BUG

    _IO_

    SCOOP
    TINSL
{
/*1*/booksC::~booksC( voidT )/*1*/

    }
        /*}                                                                                                                                                                                   */    \
        /*    LOGrAW(   ostoSay ) ;                                                                                                                                                           */    \
        /*    OStEXTAK( ostoSay , "\r\n" ) ;                                                                                                                                                  */    \
        /*    OStEXTC(  ostoSay , pbFlagsiBookBackCt[OFFbOOKsLOTnOW/SB]&mask , 0 ) ;                                                                                                          */    \
        /*    OStEXTAK( ostoSay ,"    " ) ;                                                                                                                                                   */    \
        /*    OStEXTC(  ostoSay , *pbFlagsiBookBackCt , 0 ) ;                                                                                                                                 */    \
        /*    OStEXTAK( ostoSay ,"    " ) ;                                                                                                                                                   */    \
        /*    OStEXTCF( ostoSay , pbFlagsiBookBackCt , '0' ) ;                                                                                                                                */    \
        /*    OStEXTAK( ostoSay ,"    " ) ;                                                                                                                                                   */    \
        /*    OStEXTC(  ostoSay , offBookBackNow , 0 ) ;                                                                                                                                      */    \
        /*    OStEXTAK( ostoSay ,"    " ) ;                                                                                                                                                   */    \
        /*    OStEXTC(  ostoSay , PBbOOKbACKnOW , '0' ) ;                                                                                                                                     */    \
        /*    OStEXTAK( ostoSay , "DELzOMBIEbOOKbACKnOWiF / not deleting [pbBook,offBookBackNow,pbFlagsiBookBackCt,*pbFlagsiBookBackCt,pbFlagsiBookBackCt[OFFbOOKsLOTnOW/SB]&mask]:    " ) ;  */    \
        /*    OStEXT(   ostoSay , TUCK << 2 ) ;                                                                                                                                               */    \
        /*{                                                                                                                                                                                   */    \
        /*else                                                                                                                                                                                */    \
        }                                                                                                                                                                                           \
            DELzOMBIE( pDoomed ) ;                                                                                                                                                                  \
            bookC* pDoomed = (bookC*)PBbOOKbACKnOW ;                                                                                                                                                \
            BOOKnOWrESETfLAG                                                                                                                                                                        \
        {                                                                                                                                                                                           \
        if( BOOKnOWeXISTS )                                                                                                                                                                         \
                                                                                                                                                                                                    \
        byteT mask = BOOKnOWmASK ;                                                                                                                                                                  \
    {                                                                                                                                                                                               \
                                                                                                                                                                                                    \
#define DELzOMBIEbOOKbACKnOWiF                                                                                                                                                                      \

#define OFFbOOKsLOTnOW ( offBookBackNow % CbOOKsLOTS )

#define NEWbOOK2sETfLAG pbFlagsiBookBackCt[ OFFbOOKsLOTnOW / SB ] |= mask ;

#define BOOKnOWrESETfLAG pbFlagsiBookBackCt[ OFFbOOKsLOTnOW / SB ] &= ~mask ;

        if( BOOKnOWeXISTS ) { BLAMMO ; }
        byteT mask = BOOKnOWmASK ;                                                          \
                                                                                            \
#define NEWbOOK1bLAMMOiFcT                                                                  \

#define BOOKnOWeXISTS ( pbFlagsiBookBackCt[ OFFbOOKsLOTnOW / SB ] & mask )

#define BOOKnOWmASK ( (byteT)( 1 << OFFbOOKsLOTnOW % SB ) )

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

