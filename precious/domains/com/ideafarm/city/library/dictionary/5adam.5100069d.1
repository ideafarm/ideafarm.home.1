
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    }
        }
            etThread.delF( tin0P , psttTrimmed ) ;
            etThread.delF( tin0P , psttNew ) ;
            etThread.delF( tin0P , psttOld ) ;

            etThread.diskMoveFileOrDirF( tin0P , psttNew , psttOld , 1 ) ;

            //etThread.traceF( tin0P , T("new : ")+T(psttNew) ) ;
            etThread.strFuseF( tin0P , psttNew , tDotJpg ) ;
            etThread.strFuseF( tin0P , psttNew , psttTrimmed ) ;
            etThread.strFuseF( tin0P , psttNew , sttDot ) ;
            etThread.strFuseF( tin0P , psttNew , TF3(idf2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,3) ) ;
            etThread.strFuseF( tin0P , psttNew , sttDot ) ;
            etThread.strFuseF( tin0P , psttNew , psttLeverTime ) ;
            etThread.strFuseF( tin0P , psttNew , tIdeafarm6Dot ) ;
            etThread.strMakeF( tin0P , LF , psttNew , tPath , TUCK << 2 ) ; ___( psttNew ) ;
            ZE( strokeS* , psttNew ) ;

            etThread.delF( tin0P , psttn ) ;
            ((tin123S&)tin0P).pEther->strSubstringF( tin0P , psttTrimmed , idf , countTC() , psttn ) ; ___( psttTrimmed ) ;
            countT idf = 5 ;
            ZE( strokeS* , psttTrimmed ) ;

            //etThread.traceF( tin0P , T("old : ")+T(psttOld) ) ;
            etThread.strFuseF( tin0P , psttOld , tDotJpg ) ;
            etThread.strFuseF( tin0P , psttOld , psttn ) ;
            etThread.strFuseF( tin0P , psttOld , psttLeverTime ) ;
            etThread.strFuseF( tin0P , psttOld , tIdeafarm5Dot ) ;
            etThread.strMakeF( tin0P , LF , psttOld , tPath , TUCK << 2 ) ; ___( psttOld ) ;
            ZE( strokeS* , psttOld ) ;

            //etThread.traceF( tin0P , T("dime: ")+T(psttn) ) ;
            swsNameByBaseName >> psttn ;
            ZE( strokeS* , psttn ) ;
        {
        while( swsNameByBaseName )

        //etThread.traceF( tin0P , T("base: ")+T(psttLeverBaseName) ) ;
        //etThread.traceF( tin0P , psttLeverBaseName ) ;
        psttLeverBaseName = (strokeS*)swsNameByBaseName.leverF( tin0P , idf2 ) ;
    {
    for( countT idf2 = 1 ; idf2 <= cFlavors2 ; idf2 ++ )
    strokeS sttDot( '.' ) ;
    countT cFlavors2 = swsNameByBaseName.cFlavorsF( tin0P ) ;

    }
        etThread.delF( tin0P , psttBaseName ) ;
        }
            swsNameByBaseName << psttn ; psttn = 0 ;
            psttLeverBaseName = psttBaseName ;
        {
        if( !idf )

        etThread.strSubstringF( tin0P , psttBaseName , idf , sttq , tSssDim , psttn ) ; ___( psttBaseName ) ;
        countT idf = 5 ;
        ZE( strokeS* , psttBaseName ) ;

        //etThread.traceF( tin0P , T("in  : ")+T(psttn) ) ;
        swsNameByTime >> psttn ;
        ZE( strokeS* , psttn ) ;
    {
    while( swsNameByTime )

    switchStackC swsNameByBaseName( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttLeverBaseName , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    ZE( strokeS* , psttLeverBaseName ) ;

    psttLeverTime = (strokeS*)swsNameByTime.leverF( tin0P , idFlavor ) ;

    if( !( cTimesRemaining % ( TUCK >> 4 ) ) ) etThread.traceF( tin0P , T("times remaining: ")+TF2(cTimesRemaining,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
    countT cTimesRemaining = cFlavors - idFlavor ;
{
for( countT idFlavor = 1 ; idFlavor <= cFlavors ; idFlavor ++ )
countT cFlavors = swsNameByTime.cFlavorsF( tin0P ) ;

;
                                                                
    +S2(sa_SSSaNDeND,sc_ccSSS)
        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S3(0,sc_ccSSSrEPEAT,7)
        +T("x")
        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S3(0,sc_ccSSSrEPEAT,7)
        +T(".")
    +S2(sa_SSSaND,sc_ccSSS)
    T("")

TN( tSssDim , "" ) ; tSssDim =           // ".12345678x12345678."
strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

etThread.diskWalkF( tin0P , cDirs , cFiles , tPath , bQuit , diskWalkRenameCBF , pcArg ) ;
ZE( countT , bQuit ) ;
ZE( countT , cFiles ) ;
ZE( countT , cDirs ) ;
TN( tPath , "///d/ideafarm.home.101/IdeaFarm (tm)/2.1. Drop Files Here To Archive Them/" ) ;

countT pcArg[] = { (countT)&psttLeverTime , (countT)&swsNameByTime , (countT)&cDone , (countT)&tIdeafarm5Dot , (countT)&tDotJpg } ;

TN( tDotJpg       , ".jpg" ) ;
TN( tIdeafarm6Dot , "!ideafarm.6." ) ;
TN( tIdeafarm5Dot , "!ideafarm.5." ) ;
ZE( countT        , cDone ) ;

switchStackC swsNameByTime( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttLeverTime , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
ZE( strokeS* , psttLeverTime ) ;

TODO

}
    return 0 ;

    ((tin123S&)tin0P).pEther->delF( tin0P , psttShort3 ) ;
    ((tin123S&)tin0P).pEther->delF( tin0P , psttShort2 ) ;
    ((tin123S&)tin0P).pEther->delF( tin0P , psttShort1 ) ;
    ((tin123S&)tin0P).pEther->delF( tin0P , psttShort ) ;
    ((tin123S&)tin0P).pEther->delF( tin0P , psttPath ) ;

    }
        }
            swsNameByTimeP << psttShort3NoExt ; psttShort3NoExt = 0 ;
            psttLeverTimeP = psttShort2 ;

            ((tin123S&)tin0P).pEther->strSubstringF( tin0P , psttShort3NoExt , idf , idl , psttShort3 ) ; ___( psttShort3NoExt ) ;
            idl = psttShort3->idAdam - 4 ;
            idf = 1 ;
            ZE( strokeS* , psttShort3NoExt ) ;
        {
        )
            psttShort3->idAdam - 3 == ((tin123S&)tin0P).pEther->strIdF( tin0P , tDotJpgP , psttShort3 , - 1 )
            &&
            psttShort3[ CSpREFIX - 1 + 1 ].idAdam == '.'
            &&
            psttShort2[ CSpREFIX - 1 + 9 ].idAdam == '@'
            &&
            !((tin123S&)tin0P).pEther->strCompareF( tin0P , tIdeafarm5DotP , psttShort1 )
        (
        if

        ((tin123S&)tin0P).pEther->strConvertToLowerCaseF( tin0P , psttShort3 ) ;
        ((tin123S&)tin0P).pEther->strSubstringF( tin0P , psttShort3 , idf , idl , psttShort ) ; ___( psttShort3 ) ;
        idl = 0 ;
        ((tin123S&)tin0P).pEther->strSubstringF( tin0P , psttShort2 , idf , idl , psttShort ) ; ___( psttShort2 ) ;
        idl = 0x19 ;
        ((tin123S&)tin0P).pEther->strSubstringF( tin0P , psttShort1 , idf , idl , psttShort ) ; ___( psttShort1 ) ;
        countT idl = 0xc ;
        countT idf = 1 ;
    {
    if( psttShort && psttShort->idAdam >= 0x1e )
    ZE( strokeS* , psttShort3 ) ;
    ZE( strokeS* , psttShort2 ) ;
    ZE( strokeS* , psttShort1 ) ;

    // !ideafarm.5.19991228@0000.00.!.note.ttt
    // !ideafarm.5.19991228@0000.00.000b3751.c44d5e6f.2f9afda7.scanner.!.19991228@0000.notarized.declaration.of.legal.name.change.0600x0761.jpg
    // |----------||-----------||-->
    // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
    // 0              1               2               3               4

    //etherC::etRockIF( tin0P ).traceF( tin0P , psttShort ) ;
    //etherC::etRockIF( tin0P ).traceF( tin0P , psttPath ) ;

    ___( psttShort ) ;
    ___( psttPath ) ;
    ((tin123S&)tin0P).pEther->strBisectF( tin0P , psttPath , psttShort , tNameOld , 0 , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
    ZE( strokeS* , psttShort ) ;
    ZE( strokeS* , psttPath ) ;

    TN( tNameOld , ifFileNameC( tin0P , *((tin123S&)tin0P).pEther , postNameP ) ) ;

    if( !( cDoneP % TUCK ) ) etherC::etRockIF( tin0P ).traceF( tin0P , T("[cDoneP]: ")+TF2(cDoneP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
    cDoneP ++ ;

    textC&        tDotJpgP       =         *(textC*)pcArgP[ 4 ] ;
    textC&        tIdeafarm5DotP =         *(textC*)pcArgP[ 3 ] ;
    countT&       cDoneP         =        *(countT*)pcArgP[ 2 ] ; 
    switchStackC& swsNameByTimeP =  *(switchStackC*)pcArgP[ 1 ] ;
    strokeS*&     psttLeverTimeP =      *(strokeS**)pcArgP[ 0 ] ;
{
boolT diskWalkRenameCBF( tin0S& tin0P , countT& cDirsP , countT& cFilesP , boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

// THE FORMAT 5 SEQUENCE NUMBERS ARE INCORRECT IN THAT JPG FILES WHICH DIFFER ONLY IN DIMENSION ARE NOT GIVEN THE SAME SEQUENCE NUMBER

/*1*/WAKEsHOWtEXT( "tool.rename.archive.format.5.recalculate.sequence.correctly" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

