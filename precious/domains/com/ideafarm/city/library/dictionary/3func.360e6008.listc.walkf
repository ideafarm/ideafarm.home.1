
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return flagsRC ;

    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.idNestP -- ;

    //((tinFullS&)tinBaseP).tlsDelF( LF , *(byteT**)&pczName ) ;
    { puseC puseat( tinBaseP , ifcIDpOOL_ADAMtEMP ) ; PUSE( tinBaseP , *(byteT**)&pczName ) ; }

    if( bClearPoolRecord ) ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.pPoolRecord = 0 ;

    if( !ppHand[ 1 ] && ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleHiP ) ppHand[ 1 ] = new( 0 , tinBaseP , (byteT*)((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleHiP , SIZEOF_handleC ) handleC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
    if( !ppHand[ 0 ] && ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleLoP ) ppHand[ 0 ] = new( 0 , tinBaseP , (byteT*)((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleLoP , SIZEOF_handleC ) handleC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

    if( !( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_DOnOTuNGRABoOTHaTeNDoFwALK ) ) { DELzOMBIE( ppHand[ !offWoth ] ) ; }

    }
        }
            else if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleRootP ) ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleRootP->closeIfF() ;
            }
                if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pbHandleRootP ) phRoot = new( 0 , tinBaseP , ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pbHandleRootP , SIZEOF_handleC ) handleC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            
                DELzOMBIE( phRoot ) ;
                handleC*& phRoot = *((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.ppHandleRootP ;
            {
            if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.ppHandleRootP && ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pbHandleRootP )
        {
        if( bWothIsRoot && !( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_RETAINrOOT ) )

        DELzOMBIE( ppHand[  offWoth ] ) ;
    {
    if( !( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_DOnOTuNGRABwOTHaTeNDoFwALK ) )

    }
        }
            __( !*pApt ) ;
                                                  pNew = 0 ;

            //}
            //    LOGrAW(    ostoSay ) ;
            //    CONoUTrAW( ostoSay ) ;
            //
            //    OStEXTAK( ostoSay , "\r\n" ) ;
            //    OStEXTA(  ostoSay , bOk ? " (is a           listingC)" : " (is NOT a           listingC)" ) ;
            //    OStEXTA(  ostoSay , pPoolIn ? pPoolIn->postNameF( tinBaseP ) : "unknown" ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTA(  ostoSay , ((tinFullS&)tinBaseP).pPoolUse->postNameF( tinBaseP ) ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , pNew , 0 ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , *pApt , 0 ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , ((tinFullS&)tinBaseP).pag1->idAdam , 0 ) ;
            //    OStEXTAK( ostoSay , "          listC::walkF new [idAdam,apt,ptr,puse,inpool]: " ) ;
            //    OStEXT(   ostoSay , TUCK << 2 ) ;
            //
            //    boolT  bOk     =           listingC::bIsListingIF( tinBaseP , pNew ) ;
            //    poolC* pPoolIn = poolC::pPoolIF( tinBaseP , (byteT*)pNew ) ;
            //{
            //if( ((tinFullS&)tinBaseP).pc Utility[ 0 ] && idName == LISTnAMEsYS_RECORD )

                                         *pApt = pNew ;
                ((          listC*)pNew)->aptBro = *pApt ;
            __( ((          listC*)pNew)->aptBro ) ;
                      listingC*& pNew = ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pNewP ;

            cKidNew ++ ;
            flagsRC |= flLISTwALKrETURNcODE_NEWlISTING ;
        {
        if( !POOP && ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pNewP )
        //CS:CODEsYNC: PSEUDOdUPLICATEcODE 2200004 2200004
    
        FV(flLISTwALKcALLbACKrETURNcODE,flRetCode) ;

        ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer = save ;

        THREADmODE3rESTORE
        // ********************************************************************************************************************************************************************
        flagsT flRetCode = !((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pListWalkCBFP ? flLISTwALKcALLbACKrETURNcODE_null : (*((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pListWalkCBFP)( tinBaseP ) ;
        // ********************************************************************************************************************************************************************

                      ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer = idGrabLayerP ;
        countT save = ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer ;

        ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.idCallP ++ ;
        THREADmODE3oN( flTHREADmODE3_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE3_ALLOWnEWdROPnOTiNaDAMtEMP ) ;
        ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pDadP = this ;
        ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pListingP = 0 ;
    {
    if( !POOP && !bQuit )

    }
        }
            if( bWothIsRoot ) bWothIsRoot = 0 ;
            offWoth = !offWoth ;
        {
        if( !bKidDeleted )
        //pklNU = pk && pk->flagsF() & fliLISTINGc_MIXINlIST ? (          listC*)pk : 0 ; //FOR DEBUGGING CONVENIENCE ; NOT USED

        }
            pk = &APT(      listingC , *pApt ) ;
            if( pk ) pApt = &(     (listC*)pk)->aptBro ; // IF !pk THEN *pApt NOW POINTS TO THE           listingC THAT FOLLOWED THE DELETED           listingC
        {
        else
        }
            pk = &APT( listingOfSetC , *pApt ) ;
            if( pk ) pApt = &((listOfSetC*)pk)->aptBro ; // IF !pk THEN *pApt NOW POINTS TO THE           listingC THAT FOLLOWED THE DELETED           listingC
        {
        if( bOfSet )

        }
            break ;
            bQuit = 1 ;
        {
        if( F(flRetCode) & flLISTwALKcALLbACKrETURNcODE_QUIT )

        }
            }
                else if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleRootP ) ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleRootP->closeIfF() ;
                }
                    if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pbHandleRootP ) phRoot = new( 0 , tinBaseP , ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pbHandleRootP , SIZEOF_handleC ) handleC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            
                    DELzOMBIE( phRoot ) ;
                    handleC*& phRoot = *((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.ppHandleRootP ;
                {
                if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.ppHandleRootP && ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pbHandleRootP )
            {
            if( bWothIsRoot && !( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_RETAINrOOT ) )

            ppHand[ offWoth ] = new( 0 , tinBaseP , offWoth ? pbHi : pbLo , SIZEOF_handleC ) handleC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            DELzOMBIE( ppHand[ offWoth ] ) ;
        {
        if( !bKidDeleted && !bWothDeleted )

        }
            ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer = save ;

            THREADmODE3rESTORE
            DEL( pk ) ;
            THREADmODE3oN( flTHREADmODE3_ALLOWdESTRUCTIONoFlISTINGc ) ;

                          ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer = idGrabLayerP ;
            countT save = ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer ;

            ppHand[ !offWoth ] = new( 0 , tinBaseP , !offWoth ? pbHi : pbLo , SIZEOF_handleC ) handleC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            DELzOMBIE( ppHand[ !offWoth ] ) ;
        
                    ((          listC*)pk)->aptBro.resetF() ;
            *pApt = ((          listC*)pk)->aptBro ;  //CAST IS DONE TO AVOID NEEDING TO MAKE ME A FRIEND OF           listingC; IN GENERAL, *pk WILL NOT BE A           listC INSTANCE; THIS IS OK BECAUSE aptBro IS A MEMBER OF           listingC SO WILL ALWAYS BE AT THE EXPECTED LOCATION
        {
        if( bKidDeleted )

        }
            }
                }
                    break ;           // THIS HAPPENS WHILE DELETING {ROOT,APPLICATION} WHEN UNINDEX ATTEMPTS TO DELETE SYSTEM2, WHICH IS STILL GRABBED AS PART OF THE WALK OF ROOT
                    bKidDeleted = 0 ; // THE CALLING THREAD GRABBED *pk RECURSIVELY AND IT WILL STILL BE GRABBED IF I TRY TO DELETE IT
                {
                if( ((tinFullS&)tinBaseP).ppbGrabitRecurse[ offr ] == pbFind && ((tinFullS&)tinBaseP).pcGrabitRecurse[ offr ] )
            {
            for( countT offr = 0 ; offr < CmAXgRABITrECURSEiNtINs ; offr ++ )
            byteT* pbFind = (byteT*)&pk->flagsRefF() ;
        {
        if( bKidDeleted )

        ;
            && ( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_IGNOREcREF                                                              || !pk->cRefF()      )
            && ( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_IGNOREcREFdATUM || pk->idTypeDatumF() == ifcIDtYPEmIXINdATUM_listingVSP || !pk->cRefDatumF( tinBaseP ) )
            pk->flagsF() & fliLISTINGc_DELETErEQUESTED
        boolT bKidDeleted =

        }
            }
                POPtINaRGS

                ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer = save ;

                // ********************************************************
                ((          listC*)pk)->walkF( tinBaseP , idGrabLayerP ) ;
                // ********************************************************

                              ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer = idGrabLayerP ;
                countT save = ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer ;

                ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP    = flLISTwALK_CALLERgRABBEDrOOT ;
                ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pListWalkCBFP = listWalkUnIndexCBF ;
                PUSHtINaRGS
            {
            )
                && pczName[ 1 ] == LISTnAMEsYS_ROOTaPPLICATION
                && pczName[ 0 ] == LISTnAMEsYS_ROOT
                && pczName
                && (           listingC::bIsListingIF( tinBaseP , *pApt , fliLISTINGc_MIXINlIST ) ||           listingC::bIsListingIF( tinBaseP , *pApt , fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM ) )
                pk->flagsF() & fliLISTINGc_DELETErEQUESTED
            (
            if

            if( POOP ) break ;
            }
                ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.cRecurseP -- ;
                ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP = flagsSave ;

                ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer = save ;

                // ********************************************************
                flagsT flagsRC = ((          listC*)pk)->walkF( tinBaseP , idGrabLayerP ) ;
                // ********************************************************

                              ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer = idGrabLayerP ;
                countT save = ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer ;

                                   ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP |= flLISTwALK_CALLERgRABBEDrOOT ;
                flagsT flagsSave = ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP ;
                ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.cRecurseP ++ ;
            {
            )
                && (           listingC::bIsListingIF( tinBaseP , *pApt , fliLISTINGc_MIXINlIST ) ||           listingC::bIsListingIF( tinBaseP , *pApt , fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM ) )
                && !( F(flRetCode) & flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE )
                   !( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_DOnOTwALKkIDaFTERcALLINGkID )
            (
            if // NOTE THAT I WILL WALK A LIST EVEN IF ITS INSPECTOR RETURNED flLISTwALKcALLbACKrETURNcODE_QUIT

            }
                if( F(flRetCode) & flLISTwALKcALLbACKrETURNcODE_DELETE ) pk->flagsRefF() |= fliLISTINGc_DELETErEQUESTED ;
    
                }
                    }
                        else if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleRootP ) ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleRootP->closeIfF() ;
                        }
                            if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pbHandleRootP ) phRoot = new( 0 , tinBaseP , ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pbHandleRootP , SIZEOF_handleC ) handleC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            
                            DELzOMBIE( phRoot ) ;
                            handleC*& phRoot = *((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.ppHandleRootP ;
                        {
                        if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.ppHandleRootP && ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pbHandleRootP )
                    {
                    if( bWothIsRoot && !( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_RETAINrOOT ) )
            
                    ppHand[ offWoth ] = new( 0 , tinBaseP , offWoth ? pbHi : pbLo , SIZEOF_handleC ) handleC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                    DELzOMBIE( ppHand[ offWoth ] ) ;

                    cKidNotDeleted ++ ;
                {
                if( bWothDeleted ) 
                bWothDeleted = !( F(flRetCode) & flLISTwALKcALLbACKrETURNcODE_DELETE ) ; //WOTH CAN BE CLOSED NOW UNLESS THE CURRENT LISTING MIGHT BE DELETED AFTER BEING WALKED
    
                }
                    if( POOP ) break ;
                    }
                                                     __( !*pApt ) ;
                                                                  pNew = 0 ;
                                                          *pApt = pNew ;
                            (     (listC*)pNew)->aptBro = *pApt ;
                        __( (     (listC*)pNew)->aptBro ) ;
                    {
                    else
                    }
                                                     __( !*pApt ) ;
                                                                  pNew = 0 ;
                                                          *pApt = pNew ;
                            ((listOfSetC*)pNew)->aptBro = *pApt ;
                        __( ((listOfSetC*)pNew)->aptBro ) ;
                    {
                    if( bOfSet )
                    listingC*& pNew = ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pNewP ;

                    cKidNew ++ ;
                    flagsRC |= flLISTwALKrETURNcODE_NEWlISTING ;
                {
                if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pNewP )
                //CS:CODEsYNC: PSEUDOdUPLICATEcODE 2200004 2200004

                if( POOP ) break ;
                FV(flLISTwALKcALLbACKrETURNcODE,flRetCode) ;

                ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer = save ;

                THREADmODE3rESTORE
                // ****************************************************************************************************************************
                if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pListWalkCBFP ) flRetCode = (*((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pListWalkCBFP)( tinBaseP ) ;
                // ****************************************************************************************************************************
                ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.idCallP ++ ;
                THREADmODE3oN( flTHREADmODE3_ALLOWcONSTRUCTIONoFlISTINGc | flTHREADmODE3_ALLOWnEWdROPnOTiNaDAMtEMP ) ;

                              ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer = idGrabLayerP ;
                countT save = ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer ;

                ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pDadP = this ;
                __( !          listingC::bIsListingIF( tinBaseP , ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pListingP ) ) ; //U::TO FIND A BUG
                ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pListingP = pk ;
            {
            if( bCall )

            }
                bCall = !!((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.offStretchEnd ;

                }
                    }
                        default                              : { if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.offStretchEnd ) ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.offStretchEnd = ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.offStretchBegin = 0 ; break ; }
                        case LISTnAMEsYS_STRETCHbEGINbITS       : { ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.offStretchBegin = off ; break ; }
                        case LISTnAMEsYS_STRETCHbEGINcOUNTsTRZ  :
                        case LISTnAMEsYS_STRETCHbEGINcOUNT      :
                        case LISTnAMEsYS_STRETCHbEGINoStEXTsTRZ :
                        case LISTnAMEsYS_STRETCHeND             : { ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.offStretchEnd   = off ; break ; }
                    {
                    switch( pczName[ off ] )
                {
                for( countT off = 0 ; pczName[ off ] ; off ++ )
            {
            if( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_FILTEReNDoFsTRETCHEDvALUE )

            boolT bCall = !( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_FILTEReNDoFsTRETCHEDvALUE ) ; //IF NO FILTER FLAGS ARE SET

            }
                ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.cRecurseP -- ;
                ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP = flagsSave ;

                ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer = save ;

                // ********************************************************
                flagsT flagsRC = ((          listC*)pk)->walkF( tinBaseP , idGrabLayerP ) ;
                // ********************************************************

                              ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer = idGrabLayerP ;
                countT save = ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.idGrabLayer ;

                                   ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP |= flLISTwALK_CALLERgRABBEDrOOT ;
                flagsT flagsSave = ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP ;
                ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.cRecurseP ++ ;
            {
            )
                && (           listingC::bIsListingIF( tinBaseP , *pApt , fliLISTINGc_MIXINlIST ) ||           listingC::bIsListingIF( tinBaseP , *pApt , fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM ) )
                F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_WALKkIDbEFOREcALLINGkID
            (
            if // THIS EARLY WALK CODE DOES NOT EXECUTE UNLESS EXPLICITLY REQUESTED BY APPLICATION CODE
        {
        if( !( pk->flagsF() & fliLISTINGc_DELETErEQUESTED ) )
        ZE( boolT , bWothDeleted ) ;
        flagsT flRetCode = flLISTwALKcALLbACKrETURNcODE_null ;

        if( !( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_IGNOREgRABITbIT ) ) { grabitC grabitx( tinBaseP , TAG( TAGiDnULL ) ) ; pk->openF( tinBaseP , *ppHand[ !offWoth ] , 0 , idGrabLayerP ) ; }

        }
            pk->flagsRefF() &= (byteT)~fliLISTINGc_GRABBED ;
            //else        { CONoUTrAW(  " resetting the GRABBED bit for a           listingC\r\n" ) ; }
            //if( pklNU ) { CONoUTrAW3( " resetting the GRABBED bit for           listC [idName]: " , pklNU->idName , "\r\n" ) ; }
        {
        if( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_RESETgRABITbIT && pk->flagsF() & fliLISTINGc_GRABBED )
        //CONoUTrAW3( "[pk->flagsi]: " , pk->flagsF() , "\r\n" ) ;

        }
            break ;
            __1
            __( *pApt ) ;
        {
        if( !listingC::bIsListingIF( tinBaseP , *pApt ) )

        //if( !( idPass % TUCK ) ) { CONoUTrAW( "~" ) ; } //U::WHY IS CPU NOT PEGGED?
        //countT idPass = 1 + incv02AM( idPassLath ) ;
        //static countT idPassLath ;
    {
    while( pk )
    ZE( boolT , bQuit ) ;

    //}
    //    LOGrAW(    ostoSay ) ;
    //    CONoUTrAW( ostoSay ) ;
    //
    //    OStEXTAK( ostoSay , "\r\n" ) ;
    //    OStEXTA(  ostoSay , bOk  ? " (is a           listingC)" : " (is NOT a           listingC)" ) ;
    //    OStEXTA(  ostoSay , pPoolIn ? pPoolIn->postNameF( tinBaseP ) : "unknown" ) ;
    //    OStEXTAK( ostoSay , " " ) ;
    //    OStEXTA(  ostoSay , ((tinFullS&)tinBaseP).pPoolUse->postNameF( tinBaseP ) ) ;
    //    OStEXTAK( ostoSay , " " ) ;
    //    OStEXTC(  ostoSay , pk , 0 ) ;
    //    OStEXTAK( ostoSay , " " ) ;
    //    OStEXTC(  ostoSay , aptKid , 0 ) ;
    //    OStEXTAK( ostoSay , " " ) ;
    //    OStEXTC(  ostoSay , ((tinFullS&)tinBaseP).pag1->idAdam , 0 ) ;
    //    OStEXTAK( ostoSay , "          listC::walkF old [idAdam,apt,ptr,puse,inpool]: " ) ;
    //    OStEXT(   ostoSay , TUCK << 2 ) ;
    //
    //    boolT  bOk     =           listingC::bIsListingIF( tinBaseP , pk ) ;
    //    poolC* pPoolIn = poolC::pPoolIF( tinBaseP , (byteT*)pk ) ;
    //{
    //if( ((tinFullS&)tinBaseP).pc Utility[ 0 ] && idName == LISTnAMEsYS_RECORD && pk )

    //listC* pklNU = pk && pk->flagsF() & fliLISTINGc_MIXINlIST ? (          listC*)pk : 0 ; //FOR DEBUGGING CONVENIENCE ; NOT USED

    ;
        :  &APT(      listingC , *pApt )
        ?  &APT( listingOfSetC , *pApt )
    listingC* pk = bOfSet

    aptC* pApt = &aptKid ;
    ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.idCallP = 0 ;
    ZE( countT , cKidNew ) ;
    ZE( countT , cKidNotDeleted ) ;

    boolT bWothIsRoot = 1 ;
    if( !( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & ( flLISTwALK_CALLERgRABBEDrOOT | flLISTwALK_IGNOREgRABITbIT ) ) ) { grabitC grabitx( tinBaseP , TAG( TAGiDnULL ) ) ; openF( tinBaseP , *ppHand[ offWoth ] , 0 , idGrabLayerP ) ; }

    }
        flagsi &= (byteT)~fliLISTINGc_GRABBED ;
        CONoUTrAW3( " resetting the GRABBED bit for           listC [idName]: " , idName , "\r\n" ) ;
    {
    if( F(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) & flLISTwALK_RESETgRABITbIT && flagsi & fliLISTINGc_GRABBED )
    //CONoUTrAW3( "[    flagsi]: " , flagsi , "\r\n" ) ;

    countT& offWoth = *( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pOffWothP ? ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pOffWothP : &offWothDefault ) ;
    ZE( countT , offWothDefault ) ;

    ppHand[ 1 ] = ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleHiP ? (handleC*)pbHi : new( 0 , tinBaseP , pbHi , SIZEOF_handleC ) handleC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
    ppHand[ 0 ] = ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleLoP ? (handleC*)pbLo : new( 0 , tinBaseP , pbLo , SIZEOF_handleC ) handleC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
    handleC* ppHand[ 2 ] ;

    byteT* const pbHi = ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleHiP ? (byteT*)((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleHiP : pbDefault + SIZEOF_handleC ;
    byteT* const pbLo = ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleLoP ? (byteT*)((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pHandleLoP : pbDefault ;
    byteT pbDefault[ 2 * SIZEOF_handleC ] ;

    }
        __( !((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.pPoolRecord ) ;
        ((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.pPoolRecord = poolC::pPoolFromNameIF( tinBaseP , vspo ) ;
        __( !(const byteT*)vspo ) ;
        THREADmODE3rESTORE
        blobVSP vspo =           listC::dictionaryQueryFromIdIF( tinBaseP , pczName[ 3 ] ) ;
        THREADmODE3oN( flTHREADmODE3_ALLOWdICTIONARYwHILEgRABBING )

        bClearPoolRecord = 1 ;
    {
    if( pczName[ 0 ] == LISTnAMEsYS_ROOT && pczName[ 1 ] == LISTnAMEsYS_ROOTsYSTEM3 && pczName[ 2 ] == LISTnAMEsYS_FIELDvALUEiNDEX && pczName[ 3 ] && !pczName[ 4 ] && !((tinFullS&)tinBaseP).ta.retained.u.listWalk.walk.pPoolRecord )
    ZE( boolT , bClearPoolRecord ) ;

    nameF( tinBaseP , pczName ) ; //20240913@2129: BACK TO ALLOC IN poolC IN ORDER TO MINIMIZE USE OF TLS ; 20140111@1810: NOW ALLOCATED IN TLS: { puseC puseat( tinBaseP , ifcIDpOOL_ADAMtEMP ) ; ___( pczName ) ; }
    ZE( countT* , pczName ) ;

    ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.idNestP ++ ;
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    const boolT  bOfSet = F(flagsPoolFormat) & flPOOLfORMAT_SETS ;
    const flagsT flagsPoolFormat = PUSE.flagsPoolFormatF() ;

    _IO_

    }
        if( POOP ) return flagsRC ;
        FV(flLISTwALK,((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP) ;
        if( POOP ) return flagsRC ;
        __( tinBaseP.idTypeTin - ifcIDtYPEtIN_FULL ) ;
        if( POOP ) return flagsRC ;
    {
    IFbEcAREFUL

    flagsT flagsRC = flLISTwALKrETURNcODE_null ;
{
/*1*/flagsT           listC::walkF( tinBaseS& tinBaseP , const countT idGrabLayerP )/*1*/

/**/
*/
  if walking the root list, *pczNameP must be 0
  the lath value must equal idName
  caller must declare a name for the list being walked
 pczNameP
  see tinArgS, which is used both to call me and for me to pass info into a callback function provided by the caller
 tinBaseP
arguments for the outermost call to walkF
it is illegal for any application code to reference           listingC instances anywhere other than within the definition of a listWalkCBFT function
it is illegal for listWalkCBFT to store a pointer or reference to any           listingC object for use outside of the callback function
 the outermost caller of me must clear the entire ((tinFullS&)tinBaseP). ta.a.pc1 and ((tinFullS&)tinBaseP). ta.a.pc2 AND ((tinFullS&)tinBaseP). ta.a.pc3 arrays and then set them as specified in the following
 for efficiency and to avoid exhausting the thread stack, i use ((tinFullS&)tinBaseP). ta.a.pc for my arguments
i call myself recursively, perhaps deeply
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

