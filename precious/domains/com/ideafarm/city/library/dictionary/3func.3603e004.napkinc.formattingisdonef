
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        BLAMMO ;
        POOPR
    {
    if( POOP )

    }
        etRock.traceF( tin0P , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;        // traceF WILL DETECT THAT IT MUST DEFER THIS BOOKING (BECAUSE I HAVE GRABBED AT LEVEL ifcIDgRABlAYER_eGRABmEMORYsPACEc, WHICH IS ABOVE ifcIDgRABlAYER_bBOOKSc
        etherC& etRock = etherC::etRockIF( tin0P ) ;
        OStEXTA(  ostoSay , postName ) ;
        OStEXTAK( ostoSay , "    " ) ;
        OStEXTC(  ostoSay , idImpotence2 , 0 ) ;
        OStEXTAK( ostoSay , "napkinC::formattingIsDoneF / could not write \"formatted\" fingerprint [idImpotence2,postName]:    " ) ;
        OStEXT(   ostoSay , TUCK << 1 ) ;
    {
    else if( idImpotence2 )
    }
        etRock.traceF( tin0P , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;        // traceF WILL DETECT THAT IT MUST DEFER THIS BOOKING (BECAUSE I HAVE GRABBED AT LEVEL ifcIDgRABlAYER_eGRABmEMORYsPACEc, WHICH IS ABOVE ifcIDgRABlAYER_bBOOKSc
        etherC& etRock = etherC::etRockIF( tin0P ) ;
        OStEXTA(  ostoSay , postName ) ;
        OStEXTAK( ostoSay , "napkinC::formattingIsDoneF / access denied, so could not write \"formatted\" fingerprint [postName]:    " ) ;
        OStEXT(   ostoSay , TUCK << 1 ) ;
    {
    if( idImpotence2 == ifcIDiMPOTENCEbASEeRRORcODE_ACCESSdENIED )

    }
        etRock.traceF( tin0P , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;        // traceF WILL DETECT THAT IT MUST DEFER THIS BOOKING (BECAUSE I HAVE GRABBED AT LEVEL ifcIDgRABlAYER_eGRABmEMORYsPACEc, WHICH IS ABOVE ifcIDgRABlAYER_bBOOKSc
        etherC& etRock = etherC::etRockIF( tin0P ) ;
        OStEXTA(  ostoSay , postName ) ;
        OStEXTAK( ostoSay , "    " ) ;
        OStEXTC(  ostoSay , idImpotence1 , 0 ) ;
        OStEXTAK( ostoSay , "napkinC::formattingIsDoneF / could not flush [idImpotence1,postName]:    " ) ;
        OStEXT(   ostoSay , TUCK << 1 ) ;
    {
    else if( idImpotence1 )
    }
        etRock.traceF( tin0P , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;        // traceF WILL DETECT THAT IT MUST DEFER THIS BOOKING (BECAUSE I HAVE GRABBED AT LEVEL ifcIDgRABlAYER_eGRABmEMORYsPACEc, WHICH IS ABOVE ifcIDgRABlAYER_bBOOKSc
        etherC& etRock = etherC::etRockIF( tin0P ) ;
        OStEXTA(  ostoSay , postName ) ;
        OStEXTAK( ostoSay , "napkinC::formattingIsDoneF / access denied, so could not flush [postName]:    " ) ;
        OStEXT(   ostoSay , TUCK << 1 ) ;
    {
    if( idImpotence1 == ifcIDiMPOTENCEbASEeRRORcODE_ACCESSdENIED )

    }
        TELLsYSc3LIFI( ifcIDtYPEtELLsYS_NAPKINfORMAT , (byteT*)&ti , sizeof ti , idLineCt , idiFileCt )
        ti.idiFileCt = idiFileCt ;
        ti.idLineCt  = idLineCt ;
        ti.cbData    = ((napkinHeaderS*)pbNapkin)->cbData ;
        ti.pbData    = pbNapkin + sizeof( napkinHeaderS ) ;
        ti.costName  = thirdC::c_strlenIF( tin0P , ti.postName ) ;
        thirdC::c_strncpyIF( tin0P , ti.postName , postName , sizeof ti.postName ) ;
        ti.osPid     = ((tin1S&)tin0P).osPid ;
        tellInfoSysNapkinS ti ;
    {
    if( !bNoTellP && pbNapkin && this != &processGlobal4I.napHome ) //ASSUME: napHome IS CT WOTH

    ((tin1S&)tin0P).cYield = 0 ;
    thirdC::dosPriorityIF( tin0P , idDesireCtSave ) ;

    THREADmODE3oFF( flTHREADmODE3_SUPPRESStRACING )
    }
        //CONoUTrAW( "\r\n" ) ;
        //CONoUTrAW( postName ) ;
        //CONoUTrAW( "memory space ungrabbed:  " ) ;
        THREADmODE4rESTORE0( flThreadMode4Save )
        pzbMemorySpaceUse->ungrabF( tin0P ) ;
        //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("formattingIsDoneF / ungrabbing [pzbMemorySpaceUse]:    ")+TF2((countT)pzbMemorySpaceUse,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    if( !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT ) )

    bDataAreaFormatted ++ ;

    }
        }
            POOPRqUIET
            idImpotence2 = POOP ;
        {
        if( POOP )
        putNegAM( ((napkinHeaderS*)pbNapkin)->bFormatted , FINGERnEG_NAPKINiSfORMATTED ) ;
        POOPIE
    {
    ZE( boolT , idImpotence2 ) ;

    }
        }
            POOPRqUIET
            idImpotence1 = POOP ;
        {
        if( POOP )
        thirdC::flushViewOfFileIF( tin0P , pbNapkin , sizeof( napkinHeaderS ) + ((napkinHeaderS*)pbNapkin)->cbData ) ; //THIS IS DONE TO ENSURE THAT FINGERnEG_NAPKINiSfORMATTED CANNOT BE SEEN UNLESS THE BACKING FILE IMAGE CONTAINS A COMPLETELY FORMATTED IMAGE
        POOPIE
    {
    ZE( boolT , idImpotence1 ) ;

    _IO_

    }
        if( POOP ) BLAMMO ;
        __Z( pbNapkin ) ;
        __( osTidCt - ((tin1S&)tin0P).osTid ) ;
        __( bDataAreaFormatted ) ;
        __( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) ;
        if( POOP ) BLAMMO ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT napkinC::formattingIsDoneF( tin0S& tin0P , const boolT bNoTellP )/*1*/

/**/
*/
 tin0P
arguments
i must be called exactly wo'ce after constructing me to indicate that the caller has finished formatting my data area
\<A HREF=\"5.15e0005.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$formattingIsDoneF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
