
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

etThread.delF( tin0P , pbi2 ) ;
etThread.delF( tin0P , pbi1 ) ;


}
    etThread.traceF( tin0P , T("---- [offWoth,off,diff,cbRemaining]:    ")+TF2(offWoth,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pbc1-pbi1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tb4+TF2(offWoth-(pbc1-pbi1),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pbe1-pbc1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    }
        }
            pbc1 += sizeof( count01T ) ;
            etThread.traceF( tin0P , T("++++ [signature]:    ")+TF2(*(count02T*)pbc1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN) ) ;
        {
        default :
        }
            break ;

            pbc2  = pbc1 ;

            pEE2 = (endEntryS*)pbc2 ; pbc2 += sizeof( endEntryS ) ;
            pEE1 = (endEntryS*)pbc1 ; pbc1 += sizeof( endEntryS ) ;
            static endEntryS* pEE2 ;
            static endEntryS* pEE1 ;
        {
        case 0x06054b50 :
        }
            break ;

            pbc2  = pbc1 ;

            pbc1 = pbSave1 + 0x52 + pFE1->cbFileName ;

#endif
            pbc1 += sizeof( count01T ) ;
#else
            pbc1 += pFE1->cbComment ;
            
            pbc1 += pFE1->cbCompressed ;
            
            pbc1 += pFE1->cbExtraField ;
#if defined( NEVERdEFINED )

            pbIndexLag = pbSave1 ;
            cbFileNameLag = pFE1->cbFileName ;
            
            etThread.traceF( tin0P , T("index [cbFileName,fileName]:    ")+TF2(pFE1->cbFileName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postfnBuf) ) ; pbc1 += pFE1->cbFileName ;

            postfnBuf[ pFE1->cbFileName ] = 0 ;
            thirdC::c_memcpyIF( tin0P , postfnBuf , pbc1 , pFE1->cbFileName ) ;

            etThread.traceF( tin0P , T("index [cbEntry]:    ")+TF2(cbEntry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            countT cbEntry = pbSave1 - cbFileNameLag - pbIndexLag ;

            }
                countT foo = 2 ;
            {
            if( bDiffOo )
            bDiffOo = etThread.memCompareF( tin0P , (byteT*)pFE2 , (byteT*)pFE1 , sizeof( fileEntryS ) ) ;
            static boolT bDiffOo ;

            pFE2 = (fileEntryS*)pbc2 ; pbc2 += sizeof( fileEntryS ) ;
            pFE1 = (fileEntryS*)pbc1 ; pbc1 += sizeof( fileEntryS ) ;
            static fileEntryS* pFE2 ;
            static fileEntryS* pFE1 ;

            const byteT* pbSave2 = pbc2 ;
            const byteT* pbSave1 = pbc1 ;
        {
        case 0x02014b50 :
        }
            break ;

            pbc2  = pbSave2 + ( pbc1 - pbSave1 ) ;

            pbc1 += pLFH1->cbCompressed ;
            
            pbc1 += pLFH1->cbExtraField ;
            
            etThread.traceF( tin0P , T("data  [fileName]:    ")+T(postfnBuf) ) ; pbc1 += pLFH1->cbFileName ;

            postfnBuf[ pLFH1->cbFileName ] = 0 ;
            thirdC::c_memcpyIF( tin0P , postfnBuf , pbc1 , pLFH1->cbFileName ) ;

            }
                countT foo = 2 ;
            {
            if( bDiffWo )
            bDiffWo = etThread.memCompareF( tin0P , (byteT*)pLFH2 , (byteT*)pLFH1 , sizeof( localFileHeaderS ) ) ;
            static boolT bDiffWo ;

            }
                }
                    break ;
                    etThread.traceF( tin0P , T("hit woth diff at [offi]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT offWoth = offi ;
                {
                if( pbi2[ offi ] - pbi1[ offi ] )
            {
            for( countT offi = (byteT*)pLFH1 - pbi1 ; offi < cbi1 ; offi ++ )

            pLFH2 = (localFileHeaderS*)pbc2 ; pbc2 += sizeof( localFileHeaderS ) ;
            pLFH1 = (localFileHeaderS*)pbc1 ; pbc1 += sizeof( localFileHeaderS ) ;
            static localFileHeaderS* pLFH2 ;
            static localFileHeaderS* pLFH1 ;
        {
        case 0x04034b50 :
    {
    switch( *(count02T*)pbc1 )
    etThread.traceF( tin0P , T("++++ [offWoth,off,diff,cbRemaining]:    ")+TF2(offWoth,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pbc1-pbi1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tb4+TF2(offWoth-(pbc1-pbi1),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pbe1-pbc1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    const byteT* pbSave2 = pbc2 ;
    const byteT* pbSave1 = pbc1 ;
{
while( pbc1 < pbe1 )
ZE( countT       , cbFileNameLag ) ;
ZE( const byteT* , pbIndexLag ) ;
osTextT postfnBuf[ TUCK << 1 ] ;

//if( bDiff ) { BLAMMO ; }
static boolT bDiff = etThread.memCompareF( tin0P , pbi1 , pbi2 , cbi1 ) ;

//for( countT offo = offWoth ; offo < cbi1 ; offo ++ ) *(byteT*)&pbi1[ offo ] = 0xee ;

}
    }
        break ;
        etThread.traceF( tin0P , T("woth diff at [offi]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        pbHit = pbi2 + offi ;
        offWoth = offi ;
    {
    if( pbi2[ offi ] - pbi1[ offi ] )
{
for( countT offi = 0 ; offi < cbi1 ; offi ++ )
ZE( const byteT* , pbHit ) ;
ZE( countT , offWoth ) ;

if( cbDiff ) { BLAMMO ; }
static countT cbDiff = cbi2 - cbi1 ;

const byteT* pbe2 = pbi2 + cbi2 ;
const byteT* pbc2 = pbi2 ;
etThread.boxGetShadowF( tin0P , pbi2 , cbi2 , tZip2 ) ; ___( pbi2 ) ;
ZE( countT , cbi2 ) ;
ZE( byteT* , pbi2 ) ;

const byteT* pbe1 = pbi1 + cbi1 ;
const byteT* pbc1 = pbi1 ;
etThread.boxGetShadowF( tin0P , pbi1 , cbi1 , tZip1 ) ; ___( pbi1 ) ;
ZE( countT , cbi1 ) ;
ZE( byteT* , pbi1 ) ;

TN( tb4 , "    " ) ;
TN( tZip2 , "///e/2.zip" ) ;
TN( tZip1 , "///e/1.zip" ) ;

TODO

;
}
    count01T cbComment ;
    count02T offDiskEntries ;
    count02T cbEntries ;
    count01T cEntries ;
    count01T cEntriesThisDisk ;
    count01T idDiskStart ;
    count01T idDiskThis ;
    count02T signature ;
{
struct endEntryS

;
}
    count02T offLocalHeader ;
    count02T externalAttributes ;
    count01T internalAttributes ;
    count01T diskNumberStart ;
    count01T cbComment ;
    count01T cbExtraField ;
    count01T cbFileName ;
    count02T cbUncompressed ;
    count02T cbCompressed ;
    count02T crc32 ;
    count01T lastModFileDate ;
    count01T lastModFileTime ;
    count01T compressionMethod ;
    count01T flags ;
    count01T versionNeeded ;
    count01T versionMadeBy ;
    count02T signature ;
{
struct fileEntryS

;
}
    count01T cbExtraField ;
    count01T cbFileName ;
    count02T cbUncompressed ;
    count02T cbCompressed ;
    count02T crc32 ;
    count01T lastModFileDate ;
    count01T lastModFileTime ;
    count01T compressionMethod ;
    count01T flags ;
    count01T versionNeeded ;
    count02T signature ;
{
struct localFileHeaderS




/*1*/WAKEsHOWtEXT( "doodle dump zip file" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
