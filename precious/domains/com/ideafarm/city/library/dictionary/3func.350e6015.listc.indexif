
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//




















    }
        tinP.ta.retained.u.listWalk.walk.pPoolRecord = 0 ;

        }
            DEL( pPuseIndex ) ;
            PUSE( tinP , *(byteT**)&pczV ) ;
            DELlIST( fieldEditParamOutC , pOut ) ;
            puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
        {

        }
            listC::fieldIF( tinP , pOut , hIKV , pczField , _1_pushC( recordP ) + _1_modePushSinkC() , LF ) ; ___( pOut ) ;
            countT pczField[] = { LISTnAME_RECORD , 0 } ;

            listC::openIF( tinP , hIKV , hIK , pczV ) ;
            handleC hIKV( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
        {
        ZE( fieldEditParamOutC* , pOut ) ;

        }
            listC::openIF( tinP , hIK , pczIK ) ;
            THREADmODE3rESTORE
            listC::dictionaryReplaceOsTextIF( tinP , pczIK ) ;
            THREADmODE3oN( flTHREADmODE3_ALLOWdICTIONARYwHILEgRABBING )
            countT pczIK[] = { LISTnAME_ROOT , LISTnAME_ROOTsYSTEM3 , LISTnAME_FIELDvALUEiNDEX , (countT)postMasterPool , LISTnAME_INDEXaPPLICATION , idKeyInIndex , 0 } ;
        {
        else
        }
            listC::openIF( tinP , hIK , hIndexP , pczK ) ;
            countT pczK[] = { idKeyInIndex , 0 } ;
        {
        if( ~hIndexP )
        handleC hIK( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

        }
            THREADmODE3rESTORE
            }
                }
                    DELzOMBIE( pvspPostKey ) ;
                    idKeyInIndex = dictionaryQueryFromTextIF( tinP , *pvspPostKey ) ;
                {
                if( !bLiteralKey )

                }
                    ___( pPuseIndex ) ;
                    puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                {

                ;
                    : new( 0 , tinP , LF ) puseC( tinP , idStateSpace == ifcIDsTATEsPACE_SINGLEaDAM( tinP ) || idStateSpace == ifcIDsTATEsPACE_SCRATCH ? ifcIDpOOL_ADAMtEMP : ifcIDpOOL_HOMEtEMP )
                    ? new( 0 , tinP , LF ) puseC( puseIndexP )
                pPuseIndex = ~hIndexP
                puseat.doNotRestoreTinWhenDieF() ;
                puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;

                }
                    *pvspPostKey = dictionaryQueryFromIdIF( tinP , idKeyP ) ;
                    pvspPostKey = new( 0 , tinP , pbvsp , sizeof pbvsp ) blobVSP ;
                {
                if( !bLiteralKey )
                ZE( blobVSP* , pvspPostKey ) ;
                byteT pbvsp[ sizeof( blobVSP ) ] ;
                boolT bLiteralKey = LISTnAME_min <= idKeyP && idKeyP << LISTnAME_max ;
            {
            THREADmODE3oN( flTHREADmODE3_ALLOWdICTIONARYwHILEgRABBING )
        {
        if( ~hIndexP || thirdC::c_strcmpIF( tinP , postMasterPool , "adam.temp" ) )
        countT idKeyInIndex = idKeyP ;
        ZE( puseC* , pPuseIndex ) ;
        puseC puseMaster( tinP , *tinP.pPoolUse ) ;

        const countT idStateSpace = PUSE.idStateSpaceF() ;
        ;
            : PUSE.postNameF( tinP )
            ? 0
        const osTextT* postMasterPool = ~hIndexP

        }
            etherC::strStretchIF( tinP , pczV , 0 , valueP , cNetP ) ; ___( pczV ) ;
            puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
        {
        ZE(  countT* , pczV ) ;

        tinP.ta.retained.u.listWalk.walk.pPoolRecord = &PUSE ;

        }
            if( POOP ) return ;
            if( bCareful != - 1 ) { __( bCareful ) ; }
            countT bCareful = (- 1) ;
            if( POOP ) return ;
            __( !!tinP.ta.retained.u.listWalk.walk.pPoolRecord ) ;
            __Z( idKeyP ) ;
            if( POOP ) return ;
        {
        IFbEcAREFUL
    {
    voidT listC::indexIF( tinS& tinP , puseC& puseIndexP , handleC& hIndexP , const countT idKeyP , const countT valueP , const countT cNetP , const listingC& recordP , const listingC& datumP )

//#define FD_INDEXif(countT,- 1)


//   /*1*/FD_INDEXif( countT , - 1 )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

