

//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
}
    }
        }
            ;
                : flSORTERcrESULT_FULLYsORTED
                ? flSORTERcrESULT_NOTfULLYsORTED
            flagsResult = cOutOfOrder 

            ether.traceF( tinP , T("[cOutOfOrder]:    ")+TF2(cOutOfOrder,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            while( ~hSt && -- cDo ) ;
            }
                }
                    idJotOutLath = idJotOut ;

                    if( sgnOrder < 0 ) cOutOfOrder ++ ;
                    sCountT sgnOrder = !idJotOutLath ? 0 : subtractJotsF( tinP , c_pEther , idJotOut , idJotOutLath , param ) ;
                    countT param = (countT)pc3p ;

                    countT idJotOut = jotOut.writeF( tinP , pbi , cbi ) ;
                {
                if( pbi && cbi )

                countT       cbi = pagei ;
                const byteT* pbi = pagei ;
                pageC pagei = jotC::readIF( tinP , idJotIn ) ;

                stIdJot.extractF( 0 , tinP ) ;
                countT idJotIn = stIdJot.upF( tinP , hSt ) ;
            {
            do
            handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            //ether.traceF( tinP , T("flushing stIdJot final / [cDo]:    ")+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            countT cDo = stIdJot ;
        {
        if( !POOP && !bQuitP && stIdJot )

        }
            }
                }
                    }
                        while( ~hSt && -- cDo ) ;
                        }
                            }
                                idJotOutLath = idJotOut ;

                                if( sgnOrder < 0 ) cOutOfOrder ++ ;
                                sCountT sgnOrder = !idJotOutLath ? 0 : subtractJotsF( tinP , c_pEther , idJotOut , idJotOutLath , param ) ;
                                countT param = (countT)pc3p ;

                                }
                                    ether.traceF( tinP , T("sorterC [cEstimateOut,cOut,perTuck]          :    ")+TF2(cEstimateOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cOut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" %") ) ;
                                    ether.traceF( tinP , T("sorterC [cEstimateIn,cIn,perTuck,cOutOfOrder]:    ")+TF2(cEstimateIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" %")+tb4+TF2(cOutOfOrder,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    countT perTuck = ( cOut << 8 ) / cEstimateOut ;
                                {
                                if( !( ++ cOut % TUCK ) )
                                countT idJotOut = jotOut.writeF( tinP , pbi , cbi ) ;

                                //}
                                //    tinP.pEther->traceF( tinP , T("out:    ")+TT(pcCbUsed[0],pcCbUsed[1])+T("    ")+T(psttShort) ) ;
                                //    strokeS* psttShort = (strokeS*)( pbi + sizeof( count04T ) ) ;
                                //    countT* pcCbUsed = (countT*)pbi ;
                                //{
                            {
                            if( pbi && cbi )

                            countT       cbi = pagei ;
                            const byteT* pbi = pagei ;
                            pageC pagei = jotC::readIF( tinP , idJotToFlush ) ;

                            stIdJot.extractF( 0 , tinP ) ;
                            countT idJotToFlush = stIdJot.upF( tinP , hSt ) ;
                        {
                        do
                        handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        //ether.traceF( tinP , T("flushing stIdJot excess / [cDo]:    ")+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        countT cDo = stIdJot - cSortingSlots ;
                    {
                    if( stIdJot > cSortingSlots )

                    //ether.traceF( tinP , T("sunk aok [ids,idJot]:    ")+TF2(ids,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idJotIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                else
                }
                    }
                        __1
                        ether.traceF( tinP , T("exception: sinkF failed silently [idJot]:    ")+TF2(idJotIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;   //SHOULD BE IMPOSSIBLE
                    {
                    if( !bSuppressDuplicates )
                {
                else if( !ids )
                }
                    __1
                    ether.traceF( tinP , T("exception: sink failed [idJot]:    ")+TF2(idJotIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( bFailed )
                //tinP.pc Utility[ 0 ] -- ;
                stIdJot.sinkF( tinP , ids , idJotIn , bSuppressDuplicates ? flSTACKsINK_UNIQUE : flSTACKsINK_null , subtractJotsF , param ) ;
                //tinP.pc Utility[ 0 ] ++ ;
                countT param = (countT)pc3p ;
                ZE( countT , ids ) ;

                }
                    ether.traceF( tinP , T("sorterC [cEstimateIn,cIn,perTuck,cOutOfOrder]:    ")+TF2(cEstimateIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" %")+tb4+TF2(cOutOfOrder,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT perTuck = ( cIn << 8 ) / cEstimateIn ;
                {
                if( !( ++ cIn % TUCK ) )
            {
            if( idJotIn )

            }
                else        idJotIn = jotIn.idLathReadF() ;
                if( !pbIn ) ether.traceF( tinP , T("sorterC / exception: could not obtain blob so ignoring this page") ) ;

                countT       cbIn = pageIn ;
                const byteT* pbIn = pageIn ;
                pageC pageIn = jotIn ;
            {
            ZE( countT , idJotIn ) ;
        {
        while( !bFailed && !bQuitP && cDo -- )
        boolT bSuppressDuplicates = !!( F(flagsMode) & flSORTERc_SILENTLYsUPPRESSdUPLICATES ) ;
        countT  c_pEther = (countT)&ether ;
        countT& bFailed = pc3p[ 0 ] ;
        countT pc3p[] = { 0 , flagsMode , cbIgnoreP } ;
        TN( tb4 , "    " ) ;
        ZE( countT , idJotOutLath ) ;
        ZE( countT , cOutOfOrder ) ;
        ZE( countT , cOut ) ;
        ZE( countT , cIn ) ;

        const countT cEstimateOut = cEstimateOutP ? cEstimateOutP : cDo ;
        const countT cEstimateIn  = cDo ;
    {
    else
    if( !cDo ) flagsResult = flSORTERcrESULT_FULLYsORTED ;
    countT cDo = jotIn.cElementsF() ;
{
flagsResult( flSORTERcrESULT_null )
flagsMode( flagsModeP ) ,
cSortingSlots( cSortingSlotsP ) ,
stIdJot( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKiGNOREtABS | flSTACKc_SINKrEVERSE ) ,
jotIn( jotInP ) ,
jotOut( jotOutP ) ,
ether( etherP ) ,
/*1*/sorterC::sorterC( tinS& tinP , etherC& etherP , const boolT& bQuitP , jotC& jotOutP , jotC& jotInP , countT cSortingSlotsP , flagsT flagsModeP , countT cEstimateOutP , countT cbIgnoreP ) :/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
