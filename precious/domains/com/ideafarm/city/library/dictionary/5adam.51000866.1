
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    ++ s ; ether.osSleepF( tinP , TOCK << EXPtOCKSpERePOCH ) ;

    etThread.traceMemoryGrainRptF( tinP ) ;

    etThread.traceF( tinP , T("all are alive now") ) ;
    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;
    {
    while( cAlive < cDone )

        etThread.osThreadF( TaRG3fLAGScBtLS( tmCatchF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , 0/*CBmYtLS*/ ) , ++ idHostLath , (countT)&cAlive ) ;
    while( cDo -- )

    etThread.traceF( tinP , T("[idEpoch,cDone(after i launch)]:    ")+TF2(idEpoch,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    cDone += cDo ;

    ;
        : 0x10
        ? ChOSTSpERePOCH
    countT cDo = ++ idEpoch <= 3
{
while( !ether )
ZE( countT , cAlive ) ;
ZE( countT , cDone ) ;
sleepC s( tinP , TAG( TAGiDnULL ) ) ;
ZE( countT , idHostLath ) ;
ZE( countT , idEpoch ) ;
TN( tb4 , "    " ) ;

TODO

DONE( tmCatchF )
}
    }
        ++ s ; ether.osSleepF( tinP , idHostP == 1 ? TOCK << EXPtOCKSpERePOCH : TOCK ) ;

//etThread.traceF( tinP , T("zzzz...") ) ;

#endif
        etThread.delF( tinP , pbi ) ;

        }
            }
                }
                    break ;
                    sCatch.writeF( tinP , idpHe , nnHe , ifcIDtYPEdATAGRAM_IaMaLIVE ) ;
                {
                case ifcIDtYPEdATAGRAM_AREyOUaLIVE :
                }
                    break ;
                    stActiveUse.ungrabF( tinP ) ;
                    //etThread.traceF( tinP , T("registered [offUpdate,cPlatesAfter]:    ")+TF2(offUpdate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(stActiveUse,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    stActiveUse.sinkF( tinP , countTC() , idpHe , flSTACKsINK_UNIQUE , 0 , 0 ) ;
                    stActiveUse.grabF( tinP , TAG( TAGiDnULL ) ) ;

                    stackC& stActiveUse = *ppStActive[ offUpdate ] ;
                    countT offUpdate = ( idEpoch + 1 ) % CePOCHsTACKS ;
                {
                case ifcIDtYPEdATAGRAM_IaMaLIVE :
            {
            switch( idType )

            countT& idType = *(countT*)pbi ;
        {
        if( !ether && !POOP && cbi >= sizeof( countT ) )

        portTimeHe.timeStampIfF( tinP , etThread ) ;
        portTimeC portTimeHe( portHe ) ;
        portHe = nnHe ;
        portC portHe( idpHe ) ;

        sCatch.readF( tinP , pbi , cbi , idpHe , nnHe ) ;
        nicNameC     nnHe    ;
        ZE( countT , idpHe ) ;
        ZE( countT , cbi   ) ;
        ZE( byteT* , pbi   ) ;
#if defined( NEVERdEFINED )
    {
    while( !ether && !POOP )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    inc02AM( cAliveP ) ;

#endif
    etThread.osThreadF( TaRG3fLAGScBtLS( tmThrowP , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBmYtLS ) , idHostP , (countT)ppStActive , (countT)&idEpoch ) ;

    ZE( countT , idEpoch ) ;
    stackC* const ppStActive[] = { &stActive1 , &stActive2 } ;                                                                                              //CS:CODEsYNC: 5101200f 5101200f
    stackC  stActive2( tinP , etThread , TAG( TAGiDnULL ), flSTACKc_null , ifcSTACKtYPE_countT , ifcIDgRABlAYER_7BASEmISC1 , 0 , 0 , 0 , 0 , 0 ) ;
    stackC  stActive1( tinP , etThread , TAG( TAGiDnULL ), flSTACKc_null , ifcSTACKtYPE_countT , ifcIDgRABlAYER_7BASEmISC1 , 0 , 0 , 0 , 0 , 0 ) ;

    stackC stActiveNew( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;

    }
        //etThread.traceF( tinP , T("[&sCatch,idpRoot]:    ")+TfORsTRING((countT)&sCatch)+tb4+TF4(idpRoot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
        nnRoot  = nicNameC( 1 ) ;
        idpRoot = idpMe ;
    {
    if( idHostP == 1 )

    countT idpMe = sCatch.bindF( tinP ) ;
    socketC sCatch( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM , flSOCKETc_NOsECRECY | flSOCKETc_NOdUALsTACK , 0 , 0 , 0 , 0 , 0 , 0 ) ;
    TN( tb4 , "    " ) ;
#if defined( NEVERdEFINED )

    countT&      cAliveP = *(countT*)pTaskP->c2 ;
    const countT idHostP =           pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmCatchF )

DONE( tmThrowP )
}
    }
        ++ s ; ether.osSleepF( tinP , idHostP == 1 ? TOCK << EXPtOCKSpERePOCH : TOCK ) ;

#endif
        }
            }
                break ;

                sThrow.writeF( tinP , idpRoot , nicNameC( 1 ) , ifcIDtYPEdATAGRAM_IaMaLIVE ) ;
            {
            default :
            }
                break ;

                stActiveUse.ungrabF( tinP ) ;
                }
                    while( ~hWalk ) ;
                    }
                        etThread.traceF( tinP , T("    listed [idpHe]:    ")+TF4(idpHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
                        countT idpHe = stActiveUse.downF( tinP , hWalk ) ;
                    {
                    do
                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stActiveUse )
                etThread.traceF( tinP , T("active ports [offReport]:    ")+TF2(offReport,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                stActiveUse.grabF( tinP , TAG( TAGiDnULL ) ) ;

                stackC& stActiveUse = *ppStActiveP[ offReport ] ;
                countT offReport = idEpochP % CePOCHsTACKS ;

                stActivePurge.ungrabF( tinP ) ;
                stActivePurge.purgeF( tinP , 0 ) ;
                //etThread.traceF( tinP , T("purging [offPurge,cPlates]:    ")+TF2(offPurge,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(stActivePurge,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                stActivePurge.grabF( tinP , TAG( TAGiDnULL ) ) ;

                idEpochP ++ ;

                stackC& stActivePurge = *ppStActiveP[ offPurge ] ;
                countT offPurge = idEpochP % CePOCHsTACKS ;
            {
            case 1 :
        {
        switch( idHostP )
#if defined( NEVERdEFINED )
    {
    while( !ether && !POOP )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    TN( tb4 , "    " ) ;

#endif
    countT idpMe = sThrow.bindF( tinP ) ;
    socketC sThrow( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM , flSOCKETc_NOsECRECY | flSOCKETc_NOdUALsTACK , 0 , 0 , 0 , 0 , 0 , 0 ) ;

    countT&        idEpochP    = *(countT*)pTaskP->c3 ;
    stackC** const ppStActiveP = (stackC**)pTaskP->c2 ;
#if defined( NEVERdEFINED )
    const countT   idHostP     =           pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmThrowP )

//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return sgn ;

    }
        else if( !bg1 &&  bg2 ) sgn = - 1 ;
             if(  bg1 && !bg2 ) sgn =   1 ;

        boolT   bg2 = !!stIdptGossipP( (byteT*)c2P , subtractIdPortsF , - 1 ) ;
        boolT   bg1 = !!stIdptGossipP( (byteT*)c1P , subtractIdPortsF , - 1 ) ;
        stackC& stIdptGossipP = *(stackC*)c3P ;
    {
    if( sgn && c1P && c2P && c3P != - 1 )   //P: THE OPEN RELAYS LIST BEGINS WITH UNGOSSIPPED RELAYS ELDEST TO YOUNGEST, FOLLOWED BY GOSSIPPED RELAYS ELDEST TO YOUNGEST

    sCountT sgn = c1P && c2P ? idpt1 - idpt2 : 0 ;

    if( !(nicNameC&)idpt1 || !(nicNameC&)idpt2 ) { BLAMMO ; }

    portTimeC&  idpt2 = *(portTimeC*)c2P ;
    portTimeC&  idpt1 = *(portTimeC*)c1P ;

    _IO_     //TLNA( "subtractIdPortTimesOldF" )

    }
    {
    IFbEcAREFUL
{
/*1*/countT _export subtractIdPortTimesF( tinBaseS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

nicNameC nnRoot  ;
countT   idpRoot ;

#define ChOSTSpERePOCH ( TUCK )
//B:#define ChOSTSpERePOCH ( TUCK << 2 )
//20240916@1722

//B:#define ChOSTSpERePOCH ( 1 + ( TUCK >> 4 ) )
//G:#define ChOSTSpERePOCH ( 2 )
//#define ChOSTSpERePOCH ( 1 + ( TUCK >> 3 ) )
// 1 + ( TUCK >> 3 ) WORKS BUT 1 + ( TUCK >> 2 ) DOES NOT

#define CBmYtLS ( CBtLSmINIMUM >> 0 )
//B:#define CBmYtLS ( CBtLSmINIMUM >> 5 )
//G:#define CBmYtLS ( CBtLSmINIMUM >> 4 )
//B:#define CBmYtLS ( CBtLSmINIMUM >> 6 )
//B:#define CBmYtLS ( CBtLSmINIMUM >> 8 )
//G:#define CBmYtLS ( CBtLSmINIMUM >> 3 )
//DUT: CODE COMMENTED OUT SO DOES NOTHING BUT SLEEP

//AOK: #define CBmYtLS ( CBtLSmINIMUM >> 3 )
//BAD: #define CBmYtLS ( CBtLSmINIMUM >> 4 )
//AOK: #define CBmYtLS ( CBtLSmINIMUM >> 2 )

#define EXPtOCKSpERePOCH 0
//#define EXPtOCKSpERePOCH 3
#define CePOCHsTACKS 2

/*1*/WAKEsHOWtEXT( "doodle.udp.bang.relay" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
