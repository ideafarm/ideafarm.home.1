
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //etherP.traceF( tin0P , T("loadIF / -") ) ;
    __( bFail ) ;
    etherP.delF( tin0P , psttRootBranch ) ;
    }
        }
            DELzOMBIE( pSw_jbr ) ;
            }
                //etherP.traceF( tin0P , T("stuffed pSoulLinkP") ) ;
                }
                    }
                        etherP.delF( tin0P , psttText ) ;
                        *pSoulLinkP << psttText ;
                        //etherP.traceF( tin0P , T("loadIF: export: stuffing *pSoulLinkP [idf,idType,hashv,hashId,pstText]: ")+T("    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(hashv,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(hashId,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttText) ) ; //U;; TO FIND A BUG
                        }
                            etherP.strDecodeF( tin0P , psttText , pbzEncoded ) ; ___( psttText ) ;
                            __Z( pbzEncoded ) ;
                            const byteT* pbzEncoded = idType == ifcIDtYPEbRANCHs_strokeSstr ? (const byteT*)pageEncoded : 0 ;
                            PSP( pageEncoded , jbrText ) ;
                        {
                        else
                        if( !idf ) { etherP.strMakeF( tin0P , LF , psttText , psttRootBranch ) ; ___( psttText ) ; }
                        ZE( strokeS* , psttText ) ;

                        *pSoulLinkP << ( !idf ? 0 : hashId ) ;
                        *pSoulLinkP << ( !idf ? 0 : hashv  ) ;
                        }
                            jbrText = B(brc).value  ;
                            hashId  = B(brc).hashId ;
                            hashv   = B(brc).hashv  ;
                            idType  = B(brc).idType ;
                            BSP( brc , jbrc ) ;
                        {
                        if( idf )
                        ZE( countT , jbrText ) ;
                        ZE( countT , hashId ) ;
                        ZE( countT , hashv ) ;
                        ZE( countT , idType ) ;
                    {
                    if( !POOP )
                    if( idf ) { __Z( jbrc ) ; }
                    countT jbrc = !idf ? 0 : *pSw_jbr ;
                    *pSoulLinkP << psttzLabelShort ;
                    //etherP.traceF( tin0P , T("loadIF: stuffing *pSoulLinkP [idf,psttzLabelShort]: ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttzLabelShort) ) ; //U;; TO FIND A BUG
                    psttzLabelShort = !idf ? (strokeS*)tHeyMyRoot : (strokeS*)pSw_jbr->leverF( tin0P , idf ) ;
                {
                for( countT idf = 0 ; idf <= cFlavors ; idf ++ ) //FLAVOR 0 IS FOR AN IMPLICIT LABEL FOR THE ROOT BRANCH
                TN( tHeyMyRoot , "!myRoot" ) ;
                //etherP.traceF( tin0P , T("loadIF: stuffing *pSoulLinkP [pSw_jbr->cFlavors]: ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U;; TO FIND A BUG
                *pSoulLinkP << ( !!psttRootBranch + cFlavors ) ;
                countT cFlavors = pSw_jbr->cFlavorsF( tin0P ) ; //U:: 20160429@1510: pSw_jbr NULL DURING QUIT
                TN( tb , " " ) ;

                }
                    *pSoulLinkP << (countT)1 ; // idFormat
                    *pSoulLinkP << finger ;
                    putNegAM( *(countT*)&finger , FINGERnEG_KTlINKfILEiNNER ) ;
                    ZE( countT , finger ) ;
                    *pSoulLinkP << (osTextT*)T(" >> IdeaFarm (tm) - (c) Wo'O Ideafarm - ideafarm.com << ") ;
                {
                //etherP.traceF( tin0P , T("stuffing pSoulLinkP") ) ;
            {                                         //EXPORT [psttLabelShort,hashv,hashId] TO A FILE SO THAT OTHER KT CAN REFERENCE THE LABELS IN THE INSTANT KT
            if( !POOP && pSoulLinkP && pSw_jbr ) // pSw_jbr NULL TEST ADDED 20160429@1518 WITHOUT ANALYSIS

            }
                //etherP.traceF( tin0P , tTraceWhat+T("-") ) ;
                DELzOMBIE( pSwHashId ) ;
                //etherP.traceF( tin0P , T("deleting pSwHashId") ) ;

                }
                    //etherP.traceF( tin0P , T("deleted pBarryUtility") ) ;
                    DELzOMBIE( ((tin123S&)tin0P).pBarryUtility ) // USED TO DELETE HERE BUT REMOVED TO SUPPORT bRepeat
                    //etherP.traceF( tin0P , T("deleting pBarryUtility") ) ;
                {
                if( bDeleteBarryAsZombie )

                //etherP.traceF( tin0P , tTraceWhat+T("- / after loop") ) ;
                }
                    if( POOP ) etherP.traceF( tin0P , T("poop at loop - [idBranch]: ")+TF3(idBranch,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9) ) ;
            
                    }
                        else jbrc = 0 ;
                        }
                            if( !bFound ) jbrc = 0 ;
            
                            }
                                }
                                    break ;
                                    bFound = 1 ;
                                    jbrc = B(brc).jbrRight ;
                                {
                                if( B(brc).jbrRight )
                                BSP( brc , jbrc ) ;
            
                                if( POOP ) break ;
                                __Z( jbrc ) ;
                                stq_jbrDad >> jbrc ;
                                jbrc = 0 ;
                            {
                            while( stq_jbrDad )
                            ZE( boolT , bFound ) ;
                        {
                        else if( stq_jbrDad )
                        else if( jbrRightc ) jbrc = jbrRightc ;
                        }
                            jbrc = jbrUpc ;
                            stq_jbrDad << jbrc ;
                        {
                        if( jbrUpc )

                        }
                            jbrRightc = B(brc).jbrRight ;
                            jbrUpc    = B(brc).jbrUp    ;
                            BSP( brc , jbrc ) ;
                        {
                        ZE( countT , jbrRightc ) ;
                        ZE( countT , jbrUpc ) ;

                        }
                            }
                                //if( !B(brc).hashv || ( offPass && !B(brc).hashId ) ) etherP.traceF( tin0P , T("branch [idBranch,hashv,hashId]: ")+TP("",stq_jbrDad)+TF3(idBranch,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("    ")+TF3(B(brc).hashv,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("    ")+TF3(B(brc).hashId,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9) ) ;
                            {
                            if( B(brc).idType == ifcIDtYPEbRANCHs_strokeSstr )
                            BSP( brc , jbrc ) ;
                        {
            
                        if( POOP ) break ;
            
                        }
                            }
                                etherP.delF( tin0P , psttLabelWordElement ) ;
                                etherP.delF( tin0P , psttLabelWordLever ) ;
                                etherP.delF( tin0P , psttLabelWordBox ) ;
                                etherP.delF( tin0P , psttLabelLong ) ;
                                etherP.delF( tin0P , psttLabelWordLever ) ;
                                }
                                    }
                                        etherP.delF( tin0P , psttTextGot ) ;
                                        etherP.delF( tin0P , psttFileTinyGot ) ;

                                        }
                                            B(brc).value  = (countT)pbEncoded ;
                                            B(brc).idType = ifcIDtYPEbRANCHs_strokeSstr ;
                                            BSP( brc , jbrc ) ;

                                            if( POOP ) etherP.delF( tin0P , pbEncoded ) ;

                                            etherP.strEncodeF( tin0P , pbEncoded , tTextNew ) ; ___( pbEncoded ) ;
                                            ZEJ( byteT* , pbEncoded , jotP ) ;
                                        {

                                        //etherP.traceF( tin0P , T("new text:   \"")+tTextNew+T("\"") ) ;

                                        ;
                                            : T("<a href=\"http://")+tUri+(!psttLabelWordElement?tn:T("#")+T(psttLabelWordElement))+T("\"><span style=\"color:#c80\" onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'Click to jump from this IdeaFarm (tm) Knowledge Tree to the one at ")+tHost+T("!' , 0 )\">")+sttMark01+sttMarkf2+tDisplay+sttMark01+T("</span></a>")
                                            ? T("please report this error:  could not resolve reference")
                                        TN( tTextNew , "" ) ; tTextNew = !bRoot && !bGotIt
                                        TN( tn , "" ) ;

                                        ;
                                            : T(psttTextGot)
                                            ? tNoteFromCloud
                                        TN( tDisplay , "" ) ; tDisplay = tNoteFromCloud.csF( tin0P )

                                        //
                                        // EXAMPLE: <a href="http://test.mydomain.com/pages/index.z.black.a1587c89.10000000.html#here"><span style="color:#c80" onmouseout="sayMessageF( 0 , 16000 )" onmouseover="sayMessageF( 'Click to jump from this IdeaFarm (tm) Knowledge Tree to another one!' , 0 )">20100815: 22222222222222222222222</span></a>
                                        //
                                        // BUILD THE REPLACEMENT BRANCH TEXT (HTML HYPERTEXT LINK)

                                        //etherP.traceF( tin0P , T("uri" ":   \"")+tUri+T("\"") ) ;
                                        }
                                            ;
                                                : T(".z.black.")+TF3(hashvGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+sttDot+TF3(hashIdGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".html") ;
                                                ? T(".html")
                                            tUri += bRoot
                                            strokeS sttDot( '.' ) ;

                                            }
                                                etherP.delF( tin0P , psttw ) ;

                                                }
                                                    default : {         tUri += !idf ? T(bRoot?"/":"/pages/")+T(psttw) : tSlash+T(psttw) ; break ; }
                                                    case 3  : {                                                                            break ; }
                                                    case 2  :
                                                    case 1  : { tHost = tUri = T(psttw)                                                  ; break ; }
                                                {
                                                switch( ++ idWord )

                                                etherP.strSubstringF( tin0P , psttw , idf , sttq , sttSlash , psttLabelWordBox ) ; ___( psttw ) ;
                                                ZE( strokeS* , psttw ) ;
                                            {
                                            while( idf )
                                            ZE( countT , idWord ) ;
                                            TN( tSlash , "/" ) ;
                                            strokeS sttSlash( '/' ) ;
                                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                            countT idf = 1 ;
                                        {
                                        TN( tHost , "" ) ;
                                        TN( tUri , "" ) ;
                                        // BUILD THE URI

                                        }
                                            //etherP.traceF( tin0P , T("got trimmed [text]:   \"")+T(psttTextGot)+T("\"") ) ;
                                            }
                                                etherP.delF( tin0P , psttd ) ;
                                                etherP.strSubstringF( tin0P , psttTextGot , idf , sttq , sttMark01 , psttd ) ; ___( psttTextGot ) ;

                                                                 psttTextGot = 0 ;
                                                strokeS* psttd = psttTextGot ;
                                            {
                                            if( etherP.strIdF( tin0P , idf , sttq , sttMark01 , psttTextGot , idl , 1 ) )
                                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                            ZE( countT , idl ) ;
                                            countT idf = 1 ;
                                        {
                                        if( psttTextGot )
                                        // TRIM THE TEXT

                                        //etherP.traceF( tin0P , T("got   [note]: \"")+tNoteFromCloud+T("\"") ) ;
                                        //etherP.traceF( tin0P , T("got   [text]: \"")+T(psttTextGot)+T("\"") ) ;
                                        //etherP.traceF( tin0P , T("got [hashId]: ")+TF2(hashIdGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        //etherP.traceF( tin0P , T("got  [hashv]: ")+TF2(hashvGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        //etherP.traceF( tin0P , T("got   [tiny]: \"")+T(psttFileTinyGot)+T("\"") ) ;
                                    {
                                    if( !POOP )

                                    }
                                        __1
                                        etherP.traceF( tin0P , T("!exception: loadIF: error: could not find far label [box,label]:    ")+T(psttLabelWordBox)+T("    ")+T(psttLabelWordLever) ) ;
                                    {
                                    if( !bGotIt )

                                    }
                                        }
                                            }
                                                }
                                                    etherP.delF( tin0P , psttText ) ;

                                                    }
                                                        bGotIt = 1 ;
                                                                      psttText = 0 ;
                                                        psttTextGot = psttText ;
                                                        hashIdGot   = hashId ;
                                                        hashvGot    = hashv  ;
                                                    {
                                                    if( bFound )

                                                    //etherP.traceF( tin0P , T("inner [text]:   \"")+T(psttText)+T("\"") ) ;
                                                    soulLinkInner >> psttText ; ___( psttText ) ;
                                                    ZE( strokeS* , psttText ) ;

                                                    //etherP.traceF( tin0P , T("inner [hashId]:   ")+TF2(hashId,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    soulLinkInner >> hashId ;
                                                    ZE( countT , hashId ) ;

                                                    //etherP.traceF( tin0P , T("inner [hashv]:   ")+TF2(hashv,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    soulLinkInner >> hashv ;
                                                    ZE( countT , hashv ) ;

                                                    etherP.delF( tin0P , psttLabelShort ) ;
                                                    if( !etherP.strCompareF( tin0P , psttLabelShort , psttLabelWordLever ) ) bFound = 1 ;

                                                    //etherP.traceF( tin0P , T("inner [label]:   \"")+T(psttLabelShort)+T("\"") ) ;
                                                    soulLinkInner >> psttLabelShort ; ___( psttLabelShort ) ;
                                                    ZE( strokeS* , psttLabelShort ) ;
                                                {
                                                while( soulLinkInner && !bFound )
                                                ZE( boolT , bFound ) ;

                                                //etherP.traceF( tin0P , T("inner [cFlavors]:   ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                soulLinkInner >> cFlavors ;
                                                ZE( countT , cFlavors ) ;

                                                }
                                                    //etherP.traceF( tin0P , T("inner [idFormat]:   ")+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    soulLinkInner >> idFormat ;
                                                    ZE( countT , idFormat ) ;

                                                    //etherP.traceF( tin0P , T("inner [finger]:   ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    soulLinkInner >> finger ;
                                                    ZE( countT , finger ) ;

                                                    etherP.delF( tin0P , postTM ) ;
                                                    //etherP.traceF( tin0P , T("inner [tm]:   \"")+T(postTM)+T("\"") ) ;
                                                    soulLinkInner >> postTM ; ___( postTM ) ;
                                                    ZE( osTextT* , postTM ) ;
                                                {
                                            {
                                            if( soulLinkInner )

                                            }
                                                soulLinkOuter >> soulLinkInner ;

                                                //etherP.traceF( tin0P , T("outer [fileTiny]:   \"")+T(psttFileTinyGot)+T("\"") ) ;
                                                }
                                                    etherP.delF( tin0P , psttFolderFile ) ;

                                                    }
                                                        etherP.strSubstringF( tin0P , psttFileTinyGot , idHit , countTC() , psttFolderFile ) ; ___( psttFileTinyGot ) ;
                                                        idHit ++ ;
                                                    {
                                                    if( idHit )
                                                    countT idHit = etherP.strIdF( tin0P , strokeS( '/' ) , psttFolderFile , - 1 ) ;

                                                    //etherP.traceF( tin0P , T("outer [folderFile]:   \"")+T(psttFolderFile)+T("\"") ) ;
                                                    soulLinkOuter >> psttFolderFile ; ___( psttFolderFile ) ;
                                                    ZE( strokeS* , psttFolderFile ) ;
                                                {

                                                }
                                                    //etherP.traceF( tin0P , T("outer [idFormat]:   ")+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    soulLinkOuter >> idFormat ;
                                                    ZE( countT , idFormat ) ;

                                                    //etherP.traceF( tin0P , T("outer [finger]:   ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    soulLinkOuter >> finger ;
                                                    ZE( countT , finger ) ;

                                                    etherP.delF( tin0P , postTM ) ;
                                                    //etherP.traceF( tin0P , T("outer [tm]:   \"")+T(postTM)+T("\"") ) ;
                                                    soulLinkOuter >> postTM ; ___( postTM ) ;
                                                    ZE( osTextT* , postTM ) ;
                                                {
                                            {
                                            if( soulLinkOuter )

                                            }
                                                etherP.delF( tin0P , pbLink ) ;
                                                if( pbLink ) soulLinkOuter.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_soulC , pbLink , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;

                                                //if( pbLink ) ; etherP.boxPutF( tin0P , T("///d/tmp/x/verify.soul.blob.not.html") , pbLink , cbLink ) ; //U:: TO FIND A BUG

                                                }
                                                    }
                                                        etherP.traceF( tin0P , T("!exception: error:  could not get page linkage from ")+tBox ) ;
                                                        POOPR ;
                                                    {
                                                    if( POOP )
                                                    ((tin123S&)tin0P).pEtScratch->boxGetShadowF( tin0P , pbLink , cbLink , tBox ) ; ___( pbLink ) ;
                                                    SCOOPS
                                                {
                                                IFsCRATCH
                                                TN( tBox , "" ) ; tBox = T(psttLabelWordBox)+T(".link.pages.soul.blob.not.html") ;
                                                ZE( countT , cbLink ) ;
                                                ZE( byteT* , pbLink ) ;
                                            {
                                            soulC soulLinkOuter( tin0P , TAG( TAGiDnULL ) ) ;
                                        {
                                        soulC soulLinkInner( tin0P , TAG( TAGiDnULL ) ) ;
                                    {
                                    ZE( boolT    , bGotIt ) ;
                                    ZE( strokeS* , psttTextGot ) ;
                                    ZE( strokeS* , psttFileTinyGot ) ;
                                    ZE( countT   , hashIdGot ) ;
                                    ZE( countT   , hashvGot ) ;

                                    }
                                        etherP.strMakeF( tin0P , LF , psttLabelWordLever , T("!myRoot") ) ; ___( psttLabelWordLever ) ;
                                        bRoot = 1 ;
                                    {
                                    if( !psttLabelWordLever )
                                    ZE( boolT    , bRoot ) ;

                                    }
                                        }
                                            etherP.delF( tin0P , psttp ) ;
                                            //etherP.traceF( tin0P , T("soulIdFragCloud [psttp]: ")+T(psttp) ) ;

                                            }
                                                break ;
                                                etherP.delF( tin0P , psttp ) ;
                                                etherP.delF( tin0P , postNote ) ;
                                                //etherP.traceF( tin0P , T("soulIdFragCloud [psttp]: ")+T(psttp) ) ;

                                                }
                                                    if( POOP ) POOPR

                                                    else tNoteFromCloud = T(postNote) ;
                                                    else if( !postNote || !*postNote ) tNoteFromCloud = T("Please report this error:  Note text in ")+T(psttp)+T(" is null length") ;
                                                    }
                                                        tNoteFromCloud = T("Please report this error:  Could not get note text from ")+T(psttp) ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    ((tin123S&)tin0P).pEtScratch->boxGetShadowF( tin0P , postNote , costNote , psttp ) ; ___( postNote ) ;
                                                    SCOOPS
                                                {
                                                IFsCRATCH
                                                ZE( countT , costNote ) ;
                                                ZE( byteT* , postNote ) ;

                                                //etherP.traceF( tin0P , T("retrieving note from [psttp]: \"")+T(psttp)+T("\"") ) ;
                                            {
                                            else if( bFound )
                                            }
                                                if( !etherP.strCompareF( tin0P , psttp , psttLabelWordElement ) ) bFound = 1 ;
                                            {
                                            if( bLabelShort )

                                            soulIdFragCloud >> psttp ; ___( psttp ) ;
                                            ZE( strokeS* , psttp ) ;

                                            bLabelShort = !bLabelShort ;
                                        {
                                        while( soulIdFragCloud ) //U:: OBTAIN THE CONTENTS OF THE MATCHING NOTE FILE
                                        ZE( boolT , bFound ) ;
                                        ZE( boolT , bLabelShort ) ;

                                        }
                                            if( POOP ) POOPR

                                            etherP.delF( tin0P , pbLink ) ;
                                            else soulIdFragCloud.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_soulC , pbLink , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                                            }
                                                tNoteFromCloud = T("Please report this error:  Could not get frag note linkage from ")+tBox ;
                                                POOPR ;
                                            {
                                            if( POOP )

                                            ((tin123S&)tin0P).pEtScratch->boxGetShadowF( tin0P , pbLink , cbLink , tBox ) ; ___( pbLink ) ;
                                            ZE( countT , cbLink ) ;
                                            ZE( byteT* , pbLink ) ;

                                            TN( tBox , "" ) ; tBox = T(psttLabelWordBox)+T(".link.frag.notes.soul.blob.not.html") ;

                                            SCOOPS
                                        {
                                        IFsCRATCH
                                        soulC soulIdFragCloud( tin0P , TAG( TAGiDnULL ) ) ;
                                    {
                                    if( psttLabelWordElement )
                                    TN( tNoteFromCloud , "" ) ;

                                    //etherP.traceF( tin0P , T("link label [label,box]:    \"")+T(psttLabelWordLever)+T("\"")+T("    \"")+T(psttLabelWordBox)+T(".link.pages.soul.blob.not.html")+T("\"") ) ;
                                {
                                else
                                }
                                    }
                                        //etherP.traceF( tin0P , T("setting reference [jbrHe,psttzLabelShort,psttRefHtmlId]:")+TF2(*pSw_jbr,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    \"")+T(psttzLabelShort)+T("\"    \"")+T(B(brc).psttRefHtmlId)+T("\"") ) ;
                                        B(brc).value = *pSw_jbr ; // jbrzHe        (THIS LINE OVERWRITES pbEncoded WHICH IS NOW A ZOMBIE POINTER
                                                               psttLabelWordElement = 0 ;
                                        B(brc).psttRefHtmlId = psttLabelWordElement  ;
                                        psttzLabelShort      = psttLabelWordLever ;
                                    {
                                    else if( psttLabelWordLever )
                                    }
                                        __1                                                                                                       //20180420@1949: COMMENTED OUT WITHOUT ANALYSIS TO HANDLE MISSING LABEL
                                        etherP.traceF( tin0P , T("error: could not find reference \"")+T(psttLabelLong)+T("\"") ) ;
                                        B(brc).value = 0 ;        // jbrzHe        (THIS LINE OVERWRITES pbEncoded WHICH IS NOW A ZOMBIE POINTER
                                    {
                                    if( !pSw_jbr->idSlotOfLeverF( tin0P , (countT)psttLabelWordLever ) )
                                    BSP( brc , jbrc ) ;

                                    __Z( pSw_jbr ) ;
                                {
                                if( !psttLabelWordBox )

                                //etherP.traceF( tin0P , T("loadIF: label word [element]:   ")+T(psttLabelWordElement) ) ;
                                //etherP.traceF( tin0P , T("loadIF: label word   [lever]:   ")+T(psttLabelWordLever  ) ) ;
                                //etherP.traceF( tin0P , T("loadIF: label word     [box]:   ")+T(psttLabelWordBox    ) ) ;
                                etherP.strTrimF( tin0P , psttLabelWordBox , 0 , 0 , T("\"") ) ;

                                }
                                    etherP.delF( tin0P , pstt1LabelLongWords ) ;
                                    }
                                        }
                                            else if( !psttLabelWordElement ) { etherP.strMakeF( tin0P , LF , psttLabelWordElement , psttc1 ) ; ___( psttLabelWordElement ) ; }
                                            else if( !psttLabelWordLever   ) { etherP.strMakeF( tin0P , LF , psttLabelWordLever   , psttc1 ) ; ___( psttLabelWordLever   ) ; }
                                                 if( !psttLabelWordBox     ) { etherP.strMakeF( tin0P , LF , psttLabelWordBox     , psttc1 ) ; ___( psttLabelWordBox     ) ; }
                                        {
                                        else
                                        }
                                            else if( !psttLabelWordElement ) { etherP.strMakeF( tin0P , LF , psttLabelWordElement , psttc1 ) ; ___( psttLabelWordElement ) ; }
                                                 if( !psttLabelWordLever   ) { etherP.strMakeF( tin0P , LF , psttLabelWordLever   , psttc1 ) ; ___( psttLabelWordLever   ) ; }
                                        {
                                        else if( !bFarLabel )
                                        if( !etherP.strCompareF( tin0P , psttc1 , T("!link") ) ) bFarLabel = 1 ;

                                        //etherP.traceF( tin0P , T("loadIF: labelLong word:    ")+T(psttc1) ) ;
                                    {
                                    FORsTRINGSiN1( pstt1LabelLongWords )
                                    ZE( boolT , bFarLabel ) ;
                                    etherP.strWordsF( tin0P , pstt1LabelLongWords , psttLabelLong , sttq , T(",") , flSTRwORDS_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1LabelLongWords ) ;
                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                    ZE( strokeS* , pstt1LabelLongWords ) ;
                                {
                                ZE( strokeS* , psttLabelWordElement ) ;     //OPTIONAL
                                ZE( strokeS* , psttLabelWordLever ) ;       //OPTIONAL
                                ZE( strokeS* , psttLabelWordBox ) ;         //REQUIRED

                                }
                                    //etherP.traceF( tin0P , T("loadIF: [psttLabelLong]:    ")+T(psttLabelLong) ) ;

                                    etherP.delF( tin0P , pbEncoded ) ;
                                    etherP.strDecodeF( tin0P , psttLabelLong , (byteT*)valuec ) ; ___( psttLabelLong ) ;
                                    byteT* pbEncoded = (byteT*)valuec ;
                                {
                                ZE( strokeS* , psttLabelLong ) ;

                                // 
                                // FOR !link  LABELS, THE INSTANT BRANCH WILL BECOME OF TYPE ifcIDtYPEbRANCHs_strokeSstr, WITH A GENERATED STRING VALUE (AN HTML HYPERTEXT LINK)
                                // FOR NORMAL LABELS, THE INSTANT BRANCH WILL REMAIN OF TYPE ifcIDtYPEbRANCHs_branchSptr
                                // 
                                // SEMANTICS

                                //
                                //  !link,"archiveview.mydomain.com//http/201x/3/index",archive                   ACTUAL EXAMPLE (FOM ARCHIVE TOC KT)
                                //  !link,"test.mydomain.com//http/index",label@htmlId                            POINTS TO A FOREIGN LABEL, TO BE RESOLVED USING THE SPECIFIED LINK FILE
                                //  !link,"test.mydomain.com//http/index"                                         POINTS TO THE FOREIGN LABEL "!myRoot", TO BE RESOLVED USING THE SPECIFIED LINK FILE (ADDED 20230612@1603)
                                //  label                                                                         POINTS TO A LABEL WITHIN THE INSTANT KT
                                //
                                // LABEL FORMATS
                            {                                                 //I NOW SUPPORT !link REFERENCES, WHICH HAS TO BE DONE ON LATH PASS SINCE I NEED THE HASH VALUES
                            else if( idTypec == ifcIDtYPEbRANCHs_branchSptr ) //REPLACING REFERENCES COULD BE DONE ON EITHER PASS ; DONE HERE TO BALANCE MEMORY USAGE (barryC IS USED ON THE OTHER PASS)
                            }
                                }
                                    B(brc).hashId = ++ *pSwHashId ;
                                    cLeverHash = B(brc).hashv ;
                                {
                                else
                                if( !cCollisions || !stHashCollisions( B(brc).hashv ) ) B(brc).hashId = 1 ;
                                BSP( brc , jbrc ) ;
                            {
                            if( idTypec == ifcIDtYPEbRANCHs_strokeSstr )

                            }
                                valuec  = B(brc).value  ;
                                idTypec = B(brc).idType ;
                                BSP( brc , jbrc ) ;
                            {
                            ZE( countT , valuec ) ;
                            ZE( countT , idTypec ) ;
                        {
                        else
                        }
                            else                                               B(brc).hashF( tin0P , jbrc , *((tin123S&)tin0P).pBarryUtility , stHashCollisions ) ;
                            if( B(brc).idType != ifcIDtYPEbRANCHs_strokeSstr ) B(brc).hashv = 0xeeeeeeee ; //U::TO FIND A BUG

                            BSP( brc , jbrc ) ;
                        {
                        if( !offPass )
            
                        }
                            }
                                }
                                    break ;
                                    __1
                                    etherP.traceF( tin0P , T("!exception: unexpected type [idType]: ")+TF3(B(brc).idType,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9) ) ;
                                {
                                default :
                                }
                                    break ;
                                {
                                case ifcIDtYPEbRANCHs_branchSptr :
                                case ifcIDtYPEbRANCHs_strokeSstr :
                            {
                            switch( B(brc).idType )

                            BSP( brc , jbrc ) ;
                        {

                        //}
                        //    //LOGrAW5( "loadIF [idThread,idBranch]:    " , ((tin123S&)tin0P).monitor.idThread , "    " , idBranch , "\r\n" ) ;
                        //
                        //    //etherP.traceF( tin0P , T("loadIF [idBranch]: ")+TF2(idBranch,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , flTRACE_null , ifcIDtRACEdIVERT_8 ) ;
                        //
                        //    //if( !( F(((tin123S&)tin0P).flagsThreadMode3) & flTHREADmODE3_INoUTcHATTER ) ) { THREADmODE3oN( flTHREADmODE3_INoUTcHATTER ); }
                        //{
                        //if( !offPass && idBranch >= 0x13aa0 ) //U:: TO FIND A BUG, WE TRACE: loadIF / setting hashv / [idBranch]: aaa31
            
                        ///*if( !( idBranch % ( TUCK << 4 ) ) )*/ etherP.traceF( tin0P , tTraceWhat+T("[idBranch]: ")+TF2(idBranch,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                        ++ idBranch ;

                        _IO_
                    {
                    else
                    }
                        jbrc = 0 ;
                        //etherP.traceF( tin0P , T("setting jbrc to ze [idBranch before incrementing]: ")+TF3(idBranch,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9) ) ;
                    {
                    if( !(const byteT*)jotP[ jbrc & ~NM_HIGH ] )
                {
                while( !POOP && !bQuitP && jbrc )
                switchC* pSwHashId = !cCollisions ? 0 : new( 0 , tin0P , pbSwHashId , sizeof pbSwHashId ) switchC( tin0P , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cLeverHash ) ;
                ZE( countT , cLeverHash ) ;
                byteT pbSwHashId[ sizeof( switchC ) ] ;
                const countT cCollisions = !offPass ? 0 : stHashCollisions ;
                countT jbrc = 2 | jotP.tagHighNibbleF() ;
                ZE( countT , idBranch ) ;
                staqC stq_jbrDad( tin0P ) ;

                }
                    }
                        }
                            }
                                }
                                    etherP.delF( tin0P , psttzLabelShort ) ;
                                    *pSw_jbr = *(countT*)(const byteT*)pi ;

                                    }
                                        break ;
                                        __1
                                        etherP.delF( tin0P , psttzLabelShort ) ;
                                        //etherP.traceF( tin0P , T("error: label is not unique [label]: \"")+T(psttzLabelShort)+T("\"") ) ;                         //U:: TEST ERRORS SUCH AS THIS TO ENSURE THAT SOFTWARE DOESN'T CRASH
                                    {
                                    if( jbrSwitched )

                                    countT& jbrSwitched = *pSw_jbr ;
                                {
                                else
                                if( !psttzLabelShort ) { etherP.strDecodeF( tin0P , psttzLabelShort , pi ) ; ___( psttzLabelShort ) ; }
                            {
                            else
                            if( !(const byteT*)pi ) { BLAMMO ; }    //SHOULD BE IMPOSSIBLE
                            pi = jotReferences ;
                            pageC pi( tin0P , jotReferences , 0 ) ;
                        {
                        while( cDo -- && !bQuitP )
                        countT cDo = jotReferences.cElementsF() ;
                    {
                    if( pSw_jbr )
                    pSw_jbr = new( 0 , tin0P , pb_sw_jbr , sizeof pb_sw_jbr ) switchC( tin0P , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLabelShort ) ;
                {
                if( offPass )

                }
                    }
                        bDeleteBarryAsZombie = 1 ;
                        //etherP.traceF( tin0P , T("constructed  barryC instance") ) ;
                        ((tin123S&)tin0P).pBarryUtility = new( 0 , tin0P , pb_barryHash , sizeof pb_barryHash ) barryC( tin0P ) ; //TO ALLOW APP TO PRECONSTRUCT barryC
                        //etherP.traceF( tin0P , T("constructing barryC instance") ) ;
                    {
                    else
                    if( ((tin123S&)tin0P).pBarryUtility ) ((tin123S&)tin0P).pBarryUtility->setF( tin0P ) ; // ALLOW CALLER TO PRECONSTRUCT barryC INSTANCE SO THAT INABILITY TO CT CAN BE DETECTED EARLIER (barryC HAS A HUGE MEMORY FOOTPRINT)
                {
                if( !offPass )
                ZE( boolT , bDeleteBarryAsZombie ) ;

                byteT pb_sw_jbr[    sizeof( switchC ) ] ;
                byteT pb_barryHash[ sizeof( barryC  ) ] ;
            
                //etherP.traceF( tin0P , tTraceWhat+T("+") ) ;
                TN( tTraceWhat , !offPass ? "loadIF / setting hashv / " : "loadIF / setting hashId and setting reference jPointers / " ) ;
            {
            for( countT offPass = 0 ; !bQuitP && offPass <= 1 ; offPass ++ )
            stackC stHashCollisions( tin0P , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE ) ;
        {
        if( !bFail )
        ZE( switchC* , pSw_jbr ) ;
        ZE( strokeS* , psttzLabelShort ) ;

        }
            }
                }
                    }
                        }
                            }
                                stCursor[ 1 ] = jNew ; jNew = 0 ;
                    
                                B(brLeft).jbrRight = jNew ;
                                __NZ( B(brLeft).jbrRight ) ;
                                BSP( brLeft , stCursor[ 1 ] ) ;
                    
                                if( idLevel < idLevelLath ) stCursor.purgeF( tin0P , idLevel ) ;
                            {
                            else
                            }
                                stCursor << jNew ; jNew = 0 ;
                    
                                }
                                    B(brDown).jbrUp = jNew ;
                                    __NZ( B(brDown).jbrUp ) ;
                                    BSP( brDown , stCursor[ 1 ] ) ;
                                {
                                if( idLevelLath )
                            {
                            if( idLevel == idLevelLath + 1 )
                        {
                        if( !POOP )

                        else { __1 }
                        }
                            if( POOP ) etherP.delF( tin0P , pbEncoded ) ;

                            etherP.delF( tin0P , psttLabelShort ) ;

                            //etherP.traceF( tin0P , T("loadIF new reference [jNew,psttLabelShort]: ")+TF2(jNew,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+T(psttLabelShort) ) ;

                            }
                                new( 0 , tin0P , (byteT*)(const byteT*)pageNew , pageNew ) branchS( (countT)pbEncoded , !bNoRefs ? ifcIDtYPEbRANCHs_branchSptr : ifcIDtYPEbRANCHs_strokeSstr ) ;
                                PSP( pageNew , jNew ) ;
                            {
                            if( !POOP )

                            __Z( jNew ) ;
                            jNew = jotP.writeF( tin0P , 0 , sizeof( branchS ) ) ;
                            jNewLag = jNew ;

                            etherP.strEncodeF( tin0P , pbEncoded , psttLabelShort ) ; ___( pbEncoded ) ;
                            ZE( byteT* , pbEncoded ) ;

                            csttTrimmedP += psttLabelShort->idAdam ;
                        {
                        else if( psttLabelShort )
                        }
                            etherP.delF( tin0P , psttLabelShort ) ;
                            }
                                }
                                    jotReferences.writeF( tin0P , (byteT*)&jNew , sizeof jNew ) ; // jotReferences WILL CONTAIN A SEQUENCE OF [psttLabelShort,jNew] PAIRS
                                    etherP.strEncodeF( tin0P , pbEncoded , psttLabelShort ) ; ___( pbEncoded ) ;
                                    ZEJ( byteT* , pbEncoded , jotReferences ) ;
                                {
                                if( psttLabelShort )
                                pbEncoded = 0 ;
                            {
                            else
                            if( POOP ) etherP.delF( tin0P , pbEncoded ) ;

                            etherP.delF( tin0P , pstttBranch ) ;

                            if( !psttRootBranch ) etherP.strMakeF( tin0P , LF , psttRootBranch , pstttBranch ) ; ___( psttRootBranch ) ;

                            //etherP.traceF( tin0P , T("loadIF new branch   [jNew,pstttBranch]: ")+TF2(jNew,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+T(pstttBranch) ) ;

                            }
                                new( 0 , tin0P , (byteT*)(const byteT*)pageNew , pageNew ) branchS( (countT)pbEncoded ) ;
                                PSP( pageNew , jNew ) ;
                            {
                            if( !POOP )

                            __Z( jNew ) ;
                            jNew = jotP.writeF( tin0P , 0 , sizeof( branchS ) ) ;
                            jNewLag = jNew ;

                            etherP.strEncodeF( tin0P , pbEncoded , pstttBranch ) ; ___( pbEncoded ) ;
                            ZEJ( byteT* , pbEncoded , jotP ) ;

                            //P:PERSONALITY: THE INTENT OF THIS CHANGE IS TO ELIMINATE ALL MODIFICATION BY loadIF OF THE TEXT OF EACH BRANCH SO THAT THE BRANCH TREE JUST CONTAINS WHAT IS SPECIFIED IN THE INPUT SOIL FILE
                            //20230613@1016: CAPITALIZATION OF WOTH STROKE WAS BEING DONE HERE AND WAS INCORRECTLY CAPITALIZING pstttBranch[ CSpREFIX + idMark ] EVEN IF THAT STROKE IS AN ENCODED ESCAPE STROKE; MOVED CAPITALIZATION TO putFileIF

                            csttTrimmedP += pstttBranch->idAdam ;

                            }
                                if( cFoundMark ) idMark = etherP.strIdF( tin0P , sttMark01 , pstttBranch , 1 ) ;

                                if( cFoundLit )     etherP.strReplaceF( tin0P , pstttBranch , 0 , tmff , tBackSlash   , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // SHOW ALL LITERAL BACKSLASH

                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbj  , tmf2 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\j"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbh  , tme2 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\h"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbw  , tmd2 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\w"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tby  , tmc2 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\y"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbz  , tmb2 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\z"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tb9  , tma2 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\9"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tb8  , tm92 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\8"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tb7  , tm82 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\7"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tb6  , tm72 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\6"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tb5  , tm62 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\5"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tb4  , tm52 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\4"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tb3  , tm42 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\3"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tb2  , tm32 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\2"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tb1  , tm22 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\1"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tb0  , tm12 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\0"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbn  , tm02 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\n"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbi  , tmf1 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\i"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbk  , tme1 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\k"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbd  , tmd1 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\d"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbr  , tmc1 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\r"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbx  , tmb1 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\x"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbo  , tma1 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\o"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbt  , tm91 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\t"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbl  , tm81 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\l"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbp  , tm71 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\p"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbe  , tm61 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\e"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbc  , tm51 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\c"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbv  , tm41 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\v"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbs  , tm31 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\s"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tba  , tm21 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\a"
                                                    etherP.strReplaceF( tin0P , pstttBranch , 0 , tbf  , tm11 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\f"
                                countT cFoundMark = etherP.strReplaceF( tin0P , pstttBranch , 0 , tbm  , tm01 , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // ENCODE ALL "\m"
                                countT cFoundLit  = etherP.strReplaceF( tin0P , pstttBranch , 0 , tbb  , tmff , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( pstttBranch ) ; // HIDE ALL LITERAL BACKSLASH
                            {
                            ZE( countT , idMark ) ;
                            //ENCODE ESCAPE CHARACTERS
                        {
                        if( pstttBranch )
                        ZE( countT , jNewLag ) ;
                        ZE( countT , jNew ) ;
                    
                        }
                            break ;
                            bFail = 1 ;
                        {
                        if( idLevel > idLevelLath + 1 ) // CAN SPECIFY KID OF LATH BRANCH, BUT NO HIGHER

                        //etherP.traceF( tin0P , T("loadIfIF [idLevel,psttLabelShort,pstttBranch]: ")+TF2(idLevel,flFORMAT_NObIGITvALUES)+T(" \"")+T(psttLabelShort)+T("\" \"")+T(pstttBranch)+T("\"\r\n") ) ;

                        }
                            }
                                else                                 etherP.delF( tin0P , psttLabelShort   ) ;
                                if( psttLabelShort && psttLabelShort->idAdam ) etherP.delF( tin0P , pstttBranch ) ;
                                etherP.strTrimF( tin0P , psttLabelShort , 0 , tBlank ) ; ___( psttLabelShort ) ;
                                etherP.strSubstringF( tin0P , psttLabelShort , idf , countTC() , pstttBranch ) ; ___( psttLabelShort ) ;
                                countT idf = 2 ;
                            {
                            else if( !idColon2 && pstttBranch->idAdam > 1 )                                                                             // IF THIS LOOKS LIKE A REFERENCE TO A LABELED BRANCH
                            }
                                }
                                    }
                                        etherP.delF( tin0P , pstttAfterLabelShort ) ;
                                        etherP.delF( tin0P , psttLabelShort ) ;
                                    {
                                    else 
                                    }
                                                      pstttAfterLabelShort = 0 ;
                                        pstttBranch = pstttAfterLabelShort ;
                                        etherP.delF( tin0P , pstttBranch ) ;
                                        //etherP.strokeF( tin0P , T("[psttLabelShort,pstttAfterLabelShort]: \"")+T(psttLabelShort)+T("\" \"")+T(pstttAfterLabelShort)+T("\"\r\n") ) ;
                                    {
                                    if( pstttAfterLabelShort && pstttAfterLabelShort->idAdam )
                                    etherP.strTrimF( tin0P , pstttAfterLabelShort , 0 , tBlank ) ; ___( pstttAfterLabelShort ) ;
                                    etherP.strSubstringF( tin0P , pstttAfterLabelShort , idf , countTC() , pstttBranch ) ; ___( pstttAfterLabelShort ) ;
                                    idf = idColon2 + 1 ;
                                {
                                ZE( strokeS* , pstttAfterLabelShort ) ;

                                etherP.strSubstringF( tin0P , psttLabelShort , idf , idl , pstttBranch ) ; ___( psttLabelShort ) ;
                                countT idl = idColon2 - 1 ;
                                countT idf = 2 ;
                            {
                            if( idColon2 > 2 && idColon2 < pstttBranch->idAdam )                                                                        // IF THIS LOOKS LIKE A LABELED BRANCH
                            const countT idColon2 = etherP.strIdF( tin0P , sttColon , pstttBranch , 2 ) ;

                            }
                                break ;
                                etherP.delF( tin0P , pstttBranch ) ;
                                bFail = 1 ;
                            {
                            if( idFieldIn == 1 ) // THE ROOT BRANCH MAY NOT BE EXPLICITLY LABELED (IT IS ALWAYS IMPLICITLY LABELED USING THE RESERVED LABEL "!myRoot"
                        {
                        if( pstttBranch->idAdam && pstttBranch[ CSpREFIX ] == sttColon )
                        ZE( strokeS* , psttLabelShort ) ;

                        etherP.delF( tin0P , psttLine ) ;
                        etherP.strTrimF( tin0P , pstttBranch , psttLine , tBlank ) ; ___( pstttBranch ) ;
                        ZE( strokeS* , pstttBranch ) ;
                    
                        }
                            break ;
                            bFail = 1 ;
                        {
                        if( !idLevel ) //NULL LINE OR LINE OF BLANKS

                        countT idLevel = etherP.strIdAnyF( tin0P , 0 , flSTRmATCH_null , idf , sttq , tBlank , psttLine , 0 , 1 , flSTRiDaNY_NOT ) ;
                        countT idf = 1 ;

                        countT idLevelLath = stCursor ;

                        //etherP.traceF( tin0P , psttLine ) ;
                        etherP.strDecodeF( tin0P , psttLine , pbzEncoded ) ; ___( psttLine ) ;
                        ZE( strokeS* , psttLine ) ;
                    {
                    if( !POOP )

                    }
                        ///*if( idFieldIn == 1 || !( cRemain % TUCK ) )*/ etherP.traceF( tin0P , tTraceWhat+T(" [cRemain]: ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                        countT cRemain = idFieldIn == 1 ? cFieldsIn : cFieldsIn - idFieldIn ;
                    {

                    __( !cbIn ) ;
                    __( flagsIn - flSOULiTEM_null ) ;
                    __( idTypeIn - ifcIDtYPEsOULiTEM_strokeSptr ) ;
                    byteT* pbzEncoded = soulLinesP.pbFieldF( tin0P , idTypeIn , flagsIn , cbIn , idFieldIn ) ;
                    ZE( countT , cbIn     ) ;
                    ZE( flagsT , flagsIn  ) ;
                    ZE( countT , idTypeIn ) ;

                    }
                        countT foo = 2 ;
                    {
                    if( idFieldIn == 0x1806a ) // ITERATION 0x1806b FAILS IN strEncodeF
                    //U:: TO FIND A BUG
                {
                for( countT idFieldIn = 1 ; !bQuitP && idFieldIn <= cFieldsIn ; idFieldIn ++ )
                TN( tTraceWhat , "loadIF / constructing tree from text lines in soulC / " ) ;
                countT cFieldsIn = soulLinesP ;
                boolT bNoRefs = !!( F(flagsP) & flBRANCHslOADf_NOrEFERENCES ) ;

                TN( tmff , ""     ) ; tmff = T("")+S2(0xff,sc_MARK) ;
                TN( tmf2 , ""     ) ; tmf2 = T("")+sttMarkf2 ;
                TN( tme2 , ""     ) ; tme2 = T("")+S2(0x2e,sc_MARK) ;
                TN( tmd2 , ""     ) ; tmd2 = T("")+S2(0x2d,sc_MARK) ;
                TN( tmc2 , ""     ) ; tmc2 = T("")+S2(0x2c,sc_MARK) ;
                TN( tmb2 , ""     ) ; tmb2 = T("")+S2(0x2b,sc_MARK) ;
                TN( tma2 , ""     ) ; tma2 = T("")+S2(0x2a,sc_MARK) ;
                TN( tm92 , ""     ) ; tm92 = T("")+S2(0x29,sc_MARK) ;
                TN( tm82 , ""     ) ; tm82 = T("")+S2(0x28,sc_MARK) ;
                TN( tm72 , ""     ) ; tm72 = T("")+S2(0x27,sc_MARK) ;
                TN( tm62 , ""     ) ; tm62 = T("")+S2(0x26,sc_MARK) ;
                TN( tm52 , ""     ) ; tm52 = T("")+S2(0x25,sc_MARK) ;
                TN( tm42 , ""     ) ; tm42 = T("")+S2(0x24,sc_MARK) ;
                TN( tm32 , ""     ) ; tm32 = T("")+S2(0x23,sc_MARK) ;
                TN( tm22 , ""     ) ; tm22 = T("")+S2(0x22,sc_MARK) ;
                TN( tm12 , ""     ) ; tm12 = T("")+S2(0x21,sc_MARK) ;
                TN( tm02 , ""     ) ; tm02 = T("")+S2(0x20,sc_MARK) ;
                TN( tmf1 , ""     ) ; tmf1 = T("")+S2(0x1f,sc_MARK) ;
                TN( tme1 , ""     ) ; tme1 = T("")+S2(0x1e,sc_MARK) ;
                TN( tmd1 , ""     ) ; tmd1 = T("")+S2(0x1d,sc_MARK) ;
                TN( tmc1 , ""     ) ; tmc1 = T("")+S2(0x1c,sc_MARK) ;
                TN( tmb1 , ""     ) ; tmb1 = T("")+S2(0x1b,sc_MARK) ;
                TN( tma1 , ""     ) ; tma1 = T("")+S2(0x1a,sc_MARK) ;
                TN( tm91 , ""     ) ; tm91 = T("")+S2(0x19,sc_MARK) ;
                TN( tm81 , ""     ) ; tm81 = T("")+S2(0x18,sc_MARK) ;
                TN( tm71 , ""     ) ; tm71 = T("")+S2(0x17,sc_MARK) ;
                TN( tm61 , ""     ) ; tm61 = T("")+S2(0x16,sc_MARK) ;
                TN( tm51 , ""     ) ; tm51 = T("")+S2(0x15,sc_MARK) ;
                TN( tm41 , ""     ) ; tm41 = T("")+S2(0x14,sc_MARK) ;
                TN( tm31 , ""     ) ; tm31 = T("")+S2(0x13,sc_MARK) ;
                TN( tm21 , ""     ) ; tm21 = T("")+S2(0x12,sc_MARK) ;
                TN( tm11 , ""     ) ; tm11 = T("")+S2(0x11,sc_MARK) ;
                TN( tm01 , ""     ) ; tm01 = T("")+sttMark01 ;
                TN( tbz  , "\\z"  ) ; // ZIP FILE NAME
                TN( tby  , "\\y"  ) ; // MISCELLANEOUS FILE NAME
                TN( tbx  , "\\x"  ) ; // LONE PARAGRAPH: FOR THIS BRANCH'S PAGE, REDUCE MAX LEVEL BY 1 SO THAT ONLY A SINGLE PARAGRAPH OF THESIS SENTENCES APPEARS
                TN( tbw  , "\\w"  ) ; // SOIL FILE NAME
                TN( tbv  , "\\v"  ) ; // VIDEO MOVIE FILE NAME
                TN( tbu  , ""     ) ; // RESERVED
                TN( tbt  , "\\t"  ) ; // URL SCHOLARLY TREATISE
                TN( tbs  , "\\s"  ) ; // SNAPSHOT PHOTO FILE NAME
                TN( tbr  , "\\r"  ) ; // FLAG: RAW: DO NOT CAPITALIZE AND DO NOT APPEND A PERIOD
                TN( tbq  , ""     ) ; // RESERVED
                TN( tbp  , "\\p"  ) ; // TEXT PDF FILE NAME
                TN( tbo  , "\\o"  ) ; // URL OTHER
                TN( tbn  , "\\n"  ) ; // NULL
                TN( tbm  , "\\m"  ) ; // MARK
                TN( tbl  , "\\l"  ) ; // URL LAW
                TN( tbk  , "\\k"  ) ; // SUPPRESS KID PAGE
                TN( tbj  , "\\j"  ) ; // FLAG: WITHIN A WEB PAGE, INCLUDE HTML PREFIX AND SUFFIX IF BRANCH IS RELATIVE LEVEL 3
                TN( tbi  , "\\i"  ) ; // ICON OR OTHER IMAGE FILE NAME (CONTENT EXPLICITLY SPECIFIED BY AUTHOR, IN CONTRAST TO THE ICONS THAT putFileIF USES AUTOMATICALLY E.G. TO INDICATE THE TYPE OF ANCHOR)
                TN( tbh  , "\\h"  ) ; // "HERE"
                TN( tbg  , "\\g"  ) ; // RESERVED (IF EVER NEED A "GO" MARK TO CAUSE INSERTION OF "#foo" TO GO TO THE ID MARK INSERTED IN OBEDIENCE TO \h
                TN( tbf  , "\\f"  ) ; // FILE NAME
                TN( tbe  , "\\e"  ) ; // TEXT EMAIL FILE NAME
                TN( tbd  , "\\d"  ) ; // SUPPRESS NEW PARAGRAPH
                TN( tbc  , "\\c"  ) ; // TEXT ASCII FILE NAME
                TN( tbb  , "\\\\" ) ;
                TN( tba  , "\\a"  ) ; // AUDIO FILE NAME
                TN( tb9  , "\\9"  ) ; // FLAG: INCLUDE IFF idEditionP == 9
                TN( tb8  , "\\8"  ) ; // FLAG: INCLUDE IFF idEditionP == 8
                TN( tb7  , "\\7"  ) ; // FLAG: INCLUDE IFF idEditionP == 7
                TN( tb6  , "\\6"  ) ; // FLAG: INCLUDE IFF idEditionP == 6
                TN( tb5  , "\\5"  ) ; // FLAG: INCLUDE IFF idEditionP == 5
                TN( tb4  , "\\4"  ) ; // FLAG: INCLUDE IFF idEditionP == 4
                TN( tb3  , "\\3"  ) ; // FLAG: INCLUDE IFF idEditionP == 3 
                TN( tb2  , "\\2"  ) ; // FLAG: INCLUDE IFF idEditionP == 2
                TN( tb1  , "\\1"  ) ; // FLAG: INCLUDE IFF idEditionP == 1
                TN( tb0  , "\\0"  ) ; // FLAG: INCLUDE IFF idEditionP == 0 (BRANCHES MARKED WITH THIS FLAG ARE COMMENTS SINCE idEditionP CANNOT BE 0)
                TN( tBackSlash , "\\"   ) ;
                TN( tBlank , " "   ) ;
                strokeS sttColon( ':' ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            {
            stackC  stCursor( tin0P , etherP , TAG( TAGiDnULL ), flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY , ifcSTACKtYPE_countT ) ;
        {
        strokeS sttMarkf2( 0x2f , sc_MARK ) ;
        strokeS sttMark01( 0x10 , sc_MARK ) ;
        jotC jotReferences( tin0P , "branchs.loadif.references" , flJOTc_WRITE | flJOTc_DELETE | flJOTc_PRIVATE ) ;
    {
    ZE( strokeS* , psttRootBranch ) ;
    ZE( boolT , bFail ) ;
    //etherP.traceF( tin0P , T("loadIF / +") ) ;

    _IO_

    // ----- CONSTRUCT A TREE OF branchS INSTANCES THAT CONTAINS INCOMPLETELY CONSTRUCTED REFERENCE BRANCHES

    }
        if( POOP ) return ;
        FV( flBRANCHslOADf , flagsP ) ;
        __Z( soulLinesP ) ;
        __NZ( csttTrimmedP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT branchS::loadIF( tin0S& tin0P , etherC& etherP , const boolT& bQuitP , jotC& jotP , countT& csttTrimmedP , soulC& soulLinesP , const flagsT flagsP , soulC* pSoulLinkP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

