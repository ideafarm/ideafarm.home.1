
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

}
    if( bDelete ) PUSE( tin0P , *(byteT**)&pbi ) ;
    }
        CONoUTrAW( "\r\n" ) ;
        CONoUTrAW( pbi ) ;
    {
    if( pbi )
    boolT bDelete = books.readF( tin0P , pbi , cbi , hRead ) ;
    countT cbi = 0x10 ;
    ZE( const byteT* , pbi ) ;

    handleC hRead( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;

    booksC books( tin0P , TAG( TAGiDnULL ) , "varying.size" , ifcIDsTATEsPACE_SINGLEaDAM( tin0P ) , flBOOKSc_USEdRIVEc ) ;
{

((tin9S&)tin0P).pEther   = pEtherSave ;
((tin9S&)tin0P).pPoolUse = pPoolSave ;

}
    if( pcpIdApt ) PUSE( tin0P , *(byteT**)&pcpIdApt ) ;
    books.writeF( tin0P , pcpIdApt , pbo , cbo ) ; ___( pcpIdApt ) ;
    ZE( countT* , pcpIdApt ) ;
    countT cbo = thirdC::c_strlenIF( tin0P , pbo ) ;
    byteT* pbo = "89abcdef" ;

    booksC books( tin0P , TAG( TAGiDnULL ) , "varying.size" , ifcIDsTATEsPACE_SINGLEaDAM( tin0P ) , flagsUse | flBOOKSc_WRITER , 8 , PCPnOpUSE ) ;
{

}
    if( pcpIdApt ) PUSE( tin0P , *(byteT**)&pcpIdApt ) ;
    books.writeF( tin0P , pcpIdApt , pbo , cbo ) ; ___( pcpIdApt ) ;
    ZE( countT* , pcpIdApt ) ;
    countT cbo = thirdC::c_strlenIF( tin0P , pbo ) ;
    byteT* pbo = "01234567" ;

    booksC books( tin0P , TAG( TAGiDnULL ) , "varying.size" , ifcIDsTATEsPACE_SINGLEaDAM( tin0P ) , flagsUse | flBOOKSc_WRITER | flBOOKSc_PURGEoNcT , 1 , PCPnOpUSE ) ;
{

etherC*      pEtherSave = ((tin9S&)tin0P).pEther ; ((tin9S&)tin0P).pEther = 0 ;
poolC*       pPoolSave = ((tin9S&)tin0P).pPoolUse ; ((tin9S&)tin0P).pPoolUse = 0 ;
const flagsT flagsUse = flBOOKSc_null | flBOOKSc_DOnOTuSEpUSE /*| flBOOKSc_NAPKINuSESsIMPLESTgRABc*/ ;

//U::BLAMMO ; //**** NOTE ****:  I WILL NOT EXECUTE UNLESS THE ((tin9S&)tin0P).monitor.idThread != 1 CHECK IS COMMENTED OUT IN func.*.booksC.booksC

TODO

#define PCPnOpUSE pcpIdBookNoPuse , sizeof pcpIdBookNoPuse / sizeof pcpIdBookNoPuse[ 0 ] , pcpOffIdBookNoPuse , sizeof pcpOffIdBookNoPuse / sizeof pcpOffIdBookNoPuse[ 0 ]

countT pcpOffIdBookNoPuse[ TUCK ] ;
countT pcpIdBookNoPuse[ TUCK ] ;

/*1*/WAKEsHOWtEXT( "example.other.func.2340003.booksC.booksC.ctdt.early.late" )/*1*/

/**/
*/
construction of static globals anywhere except in the globals module is nonconformant
i do not ct a static global because the sequence of construction of static globals in this module vs in the globals module is not defined by the language and might vary across development platforms
my code simulates this epoch by modifying tin0P
i demonstrate ct/dt and writing to a booksC instance early/late i.e. when PUSE does not exist
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

