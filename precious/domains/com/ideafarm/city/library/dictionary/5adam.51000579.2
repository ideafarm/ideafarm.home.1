
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return *this ;

    }
        else { ether.strMakeF( tinBaseP , LF , psttOldComment , datum.psttOldComment ) ; ___( psttOldComment ) ; }
        }
            }
                ether.delF( tinBaseP , psttd ) ;
                ether.strMakeF( tinBaseP , LF , psttOldComment , T(psttd)+T("\r\n")+T(datum.psttOldComment) ) ; ___( psttOldComment ) ;
                strokeS* psttd = psttOldComment ; psttOldComment = 0 ;
            {
            if( ether.strCompareF( tinBaseP , psttOldComment , datum.psttOldComment ) )
        {
        if( psttOldComment )
    {
    if( datum.psttOldComment )

    if( !idAdam ) idAdam = datum.idAdam ;
    if( !idHome ) idHome = datum.idHome ;
    if( !psttUrl ) { ether.strMakeF( tinBaseP , LF , psttUrl , datum.psttUrl ) ; ___( psttUrl ) ; }
    const datumPeanutC& datum = *(datumPeanutC*)&plateP ;
    TINSL
{
plateC& datumPeanutC::operator +=( plateC& plateP )

}
    return psttRpt ;

    ether.strMakeF( tinBaseP , LF , psttRpt , TF2(idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": ")+T(psttOldComment) ) ; ___( psttRpt ) ;

    ether.delF( tinBaseP , psttRpt ) ; //U::RECALC ONLY IF STALE
    TINSL
{
datumPeanutC::operator const strokeS*( voidT )

}
    ether.delF( tinBaseP , psttIdAdam ) ;
    ether.delF( tinBaseP , psttIdHome ) ;
    if( psttIdAdam ) idAdam = ether.strDigitsToSCountF( tinBaseP , psttIdAdam ) ;
    if( psttIdHome ) idHome = ether.strDigitsToSCountF( tinBaseP , psttIdHome ) ;

    }
        }
            ether.delF( tinBaseP , psttk ) ;

            }
                soulP >> *ppsttv ; ___( *ppsttv ) ;
                ether.delF( tinBaseP , *ppsttv ) ;
            {
            if( ppsttv )

            else if( !ether.strCompareF( tinBaseP , psttk , T("_idAdam") ) ) { ppsttv = &psttIdAdam ; }
            else if( !ether.strCompareF( tinBaseP , psttk , T("_idHome") ) ) { ppsttv = &psttIdHome ; }
            else if( !ether.strCompareF( tinBaseP , psttk , T("comment") ) ) { ppsttv = &psttOldComment ; }
                 if( !ether.strCompareF( tinBaseP , psttk , T("url"    ) ) ) { ppsttv = &psttUrl     ; }
            ZE( strokeS** , ppsttv ) ;
        {
        else
        if( !psttk ) { soulP >> psttk ; ___( psttk ) ; }
    {
    while( soulP )
    ZE( strokeS* , psttIdAdam ) ;
    ZE( strokeS* , psttIdHome ) ;
    ZE( strokeS* , psttk ) ;
{
idAdam( 0 )
idHome( 0 ) ,
psttOldComment( 0 ) ,
psttUrl( 0 ) ,
psttRpt( 0 ) ,
ether( etherP ) ,
datumPeanutC::datumPeanutC( tinBaseS& tinBaseP , etherC& etherP , soulC& soulP ) :

}
{
idAdam( 0 )
idHome( 0 ) ,
psttOldComment( 0 ) ,
psttUrl( 0 ) ,
psttRpt( 0 ) ,
ether( *((tinNormalS&)tinBaseP).pEther ) ,
datumPeanutC::datumPeanutC( tinBaseS& tinBaseP ) :

}
    return scSgn ;

    }
        ;
                : 0
                ? - 1
            : datum.psttOldComment
                : 1
                ? ether.strCompareF( tinBaseP , psttOldComment , datum.psttOldComment )
            ? datum.psttOldComment
        scSgn = psttOldComment
    {
    if( !scSgn && !bUrlOnly )

    }
        ;
                : 0
                ? - 1
            : datum.psttUrl
                : 1
                ? ether.strCompareF( tinBaseP , psttUrl , datum.psttUrl )
            ? datum.psttUrl
        scSgn = psttUrl
    {
    if( !scSgn )

    ;
            : 0
            ? - 1
        : datum.idAdam
            : 1
            ? idAdam - datum.idAdam
        ? datum.idAdam
    sCountT scSgn = idAdam

    TINSL
    datumPeanutC& datum = *(datumPeanutC*)&plateP ;
{
sCountT datumPeanutC::operator -( const plateC& plateP ) const

}
    return *this ;

    idAdam = datum.idAdam ;
    idHome = datum.idHome ;

    if( datum.psttOldComment ) { ether.strMakeF( tinBaseP , LF , psttOldComment , datum.psttOldComment ) ; ___( psttOldComment ) ; }
    ether.delF( tinBaseP , psttOldComment ) ;

    if( datum.psttUrl ) { ether.strMakeF( tinBaseP , LF , psttUrl , datum.psttUrl ) ; ___( psttUrl ) ; }
    ether.delF( tinBaseP , psttUrl ) ;

    if( datum.psttRpt ) { ether.strMakeF( tinBaseP , LF , psttRpt , datum.psttRpt ) ; ___( psttRpt ) ; }
    ether.delF( tinBaseP , psttRpt ) ;

    datumPeanutC& datum = *(datumPeanutC*)&plateP ;
    TINSL
{
plateC& datumPeanutC::operator =( plateC& plateP )

}
    ether.delF( tinBaseP , psttOldComment ) ;
    ether.delF( tinBaseP , psttUrl ) ;
    ether.delF( tinBaseP , psttRpt ) ;
    TINSL
{
datumPeanutC::~datumPeanutC( voidT )

}
    return *this ;
{
plateC& datumPeanutC::operator >>( soulC& sP )

}
    return new( 0 , tinBaseP , idLineP , idiFileP ) datumPeanutC( tinBaseP ) ;
{
datumPeanutC* datumPeanutC::newF( tinBaseS& tinBaseP , const countT idLineP , const countT idiFileP )

NEWdELcLASS( 1 , datumPeanutC )

}
    bUrlOnly = bUrlOnlyP ;
{
voidT datumPeanutC::setModeF( const boolT bUrlOnlyP )

boolT datumPeanutC::bUrlOnly ;

#include postADAMhEADER

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

