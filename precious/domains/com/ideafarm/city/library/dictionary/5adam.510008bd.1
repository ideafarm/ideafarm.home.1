
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK >> 2 ) ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

#endif
}
//    bFail = WSACleanup() ;

    if( bFail ) ;

    bFail = bind( osh , (sockaddr*)&info2 , sizeof info2 ) ;

    info2.sin6_port   = (short)htons( 0x00000035 ) ;
    info2.sin6_family = AF_INET6 ;
    static sockaddr_in6 info2 ;

    unsigned osh = socket( PF_INET6 , SOCK_DGRAM , 0 ) ;

    }
//        bFail = WSAStartup( 0x0202 , &info1 ) ;
//        WSADATA info1 ;
    {

    int bFail = 0 ;
{
#if defined( NEVERdEFINED )

TODO

DONE( tmWorkF )
}
    etThread.traceF( tin0P , T("Normal access restored.") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;

    sgnDone_tmWorkDnsF.waitF( tin0P ) ;
    }
        bQuitDns = 1 ;

#endif
        }

        {
        if( bFirefox )

        etThread.delF( tin0P , psttUnwanted ) ;
        etThread.delF( tin0P , psttWanted ) ;
        boolT bFirefox = !etThread.strCompareF( tin0P , psttWanted , tY ) ;
        etThread.strConvertToLowerCaseF( tin0P , psttWanted ) ;
        etThread.strHearF( tin0P , psttWanted , psttUnwanted , 1 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;
        etThread.traceF( tin0P , T("Is Firefox your default browser on this computer? ('y' or 'n'):    ") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;

        etThread.osHttpViewF( tin0P , T("about:config?dnsCache") , 0 ) ;

        etThread.delF( tin0P , psttBrowser ) ;
        etThread.traceF( tin0P , psttBrowser ) ;
        etThread.osHttpViewerF( tin0P , psttBrowser ) ; ___( psttBrowser ) ;
        ZE( strokeS* , psttBrowser ) ;
#if defined( NEVERdEFINED )



        }
            ++ s ; etThread.osSleepF( tin0P , TUCK >> 6 ) ;

            }
                //etThread.traceF( tin0P , T("[time,ipv6]:    ")+TT(timeN1,timeN2)+tb4+T(nnNow) , flTRACE_NOpREFIX ) ;
                nicNameC nnNow = sub.nnF( tin0P , minute ) ;

                etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT  , timeN1 ) ;

                minuteLath = minute ;
            {
            if( minuteLath != minute )                          // A:ASSUME: THE LIFETIME OF EACH ipv6 ADDRESS IS GREATER THAN RE MINUTES, SO THAT THE ipv6 OF THE LATH MINUTE WILL CONTINUE TO BE VALID WELL AFTER I NO LONGER OBTAIN ITS VALUE
            countT minute = ( timeN1 >> 0x14 ) - 1 ;            // USE THE PRIOR MINUTE

            etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT  , timeN1 ) ;
        {
        while( !bHeardEnterKey )
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        ZE( countT , minuteLath ) ;

        ideaNetSubscriptionC sub( tin0P , etThread , 1 , 1 , tSecret ) ; ___( pSubP ) ;

        TN( tSecret , "308f" "c905" "2f7e" "f879" "38b0" "e553" "4095" "944f" "1c0b" "88e5" ) ;         //CODED THIS WAY TO AVOID TRIGGERING GITGUARDIAN ; THIS IS A SECRET BUT ONLY FOR TESTING ; NO HARM CAN COME FROM DISCLOSURE
        TN( tb4 , "    " ) ;

//        ideaNetC in( tin0P , etThread ) ;

        etThread.traceF( tin0P , T("Press the Enter key, and I will restore your access to the public web and disable your access to IdeaNet (tm):    ") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        etThread.osThreadF( TaRG2cBsTACK( tmHearF , TICK >> 2 ) , (countT)&bHeardEnterKey ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
        ZE( boolT , bHeardEnterKey ) ;
    {

    etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkDnsF , sgnDone_tmWorkDnsF , TICK >> 2 ) , (countT)&bQuitDns ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
    signC sgnDone_tmWorkDnsF( tin0P , TAG( TAGiDnULL ) ) ;
    ZE( boolT , bQuitDns ) ;

    etThread.delF( tin0P , psttUnwanted ) ;
    etThread.delF( tin0P , psttWanted ) ;
    etThread.strHearF( tin0P , psttWanted , psttUnwanted , 0 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;

    ) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

        "\r\nPress the Enter key, and I will disable your access to the public web and enable  your access to IdeaNet (tm):    "
        "\r\n"
        "\r\naddress changes every few seconds.)"
        "\r\nthat will serve that page to your computer so that your browser can display it.  (That numeric"
        "\r\nsee it.  Second, only I know how to obtain the numeric address of the computer, \"1.ideafarm.com\","
        "\r\nreasons.  First, your password must never be put out onto the public Internet, where someone might"
        "\r\nfor this, by redirecting all domain name queries on your computer to myself.  This is done for two"
        "\r\nSuch a page can be viewed using your normal Web browser, but only after I have set up your computer"
        "\r\n"
        "\r\n    http://someunguessablepassword.password.1.ideafarm.com/somepage.html"
        "\r\n"
        "\r\nresource (\"page\") on the Web, like this:"
        "\r\nEach subscriber is issued a password, which is specified at the beginning of the domain name for a"
        "\r\nIdeaFarm (tm) IdeaNet (tm) is a subscribers-only World Wide Web system within the public Internet system."
        "\r\n"
        "\r\nobtain the numeric address for the computer that serves \"somedomain.com\"."
        "\r\nWeb browser can display a page with a name such as \"http://somedomain.com/somepage.html\", it must"
        "\r\nEach computer on the public Internet has a numeric address, which is a single large number. Before your"

    etThread.traceF( tin0P , T(

    ZE( strokeS* , psttUnwanted ) ;
    ZE( strokeS* , psttWanted ) ;

    TN( tY , "y" ) ;

        etThread.delF( tin0P , psttBrowser ) ;
        //etThread.traceF( tin0P , psttBrowser ) ;
        etThread.osHttpViewerF( tin0P , psttBrowser ) ; ___( psttBrowser ) ;
        ZE( strokeS* , psttBrowser ) ;
{
if( pTaskP )
TASK( tmWorkF )

DONE( tmHearF )
}
    bHeardEnterKeyP = 1 ;

    etThread.delF( tin0P , psttUnwanted ) ;
    etThread.delF( tin0P , psttWanted ) ;
    etThread.strHearF( tin0P , psttWanted , psttUnwanted , 0 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;
    ZE( strokeS* , psttUnwanted ) ;
    ZE( strokeS* , psttWanted ) ;

    boolT& bHeardEnterKeyP = *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmHearF )

DONE( tmWorkDnsF )
}
    }
        }
            DELzOMBIE( psoDoomed ) ;
            socketC* psoDoomed = (socketC*)pbSocket ;
        {

        }
            ++ s ; etThread.osSleepF( tin0P , TOCK >> 3 ) ;
        {
        while( cWorkers )
        gv.bQuit = 1 ;

        }
            gv.cirJob << &job ;
            jobDnsS job( pbq , cbq , idp , nnPeer ) ;

            }
                }
                    }
                        break ;
                        ++ s ; etThread.osSleepF( tin0P , TOCK >> 2 ) ;
                        etRock.traceF( tin0P , postRc ? T(postRc) : T("network error [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                    {
                    if( rc != ifcIDiMPOTENCEbASEeRRORcODE_NETWORKbUSY )

                    POOPRqUIET
                    countT rc = POOP ;
                {
                if( POOP )
                sockd.readF( tin0P , pbq , cbq , idp , nnPeer ) ; ___( pbq ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK
            nicNameC nnPeer ;
            ZE( countT , idp ) ;
            ZE( countT , cbq ) ;
            ZE( byteT* , pbq ) ;
            _IO_
        {
        while( !POOP && !bQuitDnsP )

        }
            etThread.osThreadF( TaRG2cBsTACK( tmWorkerDnsF , CBsTACKmIN << 2 ) , (countT)&bFail , (countT)&cWorkers , (countT)&sockd , (countT)&gv ) ;
            inc02AM( cWorkers ) ;
        {
        while( cDo -- )
        if( cDo > 1 ) cDo = 1 ;
        countT cDo = thirdC::osProcessorsIF( tin0P ) ;
        gVarDnsS gv( tin0P , etThread ) ;
        ZE( boolT  , bFail    ) ;
        ZE( countT , cWorkers ) ;

        }
            }
                continue ;
                ++ s ; etThread.osSleepF( tin0P , TOCK >> 2 ) ;
                POOPR
            {
            if( POOP )
            sockd.bindF( tin0P , ifcPORToLD2_DNS ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK

        }
            }
                continue ;
                ++ s ; etThread.osSleepF( tin0P , TOCK >> 2 ) ;
                POOPR
            {
            if( POOP )
            new( 0 , tin0P , pbSocket , sizeof pbSocket ) socketC( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK

        socketC& sockd = *(socketC*)pbSocket ;
        byteT pbSocket[ sizeof( socketC ) ] ;

        _IO_
    {
    while( !POOP && !bQuitDnsP )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    boolT& bQuitDnsP = *(boolT*)pTaskP->c1 ;

    _IO_
{
if( pTaskP && pTaskP->c1 )
TASK( tmWorkDnsF )

DONE( tmWorkerDnsF )
}
    dec02AM( cWorkersP ) ;

    }
        }
            IFsCRATCHoK{}

            etThread.delF( tin0P , job.pbq ) ;
            }
                }
                    etThread.delF( tin0P , pbr ) ;
                    }
                        }
                            }
                                POOPR
                            {
                            else
                            if( !POOP ) /*;*/etRock.traceF( tin0P , T("reply written aok") ) ;
                            sockdP.writeF( tin0P , job.idp , job.nnPeer , pbr , cbr ) ;
                            _IO_
                        {
                        else
                        }
                            POOPR
                        {
                        if( POOP )
                        ((tin1S&)tin0P).pEtScratch->dnsReplyF( tin0P , pbr , cbr , job.pbq , stsReplies , 1 , idError ) ;
                        SCOOPS
                        _IO_
                    {
                    IFsCRATCHoK
                    ZE( countT , cbr ) ;
                    ZE( byteT* , pbr ) ;

                    const osTextT* postError = processGlobal4S::_processGlobal4I_IF().mapIdErrorDns( idError ) ;
                {
                if( idError == ifcIDeRRORdNS_AOK )      // STFU IF I DON'T KNOW THE NAME, SO THAT PEER WILL TRY SECONDARY DNS SERVERS

                }
                    }
                        }
                            if( !stsReplies ) idError = ifcIDeRRORdNS_NAMEnOTdEFINED ;

                            }
                                DEL( ps ) ;
                                }
                                    }
                                        }
                                            break ;
                                        
                                            }
                                                etRock.traceF( tin0P , T("dns reply [nnOut,nnPeer]:    ")+tb4+T(nnOut)+tb4+T(job.nnPeer) ) ;
                                                rec_AAAA_F( tin0P , etThread , stsReplies , ifcIDsECTIONdNSrEPLY_ANSWER , tDomainGross , nnOut , job.nnPeer ) ;
                                            {
                                            if( ~nnOut )
                                        
                                            if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainGross , T("1.ideanet.ideafarm.com") ) ) nnOut = nnBook1 ;
                                        
                                            nicNameC nnOut ;
                                            etRock.traceF( tin0P , T("dns AAAA [query]:    ")+tDomainGross ) ;
                                            _IO_
                                        {
                                        case ifcIDtYPEdNSqUERY_AAAA :
                                    {
                                    if( idClass == 1 ) switch( idType )

                                    *ps >> idClass ;
                                    ZE( countT , idClass ) ;

                                    *ps >> idType ;
                                    ZE( countT , idType ) ;

                                    etThread.delF( tin0P , psttw ) ;
                                    TN( tDomainGross , psttw ) ;
                                    if( psttw ) ((tin1S&)tin0P).pEtScratch->strConvertToLowerCaseF( tin0P , psttw ) ; ___( psttw ) ;
                                    *ps >> psttw ;
                                    ZE( strokeS* , psttw ) ;
                                    _IO_
                                {
                                if( ps )
                                stsQueries >> ps ;
                                ZE( soulC* , ps ) ;
                                _IO_
                            {
                            while( stsQueries )
                            _IO_
                        {
                        else
                        }
                            idError = ifcIDeRRORdNS_CANNOTpARSEqUERY ;
                            POOPR
                        {
                        if( rc )
                        etThread.delF( tin0P , pbNU ) ;
                        countT rc = POOP ;
                        ((tin1S&)tin0P).pEtScratch->dnsParseF( tin0P , pbNU , countTC() , stsQueries , stsRepliesNU , job.pbq , job.cbq ) ;
                        SCOOPS
                        _IO_
                    {
                    IFsCRATCHoK
                    ZE( byteT* , pbNU ) ;

                    stsRepliesNU.purgeF( tin0P ) ;
                    stsQueries.purgeF( tin0P ) ;
                    _IO_
                {

                ++ gvP.idClient ;

                countT idError = ifcIDeRRORdNS_AOK ;
                _IO_
            {
            if( job.pbq && job.cbq )
            _IO_
        {
        if( !gvP.bQuit )

        gvP.cirJob >> &job ;
        jobDnsS job ;
    {
    while( !gvP.bQuit )

    nicNameC nnBook1( 0x2 , 0x0 , 0xac004cfb , 0x200119f0 ) ;   // 2001:19f0:ac00:4cfb::2

    stackC stsQueries(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stsReplies(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stsRepliesNU( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    etherC& etRock = etherC::etRockIF( tin0P ) ;
    TN( tb4 , "    " ) ;

    gVarDnsS&    gvP       = *(gVarDnsS*)pTaskP->c4  ;
    socketC&     sockdP    =  *(socketC*)pTaskP->c3  ;
    countT&      cWorkersP =   *(countT*)pTaskP->c2  ;
    boolT&       bFailP    =    *(boolT*)pTaskP->c1  ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmWorkerDnsF )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_AAAA ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_AAAA_F [nnPeer,nn,name]:    peer: ")+T(nnPeerP)+T("    directed to: ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_AAAA_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP , const nicNameC& nnPeerP )

NEWdELcLASS( 1 , jobDnsS ) ;

;
}
    }
    {
    cirJob(  tin0P , etherP , bQuit , flCIRCLEc_null , sizeof jobDnsS , TUCK << 0 )
    idClient( 0 ) ,
    bQuit( 0 ) ,
    inline gVarDnsS( tin0S& tin0P , etherC& etherP ) :

    circleC cirJob                ;
    countT  idClient              ;
    boolT   bQuit                 ;
{
struct gVarDnsS

;
}
    {}
    idp( 0 )
    cbq( 0 ) ,
    pbq( 0 ) ,
    inline jobDnsS( voidT ) :

    {}
    nnPeer( nnPeerP )
    idp( idpP ) ,
    cbq( cbqP ) ,
    pbq( pbqP ) ,
    inline jobDnsS( byteT* pbqP , countT cbqP , countT idpP , nicNameC& nnPeerP ) :
    NEWdELcLASSpROTOS

    nicNameC nnPeer ;
    countT   idp    ;
    countT   cbq    ;
    byteT*   pbq    ;
{
struct jobDnsS

//OBSOLETES: 8bc_

/*1*/WAKEhIDE( "ifcIDaDAM_IDEAnET" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
