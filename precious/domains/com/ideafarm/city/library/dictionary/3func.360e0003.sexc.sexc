
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        if( !btrAM( pReg->pbSexGrabbedBits , offSexBit ) ) { BLAMMO ; }

        if( !pReg ) { BLAMMO ; }
        }
            }
                break ;
                pReg = pRegs + offr ;
            {
            if( !thirdC::c_strcmpIF( tinP , pRegs[ offr ].postPoolName , postPoolName ) )
        {
        for( countT offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )
        ZE( poolRegistrationS* , pReg ) ;

        const osTextT* postPoolName = pPoolContainsMe->postNameF( tinP ) ;
        poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;
        homeS& home = homeS::homeIF() ;
    {
    if( bGrabbed )

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    // UNGRAB (CLEAR) THE "CONSTRUCTING" BIT FOR MY SPECIFICATIONS [expCbDropP,expSlotsP] TO SERIALIZE CONSTRUCTION
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    //}
    //    OStEXTAK( ostoSay , "\"" ) ;
    //    OStEXTA(  ostoSay , postNameP ) ;
    //    OStEXTAK( ostoSay , "\r\n sexC - [postName]: \"" ) ;
    //    OStEXT(   ostoSay , TUCK << 2 ) ;
    //{
    //if( tinP.pc Utility[ 0 ] )

    if( !POOP ) flagsState |= flSEXcsTATE_CONSTRUCTEDaOK ;

    }
        TELLsYSc3LIFI( idTypeSay , (byteT*)&info , sizeof info , idLineCtP , idiFileCtP )
        info.idiFileCt  = idiFileCtP ;
        info.idLineCt   = idLineCtP ;
        info.pSex       = this ;
        thirdC::c_strcpyIF( tinP , info.postName , pzMetaHead->postName ) ;
        info.expSlots   = pzMetaHead->expSlots  ;
        info.expCbDrop  = pzMetaHead->expCbDrop ;
        info.osPid      = tinP.osPid ;
        tellInfoSysSexS info ;
        countT idTypeSay = ifcIDtYPEtELLsYS_SEXcT ;
    {
    if( !POOP )

    }
                                         pSexLifoConstructing = 0 ;
            tinP.pSexLifoConstructing  = pSexLifoConstructing     ;
        if( tinP.pSexLifoConstructing != this                     ) { BLAMMO ; }

    {
    if( pPoolContainsMe )

    tinP.tlsDelF( LF , countTC() ) ;
    tinP.tlsDelF( LF , countTC() ) ;
    tinP.tlsDelF( LF , countTC() ) ;
    tinP.tlsDelF( LF , countTC() ) ;
    //CS:CODEsYNC: 360e0003 360e0003

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    // CLEAN UP
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        }
            }
                }
                    else                      { LOGrAW( "!exception: sexC::sexC/i could not register myself with the leak logger for some reason other than the registry being full\r\n" ) ; }
                    else if( !POOP )          flagsState |= flSEXcsTATE_REGISTEREDwITHlEAKlOGGERaOK ;
                    if( offe == CsEXeNTRIES ) { LOGrAW( "!exception: sexC::sexC/the leak logger registry is full\r\n" ) ; } //U: 20140605@1631: CONJ: THIS CAN HAPPEN IF EXIST MULTIPLE poolC INSTANCES OR IF EXIST MULTIPLE ADAMS (SEE osThreadAdamF)

                    }
                        grabot.ungrabF( tinP ) ;

                        }
                            }
                                }
                                    break ;
                                    thirdC::c_strcpyIF( tinP , pe[ offe ].postName , pzMetaHead->postName ) ;
                                    pe[ offe ].cRef ++ ;
                                {
                                if( !pe[ offe ].cRef )
                            {
                            for( offe = 0 ; offe < CsEXeNTRIES ; offe ++ )
                        {
                        if( offe == CsEXeNTRIES )
                
                        }
                            }
                                break ;
                                pe[ offe ].cRef ++ ;
                            {
                            if( !thirdC::c_strcmpIF( tinP , pe[ offe ].postName , pzMetaHead->postName ) )
                        {
                        for( offe = 0 ; offe < CsEXeNTRIES ; offe ++ )

                        grabot.grabF( tinP , TAG( TAGiDnULL ) ) ;
                        grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
                    {
                    ZE( countT , offe ) ;
            
                    sexGlobalEntryS* pe = (sexGlobalEntryS*)( pbnRegistry + sizeof( grabotC ) ) ;
                    grabotC& grabot = *(grabotC*)pbnRegistry ;
                {
                if( pbnRegistry )
                byteT* pbnRegistry = processGlobal8I._sexC_napGlobalRegistry ;
            {
            if( !thirdC::c_strstrIF( tinP , pzMetaHead->postName , postPOOLlEAKlOGGER ) )
            POOPIE
        {

        //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        // IF I AM NOT PART OF THE poolC USED BY THE LEAKlOGGER ADAM THEN REGISTER MYSELF WITH LEAK LOGGER
        //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

        //}
        //            //    etherC::etRockIF( tinP ).traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
        //
        //    OStEXTAK( ostoSay , "\" " ) ;
        //    OStEXTA(  ostoSay , postNameP ) ;
        //    OStEXTAK( ostoSay , " \"" ) ;
        //    OStEXTCF( ostoSay , pbDataEnd , ' ' ) ;
        //    OStEXTAK( ostoSay , " " ) ;
        //    OStEXTCF( ostoSay , pbData , ' ' ) ;
        //    OStEXTA(  ostoSay , F(flagsState) & flSEXcsTATE_USINGnAPfORmETA ? " NAPKIN " : " pool   " ) ;
        //    OStEXTA(  ostoSay , F(flagsState) & flSEXcsTATE_USINGnAPfORdATA ? " NAPKIN " : " pool   " ) ;
        //    OStEXTC(  ostoSay , expSlotsP , ' ' ) ;
        //    OStEXTAK( ostoSay , " " ) ;
        //    OStEXTC(  ostoSay , expCbDropP , ' ' ) ;
        //    OStEXTAK( ostoSay , " " ) ;
        //    OStEXTC(  ostoSay , bNested , ' ' ) ;
        //    OStEXTAK( ostoSay , " " ) ;
        //    OStEXTC(  ostoSay , tinP.pag1->idAdam , ' ' ) ;
        //    OStEXTAK( ostoSay , "      sexC [idAdam,bNested,expCbDrop,expSlots,n/p,pbData,pbDataEnd,postName]: " ) ;
        //    OStEXT(   ostoSay , TUCK << 2 ) ;
        //{

        //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        // DEBUGGING CHATTER
        //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

        }
            ((napkinC*)pb_napData)->formattingIsDoneF( tinP ) ;

            formatDataBlobF( tinP ) ; //NO ACTION IS NEEDED HERE TO PRESERVE STATE WHEN STATE FILE IS USED, SINCE THE FORMATTING INFORMATION IS ONLY USED TO DETECT MEMORY CORRUPTION SO NEED NOT BE SAVED AS STATE     U::20240815@1555: HUH?

            //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            // FORMAT pbData: ORIGINALLY, pbData WAS NOT FORMATTED.  FORMATTING WAS ADDED (20210128@1831) ONLY SO THAT MEMORY CORRUPTION CAN BE DETECTED.  THE FORMATTING INFORMATION IS NOT NEEDED FOR ANY OTHER PURPOSE.
            //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        {
        if( bFormatDataBlob )
    {
    if( !POOP )

    }
        }
            }
                __Z( pbMeta ) ;
                }
                    }
                        }
                            }
                                ((napkinC*)pb_napMeta)->formattingIsDoneF( tinP ) ;

                                }
                                    if( F(flagsState) & flSEXcsTATE_USINGnAPfORmETA && !( F(((napkinC*)pb_napMeta)->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) ) ((napkinC*)pb_napMeta)->formattingIsDoneF( tinP ) ;

                                    }
                                        }
                                            countT foo = 2 ;
                                        {
                                        if( idIn == 2 )
                                        countT idIn = 1 + incv02AM( idInLath ) ;
                                        static countT idInLath ;
                                    {
                                    if( expCbDropP == 0x9 && expSlotsP == 8 )
                            
                                    }
                                        __( expSlotsP  - pzMetaHead->expSlots  ) ;
                                        __( expCbDropP - pzMetaHead->expCbDrop ) ;
                                    {
                                    else
                                    }
                                        if( pzMetaNote ) thirdC::c_memsetIF( tinP , (byteT*)pzMetaNote , sizeof( dropNoteS ) << pzMetaHead->expSlots ) ;
                            
                                        }
                                            for( countT offo = 0 ; offo < cSlots ; offo ++ ) pzMetaNote[ offo ].idDelLath = pzMetaNote[ offo ].idNewLath = 0 ;
                                            countT cSlots = 1 << pzMetaHead->expSlots ;
                                        {
                                        if( pzMetaNote )
                            
                                        }
                                            while( cToDo -- ) btsLathAM( pbzMetaBitsOwned , 1 << pzMetaHead->expSlots ) ;
                                            cToDo = pzMetaHead->cSlotsAvoidHi ;                                         // THE HIGH SLOTS ARE UNUSEABLE TO ENSURE HEADROOM OF sizeof( countT ) - 1 SO THAT HIGHEST BYTE CAN BE REFERENCED BY DWORD INSTRUCTION (E.G. movsd)
                            
                                            while( cToDo -- ) btsWothAM( pbzMetaBitsOwned , 1 << pzMetaHead->expSlots ) ;
                                            countT cToDo = pzMetaHead->cSlotsAvoidLo ;                                  // THE LOW SLOTS ARE UNUSEABLE BECAUSE THEY OVERLAY napkinHeaderS FOR (*(napkinC*)pb_napData)
                                                                                                                    // FOR SMALL SLOT SIZES (LESS THAN ALLOCATION GRAIN SIZE):
                                        {
                                        if( F(flagsState) & flSEXcsTATE_USINGnAPfORdATA )

                                        // THIS DOES NOT HAVE TO BE DONE IF pbData WAS ALLOCATED USING THE POOL BECAUSE HEADROOM WAS CREATED WHEN THAT sexC WAS CONSTRUCTED
                                        // IF DATA IS IN NAPKIN THEN MARK THE HIGH SLOTS AS UNUSEABLE SO THAT THERE IS ENOUGH HEADROOM FOR THE HIGHEST BYTE TO BE ACCESSED USING A DWORD INSTRUCTION
                                        // 
                                        // THIS DOES NOT HAVE TO BE DONE IF pbData WAS ALLOCATED USING THE POOL BECAUSE THERE IS NO OVERLAYED napkinC HEADER TO PROTECT
                                        // IF DATA IS IN NAPKIN THEN MARK THE LOW SLOTS AS UNUSEABLE SO THAT THE DATA NAPKIN HEADER, WHICH THEY OVERLAY FOR SMALL SLOT SIZES, WON'T BE TRASHED

                                        thirdC::c_memsetIF( tinP , pbzMetaBitsOwned , cbaBitsOwned ) ;
                                    {
                                    if( bFormat )
                            
                                    if( F(flagsCt) & fliSEXc_NOTES ) pzMetaNote = (dropNoteS*)( pbzMetaBitsOwned + cbaBitsOwned ) ;
                            
                                    cbaBitsOwned += CBtOaLIGN02( pbzMetaBitsOwned + cbaBitsOwned ) ;
                                    countT cbaBitsOwned = 1 + ( 1 << expSlotsP ) / SB ;
                            
                                    pbzMetaBitsOwned = (byteT*)( pzMetaHead + 1 ) ;
                            
                                    __( flagsCt - pzMetaHead->flagsCtCopy ) ;

                                    inc02AM( pzMetaHead->cRef ) ;
                                    }
                                        //CONoUTrAWd( "[expCbDrop,expSlots,bSmallSlots,USINGnAPfORdATA,cSlotsAvoidLo,cSlotsAvoidHi]: " , expCbDropP , " " , expSlotsP , " " , bSmallSlots , " " , !!( F(flagsState) & flSEXcsTATE_USINGnAPfORdATA ) , " " , pzMetaHead->cSlotsAvoidLo , " " , pzMetaHead->cSlotsAvoidHi , "\r\n" ) ; //U:: TO FIND A BUG

                                        }
                                            *(countT*)&pzMetaHead->cSlotsAvoidHi = 1 + ( sizeof( countT        ) - 2 ) / cbSlot ; // HEADROOM: sizeof( countT ) - 1 (ALWAYS 1 NOW THAT DROPhEADER IS USED; THIS LINE IS CODED GENERALLY TO WORK EVEN IF !( CBsEXdROPsEPARATOR + CBsEXdROPhEADER ))
                                            *(countT*)&pzMetaHead->cSlotsAvoidLo = 1 + ( sizeof( napkinHeaderS ) - 1 ) / cbSlot ; // SOME PART OF NAPKIN HEADER IS UNDER THIS MANY SLOTS
                                            countT cbSlot = ( CBsEXdROPsEPARATOR + CBsEXdROPhEADER ) + ( 1 << expCbDropP ) ;
                                        {
                                        if( F(flagsState) & flSEXcsTATE_USINGnAPfORdATA && bSmallSlots )

                                        //CONoUTrAW9( "sexC formatting meta [USINGnAPfORdATA,bSmallSlots,expCbDropP,expSlotsP,]: " , !!( F(flagsState) & flSEXcsTATE_USINGnAPfORdATA ) , " " , bSmallSlots , " " , expCbDropP , " " , expSlotsP , "\r\n" ) ;

                                        pzMetaHead = new( 0 , tinP , pbMeta , sizeof( sexHeadS ) ) sexHeadS( tinP , expCbDropP , expSlotsP , postNameP , flagsCt ) ;
                                    {
                                    else
                                    if( !bFormat ) pzMetaHead = (sexHeadS*)pbMeta ;
                                
                                    ;
                                                    : 1                                                                                 // ELSE FORMAT
                                                    ? 0                                                                                 // THEN DO NOT FORMAT
                                                : ((fileC*)pbFileMeta)->idOpenResultF( tinP  ) == ifcOPENrESULT_EXISTED                 // ELSE DID MY BACKING FILE ALREADY EXIST?
                                                ? 1                                                                                     // THEN FORMAT
                                            : !( F(flagsCt) & fliSEXc_MAPPEDtOdISK )                                                    // ELSE AM I STATELESS (NOT BACKED BY A DISK FILE)?
                                            ? 0                                                                                         // THEN DO NOT FORMAT
                                        : F(((napkinC*)pb_napMeta)->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED        // ELSE DID NAPKIN ALREADY EXIST?
                                        ? 1                                                                                             // THEN FORMAT
                                    const boolT bFormat = !( F(flagsState) & flSEXcsTATE_USINGnAPfORmETA )                              // WAS LIST ALLOCATED FROM POOL?
                                {
                                if( !POOP )

                                //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                // FORMAT pbMeta
                                //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                            {
                            if( !( F(((napkinC*)pb_napMeta)->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
                        {
                        if( !POOP )

                        __Z( pbMeta ) ;
                        pbMeta  = *(napkinC*)pb_napMeta ;
                    {
                    if( !POOP )

                    ) ;
                        F(flagsCt) & ( fliSEXc_nFeO | fliSEXc_READoNLY ) ? ifcOPENsHAREDmEMORYhOW_nFeO : ifcOPENsHAREDmEMORYhOW_nCeO , /*tinP.pag1->idMemorySpace == ifcIDmEMORYsPACE_APPLICATION ? flNAPKINc_LOCK :*/ flNAPKINc_null , 1 , idMemorySpaceP
                        cbaMeta ,
                        ) ,
                                : (const handleC*)*(fileC*)pbFileMeta
                                ? 0
                            !idStateSpaceP
                        (
                        ) ,
                            )
                                tinP.pbF( 4 )
                                ) ,
                                    "."
                                    ) ,
                                        tinP.pbF( 3 )
                                        ) ,
                                            "."
                                            ) ,
                                                tinP.pbF( 2 )
                                                ) ,
                                                    "."
                                                    ) ,
                                                        postNameP
                                                        ) ,
                                                            tinP , tinP.pbF() , "sexC/meta/"
                                                        (
                                                        thirdC::c_strcpyIF
                                                        tinP ,
                                                    (
                                                    thirdC::c_strcatIF
                                                    tinP ,
                                                (
                                                thirdC::c_strcatIF
                                                tinP ,
                                            (
                                            thirdC::c_strcatIF
                                            tinP ,
                                        (
                                        thirdC::c_strcatIF
                                        tinP ,
                                    (
                                    thirdC::c_strcatIF
                                    tinP ,
                                (
                                thirdC::c_strcatIF
                                tinP ,
                            (
                            thirdC::c_strcatIF
                        (
                        tinP , idLineNewP , idiFileNewP , pbBitsCtP ,
                    (
                    new( 0 , tinP , pb_napMeta , sizeof pb_napMeta ) napkinC
                    flagsState |= flSEXcsTATE_USINGnAPfORmETA ;
                {
                if( !pbMeta )

                //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                // IF COULD NOT, THEN ALLOCATE pbMeta USING A napkinC TO OBTAIN A MEMORY ALLOCATION FROM THE BASE O.S.
                //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            {
            else
            }
                //U::DELETE THE BLOB THAT I JUST ALLOCATED
            {
            if( POOP )

            }
                THREADmODE3rESTORE
                }
                    }
                        }
                            }
                                DELlIST( fieldEditParamOutC , pOut ) ;
                                puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                            {

                            }
                                }
                                    pbMetaEnd = pbMeta + cbaMeta ;
                                    pbMeta    = (byteT*)(const osTextT*)pOut->vspBlob ;
                                {
                                if( !POOP )
                                __NZ( pOut->pNext ) ;
                            {
                            if( !POOP )
                            __Z( pOut ) ;
                
                            THREADmODE4rESTORE
                            flagsT flagsRC = listC::fieldIF( tinP , pOut , hListSex , pczField , _1_modePushIfNotExistC() + _1_pushC( 0 , cbaMeta ) + _1_modeQueryNewC() + _1_queryC() , idLineNewP , idiFileNewP , flLISToPEN_null , ifcIDgRABlAYER_8POOL5nEW) ;
                            THREADmODE4oN( flTHREADmODE4_DOnOTmAKEsEXiNpOOL )
                            ZE( fieldEditParamOutC* , pOut ) ;
                
                            listC::openIF( tinP , hListSex , pczListSex , flLISToPEN_null , ifcIDgRABlAYER_8POOL5nEW) ;
                            handleC hListSex( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                        {
                        if( ( 1 << expCbDropP != sizeof( listC ) || bListsExist ) ) // CREATION OF THE RECORD AND THE FIELD listC WOULD REQUIRE ME
                
                        }
                            if( ~hListField ) bListsExist = 1 ;
                            listC::openIF( tinP , hListField , hListSex , pczField , flLISToPEN_IFeXISTS , ifcIDgRABlAYER_8POOL5nEW) ;
                            handleC hListField( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                        {
                        if( ~hListSex )
                        listC::openIF( tinP , hListSex , pczListSex , flLISToPEN_IFeXISTS , ifcIDgRABlAYER_8POOL5nEW) ;
                        handleC hListSex( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                    {
                    ZE( boolT , bListsExist ) ;
                
                    grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
                
                    countT pczField[]   = { ifcIDrECORDfIELD_SEXcbACKINGbLOBlIST , 0 } ;
                
                    puseC puseUse( tinP , *pPoolContainsMe ) ;
                {
                THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY )
            
                // ALLOCATE pbMeta FROM *pPoolContainsMe TO AVOID THE OVERHEAD OF USING A napkinC AND ESCAPE THE BASE O.S. ALLOCATION GRAIN MINIMUM AND MINIMIZE ADDRESS SPACE FRAGMENTATION
            {
            )
                !bNested
                &&
                pPoolContainsMe
                &&
                !( F(tinP.flagsThreadMode4) & flTHREADmODE4_DOnOTmAKEsEXiNpOOL )
                &&
                F(flagsCt) & fliSEXc_ALLOWsEXiNpOOL
                &&
                !POOP
            (
            if

            //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            // TRY TO ALLOCATE pbMeta FROM A SIBLING sexC (ANOTHER sexC, EXISTING OR NEWLY CREATED, OF *pPoolContainsMe
            //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

            pbDataEnd = !pbData ? 0 : pbData + ( ( CBsEXdROPsEPARATOR + CBsEXdROPhEADER ) + ( 1 << expCbDropP ) ) * ( 1 << expSlotsP ) ;
        {
        if( !POOP )

        __Z( pbData ) ;
        }
            }
                }
                    if( !( F(((napkinC*)pb_napData)->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) ) bFormatDataBlob = 1 ;                         // THE DATA NAPKIN CANNOT BE FORMATTED UNTIL AFTER THE META NAPKIN IS FORMATTED
                    if( bSmallSlots                                                                                 ) pbData -= sizeof( napkinHeaderS ) ;
                {
                if( !POOP )

                __Z( pbData ) ;
                pbData  = *(napkinC*)pb_napData ;
            {
            if( !POOP )

            ) ;
                F(flagsCt) & ( fliSEXc_nFeO | fliSEXc_READoNLY ) ? ifcOPENsHAREDmEMORYhOW_nFeO : ifcOPENsHAREDmEMORYhOW_nCeO , /*tinP.pag1->idMemorySpace == ifcIDmEMORYsPACE_APPLICATION && expCbDropP + expSlotsP <= 0x14 ? flNAPKINc_LOCK :*/ flNAPKINc_null , 1 , idMemorySpaceP
                cbaDataNapkin ,
                ) ,
                        : (const handleC*)*(fileC*)pbFileData
                        ? 0
                    !idStateSpaceP
                (
                ) ,
                    tinP.pbF( 4 )
                    ) ,
                        "."
                        ) ,
                            tinP.pbF( 3 )
                            ) ,
                                "."
                                ) ,
                                    tinP.pbF( 2 )
                                    ) ,
                                        "."
                                        ) ,
                                            postNameP
                                            ) ,
                                                tinP , tinP.pbF() , "sexC/data/"
                                            (
                                            thirdC::c_strcpyIF
                                            tinP ,
                                        (
                                        thirdC::c_strcatIF
                                        tinP ,
                                    (
                                    thirdC::c_strcatIF
                                    tinP ,
                                (
                                thirdC::c_strcatIF
                                tinP ,
                            (
                            thirdC::c_strcatIF
                            tinP ,
                        (
                        thirdC::c_strcatIF
                        tinP ,
                    (
                    thirdC::c_strcatIF
                    tinP ,
                (
                thirdC::c_strcatIF
                idLineNewP , idiFileNewP , pbBitsCtP ,
                ) ,
                    tinP
                (
            (
            new( 0 , tinP , pb_napData , sizeof pb_napData ) napkinC

            flagsState |= flSEXcsTATE_USINGnAPfORdATA ;
            // WHEN SLOT SIZE IS LARGE, DATA BEGINS IN THE NORMAL PLACE (AT THE END OF THE NAPKIN HEADER) AND ADDITIONAL BYTES ARE ALLOCATED FOR HEADROOM (SO THAT THE HIGHEST VALID BYTE CAN BE READ USING A DWORD OPERATION SUCH AS movsd)
            // WHEN SLOT SIZE IS SMALL, DATA OVERLAYS THE NAPKIN HEADER AND NO ADDITIONAL BYTES ARE ALLOCATED.  INSTEAD, THE LOWEST AND HIGHEST SLOTS ARE MARKED AS UNAVAILABLE; THIS IS DONE TO AVOID THE EXTRA ALLOCATION UNIT REQUIRED FOR THE NAPKIN HEADER AND THE HEADROOM BYTES.  THE SLOTS SACRIFICED OCCUPY LESS MEMORY THAN THE ALLOCATION UNIT WOULD
        {
        if( !pbData )

        //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        // IF COULD NOT, THEN ALLOCATE pbData USING A napkinC TO OBTAIN A MEMORY ALLOCATION FROM THE BASE O.S.
        //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    {
    else
    }
        //U::DELETE THE BLOB THAT I JUST ALLOCATED
    {
    if( POOP )
    ZE( boolT , bFormatDataBlob ) ;

    }
        THREADmODE3rESTORE
        }
            }
                //DO THIS IN MY DESTRUCTOR BUT ONLY IF I AM THE ONLY CLIENT: listC::deleteIF( tinP, pczListSex ) ;
        
                }
                    }
                        DELlIST( fieldEditParamOutC , pOut ) ;
                        puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                    {

                    }
                        if( !POOP ) pbData = (byteT*)(const osTextT*)pOut->vspBlob ;
                        __NZ( pOut->pNext ) ;
                    {
                    if( !POOP )
                    __Z( pOut ) ;
        
                    THREADmODE4rESTORE
                    flagsT flagsRC = listC::fieldIF( tinP , pOut , hListSex2 , pczField , _1_modePushIfNotExistC() + _1_pushC( 0 , cbaDataPool ) + _1_modeQueryNewC() + _1_queryC() , idLineNewP , idiFileNewP , flLISToPEN_null , ifcIDgRABlAYER_8POOL5nEW ) ;
                    THREADmODE4oN( flTHREADmODE4_DOnOTmAKEsEXiNpOOL )
                    ZE( fieldEditParamOutC* , pOut ) ;
        
                    listC::openIF( tinP , hListSex2 , pczListSex , flLISToPEN_null , ifcIDgRABlAYER_8POOL5nEW ) ; //U::BUG: THE grabitC::ungrabF BLAMMO OCCURS WITHIN THIS CALL
                    handleC hListSex2( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                {
                )
                    1 << expCbDropP != sizeof( listC )           // CREATION OF THE RECORD AND THE FIELD listC WOULD NOT REQUIRE ME
                    ||
                    bListsExist
                (
                if

                }
                    }
                        if( ~hListField ) bListsExist = 1 ;
                        listC::openIF( tinP , hListField , hListSex1 , pczField , flLISToPEN_IFeXISTS , ifcIDgRABlAYER_8POOL5nEW ) ;
                        handleC hListField( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                    {
                    if( ~hListSex1 )
                    listC::openIF( tinP , hListSex1 , pczListSex , flLISToPEN_IFeXISTS , ifcIDgRABlAYER_8POOL5nEW ) ;
                    handleC hListSex1( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                {
            {
            ZE( boolT , bListsExist ) ;

            grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
        
            countT pczField[]   = { ifcIDrECORDfIELD_SEXcbACKINGbLOBdATA , 0 } ;
        
            puseC puseUse( tinP , *pPoolContainsMe ) ;
        {
        THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY )
    
        // ALLOCATE pbData FROM *pPoolContainsMe TO AVOID THE OVERHEAD OF USING A napkinC AND ESCAPE THE BASE O.S. ALLOCATION GRAIN MINIMUM AND MINIMIZE ADDRESS SPACE FRAGMENTATION
    {
    )
        !bNested
        &&
        pPoolContainsMe
        &&
        !( F(tinP.flagsThreadMode4) & flTHREADmODE4_DOnOTmAKEsEXiNpOOL )
        &&
        F(flagsCt) & fliSEXc_ALLOWsEXiNpOOL
        &&
        !POOP
    (
    if

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    // TRY TO ALLOCATE pbData FROM A SIBLING sexC (ANOTHER sexC, EXISTING OR THAT I CAUSE TO BE CREATED, OF *pPoolContainsMe
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    tinP.tlsNewF( LF , TUCK ) ;
    tinP.tlsNewF( LF , 0x10 ) ;    thirdC::c_itoaIF( tinP , tinP.pbF() , 0x10 , idStateSpaceP ) ;
    tinP.tlsNewF( LF , 0x10 ) ;    thirdC::c_itoaIF( tinP , tinP.pbF() , 0x10 , expCbDropP ) ;
    tinP.tlsNewF( LF , 0x10 ) ;    thirdC::c_itoaIF( tinP , tinP.pbF() , 0x10 , expSlotsP ) ;
    //CS:CODEsYNC: 360e0003 360e0003

    const countT pczListSex[] = { LISTnAME_ROOT , LISTnAME_ROOTsYSTEM1 , LISTnAME_HANDhOLD , LISTnAME_SEXc , BM_HIGH | expCbDropP , BM_HIGH | expSlotsP , 0 } ;

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    // AT THIS POINT I AM THE ONLY THREAD OF ANY PROCESS FOR THIS HOME THAT IS PROCEEDING TO CONSTRUCT A sexC FOR MY SPECIFICATIONS, AND bNested INDICATES WHETHER I AM CALLED BY MYSELF
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        }
            THREADmODE2rESTORE
            }
                bGrabbed = 1 ;

                }
                    ++ s ; thirdC::dosSleepWinkIF( tinP ) ;
                {
                while( btsAM( pReg->pbSexGrabbedBits , offSexBit ) )
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        {
        if( !POOP )

        __( !pReg ) ;
        }
            }
                break ;
                pReg = pRegs + offr ;
            {
            if( !thirdC::c_strcmpIF( tinP , pRegs[ offr ].postPoolName , postPoolName ) )
        {
        for( countT offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )
        ZE( poolRegistrationS* , pReg ) ;

        const osTextT* postPoolName = pPoolContainsMe->postNameF( tinP ) ;
        poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;
        homeS& home = homeS::homeIF() ;
    {
    if( !bNested && pPoolContainsMe )
    ZE( boolT , bGrabbed ) ;

    //const byteT  maskSexByte = (byteT)( 1 << ( offSexBit % SB ) )    ;
    //const countT offSexByte  =                 offSexBit / SB        ;
      const countT offSexBit   = expCbDropP * CsLOTeXTENTS + expSlotsP ;

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    // GRAB (SET) THE "CONSTRUCTING" BIT FOR MY SPECIFICATIONS [expCbDropP,expSlotsP] TO SERIALIZE CONSTRUCTION
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
                               tinP.pSexLifoConstructing = this ;
        pSexLifoConstructing = tinP.pSexLifoConstructing ;

        }
            pSexc = pSexc->pSexLifoConstructing ;
            }
                break ;
                bNested = 1 ;
            {
            if( pSexc == this )
        {
        while( pSexc )
        sexC* pSexc = tinP.pSexLifoConstructing ;
    {
    if( pPoolContainsMe )                                                       // I AM MAINLY FOR USE WITHIN poolC ; BUT AN APPLICATION CAN CT ME (pPoolContainsMe MUST BE 0)
    ZE( boolT , bNested ) ;

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    // SET UP FOR WORK: SET bNested
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        if( F(flagsCt) & fliSEXc_NOTES ) cbaMeta += sizeof( dropNoteS ) << expSlotsP ;
                                         cbaMeta  = sizeof( sexHeadS  ) + cbNeededForBits + CBtOaLIGN02( cbNeededForBits ) ;
        countT                                                            cbNeededForBits                                  = 1 + ( 1 << expSlotsP ) / SB ;
    {
    ZE( countT , cbaMeta ) ;

    }
        ;
                        )
                                :            sizeof( countT        ) - 1     // ADD HEADROOM SO THAT THE LATH BYTE CAN BE READ USING A DWORD (countT) INSTRUCTION ; SINCE THE DATA WILL BE AN INTEGRAL MULTIPLE OF THE ALLOCATION UNIT, THIS HEADROOM WILL CAUSE AN ENTIRE ALLOCATION UNIT (1 TOCK) (64K) TO BE OBTAINED JUST TO GET THESE 3 BYTES
                                ? - (sCountT)sizeof( napkinHeaderS )         // SUBTRACT FOR napHeaderS SO THAT THE BYTES ALLOCATED BY napkinC WILL BE AN INTEGRAL MULTIPLE OF THE ALLOCATION UNIT ; THIS RESULTS IN THE napHeaderS OVERLAYING SOME LOW DATA SLOTS, WHICH IS WHY THE FORMATTING CODE MUST MARK THOSE SLOTS AS UNAVAILABLE ; THE FORMATTING CODE WILL ALSO MARK SOME HIGH SLOTS AS UNAVAILABLE, IN ORDER TO GUARANTEE HEADROOM FOR ACCESSING THE HIGHEST BYTE
                            bSmallSlots
                        (
                        +
        cbaDataNapkin = cbaDataNeeded
        cbaDataPool   = cbaDataNeeded ;
        countT          cbaDataNeeded = ( 1 << expSlotsP ) * ( ( CBsEXdROPsEPARATOR + CBsEXdROPhEADER ) + ( 1 << expCbDropP ) ) ;                           // FOR SMALL expCbDropP, SLOTS AT BOTTOM ARE UNUSEABLE; SEE sexHeadS::cSlotsAvoidLo
    {
    ZE( countT , cbaDataNapkin ) ;
    ZE( countT , cbaDataPool   ) ;

    const boolT bSmallSlots = ( CBsEXdROPsEPARATOR + CBsEXdROPhEADER ) + ( 1 << expCbDropP ) < ( 1 << thirdC::os_expCbAllocationGrain_IF( tinP ) ) ;        // FOR SMALL SLOT SIZES, pbData WILL POINT TO THE napkinHeaderS CONTROL STRUCTURE, WHICH IS WHY THE LOW SLOTS MUST BE MARKED AS UNAVAILABLE

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    // SET UP FOR WORK: CALCULATE BLOB SIZES NEEDED
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    //U::REMOVE UNNECESSARY AND/OR UNUSED SERIALIZATION SUPPORT sexC poolC FOR poolRegistrationS

    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    // 
    // BUT ITS USE IS RETAINED BECAUSE IT AVOIDS THE USE OF *pPoolContainsMe, WHICH COULD TRIGGER NESTED CONSTRUCTION OF OTHER sexC
    // NOW THAT napkinC'S ARE CONDITIONALLY CONSTRUCTED IN THE BODY OF THE sexC CONSTRUCTOR, TLS IS NOT NEEDED FOR CODING CONVENIENCE
    // TLS WAS ORIGINALLY USED FOR CODING CONVENIENCE WHEN THE OO napkinC'S WERE UNCONDITIONALLY CONSTRUCTED AS napkinC MEMBERS
    // TLS (tinS::newF pbF delF) IS USED FOR SHORT STRINGS TO CALCULATE A napkinC PARAMETER VALUE (postNameP)
    // 
    // 3. ON FAILURE, I IMMEDIATELY DESTROY ANY napkinC AND OTHER INSTANCES THAT I HAVE CREATED ; MY DESTRUCTOR DOES NOT NEED TO DO THIS (NEW?)
    // 2. CALLER MUST DETECT MY IMPOTENCE (BY CALLING operator const poopC&) AND DESTROY ME                                              (OLD)
    // 1. ON FAILURE, THE INSTANCE BECOMES IMPOTENT BUT THE CALLER DOES NOT                                                              (OLD)
    //
    // 20240814@1541: POLISHING THIS CT'OR CODE TO CORRECTLY HANDLE IMPOTENCE ACCORDING TO THE FOLLOWING REQUIREMENTS:
    // 
    // WILL DETECT THIS AND BECOME IMPOTENT.  THE CALLER MUST DETECT THIS AND DESTROY ME RATHER THAN USE ME.  "SPECIFICATIONS" MEANS "[expCbDrop,expSlots]"
    // THE CALLER MUST CAST ME TO (const poopC&) TO DISCOVER WHETHER I WAS CONSTRUCTED AOK.  IF SOMETHING THAT I DO CAUSES A sexC WITH THE SAME SPEC TO BE CT'D, I
    // 
    // EXACTLY DETERMINES WHETHER THE poolC ATTEMPTS ARE SUPPRESSED AND WHETHER THOSE CIRCUMSTANCES CAN BE REDUCED OR ELIMINATED.
    // AT THE TIME OF THIS WRITING, THE ENHANCED CODE APPEARS TO WORK, BUT HAS NOT BEEN TESTED AND IS NOT UNDERSTOOD.  IN PARTICULAR, I DO NOT UNDERSTAND WHAT
    // 
    // THE UNHAPPIEST OUTCOME IS THAT A NEW sexC IS CONSTRUCTED RECURSIVELY THAT GETS BOTH pbData AND pbMeta USING napkinC.
    // RECURSIVELY.  THAT RECURSION WILL ALWAYS USE napkinC.  (I THINK THAT THIS IS TRUE.  U::STUDY THE CURRENT CODE TO SEE WHEN IT SUPPRESSES THE poolC ATTEMPTS.)
    // THAT A sexC INSTANCE THAT HAS AN AVAILABLE SLOT HAPPENS TO ALREADY EXIST FOR THE PARTICULAR SLOT SIZE NEEDED.  IF NOT, THEN A sexC WILL BE CONSTRUCTED
    // TO REDUCE FRAGMENTATION, THIS CODE NOW ATTEMPTS TO OBTAIN MEMORY FROM *pPoolContainsMe FOR pbData AND pbMeta.  THE HAPPIEST OUTCOME FOR SUCH A REQUEST IS
    // 
    // SUFFICIENTLY LARGE CONTIGUOUS PIECE.
    // ACTUAL AVAILABLE MEMORY BEING FAR BELOW THEORETICAL.  (napkinC CONSTRUCTION WOULD FAIL EVEN IF TOTAL AVAILABLE MEMORY WAS SUFFICIENT IF THERE ISN'T A
    // THE RANDOM ON DEMAND CONSTRUCTION OF 004 (1024_9 I.E. 1K) BASE O.S. MEMORY ALLOCATIONS OF VARIOUS SIZES WOULD FRAGMENT THE ADDRESS SPACE, RESULTING IN
    // poolC USES "OO POWER EXPANSION" TO CONSTRUCT sexC ("SLOTS EXTENTS") ON DEMAND.  IN THEORY, 02 INSTANCES COULD BE CONSTRUCTED FOR EACH OF 02 SLOT SIZES.
    // 
    // EACH SLOT IS ASSOCIATED WITH A SINGLE BIT IN pbMeta.  IF THAT BIT IS 0, THE SLOT IS AVAILABLE; ELSE THE SLOT IS "OWNED" (OR "IN USE").
    // *pPoolContainsMe, THE POINTER VALUE THAT IS RETURNED POINTS TO THE BEGINNING OF WO OF THESE SLOTS.  (THE SLOT SELECTED IS ALWAYS THE HIGHEST AVAILABLE SLOT.)
    // pbData IS SIMPLY A SEQUENCE OF 1 << expSlotsP "SLOTS", EACH OF SIZE 1 << expCbDropP.  WHEN APPLICATION CODE USES THE new OPERATOR TO REQUEST MEMORY FROM
    // OO napkinC's.  THE ONLY UNUSUAL FEATURE OF THE CODE WAS THAT THREAD LOCAL STORAGE WAS USED TO CALCULATE THE CONSTRUCTION ARGUMENTS FOR THESE OO napkinC'S.
    // WHEN ORIGINALLY WRITTEN, MY JOB WAS SIMPLY TO ASK THE BASE O.S. TO ALLOCATE OO SHARED MEMORY BLOBS, pbData AND pbMeta.  THESE BLOBS WERE OBTAINED USING
    // 
    // INTRODUCTION AND OVERVIEW
    // 
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    // A:ASSUME: sizeof( sexHeadS ) IS INTEGRAL MULTIPLE OF sizeof( countT )
    // 
    // WHEN THE BIT FOR A SLOT IS SET, THAT SLOT IS MARKED AS "OWNED" ("IN USE")
    // 
    // pzMetaNote                                       sizeof( dropNoteS ) << expSlotsP        1 dropNoteS FOR EACH OF 1 << expSlotsP SLOTS
    // 
    //                                                  CBtOaLIGN02( cbMetaNeeded )             PADDING TO ALIGN pzMetaNote TO countT BOUNDARY
    // 
    // pbzMetaBitsOwned                                 cbMetaNeeded                            1 BIT FOR EACH OF 1 << expSlotsP SLOTS
    // 
    // pbMeta == pzMetaHead                             sizeof( sexHeadS )                      sexHeadS
    // 
    // ADDRESS                                          LENGTH                                  DESCRIPTION
    // 
    // META LAYOUT

    _IO_

    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
pSexLifoConstructed( 0 )
offFoundLath( - 1 ) ,
pSexLifoConstructing( 0 ) ,
pbDataEnd( 0 ) ,
pbData( 0 ) ,
pzMetaNote( 0 ) ,
pbzMetaBitsOwned( 0 ) ,
pzMetaHead( 0 ) ,
pbMeta( 0 ) ,
idLathNewDel( 0 ) ,
idStateSpace( idStateSpaceP ) ,
flagsState( flSEXcsTATE_null ) ,
) ,
            )
                flagsP | fliSEXc_MAPPEDtOdISK
                ,
                ctFilesF( tinP , postNameP , expCbDropP , expSlotsP , idStateSpaceP )
            (
        :
        ? flagsP
    !idStateSpaceP
(
flagsCt
pPoolContainsMe( pPoolContainsMeP ) ,
/*1*/sexC::sexC( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const countT idLineNewP , const countT idiFileNewP , const osTextT* const postNameP , const countT expCbDropP , const countT expSlotsP , const flagsT flagsP , const countT idStateSpaceP , countT idMemorySpaceP , poolC* const pPoolContainsMeP ) :/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

