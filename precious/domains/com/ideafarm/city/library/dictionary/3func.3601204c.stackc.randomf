
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return ;

    _OUTbATONsTACKc_
    }
        default : { *(countT*)pbP = operator[]( 1 + ranUni * cPlates ) ; break ; }
        }
            break ;

            third.c_memcpyIF( tin0P , pbP , (byteT*)&cd , cbData ? cbData : sizeof( countT ) + cd ) ;
            if( !pbP ) { third.newF( tin0P , LF , pbP , cbData ? cbData : sizeof( countT ) + cd ) ; ___BITScT( pbP , 0xe1f ) ; }
            countT& cd = operator[]( 1 + ranUni * cPlates ) ;
        {
        case ifcSTACKtYPE_BLOB             :
        case ifcSTACKtYPE_count9S          : {          *(count9S*)pbP =          *(count9S*)&operator[]( 1 + ranUni * cPlates ) ; break ; } // WE CAST TO A POINTER BECAUSE CASTING DIRECTLY TO          count9S& RESULTS IN A TEMPORARY countT OBJECT BEING USED
        case ifcSTACKtYPE_count8S          : {          *(count8S*)pbP =          *(count8S*)&operator[]( 1 + ranUni * cPlates ) ; break ; } // WE CAST TO A POINTER BECAUSE CASTING DIRECTLY TO          count8S& RESULTS IN A TEMPORARY countT OBJECT BEING USED
        case ifcSTACKtYPE_count7S          : {          *(count7S*)pbP =          *(count7S*)&operator[]( 1 + ranUni * cPlates ) ; break ; } // WE CAST TO A POINTER BECAUSE CASTING DIRECTLY TO          count7S& RESULTS IN A TEMPORARY countT OBJECT BEING USED
        case ifcSTACKtYPE_count6S          : {          *(count6S*)pbP =          *(count6S*)&operator[]( 1 + ranUni * cPlates ) ; break ; } // WE CAST TO A POINTER BECAUSE CASTING DIRECTLY TO          count6S& RESULTS IN A TEMPORARY countT OBJECT BEING USED
        case ifcSTACKtYPE_count5S          : {          *(count5S*)pbP =          *(count5S*)&operator[]( 1 + ranUni * cPlates ) ; break ; } // WE CAST TO A POINTER BECAUSE CASTING DIRECTLY TO          count5S& RESULTS IN A TEMPORARY countT OBJECT BEING USED
        case ifcSTACKtYPE_count4S          : {          *(count4S*)pbP =          *(count4S*)&operator[]( 1 + ranUni * cPlates ) ; break ; } // WE CAST TO A POINTER BECAUSE CASTING DIRECTLY TO          count4S& RESULTS IN A TEMPORARY countT OBJECT BEING USED
        case ifcSTACKtYPE_count3S          : {          *(count3S*)pbP =          *(count3S*)&operator[]( 1 + ranUni * cPlates ) ; break ; } // WE CAST TO A POINTER BECAUSE CASTING DIRECTLY TO          count3S& RESULTS IN A TEMPORARY countT OBJECT BEING USED
        case ifcSTACKtYPE_count2S          : {          *(count2S*)pbP =          *(count2S*)&operator[]( 1 + ranUni * cPlates ) ; break ; } // WE CAST TO A POINTER BECAUSE CASTING DIRECTLY TO          count2S& RESULTS IN A TEMPORARY countT OBJECT BEING USED
        case ifcSTACKtYPE_count04T         : {         *(count04T*)pbP =         *(count04T*)&operator[]( 1 + ranUni * cPlates ) ; break ; } // WE CAST TO A POINTER BECAUSE CASTING DIRECTLY TO         count04T& RESULTS IN A TEMPORARY countT OBJECT BEING USED
        case ifcSTACKtYPE_timeS            : {            *(timeS*)pbP =            *(timeS*)&operator[]( 1 + ranUni * cPlates ) ; break ; } // WE CAST TO A POINTER BECAUSE CASTING DIRECTLY TO            timeS& RESULTS IN A TEMPORARY countT OBJECT BEING USED
        case ifcSTACKtYPE_nicNameC         : {         *(nicNameC*)pbP =         *(nicNameC*)&operator[]( 1 + ranUni * cPlates ) ; break ; } // WE CAST TO A POINTER BECAUSE CASTING DIRECTLY TO         nicNameC& RESULTS IN A TEMPORARY countT OBJECT BEING USED
    {
    switch( idType )
    _INbATONsTACKc_

    }
        if( third ) return ;
        __( F(flags) & flSTACKc_XRAY ) ;
        __( idType != ifcSTACKtYPE_BLOB            &&  !pbP ) ;
        __( idType == ifcSTACKtYPE_BLOB && !cbData && !!pbP ) ;
        if( third ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT stackC::randomF( tin0S& tin0P , byteT*& pbP )/*1*/

/**/
*/
   these bytes will be assigned the value of the randomly selected plate
  must contain the address of cbData bytes
   if not 0 then must point to cbData writeable bytes
   ifcSTACKtYPE_BLOB: pbP can be either 0 or not 0
  must not be 0 unless ifcSTACKtYPE_BLOB
 pbP
 tin0P
arguments
  this time determines the seed that is used to construct the ranUniC object for the stackC
 the result of the wo'th call to me for a given stackC object is determined by the time that the stackC was constructed
 each of the plates is equally likely to be chosen
i choose a plate randomly
\<A HREF=\"5.1150051.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$randomF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

