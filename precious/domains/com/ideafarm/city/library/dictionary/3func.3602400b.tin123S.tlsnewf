
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbData ;

    //if( !thirdC::c_strcmpIF( tin0P , postThreadName , "tmNodeF" ) ) tlsTraceF() ; //U::DISABLE IN PRODUCTION
    tlsCheckF() ;

    //}
    //    LOGrAWtID2( "tin123S::newF [pb]: " , pbData ) //U:: TO FIND A BUG: REMOVE IN PRODUCTION FOR SPEED
    //    tin0S& tin0P = *this ;
    //{

    }
        }
            th.pcStepLFAt[ offElt + 2 ] = (countT)pbData      ;
            th.pcStepLFAt[ offElt + 1 ] = idiFileP            ;
            th.pcStepLFAt[ offElt     ] = idLineP   | BM_HIGH ;     // BM_HIGH INDICATES "NEW"
            offElt = offStep * 3 ;
            countT offStep = ( th.cSteps ++ ) % CmAXsTEPtLS ;
        {
        ZE( countT , offElt ) ;

        }
            cTls ++ ;
            if( postNameP ) thirdC::c_memsetIF( tin0P , pbData , cbP ) ; //tlsBlobC RELIES ON THIS LINE TO SMUDGE ITS FOOT FINGERPRINTS
            pbData = pbc ;

            }
                BLAMMO ;                                //IF BLOW HERE THEN NEED TO MAKE TLS LARGER FOR THIS THREAD
                tlsTraceF() ;
            {
            if( pbe < pbc + cbP )

            }
                thirdC::c_memcpyIF( tin0P , pbc , postInGroupP , costaInGroupP )  ; pbc += costaInGroupP    ; // postInGroup
                }
                    BLAMMO ;                                    //IF BLOW HERE THEN NEED TO MAKE TLS LARGER FOR THIS THREAD
                    tlsTraceF() ;
                {
                if( pbe < pbc + costaInGroupP )
            {
            if( costaInGroupP )
            }
                thirdC::c_memcpyIF( tin0P , pbc , postNameP , costaNameP )           ; pbc += costaNameP       ; // postName
                }
                    BLAMMO ;                            //IF BLOW HERE THEN NEED TO MAKE TLS LARGER FOR THIS THREAD
                    tlsTraceF() ;
                {
                if( pbe < pbc + costaNameP )
            {
            if( costaNameP )
            *(countT*)pbc = costaInGroupP                                                                        ; pbc += sizeof( countT ) ; // costaInGroup
            *(countT*)pbc = costaNameP                                                                           ; pbc += sizeof( countT ) ; // costaName
            *(countT*)pbc = 0                                                                                    ; pbc += sizeof( countT ) ; // offNextInGroup
            *(countT*)pbc = 0                                                                                    ; pbc += sizeof( countT ) ; // offNextObject
            *(countT*)pbc = offElder                                                                             ; pbc += sizeof( countT ) ; // offElder
            *(countT*)pbc = 1                                                                                    ; pbc += sizeof( countT ) ; // cRef
            *(countT*)pbc = idiFileP                                                                             ; pbc += sizeof( countT ) ; // idiFile
            *(countT*)pbc = idLineP                                                                              ; pbc += sizeof( countT ) ; // idLine
            *(countT*)pbc = ( TLSeNTRYoFF_endNotUsed - 1 ) * sizeof( countT ) + costaNameP + costaInGroupP + cbP ; pbc += sizeof( countT ) ; // cbEntry
            //if( ((tin123S&)tin0P).pc Utility[ 0 ] && costaInGroupP ) { CONoUTrAW( postInGroupP ) ; CONoUTrAW( "\r\n" ) ; }
            //if( ((tin123S&)tin0P).pc Utility[ 0 ] && costaNameP    ) { CONoUTrAW( postNameP    ) ; CONoUTrAW( "\r\n" ) ; }
            //if( ((tin123S&)tin0P).pc Utility[ 0 ]                  ) { CONoUTrAW3( "tin123S::newF/entry formatted at " , (countT)pbc , "\r\n" ) ; }
            //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) ((tin123S&)tin0P).pc Utility[ 1 ] ++ ;
            const byteT* const pbe = pbTls + cbTls ;
            byteT*             pbc = pbTls + th.offTopEntry ;
        
            }
                }
                    offCursor = ( (countT*)( pbTls + offCursor ) )[ TLSeNTRYoFF_offElder ] ;
        
                    }
                        break ;
                        offNextInGroup = th.offTopEntry ;
                        if( offNextInGroup ) { BLAMMO ; }
                        countT& offNextInGroup = ( (countT*)( pbTls + offCursor ) )[ TLSeNTRYoFF_offNextInGroup ] ;
                    {
                    )
                        ( costaInGroupP && postInGroup && !thirdC::c_strcmpIF( tin0P , postInGroup , postInGroupP ) )
                        ||
                        ( !costaInGroup && !costaInGroupP )
                    (
                    if
        
                    const osTextT* const postInGroup  = !costaInGroup ? 0 : (byteT*)&costaInGroup + sizeof( countT ) + costaName ;
                    countT&              costaInGroup = ( (countT*)( pbTls + offCursor ) )[ TLSeNTRYoFF_costaInGroup ] ;
                    countT&              costaName    = ( (countT*)( pbTls + offCursor ) )[ TLSeNTRYoFF_costaName    ] ;
                {
                while( offCursor )
                countT offCursor = offElder ;
        
                offNextObject = th.offTopEntry ;                                               // elder.offNextObject
                if( offNextObject ) { BLAMMO ; }
                countT& offNextObject = ( (countT*)( pbTls + offElder ) )[ TLSeNTRYoFF_offNextObject ] ;
            {
            if( offElder )

            }
                BLAMMO ;                        //IF BLOW HERE THEN NEED TO MAKE TLS LARGER FOR THIS THREAD
                tlsTraceF() ;
            {
            if( cbTls <= th.offTopEntry + TLSeNTRYoFF_endNotUsed * sizeof( countT ) )
            if( cbTls <= th.offTopEntry                                             ) { BLAMMO ; } //IF BLOW HERE THEN THE FOLLOWING CODE HAS A BUG

            //if( !thirdC::c_strcmpIF( *this , postThreadName , "tmWorkerF" ) ) { CONoUTrAW5( "" , (countT)&th.offTopEntry , "    tlsNewF / !pbData so just set [offTopEntry]:    " , th.offTopEntry , "\r\n" ) ; }

            th.cNew ++ ;
        
            ;
                : offElder + sizeof( countT ) + ( (countT*)( pbTls + offElder ) )[ TLSeNTRYoFF_cbEntry ]
                ? sizeof( tlsHeaderS )
            th.offTopEntry = !offElder
            const countT offElder = th.offTopEntry ;

            //pc Utility[ 2 ] = TLSeNTRYoFF_cbEntry    ; //U:: TO FIND A BUG
            //pc Utility[ 1 ] = (countT)pbTls          ; //U:: TO FIND A BUG
            //pc Utility[ 0 ] = th.offTopEntry         ; //U:: TO FIND A BUG
        {
        if( !pbData )
    
        }
            }
                offMe = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_offElder ] ;
        
                }
                    }
                        break ;
                        pbData = (byteT*)&costaInGroup + sizeof( countT ) + costaName + costaInGroup ;

                        }
                            BLAMMO ;
                            CONoUTrAW3( "" , glass.idThread , "    cRef++\r\n" ) ;
                        {
                        //20210416@1530:  THIS JUST PROVES THAT THIS CODE IS NEVER USED ; REMOVE THIS BLAMMO IF NEEDED

                        __( !( cRef ++ ) ) ;
                        countT& cRef = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_cRef ] ;
                    {
                    if( postName && !thirdC::c_strcmpIF( tin0P , postName , postNameP ) )
                {
                if( !postInGroupP || ( postInGroup && !thirdC::c_strcmpIF( tin0P , postInGroup , postInGroupP ) ) )
        
                const osTextT* const postInGroup  = !costaInGroup ? 0 : (byteT*)&costaInGroup + sizeof( countT ) + costaName ;
                const osTextT* const postName     = !costaName    ? 0 : (byteT*)&costaInGroup + sizeof( countT ) ;
                countT&              costaInGroup = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_costaInGroup ] ;
                countT&              costaName    = ( (countT*)( pbTls + offMe ) )[ TLSeNTRYoFF_costaName    ] ;
            {
            while( offMe )
            countT offMe = costaNameP ? th.offTopEntry : 0 ;
        {
        //if( !thirdC::c_strcmpIF( *this , postThreadName , "tmWorkerF" ) ) { CONoUTrAW5( "" , (countT)&th.offTopEntry , "    tlsNewF / on entry [offTopEntry]:    " , th.offTopEntry , "\r\n" ) ; }

        //}
        //    CONoUTrAW( "\"\r\n" ) ;
        //    CONoUTrAW( postNameP ) ;
        //    CONoUTrAW( "tlsNewF [postNameP]:    \"" ) ;
        //{
        //if( postNameP )
        //
        //}
        //    CONoUTrAW( "\"\r\n" ) ;
        //    CONoUTrAW( postInGroupP ) ;
        //    CONoUTrAW( "tlsNewF [postInGroupP]:    \"" ) ;
        //{
        //if( postInGroupP )
        //
        //}
        //    }
        //        CONoUTrAW5( "tlsNewF [cbP,offTopEntryMax(before)]:    " , cbP , "    " , offTopEntryMax , "\r\n" ) ;
        //        offTopEntryMax = th.offTopEntry ; //INTENTIONAL RACE: THIS CODE IS NOT THREAD SAFE BUT I DON'T CARE SINCE ANY CLOBBERING IS LIKELY TO BE HEALED, AND I ONLY USE THIS MAX TO GET AN IDEA HOW BIG TLS MUST BE
        //    {
        //    if( offTopEntryMax < th.offTopEntry )
        //    static countT offTopEntryMax ;
        //{

        tlsHeaderS& th = *(tlsHeaderS*)pbTls ;

        const countT costaInGroupP = !postInGroupP ? 0 : 1 + thirdC::c_strlenIF( tin0P , postInGroupP ) ;
        const countT costaNameP    = !postNameP    ? 0 : 1 + thirdC::c_strlenIF( tin0P , postNameP    ) ;
    {
    ZE( byteT* , pbData ) ;

    }
        scoopC _scoop( tin0P , LF , _poop ) ;
        poopC _poop( flPOOP_SMELLY ) ;
    {
    //THIS BUG WAS FOUND; IT WAS A ZOMBIE tin0P REFERENCE; THE TEST IS RETAINED TO DETECT NEW INTRODUCTIONS OF THAT BUG

    }
        *pcBlammo = -1 ;
        ZE( countT* , pcBlammo ) ;

        LOGrAW(    postSay ) ;
        CONoUTrAW( postSay ) ;

        ;
            : "\r\nerror:  tlsNewF called on raw thread (tmBreakF)\r\n"
            ? "\r\nerror:  tlsNewF called on raw thread (tmHeartF)\r\n"
        osTextT* postSay = ((tin123S&)tin0P).idTinNamed == ifcIDtINnAMED_tinHeartI
    {
    if( ((tin123S&)tin0P).idTinNamed == ifcIDtINnAMED_tinHeartI || ((tin123S&)tin0P).idTinNamed == ifcIDtINnAMED_tinBreakI  ) // RAW THREAD, SO CANNOT CALL TINSL

    //_IO_
    //SPEED OPTIMIZATION: THIS _IO_ WOULD HAVE THE #1 HIGHEST FREQUENCY OF CALLS

    if( !pbTls ) { BLAMMO ; }

    }
        countT foo = 2 ;
    {
    if( !thirdC::c_strcmpIF( *this , postThreadName , "tmWorkerF" ) )

    tlsCheckF() ;
    //if( !thirdC::c_strcmpIF( tin0P , postThreadName , "tmNodeF" ) ) tlsTraceF() ; //U::DISABLE IN PRODUCTION

    }
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    POOPIES

    tin0S& tin0P = *this ;
{
/*1*/byteT* tin123S::tlsNewF( const countT idLineP , const countT idiFileP , const countT cbP , const osTextT* const postNameP , const osTextT* const postInGroupP )/*1*/

//
//    postInGroup
//    postName
//    costaInGroup (includes null terminator; if 0 then class is unnamed)
//    costaName (includes null terminator; if 0 then object is unnamed)
//    offNextInGroup (set to 0 by constructing entry)
//    offNextObject (set to 0 by constructing entry; if null then terminates the tls stack
//    offElder (address of entry immediately below me) (0 indicates that i am the bottommost entry)
//    cRef (number of instances including the constructing instance; is never 0)
//    cbEntry (exclusive prefix)
//   tls entry
//    th.offTopEntry (address of lath entry constructed); this is redundant; it is for speed and to detect corruption
//   tls header
//
// TLS LAYOUT

/**/
*/
caller must d elete tls pointers lifo
if i allocate unnamed bytes then i do not initialize them
if i allocate named bytes then i initialize those bytes to 0
if there was no bytes associated with this name and group, i allocate those bytes
i evaluate to the address of cbP bytes associated with the specified name and group
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

