
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    }
        }
            }
                thirdC::c_systemIF( tin0P , tCommand ) ;
                //ether.traceF( tin0P , tCommand+T("    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++") ) ;

                ;

                    +T(" validate=no > nul")+tCRLF
                    )
                                : tRegisterBoth
                                ? tRegisterPrimary
                            : !ether.strCompareF( tin0P , psttzSuffix , tPrimaryOnly )
                            ? tRegisterNone
                        !ether.strCompareF( tin0P , psttzSuffix , tNone )
                    (
                    +
                    +T(!offPass?"127.0.0.1 ":"::1 ")
                    +T("\" source=static address=")
                    T(psttzlName)

                TN( tCommand , !offPass ? "netsh interface ipv4 set dnsservers name=\"" : "netsh interface ipv6 set dnsservers name=\"" ) ; tCommand +=

                // netsh interface ipv4 set dnsservers name="foo"  source=static address=1.2.3.4 register=none validate=no > nul

                while( ~hWalk ) ;
                }
                    //ether.traceF( tin0P , tb8+T(pstta) ) ;
                    strokeS* pstta = (strokeS*)swsAddressesUse.downF( tin0P , hWalk ) ;
                {
                do
                handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( swsAddressesUse )

            //ether.traceF( tin0P , T("*************************************    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzSuffix)+tb4+T(psttzlName) ) ;
            strokeS* psttzSuffix = (strokeS*)(countT&)swSuffixUse ;
            countT idType = swTypeUse ;
            psttzlName = (strokeS*)swTypeUse.leverF( tin0P , idf ) ;
    
            _IO_
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swTypeUse.cFlavorsF( tin0P ) ;

        switchStackC& swsAddressesUse = !offPass ? swsAddresses4 : swsAddresses6 ;
        switchC&      swSuffixUse     = !offPass ? swSuffix4     : swSuffix6     ;
        switchC&      swTypeUse       = !offPass ? swType4       : swType6       ;
        //ether.traceF( tin0P , T(!offPass?"====================================================== IPV4 ==========================================================":"====================================================== IPV6 ==========================================================") ) ;
    {
    for( countT offPass = 0 ; offPass <= 1 ; offPass ++ )
    //ether.traceF( tin0P , T("****************************************************************************************************************************************************************************************************************************************************************") ) ;
    // SET DNS TO LOOPBACK FOR ALL INTERFACES THAT HAVE DNS ADDRESSES

    }
        }
            }
                }
                    }
                        }
                            swSuffixUse = (countT)pstts ;
                            ether.strTrimF( tin0P , pstts ) ; ___( pstts ) ;
                            ether.strSubstringF( tin0P , pstts , idf , sttq , tCRLF , psttBig ) ; ___( pstts ) ;
                            ZE( strokeS* , pstts ) ;
                        {

                        ether.delF( tin0P , pstt1Addresses ) ;
                        }
                            swsAddressesUse << psttLower ;
                            ether.strConvertToLowerCaseF( tin0P , psttLower , psttc1 ) ; ___( psttLower ) ;
                            ZE( strokeS* , psttLower ) ;
                        {
                        FORsTRINGSiN1( pstt1Addresses )
                        ether.strWordsF( tin0P , pstt1Addresses , tAddresses , sttq , T(" \r\n") ) ; ___( pstt1Addresses ) ;
                        ZE( strokeS* , pstt1Addresses ) ;
                    {
                    if( ether.strCompareF( tin0P , tNone , tAddresses ) )

                    ether.delF( tin0P , pstts ) ;
                    TN( tAddresses , pstts ) ;
                    ether.strTrimF( tin0P , pstts ) ; ___( pstts ) ;
                    ether.strSubstringF( tin0P , pstts , idf , sttq , t4 , psttBig ) ; ___( pstts ) ;
                    ZE( strokeS* , pstts ) ;
                    swTypeUse = idType1Dhcp2Static ;
                {
                if( idType1Dhcp2Static )

                else if( !ether.strCompareF( tin0P , tMatch , t3 ) ) idType1Dhcp2Static = 2 ;
                else if( !ether.strCompareF( tin0P , tMatch , t2 ) ) idType1Dhcp2Static = 1 ;
                }
                    psttzlName = tName ;
                    ////ether.traceF( tin0P , tName ) ;
                    ether.delF( tin0P , pstts ) ;
                    tName = T(pstts) ;
                    ether.strTrimF( tin0P , pstts ) ; ___( pstts ) ;
                    ether.strSubstringF( tin0P , pstts , idf , sttq , tq , psttBig ) ; ___( pstts ) ;
                    ZE( strokeS* , pstts ) ;
                {
                if( !ether.strCompareF( tin0P , tMatch , t1 ) )
                ZE( countT , idType1Dhcp2Static ) ;

                }
                    break ;
                    ether.delF( tin0P , psttm ) ;
                    ////ether.traceF( tin0P , tMatch ) ;
                    tMatch = T(psttm) ;
                    stMatch >> psttm ;
                    ZE( strokeS* , psttm ) ;
                {
                while( stMatch )
                TN( tMatch , "" ) ;

                ////ether.traceF( tin0P , T("[idf]  :    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                ////ether.traceF( tin0P , T("[idHit]:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                countT idHit = ether.strIdF( tin0P , &stMatch , flSTRmATCH_REPORTmATCH , idf , sttq , psttre , psttBig , 0 , 1 ) ;
                stackC stMatch( tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
            {
            while( idf )
            TN( tName , "" ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;

            ////ether.traceF( tin0P , tListRaw , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

            strokeS* psttBig = tListRaw ;
            strokeS* psttre = tre ;

            ether.delF( tin0P , posti ) ;
            TN( tListRaw , posti ) ;
            ether.boxGetF( tin0P , posti , costi , T("///c/doodle.ttt") ) ; ___( posti ) ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;

            thirdC::c_systemIF( tin0P , !offPass ? "netsh interface ipv4 show dnsservers > c:\\doodle.ttt" :  "netsh interface ipv6 show dnsservers > c:\\doodle.ttt" ) ;

            switchStackC& swsAddressesUse = !offPass ? swsAddresses4 : swsAddresses6 ;
            switchC&      swSuffixUse     = !offPass ? swSuffix4     : swSuffix6     ;
            switchC&      swTypeUse       = !offPass ? swType4       : swType6       ;
        {
        for( countT offPass = 0 ; offPass <= 1 ; offPass ++ )

        ;

            +S2(sa_SSSaNDeND,sc_ccSSS)
                +S2(sa_SSSrEPORTmATCHeND,sc_ccSSS)
                   +S2(sa_SSSoReND,sc_ccSSS)
                       +S2(sa_SSSaNDeND,sc_ccSSS)
                           +t4
                       +S2(sa_SSSaND,sc_ccSSS)
                       +S2(sa_SSSaNDeND,sc_ccSSS)
                           +t3
                       +S2(sa_SSSaND,sc_ccSSS)
                       +S2(sa_SSSaNDeND,sc_ccSSS)
                           +t2
                       +S2(sa_SSSaND,sc_ccSSS)
                       +S2(sa_SSSaNDeND,sc_ccSSS)
                           +t1
                       +S2(sa_SSSaND,sc_ccSSS)
                   +S2(sa_SSSoR,sc_ccSSS)
                +S2(sa_SSSrEPORTmATCH,sc_ccSSS)                  // 123456789abcde
            +S2(sa_SSSaND,sc_ccSSS)

        TN( tre , "" ) ; tre += tn

        TN( t4 , "Register with which suffix:" ) ;
        TN( t3 , "Statically Configured DNS Servers:" ) ;
        TN( t2 , "DNS servers configured through DHCP:" ) ;
        TN( t1 , "Configuration for interface \"" ) ;
        TN( tNone , "None" ) ;
        TN( tq , "\"" ) ;
        TN( tn , "" ) ;
    {

    SCOOP
{
tRegisterBoth(    tin0P ,         TAG( TAGiDnULL ) , flTEXTc_null            , "register=both"    )
tRegisterPrimary( tin0P ,         TAG( TAGiDnULL ) , flTEXTc_null            , "register=primary" ) ,
tRegisterNone(    tin0P ,         TAG( TAGiDnULL ) , flTEXTc_null            , "register=none"    ) ,
tPrimaryOnly(     tin0P ,         TAG( TAGiDnULL ) , flTEXTc_null            , "Primary only"     ) ,
tNone(            tin0P ,         TAG( TAGiDnULL ) , flTEXTc_null            , "None"             ) ,
tCRLF(            tin0P ,         TAG( TAGiDnULL ) , flTEXTc_null            , "\r\n"             ) ,
tb8(              tin0P ,         TAG( TAGiDnULL ) , flTEXTc_null            , "        "         ) ,
tb4(              tin0P ,         TAG( TAGiDnULL ) , flTEXTc_null            , "    "             ) ,
swsAddresses6(    tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ,
swsAddresses4(    tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ,
swSuffix6(        tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName ) ,
swSuffix4(        tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName ) ,
swType6(          tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName ) ,
swType4(          tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName ) ,
psttzlName( 0 ) ,
poop(  etherP ) ,
ether( etherP ) ,
/*1*/ideaNetC::ideaNetC( tin0S& tin0P , etherC& etherP ) :/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
