
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.delF( tinBaseP , pbOut ) ;
etThread.delF( tinBaseP , pbIn ) ;
etThread.delF( tinBaseP , pcCode ) ;

//etThread.strokeF( tinBaseP , T("out: \"")+T(pbOut)+T("\"\r\nin:  \"")+T(pbIn)+T("\"\r\n") ) ;

etThread.boxPutF( tinBaseP , T("///d/test.copy") , pbIn , cbIn ) ;
etThread.strokeF( tinBaseP , T("done\r\n") ) ;

dad( tinBaseP , pbIn , cbIn , pcCode , ccCode ) ; ___( pbIn ) ;
ZE( countT , cbIn ) ;
ZE( byteT* , pbIn ) ;
etThread.strokeF( tinBaseP , T("phase 2: decoding\r\n") ) ;

//etThread.strokeF( tinBaseP , T("\r\n") ) ;
//for( countT off = 0 ; off < ccCode ; off ++ ) etThread.strokeF( tinBaseP , TF3(pcCode[off],flFORMAT_UNSIGNED,8)+T(off%8==7?"\r\n":" ") ) ;
//etThread.strokeF( tinBaseP , T("code:\r\n") ) ;

etThread.boxPutF( tinBaseP , T("///d/test.codes") , (byteT*)pcCode , ccCode * sizeof( countT ) ) ;

mom( tinBaseP , pcCode , ccCode , pbOut , cbOut ) ; ___( pcCode ) ;
ZE( countT  , ccCode ) ;
ZE( countT* , pcCode ) ;
etThread.strokeF( tinBaseP , T("phase 1: encoding\r\n") ) ;

etThread.boxGetShadowF( tinBaseP , pbOut , cbOut , T("///d/test") ) ; ___( pbOut ) ;
ZE( countT , cbOut ) ;
ZE( byteT* , pbOut ) ;
//byteT*  pbOut   = "wxyzwxyzwxyz" ;

spouseC dad( tinBaseP , etThread ) ;
spouseC mom( tinBaseP , etThread ) ;

TODO

}
    }
        pbP[ off ] = 0 ;
        for( countT off = 0 ; off < ccP ; off ++ ) pbP[ off ] = (*this)( tinBaseP , pcP[ off ] ) ;
    {
    if( pbP )
    ether.newF( tinBaseP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
    cbP = ccP ;
    if( !ccP ) ccP = ether.strBodyLengthF( tinBaseP , pcP ) ;
{
voidT spouseC::operator ()( tinBaseS& tinBaseP , byteT*& pbP , countT& cbP , const countT* const pcP , countT ccP )

}
    if( pcP ) for( countT off = 0 ; off < cbP ; off ++ ) pcP[ off ] = (*this)( tinBaseP , pbP[ off ] ) ;
    ether.newF( tinBaseP , LF , pcP , ccP ) ; ___( pcP ) ;
    ccP = cbP ;
    if( !cbP ) cbP = ether.strBodyLengthF( tinBaseP , pbP ) ;
{
voidT spouseC::operator ()( tinBaseS& tinBaseP , countT*& pcP , countT& ccP , const byteT* const pbP , countT cbP )

}
    return bb ;

    pbInAll[ offIn ++ ] = bb ;

    byteT bb = pbInAll[ offPrior ] ;

    if( !( offIn % 0x100 ) ) { CONoUTrAW( "." ) ; }

    countT offPrior = offIn - cP ;

    }
        offIn ++ ;
        pbInAll[ offIn ] = (byteT)offIn ;
    {
    while( offIn < 0x100 )
{
byteT spouseC::operator ()( tinBaseS& tinBaseP , const countT cP ) //"dad" LISTENER, DECODER

}
    return ( offIn ++ ) - code ; //SET code TO THE BACKWARD OFFSET OF THE OCCURANCE

    swsOff << offIn ;

    else                 code = bP ;
    else if( swsOff )    code = swsOff[ 1 ] ;
    if( swsOff > 0x100 ) swsOff >> code ;
    lever = bP ;
    ZE( countT , code ) ; //SET code TO THE ABSOLUTE OFFSET OF AN EARLIER OCCURANCE

    if( !offIn ) offIn = 0x100 ;
{
countT spouseC::operator ()( tinBaseS& tinBaseP , const byteT bP ) //"mom" TALKER, ENCODER

}
    ether.memSetF( tinBaseP , pbInAll , cbInAllMax + 1 ) ;
    ether.newF( tinBaseP , LF , pbInAll , cbInAllMax + 1 ) ; ___( pbInAll ) ;
    cbInAllMax = 0x10000 ;
{
cbInAllMax( 0 )
cbInAll( 0 ) ,
pbInAll( 0 ) ,
offIn( 0 ) ,
swsOff( tinBaseP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , lever , flSTACKc_FIFO ) ,
lever( 0 ) ,
ether( etherP ) ,
spouseC::spouseC( tinBaseS& tinBaseP , etherC& etherP ) :

}
    ether.delF( tinBaseP , pbInAll ) ;
    TINSL
{
spouseC::~spouseC( voidT )

;
}
  voidT operator ()( tinBaseS& tinBaseP , byteT*& pbP , countT& cbP , const countT* const pcP , countT ccP ) ;
  voidT operator ()( tinBaseS& tinBaseP , countT*& pcP , countT& ccP , const byteT* const pbP , countT cbP = 0 ) ;
 /*utilities*/

  byteT operator ()( tinBaseS& tinBaseP , const countT cP ) ; //IF THIS IS USED, CALL THE OBJECT "dad" (LISTENER)
  countT operator ()( tinBaseS& tinBaseP , const byteT bP ) ; //IF THIS IS USED, CALL THE OBJECT "mom" (TALKER)
 /*encode,decode*/ //EACH spouseC OBJECT IS EITHER THE TALKER (ENCODER,MOM) OR THE LISTENER (DECODER,DAD)

  spouseC( tinBaseS& tinBaseP , etherC& etherP ) ;
  ~spouseC( voidT ) ;
 /*birth,death*/

 public :

 countT       cbInAllMax ;
 countT       cbInAll ;
 byteT*       pbInAll ;
 countT       offIn ;
 switchStackC swsOff ;
 countT       lever ;
 etherC&      ether ;
{
class spouseC

/*1*/WAKEhIDE( "doodle.spouseC" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

