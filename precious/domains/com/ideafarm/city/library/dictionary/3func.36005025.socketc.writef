
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
    
        ((tin1S&)tin0P).pag3->_socketC_.grab.ungrabF( tin0P ) ;
        pOdometer->cbWrite += ((tin1S&)tin0P).odoSockCbWrite - _odoSockCbWriteOpen ;
        pOdometer->cbRead  += ((tin1S&)tin0P).odoSockCbRead  - _odoSockCbReadOpen  ;
        pOdometer = (sockOdometerS*)&(countT&)*((tin1S&)tin0P).pag3->_socketC_.pSwOdometer ;
        ((tin1S&)tin0P).pag3->_socketC_.nnLever = nnPeer ;
        ((tin1S&)tin0P).pag3->_socketC_.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    
        bWrite.ungrabF( tin0P ) ;
    
        if( idleTimeAllowedWrite ) FRESHtIMEaTOMIC( *pEther , timeLathWrite.time1 , timeLathWrite.time2 )
    
        }
            }
                }
                    pEther->delF( tin0P , pcCode ) ;
                    else                     writeF( tin0P , (byteT*)pcCode , sizeof( count01T ) * ccCode ) ;
                    if( !pcCode || !ccCode ) __1
            
                    mom( tin0P , pcCode , ccCode , pbOut , cbOut , pczPillNameP , bPinP ) ; ___( pcCode ) ;
                    ZE( countT    , ccCode ) ;
                    ZE( count01T* , pcCode ) ;
            
                    countT cbOut = 3 * sizeof( countT ) + cbTrailer ;
                {
                if( pbOut )
    
                }
                    else pbOut = 0 ;
                    }
                        cbTrailer = *(countT*)pbc ;
                        idFormat  = *(countT*)pbc ; pbc += sizeof( countT ) ;
                                                    pbc += sizeof( countT ) ;
                    {
                    if( pbc && getNegAM( *(countT*)pbc ) == FINGERnEG_SOULc )
                    const byteT* pbc = pbOut ;
                    ZE( countT , idFormat ) ;
                {
                ZE( countT , cbTrailer ) ;
                const byteT* pbOut = soulP ;
            {
            else if( !*pEther )
            }
                THREADmODE1rESTORE

                }
                    pEther->sockWriteF( tin0P , handle , soulP ) ;
                    //etherC::etRockIF( tin0P ).traceF( tin0P , T("flSOCKETc_CRYPTfOREIGNsSL is not set") ) ;
                {
                else
                }
                    pEther->openSslTls_writeF( tin0P , handle , WS( soulP ) ) ;
                    armSslC armMe( tin0P , flagsOpenSslFails ) ;
                    //etherC::etRockIF( tin0P ).traceF( tin0P , T("flSOCKETc_CRYPTfOREIGNsSL is     set") ) ;
                {
                if( F(flags) & flSOCKETc_CRYPTfOREIGNsSL )

                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            {
            if( F(flags) & flSOCKETc_NOsECRECY )
        {
        if( bPayload )
    
        }
            }
                }
                    /*default :*/ { __( idCmdTopSecretP ) ; /*break ;*/ }
                {
                //switch( idCmdTopSecretP )
                bPayload = 0 ;
            {
            if( idCmdTopSecretP != ifcIDcMDsOCKETtOPsECRET_PAYLOAD )
    
            writeF( tin0P , (byteT*)&idCmdTopSecretP , sizeof idCmdTopSecretP ) ;
            if( !idCmdTopSecretP ) idCmdTopSecretP = ifcIDcMDsOCKETtOPsECRET_PAYLOAD ;
    
    
            }
                }
                    break ;
    
                    (*pEther)( tin0P , pSoul ) ;
                    }
                        }
                            (*pEther)( tin0P , psFinger ) ;
                            }
                                writeF( tin0P , *psFinger ) ;
                                *psFinger << (countT)FINGERnEG_SOCKETsECREThANDSHAKE ;
                            {
                            if( psFinger )
                            (*pEther)( tin0P , psFinger , TAG( TAGiDnULL ) ) ;
                            ZE( soulC* , psFinger ) ;
    
                            pEther->delF( tin0P , pcCode ) ;
                            }
                                writeF( tin0P , (byteT*)pcCode , ccCode * sizeof( count01T ) ) ;
                                writeF( tin0P , (byteT*)&ccCode , sizeof ccCode ) ;
        
                                writeF( tin0P , (byteT*)&idCmd , sizeof idCmd ) ;
                                countT idCmd = ifcIDcMDsOCKETtOPsECRET_3APPLYtHISpINrEFERENCE ;
                            {
                            else
                            if( !pcCode || !ccCode ) __1
                    
                            mom( tin0P , pcCode , ccCode , 0 , 0 , pczKeyTopSecretPeer , 1 ) ; ___( pcCode ) ;
                            ZE( countT    , ccCode ) ;
                            ZE( count01T* , pcCode ) ;
                        {
    
                        //CONoUT( "sending reference" ) ;
                    {
                    if( pSoul )
                    (*pEther)( tin0P , pSoul , TAG( TAGiDnULL ) ) ;
                    ZE( soulC* , pSoul ) ;
                    idPhaseTopSecret = ifcIDpHASEsOCKETtOPsECRET_4SECURED ;
                {
                case ifcIDpHASEsOCKETtOPsECRET_3SENDpINrEFERENCE :
                }
                    }
                        }
                            break ;
                            }
                                writeF( tin0P , (byteT*)&idCmd , sizeof idCmd ) ;
                                countT idCmd = ifcIDcMDsOCKETtOPsECRET_2SENDpINiMAGEsECRETLY ;
                            {
                            if( homeS::homeIF().cSecretServerRegistrationsSeen )
                        {
                        else
                        if( pEther->diskFileExistsF( tin0P , tLongPeer ) ) idPhaseTopSecret = ifcIDpHASEsOCKETtOPsECRET_3SENDpINrEFERENCE ;
    
                        TN( tLongPeer , "" ) ; tLongPeer = T("///desk/" POSTfOLDERsECURITYkEYdEPOSITORY)+(idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/")+tShort ;
                        countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;
                        textC tShort( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , (countT*)pczKeyTopSecretPeer , flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE , 8 , 0 , tDot ) ;
                        TN( tDot , "." ) ;
                    {
                    else
                    if( !pczKeyTopSecretPeer ) break ;
                {
                case ifcIDpHASEsOCKETtOPsECRET_2REQUESTpINiMAGE :
                }
                    break ;
    
                    }
                        (*pEther)( tin0P , pSoul ) ;
                        }
                            writeF( tin0P , *pSoul ) ;
                            homeS::homeIF().idptRelay >> *pSoul ;
                            *pSoul << pczKeyTopSecret ;
                        {
                        if( pSoul )
                        (*pEther)( tin0P , pSoul , TAG( TAGiDnULL ) ) ;
                        ZE( soulC* , pSoul ) ;
        
                        writeF( tin0P , (byteT*)&idCmd , sizeof idCmd ) ;
                        countT idCmd = ifcIDcMDsOCKETtOPsECRET_1MYpINnAMEiS ;
        
                        idPhaseTopSecret = ifcIDpHASEsOCKETtOPsECRET_2REQUESTpINiMAGE ;
                    {
                    if( pczKeyTopSecret && homeS::homeIF().idptRelay )
                {
                case ifcIDpHASEsOCKETtOPsECRET_1SENDpINnAME :
            {
            switch( idPhaseTopSecret )
    
            BLAMMO ; //U::flSOCKETc_TOPsECRET IS NOT YET SUPPORTED; IT WORKS AND CODING IS COMPLETE, BUT DEADLOCK OCCURS 1/2 OF TIME; DISABLED PENDING COMPLETION OF MONITOR
        {
        if( F(flags) & flSOCKETc_TOPsECRET )
        boolT bPayload = 1 ;
    
        bWrite.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    
        const countT _odoSockCbWriteOpen = ((tin1S&)tin0P).odoSockCbWrite ;
        const countT _odoSockCbReadOpen  = ((tin1S&)tin0P).odoSockCbRead  ;
    
        _IO_
    
        }
            }
                return ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL    
        SCOOPP
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/voidT socketC::writeF( tin0S& tin0P , soulC& soulP , const countT* const pczPillNameP , const boolT bPinP , countT idCmdTopSecretP )/*1*/

/**/
*/
  if flSOCKETc_TOPsECRET and not 0 then soulP is interpreted as arguments to the specified command
   equivalent to specifying ifcIDcMDsOCKETtOPsECRET_PAYLOAD
  if flSOCKETc_TOPsECRET and 0 then soulP is handled as data to be sent
  if not flSOCKETc_TOPsECRET then ignored
  normally 0
 idCmdTopSecretP
 bPinP
   only a reference to that pill file will be sent over the connection
  if not 0 then the codes for the soulP image will be written to a pill file
  normally 0
 pczPillNameP
  else see idCmdTopSecretP
  if not flSOCKETc_TOPsECRET then the image of soulP is written
 soulP
 tin0P
arguments
\<A HREF=\"5.1070028.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$writeF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

