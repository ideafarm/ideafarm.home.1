
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //CONoUTrAW( " *********************************************************************************************************\r\n" ) ;
    //CONoUTrAW( guts.postName ) ;
    //CONoUTrAW( " poolC/-:  " ) ;

    }
        stPoolNames.sinkF( tinBaseP , countTC() , (countT)guts.postName ) ;
        stackC& stPoolNames = ((tinFullS&)tinBaseP).pEther->ifcStkPoolNamesF( tinBaseP ) ;
    {
    if( ((tinFullS&)tinBaseP).pEther )                                                                               // CS:CODEsYNC: 360e2003 360e2003

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // REGISTER MY NAME SO THAT tmWatchF CAN SEE WHICH poolC NAMES THIS PROCESSES IS USING
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        THREADmODE3rESTORE
        }
            }
                listC::indexIF( tinBaseP , hList ) ;

                //CONoUTrAW( "\"\r\n" ) ;
                //CONoUTrAW( postNameP ) ;
                //CONoUTrAW( "poolC / indexing list root/application of \"" ) ;
            {
            if( ~hList )

            listC::openIF( tinBaseP , hList , pczName , flLISToPEN_IFeXISTS ) ;
            countT pczName[] = { LISTnAMEsYS_ROOT , LISTnAMEsYS_ROOTaPPLICATION , 0 } ;
            handleC hList( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

            puseC puseMe( tinBaseP , *this ) ;
        {
        THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY )
    {                                                                                                                   // INDEX ALL OF MY DATUM VALUES
    )
        && !( F(flagsP) & flPOOLc_DOnOTiNDEXdURINGcT                                 )                                  // MY CALLER DIDN'T FORBID ME TO INDEX MYSELF               (DO NOTHING IF I AM TOLD TO DO NOTHING)
        && !( F(napFace.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED )                                  // MY BACKING IMAGE DIDN'T ALREADY EXIST                    (DO NOTHING IF BACKING DATA ALREADY EXISTED BECAUSE ITS CREATOR PRESUMABLY INDEXED IT ALL)
           !( F(flagsInstance) & flPOOLiNSTANCE_NAPfACEfORMATTEDbYmE                 )                                  // I DIDN'T FORMAT MY BACKING IMAGE                         (DO NOTHING IF I FORMATTED MY BACKING IMAGE BECAUSE THERE IS NO DATA TO INDEX)
    (
    if

    // INDEX IFF NEW INTO MEMORY... (OPTIMIZATION:)... UNLESS I FORMATTED, WHICH IMPLIES THAT THERE IS NO CONTENT YET

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // MAYBE INDEX ALL OF MY DATUM VALUES
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        if( ~hList ) listC::resetIndexBitsIF( tinBaseP , hList ) ;

        listC::openIF( tinBaseP , hList , pczName , flLISToPEN_IFeXISTS ) ;
        countT pczName[] = { LISTnAMEsYS_ROOT , LISTnAMEsYS_ROOTaPPLICATION , 0 } ;
        handleC hList( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

        puseC puseMe( tinBaseP , *this ) ;
    {
    if( F(flagsP) & flPOOLc_RESETiNDEXbITS )

    ((tinFullS&)tinBaseP).flagsThreadMode2 = saveThreadMode2 ;

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // MAYBE RESET ALL INDEX BITS
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    batPoolCt.ungrabF( tinBaseP ) ;
                                                                                                        // CS:CODEsYNC: 360e2003 360e2003
    else if( !((tinFullS&)tinBaseP).pEther                      ) { BLAMMO ; }                                           // IT IS ILLEGAL TO CT A poolC INSTANCE OTHER THAN THOSE WHICH ARE REGISTERED IN tinBaseP IF !((tinFullS&)tinBaseP).pEther BECAUSE I WILL NOT BE ABLE TO REGISTER MY NAME INTO stPoolNames
    else if( this == (poolC*)((tinFullS&)tinBaseP).pag1->pbzphp )                 ((tinFullS&)tinBaseP).pag1->pPoolHomePerm = this ;
    else if( this == (poolC*)((tinFullS&)tinBaseP).pag1->pbzpap )                 ((tinFullS&)tinBaseP).pag1->pPoolAdamPerm = this ;
    else if( this == (poolC*)((tinFullS&)tinBaseP).pag1->pbzpsc )                 ((tinFullS&)tinBaseP).pag1->pPoolScratch  = this ;
    else if( this == (poolC*)((tinFullS&)tinBaseP).pag1->pbzpht )                 ((tinFullS&)tinBaseP).pag1->pPoolHomeTemp = this ;
         if( !((tinFullS&)tinBaseP).pag1->pPoolAdamTemp         ) ((tinFullS&)tinBaseP).pPoolUse = ((tinFullS&)tinBaseP).pag1->pPoolAdamTemp = this ; //A:ASSUME: THE ADAM TEMP POOL IS CT WOTH

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // REGISTER MYSELF AS AN ADAM/HOME TEMP/PERM (OR SCRATCH) INSTANCE
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    processGlobal5I._poolC_grab_pPool.ungrabF( tinBaseP ) ;

    }
        ((tinFullS&)tinBaseP).pEther->osThreadF( TaRG1( tmPoolFlushF ) ) ;
        puseC puseat( tinBaseP , ifcIDpOOL_ADAMtEMP ) ;
    {
    if( idStateSpaceP && ! processGlobal2I._poolC_cBacked ++ )

            processGlobal2I._poolC_pPool = this ;
    pNext = processGlobal2I._poolC_pPool ;

    processGlobal5I._poolC_grab_pPool.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
    
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // LAUNCH tmPoolFlushF IF NOT YET LAUNCHED
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        }
            }
                }
                    guts.pGrabNewElt[ offs ].ungrabF( tinBaseP ) ;

                    guts.ppSlots[ offs ]->makeSexF( tinBaseP , expSlotsWanted ) ;

                    }
                        guts.ppSlots[ offs ] = new( 0 , tinBaseP , guts.pbza + offs * sizeof( slotsC ) , sizeof( slotsC ) ) slotsC( tinBaseP , TAG( TAGiDnULL ) , LF , ostoName , guts.cBitsExpCbDrop , offs , face.pcCbDropAdjust[ offs ] , face.cbDropSeparator , flagsc , guts.idStateSpace , guts.idMemorySpace , this ) ;
        
                        if( F(guts.flagsCt) & flPOOLc_NOdROPhEADERS ) flagsc |= flSLOTSc_NOdROPhEADERS ;
                        if( F(guts.flagsCt) & flPOOLc_NOsEXiNpOOL   ) flagsc |= flSLOTSc_NOsEXiNpOOL   ;
                        if( F(guts.flagsCt) & flPOOLc_NOTES         ) flagsc |= flSLOTSc_NOTES         ;
                        if( F(guts.flagsCt) & flPOOLc_READoNLY      ) flagsc |= flSLOTSc_READoNLY      ;
                        flagsT                                        flagsc  = flSLOTSc_null          ;
                    {
                    if( !guts.ppSlots[ offs ] )

                    guts.pGrabNewElt[ offs ].grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
    
                    //CONoUTrAW( "\r\n" ) ;
                    //CONoUTrAW( ostoName ) ;
    
                    OStEXTCF( ostoName , offs , '0' ) ;
                    OStEXTAK( ostoName , ".slots." ) ;
                    OStEXTA(  ostoName , ostoNameGroup ) ;
                    OStEXT(   ostoName , TUCK << 2 )

                    countT offs = expCbDropWanted ;
                {
                if( guts.expCbDropMin <= expCbDropWanted && expCbDropWanted <= guts.expCbDropMax )

                countT expSlotsWanted  = *pczHintPreallocationP >> SB & ( 1 << SB ) - 1 ;
                countT expCbDropWanted = *pczHintPreallocationP       & ( 1 << SB ) - 1 ;
                boolT  bAll            = *pczHintPreallocationP       & BM_HIGH2        ;           //U:: OBEY THIS
            {
            for( ; *pczHintPreallocationP ; pczHintPreallocationP ++ )
        {
        if( pczHintPreallocationP )
    
        // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
        // EARLY CONSTRUCT THE slotsC INSTANCE FOR EACH HINT expCbDrop
        // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

        refresh_ppSlots_F( tinBaseP ) ;
    
        // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
        // EARLY CONSTRUCT THE slotsC INSTANCE FOR EACH expCbDrop FOR WHICH SOME BACKING MEMORY (FOR A sexC INSTANCE) EXISTS
        // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

        OStEXTAK( ostoNameGroup , ".poolC" ) ;
        OStEXTA(  ostoNameGroup , guts.postName ) ;
        OStEXT(   ostoNameGroup , TUCK << 2 )
        //CS:CODEsYNC: 360e2003 360e201c
    
        //CONoUTrAW( " *********************************************************************************************************\r\n" ) ;
        //CONoUTrAW( guts.postName ) ;
        //CONoUTrAW( " poolC/+:  " ) ;
    
        puseC puse( tinBaseP , ifcIDpOOL_NONE ) ;
    {

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // EARLY CONSTRUCT ALL slotsC INSTANCES THAT I WANT
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        }
            }
                ++ s ; thirdC::dosSleepWinkIF( tinBaseP ) ;
                etherC::etRockIF( tinBaseP ).traceF( tinBaseP , (strokeS*)"poolC / registration / waiting for a free slot" , flTRACE_PARAMETERiSoStEXT ) ;

                if( bDone ) break ;
                }
                    }
                        }
                            break ;
                            bDone = 1 ;        
                            pRegs[ offr ].flagsi |= fliPOOLrEGISTRATIONs_FORMATTED ;
                            thirdC::c_strcpyIF( tinBaseP , pRegs[ offr ].postPoolName , postNameP ) ;
                            pRegs[ offr ].resetF( tinBaseP ) ;
                        {
                        if( !setIfZeAM( pRegs[ offr ].cRefPoolReg , 1 ) )
                        grabitC grabx( tinBaseP , TAG( TAGiDnULL ) , (byteT*)&pRegs[ offr ].flagsi , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_null , 0 , ifcIDgRABlAYER_9POOLlAYER3 ) ;
                    {
                    if( !bDone ) for( countT offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )

                    }
                        }
                            break ;
                            bDone = 1 ;        
                            inc02AM( pRegs[ offr ].cRefPoolReg ) ;
                        {
                        if( pRegs[ offr ].flagsi & fliPOOLrEGISTRATIONs_FORMATTED && !thirdC::c_strcmpIF( tinBaseP , pRegs[ offr ].postPoolName , postNameP ) )
                        grabitC grabx( tinBaseP , TAG( TAGiDnULL ) , (byteT*)&pRegs[ offr ].flagsi , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_null , 0 , ifcIDgRABlAYER_9POOLlAYER2) ;
                    {
                    for( countT offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )

                    grabitC grabx( tinBaseP , TAG( TAGiDnULL ) , (byteT*)&home.fliGrab , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_null , 0 , ifcIDgRABlAYER_9POOLlAYER1 ) ;
                {
                ZE( boolT , bDone ) ;
            {
            for(;;)
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        {

        //   nap
        //  if !done
        //  ungrab array
        // 
        //     break
        //     set done
        //     format
        //    if set cRef from 0 to 1
        //   for each array element
        //  if !done
        //    break
        //    set done
        //    update
        //   if formatted and name matches
        //  for each array element
        //  grab array
        // while( !done )
        // 
        // RECIPE

        ZE( countT , offr ) ;
        poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;
        homeS& home = homeS::homeIF() ;
        // THIS MEANS THAT poolC INSTANCES THAT ARE REGISTERED ARE NOT NECESSARILY FULLY CONSTRUCTED AND USEABLE
    {   // *this IS REGISTERED EARLY AND DEREGISTERED LATE BECAUSE sexC CONSTRUCTORS AND DESTRUCTORS MUST REFER TO IT

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // CREATE AND FORMAT REGISTRATION RECORD OR WAIT UNTIL ANOTHER poolC INSTANCE HAS DONE SO
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    napGuts.formattingIsDoneF( tinBaseP ) ; //MUST BE DONE AFTER napFace IS FULLY CT SO THAT ((tinFullS&)tinBaseP).idDesireSetBySelf IS UNWOUND CORRECTLY
    new( 0 , tinBaseP , &napGuts ) guts_poolC_S( tinBaseP , idLineCtP , idiFileCtP , pbBitsCtP , postNameP , flagsP , idStateSpaceP , expCbDropMinP , expCbDropMaxP , idMemorySpaceP ) ;
    
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // FORMAT napGuts
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        ((face_poolC_S*)(byteT*)napFace)->cRef = 1 ;
        CONoUTrAW3( " resetting poolC cRef to 1 from " , ((face_poolC_S*)(byteT*)napFace)->cRef , "\r\n" ) ;
    {
    if( F(flagsP) & flPOOLc_RESETcrEF && ((face_poolC_S*)(byteT*)napFace)->cRef != 1 ) //A:ASSUME: I AM NOT RACING WITH ANOTHER PROCESS TO ctFaceF()

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // MAYBE RESET cRef
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    //20170830@2027: ctFaceF WAS CALLED HERE.  MOVED TO EARLIER TO AVOID RECURSIVELY GRABBING GRABmEMORYsPACE

    if( F(((tinFullS&)tinBaseP).flagsThreadMode3) & flTHREADmODE3_DISALLOWpUSE ) { BLAMMO ; }

    }
        if( aptnu ) ;
        aptC& aptnu = aptListRootF() ;
    {
    //U:: TO FIND A BUG

    }
        __( cbDropSeparatorP && cbDropSeparatorP - sizeof( countT ) ) ;
        __( idMemorySpaceP && ( idMemorySpaceP < ifcIDmEMORYsPACE_min || idMemorySpaceP > ifcIDmEMORYsPACE_max ) ) ;
        FV( flPOOLc , flagsP ) ;
        FV( flTHREADmODE2 , ((tinFullS&)tinBaseP).flagsThreadMode2 ) ;
        FV( flTHREADmODE2 , saveThreadMode2 ) ;
    {
    IFbEcAREFUL

                                                    ((tinFullS&)tinBaseP).tlsDelF( LF , countTC() ) ; //TLS:1
                                                    ((tinFullS&)tinBaseP).tlsDelF( LF , countTC() ) ; //TLS:2
                                                    ((tinFullS&)tinBaseP).tlsDelF( LF , countTC() ) ; //TLS:3
    flagsT saveThreadMode2 = *(flagsT*)((tinFullS&)tinBaseP).pbF() ; ((tinFullS&)tinBaseP).tlsDelF( LF , countTC() ) ; //TLS:4
                                                    ((tinFullS&)tinBaseP).tlsDelF( LF , countTC() ) ; //TLS:5
                                                    ((tinFullS&)tinBaseP).tlsDelF( LF , countTC() ) ; //TLS:6
    _IO_
{
pSexLifoConstructed( 0 )
face( *(face_poolC_S*)(byteT*)napFace ) ,
guts( *(guts_poolC_S*)(byteT*)napGuts ) ,
) ,
    0 , sizeof( guts_poolC_S ) , ifcOPENsHAREDmEMORYhOW_nCeF //ALWAYS USES MEMORY SPACE DEDICATED TO EXCLUSIVE USE BY THE CONSTRUCTING PROCESS (((tinFullS&)tinBaseP).osPid IS USED TO UNIQUIFY THE NAME)
    ) ,
        )
            ((tinFullS&)tinBaseP).pbF( 2 )                                                                                        //TLS:5
            ) ,
                "."
                ) ,
                    idStateSpaceP ? ((tinFullS&)tinBaseP).pbF( 5 ) : ""                                                           //TLS:2
                    ) ,
                        idStateSpaceP ? "." : ""
                        ) ,
                            postNameP
                            ) ,
                                tinBaseP , ((tinFullS&)tinBaseP).pbF() , "poolC/guts/"                                                //TLS:6
                            (
                            thirdC::c_strcpyIF
                            tinBaseP ,
                        (
                        thirdC::c_strcatIF
                        tinBaseP ,
                    (
                    thirdC::c_strcatIF
                    tinBaseP ,
                (
                thirdC::c_strcatIF
                tinBaseP ,
            (
            thirdC::c_strcatIF
            tinBaseP ,
        (
        thirdC::c_strcatIF
        ((tinFullS&)tinBaseP).tlsNewF( LF , TUCK ) ,                                                                              //TLS:6  ======== NEW ==========================================================    TUCK        "poolC/guts/[postNameP].[idStateSpaceP].[osPid]"
        thirdC::c_itoaIF( tinBaseP , ((tinFullS&)tinBaseP).pbF() , 0x10 , ((tinFullS&)tinBaseP).osPid ) ,                                              //TLS:2
        ((tinFullS&)tinBaseP).tlsNewF( LF , TUCK >> 4 ) ,                                                                         //TLS:5  ======== NEW ==========================================================    TUCK >> 4   [osPid]
    (
    tinBaseP , idLineCtP , idiFileCtP , pbBitsCtP ,
(
napGuts
flagsInstance( flPOOLiNSTANCE_null ) ,
) ,
    )
        (poolC*)0
        ((tinFullS&)tinBaseP).flagsThreadMode2 |= flTHREADmODE2_ALLOWsTOPwHILEgRABBING ,
        *(flagsT*)((tinFullS&)tinBaseP).pbF() = ((tinFullS&)tinBaseP).flagsThreadMode2 ,                                                           //TLS:4
        ((tinFullS&)tinBaseP).tlsNewF( LF , sizeof( flagsT ) ) ,                                                                  //TLS:4  ======== NEW ==========================================================    4           [flagsThreadMode2]
        ) ,
            cbDropSeparatorP , idStateSpaceP
            ,
            )
                ( F(flagsP) & flPOOLc_NOdROPhEADERS ? flPOOLfORMAT_NOdROPhEADERS : flPOOLfORMAT_null )
                |
                ( F(flagsP) & flPOOLc_SETS          ? flPOOLfORMAT_SETS          : flPOOLfORMAT_null )
                |
                ( F(flagsP) & flPOOLc_NOTES         ? flPOOLfORMAT_NOTES         : flPOOLfORMAT_null )
            (
            tinBaseP , idLineCtP , idiFileCtP , pbBitsCtP ,
        (
        ctFaceF
    (
(
pNext
) ,
    sizeof( face_poolC_S ) , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_null , - 1 , idMemorySpaceP
    ) ,
                )
                    (const handleC*)*(fileC*)pbFileFace
                    ctFilesF( tinBaseP , postNameP , idStateSpaceP ) ,
                (
            :
            ? 0
        !idStateSpaceP
    (
    ) ,
        )
            idStateSpaceP ? ((tinFullS&)tinBaseP).pbF( 2 ) : ""                                                                   //TLS:2
            ) ,
                idStateSpaceP ? "." : ""
                ) ,
                    postNameP
                    ) ,
                        tinBaseP , ((tinFullS&)tinBaseP).pbF() , "poolC/face/"                                                        //TLS:3
                    (
                    thirdC::c_strcpyIF
                    tinBaseP ,
                (
                thirdC::c_strcatIF
                tinBaseP ,
            (
            thirdC::c_strcatIF
            tinBaseP ,
        (
        thirdC::c_strcatIF
        ((tinFullS&)tinBaseP).tlsNewF( LF , TUCK ) ,                                                                              //TLS:3  ======== NEW ==========================================================    TUCK        "poolC/face/[postNameP].[idStateSpaceP]"
        thirdC::c_itoaIF( tinBaseP , ((tinFullS&)tinBaseP).pbF() , 0x10 , idStateSpaceP ) ,                                           //TLS:2
        ((tinFullS&)tinBaseP).tlsNewF( LF , TUCK >> 4 ) ,                                                                         //TLS:2  ======== NEW ==========================================================    TUCK >> 4   [idStateSpaceP]
    (
    tinBaseP ,idLineCtP , idiFileCtP , pbBitsCtP ,
(
napFace
) ,
    ifcIDgRABlAYER_8POOL1cT , flBATONc_GRABBED | flBATONc_NOTjEALOUS , pb_batPoolCt , sizeof pb_batPoolCt
    ) ,
        )
            postNameP
            ) ,
                tinBaseP , ((tinFullS&)tinBaseP).pbF() , "poolC/batonCt/"                                                             //TLS:1
            (
            thirdC::c_strcpyIF
            tinBaseP ,
        (
        thirdC::c_strcatIF
        ((tinFullS&)tinBaseP).tlsNewF( LF , TUCK ) ,                                                                              //TLS:1  ======== NEW ==========================================================    TUCK        "poolC/batonCt/[postNameP]"
    (
    tinBaseP , idLineCtP , idiFileCtP , pbBitsCtP ,
(
batPoolCt
/*1*/poolC::poolC( tinBaseS& tinBaseP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postNameP , const countT cbDropSeparatorP , const flagsT flagsP , const countT idStateSpaceP , const countT expCbDropMinP , const countT expCbDropMaxP , const countT* pczHintPreallocationP , countT idMemorySpaceP ) :/*1*/

}
    if( F(flagsPoolFormat) & flPOOLfORMAT_SETS ) pcCbDropAdjust[ 5 ] = sizeof( countT ) ;          //THIS WILL PROVIDE A SLOT SIZE THAT IS EXACTLY THE SIZE OF listOfSetC
    thirdC::c_memsetIF( tinBaseP , (byteT*)pcCbDropAdjust , sizeof pcCbDropAdjust ) ;
    putNegAM( *(countT*)&finger , FINGERnEG_POOLcfACE ) ;
    _IO_
{
cbDropHeader( cbDropHeaderP )
cbDropSeparator( cbDropSeparatorP ) ,
idListNameLath( 0 ) ,
cRef( 1 ) ,
flagsPoolFormat( flagsPoolFormatP ) ,
idFormat( 1 ) ,
finger( 0 ) ,
poolC::face_poolC_S::face_poolC_S( tinBaseS& tinBaseP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const flagsT flagsPoolFormatP , const countT cbDropSeparatorP , const countT cbDropHeaderP ) :

}
    for( countT offg = 0 ; offg < CsLOTsIZESmAX ; offg ++ ) new( 0 , tinBaseP , pbzaGrab + offg * sizeof( grabC ) , sizeof( grabC ) ) grabC( tinBaseP , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS | flGRABc_SHARElAYER , ifcIDgRABlAYER_8POOL5nEW ) ;

    thirdC::c_memsetIF( tinBaseP , (byteT*)ppSlots , sizeof ppSlots ) ;
    thirdC::c_strcpyIF( tinBaseP , postName , postNameP ) ;
    _IO_
{
)
                    : 5
                    ? 4
                : expCbDropMax - expCbDropMin <= 0xf
                ? 3
            : expCbDropMax - expCbDropMin <= 7
            ? 2
        : expCbDropMax - expCbDropMin == 3
        ? expCbDropMax - expCbDropMin
    expCbDropMax - expCbDropMin <= 2
(
cBitsExpCbDrop
expCbDropMax( expCbDropMaxP != - 1 ? expCbDropMaxP : sizeof ppSlots / sizeof ppSlots[ 0 ] - 1 ) ,
expCbDropMin( expCbDropMinP != - 1 ? expCbDropMinP : 0                                        ) ,
pGrabNewElt( (grabC*)pbzaGrab ) ,
idMemorySpace( idMemorySpaceP ) ,
idStateSpace( idStateSpaceP ) ,
flagsCt( flagsP ) ,
poolC::guts_poolC_S::guts_poolC_S( tinBaseS& tinBaseP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postNameP , const flagsT flagsP , const countT idStateSpaceP , const countT expCbDropMinP , const countT expCbDropMaxP , countT idMemorySpaceP ) :

//     | 
//     | f1 (impossible) f1                  5              (expCbDrop f1 IS IMPOSSIBLE BECAUSE THE LOWEST ALLOCATION GRAIN IS NOT AVAILABLE AND THE RUNNING PROGRAM'S FOOTPRINT OCCUPIES PART OF THE REMAINDER OF THE LOWER HALF OF THE FULL ADDRESS SPACE (THE UPPER HALF IS NOT ACCESSIBLE TO APPLICATION CODE)
//     | e1              e1                  5
//     | d1              d1                  5
//     | c1              c1                  5
//     | b1              b1                  5
//     | a1              a1                  5
//     | 91              91                  5
//     | 81              81                  5
//     | 71              71                  5
//     | 61              61                  5
//     | 51              51                  5
//     | 41              41                  5
//     | 31              31                  5
//     | 21              21                  5
//     | 11              11                  5
//     | 01              01 ---------------- 5
//     | f               f                   4
//     | e               e                   4
//     | d               d                   4
//     | c               c                   4
//     | b               b                   4
//     | a               a                   4
//     | 9               9                   4
//     | 8               8  ---------------- 4
//     | 7               7                   3
//     | 6               6                   3
//     | 5               5                   3
//     | 4               4  ---------------- 3
//     | 3               3                   2
//     | 2               2  ---------------- 2
//     | 1               1  ---------------- 1
//     | 0               0  ---------------- 0
//     | 
//     | EXPmAX-EXPmIN   HIGHESToFFSET       BITSnEEDED
//     | 
//  cBitsExpCbDrop IS SET ACCORDING TO THIS TABLE


/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

