
REST

etherC::loafIF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("ok") ) ;

}
    }
        etThread.delF( tinBaseP , pbi ) ;

        }
            etThread.traceF( tinBaseP , T("caught ")+TF2(idSay,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" from port ")+TF2(idpi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" of ")+T(idhi) ) ;
            countT& idSay = *(countT*)pbi ;
        {
        if( !ether && cbi >= sizeof( countT ) )

        }
            etThread.traceF( tinBaseP , T("oops!") ) ;
            POOPR
        {
        if( POOP )
        sock.readF( tinBaseP , pbi , cbi , idpi , idhi ) ;
        nicNameC idhi ;
        ZE( countT , idpi ) ;
        ZE( countT , cbi ) ;
        ZE( byteT* , pbi ) ;
    {
    while( !ether )

    etThread.osThreadF( TaRG1( tmOpenDoor ) , (countT)&sock ) ;

    idPortBind = sock.bindF( tinBaseP , idPortBind ) ;

    socketC sock( tinBaseP , *((tinFullS&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    SCOOPS
{
IFsCRATCH

for( countT offn = 0 ; offn < cnnToServer ; offn ++ ) etThread.traceF( tinBaseP , T("server :    ")+T(pnnToServer[offn]) ) ;
//for( countT offn = 0 ; offn < cnnToGray   ; offn ++ ) etThread.traceF( tinBaseP , T("gray   :    ")+T(pnnToGray[offn]) ) ;
for( countT offn = 0 ; offn < cnnToBlack  ; offn ++ ) etThread.traceF( tinBaseP , T("black  :    ")+T(pnnToBlack[offn]) ) ;

socketC::nicNameIF( tinBaseP , etThread , pnnToServer , cnnToServer , psttServer ) ;
//socketC::nicNameIF( tinBaseP , etThread , pnnToGray   , cnnToGray   , psttGray   ) ;
socketC::nicNameIF( tinBaseP , etThread , pnnToBlack  , cnnToBlack  , psttBlack  ) ;

strokeS* psttServer = tServer ;
//strokeS* psttGray   = tGray   ;
strokeS* psttBlack  = tBlack  ;

TN( tServer , "2001:19f0:5401:562:5400:4ff:fe64:599c"  ) ;
//TN( tGray   , "2600:380:c13d:e195:cb25:bce0:6edf:920c" ) ;
TN( tBlack  , "2600:380:857c:6a24:9a52:7422:2911:7b0f" ) ;


//
// netsh interface ipv6 set privacy state=disabled
//
// THIS ADAM CAN RUN ON OO IPv6 HOSTS WITH THE HARDCODED IPv6 ADDRESSES.  THE USE OF TEMPORARY ADDRESSES MUST BE DISABLED.  THIS CAN BE DONE BY EXECUTING THE FOLLOWING COMMAND IN AN ELEVATED COMMAND PROMPT:

TODO

DONE( tmOpenDoor )
}
    }
        ++ s ; ether.osSleepF( tinBaseP , TOCK ) ;

        }
            pSock->writeF( tinBaseP , idPortTo , pnnToServer[ offn ] /*nicNameC()*/ , (byteT*)&idSayLath , sizeof idSayLath ) ;               // 64222_9
            etThread.traceF( tinBaseP , T("throwing ")+TF2(idSayLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" from port ")+TF2(idPortBind,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" to port ")+TF2(idPortTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" of ")+T(pnnToServer[offn]) ) ;

            //pSock->writeF( tinBaseP , idPortTo , pnnToGray[ offn ] /*nicNameC()*/ , (byteT*)&idSayLath , sizeof idSayLath ) ;               // 64222_9
            //etThread.traceF( tinBaseP , T("throwing ")+TF2(idSayLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" from port ")+TF2(idPortBind,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" to port ")+TF2(idPortTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" of ")+T(pnnToGray[offn]) ) ;

            //pSock->writeF( tinBaseP , idPortTo , pnnToBlack[ offn ] /*nicNameC()*/ , (byteT*)&idSayLath , sizeof idSayLath ) ;               // 64222_9
            //etThread.traceF( tinBaseP , T("throwing ")+TF2(++idSayLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" from port ")+TF2(idPortBind,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" to port ")+TF2(idPortTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" of ")+T(pnnToBlack[offn]) ) ;
        {
        for( countT offn = 0 ; offn < cnnToBlack ; offn ++ )

        idPass ++ ;
    {
    while( !ether )
    ZE( countT , idPass ) ;
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    countT idSayLath  = 0x10000000 ;

    socketC* pSock = (socketC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmOpenDoor )

countT idPortTo = 0xfade ;
countT idPortBind = 0xfade ;

ZE( countT    , cnnToServer ) ;
ZE( nicNameC* , pnnToServer ) ;
//ZE( countT    , cnnToGray   ) ;
//ZE( nicNameC* , pnnToGray   ) ;
ZE( countT    , cnnToBlack  ) ;
ZE( nicNameC* , pnnToBlack  ) ;

/*1*/WAKEsHOWtEXT( "dut.duplex.udt.keepalive" )/*1*/
/**/
*/
 U:: a better test would be to put black and gray behind oo different hotspots from oo different carriers, e.g. ATT and T-Mobile
  server refers to a virtual server that is unprotected
  black and  gray refer to oo laptops connected using (the same) hotspot
 i contain code for "black", "gray", and "server"
  all nodes can be protected
  this works because the cell carrier system registers the [port,nn] pair to a table of permitted incoming packets
  to do this, the protected node throws a datagram to the port of the peer that wants to throw datagrams to the protected node
 but this protection can be disabled if the nodes know each other's ipv6 addresses
 cell phone systems will not allow incoming connections to a node behind its hotspot
i demonstrate that a udp "connection" can be established between oo nodes that know each other's ipv6 address, even if wo node is behind a cell phone hotspot
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
