
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    return *this ;
    }
        ether.delF( tin0P , psttLongTo ) ;

        if( pQueueCBF ) (*pQueueCBF)( tin0P , *this , psttLongTo ) ;

        __( rcFail ) ;
        }
            }
                }
                    POOPRqUIET
                    }
                        etRock.traceF( tin0P , T("!exception / i could not move this new file to the archive") ) ;
                        rcFail = POOP ;
                    {
                    if( offPass > 1 )
                {
                else
                if( !POOP ) break ;

                              ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF(   tin0P , psttLongTo , psttLongFileP          , 1 ) ;
                if( offPass ) ((tin1S&)tin0P).pEtScratch->diskFileOrDirDeleteF( tin0P , psttLongTo , flFILEoRdIRdELETE_null , 1 ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK
            ZE( countT , rc ) ;
        {
        for( countT offPass = !ids ; !rcFail ; offPass ++ )
        ZE( countT , rcFail ) ;
        ether.strMakeF( tin0P , LF , psttLongTo , T(psttLongArchive)+tShort ) ; ___( psttLongTo ) ;
        ZE( strokeS* , psttLongTo ) ;

        ether.traceF( tin0P , T(ids?"new     [tShort]:    ":"existed [tShort]:    ")+tShort ) ;

        if( !ids ) ether.delF( tin0P , posts ) ;

        stShort.sinkF( tin0P , ids , posts , flSTACKsINK_UNIQUE ) ;
        ZE( countT , ids ) ;
        ether.strMakeF( tin0P , LF , posts , tShort ) ; ___( posts ) ;
        ZE( osTextT* , posts ) ;
    
        //ether.traceF( tin0P , T("[short]:    ")+tShort ) ;
    {
    if( tShort.csF( tin0P ) )

    TN( tShort , pstts ) ;
    ether.delF( tin0P , psttnu ) ;
    ether.strBisectF( tin0P , psttnu , pstts , psttLongFileP , psttSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( pstts ) ;  ___( psttnu ) ;
    ZE( strokeS* , pstts  ) ;
    ZE( strokeS* , psttnu ) ;

    etherC& etRock = etherC::etRockIF( tin0P ) ;

    }
        if( POOP ) return *this ;
        __Z( psttLongFileP ) ;
        if( POOP ) return *this ;
    {
    IFbEcAREFUL

    TINSL
{
/*1*/queueC& queueC::operator <<( const strokeS* const psttLongFileP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
