
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        }
            DELzOMBIE( psoDoomed ) ;
            socketC* psoDoomed = (socketC*)pbSocket ;
        {

        }
            sgnDone_tmBlockF.waitF( tin0P ) ;

            }
                ++ s ; etThread.osSleepF( tin0P , TOCK >> 3 ) ;
                etRock.traceF( tin0P , T("waiting for all workers to go away [cIn,cWorkers]:    ")+TF2(++cIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+gc.tb4+TF2(cWorkers,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            while( cWorkers )
            ZE( countT , cIn ) ;
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            gv.bQuit ++ ;

            }
                //etRock.traceF( tin0P , gc.tSayPushedJob+TF2(gv.cirJob,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                gv.cirJob << &job ;
                //etRock.traceF( tin0P , gc.tSayPushingJob+TF2(gv.cirJob,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                jobS job( pbq , cbq , idp , nnPeer ) ;

                /**/etRock.traceF( tin0P , gc.tSayWaitedForPacket+T(nnPeer)+gc.tb4+TF2(cbq,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                }
                    }
                        break ;
                        ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                        etRock.traceF( tin0P , gc.tSayExReadFailed+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )
                    //etRock.traceF( tin0P , gc.tSayCalledRead ) ;
                    sockd.readF( tin0P , pbq , cbq , idp , nnPeer ) ; ___( pbq ) ;
                    //etRock.traceF( tin0P , gc.tSayCallingRead ) ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                //etRock.traceF( tin0P , gc.tSayWaitingForPacket ) ;
                nicNameC nnPeer ;
                ZE( countT , idp ) ;
                ZE( countT , cbq ) ;
                ZE( byteT* , pbq ) ;

                //etRock.traceF( tin0P , gc.tSayInnerLoopBegun ) ;
                _IO_
            {
            while( !POOP && !ether )

            }
                etThread.osThreadF( TaRG2cBsTACK( tmWorkerF , CBsTACKmIN << 2 ) , (countT)&bFail , (countT)&cWorkers , (countT)&cirNnPeerDoNotDivert , (countT)&cirRecentDomainGrossTrace , (countT)&offSettingsUse , (countT)&mySettingsA , (countT)&mySettingsB , (countT)&sockd , (countT)&gc , (countT)&gv , (countT)&grab_tSuffix1Gorilla , (countT)&tSuffix1Gorilla , (countT)&grab_tSuffix2Gorilla , (countT)&tSuffix2Gorilla , (countT)&tRandomLabelPrefix , (countT)&tRandomLabelPrefixLag , (countT)&stNnPeerBlock , (countT)&stRecentHash , (countT)&ideaNetSub , (countT)&nnIdeaNetUse ) ;
                inc02AM( cWorkers ) ;
            {
            while( cDo -- )
            countT cDo = thirdC::osProcessorsIF( tin0P ) << 3 ;

            etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmBlockF , sgnDone_tmBlockF , CBsTACKmIN << 1 ) , (countT)&stNnPeerBlock ) ;
            signC sgnDone_tmBlockF( tin0P , TAG( TAGiDnULL ) ) ;

            stackC  stNnPeerBlock( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ;
            circleC cirRecentDomainGrossTrace( tin0P , etThread , gv.bQuit , flCIRCLEc_OVERWRITE , sizeof( strokeS* ) , TUCK >> 5 , deleteElementF ) ;
            circleC cirNnPeerDoNotDivert(      tin0P , etThread , gv.bQuit , flCIRCLEc_OVERWRITE , sizeof( nicNameC ) , TUCK >> 2 ) ;
        {

        ZE( boolT  , bFail    ) ;
        ZE( countT , cWorkers ) ;

        }
            }
                continue ;
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                etRock.traceF( tin0P , T("!exception / could not bind socket to the dns port [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )
            sockd.bindF( tin0P , ifcPORToLD2_DNS ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK

        }
            }
                continue ;
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                etRock.traceF( tin0P , T("!exception / could not construct socket [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )

            new( 0 , tin0P , pbSocket , sizeof pbSocket ) socketC( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        socketC& sockd = *(socketC*)pbSocket ;
        byteT pbSocket[ sizeof( socketC ) ] ;

        //etRock.traceF( tin0P , T("outer loop begun") ) ;
        _IO_
    {
    while( !POOP && !ether )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    etThread.osThreadF( TaRG2cBsTACK( tmRememberRecentIdeaNetHashP , CBsTACKmIN << 1 ) , (countT)&nnIdeaNetUse , (countT)&stRecentHash , (countT)&ideaNetSub ) ;
    ideaNetSubscriptionC ideaNetSub( tin0P , etThread , idBook , idSub , tSecret ) ; ___( pSubP ) ;
    countT   idSub  = 1 ;
    countT   idBook = 1 ;
    stackC   stRecentHash( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_ALLOWzE ) ;     // THE HASH FUNCTION CAN RETURN 0
    nicNameC nnIdeaNetUse ;

    TN( tSecret , "bc2a" "79d2" "dc3d" "4462" "c587" "603e" "c576" "5563" "dd57" "181f" ) ;         //CS:CODEsYNC: 510008c0 510008af
    //CODED THIS WAY TO AVOID TRIGGERING GITGUARDIAN ; THIS IS A SECRET BUT ONLY FOR TESTING ; NO HARM CAN COME FROM DISCLOSURE


    //U::6: etThread.osThreadF( TaRG2cBsTACK( tmUpdateNnHostsF , CBsTACKmIN << 1 ) , (countT)&gv.nnHostWebLath , (countT)&gv.nnHostWebLag0 , (countT)&gv.nnHostWebLag1 , (countT)&gv.nnHostWebLag2 , (countT)&gv.nnHostWebLag3 ) ;

    mySettingsA.grabMe.ungrabF( tin0P ) ;

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                   *******************************************************************************************************************************************************************************************************************************************************************************************
    //*****  PREPARE TO WORK  *******************************************************************************************************************************************************************************************************************************************************************************************
    //*****                   *******************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                                   ***************************************************************************************************************************************************************************************************************************************************************************
    //*****  LOCAL VARIABLES (MASTER THREAD)  ***************************************************************************************************************************************************************************************************************************************************************************
    //*****                                   ***************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                                              ****************************************************************************************************************************************************************************************************************************************************************
    //*****  LOCAL VARIABLES (INSTANCE FOR EACH WORKER)  ****************************************************************************************************************************************************************************************************************************************************************
    //*****                                              ****************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    etThread.osThreadF( TaRG2cBsTACK( tmRandomizeWebhookDomainPrefixF , CBsTACKmIN << 2 ) , (countT)&offSettingsUse , (countT)&mySettingsA , (countT)&mySettingsB , (countT)&gc , (countT)&gv , (countT)&tRandomLabelPrefix , (countT)&tRandomLabelPrefixLag ) ;
    TN( tRandomLabelPrefixLag , "" ) ;
    TN( tRandomLabelPrefix    , "abgmdwmybvfj3yub5r" ) ;

    gVarS gv( tin0P , etThread , gc , mySettingsA ) ;

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                                            ******************************************************************************************************************************************************************************************************************************************************************
    //*****  GLOBAL VARIABLES (SHARED BY ALL WORKERS)  ******************************************************************************************************************************************************************************************************************************************************************
    //*****                                            ******************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    gConstS gc( tin0P , mySettingsA ) ;

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                                            ******************************************************************************************************************************************************************************************************************************************************************
    //*****  GLOBAL CONSTANTS (SHARED BY ALL WORKERS)  ******************************************************************************************************************************************************************************************************************************************************************
    //*****                                            ******************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    }
        __1 ;
        etRock.traceF( tin0P , T("!exception / a required setting is missing") ) ;
        mySettingsA.grabMe.ungrabF( tin0P ) ;
        _IO_
    {
    if( !mySettingsA )
    mySettingsA.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

    etThread.osThreadF( TaRG2cBsTACK( tmCatchLabelSuffixF , CBsTACKmIN << 1 ) , (countT)&grab_tSuffix1Gorilla , (countT)&tSuffix1Gorilla , (countT)&grab_tSuffix2Gorilla , (countT)&tSuffix2Gorilla ) ;
    TN( tSuffix2Gorilla , "" ) ;
    grabC grab_tSuffix2Gorilla( tin0P , TAG( TAGiDnULL ) ) ;
    TN( tSuffix1Gorilla , "" ) ;
    grabC grab_tSuffix1Gorilla( tin0P , TAG( TAGiDnULL ) ) ;

    //etRock.traceF( tin0P , T("the settings are ready") ) ;
    }
        sgnSettingsReady.waitF( tin0P ) ;
        etThread.osThreadF( TaRG2cBsTACK( tmFreshSettingsF , CBsTACKmIN << 1 ) , (countT)&sgnSettingsReady , (countT)&offSettingsUse , (countT)&mySettingsA , (countT)&mySettingsB ) ;
        signC sgnSettingsReady( tin0P , TAG( TAGiDnULL ) ) ;
    {

    ZE( countT , offSettingsUse ) ;
    mySettingsS mySettingsB( tin0P , etThread ) ;
    mySettingsS mySettingsA( tin0P , etThread ) ;

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                **********************************************************************************************************************************************************************************************************************************************************************************************
    //*****  GET SETTINGS  **********************************************************************************************************************************************************************************************************************************************************************************************
    //*****                **********************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIEST ) ; // RUDE WOULD BE AN ATTACK SURFACE
    thirdC::dosPriorityProcessIF(      tin0P , ifcTHREADpRIORITY_RUDE    ) ; // THIS IS SO PASSWORD (WEBHOOK SUFFIX) UPDATES ARE NOTICED TIMELY

    _IO_
{
if( pTaskP )
TASK( tmWorkF )

DONE( tmWorkerF )
}
    dec02AM( cWorkersP ) ;

    }
        }
            IFsCRATCHoK{}

            etThread.delF( tin0P , job.pbq ) ;
            }
                }
                    }
                        etThread.delF( tin0P , pbr ) ;
                        }
                            }
                                }
                                    etRock.traceF( tin0P , gcP.tSayExCouldNotWriteReply+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    POOPRqUIET
                                    countT rc = POOP ;
                                {
                                else
                                if( !POOP ) ; //etRock.traceF( tin0P , gcP.tSayWroteReply ) ;
                                sockdP.writeF( tin0P , job.idp , job.nnPeer , pbr , cbr ) ;
                                //etRock.traceF( tin0P , gcP.tSayReplying1/*+TF2(cbr,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)*/ ) ;
                                _IO_
                            {
                            else
                            }
                                etRock.traceF( tin0P , gcP.tSayExCouldNotBuildReply+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                POOPRqUIET
                                countT rc = POOP ;
                                _IO_
                            {
                            if( POOP )
                            ((tin1S&)tin0P).pEtScratch->dnsReplyF( tin0P , pbr , cbr , job.pbq , stsReplies , 1 , idError ) ;
                            SCOOPS
                            _IO_
                        {
                        IFsCRATCHoK
                        ZE( countT , cbr ) ;
                        ZE( byteT* , pbr ) ;

                        //else                          /*;*/etRock.traceF( tin0P , T("replying [error]:    ")+TF2(idError,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //if( postError && *postError ) /*;*/etRock.traceF( tin0P , T("replying [error]:    ")+T(postError)                                          ) ;
                        const osTextT* postError = processGlobal4S::_processGlobal4I_IF().mapIdErrorDns( idError ) ;

                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                        //****         ***************************************************************************************************************************************************************************************************************************************************************************************
                        //****  REPLY  ***************************************************************************************************************************************************************************************************************************************************************************************
                        //****         ***************************************************************************************************************************************************************************************************************************************************************************************
                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                    {
                    if( !bSilent || bForceReply )

                    if( bSilent && !bPeerIsGorilla1 ) stNnPeerBlockP.sinkF( tin0P , countTC() , job.nnPeer , flSTACKsINK_UNIQUE , 0 , 0 ) ;

                    }
                        }
                            }
                                if( !stsReplies ) idError = ifcIDeRRORdNS_NAMEnOTdEFINED ;

                                }
                                    DEL( ps ) ;
                                    }
                                        /**/etRock.traceF( tin0P , (!bSilent||bForceReply?gcP.tSayReplying2:gcP.tSaySilence)+tDomainGross ) ;

                                        }
                                            }
                                                break ;
                                            
                                                }
                                                    rec_AAAA_F( tin0P , etThread , stsReplies , ifcIDsECTIONdNSrEPLY_ANSWER , tDomainGross , nnOut , job.nnPeer ) ;
                                                    bSilent = 0 ;
                                                {
                                                if( ~nnOut )

                                                if( bIdeaNet && !bNoHit ) nnOut = nnIdeaNetUseP ;
                                                nicNameC nnOut ;

                                                //etRock.traceF( tin0P , gcP.tSayAAAARequest/*+tDomainNet*/ ) ;
                                                _IO_
                                            {
                                            case ifcIDtYPEdNSqUERY_AAAA :
                                            }
                                                break ;

                                                }
                                                    }
                                                        rec_A_F( tin0P , etThread , stsReplies , ifcIDsECTIONdNSrEPLY_ANSWER , tDomainGross , nnOut , job.nnPeer ) ;
                                                        bSilent = 0 ;
                                                    {
                                                    if( ~nnOut )

                                                    nnOut = bDivert ? nnWebHook2 : nnWebHook1 ;
                                                    )
                                                        || !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gvP.tDomainWebHooksNetLag )
                                                           !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gvP.tDomainWebHooksNet    )
                                                    (
                                                    if

                                                    nicNameC nnOut ;
                                                    etRock.traceF( tin0P , gcP.tSayARequest+tDomainNet ) ;
                                                {
                                                if( !bNoHit )

                                                _IO_
                                            {
                                            case ifcIDtYPEdNSqUERY_A :
                                            }
                                                break ;

                                                }
                                                    etThread.delF( tin0P , pbValue ) ;
                                                    }
                                                        rec_TXT_F( tin0P , etThread , stsReplies , ifcIDsECTIONdNSrEPLY_ANSWER , tDomainGross , tValue , job.nnPeer ) ;

                                                        etRock.traceF( tin0P , gcP.tSayAcmeChallengeValue+tValue ) ;
                                                        TN( tValue , pbValue ) ;
                                                        if( pbe ) *pbe = 0 ;
                                                        byteT* pbe = thirdC::c_strstrIF( tin0P , pbValue , " \r\n" ) ;      // THE WINDOWS SHELL COMMAND "echo abcd > [filename]" RESULTS IN A FILE IMAGE THAT ENDS WITH " \r\n" ; THIS CODE SUPPORTS USING SUCH A COMMAND TO WRITE THE FILE
                                                    {
                                                    if( pbValue )

                                                    }
                                                        }
                                                            }
                                                                etThread.delF( tin0P , pbValue ) ;
                                                                etRock.traceF( tin0P , T("!exception / could not get contents of ")+tLongAcmeChallengeValue2 ) ;
                                                                POOPR ;
                                                            {
                                                            if( POOP )
                                                            ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , pbValue , cbValue , tLongAcmeChallengeValue2 , 1 ) ; ___( pbValue ) ;
                                                            SCOOPS
                                                        {
                                                        IFsCRATCHoK
                                                    {
                                                    if( !pbValue )

                                                    }
                                                        }
                                                            etThread.delF( tin0P , pbValue ) ;
                                                            etRock.traceF( tin0P , T("!exception / could not get contents of ")+tLongAcmeChallengeValue1 ) ;
                                                            POOPR ;
                                                        {
                                                        if( POOP )
                                                        ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , pbValue , cbValue , tLongAcmeChallengeValue1 , 1 ) ; ___( pbValue ) ;
                                                        SCOOPS
                                                    {
                                                    IFsCRATCHoK
                                                    ZE( countT , cbValue ) ;
                                                    ZE( byteT* , pbValue ) ;

                                                    bSilent = 0 ;
                                                {
                                                else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainGross , gcP.tAcmeChallenge ) )
                                                }
                                                    rec_TXT_F( tin0P , etThread , stsReplies , ifcIDsECTIONdNSrEPLY_ANSWER , tDomainGross , mySettingsUse.tTestTextResponse , job.nnPeer ) ;
                                                    bSilent = 0 ;
                                                {
                                                if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainGross , gcP.tTestTextChallenge ) )

                                                etRock.traceF( tin0P , gcP.tSayARequest+tDomainNet ) ;
                                                _IO_
                                            {
                                            case ifcIDtYPEdNSqUERY_TXT :
                                            }
                                                break ;
                                                bForceReply = 1 ;               //U:: CONJ: ALL OF THESE SETTINGS OF bForceReply ARE REDUNDANT AND CAN BE REMOVED
                                                bSilent = 0 ;
                                            {
                                            case ifcIDtYPEdNSqUERY_CAA :
                                        {
                                        if( idClass == 1 && ( idType == ifcIDtYPEdNSqUERY_CAA || !bSilent ) ) switch( idType )

                                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        //****                                          ******************************************************************************************************************************************************************************************************************************************************
                                        //****  BUILD REPLY IF DOMAIN NAME IS EXPECTED  ******************************************************************************************************************************************************************************************************************************************************
                                        //****                                          ******************************************************************************************************************************************************************************************************************************************************
                                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        //****************************************************************************************************************************************************************************************************************************************************************************************************

                                        }
                                            }
                                                }
                                                    break ;

                                                    }
                                                        }
                                                            }
                                                                while( ~handle ) ;
                                                                }
                                                                    etThread.strokeF( tin0P , T("stRecentHashP [hash]:    ")+TF2(vv,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
                                                                    countT vv = stRecentHashP.downF( tin0P , handle ) ;
                                                                {
                                                                do
                                                                handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                            {
                                                            else
                                                            if( !stRecentHashP ) etThread.strokeF( tin0P , T("stRecentHashP is empty\r\n") ) ;
                                                        {
                                                        if( bNoHit )

                                                        etThread.delF( tin0P , psttHashQuery ) ;
                                                        etThread.traceF( tin0P , T("debug [hashQuery,bNoHit]:    ")+TF2(hashQuery,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bNoHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        if( !bOk ) bNoHit = 1 ;

                                                        }
                                                            if( hashQuery == hashNow ) bOk = 1 ;                // IF MATCH THEN THE QUERY CONTAINS THE EXPECTED HASH

                                                            ideaNetSubP.nnF( tin0P , hashNow , minute ) ;
                                                            ZE( countT , hashNow ) ;

                                                            countT minute = ( timeN1 >> 0x14 ) - 1 ;            // USE THE PRIOR MINUTE (TO AVOID RACING WITH THE WEB SERVER)

                                                            etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                                                            ZE( sCountT , timeN2 ) ;
                                                            ZE( countT  , timeN1 ) ;
                                                        {
                                                        if( !bOk )

                                                        boolT bOk = !!stRecentHashP( hashQuery ) ;              // THIS SHOULD ALWAYS SET bOk TO 1 EXCEPT WHEN stRecentHashP HAS NOT YET BEEN LOADED FULLY

                                                        countT hashQuery = etThread.strDigitsToSCountF( tin0P , psttHashQuery ) ;

                                                        etThread.strSubstringF( tin0P , psttHashQuery , countTC( 1 ) , sttq , gcP.tDash , tDomainNet ) ; ___( psttHashQuery ) ;
                                                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                        ZE( strokeS* , psttHashQuery ) ;

                                                        bSilent = 0 ;
                                                    {
                                                    if( etThread.strIdF( tin0P , gcP.tDashSub1DashBook1DotIdeaNetDomain , tDomainNet , 1 ) )
                                                {
                                                case ifcIDtYPEdNSqUERY_AAAA :
                                                }
                                                    break ;
                                                    bNoHit  = 1 ;
                                                    bSilent = 0 ;
                                                {
                                                case ifcIDtYPEdNSqUERY_A :
                                            {
                                            switch( idType )
                                        {
                                        if( bIdeaNet && idClass == 1 )
                                        ZE( boolT , bNoHit ) ;

                                        *ps >> idClass ;
                                        ZE( countT , idClass ) ;

                                        *ps >> idType ;
                                        ZE( countT , idType ) ;

                                        etThread.delF( tin0P , psttw ) ;
                                        TN( tDomainNet , psttw ) ;
                                        }
                                            bIdeaNet = 1 ;

                                            // IPV6: REPLY IFF VALID DOMAIN OF THE FORM "[random]-[idSub]-[idBook].ideanet.ideafarm.com" AND [random] MATCHES THE CURRENT [random] VALUE IN THE IPv6 ADDRESS ENABLED BY WEB1 FOR THAT SUBSCRIBER
                                            // IPV4: SAY "NO SUCH NAME"

                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****                   *****************************************************************************************************************************************************************************************************************************************************************************
                                            //****  "IDEANET" LABEL  *****************************************************************************************************************************************************************************************************************************************************************************
                                            //****                   *****************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        {
                                        else if( psttw && etThread.strIdF( tin0P , gcP.tDotIdeaNetDomain , psttw , 1 ) )
                                        }
                                            else if( bStripe )                       bSilent = 0 ;      // PEER MIGHT OR MIGHT NOT REALLY BE STRIPE, SO bDivert WILL DEPEND UPON WHETHER nnPeer IS ON THE TRUSTED LIST
                                            }
                                                else if( bGorilla2 ) { bDivert = 1 ; bSilent = 0 ; }
                                                     if( bGorilla1 ) { bDivert =     bSilent = 0 ; }
                                            {
                                            if( bPeerIsGorilla1 )

                                            etThread.delF( tin0P , psttSuffix ) ;
                                            }
                                                /**/etRock.traceF( tin0P , gcP.tSayDomainNetSuffixPeer+T(bGorilla1||bGorilla2||bStripe?"           domainnet: \"":"REJECTED   domainnet: \"")+tDomainNet+T("\"   actual: \"")+T(psttSuffix)+T("\"   valid1: \"")+tSuffix1GorillaP+T("\"   valid2: \"")+tSuffix2GorillaP+T("\"   stripe: \"")+mySettingsUse.tSuffixUsedByStripe+T("\"   peer: ")+T(job.nnPeer)+T("   tDomainPeer: \"")+tDomainPeer+T("\"") ) ;

                                                if( !bGorilla1 && !bGorilla2 ) bStripe = !etThread.strCompareF( tin0P , psttSuffix , mySettingsUse.tSuffixUsedByStripe  ) ;

                                                }
                                                    grab_tSuffix2GorillaP.ungrabF( tin0P ) ;
                                                    bGorilla2 = !etThread.strCompareF( tin0P , psttSuffix , tSuffix2GorillaP ) ;
                                                    grab_tSuffix2GorillaP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                {
                                                if( !bGorilla1 )

                                                grab_tSuffix1GorillaP.ungrabF( tin0P ) ;
                                                bGorilla1 = !etThread.strCompareF( tin0P , psttSuffix , tSuffix1GorillaP ) ;
                                                grab_tSuffix1GorillaP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                            {
                                            if( psttSuffix )
                                            ZE( boolT , bGorilla2 ) ;
                                            ZE( boolT , bGorilla1 ) ;
                                            ZE( boolT , bStripe   ) ;

                                            etThread.strMakeF( tin0P , LF , psttw , tDomainNet ) ; ___( psttw ) ;
                                            etThread.delF( tin0P , psttNet ) ;
                                            TN( tDomainNet , "" ) ; tDomainNet = T(psttNet)+T(".hidden.ideafarm.com") ;

                                            etThread.delF( tin0P , psttw ) ;
                                            etThread.strSubstringF( tin0P , psttSuffix , idf , sttq , gcP.tDot  , psttw , 0 , 0 ) ; ___( psttSuffix ) ;
                                            etThread.strSubstringF( tin0P , psttNet    , idf , sttq , gcP.tDash , psttw , 0 , 0 ) ; ___( psttNet    ) ;
                                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                            countT idf = 1 ;
                                            ZE( strokeS* , psttSuffix ) ;
                                            ZE( strokeS* , psttNet ) ;
                                            _IO_

                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****                                       *********************************************************************************************************************************************************************************************************************************************************
                                            //****  "HIDDEN" LABEL AND A DASH '-' FOUND  *********************************************************************************************************************************************************************************************************************************************************
                                            //****                                       *********************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        {
                                        else if( psttw && etThread.strIdF( tin0P , gcP.tDotHiddenDomain , psttw , 1 ) && etThread.strIdF( tin0P , gcP.tDash , psttw , 1 ) )
                                        }
                                            }
                                                while( cDo -- ) etRock.traceF( tin0P , gcP.tSayTraceMarkEnd ) ;
                                                countT cDo = 8 ;

                                                //etRock.traceF( tin0P , gcP.tSayPushedDomain+TF2(cirRecentDomainGrossTraceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                cirRecentDomainGrossTraceP << &psttSTFU ;
                                                //etRock.traceF( tin0P , gcP.tSayPushingDomain+TF2(cirRecentDomainGrossTraceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                etThread.strMakeF( tin0P , LF , psttSTFU , tDomainGross ) ; ___( psttSTFU ) ;
                                                ZE( strokeS* , psttSTFU ) ;
                                            {
                                            else
                                            if( bSTFU ) ;//etRock.traceF( tin0P , T("stfu [tDomainGross]:    ")+tDomainGross ) ;

                                            }
                                                while( c3Handle.c1 ) ;
                                                }
                                                    }
                                                        break ;
                                                        bSTFU = 1 ;
                                                    {
                                                    if( ppsttSTFU && *ppsttSTFU && !etThread.strCompareF( tin0P , *ppsttSTFU , tDomainGross ) )
                                                    strokeS** ppsttSTFU = (strokeS**)cirRecentDomainGrossTraceP[ c3Handle ] ;
                                                {
                                                do
                                                count3S c3Handle ;
                                            {
                                            ZE( boolT , bSTFU ) ;
                                            bForceReply = 1 ;

                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****                 *******************************************************************************************************************************************************************************************************************************************************************************
                                            //****  TRACEMARK END  *******************************************************************************************************************************************************************************************************************************************************************************
                                            //****                 *******************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        {
                                        else if( etThread.strIdF( tin0P , gcP.tDomainGrossTraceMarkEnd , tDomainGross ) )
                                        }
                                            }
                                                while( cDo -- ) etRock.traceF( tin0P , gcP.tSayTraceMarkBegin ) ;
                                                countT cDo = 8 ;

                                                //etRock.traceF( tin0P , gcP.tSayPushedDomain+TF2(cirRecentDomainGrossTraceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                cirRecentDomainGrossTraceP << &psttSTFU ;
                                                //etRock.traceF( tin0P , gcP.tSayPushingDomain+TF2(cirRecentDomainGrossTraceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                etThread.strMakeF( tin0P , LF , psttSTFU , tDomainGross ) ; ___( psttSTFU ) ;
                                                ZE( strokeS* , psttSTFU ) ;
                                            {
                                            else
                                            if( bSTFU ) ;//etRock.traceF( tin0P , T("stfu [tDomainGross]:    ")+tDomainGross ) ;

                                            }
                                                while( c3Handle.c1 ) ;
                                                }
                                                    }
                                                        break ;
                                                        bSTFU = 1 ;
                                                    {
                                                    if( ppsttSTFU && *ppsttSTFU && !etThread.strCompareF( tin0P , *ppsttSTFU , tDomainGross ) )
                                                    strokeS** ppsttSTFU = (strokeS**)cirRecentDomainGrossTraceP[ c3Handle ] ;
                                                {
                                                do
                                                count3S c3Handle ;
                                            {
                                            ZE( boolT , bSTFU ) ;
                                            bForceReply = 1 ;

                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****                   *****************************************************************************************************************************************************************************************************************************************************************************
                                            //****  TRACEMARK BEGIN  *****************************************************************************************************************************************************************************************************************************************************************************
                                            //****                   *****************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        {
                                        else if( etThread.strIdF( tin0P , gcP.tDomainGrossTraceMarkBegin , tDomainGross ) )
                                        }
                                            bForceReply = 1 ;
                                            bSilent     = 0 ;

                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****                  ******************************************************************************************************************************************************************************************************************************************************************************
                                            //****  ACME CHALLENGE  ******************************************************************************************************************************************************************************************************************************************************************************
                                            //****                  ******************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        {
                                        if( !etThread.strCompareF( tin0P , tDomainGross , gcP.tAcmeChallenge ) )
                                        }
                                            bForceReply = 1 ;
                                            bSilent     = 0 ;

                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****                      **************************************************************************************************************************************************************************************************************************************************************************
                                            //****  TEST TXT CHALLENGE  **************************************************************************************************************************************************************************************************************************************************************************
                                            //****                      **************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        {
                                        if( !etThread.strCompareF( tin0P , tDomainGross , gcP.tTestTextChallenge ) )
                                        ZE( boolT , bIdeaNet ) ;

                                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        //****                               *****************************************************************************************************************************************************************************************************************************************************************
                                        //****  SET bSilent AND bForceReply  *****************************************************************************************************************************************************************************************************************************************************************
                                        //****                               *****************************************************************************************************************************************************************************************************************************************************************
                                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        //****************************************************************************************************************************************************************************************************************************************************************************************************

                                        //etRock.traceF( tin0P , gcP.tSayDomainGrossPeer+tDomainGross+gcP.tqb4q+tDomainPeer+gcP.tq ) ;
                                        TN( tDomainGross , psttw ) ;
                                        if( psttw ) ((tin1S&)tin0P).pEtScratch->strConvertToLowerCaseF( tin0P , psttw ) ; ___( psttw ) ;
                                        //etRock.traceF( tin0P , gcP.tSayLoweringCase ) ;
                                        *ps >> psttw ;
                                        ZE( strokeS* , psttw ) ;
                                        _IO_
                                    {
                                    if( ps )
                                    stsQueries >> ps ;
                                    ZE( soulC* , ps ) ;
                                    //etRock.traceF( tin0P , gcP.tSayPoppingQuery ) ;
                                    _IO_
                                {
                                while( stsQueries )
                                _IO_
                            {
                            else
                            }
                                idError = ifcIDeRRORdNS_CANNOTpARSEqUERY ;
                                etRock.traceF( tin0P , gcP.tSayExCouldNotParse+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                POOPRqUIET
                            {
                            if( rc )
                            etThread.delF( tin0P , pbNU ) ;
                            //etRock.traceF( tin0P , gcP.tSayCalledDnsParse ) ;
                            countT rc = POOP ;
                            ((tin1S&)tin0P).pEtScratch->dnsParseF( tin0P , pbNU , countTC() , stsQueries , stsRepliesNU , job.pbq , job.cbq ) ;
                            SCOOPS
                            //etRock.traceF( tin0P , gcP.tSayCallingDnsParse ) ;
                            _IO_
                        {
                        IFsCRATCHoK
                        ZE( byteT* , pbNU ) ;

                        //etRock.traceF( tin0P , gcP.tSayPurgedStacks ) ;
                        stsRepliesNU.purgeF( tin0P ) ;
                        stsQueries.purgeF( tin0P ) ;
                        //etRock.traceF( tin0P , gcP.tSayPurgingStacks ) ;
                        _IO_
                    {

                    const boolT bPeerIsGorilla1 = job.nnPeer == nnGorilla1 ;

                    ++ gvP.idClient ;

                    //}
                    //    //etRock.traceF( tin0P , TT(timeN1,timeN2)+gcP.tb4+tTimeOld+gcP.tb4+T(job.nnPeer)+(bDivert?gcP.tSayDiverting:gcP.tSayGranting)+tDomainPeer ) ;
                    //
                    //    }
                    //        etThread.delF( tin0P , pstgcP.tSay ) ;
                    //        tTimeOld = T(pstgcP.tSay) ;
                    //        etThread.strFromOldTimeF( tin0P , pstgcP.tSay , mm , hh , d , m , y , dow , 0 ) ; ___( pstgcP.tSay ) ;
                    //        ZE( strokeS* , pstgcP.tSay ) ;
                    //    {
                    //    TN( tTimeOld , "" ) ;
                    //
                    //    etThread.osTimeToOldTimeF( tin0P , ms , ss , mm , hh , d , m , y , dow , timeN1 , timeN2 , flOStIMEtOoLDtIME_null ) ;
                    //    ZE(  countT , dow ) ;
                    //    ZE( sCountT , y   ) ;
                    //    ZE(  countT , m   ) ;
                    //    ZE(  countT , d   ) ;
                    //    ZE(  countT , hh  ) ;
                    //    ZE(  countT , mm  ) ;
                    //    ZE(  countT , ss  ) ;
                    //    ZE(  countT , ms  ) ;
                    //
                    //    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                    //    ZE( sCountT , timeN2 ) ;
                    //    ZE( countT  , timeN1 ) ;
                    //{

                    countT idError = ifcIDeRRORdNS_AOK ;
                    _IO_
                {
                if( job.pbq && job.cbq )
                _IO_
            {

            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****                       *************************************************************************************************************************************************************************************************************************************************************************
            //****  INSPECT THE QUERIES  *************************************************************************************************************************************************************************************************************************************************************************
            //****                       *************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************

            }
                }
                    //etRock.traceF( tin0P , gcP.tSayNotDiverting ) ;
                    bDivert = 0 ;                                                                                                                                   //P:PERSONALITY: SUPPRESS DIVERSION IF RECENT QUERY FROM LETSENCRYPT
                {
                else
                }
                    //etRock.traceF( tin0P , gcP.tSayDiverting2 ) ;
                {
                if( !timeLetsEncryptLath2 && !timeLetsEncryptLath1 )
            {
            if( bDivert )

            }
                }
                    //etRock.traceF( tin0P , gcP.tSayDiversionEnabled ) ;
                    bForceReply = timeLetsEncryptLath2 = timeLetsEncryptLath1 = 0 ;
                {
                if( timeE2 || timeE1 > TICK << 0 )

                etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeLetsEncryptLath1 , timeLetsEncryptLath2 ) ;
                etThread.osTimeNowF( tin0P , timeE1 , timeE2 ) ;
                ZE( sCountT , timeE2 ) ;
                ZE( countT  , timeE1 ) ;
            {
            else if( timeLetsEncryptLath2 || timeLetsEncryptLath1 )
            }
                //etRock.traceF( tin0P , bSuppressed ? gcP.tSayDiversionSupRefreshed : gcP.tSayDiversionSuppressed ) ;
                etThread.osTimeNowF( tin0P , timeLetsEncryptLath1 , timeLetsEncryptLath2 ) ;
                timeLetsEncryptLath2 = timeLetsEncryptLath1 = 0 ;
                countT bSuppressed = timeLetsEncryptLath2 || timeLetsEncryptLath1 ;
                bForceReply = 1 ;
            {
            if( 1 + tDomainPeer.csF( tin0P ) - gcP.tDotLetsEncryptDotOrg.csF( tin0P ) == etThread.strIdF( tin0P , gcP.tDotLetsEncryptDotOrg , tDomainPeer ) )

            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****                                                      ******************************************************************************************************************************************************************************************************************************************
            //****  IF LETS ENCRYPT THEN FORCE REPLY AND DO NOT DIVERT  ******************************************************************************************************************************************************************************************************************************************
            //****                                                      ******************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************

            }
                }
                    //U::PROD: //etRock.traceF( tin0P , gcP.tSayPrefix+T(job.nnPeer)+gcP.tSayUnknownDomain+gcP.tb4+tDomainPeer ) ;
                    //etRock.traceF( tin0P , gcP.tSayUnknownDomain ) ;
                    bDivert = 1 ;
                {
                else
                }
                    }
                        //etRock.traceF( tin0P , gcP.tSayPushedPeer+TF2(cirNnPeerDoNotDivertP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        cirNnPeerDoNotDivertP << &job.nnPeer ;
                        //etRock.traceF( tin0P , gcP.tSayPushingPeer+TF2(cirNnPeerDoNotDivertP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( !bDoNotDivert )
                {
                if( bDoNotDivert || bDomainRootAllowed || bSubnetTrusted )         //P:PERSONALITY: TRUSTED PEERS ARE DIRECTED TO wh1 ; UNTRUSTED PEERS ARE DIRECTED TO wh2

                //****************************************************************************************************************************************************************************************************************************************************************************************************
                //****************************************************************************************************************************************************************************************************************************************************************************************************
                //****                                                             ***********************************************************************************************************************************************************************************************************************************
                //****  EITHER SET bDivert OR REMEMBER nnPeer FOR "DO NOT DIVERT"  ***********************************************************************************************************************************************************************************************************************************
                //****                                                             ***********************************************************************************************************************************************************************************************************************************
                //****************************************************************************************************************************************************************************************************************************************************************************************************
                //****************************************************************************************************************************************************************************************************************************************************************************************************

                }
                    }
                        etThread.delF( tin0P , psttPeer ) ;
                        }
                            mySettingsUse.grabMe.ungrabF( tin0P ) ;
                            }
                                }
                                    break ;
                                    bDomainRootAllowed ++ ;
                                {
                                if( idHit && idHit == 1 + psttPeer->idAdam - mySettingsUse.pptDomainRootAllowed[ offt ]->csF( tin0P ) )
                                countT idHit  = etThread.strIdF( tin0P , *mySettingsUse.pptDomainRootAllowed[ offt ] , psttPeer , 1 ) ;
                            {
                            for( countT offt = 0 ; offt < mySettingsUse.cDomainRootAllowed ; offt ++ )
                            mySettingsUse.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                            //etRock.traceF( tin0P , gcP.tSayPeer/*+T(psttPeer)*/ ) ;
                            tDomainPeer = T(psttPeer) ;
                            _IO_
                        {
                        else
                        if( !psttPeer ) ;//etRock.traceF( tin0P , gcP.tSayExReverseLookupFailed ) ;
                        etThread.sockPsttHostF( tin0P , psttPeer , job.nnPeer ) ; ___( psttPeer ) ;
                        //etRock.traceF( tin0P , gcP.tSayDoingReverseLookup ) ;
                        ZE( strokeS* , psttPeer ) ;
                    {
                    if( !bSubnetTrusted )

                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                    //****                                                              **********************************************************************************************************************************************************************************************************************************
                    //****  DO NOT DIVERT IF PEER'S DOMAIN ROOT IS ALLOWED IN SETTINGS  **********************************************************************************************************************************************************************************************************************************
                    //****                                                              **********************************************************************************************************************************************************************************************************************************
                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                    //****************************************************************************************************************************************************************************************************************************************************************************************************

                    }
                        mySettingsUse.grabMe.ungrabF( tin0P ) ;
                        }
                            }
                                }
                                    break ;
                                    //etRock.traceF( tin0P , T("ipv6 found in mySettingsUse.pnnSubnetTrusted [nnPeer]:    ")+T(job.nnPeer) ) ;
                                    bSubnetTrusted = 1 ;
                                {
                                if( mySettingsUse.pnnSubnetTrusted[ offn ] == job.nnPeer( 0x40 ) )
                            {
                            else
                            }
                                }
                                    break ;
                                    //etRock.traceF( tin0P , T("ipv4 found in mySettingsUse.pnnSubnetTrusted [nnPeer]:    ")+T(job.nnPeer) ) ;
                                    bSubnetTrusted = 1 ;
                                {
                                if( mySettingsUse.pnnSubnetTrusted[ offn ] == job.nnPeer( 0x18 ) )
                            {
                            if( job.nnPeer.isIPv4F() )
                            _IO_
                        {
                        for( countT offn = 0 ; offn < mySettingsUse.cnnSubnetTrusted ; offn ++ )
                        mySettingsUse.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        _IO_
                    {

                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                    //****                                                                ********************************************************************************************************************************************************************************************************************************
                    //****  DO NOT DIVERT IF PEER'S DOMAIN SUBNET IS TRUSTED IN SETTINGS  ********************************************************************************************************************************************************************************************************************************
                    //****                                                                ********************************************************************************************************************************************************************************************************************************
                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                {
                if( !bDoNotDivert )
                ZE( boolT , bDomainRootAllowed ) ;
                ZE( boolT , bSubnetTrusted     ) ;

                }
                    while( c3Handle.c1 ) ;
                    }
                        }
                            break ;
                            //etRock.traceF( tin0P , T("found in cirNnPeerDoNotDivertP [nnPeer]:    ")+T(job.nnPeer) ) ;
                            bDoNotDivert = 1 ;
                        {
                        if( pnn && *pnn == job.nnPeer )
                        nicNameC* pnn = (nicNameC*)cirNnPeerDoNotDivertP[ c3Handle ] ;
                    {
                    do
                    count3S c3Handle ;
                {
                ZE( boolT , bDoNotDivert ) ;

                //****************************************************************************************************************************************************************************************************************************************************************************************************
                //****************************************************************************************************************************************************************************************************************************************************************************************************
                //****                                          ******************************************************************************************************************************************************************************************************************************************************
                //****  DO NOT DIVERT IF RECENTLY NOT DIVERTED  ******************************************************************************************************************************************************************************************************************************************************
                //****                                          ******************************************************************************************************************************************************************************************************************************************************
                //****************************************************************************************************************************************************************************************************************************************************************************************************
                //****************************************************************************************************************************************************************************************************************************************************************************************************

                _IO_
            {
            TN( tDomainPeer , "" ) ;
            ZE( boolT , bDivert     ) ;
            ZE( boolT , bForceReply ) ;
            boolT bSilent = 1 ;         //PS:PERSONALITY: I DO NOT RESPOND UNLESS I KNOW THE ANSWER TO THE QUERY ; THIS IS INTENDED TO CAUSE THE REQUESTING PEER TO FAILOVER TO MAKE THE REQUEST FROM ITS ALTERNATE DNS SERVER

            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****               *********************************************************************************************************************************************************************************************************************************************************************************
            //****  SET bDivert  *********************************************************************************************************************************************************************************************************************************************************************************
            //****               *********************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
        {
        if( !gvP.bQuit )

        /**/etRock.traceF( tin0P , T("pulled a job") ) ;

        mySettingsUse.grabMe.ungrabF( tin0P ) ;
        nicNameC nnGorilla1 = etThread.sockNicNameF( tin0P , mySettingsUse.tIpGorilla1 ) ;
        nicNameC nnWebHook2 = etThread.sockNicNameF( tin0P , mySettingsUse.tIpWebHook2 ) ;
        nicNameC nnWebHook1 = etThread.sockNicNameF( tin0P , mySettingsUse.tIpWebHook1 ) ;
        /**/etRock.traceF( tin0P , T("[offSettingsUseSnap,tIpWebHook1,tIpWebHook2,tIpGorilla1]:    ")+TF2(offSettingsUseSnap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+mySettingsUse.tIpWebHook1+tb4+mySettingsUse.tIpWebHook2+tb4+mySettingsUse.tIpGorilla1 ) ;
        mySettingsUse.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

        mySettingsS& mySettingsUse = offSettingsUseSnap % 2 ? mySettingsBP : mySettingsAP ;        //P:PERSONALITY: I WILL USE THE SAME SETTINGS INSTANCE FOR ALL PROCESSING FOR A JOB
        const countT offSettingsUseSnap = offSettingsUseP ;

        gvP.cirJob >> &job ;
        jobS job ;

        //etRock.traceF( tin0P , T("pulling a job") ) ;
    {
    while( !gvP.bQuit )
    TN( tLongWoTimePasswordUrlSuffix , "" ) ; tLongWoTimePasswordUrlSuffix = T("///d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(ifcIDaDAM_DNS)+T("/woTimePasswordUrlSuffix") ;
    ZE( sCountT , timeLetsEncryptLath2 ) ;
    ZE( countT  , timeLetsEncryptLath1 ) ;

    TN( tLongAcmeChallengeValue2 , "///d/acme/txt.challenge.value."   "hidden.ideafarm.com.ttt" ) ;
    TN( tLongAcmeChallengeValue1 , "///d/acme/txt.challenge.value." "_.hidden.ideafarm.com.ttt" ) ;

    stackC stsQueries(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stsReplies(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stsRepliesNU( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    etherC& etRock = etherC::etRockIF( tin0P ) ;
    TN( tb4 , "    " ) ;

    nicNameC&             nnIdeaNetUseP              =             *(nicNameC*)pTaskP->c41 ;
    ideaNetSubscriptionC& ideaNetSubP                = *(ideaNetSubscriptionC*)pTaskP->c31 ;
    stackC&               stRecentHashP              =               *(stackC*)pTaskP->c21 ;
    stackC&               stNnPeerBlockP             =               *(stackC*)pTaskP->c11 ;
    textC&                tRandomLabelPrefixLagP     =                *(textC*)pTaskP->c01 ;
    textC&                tRandomLabelPrefixP        =                *(textC*)pTaskP->cf  ;
    textC&                tSuffix2GorillaP           =                *(textC*)pTaskP->ce  ;
    grabC&                grab_tSuffix2GorillaP      =                *(grabC*)pTaskP->cd  ;
    textC&                tSuffix1GorillaP           =                *(textC*)pTaskP->cc  ;
    grabC&                grab_tSuffix1GorillaP      =                *(grabC*)pTaskP->cb  ;
    gVarS&                gvP                        =                *(gVarS*)pTaskP->ca  ;
    gConstS&              gcP                        =              *(gConstS*)pTaskP->c9  ;
    socketC&              sockdP                     =              *(socketC*)pTaskP->c8  ;
    mySettingsS&          mySettingsBP               =          *(mySettingsS*)pTaskP->c7  ;
    mySettingsS&          mySettingsAP               =          *(mySettingsS*)pTaskP->c6  ;
    countT&               offSettingsUseP            =               *(countT*)pTaskP->c5  ;
    circleC&              cirRecentDomainGrossTraceP =              *(circleC*)pTaskP->c4  ;
    circleC&              cirNnPeerDoNotDivertP      =              *(circleC*)pTaskP->c3  ;
    countT&               cWorkersP                  =               *(countT*)pTaskP->c2  ;
    boolT&                bFailP                     =                *(boolT*)pTaskP->c1  ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 && pTaskP->c8 && pTaskP->c9 && pTaskP->ca && pTaskP->cb && pTaskP->cc && pTaskP->cd && pTaskP->ce && pTaskP->cf && pTaskP->c01 && pTaskP->c11 && pTaskP->c21 )
TASK( tmWorkerF )

DONE( tmRememberRecentIdeaNetHashP )
}
    }
        ++ s ; etThread.osSleepF( tin0P , TUCK >> 6 ) ;

        }
            stRecentHashP.purgeF( tin0P , 8 ) ;     //U:: 4 IS PROBABLY ENOUGH
            stRecentHashP << hashNow ;
            nnIdeaNetUseP = ideaNetSubP.nnF( tin0P , hashNow , minute ) ;
            ZE( countT , hashNow ) ;

            etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT  , timeN1 ) ;

            minuteLath = minute ;
        {
        if( minuteLath != minute )                          // A:ASSUME: THE LIFETIME OF EACH ipv6 ADDRESS IS GREATER THAN RE MINUTES, SO THAT THE ipv6 OF THE LATH MINUTE WILL CONTINUE TO BE VALID WELL AFTER I NO LONGER OBTAIN ITS VALUE
        countT minute = ( timeN1 >> 0x14 ) - 1 ;            // USE THE PRIOR MINUTE (TO AVOID RACING WITH THE WEB SERVER)

        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;
    {
    while( !ether )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    ZE( countT , minuteLath ) ;

    ideaNetSubscriptionC& ideaNetSubP   = *(ideaNetSubscriptionC*)pTaskP->c3 ;
    stackC&               stRecentHashP =               *(stackC*)pTaskP->c2 ;
    nicNameC&             nnIdeaNetUseP =             *(nicNameC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmRememberRecentIdeaNetHashP )

DONE( tmBlockF )
}
    }
        ++ s ; ether.osSleepF( tin0P , TICK >> 2 ) ;
        etThread.osFirewallBlockF( tin0P , LF , stNnPeerBlockP , T("dns bSilent is set") , T("dns bSilent, so blocking peers [idSet]:    ")+TF2(++idSet,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( !ether )
    ZE( countT , idSet ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    stackC& stNnPeerBlockP = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmBlockF )

DONE( tmCatchLabelSuffixF )
}
    }
        }
            }
                etRock.traceF( tin0P , T("!exception / impotence while catching [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )

            }
                etThread.delF( tin0P , pbi ) ;
                }
                    }
                        /**/etThread.traceF( tin0P , tSay2+tSuffix2GorillaP ) ;
                        grab_tSuffix2GorillaP.ungrabF( tin0P ) ;
                        tSuffix2GorillaP = T(pbi) ;
                        grab_tSuffix2GorillaP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                    {
                    else if( pbi == thirdC::c_strstrIF( tin0P , pbi , "wh2" ) )
                    }
                        /**/etThread.traceF( tin0P , tSay1+tSuffix1GorillaP ) ;
                        grab_tSuffix1GorillaP.ungrabF( tin0P ) ;
                        tSuffix1GorillaP = T(pbi) ;
                        grab_tSuffix1GorillaP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                    {
                    if( pbi == thirdC::c_strstrIF( tin0P , pbi , "wh1" ) )
                {
                //if( nnPeer == nnAllowed )

                sCatch.readF( tin0P , pbi , cbi , idPortHe , nnPeer ) ; ___( pbi ) ;
                nicNameC nnPeer ;
                ZE( countT , idPortHe ) ;
                ZE( countT , cbi ) ;
                ZE( byteT* , pbi ) ;
            {
            while( !ether && !POOP )

            etRock.traceF( tin0P , T("catching begun [idpCatch]:    ")+TF4(idpCatch,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
            etScratch.boxPutF( tin0P , tLong , (byteT*)&idpCatch , sizeof idpCatch ) ;
            countT idpCatch = sCatch.bindF( tin0P ) ;
            socketC sCatch( tin0P , etScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
            etherC& etScratch = *((tin1S&)tin0P).pEtScratch ;

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
    {
    while( !ether )

    TN( tSay2 , "caught [tSuffix2Gorilla]:    " ) ;
    TN( tSay1 , "caught [tSuffix1Gorilla]:    " ) ;
    TN( tLong , "" ) ; tLong = T("///d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(ifcIDaDAM_DNS)+T("/idpCatchLabelSuffix") ;
    //nicNameC nnAllowed = etThread.sockNicNameF( tin0P , T("10.0.3.1") ) ;
    etherC&  etRock    = etherC::etRockIF( tin0P ) ;

    textC& tSuffix2GorillaP      = *(textC*)pTaskP->c4 ;
    grabC& grab_tSuffix2GorillaP = *(grabC*)pTaskP->c3 ;
    textC& tSuffix1GorillaP      = *(textC*)pTaskP->c2 ;
    grabC& grab_tSuffix1GorillaP = *(grabC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmCatchLabelSuffixF )

DONE( tmRandomizeWebhookDomainPrefixF )
}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK << 3 ) ;

        DEL( pSwPathValue ) ;
        }
            }
                etThread.delF( tin0P , psttValue ) ;
        
                }
                    }
                        etRock.traceF( tin0P , T("**** AFTER UPDATE ****    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] ) ;
                        *pptValue[ offe ] = T(psttValue) ;
                    {
                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                {
                for( countT offe = 0 ; offe < cPaths ; offe ++ )
        
                if( cPaths - cValues ) { BLAMMO ; }
                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
        
                //etRock.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                //etRock.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;
        
                strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
        
                _IO_
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
            
            ;
            }
                &tPathUrl ,
            {
            textC* pptPath[] =
            
            TN( tPathUrl , "\"url\"/" ) ;
            
            ;
            }
                &tValueUrl ,                                                                                                                                                    //CS:CODEsYNC: 510008af 510008af    ; CODE ASSUMES THAT tValueUrl IS AT OFFSET 0
            {
            textC* pptValue[] =

            TN( tValueUrl , "" ) ;
        {
        if( pSwPathValue )

        }        
            }
                }
                    }
                        }
                            }
                                DEL( pSwPathValue ) ;
                                etRock.traceF( tin0P , tSayExCouldNotParseJson+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tDomainStripeApi ) ;
                                POOPRqUIET
                                countT rc = POOP ;
                            {
                            if( POOP )
                            __Z( pSwPathValue ) ;
                            ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                            //etRock.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                            //etRock.traceF( tin0P , T("json response:") ) ;
                            _IO_
                        {
                        else
                        }
                            etRock.traceF( tin0P , tSayExCouldNotReadFromSocket+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tDomainStripeApi ) ;
                            POOPRqUIET
                            countT rc = POOP ;
                            _IO_
                        {
                        if( POOP )
                
                        }
                            __NZ( costj == sizeof postj ) ;
                            }
                                else if( costj ) break ;
                                     if( cNest ) costj ++ ;
                    
                                else if( postj[ costj ] == '}' ) cNest -- ;
                                     if( postj[ costj ] == '{' ) cNest ++ ;
                    
                                //putchar( postj[ costj ] ) ;

                                if( !cbIn ) break ;
                                countT cbIn = sock.readF( tin0P , postj + costj , 1 ) ;
                            {
                            while( !POOP && costj < sizeof postj )
                            ZE( countT , cNest ) ;
                            ZE( countT , costj ) ;
                        {
                        thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                        osTextT postj[ TOCK ] ;
                        _IO_
                    {
                    else
                    }
                        etRock.traceF( tin0P , tSayExCouldNotWriteToSocket+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tDomainStripeApi ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                        _IO_
                    {
                    if( POOP )
                    sock.writeF( tin0P , (osTextT*)tSay ) ;
                    //etRock.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                    //etRock.traceF( tin0P , T("request:") ) ;

                    mySettingsUse.grabMe.ungrabF( tin0P ) ;
                    TN( tSay , "" ) ; tSay = T("POST ")+tPathEndpoint+mySettingsUse.tStripeIdObjectWebhookDestinationTest+T("?url=https%3A%2F%2F")+tRandomLabelPrefixP+T("-3DFg.hidden.ideafarm.com%2Fnobot%2Fnotify%2Fstripe.20240206%401123 HTTP/1.1\r\nAuthorization: Bearer ")+mySettingsUse.tStripeApiKeyTest+T("\r\nHost: api.stripe.com\r\nStripe-Version: 2024-06-20\r\n\r\n") ;
                    mySettingsUse.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                    }
                        ++ s ; thirdC::dosSleepWinkIF( tin0P , 4 ) ;                        // NAP FOR A WINK TO GIVE HTTP AND GORILLA SERVERS TIME TO CATCH THE DATAGRAM
                        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                        etThread.delF( tin0P , pbi ) ;
                        }
                            sThrow.writeF( tin0P , idpCatch , nnHe3 , tThrow , tThrow.csF( tin0P ) ) ;
                            /**/etRock.traceF( tin0P , tSayThrowing3+tThrow ) ;
                            countT idpCatch = *(countT*)pbi ;
                        {
                        if( pbi && cbi == sizeof( countT ) )
                        }
                            }
                                etThread.delF( tin0P , pbi ) ;
                                etRock.traceF( tin0P , T("!exception / could not get contents of ")+tLongThrowToPort3 ) ;
                                POOPR ;
                            {
                            if( POOP )
                            ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , pbi , cbi , tLongThrowToPort3 ) ; ___( pbi ) ;
                            SCOOPS
                        {
                        IFsCRATCHoK

                        cbi = 0 ;
                        etThread.delF( tin0P , pbi ) ;
                        }
                            sThrow.writeF( tin0P , idpCatch , nnHe2 , tThrow , tThrow.csF( tin0P ) ) ;
                            /**/etRock.traceF( tin0P , tSayThrowing2+tThrow ) ;
                            countT idpCatch = *(countT*)pbi ;
                        {
                        if( pbi && cbi == sizeof( countT ) )
                        }
                            }
                                etThread.delF( tin0P , pbi ) ;
                                etRock.traceF( tin0P , T("!exception / could not get contents of ")+tLongThrowToPort2 ) ;
                                POOPR ;
                            {
                            if( POOP )
                            ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , pbi , cbi , tLongThrowToPort2 ) ; ___( pbi ) ;
                            SCOOPS
                        {
                        IFsCRATCHoK

                        cbi = 0 ;
                        etThread.delF( tin0P , pbi ) ;
                        }
                            sThrow.writeF( tin0P , idpCatch , nnHe1 , tThrow , tThrow.csF( tin0P ) ) ;
                            /**/etRock.traceF( tin0P , tSayThrowing1+tThrow ) ;
                            countT idpCatch = *(countT*)pbi ;
                        {
                        if( pbi && cbi == sizeof( countT ) )
                        }
                            }
                                etThread.delF( tin0P , pbi ) ;
                                etRock.traceF( tin0P , T("!exception / could not get contents of ")+tLongThrowToPort1 ) ;
                                POOPR ;
                            {
                            if( POOP )
                            ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , pbi , cbi , tLongThrowToPort1 ) ; ___( pbi ) ;
                            SCOOPS
                        {
                        IFsCRATCHoK
                        ZE( countT , cbi ) ;
                        ZE( byteT* , pbi ) ;

                        socketC sThrow( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

                        TN( tThrow , "" ) ; tThrow = tRandomLabelPrefixP+tb+tRandomLabelPrefixLagP ;
                        _IO_
                    {

                    gvP.tDomainWebHooksNet    = tRandomLabelPrefixP   +gcP.tDotHiddenDomain ;
                    }
                        tRandomLabelPrefixP = TF3(++idLabelPrefixLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T("_")+tNewPassword ;

                        TN( tNewPassword , "" ) ; tNewPassword = TF4((countT)ruPassword,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FILLzE,0,0x24) ;    //[0-9,a-z]
                        countT idNewPassword = ruPassword ;
                        _IO_
                    {
                    gvP.tDomainWebHooksNetLag = tRandomLabelPrefixLagP+gcP.tDotHiddenDomain ;

                    tRandomLabelPrefixLagP = tRandomLabelPrefixP                         ;
                    _IO_
                {
                else
                }
                    etRock.traceF( tin0P , tSayExCouldNotConnectToServer+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tDomainStripeApi ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                    _IO_
                {
                if( POOP )
                sock.connectF( tin0P , 443 , nnServer ) ;
                socketC sock( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL ) ;

                //etRock.traceF( tin0P , T("connecting to IPv4:    ")+T(nnServer) ) ;
                _IO_
            {
            else
            }
                etRock.traceF( tin0P , tSayExCouldNotObtainNnServer+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tDomainStripeApi ) ;
                POOPRqUIET
                countT rc = POOP ;
                _IO_
            {
            if( POOP )
            nicNameC nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tDomainStripeApi ) ;
            _IO_

            SCOOPS
        {
        IFsCRATCHoK
        ZE( switchC* , pSwPathValue ) ;
        ZE( strokeS* , psttPath     ) ;

        mySettingsS& mySettingsUse = offSettingsUseSnap % 2 ? mySettingsBP : mySettingsAP ;
        const countT offSettingsUseSnap = offSettingsUseP ;
        _IO_
    {
    while( !ether )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    ZE( countT , idLabelPrefixLath ) ; //U:: FOR TESTING ONLY ; REPLACE WITH RANDOM NUMBER THAT IS UPDATED RANDOMLY
    ranUniC ruPassword( tin0P , (measure04T)MAXcOUNTT + 1 , processGlobal1S::_processGlobal1I_IF().trueRandom ) ;

    nicNameC nnHe3 = etThread.sockNicNameF( tin0P , T("10.0.3.1") ) ;
    nicNameC nnHe2 = etThread.sockNicNameF( tin0P , T("10.0.1.2") ) ;
    nicNameC nnHe1 = etThread.sockNicNameF( tin0P , T("10.0.1.1") ) ;

    TN( tSayExCouldNotParseJson       , "!exception / could not parse json [rc,domain]:    " ) ;
    TN( tSayExCouldNotReadFromSocket  , "!exception / could not read from socket [rc,domain]:    " ) ;
    TN( tSayExCouldNotWriteToSocket   , "!exception / could not write to socket [rc,domain]:    " ) ;
    TN( tSayExCouldNotConnectToServer , "!exception / could not connect to server [rc,domain]:    " ) ;
    TN( tSayExCouldNotObtainNnServer  , "!exception / could not obtain IPv4 [rc,domain]:    " ) ;

    //CS:CODEsYNC: dns.2/ CHANGES AFTER dns.1/ CHANGES, SO WATCHER SHOULD WAIT FOR dns.2/ AND THEN WAIT FOR dns.1/

    TN( tSayThrowing3 , "throwing to go1 [tLabelPrefix]:    " ) ;
    TN( tSayThrowing2 , "throwing to wh2 [tLabelPrefix]:    " ) ;
    TN( tSayThrowing1 , "throwing to wh1 [tLabelPrefix]:    " ) ;
    TN( tLongThrowToPort3 , "" ) ; tLongThrowToPort3 = T("////go1/d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(ifcIDaDAM_GORILLAwEBHOOKS)+T("/idpCatchLabelPrefix") ;
    TN( tLongThrowToPort2 , "" ) ; tLongThrowToPort2 = T("////wh2/d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(ifcIDaDAM_ROOThTTPsERVER )+T("/idpCatchLabelPrefix") ;
    TN( tLongThrowToPort1 , "" ) ; tLongThrowToPort1 = T("////wh1/d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(ifcIDaDAM_ROOThTTPsERVER )+T("/idpCatchLabelPrefix") ;

    TN( tLongRandomLabelPrefix    , "////dns1/d/ideafarm.home.101/controls/set.by.dns.2/dnsRandomLabelPrefix"    ) ;      //CS:CODEsYNC: 510008af 510005ab
    TN( tLongRandomLabelPrefixLag , "////dns1/d/ideafarm.home.101/controls/set.by.dns.1/dnsRandomLabelPrefixLag" ) ;      //CS:CODEsYNC: 510008af 510005ab
    TN( tPathEndpoint    , "/v1/webhook_endpoints/" ) ;
    TN( tDomainStripeApi , "api.stripe.com" ) ;
    TN( tb4 , "    " ) ;
    TN( tb , " " ) ;

    etherC& etRock = etherC::etRockIF( tin0P ) ;

    // FOR SIMPLICITY AND RELIABILITY, A NEW CONNECTION IS ESTABLISHED FOR EACH ITERATION (THIS CAN BE OPTIMIZED)
    // THIS IS JUST SKELETON CODE FOR PROOF OF CONCEPT ; I PERIODICALLY UPDATE THE STRIPE WEBHOOK DESTINATION URL FOR THE TEST ENVIRONMENT, BUT ALWAYS TO THE SAME VALUE

    textC&       tRandomLabelPrefixLagP     =       *(textC*)pTaskP->c7 ;
    textC&       tRandomLabelPrefixP        =       *(textC*)pTaskP->c6 ;
    gVarS&       gvP                        =       *(gVarS*)pTaskP->c5 ;
    gConstS&     gcP                        =     *(gConstS*)pTaskP->c4 ;
    mySettingsS& mySettingsBP               = *(mySettingsS*)pTaskP->c3 ;
    mySettingsS& mySettingsAP               = *(mySettingsS*)pTaskP->c2 ;
    countT&      offSettingsUseP            =      *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmRandomizeWebhookDomainPrefixF )

}
    return 0 ;
    ((tin1S&)tin0P).pEther->delF( tin0P , psttd ) ;
    strokeS*& psttd = *(strokeS**)cAtP ;
{
countT deleteElementF( tin0S& tin0P , countT& cAtP , countT& cArgDeleteP )

//U::6: DONE( tmUpdateNnHostsF )
//U::6: }
//U::6:     }
//U::6:         ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;
//U::6: 
//U::6:         }
//U::6:             }
//U::6:                 etRock.traceF( tin0P , T("!exception / could not write batch file [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLong ) ;
//U::6:                 POOPRqUIET
//U::6:                 countT rc = POOP ;
//U::6:             {
//U::6:             else
//U::6:             if( !POOP ) ;//etRock.traceF( tin0P , T("wrote batch file aok [tLong]:    ")+tLong ) ;
//U::6:             ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , tBatFileImage , tBatFileImage.csF( tin0P ) ) ;
//U::6:             SCOOPS
//U::6:             _IO_
//U::6:         {
//U::6:         IFsCRATCHoK
//U::6:         TN( tBatFileImage , "" ) ; tBatFileImage = T("@echo off\r\n")+tBefore2+tNnHostWeb+tAfter2+T("\r\n") ;
//U::6:         tLong = T("////web1/d/ideafarm.home.101/controls/drop.executables/new.ipv6.netsh.from.dns.")+TfORsTRING(++idFileOut)+T(".bat" ) ;
//U::6:         //etRock.traceF( tin0P , T("new  [nnHostWebLag0]:    ")+tNnHostWeb ) ;
//U::6:         TN( tNnHostWeb , "" ) ; tNnHostWeb = T(nnHostWebLag0P) ;
//U::6: 
//U::6:                                                            nnHostWebLag0P = nnHostWebLathP ;
//U::6:                                           nnHostWebLag1P = nnHostWebLag0P ;
//U::6:                          nnHostWebLag2P = nnHostWebLag1P ;
//U::6:         nnHostWebLag3P = nnHostWebLag2P ;
//U::6: 
//U::6:         ( *(count04T*)&nnHostWebLathP ) ++ ;
//U::6: 
//U::6:         }
//U::6:             }
//U::6:                 }
//U::6:                     etRock.traceF( tin0P , T("!exception / could not write batch file [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLong ) ;
//U::6:                     POOPRqUIET
//U::6:                     countT rc = POOP ;
//U::6:                 {
//U::6:                 else
//U::6:                 if( !POOP ) ;//etRock.traceF( tin0P , T("wrote batch file aok [tLong]:    ")+tLong ) ;
//U::6:                 ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , tBatFileImage , tBatFileImage.csF( tin0P ) ) ;
//U::6:                 SCOOPS
//U::6:                 _IO_
//U::6:             {
//U::6:             IFsCRATCHoK
//U::6:             TN( tBatFileImage , "" ) ; tBatFileImage = T("@echo off\r\n")+tBefore1+tNnHostWeb+tAfter1+T("\r\n") ;
//U::6:             tLong = T("////web1/d/ideafarm.home.101/controls/drop.executables/new.ipv6.netsh.from.dns.")+TfORsTRING(++idFileOut)+T(".bat" ) ;
//U::6: 
//U::6:             //etRock.traceF( tin0P , T("doomed [nnHostWebLag3]:    ")+tNnHostWeb ) ;
//U::6:             TN( tNnHostWeb , "" ) ; tNnHostWeb = T(nnHostWebLag3P) ;
//U::6:         {
//U::6:         if( ~nnHostWebLag3P )
//U::6:         TN( tLong , "" ) ; 
//U::6:     {
//U::6:     while( !ether )
//U::6:     ZE( countT , idFileOut ) ;
//U::6:     sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
//U::6: 
//U::6:     TN( tb4      , "    " ) ;
//U::6:     TN( tAfter2  , "/64\"" ) ;
//U::6:     TN( tAfter1  , "\"" ) ;
//U::6:     TN( tBefore2 , "netsh interface ipv6 add    address interface=\"outer\" address=\"" ) ;
//U::6: 
//U::6:     ) ;
//U::6: 
//U::6:         "netsh interface ipv6 delete address interface=\"outer\" address=\""
//U::6:         "netsh interface ipv6 delete address interface=\"outer\" address=\"2001:19f0:0:7077:5400:5ff:fe59:278d\"\r\n"            //U:: PUT THIS INTO A SETTING
//U::6: 
//U::6:     TN( tBefore1 ,
//U::6: 
//U::6:     //
//U::6:     // ADD    THE YOUNGEST ADDRESS (LAG 0)
//U::6:     // SET    THE YOUNGEST ADDRESS (LAG 0)
//U::6:     // SHIFT  THE DATA TO LAG
//U::6:     // DELETE THE OLDEST   ADDRESS (LAG 3)
//U::6:     //
//U::6:     // RECIPE
//U::6: 
//U::6:     nicNameC& nnHostWebLag3P = *(nicNameC*)pTaskP->c5 ;
//U::6:     nicNameC& nnHostWebLag2P = *(nicNameC*)pTaskP->c4 ;
//U::6:     nicNameC& nnHostWebLag1P = *(nicNameC*)pTaskP->c3 ;
//U::6:     nicNameC& nnHostWebLag0P = *(nicNameC*)pTaskP->c2 ;
//U::6: 
//U::6:     nicNameC& nnHostWebLathP = *(nicNameC*)pTaskP->c1 ;     // WILL ALWAYS BE THE SAME AS nnHostWebLag0P ; IS USED TO MAKE THE CODE EASIER TO UNDERSTAND
//U::6: 
//U::6:     _IO_
//U::6: {
//U::6: if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
//U::6: TASK( tmUpdateNnHostsF )

}
    }
        stsRepliesP << ps ;

        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // cSerial
        *ps << (countT)0 ; // cSerial
        *ps << psttEmailP ;
        *ps << psttNsP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_SOA ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_SOA_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttNsP , const strokeS* const psttEmailP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_NS ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_NS_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;
        *ps << (countT)0 ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_MX ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_MX_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_AAAA ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_AAAA_F [nnPeer,nn,name]:    peer: ")+T(nnPeerP)+T("    directed to: ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_AAAA_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP , const nicNameC& nnPeerP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_A ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_A_F [nnPeer,nn,name]:    peer: ")+T(nnPeerP)+T("    directed to: ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_A_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP , const nicNameC& nnPeerP )

}
    }
        stsRepliesP << ps ;

        *ps << psttvP ;                 //U:: ENHANCE THIS TO SUPPORT ARBITRARY BLOB (I.E. THAT CAN CONTAIN NULL BYTES AND ANY BYTE VALUE)
        *ps << cText ;
        countT cText = 1 ;
        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;          time1 = 0x01c79c71 ;  //INCRESED SLIGHTLY (1/2 TOCK, TO ROUND) FROM 17c17c10.00000000, WHICH IS 600 SECONDS, WHICH IS GODADDY MINIMUM TTL ; THIS IS DONE HERE SO RESPONSES CAN BE COMPARED WITH THOSE FROM GODADDY
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_TXT ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_TXT_F [nnPeer,value,name]:    peer: ")+T(nnPeerP)+T("    directed to: ")+T(psttvP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_TXT_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttvP , const nicNameC& nnPeerP )

DONE( tmFreshSettingsF )
}
    }
        }
            }
                sgnSettingsReadyP.giveF( tin0P , ifcIDmODEsIGNgIVE_ON ) ;       //U::ifcIDmODEsIGNgIVE_ON IS A WORKAROUND TO AN APPARENT RACE CONDITION IN WHICH I HANG TRYING FUTILELY TO grabF()
                bWoth = 0 ;
                _IO_
            {
            if( bWoth )

            }
                if( !POOP && !bWoth ) ++ offSettingsUseP ;        // NOT SERIALIZED BECAUSE offSettingsUseP % 2 CANNOT EVER POINT TO AN INVALID INSTANCE
                __NZ( !mySettingsNew ) ;

                }
                    if( ~mySettingsNew ) break ;

                    mySettingsNew.grabMe.ungrabF( tin0P ) ;
                    etRock.traceF( tin0P , T(!mySettingsNew?"the new settings are incomplete":"the new settings are aok")+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    mySettingsNew.freshenF( tin0P ) ;
                    /**/etRock.traceF( tin0P , T(!mySettingsNew?"the stale settings are incomplete":"the stale settings are aok")+tb4+TF2(++idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    mySettingsNew.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                    ++ s ; etThread.osSleepF( tin0P , TOCK << 2 ) ; // TIME FOR PISS TO FINISH UPDATING SETTINGS
                {
                while( !POOP )
                ZE( countT , idTry ) ;
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                ;
                        : mySettingsBP
                        ? mySettingsAP
                    : offSettingsUseP % 2
                    ? mySettingsAP
                mySettingsS& mySettingsNew = bWoth

                /**/etRock.traceF( tin0P , T("the timestamp of the settings files has changed ; napping and then calling freshenF") ) ;
                timeWrittenLath = timeWritten ;
                _IO_
            {
            if( timeWrittenLath.time1 != timeWritten.time1 || timeWrittenLath.time2 != timeWritten.time2 )

            }
                }
                    }
                        }
                            continue ;
                            /**/etRock.traceF( tin0P , T("!exception / could not get file time [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongFile ) ;
                            POOPRqUIET
                            countT rc = POOP ;
                        {
                        else
                        }
                            break ;
                            //etRock.traceF( tin0P , T(" [timeWritten]:    ")+TT(timeWritten.time1,timeWritten.time2) ) ;
                        {
                        if( !POOP )

                        thirdC::getFileTimeIF( tin0P , fir , &timeWritten , 0 , 0 ) ;
                    {
                    else
                    }
                        continue ;
                        /**/etRock.traceF( tin0P , T("!exception / could not open settings file to get file time [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongFile ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )

                    fileC fir( tin0P , (strokeS*)tLongFile , ifcOPENaCCESS_R , ifcOPENsHARE_WR , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;

                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                _IO_
            {
            while( !ether )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            timeS timeWritten ;
            _IO_
        {
        if( bWoth || etThread.etherC::diskWaitDirF( tin0P , hWait , ether , tLongPath , TICK >> 2 , flWAITdIR_ATTRIBUTE | flWAITdIR_SIZE | flWAITdIR_WRITE ) )
        _IO_
    {
    while( !ether && !POOP )
    timeS timeWrittenLath ;
    handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    TN( tb4 , "    " ) ;
    boolT bWoth = 1 ;

    etherC& etRock = etherC::etRockIF( tin0P ) ;

    TN( tLongFile , "" ) ; tLongFile = tLongPath + T("kv.settings.ipdos.jotC.data.booksC.1.book.00000001.00000001.bookC") ;

    }
        tLongPath = T(ifFile) ;
        ifFileNameC ifFile( tin0P , etThread , postPath ) ;

        __Z( *postPath ) ;
        thirdC::postPathStateSpaceIF( tin0P , postPath , sizeof postPath , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
        osTextT postPath[ TUCK << 1 ] ;
        _IO_
    {
    TN( tLongPath , "" ) ;

    mySettingsS&  mySettingsBP      =  *(mySettingsS*)pTaskP->c4 ;
    mySettingsS&  mySettingsAP      =  *(mySettingsS*)pTaskP->c3 ;
    countT&       offSettingsUseP   =       *(countT*)pTaskP->c2 ;
    signC&        sgnSettingsReadyP =        *(signC*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmFreshSettingsF )

}
    THREADmODE1rESTORE
    grabMe.ungrabF( tin0P ) ;

    }
        }
            else                                                                     break ;
            if( etherMe.strCompareF( tin0P , *pptDomainRootAllowed[ offt ] , tnu ) ) cDomainRootAllowed ++ ;
        {
        for( countT offt = 0 ; offt < sizeof pptDomainRootAllowed / sizeof pptDomainRootAllowed[ 0 ] ; offt ++ )
        cDomainRootAllowed = 0 ;
        TN( tnu , ".not.used.ideafarm.com" ) ;                                                          //P:PERSONALITY: I IGNORE ALL ELEMENTS NOT BEFORE THE WO'TH ELEMENT THAT CONTAINS THE "NOT USED" VALUE ; THIS IS FOR SPEED
        _IO_
    {

    }
        /**/etRock.traceF( tin0P , T("trusted (Stripe) [off,subnet]:    ")+TF3(offn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,3)+tb4+T(pnnSubnetTrusted[offn]) ) ;
    {
    for( countT offn = 0 ; offn < cnnSubnetTrusted ; offn ++ )

    }
        }
            }
                while( ~hWalk ) ;
                }
                    pnnSubnetTrusted[ offo ++ ] = nnSubnet ;
                    nicNameC& nnSubnet = (nicNameC&)stNnSubnetTrusted.downF( tin0P , hWalk ) ;
                {
                do
                handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , offo ) ;
                _IO_
            {
            if( pnnSubnetTrusted )
            etherMe.newF( tin0P , LF , pnnSubnetTrusted , cnnSubnetTrusted ) ; ___( pnnSubnetTrusted ) ;
        {
        if( cnnSubnetTrusted )
        cnnSubnetTrusted = stNnSubnetTrusted ;

        }
            etherMe.delF( tin0P , pstt1Nn ) ;
            }
                }
                    stNnSubnetTrusted.sinkF( tin0P , countTC() , nnSubnet , flSTACKsINK_UNIQUE ) ;

                    ;
                        : nnIPv46( 0x40 )
                        ? nnIPv46( 0x18 )
                    nicNameC nnSubnet = nnIPv46.isIPv4F()
                    nicNameC nnIPv46  = etherMe.sockNicNameF( tin0P , psttc1 ) ;

                    /**/etRock.traceF( tin0P , T("adding trusted:    ")+T(psttc1) ) ;
                {
                else
                if( !psttc1 || !psttc1->idAdam ) etRock.traceF( tin0P , T("!exception / null length trusted nicNameC value ignored") ) ;

                _IO_
            {
            FORsTRINGSiN1( pstt1Nn )

            countT cNn = etherMe.strWordsF( tin0P , pstt1Nn , tNnTrusted , sttq , T(" ,") ) ; ___( pstt1Nn ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1Nn ) ;
            _IO_
        {
        stackC stNnSubnetTrusted( tin0P , etherMe , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_nicNameC ) ;
        _IO_
    {

    zapF( tin0P ) ;

    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed8]:    \"")+tDomainRootAllowed8+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed7]:    \"")+tDomainRootAllowed7+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed6]:    \"")+tDomainRootAllowed6+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed5]:    \"")+tDomainRootAllowed5+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed4]:    \"")+tDomainRootAllowed4+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed3]:    \"")+tDomainRootAllowed3+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed2]:    \"")+tDomainRootAllowed2+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed1]:    \"")+tDomainRootAllowed1+T("\"") ) ;

    /**/etRock.traceF( tin0P , T("settings [tIpWebHook1,tIpWebHook2,tIpGorilla1,tStripeApiKeyTest,tStripeIdObjectWebhookDestinationTest]:    \"")+tIpWebHook1+T("\"    \"")+tIpWebHook2+T("\"    \"")+tIpGorilla1+T("\"    \"")+tStripeApiKeyTest+T("\"    \"")+tStripeIdObjectWebhookDestinationTest ) ;

    /**/etRock.traceF( tin0P , T("[tStripeIdObjectWebhookDestinationTest]:    ")+tStripeIdObjectWebhookDestinationTest ) ;
    }
        etherMe.delF( tin0P , psttEat ) ;
        tStripeIdObjectWebhookDestinationTest = T(psttEat) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.stripe.idobject.webhook.destination.test")  ) ; ___( psttEat ) ;
        _IO_
    {

    /**/etRock.traceF( tin0P , T("[tStripeApiKeyTest]:    ")+tStripeApiKeyTest ) ;
    }
        etherMe.delF( tin0P , psttEat ) ;
        tStripeApiKeyTest = T(psttEat) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.stripe.api.key.test")  ) ; ___( psttEat ) ;
        _IO_
    {

    /**/etRock.traceF( tin0P , T("[tNnTrusted]:    ")+tNnTrusted ) ;
    }
        etherMe.delF( tin0P , psttEat ) ;
        tNnTrusted = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.nn.trusted")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed8 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.8")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed7 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.7")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed6 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.6")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed5 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.5")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed4 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.4")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed3 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.3")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed2 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.2")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed1 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.1")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tIpGorilla1 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.go1")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tIpWebHook2 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh2")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        }
            tSuffixUsedByStripe = T(psttEat) ;
            etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
            _IO_
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.stripe.label.suffix")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , pstt1w ) ;
        }
            }
                break ;
                tIpWebHook1 = T(psttc1) ;
            {
            else if( bArmed )
            if( !etherMe.strCompareF( tin0P , tStatic , psttc1 ) ) bArmed = 1 ;
        {
        FORsTRINGSiN1( pstt1w )
        ZE( boolT , bArmed ) ;
        etherMe.strWordsF( tin0P , pstt1w , tNetshCommandIpv4 , sttq ) ; ___( pstt1w ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        TN( tStatic , "static" ) ;
        ZE( strokeS* , pstt1w ) ;
    
        // {kv: dns.wh1.netsh.command.ipv4.1 "netsh interface ip set address "outer" static 1.2.3.4 255.255.254.0 1.2.3.1"     }
    
        _IO_
    {
    else if( etherMe.strIdF( tin0P , tStatic , tNetshCommandIpv4 ) )
    }
        etherMe.delF( tin0P , psttEat ) ;
        tIpWebHook1 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1.dhcp")  ) ; ___( psttEat ) ;
        _IO_
    {
    if( etherMe.strIdF( tin0P , tDhcp , tNetshCommandIpv4 ) )

    }
        etherMe.delF( tin0P , psttEat ) ;
        }
            }
                ++ s ; etPrime.osSleepF( tin0P , TOCK >> 1 ) ;

                }
                    }
                        etherMe.delF( tin0P , psttLong ) ;
                        etRock.traceF( tin0P , T("!exception / will retry ; could not write to unique file [rc,like]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLike ) ;
                        POOPR ;
                        countT rc = POOP ;
                    {
                    else
                    if( !POOP ) break ;
                    ((tin1S&)tin0P).pEtScratch->boxPutUniqueF( tin0P , psttLong , tLike , tBatFileImage , tBatFileImage.csF( tin0P ) ) ;
                    SCOOPS
                {
                IFsCRATCHoK
            {
            while( !etPrime )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            ZE( strokeS* , psttLong ) ;

            TN( tLike , "" ) ; tLike = T("////wh1/d/ideafarm.home.101/controls/drop.executables/new.ipv4.netsh.from.dns.")+TfORsTRING(idFreshen)+T(".@1@.bat" ) ;
            TN( tBatFileImage , "" ) ; tBatFileImage = T("@echo off\r\n")+tNetshCommandIpv4+T("\r\n") ;

            tNetshCommandIpv4 = T(psttEat) ;
            etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.")+tNetshCommandIpv4SettingKey  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tNetshCommandIpv4SettingKey = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1.netsh.command.ipv4.settingkey")  ) ; ___( psttEat ) ;
        _IO_
    {

    grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

    countT idFreshen = 1 + incv02AM( idFreshenLath ) ;
    static countT idFreshenLath ;

    TN( tStatic , "static" ) ;
    TN( tDhcp   , "dhcp"   ) ;
    TN( tb4     , "    "   ) ;
    TN( tDot    , "."      ) ;
    TN( tDash   , "-"      ) ;
    etherC& etPrime = etherC::etPrimeIF( tin0P ) ;
    etherC& etRock  = etherC::etRockIF(  tin0P ) ;
    _IO_
{
voidT mySettingsS::freshenF( tin0S& tin0P )

}
    cnnSubnetTrusted = 0 ;

    }
        etherMe.delF( tin0P , pnnSubnetTrusted ) ;
        }
            DELzOMBIE( pDoomed ) ;
            nicNameC* pDoomed = pnnSubnetTrusted + offn ;
        {
        for( countT offn = 0 ; offn < cnnSubnetTrusted ; offn ++ )
    {
    if( pnnSubnetTrusted )
    _IO_
{
voidT mySettingsS::zapF( tin0S& tin0P )

}
    return bMissing ;

    ) ;
        !tStripeIdObjectWebhookDestinationTest.csF( tin0P )
        ||
        !tStripeApiKeyTest.csF( tin0P )
        ||
        !tDomainRootAllowed8.csF( tin0P )
        ||
        !tDomainRootAllowed7.csF( tin0P )
        ||
        !tDomainRootAllowed6.csF( tin0P )
        ||
        !tDomainRootAllowed5.csF( tin0P )
        ||
        !tDomainRootAllowed4.csF( tin0P )
        ||
        !tDomainRootAllowed3.csF( tin0P )
        ||
        !tDomainRootAllowed2.csF( tin0P )
        ||
        !tDomainRootAllowed1.csF( tin0P )
        ||
        !tSuffixUsedByStripe.csF( tin0P )
        ||
        !tIpGorilla1.csF( tin0P )
        ||
        !tIpWebHook2.csF( tin0P )
        ||
        !tIpWebHook1.csF( tin0P )
        ||
        !tNetshCommandIpv4.csF( tin0P )
        ||
        !tNetshCommandIpv4SettingKey.csF( tin0P )
    (
    boolT bMissing =
    TINSL
{
boolT mySettingsS::operator !( voidT )

}
    *(textC**)&pptDomainRootAllowed[ 7 ] = &tDomainRootAllowed8 ;
    *(textC**)&pptDomainRootAllowed[ 6 ] = &tDomainRootAllowed7 ;
    *(textC**)&pptDomainRootAllowed[ 5 ] = &tDomainRootAllowed6 ;
    *(textC**)&pptDomainRootAllowed[ 4 ] = &tDomainRootAllowed5 ;
    *(textC**)&pptDomainRootAllowed[ 3 ] = &tDomainRootAllowed4 ;
    *(textC**)&pptDomainRootAllowed[ 2 ] = &tDomainRootAllowed3 ;
    *(textC**)&pptDomainRootAllowed[ 1 ] = &tDomainRootAllowed2 ;
    *(textC**)&pptDomainRootAllowed[ 0 ] = &tDomainRootAllowed1 ;
{
cDomainRootAllowed(                    0                                                                  )
cnnSubnetTrusted(                      0                                                                  ) ,
pnnSubnetTrusted(                      0                                                                  ) ,
tStripeIdObjectWebhookDestinationTest( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tStripeApiKeyTest(                     tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tTestTextResponse(                     tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "abcdefgh"               ) ,
tNnTrusted(                            tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed8(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed7(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed6(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed5(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed4(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed3(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed2(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed1(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tIpGorilla1(                           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tIpWebHook2(                           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tIpWebHook1(                           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tSuffixUsedByStripe(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tNetshCommandIpv4(                     tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tNetshCommandIpv4SettingKey(           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
grabMe(                                tin0P , TAG( TAGiDnULL ) , flGRABc_SHARElAYER | flGRABc_NOTjEALOUS ) ,
etherMe(                               etherP                                                             ) ,
mySettingsS::mySettingsS( tin0S& tin0P , etherC& etherP ) :

}
    zapF( tin0P ) ;
    TINSL
{
mySettingsS::~mySettingsS( voidT )

NEWdELcLASS( 1 , jobS ) ;

;
}
    }
        //U::6: nnHostWebLag0 = etherP.sockNicNameF( tin0P , T("2001:19f0:0000:7077:5400:05ff:fe59:278d") ) ;        //U:: PUT THIS INTO A SETTING ; THIS IS THE IPv6 ASSIGNED TO web1
        //U::6: nnHostWebLag0 = etherP.sockNicNameF( tin0P , T("2001:19f0:0:7077::1") ) ;        //U:: FOR TESTING
        //U::6: nnHostWebLath = etherP.sockNicNameF( tin0P , T("2001:19f0:0:7077::") ) ;                             //U:: PUT THIS INTO A SETTING ; THIS IS THE BEGINNING VALUE THAT IS INCREMENTED BY tmUpdateNnHostsF TO OBTAIN AN EPHEMERAL (AND EVENTUALLY RANDOM) IPv6 VALUE FOR web1
    {
    tDomainWebHooksNetLag( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" )
    tDomainWebHooksNet(    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
    cirJob(  tin0P , etherP , bQuit , flCIRCLEc_null , sizeof jobS , TUCK << 0 ) ,
    idClient( 0 ) ,
    bQuit( 0 ) ,
    inline gVarS( tin0S& tin0P , etherC& etherP , gConstS& gcP , mySettingsS& mySettingsP ) :

    //U::6: nicNameC nnHostWebLag3 ;
    //U::6: nicNameC nnHostWebLag2 ;
    //U::6: nicNameC nnHostWebLag1 ;
    //U::6: nicNameC nnHostWebLag0 ;
    //U::6: nicNameC nnHostWebLag0 ;
    //U::6: nicNameC nnHostWebLath ;

    textC   tDomainWebHooksNetLag ;
    textC   tDomainWebHooksNet    ;
    circleC cirJob                ;
    countT  idClient              ;
    boolT   bQuit                 ;
{
struct gVarS

;
}
    }
    {
    //U::6: , tTarget(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "target.ipv6-only.ideafarm.com" )

    tDotLetsEncryptDotOrg(              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".letsencrypt.org"                                                                                                      )

    tSayAcmeChallengeValue(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "TXT acme.challenge [value]:    "                                                                                       ) ,
    tSayTraceMarkEnd(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "---------------------------------------------------------------------------------------------------------------------" ) ,
    tSayTraceMarkBegin(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" ) ,
    tDomainGrossTraceMarkEnd(           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".traceend.hidden.ideafarm.com"                                                                                         ) ,
    tDomainGrossTraceMarkBegin(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".tracebegin.hidden.ideafarm.com"                                                                                       ) ,

    tSayGranting(                       tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "    granting information    "                                                                                          ) ,
    tSayDiverting(                      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "    diverting information    "                                                                                         ) ,
    tSayUnknownDomain(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "    !exception / unknown peer domain"                                                                                  ) ,
    tSayPrefix(                         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "[nnPeer]:    "                                                                                                         ) ,

    tSayReadSuffixFile(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "read    suffix file [suffix]:    "                                                                                     ) ,
    tSayReadingSuffixFile(              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "reading suffix file"                                                                                                   ) ,
    tSayPushedDomain(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "pushed domain  [cDomains]:    "                                                                                        ) ,
    tSayPushingDomain(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "pushing domain [cDomains]:    "                                                                                        ) ,
    tSayPushedPeer(                     tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "pushed peer  [cPeers]:    "                                                                                            ) ,
    tSayPushingPeer(                    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "pushing peer [cPeers]:    "                                                                                            ) ,
    tSayPushedJob(                      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "pushed job  [cBacklog]:    "                                                                                           ) ,
    tSayPushingJob(                     tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "pushing job [cBacklog]:    "                                                                                           ) ,
    tSayPurgedStacks(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "purged  stacks"                                                                                                        ) ,
    tSayPurgingStacks(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "purging stacks"                                                                                                        ) ,
    tSayExCouldNotWriteReply(           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / could not write reply [rc]:    "                                                                          ) ,
    tSayWroteReply(                     tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "wrote reply"                                                                                                           ) ,
    tSayReplying1(                      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "replying / 1 [cbr]:    "                                                                                               ) ,
    tSayExCouldNotBuildReply(           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / could not build reply [rc]:    "                                                                          ) ,
    tSaySilence(                        tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "silence [tDomainGross]:    "                                                                                           ) ,
    tSayReplying2(                      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "replying / 2 [tDomainGross]:    "                                                                                      ) ,
    tSayAAAARequest(                    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "AAAA request [tDomainNet]:    "                                                                                        ) ,
    tSayARequest(                       tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "A request [tDomainNet]:    "                                                                                           ) ,
    tSayExCouldNotReadPasswordFile(     tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / could not read password suffix shared file [rc,costg,(countT)postg,postg,tLong]:    "                     ) ,
    tSayWrotePasswordFile(              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "wrote password suffix shared file aok [tLong]:    "                                                                    ) ,
    tSaySettingNewPassword(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "setting bNewPassword because suffix has already been used too many times or for too long [gv.tGorillaSuffixUsed]:    " ) ,
    tSayResettingDivert(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "resetting bDivert because suffix has already been used [gv.tGorillaSuffixUsed]:    "                                   ) ,
    tSayDomainNetSuffixPeer(            tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "[bValid,domainNet,actual,valid,valid2,peer,tDomainPeer]:    "                                                          ) ,
    tSayDomainGrossPeer(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "[domainGross,peer]:    \""                                                                                             ) ,
    tSayLoweringCase(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "lowering case"                                                                                                         ) ,
    tSayPoppingQuery(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "popping a query"                                                                                                       ) ,
    tSayExCouldNotParse(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / could not parse query [rc]:    "                                                                          ) ,
    tSayCalledDnsParse(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "called  dnsParseF"                                                                                                     ) ,
    tSayCallingDnsParse(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "calling dnsParseF"                                                                                                     ) ,
    tSayNotDiverting(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: not diverting"                     ) ,

    //U::PROD: tSayDiverting2(          tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| * * * * D I V E R T I N G * * * *" ) ,
    tSayDiverting2(                     tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "D I V E R T I N G"                                                                                                     ) ,

    tSayDiversionEnabled(               tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "----------------------------------------------------------------------------------- DIVERSION ENABLED"                 ) ,
    tSayDiversionSuppressed(            tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ DIVERSION SUPPRESSED"              ) ,
    tSayDiversionSupRefreshed(          tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ DIVERSION SUPPRESSION REFRESHED"   ) ,
    tSayPeer(                           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "[tPeer]:    "                                                                                                          ) ,
    tSayExReverseLookupFailed(          tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / reverse DNS lookup failed"                                                                                ) ,
    tSayDoingReverseLookup(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "doing reverse DNS lookup"                                                                                              ) ,
    tSayExReadFailed(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / socket read failed [rc]:    "                                                                             ) ,
    tSayCalledRead(                     tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "called readF"                                                                                                          ) ,
    tSayCallingRead(                    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "calling readF"                                                                                                         ) ,
    tSayWaitedForPacket(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "waited for a packet [nnPeer,cbq]:    "                                                                                 ) ,
    tSayWaitingForPacket(               tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "waiting for a packet"                                                                                                  ) ,
    tSayInnerLoopBegun(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "inner loop begun"                                                                                                      ) ,

    tq(                                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "\""                                                                                                                    ) ,
    tqb4q(                              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "\"    \""                                                                                                              ) ,

    tAcmeChallenge(                     tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "_acme-challenge.hidden.ideafarm.com"                                                                                   ) ,
    tTestTextChallenge(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "testtxt.hidden.ideafarm.com"                                                                                           ) ,
    tDot(                               tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "."                                                                                                                     ) ,
    tDash(                              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "-"                                                                                                                     ) ,
    tb4(                                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "    "                                                                                                                  ) ,
    tPasswordPrefix(                    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                                                                      ) ,
    tDashSub1DashBook1DotIdeaNetDomain( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "-1-1.ideanet.ideafarm.com"                                                                                             ) ,
    tDotIdeaNetDomain(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".ideanet.ideafarm.com"                                                                                                 ) ,
    tDotHiddenDomain(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".hidden.ideafarm.com"                                                                                                  ) ,
    inline gConstS( tin0S& tin0P , mySettingsS& mySettingsP ) :

    //U::6: textC tTarget                       ;

    textC tDotLetsEncryptDotOrg                 ;

    textC tSayAcmeChallengeValue                ;
    textC tSayTraceMarkEnd                      ;
    textC tSayTraceMarkBegin                    ;
    textC tDomainGrossTraceMarkEnd              ;
    textC tDomainGrossTraceMarkBegin            ;

    textC tSayGranting                          ;
    textC tSayDiverting                         ;
    textC tSayUnknownDomain                     ;
    textC tSayPrefix                            ;

    textC tSayReadSuffixFile                    ;
    textC tSayReadingSuffixFile                 ;

    textC tSayPushedDomain                      ;
    textC tSayPushingDomain                     ;
    textC tSayPushedPeer                        ;
    textC tSayPushingPeer                       ;
    textC tSayPushedJob                         ;
    textC tSayPushingJob                        ;
    textC tSayPurgedStacks                      ;
    textC tSayPurgingStacks                     ;
    textC tSayExCouldNotWriteReply              ;
    textC tSayWroteReply                        ;
    textC tSayReplying1                         ;
    textC tSayExCouldNotBuildReply              ;
    textC tSaySilence                           ;
    textC tSayReplying2                         ;
    textC tSayAAAARequest                       ;
    textC tSayARequest                          ;
    textC tSayExCouldNotReadPasswordFile        ;
    textC tSayWrotePasswordFile                 ;
    textC tSaySettingNewPassword                ;
    textC tSayResettingDivert                   ;
    textC tSayDomainNetSuffixPeer               ;
    textC tSayDomainGrossPeer                   ;
    textC tSayLoweringCase                      ;
    textC tSayPoppingQuery                      ;
    textC tSayExCouldNotParse                   ;
    textC tSayCalledDnsParse                    ;
    textC tSayCallingDnsParse                   ;
    textC tSayNotDiverting                      ;
    textC tSayDiverting2                        ;
    textC tSayDiversionEnabled                  ;
    textC tSayDiversionSuppressed               ;
    textC tSayDiversionSupRefreshed             ;
    textC tSayPeer                              ;
    textC tSayExReverseLookupFailed             ;
    textC tSayDoingReverseLookup                ;
    textC tSayExReadFailed                      ;
    textC tSayCalledRead                        ;
    textC tSayCallingRead                       ;
    textC tSayWaitedForPacket                   ;
    textC tSayWaitingForPacket                  ;
    textC tSayInnerLoopBegun                    ;

    textC tq                                    ;
    textC tqb4q                                 ;

    textC tAcmeChallenge                        ;
    textC tTestTextChallenge                    ;
    textC tDot                                  ;
    textC tDash                                 ;
    textC tb4                                   ;
    textC tPasswordPrefix                       ;
    textC tDashSub1DashBook1DotIdeaNetDomain    ;
    textC tDotIdeaNetDomain                     ;
    textC tDotHiddenDomain                      ;
{
struct gConstS

;
}
    inline boolT operator ~( voidT ) { return !!*this ; }
    boolT operator !( voidT                         ) ;
    voidT freshenF(   tin0S& tin0P                  ) ;
    mySettingsS(      tin0S& tin0P , etherC& etherP ) ;
    ~mySettingsS(     voidT                         ) ;

    countT       cnnSubnetTrusted                      ;
    nicNameC*    pnnSubnetTrusted                      ;

    countT       cDomainRootAllowed                    ;
    textC* const pptDomainRootAllowed[ 8 ]             ;

    textC        tStripeIdObjectWebhookDestinationTest ;
    textC        tStripeApiKeyTest                     ;

    textC        tTestTextResponse                     ;

    textC        tNnTrusted                            ;
    textC        tIpGorilla1                           ;
    textC        tIpWebHook2                           ;
    textC        tIpWebHook1                           ;
    textC        tSuffixUsedByStripe                   ;

    textC        tNetshCommandIpv4                     ;

    grabC        grabMe                                ;

    public :

    voidT zapF( tin0S& tin0P ) ;

    textC        tDomainRootAllowed8                   ;
    textC        tDomainRootAllowed7                   ;
    textC        tDomainRootAllowed6                   ;
    textC        tDomainRootAllowed5                   ;
    textC        tDomainRootAllowed4                   ;
    textC        tDomainRootAllowed3                   ;
    textC        tDomainRootAllowed2                   ;
    textC        tDomainRootAllowed1                   ;

    textC        tNetshCommandIpv4SettingKey           ;

    etherC&      etherMe                               ;

    private :
{
struct mySettingsS

;
}
    {}
    idp( 0 )
    cbq( 0 ) ,
    pbq( 0 ) ,
    inline jobS( voidT ) :

    {}
    nnPeer( nnPeerP )
    idp( idpP ) ,
    cbq( cbqP ) ,
    pbq( pbqP ) ,
    inline jobS( byteT* pbqP , countT cbqP , countT idpP , nicNameC& nnPeerP ) :
    NEWdELcLASSpROTOS

    nicNameC nnPeer ;
    countT   idp    ;
    countT   cbq    ;
    byteT*   pbq    ;
{
struct jobS

//U::6: CODE COMMENTED OUT THAT SUPPORTS AAAA (IPV6) REQUESTS

//  
// CERTBOT CANNOT BE USED TO RENEW A CERTIFICATE FOR THE LEAF DOMAIN, BECAUSE I DO NOT HAVE CERTBOT'S SERVERS ON MY ALLOWLIST
// I ASSUME THAT A "SHIELDS DOWN" FUNCTION IS NOT NEEDED BECAUSE THE DOMAIN NAME LEAF IS CHANGED FREQUENTLY
//  
//P:PERSONALITY: I KEEP IP ADDRESSES CONFIDENTIAL, BY TREATING THE REQUESTED DOMAIN NAME LEAF AS A PASSWORD, AND BY APPLYING AN ALLOWLIST TO nnPeer

// OBSOLETES 8a7_ (LIKE 8a7 BUT SETTINGS ARE UPDATED WITHOUT INTERRUPTING DNS SERVICE)

/*1*/WAKEhIDE( "ifcIDaDAM_DNS" )/*1*/

/**/
*/
 i simply map names (many to 1 and 1 to many) into ip addresses and, generally, tell the client to not cache
i do not use the canonical name concept
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
