
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , CBsTACKmIN << 1 ) ) ;
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        //etThread.traceF( tin0P , T("napped  for 20 minutes") ) ;
        ////etThread.osSleepF( tin0P , TICK ) ;
        //Sleep( 1000 * 60 * 20 ) ;
        //etThread.traceF( tin0P , T("napping for 20 minutes") ) ;
        //REMOVE IN PRODUCTION; THIS IS TO FACILITATE DEVELOPMENT OF SERVICE QUIT QUALITY

        }
            //etThread.traceF( tin0P , T("cleaning up") ) ;
            //U:: }
            //U::     etThread.delF( tin0P , psttDriverName ) ;
            //U::     }
            //U::         if( POOP ) POOPR
            //U::         ((thirdC&)*((tin1S&)tin0P).pEtScratch).osDriverUnregisterF( tin0P , T(psttDriverName) ) ;
            //U::         SCOOPS
            //U::     {
            //U::     IFsCRATCHoK
            //U::     etThread.osDriverNameFromMasterF( tin0P , psttDriverName , DDNUMB ) ; ___( psttDriverName ) ;
            //U::     ZE( strokeS* , psttDriverName ) ;
            //U::     buildRemovalUtilityF( tin0P , etThread ) ; //U::DOES NOT WORK
            //U:: {
            //U:: if( !bKeep )

            //CONoUTrAW( "console is gone\r\n" ) ;
            WAITuNTILaLMOSTaLONE( 0 )
            bQuitConsole = 1 ;
            //CONoUTrAW( "firing console\r\n" ) ;
            //etThread.traceF( tin0P , T("firing console") ) ;

            }    
                DELzOMBIE( pms ) ;
                memorySpaceS* pms = &memorySpaceGlass2 ;
                //CONoUTrAW( "glass2 is gone\r\n" ) ;
                WAITuNTILaLMOSTaLONE( 1 )
                memorySpaceGlass2.sgnDone_tmEatTelemetrySysF_.waitF( tin0P ) ;
                bQuitConsole = memorySpaceGlass2.bQuitMonitor = memorySpaceGlass2.bQuitEating = 1 ;
                memorySpaceS& memorySpaceGlass2 = *(memorySpaceS*)&(countT&)swMemorySpace ;
                cLeverIdMemory = ifcIDmEMORYsPACE_GLASS2 ;
                thirdC::third_flagsModeProcess1I_IF() |= flMODEpROCESS1_SUPPRESStELLS ; //RACE: A THREAD MIGHT HAVE ALREADY INSPECTED THE FLAGS BUT NOT YET WRITTEN TO THE MONITOR; THE CONSEQUENCE IS THAT SOME MESSAGES AREN'T PULLED;  THIS IS AOK AS LONG AS THE QUEUE ISN'T FILLED
                //CONoUTrAW( "firing glass2\r\n" ) ;
            {
            etThread.traceF( tin0P , T("firing my queue monitor") ) ;

            bChatterIf = 0 ;

            //Sleep( 1000 * 60 * 60 ) ;
            //etThread.traceF( tin0P , T("TO TEST:sleeping forever before firing my queue monitor") ) ;

            WAITuNTILaLMOSTaLONE( 3 )
            //20230905@1448: 3 <- 2 (NEEDED.  PROBABLY DUE TO ADDITION OF tmChatterF)
            //CONoUTrAW( "waiting for all threads other than console and glass2 to go away\r\n" ) ;
            etThread.traceF( tin0P , T("waiting for all threads other than those for the queue monitor for me and below me and console to finish") ) ;

            THREADmODE1rESTORE
            YELL( "monitoring of every space above mine has ended" ) ;
            THREADmODE1oN( flTHREADmODE1_YELL )
            etThread.traceF( tin0P , T("all queue monitors above mine are gone") ) ;

            }
                }
                    }
                        DELzOMBIE( pms ) ;
                        memorySpaceS* pms = &memorySpace ;
                        //etThread.traceF( tin0P , T("monitor is dead [idMemory]:    ")+TF2(idMemory,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                        memorySpace.sgnDone_tmEatTelemetrySysF_.waitF( tin0P ) ;
                        //etThread.traceF( tin0P , T("waiting for monitor to die [idMemory]:    ")+TF2(idMemory,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    {
                    else
                    }
                        memorySpace.bQuitMonitor = memorySpace.bQuitEating = 1 ;
                        //etThread.traceF( tin0P , T("firing monitor [idMemory]:    ")+TF2(idMemory,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    {
                    if( idPass == 1 )

                    memorySpaceS& memorySpace = *(memorySpaceS*)&(countT&)swMemorySpace ;
                    cLeverIdMemory = idMemory ;

                    if( idMemory >= ifcIDmEMORYsPACE_RESERVEDmIN && idMemory <= ifcIDmEMORYsPACE_RESERVEDmAX ) continue ;   //CS:CODEsYNC: 510004fb 510004fb
                    if( idMemory == ifcIDmEMORYsPACE_GLASS2                                                  ) continue ;   // DONE LATER
                {
                for( countT idMemory = idmMax ; idMemory >= idmMin ; idMemory -- )
                etThread.traceF( tin0P , T(idPass==1?"all adams have been fired and have died ; firing the queue monitors above mine":"waiting for all queue monitors above mine to die") ) ;
            {
            for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )

            sgnDone_tmFireAllF_.waitF( tin0P ) ;
            //etThread.traceF( tin0P , T("waiting for fire all thread to finish") ) ;

            //}
            //    }
            //        SCOOPSdEL
            //        }
            //            }
            //                else                { DEL( pso ) ; }
            //                if( !ether && pso ) etThread.osThreadF( tin0P , countTC() , tmcMonitorServerF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)pso , (countT)&cLeverIdMemory , (countT)&swMemorySpace ) ;
            //
            //                etRock.traceF( tin0P , T("main: called  acceptF for sListen") ) ;
            //                sListen.acceptF( tin0P , pso , idPortPeer , nnPeer , countTC() ) ;
            //                etRock.traceF( tin0P , T("main: calling acceptF for sListen") ) ;
            //                ZE( countT , idPortPeer ) ;
            //                nicNameC nnPeer ;
            //                ZE( socketC* , pso ) ;
            //            {
            //            while( !POOP && !etThread && !ether )
            //            sListen.listenF( tin0P ) ;
            //        {
            //        else
            //        }
            //            etThread.loafIF( tin0P ) ;
            //            POOPR
            //        {
            //        if( POOP )
            //
            //        //LOGrAW3( "home.idPortGlass2: " , home.idPortGlass2 , "\r\n" ) ;
            //        etRock.traceF( tin0P , T("main: sListen bound to port ")+TF2(home.idPortGlass2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
            //        home.idPortGlass2 = sListen.bindF( tin0P ) ;
            //        homeS& home = homeS::homeIF() ;
            //        socketC sListen( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
            //        SCOOPSnEW
            //    {
            //    IFsCRATCHoK
            //    etThread.traceF( tin0P , T("listening for clients") ) ;
            //{
            //if( !ether )
            //U::TO FIND A BUG

            //etThread.osThreadF( TaRG1( tmHooF ) , (countT)&grabHoo , 1 ) ;
            //etThread.osThreadF( TaRG1( tmHooF ) , (countT)&grabHoo ) ;
            //grabC grabHoo( tin0P , TAG( TAGiDnULL ) ) ;
            //etThread.traceF( tin0P , T("launching grabC zombie threads") ) ;

            //etThread.osThreadF( TaRG1( tmGooF ) , (countT)&grabitFoo2 , (countT)&grabitFoo1 ) ;
            //etThread.osThreadF( TaRG1( tmGooF ) , (countT)&grabitFoo1 , (countT)&grabitFoo2 ) ;
            //grabitC grabitFoo2( tin0P , TAG( TAGiDnULL ) , (byteT*)0 , 0 , 0 , 0 , flGRABITc_SUPPRESScTdT ) ;
            //grabitC grabitFoo1( tin0P , TAG( TAGiDnULL ) , (byteT*)0 , 0 , 0 , 0 , flGRABITc_SUPPRESScTdT ) ;
            //etThread.traceF( tin0P , T("launching grabitC deadlocker threads") ) ;

            //etThread.osThreadF( TaRG1( tmFooF ) , (countT)&grabFoo2 , (countT)&grabFoo1 ) ;
            //etThread.osThreadF( TaRG1( tmFooF ) , (countT)&grabFoo1 , (countT)&grabFoo2 ) ;
            //grabC grabFoo2( tin0P , TAG( TAGiDnULL ) ) ;
            //grabC grabFoo1( tin0P , TAG( TAGiDnULL ) ) ;
            //etThread.traceF( tin0P , T("launching grabC deadlocker threads") ) ;

              etThread.osThreadF( TaRG2cBsTACK( tmHireF , CBsTACKmIN << 3 ) , (countT)&cHamburgers , (countT)&fliPendingSnapShotRequest , (countT)postSnapShotRequest , (countT)&osPidEvent , (countT)&osTidEvent , (countT)&tEvent , (countT)&stOsPid , (countT)&stOsPidZombie , bConsoleP , (countT)&bKidsSuspended ) ;
            //etThread.osThreadF( TaRG2cBsTACK( tmHireF , CBsTACKmIN << 2 ) , (countT)&cHamburgers , (countT)&fliPendingSnapShotRequest , (countT)postSnapShotRequest , (countT)&osPidEvent , (countT)&osTidEvent , (countT)&tEvent , (countT)&stOsPid , (countT)&stOsPidZombie , bConsoleP , (countT)&bKidsSuspended ) ;
            //etThread.osThreadF( TaRG2cBsTACK( tmHireF , CBsTACKmIN << 1 ) , (countT)&cHamburgers , (countT)&fliPendingSnapShotRequest , (countT)postSnapShotRequest , (countT)&osPidEvent , (countT)&osTidEvent , (countT)&tEvent , (countT)&stOsPid , (countT)&stOsPidZombie , bConsoleP , (countT)&bKidsSuspended ) ;

            //U::TO QUIET THE CONSOLE FOR CRAFTWORK: etThread.osThreadF( TaRG1( tmConsoleF ) , (countT)&bQuitConsole , (countT)&cLeverIdMemory , (countT)&swMemorySpace ) ;
              etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmFireAllF , sgnDone_tmFireAllF_ , CBsTACKmIN << 2 ) , (countT)&bKidsSuspended ) ;
            //etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmFireAllF , sgnDone_tmFireAllF_ , CBsTACKmIN << 1 ) , (countT)&bKidsSuspended ) ;
            //etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmFireAllF , sgnDone_tmFireAllF_ , CBsTACKmIN << 0 ) , (countT)&bKidsSuspended ) ;
            ZE( boolT , bKidsSuspended ) ;
            signC sgnDone_tmFireAllF_( tin0P , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC2 ) ;
            //etThread.osThreadF( tin0P , countTC() , tmKillYourselfImmediatelyF ) ;
            //etThread.osThreadF( tin0P , countTC() , tmTestImpotenceF ) ;
            //etThread.traceF( tin0P , T("launching ancillary threads") ) ;

            }
                }
                      etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmEatTelemetrySysF , memorySpace.sgnDone_tmEatTelemetrySysF_ , CBsTACKmIN << 3 ) , (countT)pcArg ) ;
                    //etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmEatTelemetrySysF , memorySpace.sgnDone_tmEatTelemetrySysF_ , CBsTACKmIN << 2 ) , (countT)pcArg ) ;
                    //etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmEatTelemetrySysF , memorySpace.sgnDone_tmEatTelemetrySysF_ , CBsTACKmIN << 1 ) , (countT)pcArg ) ;

                    //CS:CODEsYNC: 510004fb.1 510004fb.1
                    pcArg[ 0xe ] = (countT)&stOsPidZombie ;
                    pcArg[ 0xd ] = (countT)&stOsPid ;
                    pcArg[ 0xc ] = (countT)&bChatter ;
                    pcArg[ 0xb ] = (countT)&tEvent ;
                    pcArg[ 0xa ] = (countT)&osTidEvent ;
                    pcArg[ 0x9 ] = (countT)&osPidEvent ;
                    pcArg[ 0x8 ] = (countT)&bCompileReport ;
                    pcArg[ 0x7 ] = (countT)postSnapShotRequest ;
                    pcArg[ 0x6 ] = (countT)&fliPendingSnapShotRequest ;
                    pcArg[ 0x5 ] = (countT)&cHamburgers ;
                    pcArg[ 0x4 ] = idMinuteZe ;
                    pcArg[ 0x3 ] = (countT)&swMemorySpace ;
                    pcArg[ 0x2 ] = (countT)&cLeverIdMemory ;
                    pcArg[ 0x1 ] = idMemory ;
                    pcArg[ 0x0 ] = (countT)&memorySpace.bQuitEating ;
                    etThread.newF( tin0P , LF , pcArg , 0xf ) ; ___( pcArg ) ;   //CS:CODEsYNC: 510004fb.1 510004fb.1
                    ZE( countT* , pcArg ) ;

                    swMemorySpace.ungrabF( tin0P ) ;
                    memorySpaceS& memorySpace = *new( 0 , tin0P , pbms , sizeof( memorySpaceS ) ) memorySpaceS( tin0P , etThread ) ;
                    byteT* pbms = (byteT*)&(countT&)swMemorySpace ;
                    cLeverIdMemory = idMemory ;
                    swMemorySpace.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                    if( idMemory >= ifcIDmEMORYsPACE_RESERVEDmIN && idMemory <= ifcIDmEMORYsPACE_RESERVEDmAX ) continue ;   //CS:CODEsYNC: 510004fb 510004fb
                {
                for( countT idMemory = idmMin ; idMemory <= idmMax ; idMemory ++ )
                countT idMinuteZe = timeN1 >> 0x16 ;    // 8:TUCK 01:TOCK 81:TICK 61:MINUTE(QUARTERTICK)
                etThread.osTimeNowF( tin0P ,  timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT  , timeN1 ) ;
            {
            TN( tEvent , "" ) ;
            stackC stOsPidZombie( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_ALLOWzE , ifcSTACKtYPE_countT ) ;
            stackC stOsPid(       tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_ALLOWzE , ifcSTACKtYPE_countT ) ;
            ZE( countT , osTidEvent ) ;
            ZE( countT , osPidEvent ) ;
            batonC bCompileReport( tin0P , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_NOTjEALOUS ) ;
            switchC swMemorySpace( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , cLeverIdMemory , 0 , sizeof( memorySpaceS ) ) ;
            osTextT postSnapShotRequest[ TUCK ] = "" ;
            ZE( flagsT , fliPendingSnapShotRequest ) ;
            ZE( countT , cHamburgers ) ;
            ZE( countT , cLeverIdMemory ) ;
            ZE( boolT , bQuitConsole ) ;
            //etThread.traceF( tin0P , T("launching telemetry eater threads") ) ;

              etThread.osThreadF( TaRG2cBsTACK( tmChatterF , CBsTACKmIN << 3 ) , (countT)&bChatterIf , (countT)&bChatter ) ;
            //etThread.osThreadF( TaRG2cBsTACK( tmChatterF , CBsTACKmIN << 2 ) , (countT)&bChatterIf , (countT)&bChatter ) ;
            //etThread.osThreadF( TaRG2cBsTACK( tmChatterF , CBsTACKmIN << 1 ) , (countT)&bChatterIf , (countT)&bChatter ) ;
            ZE( boolT , bChatter ) ;
            boolT bChatterIf = 1 ;
            //etThread.traceF( tin0P , T("launching chatter thread") ) ;
        {
        if( !ether )

        const countT idmMax = ifcIDmEMORYsPACE_max ;
        const countT idmMin = ifcIDmEMORYsPACE_min ;

        //const countT idmMax = ifcIDmEMORYsPACE_GLASS1 ;
        //const countT idmMin = ifcIDmEMORYsPACE_GLASS1 ;

        }
            etThread.osDriverRemoveOldF( tin0P , DDNUMB ) ;
            unregisterObsoleteDriversF( tin0P , etThread , DDNUMB ) ;
        {
        if( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_DRIVER ) //WILL FAIL IF I AM HIRED AT THE COMMAND LINE
        const countT cKidsAtStart = ((tin1S&)tin0P).cKidThreads ;
        //etThread.traceF( tin0P , T("removing obsolete drivers") ) ;

        //U::__( etherC::ifc_idHomeI_IF() - etherC::ifc_idHomeIdisk_IF() ) ; // THE LOW idHomeG VALUES ARE RESERVED FOR USE BY ME; IT IS ILLEGAL TO LAUNCH AN ADAM FROM THE BASE OS CONSOLE WITHOUT SPECIFYING A HIGH !idHome VALUE (HIGH BIT SET)

        }
            etThread.delF( tin0P , psttSetting ) ;
            bKeep = !!psttSetting ;
            GETsETTING( etThread , psttSetting , T("keep") )
        {
        //etThread.traceF( tin0P , T("looking for the keep setting file") ) ;
        ZE( boolT , bKeep ) ;
        //if( IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 != etThread.diskIdF( tin0P , T("///c") ) )
        //U::DO THIS IFF I AM ALONE (I MIGHT HAVE JUST BEEN FIRED BY A NEWER INSTANCE OF MYSELF

        }
            //etThread.delF( tin0P , psttSetting ) ;
            /*if( psttSetting )*/ homeS::homeIF().flags |= flHOMEs_FIREoSoNuNHANDLEDeXCEPTION ;
            //GETsETTING( etThread , psttSetting , T("reboot") )
            //20190812@1949: UNCONDITIONALLY SET THIS FLAG
        {
        //etThread.traceF( tin0P , T("looking for the reboot setting file") ) ;

        //stateS state( tin0P , etThread ) ;
    {
    if( !ether )

    //thirdC::third_flagsModeProcess2I_IF() |= flMODEpROCESS2_GRABoNLYwO ;
    etherC& etRock = etherC::etRockIF( tin0P ) ;

    //}
    //    etThread.delF( tin0P , postBody ) ;
    //    etThread.traceF( tin0P , T("called boxGetShadowF") ) ;
    //    etThread.boxGetShadowF( tin0P , postBody , costBody , T("////factory9/x/archive/2099/!ideafarm.8.2.00000000.00000001.20990018@0001.20190620@1125.001.6a585f340146ddf3075177c29b293bab.00000001.data.png") , 1 ) ;
    //    etThread.traceF( tin0P , T("calling boxGetShadowF") ) ;
    //    //((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , postBody , costBody , T("////factory9/x/archive/1999/!ideafarm.8.2.00000000.00000001.00000000@0000.20170131@0012.001.2a24e441984f7650ef8982bc85155e1c.00000001.data.jpg") , 1 ) ;
    //    ZE( countT   , costBody ) ;
    //    ZE( osTextT* , postBody ) ;
    //{
    //U::TO FIND A BUG

    //ether.traceF( tin0P , T("initializing IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System") ) ;
    //ether.osSleepF( tin0P , TICK >> 2 ) ;
    //etThread.traceF( tin0P , T("napping for a quarter tick to enable base o.s. to finish initializing") ) ;
    //etThread.osThreadF( TaRG1( tmCloakF ) ) ;
    //U:: ENABLE THIS WHEN ROCK SOLID ENOUGH TO LAUNCH EARLY RATHER THAN DELAYED

    //etRock.traceF( tin0P , T("TODO / i just called TRACEmYtHREAD") ) ; //U:: TO FIND A BUG
    //TRACEmYtHREAD ;

    }
        }
            etThread.traceF( tin0P , T("netsh / opening port 64222_9 for outgoing [bFail]:    ")+TF2(bFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            bFail = system( "netsh advfirewall firewall add rule name=\"IPDOS (tm) Udp Echo Outgoing\" dir=out action=allow description=\"Allows IPDOS (tm) homes to communicate even through NAT and incoming firewalls.\" profile=any localport=64222 protocol=udp > nul" ) ;
        {
        if( bFail ) 
        bFail = system( "netsh advfirewall firewall show rule name=\"IPDOS (tm) Udp Echo Outgoing\" > nul" ) ;

        }
            etThread.traceF( tin0P , T("netsh / opening port 64222_9 for incoming [bFail]:    ")+TF2(bFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            bFail = system( "netsh advfirewall firewall add rule name=\"IPDOS (tm) Udp Echo Incoming\" dir=in  action=allow description=\"Allows IPDOS (tm) homes to communicate even through NAT and incoming firewalls.\" profile=any localport=64222 protocol=udp > nul" ) ;
        {
        if( bFail ) 
        bFail = system( "netsh advfirewall firewall show rule name=\"IPDOS (tm) Udp Echo Incoming\" > nul" ) ;

        ZE( boolT , bFail ) ;

        //P:PERSONALITY: RULE IS CREATED ONLY IF A RULE WITH THE SAME NAME DOES NOT EXIST ; THIS MEANS THAT IF THE USER SCREWS UP A RULE, THE USER MUST MANUALLY UNSCREW IT OR DELETE IT
        // CREATE WINDOWS FIREWALL RULES (FOR ifcIDaDAM_UDPeCHO)
    {
    if( !bConsoleP )

    }
        }
            }
                break ;
                bConsoleP = 1 ;
            {
            if( !etThread.strCompareF( tin0P , psttc1 , tHeyConsole ) )
            etThread.traceF( tin0P , T("param: ")+T(psttc1) ) ;
        {
        FORsTRINGSiN1( pstt1Param )
        strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tin0P ) ;
    {
    TN( tHeyConsole , "!console" ) ;
    ZE( boolT , bConsoleP ) ;

{
if( pTaskP )
TASK( tmWorkF )

//STATE0

#include postADAMhEADER

//napHomeG IS MY ONLY ACHILLES HEEL; OTHER PROCESSES CAN AFFECT MY MEMORY ONLY BY CRAPPING ON napHomeG
//IF SO THEN THE IFC BASE GUARANTEES THAT I NEVER TOUCH SPACE 2 EXCEPT VERY EARLY (TO CONSTRUCT napHome)
//ASSUME: I AM THE WOTH PROCESS TO ACCESS napHomeG SO AM ASSIGNED MEMORY SPACE 1 FOR MY EXCLUSIVE USE

//THIS MODULE IS RESERVED FOR MAIN THREAD FUNCTION DEFINITIONS

/*1*/WAKEhIDE( "ifcIDaDAM_2GLASS2" )/*1*/
/**/
*/
 when 0050104 is empty, the rewrite is done
 as functionality is added here, remove the code from 0050104
 simpler internal design
 same function
 i am to be a rewrite of that program
 0050104 contained, initially, a working (but buggy) prototype
development plan
code mine for my development: 0050104
obsoletes 2e40104
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

