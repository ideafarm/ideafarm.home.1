
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    //etThread.traceF( tinBaseP , T("napped  for 20 minutes") ) ;
    ////etThread.osSleepF( tinBaseP , TICK ) ;
    //Sleep( 1000 * 60 * 20 ) ;
    //etThread.traceF( tinBaseP , T("napping for 20 minutes") ) ;
    //REMOVE IN PRODUCTION; THIS IS TO FACILITATE DEVELOPMENT OF SERVICE QUIT QUALITY

    }
        //etThread.traceF( tinBaseP , T("cleaning up") ) ;
        //U:: }
        //U::     etThread.delF( tinBaseP , psttDriverName ) ;
        //U::     }
        //U::         if( POOP ) POOPR
        //U::         ((thirdC&)*((tinFullS&)tinBaseP).pEtScratch).osDriverUnregisterF( tinBaseP , T(psttDriverName) ) ;
        //U::         SCOOPS
        //U::     {
        //U::     IFsCRATCH
        //U::     etThread.osDriverNameFromMasterF( tinBaseP , psttDriverName , DDNUMB ) ; ___( psttDriverName ) ;
        //U::     ZE( strokeS* , psttDriverName ) ;
        //U::     buildRemovalUtilityF( tinBaseP , etThread ) ; //U::DOES NOT WORK
        //U:: {
        //U:: if( !bKeep )
    
        //CONoUTrAW( "console is gone\r\n" ) ;
        WAITuNTILaLMOSTaLONE( 0 )
        bQuitConsole = 1 ;
        //CONoUTrAW( "firing console\r\n" ) ;
        //etThread.traceF( tinBaseP , T("firing console") ) ;

        }    
            DELzOMBIE( pms ) ;
            memorySpaceS* pms = &memorySpaceGlass2 ;
            //CONoUTrAW( "glass2 is gone\r\n" ) ;
            WAITuNTILaLMOSTaLONE( 1 )
            memorySpaceGlass2.sgnDone_tmEatTelemetrySysF_.waitF( tinBaseP ) ;
            bQuitConsole = memorySpaceGlass2.bQuitMonitor = memorySpaceGlass2.bQuitEating = 1 ;
            memorySpaceS& memorySpaceGlass2 = *(memorySpaceS*)&(countT&)swMemorySpace ;
            cLeverIdMemory = ifcIDmEMORYsPACE_GLASS2 ;
            thirdC::third_flagsModeProcess1I_IF() |= flMODEpROCESS1_SUPPRESStELLS ; //RACE: A THREAD MIGHT HAVE ALREADY INSPECTED THE FLAGS BUT NOT YET WRITTEN TO THE MONITOR; THE CONSEQUENCE IS THAT SOME MESSAGES AREN'T PULLED;  THIS IS AOK AS LONG AS THE QUEUE ISN'T FILLED
            //CONoUTrAW( "firing glass2\r\n" ) ;
        {
        etThread.traceF( tinBaseP , T("firing my queue monitor") ) ;

        bChatterIf = 0 ;

        //Sleep( 1000 * 60 * 60 ) ;
        //etThread.traceF( tinBaseP , T("TO TEST:sleeping forever before firing my queue monitor") ) ;
    
        WAITuNTILaLMOSTaLONE( 3 )
        //20230905@1448: 3 <- 2 (NEEDED.  PROBABLY DUE TO ADDITION OF tmChatterF)
        //CONoUTrAW( "waiting for all threads other than console and glass2 to go away\r\n" ) ;
        etThread.traceF( tinBaseP , T("waiting for all threads other than those for the queue monitor for me and below me and console to finish") ) ;
    
        THREADmODE2rESTORE
        YELL( "monitoring of every space above mine has ended" ) ;
        THREADmODE2oN( flTHREADmODE2_YELL )
        etThread.traceF( tinBaseP , T("all queue monitors above mine are gone") ) ;
    
        }
            }
                }
                    DELzOMBIE( pms ) ;
                    memorySpaceS* pms = &memorySpace ;
                    //etThread.traceF( tinBaseP , T("monitor is dead [idMemory]:    ")+TF2(idMemory,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    memorySpace.sgnDone_tmEatTelemetrySysF_.waitF( tinBaseP ) ;
                    //etThread.traceF( tinBaseP , T("waiting for monitor to die [idMemory]:    ")+TF2(idMemory,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                {
                else
                }
                    memorySpace.bQuitMonitor = memorySpace.bQuitEating = 1 ;
                    //etThread.traceF( tinBaseP , T("firing monitor [idMemory]:    ")+TF2(idMemory,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                {
                if( idPass == 1 )

                memorySpaceS& memorySpace = *(memorySpaceS*)&(countT&)swMemorySpace ;
                cLeverIdMemory = idMemory ;

                if( idMemory >= ifcIDmEMORYsPACE_RESERVEDmIN && idMemory <= ifcIDmEMORYsPACE_RESERVEDmAX ) continue ;   //CS:CODEsYNC: 510004fb 510004fb
                if( idMemory == ifcIDmEMORYsPACE_GLASS2                                                  ) continue ;   // DONE LATER
            {
            for( countT idMemory = idmMax ; idMemory >= idmMin ; idMemory -- )
            etThread.traceF( tinBaseP , T(idPass==1?"all adams have been fired and have died ; firing the queue monitors above mine":"waiting for all queue monitors above mine to die") ) ;
        {
        for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )

        sgnDone_tmFireAllF_.waitF( tinBaseP ) ;
        //etThread.traceF( tinBaseP , T("waiting for fire all thread to finish") ) ;
    
        //}
        //    }
        //        SCOOPSdEL
        //        }
        //            }
        //                else                { DEL( pso ) ; }
        //                if( !ether && pso ) etThread.osThreadF( tinBaseP , countTC() , tmcMonitorServerF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)pso , (countT)&cLeverIdMemory , (countT)&swMemorySpace ) ;
        //
        //                etRock.traceF( tinBaseP , T("main: called  acceptF for sListen") ) ;
        //                sListen.acceptF( tinBaseP , pso , idPortPeer , nnPeer , countTC() ) ;
        //                etRock.traceF( tinBaseP , T("main: calling acceptF for sListen") ) ;
        //                ZE( countT , idPortPeer ) ;
        //                nicNameC nnPeer ;
        //                ZE( socketC* , pso ) ;
        //            {
        //            while( !POOP && !etThread && !ether )
        //            sListen.listenF( tinBaseP ) ;
        //        {
        //        else
        //        }
        //            etThread.loafIF( tinBaseP ) ;
        //            POOPR
        //        {
        //        if( POOP )
        //
        //        //LOGrAW3( "home.idPortGlass2: " , home.idPortGlass2 , "\r\n" ) ;
        //        etRock.traceF( tinBaseP , T("main: sListen bound to port ")+TF2(home.idPortGlass2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
        //        home.idPortGlass2 = sListen.bindF( tinBaseP ) ;
        //        homeS& home = homeS::homeIF() ;
        //        socketC sListen( tinBaseP , *((tinFullS&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) ) ;
        //        SCOOPSnEW
        //    {
        //    IFsCRATCH
        //    etThread.traceF( tinBaseP , T("listening for clients") ) ;
        //{
        //if( !ether )
        //U::TO FIND A BUG
    
        //etThread.osThreadF( TaRG1( tmHooF ) , (countT)&grabHoo , 1 ) ;
        //etThread.osThreadF( TaRG1( tmHooF ) , (countT)&grabHoo ) ;
        //grabC grabHoo( tinBaseP , TAG( TAGiDnULL ) ) ;
        //etThread.traceF( tinBaseP , T("launching grabC zombie threads") ) ;
        
        //etThread.osThreadF( TaRG1( tmGooF ) , (countT)&grabitFoo2 , (countT)&grabitFoo1 ) ;
        //etThread.osThreadF( TaRG1( tmGooF ) , (countT)&grabitFoo1 , (countT)&grabitFoo2 ) ;
        //grabitC grabitFoo2( tinBaseP , TAG( TAGiDnULL ) , (byteT*)0 , 0 , 0 , 0 , flGRABITc_SUPPRESScTdT ) ;
        //grabitC grabitFoo1( tinBaseP , TAG( TAGiDnULL ) , (byteT*)0 , 0 , 0 , 0 , flGRABITc_SUPPRESScTdT ) ;
        //etThread.traceF( tinBaseP , T("launching grabitC deadlocker threads") ) ;
        
        //etThread.osThreadF( TaRG1( tmFooF ) , (countT)&grabFoo2 , (countT)&grabFoo1 ) ;
        //etThread.osThreadF( TaRG1( tmFooF ) , (countT)&grabFoo1 , (countT)&grabFoo2 ) ;
        //grabC grabFoo2( tinBaseP , TAG( TAGiDnULL ) ) ;
        //grabC grabFoo1( tinBaseP , TAG( TAGiDnULL ) ) ;
        //etThread.traceF( tinBaseP , T("launching grabC deadlocker threads") ) ;

          etThread.osThreadF( TaRG2cBsTACK( tmHireF , CBsTACKmIN << 3 ) , (countT)&cHamburgers , (countT)&fliPendingSnapShotRequest , (countT)postSnapShotRequest , (countT)&osPidEvent , (countT)&osTidEvent , (countT)&tEvent , (countT)&stOsPid , (countT)&stOsPidZombie , bConsoleP , (countT)&bKidsSuspended ) ;
        //etThread.osThreadF( TaRG2cBsTACK( tmHireF , CBsTACKmIN << 2 ) , (countT)&cHamburgers , (countT)&fliPendingSnapShotRequest , (countT)postSnapShotRequest , (countT)&osPidEvent , (countT)&osTidEvent , (countT)&tEvent , (countT)&stOsPid , (countT)&stOsPidZombie , bConsoleP , (countT)&bKidsSuspended ) ;
        //etThread.osThreadF( TaRG2cBsTACK( tmHireF , CBsTACKmIN << 1 ) , (countT)&cHamburgers , (countT)&fliPendingSnapShotRequest , (countT)postSnapShotRequest , (countT)&osPidEvent , (countT)&osTidEvent , (countT)&tEvent , (countT)&stOsPid , (countT)&stOsPidZombie , bConsoleP , (countT)&bKidsSuspended ) ;

        //U::TO QUIET THE CONSOLE FOR CRAFTWORK: etThread.osThreadF( TaRG1( tmConsoleF ) , (countT)&bQuitConsole , (countT)&cLeverIdMemory , (countT)&swMemorySpace ) ;
          etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmFireAllF , sgnDone_tmFireAllF_ , CBsTACKmIN << 2 ) , (countT)&bKidsSuspended ) ;
        //etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmFireAllF , sgnDone_tmFireAllF_ , CBsTACKmIN << 1 ) , (countT)&bKidsSuspended ) ;
        //etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmFireAllF , sgnDone_tmFireAllF_ , CBsTACKmIN << 0 ) , (countT)&bKidsSuspended ) ;
        ZE( boolT , bKidsSuspended ) ;
        signC sgnDone_tmFireAllF_( tinBaseP , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC2 ) ;
        //etThread.osThreadF( tinBaseP , countTC() , tmKillYourselfImmediatelyF ) ;
        //etThread.osThreadF( tinBaseP , countTC() , tmTestImpotenceF ) ;
        //etThread.traceF( tinBaseP , T("launching ancillary threads") ) ;

        }
            }
                  etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmEatTelemetrySysF , memorySpace.sgnDone_tmEatTelemetrySysF_ , CBsTACKmIN << 3 ) , (countT)pcArg ) ;
                //etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmEatTelemetrySysF , memorySpace.sgnDone_tmEatTelemetrySysF_ , CBsTACKmIN << 2 ) , (countT)pcArg ) ;
                //etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmEatTelemetrySysF , memorySpace.sgnDone_tmEatTelemetrySysF_ , CBsTACKmIN << 1 ) , (countT)pcArg ) ;

                //CS:CODEsYNC: 510004fb.1 510004fb.1
                pcArg[ 0xe ] = (countT)&stOsPidZombie ;
                pcArg[ 0xd ] = (countT)&stOsPid ;
                pcArg[ 0xc ] = (countT)&bChatter ;
                pcArg[ 0xb ] = (countT)&tEvent ;
                pcArg[ 0xa ] = (countT)&osTidEvent ;
                pcArg[ 0x9 ] = (countT)&osPidEvent ;
                pcArg[ 0x8 ] = (countT)&bCompileReport ;
                pcArg[ 0x7 ] = (countT)postSnapShotRequest ;
                pcArg[ 0x6 ] = (countT)&fliPendingSnapShotRequest ;
                pcArg[ 0x5 ] = (countT)&cHamburgers ;
                pcArg[ 0x4 ] = idMinuteZe ;
                pcArg[ 0x3 ] = (countT)&swMemorySpace ;
                pcArg[ 0x2 ] = (countT)&cLeverIdMemory ;
                pcArg[ 0x1 ] = idMemory ;
                pcArg[ 0x0 ] = (countT)&memorySpace.bQuitEating ;
                etThread.newF( tinBaseP , LF , pcArg , 0xf ) ; ___( pcArg ) ;   //CS:CODEsYNC: 510004fb.1 510004fb.1
                ZE( countT* , pcArg ) ;

                swMemorySpace.ungrabF( tinBaseP ) ;
                memorySpaceS& memorySpace = *new( 0 , tinBaseP , pbms , sizeof( memorySpaceS ) ) memorySpaceS( tinBaseP , etThread ) ;
                byteT* pbms = (byteT*)&(countT&)swMemorySpace ;
                cLeverIdMemory = idMemory ;
                swMemorySpace.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                if( idMemory >= ifcIDmEMORYsPACE_RESERVEDmIN && idMemory <= ifcIDmEMORYsPACE_RESERVEDmAX ) continue ;   //CS:CODEsYNC: 510004fb 510004fb
            {
            for( countT idMemory = idmMin ; idMemory <= idmMax ; idMemory ++ )
            countT idMinuteZe = timeN1 >> 0x16 ;    // 8:TUCK 01:TOCK 81:TICK 61:MINUTE(QUARTERTICK)
            etThread.osTimeNowF( tinBaseP ,  timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT  , timeN1 ) ;
        {
        TN( tEvent , "" ) ;
        stackC stOsPidZombie( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_ALLOWzE , ifcSTACKtYPE_countT ) ;
        stackC stOsPid(       tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_ALLOWzE , ifcSTACKtYPE_countT ) ;
        ZE( countT , osTidEvent ) ;
        ZE( countT , osPidEvent ) ;
        batonC bCompileReport( tinBaseP , TAG( TAGiDnULL ) , 0 , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_NOTjEALOUS ) ;
        switchC swMemorySpace( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , cLeverIdMemory , 0 , sizeof( memorySpaceS ) ) ;
        osTextT postSnapShotRequest[ TUCK ] = "" ;
        ZE( flagsT , fliPendingSnapShotRequest ) ;
        ZE( countT , cHamburgers ) ;
        ZE( countT , cLeverIdMemory ) ;
        ZE( boolT , bQuitConsole ) ;
        //etThread.traceF( tinBaseP , T("launching telemetry eater threads") ) ;

          etThread.osThreadF( TaRG2cBsTACK( tmChatterF , CBsTACKmIN << 3 ) , (countT)&bChatterIf , (countT)&bChatter ) ;
        //etThread.osThreadF( TaRG2cBsTACK( tmChatterF , CBsTACKmIN << 2 ) , (countT)&bChatterIf , (countT)&bChatter ) ;
        //etThread.osThreadF( TaRG2cBsTACK( tmChatterF , CBsTACKmIN << 1 ) , (countT)&bChatterIf , (countT)&bChatter ) ;
        ZE( boolT , bChatter ) ;
        boolT bChatterIf = 1 ;
        //etThread.traceF( tinBaseP , T("launching chatter thread") ) ;
    {
    if( !ether )

    const countT idmMax = ifcIDmEMORYsPACE_max ;
    const countT idmMin = ifcIDmEMORYsPACE_min ;

    //const countT idmMax = ifcIDmEMORYsPACE_GLASS1 ;
    //const countT idmMin = ifcIDmEMORYsPACE_GLASS1 ;

    }
        etThread.osDriverRemoveOldF( tinBaseP , DDNUMB ) ;
        unregisterObsoleteDriversF( tinBaseP , etThread , DDNUMB ) ;
    {
    if( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_DRIVER ) //WILL FAIL IF I AM HIRED AT THE COMMAND LINE
    const countT cKidsAtStart = ((tinFullS&)tinBaseP).cKidThreads ;
    //etThread.traceF( tinBaseP , T("removing obsolete drivers") ) ;
    
    //U::__( etherC::ifc_idHomeI_IF() - etherC::ifc_idHomeIdisk_IF() ) ; // THE LOW idHomeG VALUES ARE RESERVED FOR USE BY ME; IT IS ILLEGAL TO LAUNCH AN ADAM FROM THE BASE OS CONSOLE WITHOUT SPECIFYING A HIGH !idHome VALUE (HIGH BIT SET)
    
    }
        etThread.delF( tinBaseP , psttSetting ) ;
        bKeep = !!psttSetting ;
        GETsETTING( etThread , psttSetting , T("keep") )
    {
    //etThread.traceF( tinBaseP , T("looking for the keep setting file") ) ;
    ZE( boolT , bKeep ) ;
    //if( IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 != etThread.diskIdF( tinBaseP , T("///c") ) )
    //U::DO THIS IFF I AM ALONE (I MIGHT HAVE JUST BEEN FIRED BY A NEWER INSTANCE OF MYSELF

    }
        //etThread.delF( tinBaseP , psttSetting ) ;
        /*if( psttSetting )*/ homeS::homeIF().flags |= flHOMEs_FIREoSoNuNHANDLEDeXCEPTION ;
        //GETsETTING( etThread , psttSetting , T("reboot") )
        //20190812@1949: UNCONDITIONALLY SET THIS FLAG
    {
    //etThread.traceF( tinBaseP , T("looking for the reboot setting file") ) ;

    //stateS state( tinBaseP , etThread ) ;
{
if( !ether )

//thirdC::third_flagsModeProcess2I_IF() |= flMODEpROCESS2_GRABoNLYwO ;
etherC& etRock = etherC::etRockIF( tinBaseP ) ;

//}
//    etThread.delF( tinBaseP , postBody ) ;
//    etThread.traceF( tinBaseP , T("called boxGetShadowF") ) ;
//    etThread.boxGetShadowF( tinBaseP , postBody , costBody , T("////factory9/x/archive/2099/!ideafarm.8.2.00000000.00000001.20990018@0001.20190620@1125.001.6a585f340146ddf3075177c29b293bab.00000001.data.png") , 1 ) ;
//    etThread.traceF( tinBaseP , T("calling boxGetShadowF") ) ;
//    //((tinFullS&)tinBaseP).pEtScratch->boxGetShadowF( tinBaseP , postBody , costBody , T("////factory9/x/archive/1999/!ideafarm.8.2.00000000.00000001.00000000@0000.20170131@0012.001.2a24e441984f7650ef8982bc85155e1c.00000001.data.jpg") , 1 ) ;
//    ZE( countT   , costBody ) ;
//    ZE( osTextT* , postBody ) ;
//{
//U::TO FIND A BUG

//ether.traceF( tinBaseP , T("initializing IPDOS (tm) IdeaFarm (tm) Piggyback Distributed Operating System") ) ;
//ether.osSleepF( tinBaseP , TICK >> 2 ) ;
//etThread.traceF( tinBaseP , T("napping for a quarter tick to enable base o.s. to finish initializing") ) ;
//etThread.osThreadF( TaRG1( tmCloakF ) ) ;
//U:: ENABLE THIS WHEN ROCK SOLID ENOUGH TO LAUNCH EARLY RATHER THAN DELAYED

//etRock.traceF( tinBaseP , T("TODO / i just called TRACEmYtHREAD") ) ; //U:: TO FIND A BUG
//TRACEmYtHREAD ;

}
    }
        etThread.traceF( tinBaseP , T("netsh / opening port 64222_9 for outgoing [bFail]:    ")+TF2(bFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        bFail = system( "netsh advfirewall firewall add rule name=\"IPDOS (tm) Udp Echo Outgoing\" dir=out action=allow description=\"Allows IPDOS (tm) homes to communicate even through NAT and incoming firewalls.\" profile=any localport=64222 protocol=udp > nul" ) ;
    {
    if( bFail ) 
    bFail = system( "netsh advfirewall firewall show rule name=\"IPDOS (tm) Udp Echo Outgoing\" > nul" ) ;

    }
        etThread.traceF( tinBaseP , T("netsh / opening port 64222_9 for incoming [bFail]:    ")+TF2(bFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        bFail = system( "netsh advfirewall firewall add rule name=\"IPDOS (tm) Udp Echo Incoming\" dir=in  action=allow description=\"Allows IPDOS (tm) homes to communicate even through NAT and incoming firewalls.\" profile=any localport=64222 protocol=udp > nul" ) ;
    {
    if( bFail ) 
    bFail = system( "netsh advfirewall firewall show rule name=\"IPDOS (tm) Udp Echo Incoming\" > nul" ) ;

    ZE( boolT , bFail ) ;

    //P:PERSONALITY: RULE IS CREATED ONLY IF A RULE WITH THE SAME NAME DOES NOT EXIST ; THIS MEANS THAT IF THE USER SCREWS UP A RULE, THE USER MUST MANUALLY UNSCREW IT OR DELETE IT
    // CREATE WINDOWS FIREWALL RULES (FOR ifcIDaDAM_UDPeCHO)
{
if( !bConsoleP )

}
    }
        }
            break ;
            bConsoleP = 1 ;
        {
        if( !etThread.strCompareF( tinBaseP , psttc1 , tHeyConsole ) )
        etThread.traceF( tinBaseP , T("param: ")+T(psttc1) ) ;
    {
    FORsTRINGSiN1( pstt1Param )
    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tinBaseP ) ;
{
TN( tHeyConsole , "!console" ) ;
ZE( boolT , bConsoleP ) ;

TODO

//STATE0

#include postADAMhEADER

//napHomeG IS MY ONLY ACHILLES HEEL; OTHER PROCESSES CAN AFFECT MY MEMORY ONLY BY CRAPPING ON napHomeG
//IF SO THEN THE IFC BASE GUARANTEES THAT I NEVER TOUCH SPACE 2 EXCEPT VERY EARLY (TO CONSTRUCT napHome)
//ASSUME: I AM THE WOTH PROCESS TO ACCESS napHomeG SO AM ASSIGNED MEMORY SPACE 1 FOR MY EXCLUSIVE USE

//THIS MODULE IS RESERVED FOR MAIN THREAD FUNCTION DEFINITIONS

/*1*/WAKEhIDE( "ifcIDaDAM_2GLASS2" )/*1*/
/**/
*/
 when 0050104 is empty, the rewrite is done
 as functionality is added here, remove the code from 0050104
 simpler internal design
 same function
 i am to be a rewrite of that program
 0050104 contained, initially, a working (but buggy) prototype
development plan
code mine for my development: 0050104
obsoletes 2e40104
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

