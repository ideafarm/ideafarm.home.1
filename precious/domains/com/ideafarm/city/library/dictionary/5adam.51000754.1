
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    ++ s ; etThread.osSleepF( tin0P , TICK << 4 ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    if( bQuit ) break ;

    }
        }
            }
                etThread.traceF( tin0P , T("[host,min,mean,max,stdDev]:    ")+T(psttzLever)+tb4+TF3(stats.minTime,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+tb4+TF3((measureT)mMean,flFORMAT_NObIGITvALUES|flFORMAT_EXPONENT,9)+tb4+TF3(stats.maxTime,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+tb4+TF3((measureT)mStdDev,flFORMAT_NObIGITvALUES|flFORMAT_EXPONENT,9) ) ;
                measure04T mStdDev = thirdC::mathSqrtIF( tin0P , mSquare ) ;
            {
            if( 1e-8 < mSquare )
            measure04T mSquare = mMeans - mMean * mMean ;

            measure04T mMeans  = stats.sumSquared / stats.cObs ;   
            measure04T mMean   = stats.sum        / stats.cObs ;   
        {
        if( stats.cObs )

        etThread.traceF( tin0P , T("[host,cObs,sum,sumSquared]:    ")+T(psttzLever)+tb4+TF3(stats.cObs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+tb4+TF3((measureT)stats.sum,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+tb4+TF3((measureT)stats.sumSquared,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9) ) ;
        statsS& stats = *(statsS*)&(countT&)swAccumulator ;
        psttzLever = (strokeS*)swAccumulator.leverF( tin0P , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    countT cFlavors = swAccumulator.cFlavorsF( tin0P ) ;

    }
        }
            etThread.traceF( tin0P , T("[min,mean,max,stdDev]:    ")+TF3(statsAll.minTime,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+tb4+TF3((measureT)mMean,flFORMAT_NObIGITvALUES|flFORMAT_EXPONENT,9)+tb4+TF3(statsAll.maxTime,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+tb4+TF3((measureT)mStdDev,flFORMAT_NObIGITvALUES|flFORMAT_EXPONENT,9) ) ;
            measure04T mStdDev = thirdC::mathSqrtIF( tin0P , mSquare ) ;
        {
        if( 1e-8 < mSquare )
        measure04T mSquare = mMeans - mMean * mMean ;

        measure04T mMeans  = statsAll.sumSquared / statsAll.cObs ;   
        measure04T mMean   = statsAll.sum        / statsAll.cObs ;   
    {
    if( statsAll.cObs )

    etThread.traceF( tin0P , T("overall [cObs,sum,sumSquared]:    ")+TF3(statsAll.cObs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+tb4+TF3((measureT)statsAll.sum,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+tb4+TF3((measureT)statsAll.sumSquared,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9) ) ;

    while( /*-- cDo &&*/ !ether && ~hFind && !POOP ) ;
    }
        DEL( pInfo ) ;
        }
            }
                etThread.delF( tin0P , psttHost ) ;
                }
                    if( statsAll.maxTime < time1 ) statsAll.maxTime = time1 ;
                    if( statsAll.minTime > time1 ) statsAll.minTime = time1 ;
                    statsAll.sumSquared += (measure04T)time1 * (measure04T)time1 ;
                    statsAll.sum += time1 ;
                    statsAll.cObs ++ ;

                    if( stats.maxTime < time1 ) stats.maxTime = time1 ;
                    if( stats.minTime > time1 ) stats.minTime = time1 ;
                    stats.sumSquared += (measure04T)time1 * (measure04T)time1 ;
                    stats.sum += time1 ;
                    stats.cObs ++ ;
                    statsS& stats = *(statsS*)&(countT&)swAccumulator ;

                    }
                        new( 0 , tin0P , pba , cba ) statsS() ;
                        countT cba = swAccumulator.cbDataF() ;
                        byteT* pba = (byteT*)&(countT&)swAccumulator ;
                        etThread.traceF( tin0P , T("initializing accumulator [host]:    ")+T(psttHost) ) ;
                    {
                    if( !swAccumulator.idSlotOfLeverF( tin0P , (countT)psttHost ) )
                    psttzLever = psttHost ;

                    //etThread.traceF( tin0P , T("[time,host]:    ")+TF3(time1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(psttHost) ) ;
                {
                if( !bFail )

                }
                    }
                        }
                            }
                                bFail = 1 ;
                                POOPR
                            {
                            if( POOP )

                            rec >> time1 ;
                            rec >> psttHost ; ___( psttHost ) ;

                            __( idFormat - 1 ) ;
                            rec >> idFormat ;
                            ZE( countT , idFormat ) ;
                        {
                        else
                        }
                            bFail = 1 ;
                            POOPR
                        {
                        if( POOP )

                        __( getNegAM( finger ) - FINGERnEG_DATUMgORILLAiDEAFARMcOM ) ;
                        rec >> finger ;
                        ZE( countT , finger ) ;
                    {
                    else
                    }
                        continue ;
                        DEL( pInfo ) ;

                        if( POOP ) { POOPR }
                        ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tIfoName , 1 ) ;

                        POOPR
                    {
                    if( POOP )
                    ((tin1S&)tin0P).pEtScratch->boxGetF( tin0P , rec , tIfoName ) ;
                    soulC rec( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
                
                    SCOOPS
                {
                IFsCRATCHoK
                ZE( countT , time1 ) ;
                ZE( strokeS* , psttHost ) ;    
                ZE( boolT , bFail ) ;
            {
            if( !bDir )

            const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;

            TN( tIfoName , pInfo->psttIfoName ) ;
        {
        else
        }
            break ;
            DEL( pInfo ) ;
        {
        if( !pInfo || !pInfo->psttIfoName )

        etThread.diskFindFileOrDirF( tin0P , pInfo , hFind , fnLike.pathF() , &pat ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    switchC swAccumulator( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLever , 0 , sizeof( statsS ) ) ;
    ZE( strokeS* , psttzLever ) ;
    statsS statsAll ;
    //countT cDo = TUCK ;
{
while( !bQuit && !POOP )
const boolT& bQuit = *(const boolT*)&(const countT&)ether ;

patternC pat( tin0P , etThread , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
fileNameC fnLike( tin0P , etThread , tLike ) ;

TN( tb4 , "    " ) ;
TN( tLike , "///ideafarm/ephemeral/1/domains/com/ideafarm/gorilla/*.ideafarm.com.root.to.form.response.soul" ) ;

TODO

}
{
maxTime( 0 )
minTime( - 1 ) ,
sumSquared( 0 ) ,
sum( 0 ) ,
cObs( 0 ) ,
statsS::statsS( voidT ) :

NEWdELcLASS( 1 , statsS ) ;

;
}
    statsS( voidT ) ;
    NEWdELcLASSpROTOS

    countT      maxTime ;
    countT      minTime ;
    measure04T  sumSquared ;
    measure04T  sum ;
    countT      cObs ;
{
struct statsS


/*1*/WAKEhIDE( "ifcIDaDAM_GORILLAhTTPiDEAFARMcOMrEPORTER" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
