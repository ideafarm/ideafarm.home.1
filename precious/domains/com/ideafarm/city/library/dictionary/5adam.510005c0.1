
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

}
    }
        CONoUTrAW( T("writes per time: ")+TF2((countT)TICK/timeE1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
        //CONoUTrAW( T("time to write memory a TICK of times: ")+TT(timeE1,timeE2)+T("\r\n") ) ;
        etThread.osTimeSubtractF( tinBaseP , timeE1 , timeE2 , timeB1 , timeB2 ) ;
        etThread.osTimeNowF( tinBaseP , timeE1 , timeE2 ) ;
        ZE( sCountT , timeE2 ) ;
        ZE( countT , timeE1 ) ;
        
        while( cToDo -- ) etThread.memSetF( tinBaseP , pbBlob , cbBlob , (byteT)( 'z' - cToDo % 26 ) ) ;
        countT cToDo = TICK ;
        
        etThread.osTimeNowF( tinBaseP , timeB1 , timeB2 ) ;
        ZE( sCountT , timeB2 ) ;
        ZE( countT , timeB1 ) ;
    
        { byteT pb2[] = { idCycle , 0 } ; CONoUTrAW( T("idCycle: ")+T(pb2)+T("\r\n") ) ; }
        if( idCycle > 'z' ) idCycle = 'a' ;
        idCycle ++ ;
    {
    while( !ether )
    
    { byteT pb2[] = { idOpen , 0 } ; CONoUTrAW( T("idOpen: ")+T(pb2)+T("\r\n") ) ; }
    if( idOpen > 'z' ) idOpen = 'a' ;
    ++ idOpen ;

    }
        __1 ;
        __( idOpenResult ) ;
    {
    else if( idOpenResult != ifcOPENrESULT_EXISTED )
    }
        napKeep.formattingIsDoneF( tinBaseP ) ;
        }
            CONoUTrAW( "napKeep formatted\r\n" ) ;
            blank = ' ' ;
            idCycle = idOpen  = 'a' - 1 ;
            etThread.memSetF( tinBaseP , pbNap , cbNap ) ;
        {
        if( idOpenResult != ifcOPENrESULT_EXISTED )
    {
    if( !( F(napKeep.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
    const countT idOpenResult = fStore.idOpenResultF( tinBaseP ) ;
    
    countT cbBlob   = cbNap - 3 ;
    byteT* pbBlob   = pbNap + 3 ;
    byteT& blank    = *( pbNap + 2 ) ;
    byteT& idCycle  = *( pbNap + 1 ) ;
    byteT& idOpen   = *pbNap ;
    countT cbNap    = napKeep ;
    byteT* pbNap    = napKeep ;

    napkinC napKeep( tinBaseP , TAG( TAGiDnULL ) , "napKeep" , fStore , cbDiskSector - sizeof( napkinHeaderS ) , ifcOPENsHAREDmEMORYhOW_nCeO ) ;
    //fileC fStore( tinBaseP , "\\napKeep" , ifcOPENaCCESS_WR , ifcOPENsHARE_WR , flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_LOCrANDOM | flOPENdETAILS_NOcACHE , ifcOPENhOW_nCeO ) ;
    fileC fStore( tinBaseP , (strokeS*)T("///ideafarm/ephemeral/napKeep") , ifcOPENaCCESS_WR , ifcOPENsHARE_WR , flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_LOCrANDOM | flOPENdETAILS_NOcACHE , ifcOPENhOW_nCeO ) ;
{

}
    DEL( pInfo ) ;
    }
        cSectors     = pInfo->cAllocationUnits ;
        cbDiskSector = pInfo->cBytesPerSector  ;
    {
    if( pInfo )
    etThread.diskInfoF( tinBaseP , pInfo , T("///d/") ) ;
    ZE( infoDiskS* , pInfo ) ;
{
ZE( countT , cSectors ) ;
ZE( countT , cbDiskSector ) ;

TODO

/*1*/WAKEsHOWtEXT( "example.other.snip.0030055.napkinC.state.persistence" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

