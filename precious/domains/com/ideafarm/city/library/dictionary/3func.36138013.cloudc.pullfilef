
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    __Z( bOk ) ;

    }
        }
            }
                }
                    etPrime.osSleepF( tin0P , TOCK ) ;
                    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                    etRock.traceF( tin0P , T("will retry after napping for a tock") ) ;
                    ether.diskFileOrDirDeleteF( tin0P , tFileTmp ) ;
                {
                else
                }
                    break ;
                    bOk = 1 ;
                    etRock.traceF( tin0P , T("skipping this file") ) ;
                {
                if( bNotFound )

                etRock.traceF( tin0P , T("pullFileF / unknown error") ) ;
                POOPRqUIET ;
            {
            else
            }
                break ;

                }
                    }
                        }
                            }
                                }
                                    ether.traceF( tin0P , T("!exception / could not delete 3 [file]:    ")+tFileTmp ) ;
                                    POOPR
                                {
                                if( POOP )
                                ((tin1S&)tin0P).pEtScratch->diskFileOrDirDeleteF( tin0P , tFileTmp , flFILEoRdIRdELETE_null , 1 ) ;
                                ether.traceF( tin0P , T("!exception / could not move file [to,from]:    ")+tFile+T("    ")+tFileTmp ) ;
                                POOPR
                            {
                            if( POOP )
                            ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tFile , tFileTmp , 1 ) ;
                        {
                        else
                        }
                            }
                                ether.traceF( tin0P , T("!exception / could not delete 2 [file]:    ")+tFileTmp ) ;
                                POOPR
                            {
                            if( POOP )
                            ((tin1S&)tin0P).pEtScratch->diskFileOrDirDeleteF( tin0P , tFileTmp , flFILEoRdIRdELETE_null , 1 ) ;
                            ether.traceF( tin0P , T("!exception / could not delete 1 [file]:    ")+tFile ) ;
                            POOPR
                        {
                        if( POOP )
                        ((tin1S&)tin0P).pEtScratch->diskFileOrDirDeleteF( tin0P , tFile , flFILEoRdIRdELETE_null , 1 ) ;
                        SCOOPS
                    {
                    IFsCRATCHoK
                    TN( tFile , psttFileP ) ;
                {
                else
                }
                    sRenameP << (strokeS*)tFileTmp ;
                    sRenameP << psttFileP ;
                {
                if( F(flagsCt) & flCLOUDc_COPYaLLoRnONE )

                bOk = 1 ;
            {
            if( !POOP )

            }
                }
                    }
                        }
                            ether.delF( tin0P , pbBuffer ) ;
                            }
                                }
                                    }
                                        cDo -= cbGot ;
                                        ether.fileWriteF( tin0P , fOut , pbBuffer , cbGot ) ;
                                        //etRock.traceF( tin0P , T("pullFileF / U:: TO FIND A BUG: 20161201@1132: aok read bite [cDo,cbBite,cbGot]: ")+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(cbBite,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(cbGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    {
                                    else
                                    if( POOP ) etRock.traceF( tin0P , T("pullFileF / could not read bite [cDo,cbBite,cbGot]: ")+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(cbBite,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(cbGot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    __Z( cbGot ) ;
                                    countT cbGot = ss.readF( tin0P , pbBuffer , cbBite ) ;

                                    countT cbBite = cDo < cbBuffer ? cDo : cbBuffer ;
                                {
                                while( cDo && !POOP )
                                countT cDo = cbFile ;

                                //((tin1S&)tin0P).pc Utility[ 0 ] = 1 ; //U::TO FIND A BUG

                                fileC fOut( tin0P , (strokeS*)tFileTmp , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
                            {
                            if( !POOP )

                            }
                                ether.delF( tin0P , psttu ) ;
                                ether.delF( tin0P , psttPath ) ;
                                tFileTmp = T(psttPath)+T("/pullFileF.")+T(psttu) ;
                                ether.strUniqueF( tin0P , psttu ) ; ___( psttu ) ;
                                ZE( strokeS* , psttu ) ;

                                ether.delF( tin0P , psttnu ) ;
                                ether.strBisectF( tin0P , psttPath , psttnu , psttFileP , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttnu ) ;
                                ZE( strokeS* , psttnu ) ;
                                ZE( strokeS* , psttPath ) ; // OBTAINED SO TMP FILE WILL BE ON THE SAME VOLUME AS THE FILE TO BE REPLACED ; ANY FAILURE WILL ALSO BE VISIBLE SINCE TMP FILE IS IN THE SAME FOLDER
                            {

                            __Z( pbBuffer ) ;
                            ether.newF( tin0P , LF , pbBuffer , cbBuffer ) ; ___( pbBuffer ) ;
                            countT cbBuffer = cbFile < TOCK ? cbFile : TOCK ;
                            ZE( byteT* , pbBuffer ) ;
                        {
                        else
                        }
                            //LOGrAW( "\r\n--------------------------------\r\n" ) ;
                            //LOGrAW( postDebug ) ;
                            //LOGrAW( "\r\n---- REPLY (LINES RECEIVED UP TO WHEN ERROR DETECTED) ----------------------------\r\n" ) ;
                            //LOGrAW( "\r\n--------------------------------\r\n" ) ;
                            //LOGrAW( tSay ) ;
                            //LOGrAW( "\r\n---- REQUEST ----------------------------\r\n" ) ;

                            etRock.traceF( tin0P , T("pullFileF / [tSay]: >>>>")+tSay+T("<<<<") ) ;
                            etRock.traceF( tin0P , T("pullFileF / [offoDebug,responseFragment]: ")+TF2(offoDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" >>>>")+T(postDebug)+T("<<<<") ) ;
                            etRock.traceF( tin0P , T("pullFileF / error detected while inspecting reply header") ) ;
                        {
                        if( POOP )

                        }
                            }
                                else if( !POOP ) offb = - 1 ;
                                if( !offb ) break ;

                                }
                                    }
                                        }
                                            }
                                                ether.delF( tin0P , psttw ) ;
                                                cbFile = ether.strDigitsToSCountF( tin0P , psttw , 0xa , 1 ) ;
                                                ether.strSubstringF( tin0P , psttw , idf , idl , psttLine ) ; ___( psttw ) ;
                                                ZE( strokeS* , psttw ) ;

                                                ZE( countT , idl ) ;
                                                while( psttLine[ CSpREFIX - 1 + idf ] == sttBlank ) idf ++ ;
                                                countT idf = tContentLength.csF( tin0P ) + 1 ;
                                                strokeS* psttLine = tLine ;
                                            {
                                            if( 1 == ether.strIdF( tin0P , tContentLength , tLine ) )
                                            strokeS sttBlank( ' ' ) ;
                                        {
                                        else
                                        if( POOP ) etRock.traceF( tin0P , T("pullFileF / expected LF byte but received ")+TF2(ostLF,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        __NZ( ostLF != '\n' ) ;
                                    {
                                    else
                                    if( POOP ) etRock.traceF( tin0P , T("pullFileF / could not read expected LF byte") ) ;

                                    __Z( ss.readF( tin0P , &ostLF , 1 ) ) ;
                                    osTextT ostLF ;

                                    }
                                        //etRock.traceF( tin0P , T("pullFileF / header line: ")+T(postBuffer) ) ;
                                        postBuffer[ offb ] = 0 ;
                                    {
                                    if( offb )
                                {
                                if( !POOP )

                                }
                                    }
                                        __( !ether.strIdF( tin0P , tReplyCode200_OK , tLine ) ) ;

                                        }
                                            etRock.traceF( tin0P , T("not found in remote: \"")+T(psttShortP)+T("\"") ) ;
                                            bNotFound = 1 ;
                                        {
                                        if( ether.strIdF( tin0P , tReplyCode404_NotFound , tLine ) )

                                        }
                                            break ;
                                            tSay = tn ;
                                            etRock.traceF( tin0P , T("authorization refused") ) ;
                                        {
                                        if( POOP )
                                        __NZ( 1 == ether.strIdF( tin0P , tReplyCode401_Unauthorized , tLine ) ) ;
                                    {
                                    if( !POOP )

                                    __Z( offb ) ;
                                    bWoth = 0 ;
                                {
                                if( bWoth )

                                TN( tLine , postBuffer ) ;
                                postBuffer[ offb ] = 0 ;
                            {
                            else if( postBuffer[ offb ] == '\r' )         // IF I HAVE A LINE OF HEADER
                            }
                                etRock.traceF( tin0P , T("pullFileF / could not read a byte of a reply header line [offb,fragment]: ")+TF2(offb,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" >>>>")+T(postBuffer)+T("<<<<") ) ;

                                postBuffer[ offb ] = 0 ;
                            {
                            if( POOP )

                            if( !POOP ) postDebug[ offoDebug ++ ] = postBuffer[ offb ] ;

                            __Z( ss.readF( tin0P , postBuffer + offb , 1 ) ) ;
                        {
                        for( offb = 0 ; !POOP && offb < sizeof postBuffer ; offb ++ )
                        ZE( countT , cbFile ) ;
                        TN( tContentLength , "Content-Length:" ) ;
                        boolT bWoth = 1 ;
                        ZE( countT , offb ) ;
                        osTextT postBuffer[ TOCK ] ;

                        ZE( countT , offoDebug ) ;                                  //U::TO FIND A BUG
                        thirdC::c_memsetIF( tin0P , postDebug , sizeof postDebug ) ; //U::TO FIND A BUG
                        osTextT postDebug[ TOCK ] ;                                 //U::TO FIND A BUG

                        // 
                        // my.iddisk
                        // administrator.email@foo.com
                        // 
                        // Date: Mon, 08 Dec 2014 04:14:34 GMT
                        // X-Trans-Id: tx567c206bc36246dab9325-00548525aaiad3
                        // Content-Type: application/octet-stream
                        // X-Timestamp: 1418012073.44724
                        // Etag: f1290729de5a5ba08b49016a88a0f740
                        // Last-Modified: Mon, 08 Dec 2014 04:14:34 GMT
                        // Accept-Ranges: bytes
                        // Content-Length: 39
                        // HTTP/1.1 200 OK
                        // 
                        // SAMPLE REPLY
                    {
                    else
                    if( POOP ) ether.traceF( tin0P , T("pullFileF / could not write") ) ;
                    ss.writeF( tin0P , (osTextT*)tSay , (countT)tSay.csF( tin0P ) ) ;
                {
                else
                if( POOP ) ether.traceF( tin0P , T("pullFileF / could not connect") ) ;
                ss.connectF( tin0P , 443 , socketC::nicNameIF( tin0P , ether , tHost ) ) ;
            {
            else
            if( POOP ) ether.traceF( tin0P , T("pullFileF / could not ct socket") ) ;
            socketC ss( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL /*, &idleTimeAllowedRead , &idleTimeAllowedWrite*/ ) ;
            ZE( boolT , bNotFound ) ;
            TN( tFileTmp , "" ) ;

            SCOOPS
        {
        IFsCRATCHoK
        //countT idleTimeAllowedWrite = TICK >> 1 ;
        //countT idleTimeAllowedRead  = TICK >> 1 ;

        }
            ether.delF( tin0P , psttShortUrlEncoded ) ;
            }
                bHandle.ungrabF( tin0P ) ;
                tSay = T("GET ")+tUrlCloudAgent+T("/")+T(psttCloudContainerP)+T("/")+T(psttShortUrlEncoded)+T(" HTTP/1.1\r\nHost: ")+tHost+T("\r\nX-Auth-Token: ")+cloudInfo.tRackspaceAccessToken+T("\r\n\r\n") ;
                cloudInfoS& cloudInfo = *(cloudInfoS*)hCloud.osF( ifcIDtYPEhANDLE_CLOUD ) ;
                bHandle.grabF( tin0P , TAG( TAGiDnULL ) ) ;
            {

            //  
            // X-Auth-Token: f064c46a782c444cb4ba4b6434288f7c
            // Host: storage.clouddrive.com
            // GET /v1/MossoCloudFS_0672d7fa-9f85-4a81-a3ab-adb66a880123/archive/shortEncodedName HTTP/1.1
            // 
            // EXAMPLE

            ether.strToUrlF( tin0P , psttShortUrlEncoded , psttShortP ) ; ___( psttShortUrlEncoded ) ;
            ZE( strokeS* , psttShortUrlEncoded ) ;                                                                                                  
        {
        if( !tSay.csF( tin0P ) )
    {
    while( !POOP && !etPrime )
    TN( tSay , "" ) ;
    TN( tn , "" ) ;

    etherC& etPrime   = etherC::etPrimeIF( tin0P ) ;
    ZE( boolT , bOk ) ;

    //etRock.traceF( tin0P , T("the GET utterance has been appended to the log") ) ;
    //LOGrAW( tSay ) ;
    etherC& etRock = etherC::etRockIF( tin0P ) ;

    _IO_

    }
        if( POOP ) return ;
        __Z( psttShortP ) ;
        __Z( psttCloudContainerP ) ;
        __Z( psttFileP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    SCOOP
{
/*1*/voidT cloudC::pullFileF( tin0S& tin0P , soulC& sRenameP , const strokeS* const psttFileP , const strokeS* const psttCloudContainerP , const strokeS* const psttShortP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

