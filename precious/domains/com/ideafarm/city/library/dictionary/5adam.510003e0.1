
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinBaseP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    }
        etThread.osSleepF( tinBaseP , TOCK ) ;

        etThread = 0 ;

        }
            else                    { ZE( countT , tnu ) ; etThread.osThreadF( tinBaseP , tnu , tmSuckF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)pso , (countT)&tPathDatum ) ; }
            if( ether || etThread ) { DEL( pso ) ; }

            socket.acceptF( tinBaseP , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            ZE( socketC* , pso ) ;
        {
        while( !ether && !etThread )
        etThread.etherCryF( tinBaseP ) ;

        socket.listenF( tinBaseP ) ;
        countT idPort = socket.bindF( tinBaseP , ifcPORToLD1bOXsUCKER ) ;
        socketC socket( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;

        TN( tPathDatum , "///ideafarm/ephemeral/domains/com/ideafarm/city/data/new/dat." ) ;
    {
    while( !ether )

    etThread.strokeF( tinBaseP , T("IdeaFarm " "(tm) City Box Sucker\r\ni accept boxes on request\r\n") ) ;
{
else
}
    etThread.strokeF( tinBaseP , T("Another ")+textIdFileC( tinBaseP , DDNAME )+T(" appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tinBaseP , TAG( TAGiDnULL ) , T("2e30104") ) ;

TODO

DONE( tmSuckF )

}
    DEL( pso ) ;
    __( pso->readF( tinBaseP , &bnu , 1 , flSOCKETcrEAD_STILLhUNGRYiSoK ) ) ; // PEER WILL NEVER WRITE A BYTE, BUT WILL CLOSE CONN INSTEAD
    ZE( byteT , bnu ) ;
    pso->writeF( tinBaseP , (osTextT*)T("ok: this extra text appears to be needed to make the socket send this off") ) ; //U: CONJ: THIS IS NO LONGER NEEDED NOW THAT LINGER IS FIXED

    etThread.delF( tinBaseP , psttList ) ;
    etThread.delF( tinBaseP , pbAll ) ;

    }
        sOut.writeMsgF( tinBaseP , T("!amDry") ) ;

        }
            __( pbc != pbEnd ) ;
            }
                if( idf ) { etThread.strSubstringF( tinBaseP , psttw , idf , sttq , S1C(' ') , psttList ) ; ___( psttw ) ; }
                etThread.delF( tinBaseP , psttw ) ;

                etThread.strokeF( tinBaseP , T("\r\n") ) ;

                }
                    pbc += sizeof( countT ) + cbd ;

                    else etThread.boxPutF( tinBaseP , psttw , pbd , cbd ) ;
                    }
                        sOut.writeMsgF( tinBaseP , pbd , cbd ) ;
                        etThread.strokeF( tinBaseP , T("DATA DIVERTED") ) ;
                    {
                    if( 1 == etThread.strIdF( tinBaseP , idf , sttq , tPathDatum , psttw ) && *(countT*)pbd == cbd - sizeof( countT ) )

                    const countT cbd = *(countT*)pbc ;
                    const byteT* const pbd = pbc + sizeof( countT ) ;

                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf = 1 ;

                    __( pbc + sizeof( countT ) + *(countT*)pbc > pbEnd ) ;
                    __( pbc > pbEnd ) ;
                {
                if( pbc )
                __Z( pbc ) ;
                etThread.strokeF( tinBaseP , psttw ) ;

                }
                    etThread.delF( tinBaseP , psttFileId ) ;
                    etThread.strokeF( tinBaseP , T(psttFileId)+T("\t") ) ;
                    etThread.strFromF( tinBaseP , psttFileId , ++ fileId ) ; ___( psttFileId ) ;
                    ZE( strokeS* , psttFileId ) ;
                {
            {
            while( !ether && !etThread && psttw )
            ZE( countT , fileId ) ;
            etThread.strSubstringF( tinBaseP , psttw , idf , sttq , S1C(' ') , psttList ) ; ___( psttw ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttw ) ;
            pbc = pbAll ;
            ZE( byteT* , pbc ) ;
        {
        else
        }
            etThread.strokeF( tinBaseP , T("\r\n") ) ;

            else etThread.boxPutF( tinBaseP , psttList , pbAll , cbAll ) ;
            }
                sOut.writeMsgF( tinBaseP , pbAll , cbAll ) ;
                etThread.strokeF( tinBaseP , T("DATA DIVERTED") ) ;
            {
            if( 1 == etThread.strIdF( tinBaseP , idf , sttq , tPathDatum , psttList ) && *(countT*)pbAll == cbAll - sizeof( countT ) )
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;

            etThread.strokeF( tinBaseP , T("1\t")+T(psttList) ) ;
        {
        if( !fAggregate )

        boolT fAggregate = !!etThread.strIdF( tinBaseP , S1C(' ') , psttList ) ;
        pbEnd = pbAll + cbAll ;
        ZE( byteT* , pbEnd ) ;

        sOut.connectF( tinBaseP , ifcPORToLD1rIVERrESERVED ) ;
        socketC sOut( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
    {
    // PUT THE BOXES

    }
        pso->readF( tinBaseP , pbAll , cbAll ) ;
        etThread.newF( tinBaseP , LF , pbAll , cbAll ) ; ___( pbAll ) ;
        __Z( cbAll ) ;
        pso->readF( tinBaseP , (byteT*)&cbAll , sizeof cbAll ) ;
        pso->readWoLineF( tinBaseP , psttList , 0x10000 ) ;
    {
    if( !etThread )
    ZE( countT , cbAll ) ;
    ZE( byteT* , pbAll ) ;
    ZE( strokeS* , psttList ) ;
    // GET THE LIST AND THE DATA AGGREGATE

    pso->etherF( tinBaseP , etThread ) ;

    textC&   tPathDatum = *(textC*)  pTaskP->c2 ;
    socketC* pso        = (socketC*) pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmSuckF )

//     I.E. NAMES ARE SEPARATED BY A SINGLE BLANK
//   SYNTAX OF STRING:  "name1 name2 name3 ... nameN"
//   IF STRING, CLIENT SENDS COUNT FILE COUNT FILE ...
//   IF SINGLE NAME, SUCKER READS THE FILE BYTE COUNT, FOLLOWED BY THE FILE
//   CLIENT SENDS A LINE THAT CONTAINS A FILE NAME OR FILE NAME STRING
// PROTOCOL
/*1*/WAKEhIDE( "city.box.sucker" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

