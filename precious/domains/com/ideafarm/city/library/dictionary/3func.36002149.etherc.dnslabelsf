
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    /**/traceF( tin0P , T("dnsLabelsF 0 / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    delF( tin0P , pstt1w ) ;
    }
        cbP = cba ;

        /**/traceF( tin0P , T("dnsLabelsF 1 / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        __( pbc - pbP - cba ) ;    
        /**/traceF( tin0P , T("dnsLabelsF 2 / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        else *( pbc ++ ) = 0 ;
        }
            pbc += 2 ;
            *(count01T*)pbc = (count01T)( SWABnET2( offBest | 0xc000 ) ) ;
        {
        if( offBest != - 1 )
        }
            }
                for( countT ids = 1 ; ids <= psttc1->idAdam ; ids ++ ) *( pbc ++ ) = (byteT)psttc1[ CSpREFIX - 1 + ids ].idAdam ;
                *( pbc ++ ) = (byteT)psttc1->idAdam ;
            {
            FORsTRINGSiN1( pstt1w )
        {
        if( pstt1w )
        byteT* pbc = pbP ;
    {
    if( pbP )
    newF( tin0P , LF , pbP , cba ) ; ___( pbP ) ;
    /**/traceF( tin0P , T("dnsLabelsF 3 / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    }
        /**/traceF( tin0P , T("dnsLabelsF 4 / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        __( cba > 0xff ) ; //RFC1035/2/3/4
        /**/traceF( tin0P , T("dnsLabelsF 5 / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        }
            cba += 1 + psttc1->idAdam ;
            /**/traceF( tin0P , T("dnsLabelsF 6 / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            __( psttc1->idAdam > 0x3f ) ; //RFC1035/2/3/4
            /**/traceF( tin0P , T("dnsLabelsF 7 / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            __( !psttc1->idAdam ) ;
            /**/traceF( tin0P , T("dnsLabelsF 8 / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        FORsTRINGSiN1( pstt1w )
        if( psttBest != psttP ) delF( tin0P , psttBest ) ;
        strWordsOldF( tin0P , pstt1w , psttBest , sttq , T(".") ) ; ___( pstt1w ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    {
    if( psttBest )
    ZE( strokeS* , pstt1w ) ;
    countT cba = offBest != - 1 ? 2 : 1 ; // FOR TERMINATING NULL OR TERMINATING REFERENCE
    /**/traceF( tin0P , T("dnsLabelsF 9 / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    }
        /**/traceF( tin0P , T("dnsLabelsF a / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        else            __1
        if( !psttBest ) psttBest = (strokeS*)psttP ;
        /**/traceF( tin0P , T("dnsLabelsF b / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    if( offBest == - 1 )

    }
        }
            }
                /**/traceF( tin0P , T("dnsLabelsF c / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                }
                    delF( tin0P , pstts ) ;
                    else         idc += idDot + 1 ;
                    if( !idDot ) idc = 0 ;
                    countT idDot = strIdF( tin0P , T(".") , psttLeverP ) ;      //20250331@2158: psttLeverP <- pstts W/O ANALYSIS
                {
                else
                }
                    break ;
                    delF( tin0P , pstts ) ;
                    else delF( tin0P , psttn ) ;
                    }
                        /**/traceF( tin0P , T("dnsLabelsF / set [offBest,POOP]:    ")+TF2(offBest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        offBest = swOffP ;
                        psttBest = psttn ;
                        delF( tin0P , psttBest ) ;
                    {
                    if( !psttBest || !psttn || psttn->idAdam < psttBest->idAdam )
                    /**/traceF( tin0P , (psttn?T("bingo: the new portion is: \"")+T(psttn)+T("\" [POOP]:    "):T("bingo: an exact repeat (no new prefix) [POOP]:    "))+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    
                    }
                        /**/traceF( tin0P , T("called  strSubstringF [POOP,psttn]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    \"")+T(psttn)+T("\"") ) ;
                        strSubstringF( tin0P , psttn , countTC( 1 ) , countTC( idHit + idc - 3 ) , psttP ) ; ___( psttn ) ;
                        /**/traceF( tin0P , T("calling strSubstringF [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( idHit + idc >= 3 )
                    ZE( strokeS* , psttn ) ;
                {
                if( idHit && ( ( idHit == 1 && idc == 1 ) || psttP[ CSpREFIX - 3 + idHit + idc ] == S1C('.') ) )                // FOUND pstts AND IT'S EITHER AT THE BEGINNING OR PRECEDED BY A DOT
                countT idHit = strIdF( tin0P , pstts , psttP ) ;
    
                /**/traceF( tin0P , T("looking for \"")+T(pstts)+T("\" in \"")+T(psttP)+T("\" [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                strSubstringF( tin0P , pstts , countTC( idc ) , countTC() , psttLeverP ) ; ___( pstts ) ;
                ZE( strokeS* , pstts ) ;
                /**/traceF( tin0P , T("dnsLabelsF d / [idc,POOP]:    ")+TF2(idc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            while( idc )
            countT idc = 1 ;
            /**/traceF( tin0P , T("looking for portions of \"")+T(psttLeverP)+T("\", registered at ")+TF1(swOffP)+T(", in \"")+T(psttP)+T("\"") ) ;
            psttLeverP = (strokeS*)swOffP.leverF( tin0P , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swOffP.cFlavorsF( tin0P ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    {
    ZE( strokeS* , psttBest ) ;
    countT offBest = - 1 ;
    /**/traceF( tin0P , T("dnsLabelsF e / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    _IO_

    }
        if( POOP ) return ;
        /**/traceF( tin0P , T("dnsLabelsF f / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        __Z( psttP ) ;
        /**/traceF( tin0P , T("dnsLabelsF g / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        __( cbP ) ;
        /**/traceF( tin0P , T("dnsLabelsF h / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        __NZ( pbP ) ;
        /**/traceF( tin0P , T("dnsLabelsF i / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
    /**/traceF( tin0P , T("dnsLabelsF j / [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
{
/*1*/voidT etherC::dnsLabelsF( tin0S& tin0P , byteT*& pbP , countT& cbP , const strokeS* const psttP , switchC& swOffP , strokeS*& psttLeverP )/*1*/

/**/
*/
i compress if an entire earlier name is contained within psttP
\<A HREF=\"5.103018d.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dnsLabelsF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

