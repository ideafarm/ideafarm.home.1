

//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
}
    return rc ;

    ppMe[ idWorkerP - 1 ]->sp.sregC = ppMe[ idWorkerP - 1 ]->sp.sregB = ppMe[ idWorkerP - 1 ]->sp.sregA = ppMe[ idWorkerP - 1 ]->sp.regC = ppMe[ idWorkerP - 1 ]->sp.regB = ppMe[ idWorkerP - 1 ]->sp.regA = 0 ;

    }
        }
            }
                rc = ifcIDtYPEsTEPrECURSION_CALLpROLOG ;
            {
            else                                                                                                            // THE WO'TH HIGH ELEMENT IS BELOW THE LATH LOW ELEMENT, SO SWAP THEM AND THEN CALL MYSELF FOR THE ENCLOSED RANGE
            }
                ppMe[ idWorkerP - 1 ]->sp.pbHighs = ppMe[ idWorkerP - 1 ]->sp.pbUp ;
            {
            else if( ppMe[ idWorkerP - 1 ]->sp.pbUp > ppMe[ idWorkerP - 1 ]->sp.pbDn )                                                                          // ELEMENTS ARE SORTED ON THE FOCUS BIT (ALL OF THE LOWS ARE FOLLOWED BY ALL OF THE HIGHS)
            if( ppMe[ idWorkerP - 1 ]->sp.pbUp == ppMe[ idWorkerP - 1 ]->sp.pbDn ) { BLAMMO ; }                                                                 // SHOULD BE IMPOSSIBLE
        {
        else if( ppMe[ idWorkerP - 1 ]->sp.pbUp && ppMe[ idWorkerP - 1 ]->sp.pbDn )                                                                             // HAVE BOTH LOW AND HIGH ELEMENTS
        }
            ppMe[ idWorkerP - 1 ]->sp.pbHighs = ppMe[ idWorkerP - 1 ]->sp.pbUp ;
            }
                if( ppMe[ idWorkerP - 1 ]->sp.pbUp - pbP                                         ) { BLAMMO ; }
            {
            else
            }
                if( ppMe[ idWorkerP - 1 ]->sp.pbUp - pbP - ppMe[ idWorkerP - 1 ]->cbElt * ppMe[ idWorkerP - 1 ]->sp.remainderUseRoot ) { BLAMMO ; }
            {
            if( ppMe[ idWorkerP - 1 ]->sp.idNest == 1 )
        {
        else if( !ppMe[ idWorkerP - 1 ]->sp.pbDn )                                                                                            // NO LOW  ELEMENTS WERE FOUND (ALL ELEMENTS ARE HIGH)
        else if( !ppMe[ idWorkerP - 1 ]->sp.pbUp ) ;                                                                                          // NO HIGH ELEMENTS WERE FOUND (ALL ELEMENTS ARE LOW )
        if( !ppMe[ idWorkerP - 1 ]->sp.pbUp && !ppMe[ idWorkerP - 1 ]->sp.pbDn ) { BLAMMO ; }                                                                   // SHOULD BE IMPOSSIBLE

        }
            }
                }
                    break ;
                    ppMe[ idWorkerP - 1 ]->sp.pbDn = pbP + ppMe[ idWorkerP - 1 ]->sp.sregC ;
                {
                if( !( *(countT*)( pbP + ppMe[ idWorkerP - 1 ]->sp.sregC + ppMe[ idWorkerP - 1 ]->cbPrefix ) >> ppMe[ idWorkerP - 1 ]->sp.shift & 1 ) )
            {
            for( ppMe[ idWorkerP - 1 ]->sp.sregC = ppMe[ idWorkerP - 1 ]->sp.sregA ; ppMe[ idWorkerP - 1 ]->sp.sregC > ppMe[ idWorkerP - 1 ]->sp.sregB ; ppMe[ idWorkerP - 1 ]->sp.sregC -= ppMe[ idWorkerP - 1 ]->cbElt * ppMe[ idWorkerP - 1 ]->modulo )      // ACCEPT THIS ELEMENT AS AN "DOWN CANDIDATE" SINCE THE FOCUS BIT IS NOT SET

            //;
            //    : - 1
            //    ? - 1 + ppMe[ idWorkerP - 1 ]->sp.remainderUseRoot
            //ppMe[ idWorkerP - 1 ]->sp.sregB = ppMe[ idWorkerP - 1 ]->sp.idNest == 1

            else                      ppMe[ idWorkerP - 1 ]->sp.sregB = - 1                            ;
            if( ppMe[ idWorkerP - 1 ]->sp.idNest == 1 ) ppMe[ idWorkerP - 1 ]->sp.sregB = - 1 + ppMe[ idWorkerP - 1 ]->sp.remainderUseRoot ;

            ppMe[ idWorkerP - 1 ]->sp.sregA = ppMe[ idWorkerP - 1 ]->sp.regA ;

            }
                else                                                                               ppMe[ idWorkerP - 1 ]->sp.regA -= ppMe[ idWorkerP - 1 ]->cbElt ;
                if(                             !( ( ppMe[ idWorkerP - 1 ]->sp.regA / ppMe[ idWorkerP - 1 ]->cbElt ) % ppMe[ idWorkerP - 1 ]->modulo ) ) break                      ;
            {
            else for(;;)                                                                                    //U::O: USE A FORMULA RATHER THAN ITERATIVE SEARCH
            }
                else                                                                               ppMe[ idWorkerP - 1 ]->sp.regA -= ppMe[ idWorkerP - 1 ]->cbElt ;
                if( ppMe[ idWorkerP - 1 ]->sp.remainderUseRoot ==    ( ppMe[ idWorkerP - 1 ]->sp.regA / ppMe[ idWorkerP - 1 ]->cbElt ) % ppMe[ idWorkerP - 1 ]->modulo   ) break                      ;
            {
            if( ppMe[ idWorkerP - 1 ]->sp.idNest == 1 ) for(;;)                                                               //U::O: USE A FORMULA RATHER THAN ITERATIVE SEARCH
            ppMe[ idWorkerP - 1 ]->sp.regA = cbP - ppMe[ idWorkerP - 1 ]->cbElt ;

            }
                }
                    break ;
                    ppMe[ idWorkerP - 1 ]->sp.pbUp = pbP + ppMe[ idWorkerP - 1 ]->sp.regC ;
                {
                if( *(countT*)( pbP + ppMe[ idWorkerP - 1 ]->sp.regC + ppMe[ idWorkerP - 1 ]->cbPrefix ) >> ppMe[ idWorkerP - 1 ]->sp.shift & 1 )
            {
            for( ppMe[ idWorkerP - 1 ]->sp.regC = ppMe[ idWorkerP - 1 ]->sp.regA ; ppMe[ idWorkerP - 1 ]->sp.regC < ppMe[ idWorkerP - 1 ]->sp.regB ; ppMe[ idWorkerP - 1 ]->sp.regC += ppMe[ idWorkerP - 1 ]->cbElt * ppMe[ idWorkerP - 1 ]->modulo )
            ppMe[ idWorkerP - 1 ]->sp.regB = cbP ;

            //;
            //    : 0
            //    ? ppMe[ idWorkerP - 1 ]->sp.remainderUseRoot * ppMe[ idWorkerP - 1 ]->cbElt
            //ppMe[ idWorkerP - 1 ]->sp.regA = ppMe[ idWorkerP - 1 ]->sp.idNest == 1

            else                      ppMe[ idWorkerP - 1 ]->sp.regA = 0 ;
            if( ppMe[ idWorkerP - 1 ]->sp.idNest == 1 ) ppMe[ idWorkerP - 1 ]->sp.regA = ppMe[ idWorkerP - 1 ]->sp.remainderUseRoot * ppMe[ idWorkerP - 1 ]->cbElt ;
        {
        ppMe[ idWorkerP - 1 ]->sp.pbDn = 0 ;                                                                       // SET ppMe[ idWorkerP - 1 ]->sp.pbDn TO THE LATH LOW ELEMENT   (ELEMENT WITH FOCUS BIT NOT SET)
        ppMe[ idWorkerP - 1 ]->sp.pbUp = 0 ;                                                                       // SET ppMe[ idWorkerP - 1 ]->sp.pbUp TO THE WOTH HIGH ELEMENT  (ELEMENT WITH FOCUS BIT     SET)
    {

    }
        ppMe[ idWorkerP - 1 ]->sp.remainderUseRoot = ( ppMe[ idWorkerP - 1 ]->remainder - ppMe[ idWorkerP - 1 ]->sp.regA ) % ppMe[ idWorkerP - 1 ]->modulo ;
        ppMe[ idWorkerP - 1 ]->sp.regA             = ( pbP - ppMe[ idWorkerP - 1 ]->pbArray ) / ppMe[ idWorkerP - 1 ]->cbElt ;
        ppMe[ idWorkerP - 1 ]->sp.pbHighs = 0 ;

        if( ( pbP - ppMe[ idWorkerP - 1 ]->pbArray ) % ppMe[ idWorkerP - 1 ]->cbElt ) { BLAMMO ; }
    {
    if( !( ppMe[ idWorkerP - 1 ]->sp.idNest ++ ) )
    if( !pbP || !cbP ) { BLAMMO ; }

    ppMe[ idWorkerP - 1 ]->sp.cbRangeLathCall = cbP ;
    ppMe[ idWorkerP - 1 ]->sp.pbRangeLathCall = pbP ;

    countT rc = ifcIDtYPEsTEPrECURSION_EPILOG ;
    TRACEpARAMSsORTAc( "swapRsPrologIF" )
{
/*1*/countT sortaC::swapRsPrologIF( recursionSimulatorC& rsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
