
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        __1
        ether = 0 ;
    {               //    (THIS SNIPPET IS NOT IN CONFORMANCE, BECAUSE (1) IT USES "ether = 0", AND (2) IT HAS NO EFFECT (THE "__1" JUST MAKES ether IMPOTENT AGAIN SINCE SCOOP IS STILL IN EFFECT)
    if( POOP )      //U:: 20201105@1546: THIS IS ODD CODE.  boxC IS A VERY OLD CLASS.  REVIEW ITS ERROR HANDLING TO BRING IT INTO CONFORMANCE

    }
        DEL( pBatHPR  ) ;
        DEL( pBatHPC  ) ;
        DEL( pBatTap  ) ;
        DEL( pBatHose ) ;

        DEL( pSgnTapFinished  ) ;
        DEL( pSgnTapReady     ) ;
        DEL( pSgnHoseFinished ) ;
    {
    if( pBatHose )

    }
        pBatTap->ungrabF( tin0P ) ;
        pSgnTapFinished->giveF( tin0P ) ;
    {
    else if( fTap2 )
    }
        pBatHose->ungrabF( tin0P ) ;
        pSgnTapFinished->waitF( tin0P ) ;
        pSgnHoseFinished->giveF( tin0P ) ;
    {
    if( fHose2 )
    ether.delF( tin0P , psttAll  ) ;
    ether.delF( tin0P , psttName ) ;
    ether.delF( tin0P , psttPass ) ;
    ether.delF( tin0P , psttUser ) ;
    ether.delF( tin0P , psttType ) ;
    ether.delF( tin0P , psttHost ) ;

    else __1
    }
        else __1
        else if( psttType && !psttType->idAdam ) ;
        }
            pbNapkin = 0 ;
            pv = (voidT*)( pbNapkin - sizeof(countT) ) ;
            ZE( voidT* , pv ) ;
        {
        else if( !ether.strCompareF( tin0P , psttType , T("napkin.make") ) || !ether.strCompareF( tin0P , psttType , T("napkin") ) )
        }
            DEL( pHoseProcessError ) ;
            if( !ether && pHoseProcessError ) pHoseProcessError->closeNewClientF( tin0P ) ;
        {
        else if( !ether.strCompareF( tin0P , psttType , T("process.error") ) )
        }
            DEL( pHoseProcessOut ) ;
            if( !ether && pHoseProcessOut ) pHoseProcessOut->closeNewClientF( tin0P ) ;
        {
        else if( !ether.strCompareF( tin0P , psttType , T("process.out") ) )
        }
            //U:
        {
        else if( !ether.strCompareF( tin0P , psttType , T("process.in") ) )
        }
            //U:DEL( pHoseProcessIn    ) ;
            DEL( pHoseProcessOut   ) ;
            DEL( pHoseProcessError ) ;

            //{ countT hAliasError2 = 2 ; hAliasError2 = hAliasError ; }
            //{ countT hAliasOut2   = 1 ; hAliasOut2   = hAliasOut   ; }
            //{ countT hAliasIn2    = 0 ; hAliasIn2    = hAliasIn    ; }
            //U:: THIS CODE IS BUGGY

            ether.fileWriteF( tin0P , h2 , "\xDB" ) ; //U:NT (HANDLE 2 IS HARDCODED)
            ether.fileWriteF( tin0P , h1 , "\xDB" ) ; //U:NT (HANDLE 1 IS HARDCODED)
            h2.osF( ifcIDtYPEhANDLE_FILE , 2 ) ;
            h1.osF( ifcIDtYPEhANDLE_FILE , 1 ) ;
            handleC h2( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            handleC h1( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            __( value ) ;
            __( idDeathType ) ;
            ether.osProcessWaitF( tin0P , value , idDeathType , osTid , osPid ) ;
            ZE( countT , idDeathType ) ;
            ZE( countT , value ) ;
        {
        else if( !ether.strCompareF( tin0P , psttType , T("process") ) )
        }
            #endif
                fHose2 = 1 ;
            #elif defined( __NT__ )
            #ifdef __OS2__
        {
        else if( !ether.strCompareF( tin0P , psttType , T("hose") ) )
        }
            #endif
                fTap2 = 1 ;
                pSgnHoseFinished->waitF( tin0P ) ;
            #elif defined( __NT__ )
            #ifdef __OS2__
        {
        if( !ether.strCompareF( tin0P , psttType , T("tap") ) )
    {
    else if( psttHost && !psttHost->idAdam )
    }
    {
    else if( !ether.strCompareF( tin0P , psttType , T("fyle") ) )
    }
        DEL( pSControl ) ;
        verifyReplyF( tin0P , 205 ) ;
        if( pSControl ) pSControl->writeF( tin0P , (osTextT*)T("quit\r\n") ) ;
    {
    else if( !ether.strCompareF( tin0P , psttType , T("news") ) )
    }
        DEL( pSControl ) ;
        verifyReplyF( tin0P ) ;
        if( pSControl ) pSControl->writeF( tin0P , (osTextT*)T("quit\r\n") ) ;
    {
    else if( !ether.strCompareF( tin0P , psttType , T("pop") ) )
    }
        DEL( pSControl ) ;
    {
    else if( !ether.strCompareF( tin0P , psttType , T("http") ) || !ether.strCompareF( tin0P , psttType , T("https") ) )
    }
    {
    else if( !ether.strCompareF( tin0P , psttType , T("smtp") ) )
    }
        DEL( pSControl ) ;
        verifyReplyF( tin0P , 221 ) ;
        if( pSControl ) pSControl->writeF( tin0P , (osTextT*)T("quit\r\n") ) ;
    {
    else if( !ether.strCompareF( tin0P , psttType , T("ftp") ) )
    }
        DEL( pSControl ) ;
    {
    )
        !ether.strCompareF( tin0P , psttType , T("dispatcher"       ) )
        !ether.strCompareF( tin0P , psttType , T("time"             ) ) ||
        !ether.strCompareF( tin0P , psttType , T("box.sucker"       ) ) ||
        !ether.strCompareF( tin0P , psttType , T("box.server.adam"  ) ) ||
        !ether.strCompareF( tin0P , psttType , T("box.server.deputy") ) ||
        !ether.strCompareF( tin0P , psttType , T("box.server"       ) ) ||
    (
    if

    }
        ether = 0 ;
        __1
    {
    if( POOP )

    ZE( boolT , fHose2 ) ;
    ZE( boolT , fTap2 ) ;
    // CLOSE THE BACKING FILE
    _IO_

    }
        if( POOP ) return ;
        }
            DEL( pSControl ) ;
            ether.delF( tin0P , psttAll  ) ;
            ether.delF( tin0P , psttName ) ;
            ether.delF( tin0P , psttPass ) ;
            ether.delF( tin0P , psttUser ) ;
            ether.delF( tin0P , psttType ) ;
            ether.delF( tin0P , psttHost ) ;
        {
        if( POOP )
        __Z( psttName ) ;
        __Z( psttType ) ;
        __Z( psttHost ) ;
    {
    IFbEcAREFUL

    if( POOP ) return ;
    }
        DEL( pSControl ) ;
        ether.delF( tin0P , psttAll  ) ;
        ether.delF( tin0P , psttName ) ;
        ether.delF( tin0P , psttPass ) ;
        ether.delF( tin0P , psttUser ) ;
        ether.delF( tin0P , psttType ) ;
        ether.delF( tin0P , psttHost ) ;
    {
    if( POOP )
    SCOOP
    TINSL
{
/*1*/boxC::~boxC( voidT )/*1*/

/**/
*/
  \<A HREF=\"5.5120104.1.1.0.html\"\>5120104:  WAKEsHOW( "example.simplest.func.1090002.boxC.dt_boxC" )\</A\>
 simplest
examples
\<A HREF=\"5.1090002.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

