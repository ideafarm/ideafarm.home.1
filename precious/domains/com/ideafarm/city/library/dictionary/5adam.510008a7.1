
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        }
            DELzOMBIE( psoDoomed ) ;
            socketC* psoDoomed = (socketC*)pbSocket ;
        {

        }
            ++ s ; etThread.osSleepF( tin0P , TOCK >> 3 ) ;
            etRock.traceF( tin0P , T("waiting for all workers to go away [cWorkers]:    ")+TF2(cWorkers,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        while( cWorkers )
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        bQuit ++ ;

        }
            gv.st_pJob << (countT)pJob ;
            jobS* pJob = new( 0 , tin0P , LF ) jobS( pbq , cbq , idp , nnPeer ) ; ___( pJob ) ;

            //etRock.traceF( tin0P , gc.tSayWaitedForPacket/*+T(nnPeer)+gc.tb4+TF2(cbq,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)*/ ) ;
            }
                }
                    break ;
                    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                    etRock.traceF( tin0P , gc.tSayExReadFailed+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                {
                if( POOP )
                /**/etRock.traceF( tin0P , gc.tSayCalledRead ) ;
                sockd.readF( tin0P , pbq , cbq , idp , nnPeer ) ; ___( pbq ) ;
                /**/etRock.traceF( tin0P , gc.tSayCallingRead ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK
            //etRock.traceF( tin0P , gc.tSayWaitingForPacket ) ;
            nicNameC nnPeer ;
            ZE( countT , idp ) ;
            ZE( countT , cbq ) ;
            ZE( byteT* , pbq ) ;

            //etRock.traceF( tin0P , gc.tSayInnerLoopBegun ) ;
            _IO_
        {
        while( !POOP && !ether )

        }
            etThread.osThreadF( TaRG2cBsTACK( tmWorkerF , CBsTACKmIN << 1 ) , (countT)&bQuit , (countT)&bFail , (countT)&cWorkers , (countT)&mySettings , (countT)&sockd , (countT)&gc , (countT)&gv ) ;
            inc02AM( cWorkers ) ;
        {
        while( cDo -- )
        countT cDo = thirdC::osProcessorsIF( tin0P ) << 3 ;

        ZE( boolT  , bFail    ) ;
        ZE( boolT  , bQuit    ) ;
        ZE( countT , cWorkers ) ;

        }
            }
                continue ;
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                etRock.traceF( tin0P , T("!exception / could not bind socket to the dns port [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )
            sockd.bindF( tin0P , ifcPORToLD2_DNS ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK

        }
            }
                continue ;
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                etRock.traceF( tin0P , T("!exception / could not construct socket [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )

            new( 0 , tin0P , pbSocket , sizeof pbSocket ) socketC( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        socketC& sockd = *(socketC*)pbSocket ;
        byteT pbSocket[ sizeof( socketC ) ] ;

        //etRock.traceF( tin0P , T("outer loop begun") ) ;
        _IO_
    {
    while( !POOP && !ether )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    //U::6: etThread.osThreadF( TaRG2cBsTACK( tmUpdateNnHostsF , CBsTACKmIN << 1 ) , (countT)&gv.nnHostWebLath , (countT)&gv.nnHostWebLag0 , (countT)&gv.nnHostWebLag1 , (countT)&gv.nnHostWebLag2 , (countT)&gv.nnHostWebLag3 ) ;

    }
        }
            }
                etRock.traceF( tin0P , T("!exception / could not write password suffix shared file [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+gc.tb4+tLong ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            else
            if( !POOP ) /*;*/etRock.traceF( tin0P , T("wrote password suffix shared file aok [tLong]:    ")+tLong ) ;
            ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , (osTextT*)gv.tWoTimePasswordUrlSuffix , gv.tWoTimePasswordUrlSuffix.csF( tin0P ) ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        TN( tLong , "" ) ; tLong = T("////dns1/d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T("/woTimePasswordUrlSuffix") ;
    {

    mySettings.grabMe.ungrabF( tin0P ) ;

    etRock.traceF( tin0P , T("initialized [gv.tWoTimePasswordUrlSuffix]:    ")+gv.tWoTimePasswordUrlSuffix ) ;

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                   *******************************************************************************************************************************************************************************************************************************************************************************************
    //*****  PREPARE TO WORK  *******************************************************************************************************************************************************************************************************************************************************************************************
    //*****                   *******************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************


    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                                   ***************************************************************************************************************************************************************************************************************************************************************************
    //*****  LOCAL VARIABLES (MASTER THREAD)  ***************************************************************************************************************************************************************************************************************************************************************************
    //*****                                   ***************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                                              ****************************************************************************************************************************************************************************************************************************************************************
    //*****  LOCAL VARIABLES (INSTANCE FOR EACH WORKER)  ****************************************************************************************************************************************************************************************************************************************************************
    //*****                                              ****************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    gVarS gv( tin0P , etThread , gc ) ;

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                                            ******************************************************************************************************************************************************************************************************************************************************************
    //*****  GLOBAL VARIABLES (SHARED BY ALL WORKERS)  ******************************************************************************************************************************************************************************************************************************************************************
    //*****                                            ******************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    gConstS gc( tin0P , mySettings ) ;

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                                            ******************************************************************************************************************************************************************************************************************************************************************
    //*****  GLOBAL CONSTANTS (SHARED BY ALL WORKERS)  ******************************************************************************************************************************************************************************************************************************************************************
    //*****                                            ******************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    }
        __1 ;
        /**/etRock.traceF( tin0P , T("!exception / a required setting is missing") ) ;
        mySettings.grabMe.ungrabF( tin0P ) ;
        _IO_
    {
    if( !mySettings )
    mySettings.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

    etThread.traceF( tin0P , T("the settings are ready") ) ;
    sgnSettingsReady.waitF( tin0P ) ;
    etThread.osThreadF( TaRG2cBsTACK( tmFreshSettingsF , CBsTACKmIN << 1 ) , (countT)&mySettings , (countT)&sgnSettingsReady ) ;

    mySettingsS mySettings( tin0P , etThread ) ;
    signC       sgnSettingsReady( tin0P , TAG( TAGiDnULL ) ) ;

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                **********************************************************************************************************************************************************************************************************************************************************************************************
    //*****  GET SETTINGS  **********************************************************************************************************************************************************************************************************************************************************************************************
    //*****                **********************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIEST ) ; // RUDE WOULD BE AN ATTACK SURFACE
    thirdC::dosPriorityProcessIF(      tin0P , ifcTHREADpRIORITY_RUDE    ) ; // THIS IS SO PASSWORD (WEBHOOK SUFFIX) UPDATES ARE NOTICED TIMELY

    _IO_
{
if( pTaskP )
TASK( tmWorkF )


DONE( tmWorkerF )
}
    dec02AM( cWorkersP ) ;

    }
        }
            }
                }
                    IFsCRATCHoK{}

                    etThread.delF( tin0P , pJob->pbq ) ;
                    }
                        }
                            }
                                etThread.delF( tin0P , pbr ) ;
                                }
                                    }
                                        }
                                            /**/etRock.traceF( tin0P , gcP.tSayExCouldNotWriteReply+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            POOPRqUIET
                                            countT rc = POOP ;
                                        {
                                        else
                                        if( !POOP ) ;//etRock.traceF( tin0P , gcP.tSayWroteReply ) ;
                                        sockdP.writeF( tin0P , pJob->idp , pJob->nnPeer , pbr , cbr ) ;
                                        //etRock.traceF( tin0P , gcP.tSayReplying1/*+TF2(cbr,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)*/ ) ;
                                        _IO_
                                    {
                                    else
                                    }
                                        /**/etRock.traceF( tin0P , gcP.tSayExCouldNotBuildReply+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        POOPRqUIET
                                        countT rc = POOP ;
                                        _IO_
                                    {
                                    if( POOP )
                                    ((tin1S&)tin0P).pEtScratch->dnsReplyF( tin0P , pbr , cbr , pJob->pbq , stsReplies , 1 , idError ) ;
                                    SCOOPS
                                    _IO_
                                {
                                IFsCRATCHoK
                                ZE( countT , cbr ) ;
                                ZE( byteT* , pbr ) ;
                                //etRock.traceF( tin0P , gcP.tSayReplying2 ) ;

                                else                          ;//etRock.traceF( tin0P , T("replying [error]:    ")+TF2(idError,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                if( postError && *postError ) ;//etRock.traceF( tin0P , T("replying [error]:    ")+T(postError)                                          ) ;
                                const osTextT* postError = processGlobal4S::_processGlobal4I_IF().mapIdErrorDns( idError ) ;
                            {
                            if( !bSilent || bForceReply )

                            }
                                }
                                    }
                                        if( !stsReplies ) idError = ifcIDeRRORdNS_NAMEnOTdEFINED ;

                                        }
                                            DEL( ps ) ;
                                            }
                                                }
                                                    //}
                                                    //    break ;
                                                    //
                                                    //    }
                                                    //        rec_AAAA_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut ) ;
                                                    //        bSilent = 0 ;
                                                    //    {
                                                    //    if( ~nnOut )
                                                    //
                                                    //           if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gcP.tTarget      ) ) nnOut = gvP.nnHostWebLag0 ;
                                                    //    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gcP.tWebHook1    ) ) nnOut = nnWebHook1    ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                                    //    //     if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gcP.tWebHooks    ) ) nnOut = nnWebHook1    ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...
                                                    //
                                                    //    //etRock.traceF( tin0P , T("U:: debug    [gcP.tTarget]:    \"")+gcP.tTarget+T("\"") ) ;
                                                    //    //etRock.traceF( tin0P , T("U:: debug [tDomainNet]:    \"")+tDomainNet+T("\"") ) ;
                                                    //
                                                    //    nicNameC nnOut ;
                                                    //    //etRock.traceF( tin0P , gcP.tSayAAAARequest/*+tDomainNet*/ ) ;
                                                    //    _IO_
                                                    //{
                                                    //case ifcIDtYPEdNSqUERY_AAAA :
                                                    }
                                                        break ;

                                                        }
                                                            rec_A_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut ) ;
                                                            bSilent = 0 ;
                                                        {
                                                        if( ~nnOut )

                                                        }
                                                            else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gcP.tWebHook1    ) ) nnOut = nnWebHook1 ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                                                 if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gcP.tWebHooks    ) ) nnOut = nnWebHook1 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...
                                                        {
                                                        else
                                                        }
                                                                 if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gcP.tWebHooks    ) ) nnOut = nnWebHook2 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...
                                                        {
                                                        if( bDivert )

                                                        nicNameC nnOut ;
                                                        //etRock.traceF( tin0P , gcP.tSayARequest/*+tDomainNet*/ ) ;
                                                        _IO_
                                                    {
                                                    case ifcIDtYPEdNSqUERY_A :
                                                    }
                                                        break ;
                                                    {
                                                    case ifcIDtYPEdNSqUERY_CAA :
                                                {
                                                if( idClass == 1 ) switch( idType )

                                                *ps >> idClass ;
                                                ZE( countT , idClass ) ;

                                                *ps >> idType ;
                                                ZE( countT , idType ) ;

                                                etThread.delF( tin0P , psttw ) ;
                                                TN( tDomainNet , psttw ) ;
                                                }
                                                    etThread.delF( tin0P , psttSuffix ) ;

                                                    }
                                                        }
                                                            etThread.osTimeNowF( tin0P , gvP.timeUsed1 , gvP.timeUsed2 ) ;
                                                            gvP.timeUsed2 = gvP.timeUsed1 = 0 ;
                                                            gvP.cUsed = 1 ;

                                                            }
                                                                }
                                                                    /**/etRock.traceF( tin0P , gcP.tSayExCouldNotWritePasswordFile+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+gcP.tb4+tLong ) ;
                                                                    POOPRqUIET
                                                                    countT rc = POOP ;
                                                                {
                                                                else
                                                                if( !POOP ) ;//etRock.traceF( tin0P , gcP.tSayWrotePasswordFile/*+tLong*/ ) ;
                                                                ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , (osTextT*)gvP.tWoTimePasswordUrlSuffix , gvP.tWoTimePasswordUrlSuffix.csF( tin0P ) ) ;
                                                                SCOOPS
                                                                _IO_
                                                            {
                                                            IFsCRATCHoK
                                                            TN( tLong , "" ) ; tLong = T("////dns1/d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T("/woTimePasswordUrlSuffix") ;

                                                            //etRock.traceF( tin0P , gcP.tSayNewPassword/*+gvP.tWoTimePasswordUrlSuffix*/ ) ;

                                                                                  gvP.tGorillaSuffix = gvP.tWoTimePasswordUrlSuffix+gcP.tDotHiddenDotIdeafarmDotCom ;
                                                            gvP.tGorillaSuffixUsed  = gvP.tGorillaSuffix ; 
                                                                                  gvP.tWoTimePasswordUrlSuffix = gcP.tPasswordPrefix+TF4((countT)ruPassword,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FILLzE,0,0x24) ;
                                                            gvP.tWoTimePasswordUrlSuffixUsed = gvP.tWoTimePasswordUrlSuffix ;

                                                            //etRock.traceF( tin0P , gcP.tSayOldPassword/*+gvP.tWoTimePasswordUrlSuffix*/ ) ;

                                                            gvP.cUsed = 0 ;
                                                        {
                                                        if( bNewPassword )

                                                        }
                                                            }
                                                                bNewPassword = 1 ;
                                                                bDivert = 0 ;
                                                                //etRock.traceF( tin0P , gcP.tSayResettingDivert2/*+gvP.tGorillaSuffix*/ ) ;
                                                                _IO_
                                                            {
                                                            else if( !etThread.strCompareF( tin0P , psttSuffix , gvP.tGorillaSuffix ) )
                                                            }
                                                                }
                                                                    bNewPassword = 1 ;
                                                                    //etRock.traceF( tin0P , gcP.tSaySettingNewPassword/*+gvP.tGorillaSuffixUsed*/ ) ;
                                                                    _IO_
                                                                {                                                                                            
                                                                if( ++ gvP.cUsed > 0x80 || timeE2 || timeE1 > TOCK << 4 )                                   //20250608@0853: "0x80 <- 0x20" AND "<< 4" <- "<< 2" W/O ANALYSIS (THE PRECEDING CHANGE SEEMED TO REDUCED STUTTER BY A LOT)
                                                                                                                                                        //20250607@1542: "0x20 <- 0x8" AND "<< 2" <- "<< 0" W/O ANALYSIS TO FIX STUTTER (MULTIPLE UPDATES TO A SINGLE USE)
                                                                etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , gvP.timeUsed1 , gvP.timeUsed2 ) ;
                                                                etThread.osTimeNowF(      tin0P , timeE1 , timeE2 ) ;
                                                                ZE( sCountT , timeE2 ) ;
                                                                ZE( countT  , timeE1 ) ;

                                                                bDivert = 0 ;                                                                       //PS:PERSONALITY: THE DUPLICATE USAGE IS ALWAYS HONORED, BUT THEN WILL BE RETIRED IF USED TOO MANY TIMES OR TOO MUCH TIME HAS ELAPSED SINCE WOTH USE
                                                                //etRock.traceF( tin0P , gcP.tSayResettingDivert/*+gvP.tGorillaSuffixUsed*/ ) ;
                                                                _IO_
                                                            {
                                                            if( !etThread.strCompareF( tin0P , psttSuffix , gvP.tGorillaSuffixUsed ) )

                                                            _IO_
                                                        {
                                                        ZE( boolT , bNewPassword ) ;
                                                    {
                                                    if( bDivert )                                                                               //PS:PERSONALITY: HONOR THE USED SUFFIX SO THAT DUPLICATE QUERIES ALL RECEIVE THE SAME wh1 ANSWER UNTIL THE CURRENT PASSWORD IS USED

                                                    //etRock.traceF( tin0P , gcP.tSayDomainNetSuffixPeer/*+T(psttw)+T("\"    \"")+T(psttSuffix)+T("\"    \"")+tDomainPeer+T("\"")*/ ) ;

                                                    etThread.strMakeF( tin0P , LF , psttw , tDomainNet ) ; ___( psttw ) ;
                                                    etThread.delF( tin0P , psttNet ) ;
                                                    TN( tDomainNet , "" ) ; tDomainNet = T(psttNet)+T(".hidden.ideafarm.com") ;

                                                    etThread.delF( tin0P , psttw ) ;
                                                    if( bDivert ) { etThread.strSubstringF( tin0P , psttSuffix , idf , countTC()    , psttw , 0     ) ; ___( psttSuffix ) ; }
                                                                    etThread.strSubstringF( tin0P , psttNet    , idf , sttq , gcP.tDash , psttw , 0 , 0 ) ; ___( psttNet    ) ;
                                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                    countT idf = 1 ;
                                                    ZE( strokeS* , psttSuffix ) ;
                                                    ZE( strokeS* , psttNet ) ;
                                                    _IO_
                                                {
                                                if( psttw && etThread.strIdF( tin0P , gcP.tHidden , psttw , 1 ) && etThread.strIdF( tin0P , gcP.tDash , psttw , 1 ) )

                                                //etRock.traceF( tin0P , gcP.tSayDomainGrossPeer/*+tDomainGross+gcP.gcP.tqb4q+tDomainPeer+gcP.tq*/ ) ;
                                                TN( tDomainGross , psttw ) ;
                                                if( psttw ) ((tin1S&)tin0P).pEtScratch->strConvertToLowerCaseF( tin0P , psttw ) ; ___( psttw ) ;
                                                //etRock.traceF( tin0P , gcP.tSayLoweringCase ) ;
                                                *ps >> psttw ;
                                                ZE( strokeS* , psttw ) ;
                                                _IO_
                                            {
                                            if( ps )
                                            stsQueries >> ps ;
                                            ZE( soulC* , ps ) ;
                                            //etRock.traceF( tin0P , gcP.tSayPoppingQuery ) ;
                                            _IO_
                                        {
                                        while( stsQueries )
                                        _IO_
                                    {
                                    else
                                    }
                                        idError = ifcIDeRRORdNS_CANNOTpARSEqUERY ;
                                        /**/etRock.traceF( tin0P , gcP.tSayExCouldNotParse+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        POOPRqUIET
                                    {
                                    if( rc )
                                    etThread.delF( tin0P , pbNU ) ;
                                    //etRock.traceF( tin0P , gcP.tSayCalledDnsParse ) ;
                                    countT rc = POOP ;
                                    ((tin1S&)tin0P).pEtScratch->dnsParseF( tin0P , pbNU , countTC() , stsQueries , stsRepliesNU , pJob->pbq , pJob->cbq ) ;
                                    SCOOPS
                                    //etRock.traceF( tin0P , gcP.tSayCallingDnsParse ) ;
                                    _IO_
                                {
                                IFsCRATCHoK
                                ZE( byteT* , pbNU ) ;

                                //etRock.traceF( tin0P , gcP.tSayPurgedStacks ) ;
                                stsRepliesNU.purgeF( tin0P ) ;
                                stsQueries.purgeF( tin0P ) ;
                                //etRock.traceF( tin0P , gcP.tSayPurgingStacks ) ;
                                _IO_
                            {

                            ++ gvP.idClient ;

                            //}
                            //    //etRock.traceF( tin0P , TT(timeN1,timeN2)+gcP.tb4+tTimeOld+gcP.tb4+T(pJob->nnPeer)+(bDivert?gcP.tSayDiverting:gcP.tSayGranting)+tDomainPeer ) ;
                            //
                            //    }
                            //        etThread.delF( tin0P , pstgcP.tSay ) ;
                            //        tTimeOld = T(pstgcP.tSay) ;
                            //        etThread.strFromOldTimeF( tin0P , pstgcP.tSay , mm , hh , d , m , y , dow , 0 ) ; ___( pstgcP.tSay ) ;
                            //        ZE( strokeS* , pstgcP.tSay ) ;
                            //    {
                            //    TN( tTimeOld , "" ) ;
                            //
                            //    etThread.osTimeToOldTimeF( tin0P , ms , ss , mm , hh , d , m , y , dow , timeN1 , timeN2 , flOStIMEtOoLDtIME_null ) ;
                            //    ZE(  countT , dow ) ;
                            //    ZE( sCountT , y   ) ;
                            //    ZE(  countT , m   ) ;
                            //    ZE(  countT , d   ) ;
                            //    ZE(  countT , hh  ) ;
                            //    ZE(  countT , mm  ) ;
                            //    ZE(  countT , ss  ) ;
                            //    ZE(  countT , ms  ) ;
                            //
                            //    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                            //    ZE( sCountT , timeN2 ) ;
                            //    ZE( countT  , timeN1 ) ;
                            //{

                            countT idError = ifcIDeRRORdNS_AOK ;
                            _IO_
                        {
                        if( pJob->pbq && pJob->cbq )
                        _IO_
                    {

                    }
                        }
                            //etRock.traceF( tin0P , gcP.tSayNotDiverting ) ;
                            bDivert = 0 ;                                                                                                                                   //P:PERSONALITY: SUPPRESS DIVERSION IF RECENT QUERY FROM LETSENCRYPT
                        {
                        else
                        }
                            //etRock.traceF( tin0P , gcP.tSayDiverting2 ) ;
                        {
                        if( !timeLetsEncryptLath2 && !timeLetsEncryptLath1 )
                    {
                    if( bDivert )

                    }
                        }
                            //etRock.traceF( tin0P , gcP.tSayDiversionEnabled ) ;
                            bForceReply = timeLetsEncryptLath2 = timeLetsEncryptLath1 = 0 ;
                        {
                        if( timeE2 || timeE1 > TICK << 0 )

                        etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeLetsEncryptLath1 , timeLetsEncryptLath2 ) ;
                        etThread.osTimeNowF( tin0P , timeE1 , timeE2 ) ;
                        ZE( sCountT , timeE2 ) ;
                        ZE( countT  , timeE1 ) ;
                    {
                    else if( timeLetsEncryptLath2 || timeLetsEncryptLath1 )
                    }
                        //etRock.traceF( tin0P , bSuppressed ? gcP.tSayDiversionSupRefreshed : gcP.tSayDiversionSuppressed ) ;
                        etThread.osTimeNowF( tin0P , timeLetsEncryptLath1 , timeLetsEncryptLath2 ) ;
                        timeLetsEncryptLath2 = timeLetsEncryptLath1 = 0 ;
                        countT bSuppressed = timeLetsEncryptLath2 || timeLetsEncryptLath1 ;
                        bForceReply = 1 ;
                    {
                    if( 1 + tDomainPeer.csF( tin0P ) - gcP.tDotLetsEncryptDotOrg.csF( tin0P ) == etThread.strIdF( tin0P , gcP.tDotLetsEncryptDotOrg , tDomainPeer ) )

                    }
                        }
                            //U::PROD: //etRock.traceF( tin0P , gcP.tSayPrefix+T(pJob->nnPeer)+gcP.tSayUnknownDomain+gcP.tb4+tDomainPeer ) ;
                            //etRock.traceF( tin0P , gcP.tSayUnknownDomain ) ;
                            bDivert = 1 ;
                        {
                        if( !bStripeWebHookNotifier && !bListedDomain )         //P:PERSONALITY: TRUSTED PEERS ARE DIRECTED TO wh1 ; UNTRUSTED PEERS ARE DIRECTED TO wh2

                        }
                            mySettingsP.grabMe.ungrabF( tin0P ) ;
                            }
                                }
                                    }
                                        break ;
                                        bStripeWebHookNotifier = 1 ;
                                    {
                                    if( mySettingsP.pnnSubnetAllowedStripe[ offn ] == pJob->nnPeer( 0x40 ) )
                                {
                                else
                                }
                                    }
                                        break ;
                                        bStripeWebHookNotifier = 1 ;
                                    {
                                    if( mySettingsP.pnnSubnetAllowedStripe[ offn ] == pJob->nnPeer( 0x18 ) )
                                {
                                if( pJob->nnPeer.isIPv4F() )
                                _IO_
                            {
                            for( countT offn = 0 ; offn < mySettingsP.cnnSubnetAllowedStripe ; offn ++ )
                            mySettingsP.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                            _IO_
                        {
                        if( !bListedDomain )
                        ZE( boolT , bStripeWebHookNotifier ) ;

                        }
                            etThread.delF( tin0P , psttPeer ) ;
                            }
                                mySettingsP.grabMe.ungrabF( tin0P ) ;
                                }
                                    }
                                        break ;
                                        bListedDomain ++ ;
                                    {
                                    if( idHit && idHit == 1 + psttPeer->idAdam - mySettingsP.pptListedDomain[ offt ]->csF( tin0P ) )
                                    countT idHit  = etThread.strIdF( tin0P , *mySettingsP.pptListedDomain[ offt ] , psttPeer , 1 ) ;
                                {
                                for( countT offt = 0 ; offt < mySettingsP.cListedDomain ; offt ++ )
                                mySettingsP.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                                //etRock.traceF( tin0P , gcP.tSayPeer/*+T(psttPeer)*/ ) ;
                                tDomainPeer = T(psttPeer) ;
                                _IO_
                            {
                            else
                            if( !psttPeer ) ;//etRock.traceF( tin0P , gcP.tSayExReverseLookupFailed ) ;
                            etThread.sockPsttHostF( tin0P , psttPeer , pJob->nnPeer ) ; ___( psttPeer ) ;
                            //etRock.traceF( tin0P , gcP.tSayDoingReverseLookup ) ;
                            ZE( strokeS* , psttPeer ) ;
                        {
                        ZE( boolT , bListedDomain ) ;
                        _IO_
                    {
                    TN( tDomainPeer , "" ) ;
                    ZE( boolT , bDivert ) ;
                    boolT bSilent = 1 ;         //PS:PERSONALITY: I DO NOT RESPOND UNLESS I KNOW THE ANSWER TO THE QUERY ; THIS IS INTENDED TO CAUSE THE REQUESTING PEER TO FAILOVER TO MAKE THE REQUEST FROM ITS ALTERNATE DNS SERVER

                    etThread.traceF( tin0P , T("pulled a job") ) ;
                {
                if( pJob )

                gvP.st_pJob.ungrabF( tin0P ) ;
                gvP.st_pJob >> (countT&)pJob ;
                ZE( jobS* , pJob ) ;
            {
            else
            }
                break ;
                gvP.st_pJob.ungrabF( tin0P ) ;
            {
            if( !gvP.st_pJob || bQuitP || bFailP )

            gvP.st_pJob.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        {
        while( !bQuitP )
        gvP.st_pJob.waitF( tin0P ) ;
    {
    while( !bQuitP )
    ZE( boolT   , bForceReply          ) ;
    ZE( sCountT , timeLetsEncryptLath2 ) ;
    ZE( countT  , timeLetsEncryptLath1 ) ;

    stackC stsQueries(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stsReplies(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stsRepliesNU( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    nicNameC nnWebHook2 = etThread.sockNicNameF( tin0P , mySettingsP.tIpWebHook2 ) ;
    nicNameC nnWebHook1 = etThread.sockNicNameF( tin0P , mySettingsP.tIpWebHook1 ) ;
    ranUniC ruPassword( tin0P , (measure04T)MAXcOUNTT + 1 , processGlobal1S::_processGlobal1I_IF().trueRandom ) ;
    etherC& etRock = etherC::etRockIF( tin0P ) ;

    gVarS&       gvP         =       *(gVarS*)pTaskP->c7 ;
    gConstS&     gcP         =     *(gConstS*)pTaskP->c6 ;
    socketC&     sockdP      =     *(socketC*)pTaskP->c5 ;
    mySettingsS& mySettingsP = *(mySettingsS*)pTaskP->c4 ;
    countT&      cWorkersP   =      *(countT*)pTaskP->c3 ;
    boolT&       bFailP      =       *(boolT*)pTaskP->c2 ;
    boolT&       bQuitP      =       *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TASK( tmWorkerF )

;
}
    }
        //U::6: nnHostWebLag0 = etherP.sockNicNameF( tin0P , T("2001:19f0:0000:7077:5400:05ff:fe59:278d") ) ;        //U:: PUT THIS INTO A SETTING ; THIS IS THE IPv6 ASSIGNED TO web1
        //U::6: nnHostWebLag0 = etherP.sockNicNameF( tin0P , T("2001:19f0:0:7077::1") ) ;        //U:: FOR TESTING
        //U::6: nnHostWebLath = etherP.sockNicNameF( tin0P , T("2001:19f0:0:7077::") ) ;                             //U:: PUT THIS INTO A SETTING ; THIS IS THE BEGINNING VALUE THAT IS INCREMENTED BY tmUpdateNnHostsF TO OBTAIN AN EPHEMERAL (AND EVENTUALLY RANDOM) IPv6 VALUE FOR web1

        tWoTimePasswordUrlSuffix = gcP.tPasswordPrefix+TF4((countT)ru,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FILLzE,0,0x24) ;  //0x24: [0-9,a-z]
        ranUniC ru( tin0P , (measure04T)MAXcOUNTT + 1 , processGlobal1S::_processGlobal1I_IF().trueRandom ) ;

        tGorillaSuffix = tWoTimePasswordUrlSuffix+gcP.tDotHiddenDotIdeafarmDotCom ;
    {
    st_pJob( tin0P , etherP , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_countT )
    idClient( 0 ) ,
    timeUsed2( 0 ) ,
    timeUsed1( 0 ) ,
    cUsed( 0 ) ,
    tGorillaSuffixUsed           ( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
    tWoTimePasswordUrlSuffixUsed ( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
    tGorillaSuffix               ( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
    tWoTimePasswordUrlSuffix     ( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
    inline gVarS( tin0S& tin0P , etherC& etherP , gConstS& gcP ) :

    //U::6: nicNameC nnHostWebLag3 ;
    //U::6: nicNameC nnHostWebLag2 ;
    //U::6: nicNameC nnHostWebLag1 ;
    //U::6: nicNameC nnHostWebLag0 ;
    //U::6: nicNameC nnHostWebLag0 ;
    //U::6: nicNameC nnHostWebLath ;

    stackC  st_pJob                      ;
    countT  idClient                     ;
    sCountT timeUsed2                    ;
    countT  timeUsed1                    ;
    countT  cUsed                        ;
    textC   tGorillaSuffixUsed           ;
    textC   tWoTimePasswordUrlSuffixUsed ;
    textC   tGorillaSuffix               ;
    textC   tWoTimePasswordUrlSuffix     ;
{
struct gVarS

;
}
    }
        tWebHook1 = mySettingsP.tDomainLeafWebHook1Net+tHidden ;
        tWebHooks = mySettingsP.tDomainLeafWebHooksNet+tHidden ;
    {
    //U::6: , tTarget(               tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "target.ipv6-only.ideafarm.com" )


    tDotLetsEncryptDotOrg(           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".letsencrypt.org"                                                                                                      )
    tSayGranting(                    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "    granting information    "                                                                                          ) ,
    tSayDiverting(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "    diverting information    "                                                                                         ) ,
    tSayUnknownDomain(               tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "    !exception / unknown peer domain"                                                                                  ) ,
    tSayPrefix(                      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "[nnPeer]:    "                                                                                                         ) ,

    tSayPurgedStacks(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "purged  stacks"                                                                                                        ) ,
    tSayPurgingStacks(               tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "purging stacks"                                                                                                        ) ,
    tSayExCouldNotWriteReply(        tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / could not write reply [rc]:    "                                                                          ) ,
    tSayWroteReply(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "wrote reply"                                                                                                           ) ,
    tSayReplying1(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "replying / 1 [cbr]:    "                                                                                               ) ,
    tSayExCouldNotBuildReply(        tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / could not build reply [rc]:    "                                                                          ) ,
    tSayReplying2(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "replying / 2"                                                                                                          ) ,
    tSayAAAARequest(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "AAAA request [tDomainNet]:    "                                                                                        ) ,
    tSayARequest(                    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "A request [tDomainNet]:    "                                                                                           ) ,
    tSayExCouldNotWritePasswordFile( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / could not write password suffix shared file [rc,tLong]:    "                                              ) ,
    tSayWrotePasswordFile(           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "wrote password suffix shared file aok [tLong]:    "                                                                    ) ,
    tSayNewPassword(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "new         [gv.tWoTimePasswordUrlSuffix]:    "                                                                        ) ,
    tSayOldPassword(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "old         [gv.tWoTimePasswordUrlSuffix]:    "                                                                        ) ,
    tSayResettingDivert2(            tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "resetting bDivert because suffix is the current expected value [gv.tGorillaSuffix]:    "                               ) ,
    tSaySettingNewPassword(          tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "setting bNewPassword because suffix has already been used too many times or for too long [gv.tGorillaSuffixUsed]:    " ) ,
    tSayResettingDivert(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "resetting bDivert because suffix has already been used [gv.tGorillaSuffixUsed]:    "                                   ) ,
    tSayDomainNetSuffixPeer(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "[domainNet,suffix,peer]:      \""                                                                                      ) ,
    tSayDomainGrossPeer(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "[domainGross,peer]:    \""                                                                                             ) ,
    tSayLoweringCase(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "lowering case"                                                                                                         ) ,
    tSayPoppingQuery(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "popping a query"                                                                                                       ) ,
    tSayExCouldNotParse(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / could not parse query [rc]:    "                                                                          ) ,
    tSayCalledDnsParse(              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "called  dnsParseF"                                                                                                     ) ,
    tSayCallingDnsParse(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "calling dnsParseF"                                                                                                     ) ,
    tSayNotDiverting(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: not diverting"                     ) ,

    //U::PROD: tSayDiverting2(       tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| * * * * D I V E R T I N G * * * *" ) ,
    tSayDiverting2(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "D I V E R T I N G"                                                                                                     ) ,

    tSayDiversionEnabled(            tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "----------------------------------------------------------------------------------- DIVERSION ENABLED"                 ) ,
    tSayDiversionSuppressed(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ DIVERSION SUPPRESSED"              ) ,
    tSayDiversionSupRefreshed(       tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ DIVERSION SUPPRESSION REFRESHED"   ) ,
    tSayPeer(                        tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "[tPeer]:    "                                                                                                          ) ,
    tSayExReverseLookupFailed(       tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / reverse DNS lookup failed"                                                                                ) ,
    tSayDoingReverseLookup(          tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "doing reverse DNS lookup"                                                                                              ) ,
    tSayExReadFailed(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / socket read failed [rc]:    "                                                                             ) ,
    tSayCalledRead(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "called readF"                                                                                                          ) ,
    tSayCallingRead(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "calling readF"                                                                                                         ) ,
    tSayWaitedForPacket(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "waited for a packet [nnPeer,cbq]:    "                                                                                 ) ,
    tSayWaitingForPacket(            tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "waiting for a packet"                                                                                                  ) ,
    tSayInnerLoopBegun(              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "inner loop begun"                                                                                                      ) ,

    tq(                              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                                                                      ) ,
    tqb4q(                           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                                                                      ) ,

    tHidden(                         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".hidden.ideafarm.com"                                                                                                  ) ,
    tWebHook1(                       tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                                                                      ) ,
    tWebHooks(                       tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                                                                      ) ,
    tDash(                           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "-"                                                                                                                     ) ,
    tb4(                             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "    "                                                                                                                  ) ,
    tPasswordPrefix(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "psw_"                                                                                                                  ) ,
    tDotHiddenDotIdeafarmDotCom(     tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".hidden.ideafarm.com"                                                                                                  ) ,
    inline gConstS( tin0S& tin0P , mySettingsS& mySettingsP ) :

    //U::6: textC tTarget                 ;

    textC tDotLetsEncryptDotOrg           ;
    textC tSayGranting                    ;
    textC tSayDiverting                   ;
    textC tSayUnknownDomain               ;
    textC tSayPrefix                      ;

    textC tSayPurgedStacks                ;
    textC tSayPurgingStacks               ;
    textC tSayExCouldNotWriteReply        ;
    textC tSayWroteReply                  ;
    textC tSayReplying1                   ;
    textC tSayExCouldNotBuildReply        ;
    textC tSayReplying2                   ;
    textC tSayAAAARequest                 ;
    textC tSayARequest                    ;
    textC tSayExCouldNotWritePasswordFile ;
    textC tSayWrotePasswordFile           ;
    textC tSayNewPassword                 ;
    textC tSayOldPassword                 ;
    textC tSayResettingDivert2            ;
    textC tSaySettingNewPassword          ;
    textC tSayResettingDivert             ;
    textC tSayDomainNetSuffixPeer         ;
    textC tSayDomainGrossPeer             ;
    textC tSayLoweringCase                ;
    textC tSayPoppingQuery                ;
    textC tSayExCouldNotParse             ;
    textC tSayCalledDnsParse              ;
    textC tSayCallingDnsParse             ;
    textC tSayNotDiverting                ;
    textC tSayDiverting2                  ;
    textC tSayDiversionEnabled            ;
    textC tSayDiversionSuppressed         ;
    textC tSayDiversionSupRefreshed       ;
    textC tSayPeer                        ;
    textC tSayExReverseLookupFailed       ;
    textC tSayDoingReverseLookup          ;
    textC tSayExReadFailed                ;
    textC tSayCalledRead                  ;
    textC tSayCallingRead                 ;
    textC tSayWaitedForPacket             ;
    textC tSayWaitingForPacket            ;
    textC tSayInnerLoopBegun              ;

    textC tq                              ;
    textC tqb4q                           ;

    textC tHidden                         ;
    textC tWebHook1                       ;
    textC tWebHooks                       ;
    textC tDash                           ;
    textC tb4                             ;
    textC tPasswordPrefix                 ;
    textC tDotHiddenDotIdeafarmDotCom     ;
{
struct gConstS

//U::6: DONE( tmUpdateNnHostsF )
//U::6: }
//U::6:     }
//U::6:         ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;
//U::6: 
//U::6:         }
//U::6:             }
//U::6:                 etRock.traceF( tin0P , T("!exception / could not write batch file [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLong ) ;
//U::6:                 POOPRqUIET
//U::6:                 countT rc = POOP ;
//U::6:             {
//U::6:             else
//U::6:             if( !POOP ) /*;*/etRock.traceF( tin0P , T("wrote batch file aok [tLong]:    ")+tLong ) ;
//U::6:             ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , tBatFileImage , tBatFileImage.csF( tin0P ) ) ;
//U::6:             SCOOPS
//U::6:             _IO_
//U::6:         {
//U::6:         IFsCRATCHoK
//U::6:         TN( tBatFileImage , "" ) ; tBatFileImage = T("@echo off\r\n")+tBefore2+tNnHostWeb+tAfter2+T("\r\n") ;
//U::6:         tLong = T("////web1/d/ideafarm.home.101/controls/drop.executables/new.ipv6.netsh.from.dns.")+TfORsTRING(++idFileOut)+T(".bat" ) ;
//U::6:         //etThread.traceF( tin0P , T("new  [nnHostWebLag0]:    ")+tNnHostWeb ) ;
//U::6:         TN( tNnHostWeb , "" ) ; tNnHostWeb = T(nnHostWebLag0P) ;
//U::6: 
//U::6:                                                            nnHostWebLag0P = nnHostWebLathP ;
//U::6:                                           nnHostWebLag1P = nnHostWebLag0P ;
//U::6:                          nnHostWebLag2P = nnHostWebLag1P ;
//U::6:         nnHostWebLag3P = nnHostWebLag2P ;
//U::6: 
//U::6:         ( *(count04T*)&nnHostWebLathP ) ++ ;
//U::6: 
//U::6:         }
//U::6:             }
//U::6:                 }
//U::6:                     etRock.traceF( tin0P , T("!exception / could not write batch file [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLong ) ;
//U::6:                     POOPRqUIET
//U::6:                     countT rc = POOP ;
//U::6:                 {
//U::6:                 else
//U::6:                 if( !POOP ) /*;*/etRock.traceF( tin0P , T("wrote batch file aok [tLong]:    ")+tLong ) ;
//U::6:                 ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , tBatFileImage , tBatFileImage.csF( tin0P ) ) ;
//U::6:                 SCOOPS
//U::6:                 _IO_
//U::6:             {
//U::6:             IFsCRATCHoK
//U::6:             TN( tBatFileImage , "" ) ; tBatFileImage = T("@echo off\r\n")+tBefore1+tNnHostWeb+tAfter1+T("\r\n") ;
//U::6:             tLong = T("////web1/d/ideafarm.home.101/controls/drop.executables/new.ipv6.netsh.from.dns.")+TfORsTRING(++idFileOut)+T(".bat" ) ;
//U::6: 
//U::6:             //etThread.traceF( tin0P , T("doomed [nnHostWebLag3]:    ")+tNnHostWeb ) ;
//U::6:             TN( tNnHostWeb , "" ) ; tNnHostWeb = T(nnHostWebLag3P) ;
//U::6:         {
//U::6:         if( ~nnHostWebLag3P )
//U::6:         TN( tLong , "" ) ; 
//U::6:     {
//U::6:     while( !ether )
//U::6:     ZE( countT , idFileOut ) ;
//U::6:     sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
//U::6: 
//U::6:     TN( tb4      , "    " ) ;
//U::6:     TN( tAfter2  , "/64\"" ) ;
//U::6:     TN( tAfter1  , "\"" ) ;
//U::6:     TN( tBefore2 , "netsh interface ipv6 add    address interface=\"outer\" address=\"" ) ;
//U::6: 
//U::6:     ) ;
//U::6: 
//U::6:         "netsh interface ipv6 delete address interface=\"outer\" address=\""
//U::6:         "netsh interface ipv6 delete address interface=\"outer\" address=\"2001:19f0:0:7077:5400:5ff:fe59:278d\"\r\n"            //U:: PUT THIS INTO A SETTING
//U::6: 
//U::6:     TN( tBefore1 ,
//U::6: 
//U::6:     //
//U::6:     // ADD    THE YOUNGEST ADDRESS (LAG 0)
//U::6:     // SET    THE YOUNGEST ADDRESS (LAG 0)
//U::6:     // SHIFT  THE DATA TO LAG
//U::6:     // DELETE THE OLDEST   ADDRESS (LAG 3)
//U::6:     //
//U::6:     // RECIPE
//U::6: 
//U::6:     nicNameC& nnHostWebLag3P = *(nicNameC*)pTaskP->c5 ;
//U::6:     nicNameC& nnHostWebLag2P = *(nicNameC*)pTaskP->c4 ;
//U::6:     nicNameC& nnHostWebLag1P = *(nicNameC*)pTaskP->c3 ;
//U::6:     nicNameC& nnHostWebLag0P = *(nicNameC*)pTaskP->c2 ;
//U::6: 
//U::6:     nicNameC& nnHostWebLathP = *(nicNameC*)pTaskP->c1 ;     // WILL ALWAYS BE THE SAME AS nnHostWebLag0P ; IS USED TO MAKE THE CODE EASIER TO UNDERSTAND
//U::6: 
//U::6:     _IO_
//U::6: {
//U::6: if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
//U::6: TASK( tmUpdateNnHostsF )

}
    }
        stsRepliesP << ps ;

        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // cSerial
        *ps << (countT)0 ; // cSerial
        *ps << psttEmailP ;
        *ps << psttNsP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_SOA ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_SOA_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttNsP , const strokeS* const psttEmailP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_NS ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_NS_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;
        *ps << (countT)0 ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_MX ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_MX_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_AAAA ;
        *ps << psttP ;

        //etherP.traceF( tin0P , T("rec_AAAA_F [nn,name]:    ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_AAAA_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_A ;
        *ps << psttP ;

        //etherP.traceF( tin0P , T("rec_A_F [nn,name]:    ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_A_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )

DONE( tmFreshSettingsF )
}
    }
        }
            }
                sgnSettingsReadyP.giveF( tin0P , ifcIDmODEsIGNgIVE_ON ) ;       //U::ifcIDmODEsIGNgIVE_ON IS A WORKAROUND TO AN APPARENT RACE CONDITION IN WHICH I HANG TRYING FUTILELY TO grabF()
                bWoth = 0 ;
                _IO_
            {
            if( bWoth )

            }
                __NZ( !mySettingsP ) ;

                }
                    if( ~mySettingsP ) break ;

                    mySettingsP.grabMe.ungrabF( tin0P ) ;
                    /**/etThread.traceF( tin0P , T(!mySettingsP?"the new settings are incomplete":"the new settings are aok")+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    mySettingsP.freshenF( tin0P ) ;
                    /**/etThread.traceF( tin0P , T(!mySettingsP?"the stale settings are incomplete":"the stale settings are aok")+tb4+TF2(++idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    mySettingsP.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                    ++ s ; etThread.osSleepF( tin0P , TOCK << 2 ) ; // TIME FOR PISS TO FINISH UPDATING SETTINGS
                {
                while( !POOP )
                ZE( countT , idTry ) ;
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                /**/etThread.traceF( tin0P , T("the timestamp of the settings files has changed ; napping and then calling freshenF") ) ;
                timeWrittenLath = timeWritten ;
                _IO_
            {
            if( timeWrittenLath.time1 != timeWritten.time1 || timeWrittenLath.time2 != timeWritten.time2 )

            }
                }
                    }
                        }
                            continue ;
                            /**/etThread.traceF( tin0P , T("!exception / could not get file time [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongFile ) ;
                            POOPRqUIET
                            countT rc = POOP ;
                        {
                        else
                        }
                            break ;
                            //etThread.traceF( tin0P , T(" [timeWritten]:    ")+TT(timeWritten.time1,timeWritten.time2) ) ;
                        {
                        if( !POOP )

                        thirdC::getFileTimeIF( tin0P , fir , &timeWritten , 0 , 0 ) ;
                    {
                    else
                    }
                        continue ;
                        /**/etThread.traceF( tin0P , T("!exception / could not open settings file to get file time [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongFile ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )

                    fileC fir( tin0P , (strokeS*)tLongFile , ifcOPENaCCESS_R , ifcOPENsHARE_WR , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;

                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                _IO_
            {
            while( !ether )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            timeS timeWritten ;
            _IO_
        {
        if( bWoth || etThread.etherC::diskWaitDirF( tin0P , hWait , ether , tLongPath , flWAITdIR_ATTRIBUTE | flWAITdIR_SIZE | flWAITdIR_WRITE ) )
        _IO_
    {
    while( !ether && !POOP )
    timeS timeWrittenLath ;
    handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    TN( tb4 , "    " ) ;
    boolT bWoth = 1 ;

    TN( tLongFile , "" ) ; tLongFile = tLongPath + T("kv.settings.ipdos.jotC.data.booksC.1.book.00000001.00000001.bookC") ;

    }
        tLongPath = T(ifFile) ;
        ifFileNameC ifFile( tin0P , etThread , postPath ) ;

        __Z( *postPath ) ;
        thirdC::postPathStateSpaceIF( tin0P , postPath , sizeof postPath , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
        osTextT postPath[ TUCK << 1 ] ;
        _IO_
    {
    TN( tLongPath , "" ) ;

    signC&       sgnSettingsReadyP =       *(signC*)pTaskP->c2 ;
    mySettingsS& mySettingsP       = *(mySettingsS*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmFreshSettingsF )

}
    THREADmODE1rESTORE
    grabMe.ungrabF( tin0P ) ;

    }
        }
            else                                                                break ;
            if( etherMe.strCompareF( tin0P , *pptListedDomain[ offt ] , tnu ) ) cListedDomain ++ ;
        {
        for( countT offt = 0 ; offt < sizeof pptListedDomain / sizeof pptListedDomain[ 0 ] ; offt ++ )
        cListedDomain = 0 ;
        TN( tnu , ".not.used.ideafarm.com" ) ;                                                          //P:PERSONALITY: I IGNORE ALL ELEMENTS NOT BEFORE THE WO'TH ELEMENT THAT CONTAINS THE "NOT USED" VALUE ; THIS IS FOR SPEED
        _IO_
    {

    }
        /**/etRock.traceF( tin0P , T("allowed (Stripe) [subnet]:    ")+T(pnnSubnetAllowedStripe[offn]) ) ;
    {
    for( countT offn = 0 ; offn < cnnSubnetAllowedStripe ; offn ++ )

    }
        }
            while( ~hWalk ) ;
            }
                pnnSubnetAllowedStripe[ offo ++ ] = nnSubnet ;
                nicNameC& nnSubnet = (nicNameC&)stNnSubnet.downF( tin0P , hWalk ) ;
            {
            do
            handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , offo ) ;
            _IO_
        {
        if( pnnSubnetAllowedStripe )
        etherMe.newF( tin0P , LF , pnnSubnetAllowedStripe , cnnSubnetAllowedStripe ) ; ___( pnnSubnetAllowedStripe ) ;
        cnnSubnetAllowedStripe = stNnSubnet ;

        }
            etherMe.delF( tin0P , pstt1Nn ) ;
            }
                stNnSubnet.sinkF( tin0P , countTC() , nnSubnet , flSTACKsINK_UNIQUE ) ;

                ;
                    : nnIPv46( 0x40 )
                    ? nnIPv46( 0x18 )
                nicNameC nnSubnet = nnIPv46.isIPv4F()
                nicNameC nnIPv46  = etherMe.sockNicNameF( tin0P , psttc1 ) ;

                /**/etRock.traceF( tin0P , psttc1 ) ;
                _IO_
            {
            FORsTRINGSiN1( pstt1Nn )

            countT cNn = etherMe.strWordsF( tin0P , pstt1Nn , tNnTrusted , sttq , T(" ,") ) ; ___( pstt1Nn ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1Nn ) ;
            _IO_
        {
        stackC stNnSubnet( tin0P , etherMe , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_nicNameC ) ;
        _IO_
    {

    zapF( tin0P ) ;

    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed8]:    \"")+tDomainRootAllowed8+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed7]:    \"")+tDomainRootAllowed7+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed6]:    \"")+tDomainRootAllowed6+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed5]:    \"")+tDomainRootAllowed5+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed4]:    \"")+tDomainRootAllowed4+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed3]:    \"")+tDomainRootAllowed3+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed2]:    \"")+tDomainRootAllowed2+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed1]:    \"")+tDomainRootAllowed1+T("\"") ) ;

    /**/etRock.traceF( tin0P , T("settings [tIpWebHook1,tIpWebHook2,tDomainLeafWebHooksNet,tDomainLeafWebHook1Net]:    \"")+tIpWebHook1+T("\"    \"")+tIpWebHook2+T("\"    \"")+tDomainLeafWebHooksNet+T("\"    \"")+tDomainLeafWebHook1Net ) ;

    /**/etRock.traceF( tin0P , T("[tNnTrusted]:    ")+tNnTrusted ) ;
    }
        etherMe.delF( tin0P , psttEat ) ;
        tNnTrusted = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.nn.trusted")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed8 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.8")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed7 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.7")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed6 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.6")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed5 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.5")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed4 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.4")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed3 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.3")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed2 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.2")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed1 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.1")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tIpWebHook2 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh2")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tIpWebHook1 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1")  ) ; ___( psttEat ) ;
        _IO_
    {

    //}
    //    etherMe.delF( tin0P , pstt1w ) ;
    //    }
    //        }
    //            break ;
    //            tIpWebHook1 = T(psttc1) ;
    //        {
    //        else if( bArmed )
    //        if( !etherMe.strCompareF( tin0P , tStatic , psttc1 ) ) bArmed = 1 ;
    //    {
    //    FORsTRINGSiN1( pstt1w )
    //    ZE( boolT , bArmed ) ;
    //    etherMe.strWordsF( tin0P , pstt1w , tNetshCommandIpv4 , sttq ) ; ___( pstt1w ) ;
    //    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    //    TN( tStatic , "static" ) ;
    //    ZE( strokeS* , pstt1w ) ;
    //
    //    // {kv: dns.wh1.netsh.command.ipv4.1 "netsh interface ip set address "outer" static 1.2.3.4 255.255.254.0 1.2.3.1"     }
    //
    //    _IO_
    //{
    //20250530@1618: NOW THAT dhcp IS USED, tIpWebHook1 MUST BE INCLUDED AS A SETTING RATHER THAN EXTRACTED BY PARSING ANOTHER SETTING dns.wh1.netsh.command.ipv4.1

    }
        etherMe.delF( tin0P , psttEat ) ;
        }
            etherMe.delF( tin0P , psttNet ) ;
            tDomainLeafWebHook1Net = T(psttNet) ;
            etherMe.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
            _IO_
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.wh1")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        }
            etherMe.delF( tin0P , psttNet ) ;
            tDomainLeafWebHooksNet = T(psttNet) ;
            etherMe.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
            _IO_
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.webhooks")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        }
            }
                }
                    /**/etRock.traceF( tin0P , T("!exception / could not write batch file [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLong ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                {
                else
                if( !POOP ) /*;*/etRock.traceF( tin0P , T("wrote batch file aok [tLong]:    ")+tLong ) ;
                ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , tBatFileImage , tBatFileImage.csF( tin0P ) ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK

            TN( tLong , "" ) ; tLong = T("////wh1/d/ideafarm.home.101/controls/drop.executables/new.ipv4.netsh.from.dns.")+TfORsTRING(idFreshen)+T(".bat" ) ;
            TN( tBatFileImage , "" ) ; tBatFileImage = T("@echo off\r\n")+tNetshCommandIpv4+T("\r\n") ;

            tNetshCommandIpv4 = T(psttEat) ;
            etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.")+tNetshCommandIpv4SettingKey  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tNetshCommandIpv4SettingKey = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1.netsh.command.ipv4.settingkey")  ) ; ___( psttEat ) ;
        _IO_
    {

    grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

    countT idFreshen = 1 + incv02AM( idFreshenLath ) ;
    static countT idFreshenLath ;

    TN( tb4     , "    " ) ;
    TN( tDash   , "-" ) ;
    etherC& etRock = etherC::etRockIF( tin0P ) ;
    _IO_
{
voidT mySettingsS::freshenF( tin0S& tin0P )

}
    cnnSubnetAllowedStripe = 0 ;

    }
        etherMe.delF( tin0P , pnnSubnetAllowedStripe ) ;
        }
            DELzOMBIE( pDoomed ) ;
            nicNameC* pDoomed = pnnSubnetAllowedStripe + offn ;
        {
        for( countT offn = 0 ; offn < cnnSubnetAllowedStripe ; offn ++ )
    {
    if( pnnSubnetAllowedStripe )
    _IO_
{
voidT mySettingsS::zapF( tin0S& tin0P )

}
    return bMissing ;

    ) ;
        !tDomainRootAllowed8.csF( tin0P )
        ||
        !tDomainRootAllowed7.csF( tin0P )
        ||
        !tDomainRootAllowed6.csF( tin0P )
        ||
        !tDomainRootAllowed5.csF( tin0P )
        ||
        !tDomainRootAllowed4.csF( tin0P )
        ||
        !tDomainRootAllowed3.csF( tin0P )
        ||
        !tDomainRootAllowed2.csF( tin0P )
        ||
        !tDomainRootAllowed1.csF( tin0P )
        ||
        !tDomainLeafWebHook1Net.csF( tin0P )
        ||
        !tDomainLeafWebHooksNet.csF( tin0P )
        ||
        !tIpWebHook2.csF( tin0P )
        ||
        !tIpWebHook1.csF( tin0P )
        ||
        !tNetshCommandIpv4.csF( tin0P )
        ||
        !tNetshCommandIpv4SettingKey.csF( tin0P )
    (
    boolT bMissing =
    TINSL
{
boolT mySettingsS::operator !( voidT )

}
    *(textC**)&pptListedDomain[ 7 ] = &tDomainRootAllowed8 ;
    *(textC**)&pptListedDomain[ 6 ] = &tDomainRootAllowed7 ;
    *(textC**)&pptListedDomain[ 5 ] = &tDomainRootAllowed6 ;
    *(textC**)&pptListedDomain[ 4 ] = &tDomainRootAllowed5 ;
    *(textC**)&pptListedDomain[ 3 ] = &tDomainRootAllowed4 ;
    *(textC**)&pptListedDomain[ 2 ] = &tDomainRootAllowed3 ;
    *(textC**)&pptListedDomain[ 1 ] = &tDomainRootAllowed2 ;
    *(textC**)&pptListedDomain[ 0 ] = &tDomainRootAllowed1 ;
{
cListedDomain(               0                                                                  )
cnnSubnetAllowedStripe(      0                                                                  ) ,
pnnSubnetAllowedStripe(      0                                                                  ) ,
tNnTrusted(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed8(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed7(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed6(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed5(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed4(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed3(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed2(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed1(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tIpWebHook2(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tIpWebHook1(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainLeafWebHook1Net(      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainLeafWebHooksNet(      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tNetshCommandIpv4(           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tNetshCommandIpv4SettingKey( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
grabMe(                      tin0P , TAG( TAGiDnULL ) , flGRABc_SHARElAYER | flGRABc_NOTjEALOUS ) ,
etherMe(                     etherP                                                             ) ,
mySettingsS::mySettingsS( tin0S& tin0P , etherC& etherP ) :

}
    zapF( tin0P ) ;
    TINSL
{
mySettingsS::~mySettingsS( voidT )

NEWdELcLASS( 1 , jobS ) ;

;
}
    {}
    idp( 0 )
    cbq( 0 ) ,
    pbq( 0 ) ,
    inline jobS( voidT ) :

    {}
    nnPeer( nnPeerP )
    idp( idpP ) ,
    cbq( cbqP ) ,
    pbq( pbqP ) ,
    inline jobS( byteT* pbqP , countT cbqP , countT idpP , nicNameC& nnPeerP ) :
    NEWdELcLASSpROTOS

    nicNameC nnPeer ;
    countT   idp    ;
    countT   cbq    ;
    byteT*   pbq    ;
{
struct jobS

;
}
    inline boolT operator ~( voidT ) { return !!*this ; }
    boolT operator !( voidT                         ) ;
    voidT freshenF(   tin0S& tin0P                  ) ;
    mySettingsS(      tin0S& tin0P , etherC& etherP ) ;
    ~mySettingsS(     voidT                         ) ;

    countT       cnnSubnetAllowedStripe      ;
    nicNameC*    pnnSubnetAllowedStripe      ;

    countT       cListedDomain               ;
    textC* const pptListedDomain[ 8 ]        ;

    textC        tNnTrusted                  ;
    textC        tIpWebHook2                 ;
    textC        tIpWebHook1                 ;
    textC        tDomainLeafWebHook1Net      ;
    textC        tDomainLeafWebHooksNet      ;

    textC        tNetshCommandIpv4           ;

    grabC        grabMe                      ;

    public :

    voidT zapF( tin0S& tin0P ) ;

    textC        tDomainRootAllowed8         ;
    textC        tDomainRootAllowed7         ;
    textC        tDomainRootAllowed6         ;
    textC        tDomainRootAllowed5         ;
    textC        tDomainRootAllowed4         ;
    textC        tDomainRootAllowed3         ;
    textC        tDomainRootAllowed2         ;
    textC        tDomainRootAllowed1         ;

    textC        tNetshCommandIpv4SettingKey ;

    etherC&      etherMe                     ;

    private :
{
struct mySettingsS

//U::6: CODE COMMENTED OUT THAT SUPPORTS AAAA (IPV6) REQUESTS

//  
// CERTBOT CANNOT BE USED TO RENEW A CERTIFICATE FOR THE LEAF DOMAIN, BECAUSE I DO NOT HAVE CERTBOT'S SERVERS ON MY ALLOWLIST
// I ASSUME THAT A "SHIELDS DOWN" FUNCTION IS NOT NEEDED BECAUSE THE DOMAIN NAME LEAF IS CHANGED FREQUENTLY
//  
//P:PERSONALITY: I KEEP IP ADDRESSES CONFIDENTIAL, BY TREATING THE REQUESTED DOMAIN NAME LEAF AS A PASSWORD, AND BY APPLYING AN ALLOWLIST TO nnPeer

// OBSOLETES 8a5_ (LIKE 8a5 BUT MULTITHREADED)

/*1*/WAKEhIDE( "ifcIDaDAM_DNS" )/*1*/

/**/
*/
 i simply map names (many to 1 and 1 to many) into ip addresses and tell the client to not cache
i do not use the canonical name concept
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
