
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        }
            DELzOMBIE( psoDoomed ) ;
            socketC* psoDoomed = (socketC*)pbSocket ;
        {

        }
            }
                ++ s ; etThread.osSleepF( tin0P , TOCK >> 3 ) ;
                etRock.traceF( tin0P , T("waiting for all workers to go away [cIn,cWorkers]:    ")+TF2(++cIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+gc.tb4+TF2(cWorkers,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            while( cWorkers )
            ZE( countT , cIn ) ;
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            gv.bQuit ++ ;

            }
                //etRock.traceF( tin0P , gc.tSayPushedJob+TF2(gv.cirJob,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                gv.cirJob << &job ;
                //etRock.traceF( tin0P , gc.tSayPushingJob+TF2(gv.cirJob,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                jobS job( pbq , cbq , idp , nnPeer ) ;

                //etRock.traceF( tin0P , gc.tSayWaitedForPacket/*+T(nnPeer)+gc.tb4+TF2(cbq,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)*/ ) ;
                }
                    }
                        break ;
                        ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                        etRock.traceF( tin0P , gc.tSayExReadFailed+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )
                    //etRock.traceF( tin0P , gc.tSayCalledRead ) ;
                    sockd.readF( tin0P , pbq , cbq , idp , nnPeer ) ; ___( pbq ) ;
                    //etRock.traceF( tin0P , gc.tSayCallingRead ) ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                //etRock.traceF( tin0P , gc.tSayWaitingForPacket ) ;
                nicNameC nnPeer ;
                ZE( countT , idp ) ;
                ZE( countT , cbq ) ;
                ZE( byteT* , pbq ) ;

                //etRock.traceF( tin0P , gc.tSayInnerLoopBegun ) ;
                _IO_
            {
            while( !POOP && !ether )

            }
                etThread.osThreadF( TaRG2cBsTACK( tmWorkerF , CBsTACKmIN << 2 ) , (countT)&bFail , (countT)&cWorkers , (countT)&cirNnPeerDoNotDivert , (countT)&cirRecentDomainGrossTrace , (countT)&mySettings , (countT)&sockd , (countT)&gc , (countT)&gv , (countT)&grab_tSuffix1Gorilla , (countT)&tSuffix1Gorilla , (countT)&grab_tSuffix2Gorilla , (countT)&tSuffix2Gorilla ) ;
                inc02AM( cWorkers ) ;
            {
            while( cDo -- )
            countT cDo = thirdC::osProcessorsIF( tin0P ) << 3 ;

            circleC cirRecentDomainGrossTrace( tin0P , etThread , gv.bQuit , flCIRCLEc_OVERWRITE , sizeof( strokeS* ) , TUCK >> 5 , deleteElementF ) ;
            circleC cirNnPeerDoNotDivert(      tin0P , etThread , gv.bQuit , flCIRCLEc_OVERWRITE , sizeof( nicNameC ) , TUCK >> 2 ) ;
        {

        ZE( boolT  , bFail    ) ;
        ZE( countT , cWorkers ) ;

        }
            }
                continue ;
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                etRock.traceF( tin0P , T("!exception / could not bind socket to the dns port [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )
            sockd.bindF( tin0P , ifcPORToLD2_DNS ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK

        }
            }
                continue ;
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                etRock.traceF( tin0P , T("!exception / could not construct socket [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )

            new( 0 , tin0P , pbSocket , sizeof pbSocket ) socketC( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        socketC& sockd = *(socketC*)pbSocket ;
        byteT pbSocket[ sizeof( socketC ) ] ;

        //etRock.traceF( tin0P , T("outer loop begun") ) ;
        _IO_
    {
    while( !POOP && !ether )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    //U::6: etThread.osThreadF( TaRG2cBsTACK( tmUpdateNnHostsF , CBsTACKmIN << 1 ) , (countT)&gv.nnHostWebLath , (countT)&gv.nnHostWebLag0 , (countT)&gv.nnHostWebLag1 , (countT)&gv.nnHostWebLag2 , (countT)&gv.nnHostWebLag3 ) ;

    mySettings.grabMe.ungrabF( tin0P ) ;

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                   *******************************************************************************************************************************************************************************************************************************************************************************************
    //*****  PREPARE TO WORK  *******************************************************************************************************************************************************************************************************************************************************************************************
    //*****                   *******************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************


    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                                   ***************************************************************************************************************************************************************************************************************************************************************************
    //*****  LOCAL VARIABLES (MASTER THREAD)  ***************************************************************************************************************************************************************************************************************************************************************************
    //*****                                   ***************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                                              ****************************************************************************************************************************************************************************************************************************************************************
    //*****  LOCAL VARIABLES (INSTANCE FOR EACH WORKER)  ****************************************************************************************************************************************************************************************************************************************************************
    //*****                                              ****************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    gVarS gv( tin0P , etThread , gc ) ;

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                                            ******************************************************************************************************************************************************************************************************************************************************************
    //*****  GLOBAL VARIABLES (SHARED BY ALL WORKERS)  ******************************************************************************************************************************************************************************************************************************************************************
    //*****                                            ******************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    gConstS gc( tin0P , mySettings ) ;

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                                            ******************************************************************************************************************************************************************************************************************************************************************
    //*****  GLOBAL CONSTANTS (SHARED BY ALL WORKERS)  ******************************************************************************************************************************************************************************************************************************************************************
    //*****                                            ******************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    }
        __1 ;
        etRock.traceF( tin0P , T("!exception / a required setting is missing") ) ;
        mySettings.grabMe.ungrabF( tin0P ) ;
        _IO_
    {
    if( !mySettings )
    mySettings.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

    etThread.osThreadF( TaRG2cBsTACK( tmCatchF , CBsTACKmIN << 1 ) , (countT)&grab_tSuffix1Gorilla , (countT)&tSuffix1Gorilla , (countT)&grab_tSuffix2Gorilla , (countT)&tSuffix2Gorilla ) ;
    TN( tSuffix2Gorilla , "" ) ;
    grabC grab_tSuffix2Gorilla( tin0P , TAG( TAGiDnULL ) ) ;
    TN( tSuffix1Gorilla , "" ) ;
    grabC grab_tSuffix1Gorilla( tin0P , TAG( TAGiDnULL ) ) ;

    //etRock.traceF( tin0P , T("the settings are ready") ) ;
    sgnSettingsReady.waitF( tin0P ) ;
    etThread.osThreadF( TaRG2cBsTACK( tmFreshSettingsF , CBsTACKmIN << 1 ) , (countT)&mySettings , (countT)&sgnSettingsReady ) ;

    mySettingsS mySettings( tin0P , etThread ) ;
    signC       sgnSettingsReady( tin0P , TAG( TAGiDnULL ) ) ;

    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*****                **********************************************************************************************************************************************************************************************************************************************************************************************
    //*****  GET SETTINGS  **********************************************************************************************************************************************************************************************************************************************************************************************
    //*****                **********************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************
    //*******************************************************************************************************************************************************************************************************************************************************************************************************************

    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIEST ) ; // RUDE WOULD BE AN ATTACK SURFACE
    thirdC::dosPriorityProcessIF(      tin0P , ifcTHREADpRIORITY_RUDE    ) ; // THIS IS SO PASSWORD (WEBHOOK SUFFIX) UPDATES ARE NOTICED TIMELY

    _IO_
{
if( pTaskP )
TASK( tmWorkF )


DONE( tmWorkerF )
}
    dec02AM( cWorkersP ) ;

    }
        }
            IFsCRATCHoK{}

            etThread.delF( tin0P , job.pbq ) ;
            }
                }
                    }
                        etThread.delF( tin0P , pbr ) ;
                        }
                            }
                                }
                                    etRock.traceF( tin0P , gcP.tSayExCouldNotWriteReply+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    POOPRqUIET
                                    countT rc = POOP ;
                                {
                                else
                                if( !POOP ) ; //etRock.traceF( tin0P , gcP.tSayWroteReply ) ;
                                sockdP.writeF( tin0P , job.idp , job.nnPeer , pbr , cbr ) ;
                                //etRock.traceF( tin0P , gcP.tSayReplying1/*+TF2(cbr,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)*/ ) ;
                                _IO_
                            {
                            else
                            }
                                etRock.traceF( tin0P , gcP.tSayExCouldNotBuildReply+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                POOPRqUIET
                                countT rc = POOP ;
                                _IO_
                            {
                            if( POOP )
                            ((tin1S&)tin0P).pEtScratch->dnsReplyF( tin0P , pbr , cbr , job.pbq , stsReplies , 1 , idError ) ;
                            SCOOPS
                            _IO_
                        {
                        IFsCRATCHoK
                        ZE( countT , cbr ) ;
                        ZE( byteT* , pbr ) ;

                        //else                          /*;*/etRock.traceF( tin0P , T("replying [error]:    ")+TF2(idError,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //if( postError && *postError ) /*;*/etRock.traceF( tin0P , T("replying [error]:    ")+T(postError)                                          ) ;
                        const osTextT* postError = processGlobal4S::_processGlobal4I_IF().mapIdErrorDns( idError ) ;

                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                        //****         ***************************************************************************************************************************************************************************************************************************************************************************************
                        //****  REPLY  ***************************************************************************************************************************************************************************************************************************************************************************************
                        //****         ***************************************************************************************************************************************************************************************************************************************************************************************
                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                    {
                    if( !bSilent || bForceReply )

                    }
                        }
                            }
                                if( !stsReplies ) idError = ifcIDeRRORdNS_NAMEnOTdEFINED ;

                                }
                                    DEL( ps ) ;
                                    }
                                        if( !bSilent || bForceReply ) ;//etRock.traceF( tin0P , gcP.tSayReplying2+tDomainGross ) ;

                                        }
                                            //}
                                            //    break ;
                                            //
                                            //    }
                                            //        rec_AAAA_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut , job.nnPeer ) ;
                                            //        bSilent = 0 ;
                                            //    {
                                            //    if( ~nnOut )
                                            //
                                            //           if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gcP.tTarget      ) ) nnOut = gvP.nnHostWebLag0 ;
                                            //    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gcP.tWebHook1    ) ) nnOut = nnWebHook1    ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                            //    //     if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gcP.tWebHooks    ) ) nnOut = nnWebHook1    ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...
                                            //
                                            //    //etRock.traceF( tin0P , T("U:: debug    [gcP.tTarget]:    \"")+gcP.tTarget+T("\"") ) ;
                                            //    //etRock.traceF( tin0P , T("U:: debug [tDomainNet]:    \"")+tDomainNet+T("\"") ) ;
                                            //
                                            //    nicNameC nnOut ;
                                            //    //etRock.traceF( tin0P , gcP.tSayAAAARequest/*+tDomainNet*/ ) ;
                                            //    _IO_
                                            //{
                                            //case ifcIDtYPEdNSqUERY_AAAA :
                                            }
                                                break ;

                                                }
                                                    rec_A_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut , job.nnPeer ) ;
                                                    bSilent = 0 ;
                                                {
                                                if( ~nnOut )

                                                }
                                                    else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gcP.tWebHook1    ) ) nnOut = nnWebHook1 ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                                         if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gcP.tWebHooks    ) ) nnOut = nnWebHook1 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...
                                                {
                                                else
                                                }
                                                         if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , gcP.tWebHooks    ) ) nnOut = nnWebHook2 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...
                                                {
                                                if( bDivert )

                                                nicNameC nnOut ;
                                                //etRock.traceF( tin0P , gcP.tSayARequest/*+tDomainNet*/ ) ;
                                                _IO_
                                            {
                                            case ifcIDtYPEdNSqUERY_A :
                                            }
                                                break ;
                                            {
                                            case ifcIDtYPEdNSqUERY_CAA :
                                        {
                                        if( !bSilent && idClass == 1 ) switch( idType )

                                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        //****                                          ******************************************************************************************************************************************************************************************************************************************************
                                        //****  BUILD REPLY IF DOMAIN NAME IS EXPECTED  ******************************************************************************************************************************************************************************************************************************************************
                                        //****                                          ******************************************************************************************************************************************************************************************************************************************************
                                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        //****************************************************************************************************************************************************************************************************************************************************************************************************

                                        *ps >> idClass ;
                                        ZE( countT , idClass ) ;

                                        *ps >> idType ;
                                        ZE( countT , idType ) ;

                                        etThread.delF( tin0P , psttw ) ;
                                        TN( tDomainNet , psttw ) ;
                                        }
                                            else if( bStripe   )                 bSilent = 0 ;      // PEER MIGHT OR MIGHT NOT REALLY BE STRIPE, SO bDivert WILL DEPEND UPON WHETHER nnPeer IS ON THE TRUSTED LIST
                                            else if( bGorilla2 ) { bDivert = 1 ; bSilent = 0 ; }
                                                 if( bGorilla1 ) { bDivert =     bSilent = 0 ; }

                                            etThread.delF( tin0P , psttSuffix ) ;
                                            }
                                                //etRock.traceF( tin0P , gcP.tSayDomainNetSuffixPeer+T(bGorilla1||bStripe?"           domainnet: \"":"REJECTED   domainnet: \"")+tDomainNet+T("\"   actual: \"")+T(psttSuffix)+T("\"   valid: \"")+tSuffix1Gorilla+T("\"   stripe: \"")+mySettingsP.tSuffixUsedByStripe+T("\"   peer: \"")+tDomainPeer+T("\"") ) ;

                                                if( !bGorilla1 && !bGorilla2 ) bStripe = !etThread.strCompareF( tin0P , psttSuffix , mySettingsP.tSuffixUsedByStripe  ) ;

                                                }
                                                    grab_tSuffix2GorillaP.ungrabF( tin0P ) ;
                                                    bGorilla2 = !etThread.strCompareF( tin0P , psttSuffix , tSuffix2GorillaP ) ;
                                                    grab_tSuffix2GorillaP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                {
                                                if( !bGorilla1 )

                                                grab_tSuffix1GorillaP.ungrabF( tin0P ) ;
                                                bGorilla1 = !etThread.strCompareF( tin0P , psttSuffix , tSuffix1GorillaP ) ;
                                                grab_tSuffix1GorillaP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                            {
                                            if( psttSuffix )
                                            ZE( boolT , bGorilla2 ) ;
                                            ZE( boolT , bGorilla1 ) ;
                                            ZE( boolT , bStripe   ) ;

                                            etThread.strMakeF( tin0P , LF , psttw , tDomainNet ) ; ___( psttw ) ;
                                            etThread.delF( tin0P , psttNet ) ;
                                            TN( tDomainNet , "" ) ; tDomainNet = T(psttNet)+T(".hidden.ideafarm.com") ;

                                            etThread.delF( tin0P , psttw ) ;
                                            etThread.strSubstringF( tin0P , psttSuffix , idf , sttq , gcP.tDot  , psttw , 0 , 0 ) ; ___( psttSuffix ) ;
                                            etThread.strSubstringF( tin0P , psttNet    , idf , sttq , gcP.tDash , psttw , 0 , 0 ) ; ___( psttNet    ) ;
                                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                            countT idf = 1 ;
                                            ZE( strokeS* , psttSuffix ) ;
                                            ZE( strokeS* , psttNet ) ;
                                            _IO_

                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****                                       *********************************************************************************************************************************************************************************************************************************************************
                                            //****  "HIDDEN" LABEL AND A DASH '-' FOUND  *********************************************************************************************************************************************************************************************************************************************************
                                            //****                                       *********************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        {
                                        else if( psttw && etThread.strIdF( tin0P , gcP.tHidden , psttw , 1 ) && etThread.strIdF( tin0P , gcP.tDash , psttw , 1 ) )
                                        }
                                            }
                                                while( cDo -- ) etRock.traceF( tin0P , gcP.tSayTraceMarkEnd ) ;
                                                countT cDo = 8 ;

                                                //etRock.traceF( tin0P , gcP.tSayPushedDomain+TF2(cirRecentDomainGrossTraceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                cirRecentDomainGrossTraceP << &psttSTFU ;
                                                //etRock.traceF( tin0P , gcP.tSayPushingDomain+TF2(cirRecentDomainGrossTraceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                etThread.strMakeF( tin0P , LF , psttSTFU , tDomainGross ) ; ___( psttSTFU ) ;
                                                ZE( strokeS* , psttSTFU ) ;
                                            {
                                            else
                                            if( bSTFU ) ;//etRock.traceF( tin0P , T("stfu [tDomainGross]:    ")+tDomainGross ) ;

                                            }
                                                while( c3Handle.c1 ) ;
                                                }
                                                    }
                                                        break ;
                                                        bSTFU = 1 ;
                                                    {
                                                    if( ppsttSTFU && *ppsttSTFU && !etThread.strCompareF( tin0P , *ppsttSTFU , tDomainGross ) )
                                                    strokeS** ppsttSTFU = (strokeS**)cirRecentDomainGrossTraceP[ c3Handle ] ;
                                                {
                                                do
                                                count3S c3Handle ;
                                            {
                                            ZE( boolT , bSTFU ) ;
                                            bForceReply = 1 ;

                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****                 *******************************************************************************************************************************************************************************************************************************************************************************
                                            //****  TRACEMARK END  *******************************************************************************************************************************************************************************************************************************************************************************
                                            //****                 *******************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        {
                                        else if( etThread.strIdF( tin0P , gcP.tDomainGrossTraceMarkEnd , tDomainGross ) )
                                        }
                                            }
                                                while( cDo -- ) etRock.traceF( tin0P , gcP.tSayTraceMarkBegin ) ;
                                                countT cDo = 8 ;

                                                //etRock.traceF( tin0P , gcP.tSayPushedDomain+TF2(cirRecentDomainGrossTraceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                cirRecentDomainGrossTraceP << &psttSTFU ;
                                                //etRock.traceF( tin0P , gcP.tSayPushingDomain+TF2(cirRecentDomainGrossTraceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                etThread.strMakeF( tin0P , LF , psttSTFU , tDomainGross ) ; ___( psttSTFU ) ;
                                                ZE( strokeS* , psttSTFU ) ;
                                            {
                                            else
                                            if( bSTFU ) ;//etRock.traceF( tin0P , T("stfu [tDomainGross]:    ")+tDomainGross ) ;

                                            }
                                                while( c3Handle.c1 ) ;
                                                }
                                                    }
                                                        break ;
                                                        bSTFU = 1 ;
                                                    {
                                                    if( ppsttSTFU && *ppsttSTFU && !etThread.strCompareF( tin0P , *ppsttSTFU , tDomainGross ) )
                                                    strokeS** ppsttSTFU = (strokeS**)cirRecentDomainGrossTraceP[ c3Handle ] ;
                                                {
                                                do
                                                count3S c3Handle ;
                                            {
                                            ZE( boolT , bSTFU ) ;
                                            bForceReply = 1 ;

                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****                   *****************************************************************************************************************************************************************************************************************************************************************************
                                            //****  TRACEMARK BEGIN  *****************************************************************************************************************************************************************************************************************************************************************************
                                            //****                   *****************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                            //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        {
                                        if( etThread.strIdF( tin0P , gcP.tDomainGrossTraceMarkBegin , tDomainGross ) )

                                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        //****                               *****************************************************************************************************************************************************************************************************************************************************************
                                        //****  SET bSilent AND bForceReply  *****************************************************************************************************************************************************************************************************************************************************************
                                        //****                               *****************************************************************************************************************************************************************************************************************************************************************
                                        //****************************************************************************************************************************************************************************************************************************************************************************************************
                                        //****************************************************************************************************************************************************************************************************************************************************************************************************

                                        //etRock.traceF( tin0P , gcP.tSayDomainGrossPeer+tDomainGross+gcP.tqb4q+tDomainPeer+gcP.tq ) ;
                                        TN( tDomainGross , psttw ) ;
                                        if( psttw ) ((tin1S&)tin0P).pEtScratch->strConvertToLowerCaseF( tin0P , psttw ) ; ___( psttw ) ;
                                        //etRock.traceF( tin0P , gcP.tSayLoweringCase ) ;
                                        *ps >> psttw ;
                                        ZE( strokeS* , psttw ) ;
                                        _IO_
                                    {
                                    if( ps )
                                    stsQueries >> ps ;
                                    ZE( soulC* , ps ) ;
                                    //etRock.traceF( tin0P , gcP.tSayPoppingQuery ) ;
                                    _IO_
                                {
                                while( stsQueries )
                                _IO_
                            {
                            else
                            }
                                idError = ifcIDeRRORdNS_CANNOTpARSEqUERY ;
                                etRock.traceF( tin0P , gcP.tSayExCouldNotParse+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                POOPRqUIET
                            {
                            if( rc )
                            etThread.delF( tin0P , pbNU ) ;
                            //etRock.traceF( tin0P , gcP.tSayCalledDnsParse ) ;
                            countT rc = POOP ;
                            ((tin1S&)tin0P).pEtScratch->dnsParseF( tin0P , pbNU , countTC() , stsQueries , stsRepliesNU , job.pbq , job.cbq ) ;
                            SCOOPS
                            //etRock.traceF( tin0P , gcP.tSayCallingDnsParse ) ;
                            _IO_
                        {
                        IFsCRATCHoK
                        ZE( byteT* , pbNU ) ;

                        //etRock.traceF( tin0P , gcP.tSayPurgedStacks ) ;
                        stsRepliesNU.purgeF( tin0P ) ;
                        stsQueries.purgeF( tin0P ) ;
                        //etRock.traceF( tin0P , gcP.tSayPurgingStacks ) ;
                        _IO_
                    {

                    ++ gvP.idClient ;

                    //}
                    //    //etRock.traceF( tin0P , TT(timeN1,timeN2)+gcP.tb4+tTimeOld+gcP.tb4+T(job.nnPeer)+(bDivert?gcP.tSayDiverting:gcP.tSayGranting)+tDomainPeer ) ;
                    //
                    //    }
                    //        etThread.delF( tin0P , pstgcP.tSay ) ;
                    //        tTimeOld = T(pstgcP.tSay) ;
                    //        etThread.strFromOldTimeF( tin0P , pstgcP.tSay , mm , hh , d , m , y , dow , 0 ) ; ___( pstgcP.tSay ) ;
                    //        ZE( strokeS* , pstgcP.tSay ) ;
                    //    {
                    //    TN( tTimeOld , "" ) ;
                    //
                    //    etThread.osTimeToOldTimeF( tin0P , ms , ss , mm , hh , d , m , y , dow , timeN1 , timeN2 , flOStIMEtOoLDtIME_null ) ;
                    //    ZE(  countT , dow ) ;
                    //    ZE( sCountT , y   ) ;
                    //    ZE(  countT , m   ) ;
                    //    ZE(  countT , d   ) ;
                    //    ZE(  countT , hh  ) ;
                    //    ZE(  countT , mm  ) ;
                    //    ZE(  countT , ss  ) ;
                    //    ZE(  countT , ms  ) ;
                    //
                    //    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                    //    ZE( sCountT , timeN2 ) ;
                    //    ZE( countT  , timeN1 ) ;
                    //{

                    countT idError = ifcIDeRRORdNS_AOK ;
                    _IO_
                {
                if( job.pbq && job.cbq )
                _IO_
            {

            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****                       *************************************************************************************************************************************************************************************************************************************************************************
            //****  INSPECT THE QUERIES  *************************************************************************************************************************************************************************************************************************************************************************
            //****                       *************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************

            }
                }
                    //etRock.traceF( tin0P , gcP.tSayNotDiverting ) ;
                    bDivert = 0 ;                                                                                                                                   //P:PERSONALITY: SUPPRESS DIVERSION IF RECENT QUERY FROM LETSENCRYPT
                {
                else
                }
                    //etRock.traceF( tin0P , gcP.tSayDiverting2 ) ;
                {
                if( !timeLetsEncryptLath2 && !timeLetsEncryptLath1 )
            {
            if( bDivert )

            }
                }
                    //etRock.traceF( tin0P , gcP.tSayDiversionEnabled ) ;
                    bForceReply = timeLetsEncryptLath2 = timeLetsEncryptLath1 = 0 ;
                {
                if( timeE2 || timeE1 > TICK << 0 )

                etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeLetsEncryptLath1 , timeLetsEncryptLath2 ) ;
                etThread.osTimeNowF( tin0P , timeE1 , timeE2 ) ;
                ZE( sCountT , timeE2 ) ;
                ZE( countT  , timeE1 ) ;
            {
            else if( timeLetsEncryptLath2 || timeLetsEncryptLath1 )
            }
                //etRock.traceF( tin0P , bSuppressed ? gcP.tSayDiversionSupRefreshed : gcP.tSayDiversionSuppressed ) ;
                etThread.osTimeNowF( tin0P , timeLetsEncryptLath1 , timeLetsEncryptLath2 ) ;
                timeLetsEncryptLath2 = timeLetsEncryptLath1 = 0 ;
                countT bSuppressed = timeLetsEncryptLath2 || timeLetsEncryptLath1 ;
                bForceReply = 1 ;
            {
            if( 1 + tDomainPeer.csF( tin0P ) - gcP.tDotLetsEncryptDotOrg.csF( tin0P ) == etThread.strIdF( tin0P , gcP.tDotLetsEncryptDotOrg , tDomainPeer ) )

            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****                                                      ******************************************************************************************************************************************************************************************************************************************
            //****  IF LETS ENCRYPT THEN FORCE REPLY AND DO NOT DIVERT  ******************************************************************************************************************************************************************************************************************************************
            //****                                                      ******************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************

            }
                }
                    //U::PROD: //etRock.traceF( tin0P , gcP.tSayPrefix+T(job.nnPeer)+gcP.tSayUnknownDomain+gcP.tb4+tDomainPeer ) ;
                    //etRock.traceF( tin0P , gcP.tSayUnknownDomain ) ;
                    bDivert = 1 ;
                {
                else
                }
                    }
                        //etRock.traceF( tin0P , gcP.tSayPushedPeer+TF2(cirNnPeerDoNotDivertP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        cirNnPeerDoNotDivertP << &job.nnPeer ;
                        //etRock.traceF( tin0P , gcP.tSayPushingPeer+TF2(cirNnPeerDoNotDivertP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( !bDoNotDivert )
                {
                if( bDoNotDivert || bDomainRootAllowed || bSubnetTrusted )         //P:PERSONALITY: TRUSTED PEERS ARE DIRECTED TO wh1 ; UNTRUSTED PEERS ARE DIRECTED TO wh2

                //****************************************************************************************************************************************************************************************************************************************************************************************************
                //****************************************************************************************************************************************************************************************************************************************************************************************************
                //****                                                             ***********************************************************************************************************************************************************************************************************************************
                //****  EITHER SET bDivert OR REMEMBER nnPeer FOR "DO NOT DIVERT"  ***********************************************************************************************************************************************************************************************************************************
                //****                                                             ***********************************************************************************************************************************************************************************************************************************
                //****************************************************************************************************************************************************************************************************************************************************************************************************
                //****************************************************************************************************************************************************************************************************************************************************************************************************

                }
                    }
                        etThread.delF( tin0P , psttPeer ) ;
                        }
                            mySettingsP.grabMe.ungrabF( tin0P ) ;
                            }
                                }
                                    break ;
                                    bDomainRootAllowed ++ ;
                                {
                                if( idHit && idHit == 1 + psttPeer->idAdam - mySettingsP.pptDomainRootAllowed[ offt ]->csF( tin0P ) )
                                countT idHit  = etThread.strIdF( tin0P , *mySettingsP.pptDomainRootAllowed[ offt ] , psttPeer , 1 ) ;
                            {
                            for( countT offt = 0 ; offt < mySettingsP.cDomainRootAllowed ; offt ++ )
                            mySettingsP.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                            //etRock.traceF( tin0P , gcP.tSayPeer/*+T(psttPeer)*/ ) ;
                            tDomainPeer = T(psttPeer) ;
                            _IO_
                        {
                        else
                        if( !psttPeer ) ;//etRock.traceF( tin0P , gcP.tSayExReverseLookupFailed ) ;
                        etThread.sockPsttHostF( tin0P , psttPeer , job.nnPeer ) ; ___( psttPeer ) ;
                        //etRock.traceF( tin0P , gcP.tSayDoingReverseLookup ) ;
                        ZE( strokeS* , psttPeer ) ;
                    {
                    if( !bSubnetTrusted )

                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                    //****                                                       *****************************************************************************************************************************************************************************************************************************************
                    //****  DO NOT DIVERT IF DOMAIN ROOT IS ALLOWED IN SETTINGS  *****************************************************************************************************************************************************************************************************************************************
                    //****                                                       *****************************************************************************************************************************************************************************************************************************************
                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                    //****************************************************************************************************************************************************************************************************************************************************************************************************

                    }
                        mySettingsP.grabMe.ungrabF( tin0P ) ;
                        }
                            }
                                }
                                    break ;
                                    //etRock.traceF( tin0P , T("ipv6 found in mySettingsP.pnnSubnetTrusted [nnPeer]:    ")+T(job.nnPeer) ) ;
                                    bSubnetTrusted = 1 ;
                                {
                                if( mySettingsP.pnnSubnetTrusted[ offn ] == job.nnPeer( 0x40 ) )
                            {
                            else
                            }
                                }
                                    break ;
                                    //etRock.traceF( tin0P , T("ipv4 found in mySettingsP.pnnSubnetTrusted [nnPeer]:    ")+T(job.nnPeer) ) ;
                                    bSubnetTrusted = 1 ;
                                {
                                if( mySettingsP.pnnSubnetTrusted[ offn ] == job.nnPeer( 0x18 ) )
                            {
                            if( job.nnPeer.isIPv4F() )
                            _IO_
                        {
                        for( countT offn = 0 ; offn < mySettingsP.cnnSubnetTrusted ; offn ++ )
                        mySettingsP.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        _IO_
                    {

                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                    //****                                                         ***************************************************************************************************************************************************************************************************************************************
                    //****  DO NOT DIVERT IF DOMAIN SUBNET IS TRUSTED IN SETTINGS  ***************************************************************************************************************************************************************************************************************************************
                    //****                                                         ***************************************************************************************************************************************************************************************************************************************
                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                    //****************************************************************************************************************************************************************************************************************************************************************************************************
                {
                if( !bDoNotDivert )
                ZE( boolT , bDomainRootAllowed ) ;
                ZE( boolT , bSubnetTrusted     ) ;

                }
                    while( c3Handle.c1 ) ;
                    }
                        }
                            break ;
                            //etRock.traceF( tin0P , T("found in cirNnPeerDoNotDivertP [nnPeer]:    ")+T(job.nnPeer) ) ;
                            bDoNotDivert = 1 ;
                        {
                        if( pnn && *pnn == job.nnPeer )
                        nicNameC* pnn = (nicNameC*)cirNnPeerDoNotDivertP[ c3Handle ] ;
                    {
                    do
                    count3S c3Handle ;
                {
                ZE( boolT , bDoNotDivert ) ;

                //****************************************************************************************************************************************************************************************************************************************************************************************************
                //****************************************************************************************************************************************************************************************************************************************************************************************************
                //****                                          ******************************************************************************************************************************************************************************************************************************************************
                //****  DO NOT DIVERT IF RECENTLY NOT DIVERTED  ******************************************************************************************************************************************************************************************************************************************************
                //****                                          ******************************************************************************************************************************************************************************************************************************************************
                //****************************************************************************************************************************************************************************************************************************************************************************************************
                //****************************************************************************************************************************************************************************************************************************************************************************************************

                _IO_
            {
            TN( tDomainPeer , "" ) ;
            ZE( boolT , bDivert     ) ;
            ZE( boolT , bForceReply ) ;
            boolT bSilent = 1 ;         //PS:PERSONALITY: I DO NOT RESPOND UNLESS I KNOW THE ANSWER TO THE QUERY ; THIS IS INTENDED TO CAUSE THE REQUESTING PEER TO FAILOVER TO MAKE THE REQUEST FROM ITS ALTERNATE DNS SERVER

            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****               *********************************************************************************************************************************************************************************************************************************************************************************
            //****  SET bDivert  *********************************************************************************************************************************************************************************************************************************************************************************
            //****               *********************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
            //****************************************************************************************************************************************************************************************************************************************************************************************************
        {
        if( !gvP.bQuit )

        //etRock.traceF( tin0P , T("pulled a job") ) ;

        mySettingsP.grabMe.ungrabF( tin0P ) ;
        nicNameC nnWebHook2 = etThread.sockNicNameF( tin0P , mySettingsP.tIpWebHook2 ) ;
        nicNameC nnWebHook1 = etThread.sockNicNameF( tin0P , mySettingsP.tIpWebHook1 ) ;
        mySettingsP.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

        gvP.cirJob >> &job ;
        jobS job ;

        //etRock.traceF( tin0P , T("pulling a job") ) ;
    {
    while( !gvP.bQuit )
    TN( tLongWoTimePasswordUrlSuffix , "" ) ; tLongWoTimePasswordUrlSuffix = T("///d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(ifcIDaDAM_DNS)+T("/woTimePasswordUrlSuffix") ;
    ZE( sCountT , timeLetsEncryptLath2 ) ;
    ZE( countT  , timeLetsEncryptLath1 ) ;

    stackC stsQueries(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stsReplies(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stsRepliesNU( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    ranUniC ruPassword( tin0P , (measure04T)MAXcOUNTT + 1 , processGlobal1S::_processGlobal1I_IF().trueRandom ) ;
    etherC& etRock = etherC::etRockIF( tin0P ) ;

    textC&       tSuffix2GorillaP           =       *(textC*)pTaskP->cc ;
    grabC&       grab_tSuffix2GorillaP      =       *(grabC*)pTaskP->cb ;
    textC&       tSuffix1GorillaP           =       *(textC*)pTaskP->ca ;
    grabC&       grab_tSuffix1GorillaP      =       *(grabC*)pTaskP->c9 ;
    gVarS&       gvP                        =       *(gVarS*)pTaskP->c8 ;
    gConstS&     gcP                        =     *(gConstS*)pTaskP->c7 ;
    socketC&     sockdP                     =     *(socketC*)pTaskP->c6 ;
    mySettingsS& mySettingsP                = *(mySettingsS*)pTaskP->c5 ;
    circleC&     cirRecentDomainGrossTraceP =     *(circleC*)pTaskP->c4 ;
    circleC&     cirNnPeerDoNotDivertP      =     *(circleC*)pTaskP->c3 ;
    countT&      cWorkersP                  =      *(countT*)pTaskP->c2 ;
    boolT&       bFailP                     =       *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 && pTaskP->c8 && pTaskP->c9 && pTaskP->ca )
TASK( tmWorkerF )

DONE( tmCatchF )
}
    }
        }
            }
                etRock.traceF( tin0P , T("!exception / impotence while catching [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )

            }
                etThread.delF( tin0P , pbi ) ;
                }
                    }
                        //etThread.traceF( tin0P , tSay2+tSuffix2GorillaP ) ;
                        grab_tSuffix2GorillaP.ungrabF( tin0P ) ;
                        tSuffix2GorillaP = T(pbi) ;
                        grab_tSuffix2GorillaP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                    {
                    else if( pbi == thirdC::c_strstrIF( tin0P , pbi , "wh2" ) )
                    }
                        //etThread.traceF( tin0P , tSay1+tSuffix1GorillaP ) ;
                        grab_tSuffix1GorillaP.ungrabF( tin0P ) ;
                        tSuffix1GorillaP = T(pbi) ;
                        grab_tSuffix1GorillaP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                    {
                    if( pbi == thirdC::c_strstrIF( tin0P , pbi , "wh1" ) )
                {
                //if( nnPeer == nnAllowed )

                sCatch.readF( tin0P , pbi , cbi , idPortHe , nnPeer ) ; ___( pbi ) ;
                nicNameC nnPeer ;
                ZE( countT , idPortHe ) ;
                ZE( countT , cbi ) ;
                ZE( byteT* , pbi ) ;
            {
            while( !ether && !POOP )

            etRock.traceF( tin0P , T("catching begun [idpCatch]:    ")+TF4(idpCatch,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
            etScratch.boxPutF( tin0P , tLong , (byteT*)&idpCatch , sizeof idpCatch ) ;
            countT idpCatch = sCatch.bindF( tin0P ) ;
            socketC sCatch( tin0P , etScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
            etherC& etScratch = *((tin1S&)tin0P).pEtScratch ;

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
    {
    while( !ether )

    TN( tSay2 , "caught [tSuffix2Gorilla]:    " ) ;
    TN( tSay1 , "caught [tSuffix1Gorilla]:    " ) ;
    TN( tLong , "" ) ; tLong = T("///d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(ifcIDaDAM_DNS)+T("/idpCatchSuffix") ;
    //nicNameC nnAllowed = etThread.sockNicNameF( tin0P , T("10.0.3.1") ) ;
    etherC&  etRock    = etherC::etRockIF( tin0P ) ;

    textC& tSuffix2GorillaP      = *(textC*)pTaskP->c4 ;
    grabC& grab_tSuffix2GorillaP = *(grabC*)pTaskP->c3 ;
    textC& tSuffix1GorillaP      = *(textC*)pTaskP->c2 ;
    grabC& grab_tSuffix1GorillaP = *(grabC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1&& pTaskP->c2 )
TASK( tmCatchF )

}
    return 0 ;
    ((tin1S&)tin0P).pEther->delF( tin0P , psttd ) ;
    strokeS*& psttd = *(strokeS**)cAtP ;
{
countT deleteElementF( tin0S& tin0P , countT& cAtP , countT& cArgDeleteP )

//U::6: DONE( tmUpdateNnHostsF )
//U::6: }
//U::6:     }
//U::6:         ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;
//U::6: 
//U::6:         }
//U::6:             }
//U::6:                 etRock.traceF( tin0P , T("!exception / could not write batch file [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLong ) ;
//U::6:                 POOPRqUIET
//U::6:                 countT rc = POOP ;
//U::6:             {
//U::6:             else
//U::6:             if( !POOP ) ;//etRock.traceF( tin0P , T("wrote batch file aok [tLong]:    ")+tLong ) ;
//U::6:             ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , tBatFileImage , tBatFileImage.csF( tin0P ) ) ;
//U::6:             SCOOPS
//U::6:             _IO_
//U::6:         {
//U::6:         IFsCRATCHoK
//U::6:         TN( tBatFileImage , "" ) ; tBatFileImage = T("@echo off\r\n")+tBefore2+tNnHostWeb+tAfter2+T("\r\n") ;
//U::6:         tLong = T("////web1/d/ideafarm.home.101/controls/drop.executables/new.ipv6.netsh.from.dns.")+TfORsTRING(++idFileOut)+T(".bat" ) ;
//U::6:         //etRock.traceF( tin0P , T("new  [nnHostWebLag0]:    ")+tNnHostWeb ) ;
//U::6:         TN( tNnHostWeb , "" ) ; tNnHostWeb = T(nnHostWebLag0P) ;
//U::6: 
//U::6:                                                            nnHostWebLag0P = nnHostWebLathP ;
//U::6:                                           nnHostWebLag1P = nnHostWebLag0P ;
//U::6:                          nnHostWebLag2P = nnHostWebLag1P ;
//U::6:         nnHostWebLag3P = nnHostWebLag2P ;
//U::6: 
//U::6:         ( *(count04T*)&nnHostWebLathP ) ++ ;
//U::6: 
//U::6:         }
//U::6:             }
//U::6:                 }
//U::6:                     etRock.traceF( tin0P , T("!exception / could not write batch file [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLong ) ;
//U::6:                     POOPRqUIET
//U::6:                     countT rc = POOP ;
//U::6:                 {
//U::6:                 else
//U::6:                 if( !POOP ) ;//etRock.traceF( tin0P , T("wrote batch file aok [tLong]:    ")+tLong ) ;
//U::6:                 ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , tBatFileImage , tBatFileImage.csF( tin0P ) ) ;
//U::6:                 SCOOPS
//U::6:                 _IO_
//U::6:             {
//U::6:             IFsCRATCHoK
//U::6:             TN( tBatFileImage , "" ) ; tBatFileImage = T("@echo off\r\n")+tBefore1+tNnHostWeb+tAfter1+T("\r\n") ;
//U::6:             tLong = T("////web1/d/ideafarm.home.101/controls/drop.executables/new.ipv6.netsh.from.dns.")+TfORsTRING(++idFileOut)+T(".bat" ) ;
//U::6: 
//U::6:             //etRock.traceF( tin0P , T("doomed [nnHostWebLag3]:    ")+tNnHostWeb ) ;
//U::6:             TN( tNnHostWeb , "" ) ; tNnHostWeb = T(nnHostWebLag3P) ;
//U::6:         {
//U::6:         if( ~nnHostWebLag3P )
//U::6:         TN( tLong , "" ) ; 
//U::6:     {
//U::6:     while( !ether )
//U::6:     ZE( countT , idFileOut ) ;
//U::6:     sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
//U::6: 
//U::6:     TN( tb4      , "    " ) ;
//U::6:     TN( tAfter2  , "/64\"" ) ;
//U::6:     TN( tAfter1  , "\"" ) ;
//U::6:     TN( tBefore2 , "netsh interface ipv6 add    address interface=\"outer\" address=\"" ) ;
//U::6: 
//U::6:     ) ;
//U::6: 
//U::6:         "netsh interface ipv6 delete address interface=\"outer\" address=\""
//U::6:         "netsh interface ipv6 delete address interface=\"outer\" address=\"2001:19f0:0:7077:5400:5ff:fe59:278d\"\r\n"            //U:: PUT THIS INTO A SETTING
//U::6: 
//U::6:     TN( tBefore1 ,
//U::6: 
//U::6:     //
//U::6:     // ADD    THE YOUNGEST ADDRESS (LAG 0)
//U::6:     // SET    THE YOUNGEST ADDRESS (LAG 0)
//U::6:     // SHIFT  THE DATA TO LAG
//U::6:     // DELETE THE OLDEST   ADDRESS (LAG 3)
//U::6:     //
//U::6:     // RECIPE
//U::6: 
//U::6:     nicNameC& nnHostWebLag3P = *(nicNameC*)pTaskP->c5 ;
//U::6:     nicNameC& nnHostWebLag2P = *(nicNameC*)pTaskP->c4 ;
//U::6:     nicNameC& nnHostWebLag1P = *(nicNameC*)pTaskP->c3 ;
//U::6:     nicNameC& nnHostWebLag0P = *(nicNameC*)pTaskP->c2 ;
//U::6: 
//U::6:     nicNameC& nnHostWebLathP = *(nicNameC*)pTaskP->c1 ;     // WILL ALWAYS BE THE SAME AS nnHostWebLag0P ; IS USED TO MAKE THE CODE EASIER TO UNDERSTAND
//U::6: 
//U::6:     _IO_
//U::6: {
//U::6: if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
//U::6: TASK( tmUpdateNnHostsF )

}
    }
        stsRepliesP << ps ;

        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // cSerial
        *ps << (countT)0 ; // cSerial
        *ps << psttEmailP ;
        *ps << psttNsP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_SOA ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_SOA_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttNsP , const strokeS* const psttEmailP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_NS ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_NS_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;
        *ps << (countT)0 ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_MX ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_MX_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_AAAA ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_AAAA_F [nnPeer,nn,name]:    peer: ")+T(nnPeerP)+T("    directed to: ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_AAAA_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP , const nicNameC& nnPeerP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_A ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_A_F [nnPeer,nn,name]:    peer: ")+T(nnPeerP)+T("    directed to: ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_A_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP , const nicNameC& nnPeerP )

DONE( tmFreshSettingsF )
}
    }
        }
            }
                sgnSettingsReadyP.giveF( tin0P , ifcIDmODEsIGNgIVE_ON ) ;       //U::ifcIDmODEsIGNgIVE_ON IS A WORKAROUND TO AN APPARENT RACE CONDITION IN WHICH I HANG TRYING FUTILELY TO grabF()
                bWoth = 0 ;
                _IO_
            {
            if( bWoth )

            }
                __NZ( !mySettingsP ) ;

                }
                    if( ~mySettingsP ) break ;

                    mySettingsP.grabMe.ungrabF( tin0P ) ;
                    etRock.traceF( tin0P , T(!mySettingsP?"the new settings are incomplete":"the new settings are aok")+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    mySettingsP.freshenF( tin0P ) ;
                    /**/etRock.traceF( tin0P , T(!mySettingsP?"the stale settings are incomplete":"the stale settings are aok")+tb4+TF2(++idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    mySettingsP.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                    ++ s ; etThread.osSleepF( tin0P , TOCK << 2 ) ; // TIME FOR PISS TO FINISH UPDATING SETTINGS
                {
                while( !POOP )
                ZE( countT , idTry ) ;
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                /**/etRock.traceF( tin0P , T("the timestamp of the settings files has changed ; napping and then calling freshenF") ) ;
                timeWrittenLath = timeWritten ;
                _IO_
            {
            if( timeWrittenLath.time1 != timeWritten.time1 || timeWrittenLath.time2 != timeWritten.time2 )

            }
                }
                    }
                        }
                            continue ;
                            /**/etRock.traceF( tin0P , T("!exception / could not get file time [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongFile ) ;
                            POOPRqUIET
                            countT rc = POOP ;
                        {
                        else
                        }
                            break ;
                            /**/etRock.traceF( tin0P , T(" [timeWritten]:    ")+TT(timeWritten.time1,timeWritten.time2) ) ;
                        {
                        if( !POOP )

                        thirdC::getFileTimeIF( tin0P , fir , &timeWritten , 0 , 0 ) ;
                    {
                    else
                    }
                        continue ;
                        /**/etRock.traceF( tin0P , T("!exception / could not open settings file to get file time [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongFile ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )

                    fileC fir( tin0P , (strokeS*)tLongFile , ifcOPENaCCESS_R , ifcOPENsHARE_WR , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;

                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                _IO_
            {
            while( !ether )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            timeS timeWritten ;
            _IO_
        {
        if( bWoth || etThread.etherC::diskWaitDirF( tin0P , hWait , ether , tLongPath , flWAITdIR_ATTRIBUTE | flWAITdIR_SIZE | flWAITdIR_WRITE ) )
        _IO_
    {
    while( !ether && !POOP )
    timeS timeWrittenLath ;
    handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    TN( tb4 , "    " ) ;
    boolT bWoth = 1 ;

    etherC& etRock = etherC::etRockIF( tin0P ) ;

    TN( tLongFile , "" ) ; tLongFile = tLongPath + T("kv.settings.ipdos.jotC.data.booksC.1.book.00000001.00000001.bookC") ;

    }
        tLongPath = T(ifFile) ;
        ifFileNameC ifFile( tin0P , etThread , postPath ) ;

        __Z( *postPath ) ;
        thirdC::postPathStateSpaceIF( tin0P , postPath , sizeof postPath , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
        osTextT postPath[ TUCK << 1 ] ;
        _IO_
    {
    TN( tLongPath , "" ) ;

    signC&       sgnSettingsReadyP =       *(signC*)pTaskP->c2 ;
    mySettingsS& mySettingsP       = *(mySettingsS*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmFreshSettingsF )

}
    THREADmODE1rESTORE
    grabMe.ungrabF( tin0P ) ;

    }
        }
            else                                                                     break ;
            if( etherMe.strCompareF( tin0P , *pptDomainRootAllowed[ offt ] , tnu ) ) cDomainRootAllowed ++ ;
        {
        for( countT offt = 0 ; offt < sizeof pptDomainRootAllowed / sizeof pptDomainRootAllowed[ 0 ] ; offt ++ )
        cDomainRootAllowed = 0 ;
        TN( tnu , ".not.used.ideafarm.com" ) ;                                                          //P:PERSONALITY: I IGNORE ALL ELEMENTS NOT BEFORE THE WO'TH ELEMENT THAT CONTAINS THE "NOT USED" VALUE ; THIS IS FOR SPEED
        _IO_
    {

    }
        /**/etRock.traceF( tin0P , T("trusted (Stripe) [off,subnet]:    ")+TF3(offn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,3)+tb4+T(pnnSubnetTrusted[offn]) ) ;
    {
    for( countT offn = 0 ; offn < cnnSubnetTrusted ; offn ++ )

    }
        }
            }
                while( ~hWalk ) ;
                }
                    pnnSubnetTrusted[ offo ++ ] = nnSubnet ;
                    nicNameC& nnSubnet = (nicNameC&)stNnSubnetTrusted.downF( tin0P , hWalk ) ;
                {
                do
                handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , offo ) ;
                _IO_
            {
            if( pnnSubnetTrusted )
            etherMe.newF( tin0P , LF , pnnSubnetTrusted , cnnSubnetTrusted ) ; ___( pnnSubnetTrusted ) ;
        {
        if( cnnSubnetTrusted )
        cnnSubnetTrusted = stNnSubnetTrusted ;

        }
            etherMe.delF( tin0P , pstt1Nn ) ;
            }
                stNnSubnetTrusted.sinkF( tin0P , countTC() , nnSubnet , flSTACKsINK_UNIQUE ) ;

                ;
                    : nnIPv46( 0x40 )
                    ? nnIPv46( 0x18 )
                nicNameC nnSubnet = nnIPv46.isIPv4F()
                nicNameC nnIPv46  = etherMe.sockNicNameF( tin0P , psttc1 ) ;

                /**/etRock.traceF( tin0P , T("adding trusted:    ")+T(psttc1) ) ;
                _IO_
            {
            FORsTRINGSiN1( pstt1Nn )

            countT cNn = etherMe.strWordsF( tin0P , pstt1Nn , tNnTrusted , sttq , T(" ,") ) ; ___( pstt1Nn ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1Nn ) ;
            _IO_
        {
        stackC stNnSubnetTrusted( tin0P , etherMe , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_nicNameC ) ;
        _IO_
    {

    zapF( tin0P ) ;

    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed8]:    \"")+tDomainRootAllowed8+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed7]:    \"")+tDomainRootAllowed7+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed6]:    \"")+tDomainRootAllowed6+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed5]:    \"")+tDomainRootAllowed5+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed4]:    \"")+tDomainRootAllowed4+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed3]:    \"")+tDomainRootAllowed3+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed2]:    \"")+tDomainRootAllowed2+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed1]:    \"")+tDomainRootAllowed1+T("\"") ) ;

    /**/etRock.traceF( tin0P , T("settings [tIpWebHook1,tIpWebHook2,tDomainLeafWebHooksNet,tDomainLeafWebHook1Net]:    \"")+tIpWebHook1+T("\"    \"")+tIpWebHook2+T("\"    \"")+tDomainLeafWebHooksNet+T("\"    \"")+tDomainLeafWebHook1Net ) ;

    /**/etRock.traceF( tin0P , T("[tNnTrusted]:    ")+tNnTrusted ) ;
    }
        etherMe.delF( tin0P , psttEat ) ;
        tNnTrusted = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.nn.trusted")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed8 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.8")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed7 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.7")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed6 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.6")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed5 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.5")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed4 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.4")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed3 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.3")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed2 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.2")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed1 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.1")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        }
            etherMe.delF( tin0P , psttNet ) ;
            tDomainLeafWebHook1Net = T(psttNet) ;
            etherMe.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
            _IO_
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.wh1")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tIpWebHook2 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh2")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        }
            etherMe.delF( tin0P , psttNet ) ;
            tSuffixUsedByStripe = T(psttNet) ;
            etherMe.strSubstringF( tin0P , psttNet , idf , sttq , tDot , psttEat , 0 , 0 ) ;
            etherMe.delF( tin0P , psttNet ) ;
            tDomainLeafWebHooksNet = T(psttNet) ;
            etherMe.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
            _IO_
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.webhooks")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , pstt1w ) ;
        }
            }
                break ;
                tIpWebHook1 = T(psttc1) ;
            {
            else if( bArmed )
            if( !etherMe.strCompareF( tin0P , tStatic , psttc1 ) ) bArmed = 1 ;
        {
        FORsTRINGSiN1( pstt1w )
        ZE( boolT , bArmed ) ;
        etherMe.strWordsF( tin0P , pstt1w , tNetshCommandIpv4 , sttq ) ; ___( pstt1w ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        TN( tStatic , "static" ) ;
        ZE( strokeS* , pstt1w ) ;
    
        // {kv: dns.wh1.netsh.command.ipv4.1 "netsh interface ip set address "outer" static 1.2.3.4 255.255.254.0 1.2.3.1"     }
    
        _IO_
    {
    else if( etherMe.strIdF( tin0P , tStatic , tNetshCommandIpv4 ) )
    }
        etherMe.delF( tin0P , psttEat ) ;
        tIpWebHook1 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1.dhcp")  ) ; ___( psttEat ) ;
        _IO_
    {
    if( etherMe.strIdF( tin0P , tDhcp , tNetshCommandIpv4 ) )

    }
        etherMe.delF( tin0P , psttEat ) ;
        }
            }
                }
                    etRock.traceF( tin0P , T("!exception / could not write batch file [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLong ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                {
                else
                if( !POOP ) /*;*/etRock.traceF( tin0P , T("wrote batch file aok [tLong]:    ")+tLong ) ;
                ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , tBatFileImage , tBatFileImage.csF( tin0P ) ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK

            TN( tLong , "" ) ; tLong = T("////wh1/d/ideafarm.home.101/controls/drop.executables/new.ipv4.netsh.from.dns.")+TfORsTRING(idFreshen)+T(".bat" ) ;
            TN( tBatFileImage , "" ) ; tBatFileImage = T("@echo off\r\n")+tNetshCommandIpv4+T("\r\n") ;

            tNetshCommandIpv4 = T(psttEat) ;
            etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.")+tNetshCommandIpv4SettingKey  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tNetshCommandIpv4SettingKey = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1.netsh.command.ipv4.settingkey")  ) ; ___( psttEat ) ;
        _IO_
    {

    grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

    countT idFreshen = 1 + incv02AM( idFreshenLath ) ;
    static countT idFreshenLath ;

    TN( tStatic , "static" ) ;
    TN( tDhcp   , "dhcp"   ) ;
    TN( tb4     , "    "   ) ;
    TN( tDot    , "."      ) ;
    TN( tDash   , "-"      ) ;
    etherC& etRock = etherC::etRockIF( tin0P ) ;
    _IO_
{
voidT mySettingsS::freshenF( tin0S& tin0P )

}
    cnnSubnetTrusted = 0 ;

    }
        etherMe.delF( tin0P , pnnSubnetTrusted ) ;
        }
            DELzOMBIE( pDoomed ) ;
            nicNameC* pDoomed = pnnSubnetTrusted + offn ;
        {
        for( countT offn = 0 ; offn < cnnSubnetTrusted ; offn ++ )
    {
    if( pnnSubnetTrusted )
    _IO_
{
voidT mySettingsS::zapF( tin0S& tin0P )

}
    return bMissing ;

    ) ;
        !tDomainRootAllowed8.csF( tin0P )
        ||
        !tDomainRootAllowed7.csF( tin0P )
        ||
        !tDomainRootAllowed6.csF( tin0P )
        ||
        !tDomainRootAllowed5.csF( tin0P )
        ||
        !tDomainRootAllowed4.csF( tin0P )
        ||
        !tDomainRootAllowed3.csF( tin0P )
        ||
        !tDomainRootAllowed2.csF( tin0P )
        ||
        !tDomainRootAllowed1.csF( tin0P )
        ||
        !tDomainLeafWebHook1Net.csF( tin0P )
        ||
        !tSuffixUsedByStripe.csF( tin0P )
        ||
        !tDomainLeafWebHooksNet.csF( tin0P )
        ||
        !tIpWebHook2.csF( tin0P )
        ||
        !tIpWebHook1.csF( tin0P )
        ||
        !tNetshCommandIpv4.csF( tin0P )
        ||
        !tNetshCommandIpv4SettingKey.csF( tin0P )
    (
    boolT bMissing =
    TINSL
{
boolT mySettingsS::operator !( voidT )

}
    *(textC**)&pptDomainRootAllowed[ 7 ] = &tDomainRootAllowed8 ;
    *(textC**)&pptDomainRootAllowed[ 6 ] = &tDomainRootAllowed7 ;
    *(textC**)&pptDomainRootAllowed[ 5 ] = &tDomainRootAllowed6 ;
    *(textC**)&pptDomainRootAllowed[ 4 ] = &tDomainRootAllowed5 ;
    *(textC**)&pptDomainRootAllowed[ 3 ] = &tDomainRootAllowed4 ;
    *(textC**)&pptDomainRootAllowed[ 2 ] = &tDomainRootAllowed3 ;
    *(textC**)&pptDomainRootAllowed[ 1 ] = &tDomainRootAllowed2 ;
    *(textC**)&pptDomainRootAllowed[ 0 ] = &tDomainRootAllowed1 ;
{
cDomainRootAllowed(          0                                                                  )
cnnSubnetTrusted(            0                                                                  ) ,
pnnSubnetTrusted(            0                                                                  ) ,
tNnTrusted(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed8(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed7(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed6(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed5(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed4(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed3(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed2(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed1(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tIpWebHook2(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tIpWebHook1(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainLeafWebHook1Net(      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tSuffixUsedByStripe(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainLeafWebHooksNet(      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tNetshCommandIpv4(           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tNetshCommandIpv4SettingKey( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
grabMe(                      tin0P , TAG( TAGiDnULL ) , flGRABc_SHARElAYER | flGRABc_NOTjEALOUS ) ,
etherMe(                     etherP                                                             ) ,
mySettingsS::mySettingsS( tin0S& tin0P , etherC& etherP ) :

}
    zapF( tin0P ) ;
    TINSL
{
mySettingsS::~mySettingsS( voidT )

NEWdELcLASS( 1 , jobS ) ;

;
}
    }
        //U::6: nnHostWebLag0 = etherP.sockNicNameF( tin0P , T("2001:19f0:0000:7077:5400:05ff:fe59:278d") ) ;        //U:: PUT THIS INTO A SETTING ; THIS IS THE IPv6 ASSIGNED TO web1
        //U::6: nnHostWebLag0 = etherP.sockNicNameF( tin0P , T("2001:19f0:0:7077::1") ) ;        //U:: FOR TESTING
        //U::6: nnHostWebLath = etherP.sockNicNameF( tin0P , T("2001:19f0:0:7077::") ) ;                             //U:: PUT THIS INTO A SETTING ; THIS IS THE BEGINNING VALUE THAT IS INCREMENTED BY tmUpdateNnHostsF TO OBTAIN AN EPHEMERAL (AND EVENTUALLY RANDOM) IPv6 VALUE FOR web1
    {
    cirJob(  tin0P , etherP , bQuit , flCIRCLEc_null , sizeof jobS , TUCK << 0 )
    idClient( 0 ) ,
    bQuit( 0 ) ,
    inline gVarS( tin0S& tin0P , etherC& etherP , gConstS& gcP ) :

    //U::6: nicNameC nnHostWebLag3 ;
    //U::6: nicNameC nnHostWebLag2 ;
    //U::6: nicNameC nnHostWebLag1 ;
    //U::6: nicNameC nnHostWebLag0 ;
    //U::6: nicNameC nnHostWebLag0 ;
    //U::6: nicNameC nnHostWebLath ;

    circleC cirJob   ;
    countT  idClient ;
    boolT   bQuit    ;
{
struct gVarS

;
}
    }
        tWebHook1 = mySettingsP.tDomainLeafWebHook1Net+tHidden ;
        tWebHooks = mySettingsP.tDomainLeafWebHooksNet+tHidden ;
    {
    //U::6: , tTarget(               tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "target.ipv6-only.ideafarm.com" )

    tDotLetsEncryptDotOrg(           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".letsencrypt.org"                                                                                                      )

    tSayTraceMarkEnd(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "---------------------------------------------------------------------------------------------------------------------" ) ,
    tSayTraceMarkBegin(              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" ) ,
    tDomainGrossTraceMarkEnd(        tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".traceend.hidden.ideafarm.com"                                                                                         ) ,
    tDomainGrossTraceMarkBegin(      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".tracebegin.hidden.ideafarm.com"                                                                                       ) ,

    tSayGranting(                    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "    granting information    "                                                                                          ) ,
    tSayDiverting(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "    diverting information    "                                                                                         ) ,
    tSayUnknownDomain(               tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "    !exception / unknown peer domain"                                                                                  ) ,
    tSayPrefix(                      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "[nnPeer]:    "                                                                                                         ) ,

    tSayReadSuffixFile(              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "read    suffix file [suffix]:    "                                                                                     ) ,
    tSayReadingSuffixFile(           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "reading suffix file"                                                                                                   ) ,
    tSayPushedDomain(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "pushed domain  [cDomains]:    "                                                                                        ) ,
    tSayPushingDomain(               tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "pushing domain [cDomains]:    "                                                                                        ) ,
    tSayPushedPeer(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "pushed peer  [cPeers]:    "                                                                                            ) ,
    tSayPushingPeer(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "pushing peer [cPeers]:    "                                                                                            ) ,
    tSayPushedJob(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "pushed job  [cBacklog]:    "                                                                                           ) ,
    tSayPushingJob(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "pushing job [cBacklog]:    "                                                                                           ) ,
    tSayPurgedStacks(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "purged  stacks"                                                                                                        ) ,
    tSayPurgingStacks(               tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "purging stacks"                                                                                                        ) ,
    tSayExCouldNotWriteReply(        tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / could not write reply [rc]:    "                                                                          ) ,
    tSayWroteReply(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "wrote reply"                                                                                                           ) ,
    tSayReplying1(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "replying / 1 [cbr]:    "                                                                                               ) ,
    tSayExCouldNotBuildReply(        tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / could not build reply [rc]:    "                                                                          ) ,
    tSayReplying2(                   tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "replying / 2 [tDomainGross]:    "                                                                                      ) ,
    tSayAAAARequest(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "AAAA request [tDomainNet]:    "                                                                                        ) ,
    tSayARequest(                    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "A request [tDomainNet]:    "                                                                                           ) ,
    tSayExCouldNotReadPasswordFile(  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / could not read password suffix shared file [rc,costg,(countT)postg,postg,tLong]:    "                     ) ,
    tSayWrotePasswordFile(           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "wrote password suffix shared file aok [tLong]:    "                                                                    ) ,
    tSaySettingNewPassword(          tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "setting bNewPassword because suffix has already been used too many times or for too long [gv.tGorillaSuffixUsed]:    " ) ,
    tSayResettingDivert(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "resetting bDivert because suffix has already been used [gv.tGorillaSuffixUsed]:    "                                   ) ,
    tSayDomainNetSuffixPeer(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "[bValid,domainNet,actual,valid,valid2,peer]:      \""                                                                  ) ,
    tSayDomainGrossPeer(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "[domainGross,peer]:    \""                                                                                             ) ,
    tSayLoweringCase(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "lowering case"                                                                                                         ) ,
    tSayPoppingQuery(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "popping a query"                                                                                                       ) ,
    tSayExCouldNotParse(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / could not parse query [rc]:    "                                                                          ) ,
    tSayCalledDnsParse(              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "called  dnsParseF"                                                                                                     ) ,
    tSayCallingDnsParse(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "calling dnsParseF"                                                                                                     ) ,
    tSayNotDiverting(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: not diverting"                     ) ,

    //U::PROD: tSayDiverting2(       tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| * * * * D I V E R T I N G * * * *" ) ,
    tSayDiverting2(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "D I V E R T I N G"                                                                                                     ) ,

    tSayDiversionEnabled(            tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "----------------------------------------------------------------------------------- DIVERSION ENABLED"                 ) ,
    tSayDiversionSuppressed(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ DIVERSION SUPPRESSED"              ) ,
    tSayDiversionSupRefreshed(       tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ DIVERSION SUPPRESSION REFRESHED"   ) ,
    tSayPeer(                        tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "[tPeer]:    "                                                                                                          ) ,
    tSayExReverseLookupFailed(       tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / reverse DNS lookup failed"                                                                                ) ,
    tSayDoingReverseLookup(          tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "doing reverse DNS lookup"                                                                                              ) ,
    tSayExReadFailed(                tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "!exception / socket read failed [rc]:    "                                                                             ) ,
    tSayCalledRead(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "called readF"                                                                                                          ) ,
    tSayCallingRead(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "calling readF"                                                                                                         ) ,
    tSayWaitedForPacket(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "waited for a packet [nnPeer,cbq]:    "                                                                                 ) ,
    tSayWaitingForPacket(            tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "waiting for a packet"                                                                                                  ) ,
    tSayInnerLoopBegun(              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "inner loop begun"                                                                                                      ) ,

    tq(                              tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "\""                                                                                                                    ) ,
    tqb4q(                           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "\"    \""                                                                                                              ) ,

    tHidden(                         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".hidden.ideafarm.com"                                                                                                  ) ,
    tWebHook1(                       tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                                                                      ) ,
    tWebHooks(                       tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                                                                      ) ,
    tDot(                            tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "."                                                                                                                     ) ,
    tDash(                           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "-"                                                                                                                     ) ,
    tb4(                             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "    "                                                                                                                  ) ,
    tPasswordPrefix(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                                                                                                                      ) ,
    tDotHiddenDotIdeafarmDotCom(     tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ".hidden.ideafarm.com"                                                                                                  ) ,
    inline gConstS( tin0S& tin0P , mySettingsS& mySettingsP ) :

    //U::6: textC tTarget                 ;

    textC tDotLetsEncryptDotOrg           ;

    textC tSayTraceMarkEnd                ;
    textC tSayTraceMarkBegin              ;
    textC tDomainGrossTraceMarkEnd        ;
    textC tDomainGrossTraceMarkBegin      ;

    textC tSayGranting                    ;
    textC tSayDiverting                   ;
    textC tSayUnknownDomain               ;
    textC tSayPrefix                      ;

    textC tSayReadSuffixFile              ;
    textC tSayReadingSuffixFile           ;

    textC tSayPushedDomain                ;
    textC tSayPushingDomain               ;
    textC tSayPushedPeer                  ;
    textC tSayPushingPeer                 ;
    textC tSayPushedJob                   ;
    textC tSayPushingJob                  ;
    textC tSayPurgedStacks                ;
    textC tSayPurgingStacks               ;
    textC tSayExCouldNotWriteReply        ;
    textC tSayWroteReply                  ;
    textC tSayReplying1                   ;
    textC tSayExCouldNotBuildReply        ;
    textC tSayReplying2                   ;
    textC tSayAAAARequest                 ;
    textC tSayARequest                    ;
    textC tSayExCouldNotReadPasswordFile  ;
    textC tSayWrotePasswordFile           ;
    textC tSaySettingNewPassword          ;
    textC tSayResettingDivert             ;
    textC tSayDomainNetSuffixPeer         ;
    textC tSayDomainGrossPeer             ;
    textC tSayLoweringCase                ;
    textC tSayPoppingQuery                ;
    textC tSayExCouldNotParse             ;
    textC tSayCalledDnsParse              ;
    textC tSayCallingDnsParse             ;
    textC tSayNotDiverting                ;
    textC tSayDiverting2                  ;
    textC tSayDiversionEnabled            ;
    textC tSayDiversionSuppressed         ;
    textC tSayDiversionSupRefreshed       ;
    textC tSayPeer                        ;
    textC tSayExReverseLookupFailed       ;
    textC tSayDoingReverseLookup          ;
    textC tSayExReadFailed                ;
    textC tSayCalledRead                  ;
    textC tSayCallingRead                 ;
    textC tSayWaitedForPacket             ;
    textC tSayWaitingForPacket            ;
    textC tSayInnerLoopBegun              ;

    textC tq                              ;
    textC tqb4q                           ;

    textC tHidden                         ;
    textC tWebHook1                       ;
    textC tWebHooks                       ;
    textC tDot                            ;
    textC tDash                           ;
    textC tb4                             ;
    textC tPasswordPrefix                 ;
    textC tDotHiddenDotIdeafarmDotCom     ;
{
struct gConstS

;
}
    inline boolT operator ~( voidT ) { return !!*this ; }
    boolT operator !( voidT                         ) ;
    voidT freshenF(   tin0S& tin0P                  ) ;
    mySettingsS(      tin0S& tin0P , etherC& etherP ) ;
    ~mySettingsS(     voidT                         ) ;

    countT       cnnSubnetTrusted            ;
    nicNameC*    pnnSubnetTrusted            ;

    countT       cDomainRootAllowed          ;
    textC* const pptDomainRootAllowed[ 8 ]   ;

    textC        tNnTrusted                  ;
    textC        tIpWebHook2                 ;
    textC        tIpWebHook1                 ;
    textC        tDomainLeafWebHook1Net      ;
    textC        tSuffixUsedByStripe         ;
    textC        tDomainLeafWebHooksNet      ;

    textC        tNetshCommandIpv4           ;

    grabC        grabMe                      ;

    public :

    voidT zapF( tin0S& tin0P ) ;

    textC        tDomainRootAllowed8         ;
    textC        tDomainRootAllowed7         ;
    textC        tDomainRootAllowed6         ;
    textC        tDomainRootAllowed5         ;
    textC        tDomainRootAllowed4         ;
    textC        tDomainRootAllowed3         ;
    textC        tDomainRootAllowed2         ;
    textC        tDomainRootAllowed1         ;

    textC        tNetshCommandIpv4SettingKey ;

    etherC&      etherMe                     ;

    private :
{
struct mySettingsS

;
}
    {}
    idp( 0 )
    cbq( 0 ) ,
    pbq( 0 ) ,
    inline jobS( voidT ) :

    {}
    nnPeer( nnPeerP )
    idp( idpP ) ,
    cbq( cbqP ) ,
    pbq( pbqP ) ,
    inline jobS( byteT* pbqP , countT cbqP , countT idpP , nicNameC& nnPeerP ) :
    NEWdELcLASSpROTOS

    nicNameC nnPeer ;
    countT   idp    ;
    countT   cbq    ;
    byteT*   pbq    ;
{
struct jobS

//U::6: CODE COMMENTED OUT THAT SUPPORTS AAAA (IPV6) REQUESTS

//  
// CERTBOT CANNOT BE USED TO RENEW A CERTIFICATE FOR THE LEAF DOMAIN, BECAUSE I DO NOT HAVE CERTBOT'S SERVERS ON MY ALLOWLIST
// I ASSUME THAT A "SHIELDS DOWN" FUNCTION IS NOT NEEDED BECAUSE THE DOMAIN NAME LEAF IS CHANGED FREQUENTLY
//  
//P:PERSONALITY: I KEEP IP ADDRESSES CONFIDENTIAL, BY TREATING THE REQUESTED DOMAIN NAME LEAF AS A PASSWORD, AND BY APPLYING AN ALLOWLIST TO nnPeer

// OBSOLETES 8a5_ (LIKE 8a5 BUT MULTITHREADED)

/*1*/WAKEhIDE( "ifcIDaDAM_DNS" )/*1*/

/**/
*/
 i simply map names (many to 1 and 1 to many) into ip addresses and tell the client to not cache
i do not use the canonical name concept
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
