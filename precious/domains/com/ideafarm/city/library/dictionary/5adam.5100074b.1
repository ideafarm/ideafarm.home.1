
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tinBaseP , T("ok") ) ;

}
    }
        //etThread.traceF( tinBaseP , T("napped") ) ;
        ++ s ; etThread.osSleepF( tinBaseP , TOCK << 2 ) ;
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        //etThread.traceF( tinBaseP , T("napping") ) ;

        if( bQuit ) break ;

        THREADmODE2rESTORE
        }
            }
                bPrefix = !bPrefix ;

                else          pbi = 0 ;
                if( bDelete ) PUSE( tinBaseP , *(byteT**)&pbi ) ;

                ;
                    : sizeof( countT )
                    ? *(countT*)pbi
                cbi = bPrefix

                }
                    }
                        #endif

                        etThread.delF( tinBaseP , psttBrowser ) ;
                        etThread.delF( tinBaseP , psttProtocol ) ;
                        etThread.delF( tinBaseP , psttQuery ) ;
                        etThread.delF( tinBaseP , psttUri ) ;
                        etThread.delF( tinBaseP , psttContainer ) ;
                        etThread.delF( tinBaseP , psttLogBucket ) ;
                        etThread.delF( tinBaseP , psttMethod ) ;

                        }
                            }
                                etThread.traceF( tinBaseP , T("[nnHe,time,method,bucket,container,uri,query,protocol,code,cb,browser]:    ")+tSay ) ;
                            
                                ;
                            
                                    +tb4+tBrowser
                                    +tb4+TF4(cbReply,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                                    +tb4+TF4(code,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)
                                    +tb4+tProtocol
                                    +tb4+tQuery
                                    +tb4+tUri
                                    +tb4+tContainer
                                    +tb4+tLogBucket
                                    +tb4+tMethod
                                    +tb4+TT(timeW1,timeW2)
                                    T(nnHe)
                            
                                TN( tSay , "" ) ; tSay =
                            
                                TN( tBrowser   , psttBrowser   ) ;
                                TN( tProtocol  , psttProtocol  ) ;
                                TN( tQuery     , psttQuery     ) ;
                                TN( tUri       , psttUri       ) ;
                                TN( tContainer , psttContainer ) ;
                                TN( tLogBucket , psttLogBucket ) ;
                                TN( tMethod    , psttMethod    ) ;
                            {

                            // A:ASSUME:  THIS CODE ASSUMES THAT EVENTS ARE UNIQUELY IDENTIFIED BY [hash,idJot,time,nn]; MULTIPLE EVENTS WILL RESULT IN MULTIPLE VALUES FOR THE FIELDS

                            etThread.traceF( tinBaseP , T(psttUri) ) ;

                            // *****************************************************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            // ********                         ********************************************************************************************************************************************************************************************************************
                            // ********  PROCESS WO BOOK ENTRY  ********************************************************************************************************************************************************************************************************************
                            // ********                         ********************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************
                            // *****************************************************************************************************************************************************************************************************************************************************

                            _IO_
                        {
                        else
                        if( getNegAM( finger ) != FINGERnEG_ACCESSeVENTrAW || idFormat != 1 ) etThread.traceF( tinBaseP , T("unexpected format [finger,idFormat]:    ")+TF2(finger,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idFormat,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        sBookEntryIn >> psttBrowser ;             ___( psttBrowser ) ;
                        sBookEntryIn >> cbReply ;
                        sBookEntryIn >> code ;
                        sBookEntryIn >> psttProtocol ;            ___( psttProtocol ) ;
                        sBookEntryIn >> psttQuery ;               ___( psttQuery ) ;
                        sBookEntryIn >> psttUri ;                 ___( psttUri ) ;
                        sBookEntryIn >> psttContainer ;           ___( psttContainer ) ;
                        sBookEntryIn >> psttLogBucket ;           ___( psttLogBucket ) ;
                        sBookEntryIn >> psttMethod ;              ___( psttMethod ) ;
                        sBookEntryIn >> nnHe ;
                        sBookEntryIn >> *(countT*)&timeW2 ;
                        sBookEntryIn >> timeW1 ;
                        sBookEntryIn >> idFormat ;
                        sBookEntryIn >> finger ;

                        ZE( strokeS* , psttBrowser   ) ;
                        ZE( countT   , cbReply       ) ;
                        ZE( countT   , code          ) ;
                        ZE( strokeS* , psttProtocol  ) ;
                        ZE( strokeS* , psttQuery     ) ;
                        ZE( strokeS* , psttUri       ) ;
                        ZE( strokeS* , psttContainer ) ;
                        ZE( strokeS* , psttLogBucket ) ;
                        ZE( strokeS* , psttMethod    ) ;
                        nicNameC       nnHe            ;
                        ZE( sCountT  , timeW2        ) ;
                        ZE( countT   , timeW1        ) ;
                        ZE( countT   , idFormat      ) ;
                        ZE( countT   , finger        ) ;

                        }
                            etThread.delF( tinBaseP , pbPageCopy ) ;
                            }
                                sBookEntryIn.shiftLeftF( tinBaseP , ifcIDtYPEsOULiTEM_soulC , pbPageCopy , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;

                                bksAccessEvents.unlockF( tinBaseP ) ;
                                etThread.memCopyF( tinBaseP , pbPageCopy , pbzPage , cbzPage ) ;
                                const byteT* pbzPage = pageEvent ;
                                bksAccessEvents.lockF( tinBaseP , TAG( TAGiDnULL ) ) ;
                            {
                            if( !POOP )

                            __Z( pbPageCopy ) ;
                            etThread.newF( tinBaseP , LF , pbPageCopy , cbzPage ) ; ___( pbPageCopy ) ;
                            ZE( byteT* , pbPageCopy ) ;                                                 //U:: WHY DO I NEED TO MAKE A COPY?

                            countT cbzPage = pageEvent ;
                        {
                        soulC sBookEntryIn( tinBaseP , TAG( TAGiDnULL ) ) ;

                        #if defined( NEVERdEFINED )

                        etThread.traceF( tinBaseP , T("ACCESSeVENTS6aUDITbOOKS / [idIn]:    ")+TF2(++idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( !ether )

                    _IO_

                    __( (countT)pageEvent - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;
                    {
                    if( !(const byteT*)pageEvent )        //SHOULD BE IMPOSSIBLE SINCE "ALL OR NONE" USED FOR WRITING BOOKTOGETHER AND I'VE ALREADY READ THE PREFIX

                    bksAccessEvents.readF( tinBaseP , pageEvent , hRead , flBOOKScrEAD_null/*PERSISTENTcURSOR*/ ) ;
                    pageC pageEvent( tinBaseP , bksAccessEvents , cbi ) ;
                {
                else
                }
                    __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;
                    {
                    if( !pbi )
                    bDelete = bksAccessEvents.readF( tinBaseP , pbi , cbi , hRead , flBOOKScrEAD_null/*PERSISTENTcURSOR*/ , &bQuit ) ;
                {
                if( bPrefix )
                ZE( boolT , bDelete ) ;

                HANDLEaPPnOTEScOUNTcLASS ch = hRead ;

                handleC hReadSave = hRead ;
                countT cbiSave = cbi ;
            {
            while( !bQuit && !bQuit2 && !POOP )
            ZE( countT , idIn ) ;
            boolT bPrefix = 1 ;
            countT cbi = sizeof( countT ) ;
            ZE( const byteT* , pbi ) ;

            // *****************************************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
            // ********                    *************************************************************************************************************************************************************************************************************************
            // ********  EAT BOOK ENTRIES  *************************************************************************************************************************************************************************************************************************
            // ********                    *************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
            // *****************************************************************************************************************************************************************************************************************************************************
        {
        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

        handleC hRead( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
        etThread.traceF( tinBaseP , T("ACCESSeVENTS6aUDITbOOKS / enering loop to read events") ) ;

        TN( tb4 , "    " ) ;
        booksC bksAccessEvents( tinBaseP , TAG( TAGiDnULL ) , "bksAccessEvents.1.raw" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_null , 0 , 1 , 0 , 0 , 0 , 0 , &bQuit ) ;
        etThread.traceF( tinBaseP , T("ACCESSeVENTS6aUDITbOOKS / ct bksAccessEvents") ) ;
    {
    while( !bQuit && !bQuit2 && !POOP )
    ZE( boolT , bQuit2 ) ;

    const boolT& bQuit = *(const boolT*)&(const countT&)ether ;
{

TODO


/*1*/WAKEhIDE( "tool.count.and.trace.access.events" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
