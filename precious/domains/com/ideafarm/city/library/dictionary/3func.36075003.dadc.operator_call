
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            }
                }
                    }
                        pb3 += cbSnip ;
                        ether.delF( tin0P , pbSnip ) ;
                        ether.memCopyF( tin0P , pb3 , pbSnip , cbSnip ) ;
                        stOut_cbSnip >> cbSnip ;
                        stOut_pbSnip >> pbSnip ;
                        ZE( countT , cbSnip ) ;
                        ZE( byteT* , pbSnip ) ;
                    {
                    while( stOut_pbSnip )
                    byteT* pb3 = pbP ;
                    cbP = cbAll ;
                    pbP[ cbAll ] = 0 ;
                {
                if( pbP )
                ether.newF( tin0P , LF , pbP , cbAll + 1 ) ; ___( pbP ) ;

                while( !stOut_cbSnip.third && ~hDown ) ;
                do cbAll += stOut_cbSnip.downF( tin0P , hDown ) ;
                handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , cbAll ) ;
            {
            if( stOut_cbSnip )
        {
        if( !ether && !bFail )
        __( stOut_cbSnip - stOut_pbSnip ) ;
        // pbP , cbP <- CONCATENATION OF SNIPPETS IN stOut_pbSnip

        }
            }
                pcSnip = pcSnipe ;

                stOut_cbSnip << cbSnip ;
                stOut_pbSnip << pbSnip ; pbSnip = 0 ;
                if( pbSnip ) for( countT off = 0 ; off < cbSnip ; off ++ ) pbSnip[ off ] = (*this)( tin0P , pcSnip[ off ] ) ;
                ether.newF( tin0P , LF , pbSnip , cbSnip ) ; ___( pbSnip ) ;
                ZE( byteT* , pbSnip ) ;

                countT cbSnip = pcSnipe - pcSnip ; //CANNOT BE 0
                //CONoUTrAW5( "[" , pcSnip-pcP , "," , pcSnipe , "]\r\n" ) ;
                while( pcSnipe < pcEnd && *pcSnipe ) pcSnipe ++ ; // pcSnipe NOW POINTS ETHER TO 0 OR TO THE END
                const count01T* pcSnipe = pcSnip + 1 ;
            {
            else
            }
                }
                    }
                        break ;

                        }
                            ether.delF( tin0P , pbIn ) ;
                            }
                                //stOut_cbSnip << cbIn ;
                                //stOut_pbSnip << pbIn ; pbIn = 0 ;
                                //PIN IMAGE IS PRESUMED TO BE UNWANTED (E.G. SRU VALUES)

                                for( countT off = 0 ; off < cbIn ; off ++ ) rememberF( tin0P , pbIn[ off ] ) ;
                            {
                            if( !ether )
                        {
                        else
                        }
                            ether.delF( tin0P , pbIn ) ;
                            }
                                stOut_cbSnip << cbSnip ;
                                stOut_pbSnip << pbSnip ; pbSnip = 0 ;
                                (*this)( tin0P , pbSnip , cbSnip , (const count01T*)pbIn , cbIn / sizeof( count01T ) ) ;
                                ZE( countT , cbSnip ) ;
                                ZE( byteT* , pbSnip ) ;
                            {
                            if( !ether )
                            __( cbIn % sizeof( count01T ) ) ;
                        {
                        else if( idCmd == (count01T)ifcIDcMDsPOUSE_INSERTnAMEDpILL )
                        }
                            break ;
                            bFail = 1 ;
                        {
                        if( !pbIn )

                        }
                            }
                                }
                                    //if( pcNameSave[ 3 ] == idbKEYpINtYPE_SOCKETcONNECTION ) { CONoUTrAW( T("dad: ")+TF1(cbIn)+T(" ")+tShort+T("\r\n") ) ; }
                                    ether.boxGetShadowF( tin0P , pbIn , cbIn , tLong , 1 ) ; ___( pbIn ) ;
                                {
                                else
                                //else                                                   { ether.boxGetShadowF( tin0P , pbIn , cbIn , tLong , 1 ) ; ___( pbIn ) ; }
                                if( idCmd == (count01T)ifcIDcMDsPOUSE_INSERTnAMEDpILL ){ ether.boxGetF(       tin0P , pbIn , cbIn , tLong , 1 ) ; ___( pbIn ) ; }
                            {
                            else
                            }
                                }
                                    if( POOP ) POOPR
                                    else                                                   { ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , pbIn , cbIn , tLong , 1 ) ; ___( pbIn ) ; }
                                    if( idCmd == (count01T)ifcIDcMDsPOUSE_INSERTnAMEDpILL ){ ((tin1S&)tin0P).pEtScratch->boxGetF(       tin0P , pbIn , cbIn , tLong , 1 ) ; ___( pbIn ) ; }
                                    SCOOPS
                                {
                                IFsCRATCH
                            {
                            if( bSilentFailP )

                            TN( tLong , "" ) ; tLong = T("///desk/" POSTfOLDERsECURITYkEYdEPOSITORY)+(idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/")+tShort ;
                            countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;
                            pcSnip += cczName ;
                            countT* pcNameSave = (countT*)pcSnip ; //U::
                            textC tShort( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , (countT*)pcSnip , flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE , 8 , 0 , tDot ) ;
                            TN( tDot , "." ) ;
                        {
                        ZE( countT , cbIn ) ;
                        ZE( byteT* , pbIn ) ;

                        if( cczName - cczNameVerify ) { BLAMMO ; } //U::
                        countT cczNameVerify = 2 * ( ether.strBodyLengthF( tin0P , (countT*)( ++ pcSnip ) ) + 1 ) ;
                        countT cczName = *( ++ pcSnip ) ;
                    {
                    case (count01T)ifcIDcMDsPOUSE_INSERTnAMEDpIN :
                    case (count01T)ifcIDcMDsPOUSE_INSERTnAMEDpILL :
                {
                switch( idCmd )
                const count01T idCmd = *( ++ pcSnip ) ;
                //CONoUTrAW3( "[" , pcSnip-pcP , "]\r\n" ) ;
            {
            if( !*pcSnip )
        {
        while( pcSnip < pcEnd && !bFail )
        ZE( boolT , bFail ) ;
        const count01T*       pcSnip = pcP ;
        const count01T* const pcEnd = pcP + ccP ;
        stackC stOut_cbSnip( tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;
        stackC stOut_pbSnip( tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_byteT ) ;
    {
    else
    }
        }
            pbP[ off ] = 0 ;
            for( countT off = 0 ; off < ccP ; off ++ ) pbP[ off ] = (*this)( tin0P , pcP[ off ] ) ;
        {
        if( pbP )
        ether.newF( tin0P , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
        cbP = ccP ;
    {
    if( off == ccP ) //INPUT DOES NOT CONTAIN ESCAPE SEQUENCES

    }
        if( !pcP[ off ] ) break ;
    {
    for( ; off < ccP ; off ++ )
    ZE( countT , off ) ;
    _IO_

    }
        if( ether ) return ;
        __Z( ccP ) ;
        __Z( pcP ) ;
        __( cbP ) ;
        __NZ( pbP ) ;
        if( ether ) return ;
    {
    IFbEcAREFUL    
{
/*1*/voidT dadC::operator ()( tin0S& tin0P , byteT*& pbP , countT& cbP , const count01T* const pcP , countT ccP , const boolT bSilentFailP )/*1*/

//MOTIVE: SO THAT CODE LIKE THAT OF socketC::readF CAN HANDLE INCOMING CODE STREAMS WITHOUT KNOWING THE ESCAPE CODE CMD LAYOUTS
// LAYOUT: 0 , idCmd , ccLength , clobOfThatLength
//S: EXTERNAL SPECIFICATION: ALL ESCAPE SEQUENCES MUST BE LENGTH PREFIXED

/**/
*/
  if i fail silently then pbP will remain 0
  if not 0 then i will fail silently when i cannot read a referenced pill or pin file
  normally is 0
 bSilentFailP
  must not be 0
 ccP
  must point to ccP count01T values
  must not be 0
 pcP
  must be 0
 cbP
  must be 0
 pbP
 tin0P
arguments
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

