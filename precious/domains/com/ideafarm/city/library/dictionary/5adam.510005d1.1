
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

CONoUTrAW( "ok\r\n" ) ;

THREADmODE2rESTORE
}
    }
        }
            }
                else       etThread.osThreadF( TaRG1( tmListServeF ) , (countT)pso , (countT)&puseMaster , (countT)&puseHelper ) ;
                if( POOP ) { DEL( pso ) ; }
                __( bRefuse ) ;
                socket.acceptF( tin0P , pso , idPortPeer , nnPeer , bRefuse ) ; ___( pso ) ;
                ZE( boolT , bRefuse ) ;
                ZE( countT , idPortPeer ) ;
                nicNameC nnPeer ;
                ZE( socketC* , pso ) ;
            {
            while( !ether && !POOP )
    
            if( idCycle == 1 ) etThread.osThreadF( TaRG1( tmLoadHelperF ) , (countT)&puseMaster , (countT)&puseHelper ) ;
    
            socket.listenF( tin0P ) ;
            homeS::homeIF().idPortListServerEmailIdAccount = socket.bindF( tin0P ) ;
            socketC socket( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
    
            ++ idCycle ;
        {
        while( !ether )
        ZE( countT , idCycle ) ;
    {
    IFsCRATCH
    
    puseC puseWork2( tin0P , ifcIDpOOL_ADAMtEMP ) ;
    puseC puseMaster( tin0P , "list.idAccount.to.email" , flPOOLc_null , ifcIDsTATEsPACE_SINGLEaDAM( tin0P ) ) ;
    puseC puseWork1( tin0P , ifcIDpOOL_ADAMtEMP ) ;
    puseC puseHelper( tin0P , "list.email.to.idAccount" ) ;
    _IO_
{
THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

TODO

DONE( tmLoadHelperF )
}
    /*PROD*/ ether.osThreadAdamF( tin0P , ifcIDaDAM_LISTsERVERiDaCCOUNTdESCRIPTION ) ; //PRODUCTION

    //etThread.osThreadF( TaRG1( tmTestQueryF ) ) ;

    }
        CONoUTrAW( T("with email     get [idAccount,email]: ")+TF3(idAccount,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+T(" \"")+tEmail+T("\"\r\n") ) ;
    
        sIn >> idAccount ;
        ZE( countT , idAccount ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tin0P , sIn ) ;
        soulC sIn( tin0P , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tin0P , sOut ) ;
        sOut << (strokeS*)tEmail ;
        sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKiDaCCOUNTfROMeMAIL ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tin0P , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tin0P , homeS::homeIF().idPortListServerEmailIdAccount ) ;
        socketC sock( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
    
        TN( tEmail , "9bn.3vho@gmail.com" ) ;
    {
    //ENSURE THAT MY ACCOUNT IS DEFINED, EVEN IF I ZAP ALL LISTS ON DEVELOPMENT MACHINE

    THREADmODE2rESTORE
    }
        PUSE.listOld2012F( tin0P , count2S( LISTnAMEsYS_ROOTaPPLICATION ) , ifcIDhOWlIST_FIFO , 0 , 0 , listingInspect_ad5_chatterHelper_CBF ) ;
        puseC puseh( puseHelperP ) ;
    {

    }
        POPtINaRGS
        listC::walkIF( tin0P , count2S( LISTnAMEsYS_ROOTaPPLICATION ) ) ; //U::FUNCTION CHANGED: THE OLD CODE WALKED FIFO
        ((tin123S&)tin0P).ta.pushed.u.listWalk.util.pcP[ 0 ] = (countT)&puseHelperP  ;
        ((tin123S&)tin0P).ta.pushed.u.listWalk.walk.flagsWalkP |= flLISTwALK_null ;
        ((tin123S&)tin0P).ta.pushed.u.listWalk.walk.pListWalkCBFP = listingInspect_ad5_chatterMaster_CBF  ;
        PUSHtINaRGS

        puseC pusem( puseMasterP ) ;
    {
    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

    }
        ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    {
    while( !homeS::homeIF().idPortListServerEmailIdAccount )

    if( tin0P.idTypeTin - ifcIDtYPEtIN_123 ) { BLAMMOiD( tin0P.idTypeTin - ifcIDtYPEtIN_123 ) ; }

    puseC& puseHelperP =  *(puseC*)pTaskP->c2 ;
    puseC& puseMasterP =  *(puseC*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 )
TASK( tmLoadHelperF )

#endif
DONE( tmTestQueryF )
}
    }
        CONoUTrAW( T("with idAccount get [idAccount,email]: ")+TF3(idAccount,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+T(" \"")+T(psttEmail)+T("\"\r\n") ) ;
    
        sIn >> psttEmail ; ___( psttEmail ) ;
        ZE( strokeS* , psttEmail ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tin0P , sIn ) ;
        soulC sIn( tin0P , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tin0P , sOut ) ;
        sOut << idAccount ;
        sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKeMAILfROMiDaCCOUNT ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tin0P , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tin0P , homeS::homeIF().idPortListServerEmailIdAccount ) ;
        socketC sock( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
    {
    for( countT idAccount = 1 ; idAccount <= 1 ; idAccount ++ )
{
if( pTaskP )
TASK( tmTestQueryF )
#if defined( NEVERdEFINED )

#endif
DONE( tmTestQueryF )
}
    }
        CONoUTrAW( T("with tEmail get [idAccount,email]: ")+TF3(idAccount,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+T(" \"")+tEmail+T("\"\r\n") ) ;
    
        sIn >> idAccount ;
        ZE( countT , idAccount ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tin0P , sIn ) ;
        soulC sIn( tin0P , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tin0P , sOut ) ;
        sOut << (strokeS*)tEmail ;
        sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKiDaCCOUNTfROMeMAIL ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tin0P , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tin0P , homeS::homeIF().idPortListServerEmailIdAccount ) ;
        socketC sock( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;

        TN( tEmail , "123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0" ) ;
    {
    for( countT idAccount = 1 ; idAccount <= 1 ; idAccount ++ )
{
if( pTaskP )
TASK( tmTestQueryF )
#if defined( NEVERdEFINED )

}
    return heavy ;

    }
        }
            }
                }
                    break ;
                    }
                        }
                            break ;
                            }
                                PUSE( tin0P , postEmail ) ;
                                CONoUTrAW( T("HELPER| idAccount: ")+TF3(idAccount,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T(" ; email: \"")+T(postEmail)+T("\"\r\n") ) ;
                                etherC::strSquishIF( tin0P , postEmail , pcStretched , ccStretched ) ; ___( postEmail ) ;
                                ZE( osTextT* , postEmail ) ;
                                puseC puseat( tin0P , ifcIDpOOL_ADAMtEMP ) ;

                                countT idAccount = *(countT*)Ac OUNT ;
                                countT  ccStretched = thirdC::c_strlenIF( tin0P , pcStretched ) ;
                                const countT* pcStretched = pczListNameP + 1 ;
                            {
                        {
                        case ifcIDtYPEmIXINdATUM_countT : //listing_countT_C
                    {
                    switch( pdListing->idTypeDatumF() )
                {
                case fliLISTINGc_MIXINdATUM :
                }
                    break ;

                    }
                        PUSE( tin0P , *(byteT**)&pczListNameKid ) ;
                        puseC puseat( tin0P , ifcIDpOOL_ADAMtEMP ) ;
                    {

                    }
                        argP.flagsWalk = flagsSave ;

                        aList.walkOldF( tin0P , ifcIDmODEaPTsINK_LEADsHOES , &argP , 0 , listingInspect_ad5_chatterHelper_CBF , pczListNameKid ) ;

                        argP.flagsWalk |= flLISTwALKoLD_DOnOTuNGRABlIST ;
                        flagsT flagsSave = argP.flagsWalk ;
    
                        pczListNameKid[ ccDad    ] = 0 ;
                        pczListNameKid[ ccDad ++ ] = A lIST.idNameF() ;
                        thirdC::c_memcpyIF( tin0P , (byteT*)pczListNameKid , (byteT*)pczListNameP , sizeof( countT ) * ccDad ) ;
                            
                    {
                    if( pczListNameKid )

                    }
                        pczListNameKid = (countT*)PUSE.newF( tin0P , LF , sizeof( countT ) * ( ccDad + 2 ) ) ; ___( pczListNameKid ) ;
                        puseC puseat( tin0P , ifcIDpOOL_ADAMtEMP ) ;
                    {
                    ZE( countT* , pczListNameKid ) ;
                    countT ccDad = thirdC::c_strlenIF( tin0P , pczListNameP ) ;
                    
                    listC& aList = A lIST ;
                {
                case fliLISTINGc_MIXINlIST : // listC
            {
            switch( pdListing->flagsF() & fliLISTINGc_maskMIXINbITS )
        {
        if( !POOP )

        __( !listingC::bIsListingIF( tin0P , aptP ) ) ;
        listingC* pdListing = &APT( listingC , aptP ) ;
    {
    if( aptP )
    ZE( sCountT , heavy ) ;

    _IO_

    if( POOP ) return 0 ;
{
sCountT listingInspect_ad5_chatterHelper_CBF( tin0S& tin0P , aptC& aptP , listWalkArgOldS& argP , const countT* pczListNameP )

}
    return heavy ;

    }
        }
            }
                }
                    break ;
                    }
                        }
                            break ;

                            if( bDelete ) listingC::deleteOldIF( tin0P , aptP , argP.cValueTestSpec , argP.pStk_aptPrune ) ;

                            }
                                PUSE( tin0P , *(byteT**)&pczEmail ) ;
                                }
                                    if( idAccountVerify != idAccount ) bDelete = 1 ;
    
                                    THREADmODE2rESTORE
                                    //CONoUTrAW3( "STORED  idAcc " , idAccount , " into helper file using postzEmail as list name\r\n" ) ;
                                    }
                                        idAccountVerify = PUSE.list_countT_Old2012F( tin0P , pczEmail , idAccount ) ;
                                        puseC puseHelper( *(puseC*)argP.pc Utility[ 0 ] ) ;
                                    {
                                    //CONoUTrAW3( "STORING idAcc " , idAccount , " into helper file using postzEmail as list name\r\n" ) ;
                                    THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )
                                    ZE( countT , idAccountVerify ) ;
            
                                    //CONoUTrAW( T(pczEmail)+T("\r\n") ) ;
                                    etherC::strStretchIF( tin0P , pczEmail , count2S( LISTnAMEsYS_ROOTaPPLICATION ) , postzEmail ) ;
                                    pczEmail[ offo ] = 0 ;
                                    for( countT offo = 0 ; offo < ccHelper ; offo ++ ) pczEmail[ offo ] = LISTnAMEsYS_PLACEhOLDER ;
                                {
                                if( pczEmail )
                                countT* pczEmail = (countT*)PUSE.newF( tin0P , LF , sizeof( countT ) * ( ccHelper + 1 ) ) ; ___( pczEmail ) ;
                                const countT ccHelper = 1 + thirdC::c_strlenIF( tin0P , postzEmail ) ;
    
                                CONoUTrAW( T(/*DASH127 "\r\n" DASH127 "\r\n"*/ "MASTER| idAccount: ")+TF3(idAccount,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T(" ; email: \"")+T(postzEmail)+T("\"\r\n") ) ;
                                etherC::strSquishIF( tin0P , idAccount , pcStretched ) ;
                                ZE( countT , idAccount ) ;
    
                                puseC puset( tin0P , ifcIDpOOL_ADAMtEMP ) ;
                            {
                            ZE( boolT , bDelete ) ;

                            thirdC::c_strlwrIF( tin0P , postzEmail ) ; //U::REMOVE AFTER ELIMINATED ALL SOURCES OF MIXED CASE OR UPPER CASE VALUES

                            osTextT*      postzEmail  = (osTextT*)Ao StEXT ;
                            countT        ccStretched = thirdC::c_strlenIF( tin0P , pcStretched ) ;
                            const countT* pcStretched = pczListNameP + 1 ;
                        {
                        case ifcIDtYPEmIXINdATUM_blob : //listing_blob_C
                    {
                    switch( pdListing->idTypeDatumF() )
                {
                case fliLISTINGc_MIXINdATUM :
                }
                    break ;

                    }
                        PUSE( tin0P , *(byteT**)&pczListNameKid ) ;
                        puseC puseat( tin0P , ifcIDpOOL_ADAMtEMP ) ;
                    {

                    }
                        argP.flagsWalk = flagsSave ;

                        aList.walkOldF( tin0P , ifcIDmODEaPTsINK_LEADsHOES , &argP , 0 , listingInspect_ad5_chatterMaster_CBF , pczListNameKid ) ;

                        argP.flagsWalk |= flLISTwALKoLD_DOnOTuNGRABlIST ;
                        flagsT flagsSave = argP.flagsWalk ;
    
                        pczListNameKid[ ccDad    ] = 0 ;
                        pczListNameKid[ ccDad ++ ] = A lIST.idNameF() ;
                        thirdC::c_memcpyIF( tin0P , (byteT*)pczListNameKid , (byteT*)pczListNameP , sizeof( countT ) * ccDad ) ;
                    {
                    if( pczListNameKid )

                    }
                        pczListNameKid = (countT*)PUSE.newF( tin0P , LF , sizeof( countT ) * ( ccDad + 2 ) ) ; ___( pczListNameKid ) ;
                        puseC puseat( tin0P , ifcIDpOOL_ADAMtEMP ) ;
                    {
                    ZE( countT* , pczListNameKid ) ;
                    countT ccDad = thirdC::c_strlenIF( tin0P , pczListNameP ) ;
                    
                    listC& aList = A lIST ;
                {
                case fliLISTINGc_MIXINlIST : // listC
            {
            switch( pdListing->flagsF() & fliLISTINGc_maskMIXINbITS )
        {
        if( !POOP )

        __( !listingC::bIsListingIF( tin0P , aptP ) ) ;
        listingC* pdListing = &APT( listingC , aptP ) ;
    {
    if( aptP )
    ZE( sCountT , heavy ) ;

    _IO_

    if( POOP ) return 0 ;
{
sCountT listingInspect_ad5_chatterMaster_CBF( tin0S& tin0P , aptC& aptP , listWalkArgOldS& argP , const countT* pczListNameP )






        }
            return threadLocalStorage123F( ifcIDtYPEtLS_KID , tmListServeF_workF , (countT)argP , 0 , 0 , 0 , 0 , "tmListServeF" ) ;
        {
        TASKpART0PROTO( tmListServeF )


        DONEpART1
        }
            }
                dec02AM( cAllThreads ) ; /* MUST BE THE VERY LAST THING THAT THIS THREAD DOES */
                if( !bFake ) { DEL( pTaskP ) ; } /* MUST BE AS LATE AS POSSIBLE BECAUSE IT GIVES THE SIGN THAT THE THREAD IS DONE.  THE PROCESS MUST SLEEP AFTER RECEIVING THIS SIGN BEFORE ENDING, SO THAT THIS THREAD CAN COMPLETE */
                if( ((tin1S&)tin0P).glass.idThread <= ClOWtHREADS ) processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tin1S&)tin0P).glass.idThread ] = - 1 ;
                TELL( "DONEpART0: i am outa here" )
                ;
                    : thirdC::os_cAllKidThreadsI_IF( tin0P )
                    ? thirdC::os_cAllOrphanThreadsI_IF( tin0P )
                countT& cAllThreads = bOrphan
                boolT bFake   = pTaskP ? !!( F(pTaskP->flags) & flTHREADlAUNCH_FAKE   ) : 0 ;
                boolT bOrphan = pTaskP ? !!( F(pTaskP->flags) & flTHREADlAUNCH_ORPHAN ) : 0 ;
                TELL( "DONEpART0: deregistering myself from either cAllOrphanThreadsI or cAllKidThreadsI (my final act)" )
                TINSL /*THIS IS NEEDED BECAUSE tin0P WAS DELETED IF I AM tmWindowsF */
            {
            if( pEtThread ) *pEtThread = 0 ;

            }
                }
                    }
                        }
                            TELL( "DONEpART0: after deleting pEtThread, which destroys tin0P in poolOld" )
                            if( pEtThread ) { BLAMMO ; }
                            PUSE( tin0P , *(byteT**)&pEtThread ) ;
                            TINSL
                        {
                        }
                            DELzOMBIE( pDoomed ) ; /* tin0P IS DESTROYED HERE */
                            etherC* pDoomed = pEtThread ;
                        {
                        DEL( ((tin1S&)tin0P).pEtScratch ) ;
                        DEL( ((tin1S&)tin0P).pScoopEtThread ) ; /*CODEsYNC: 0010056 1020171 */
                        TELL( "DONEpART0: deleting etThread (and tin0P)" ) ;
                        ((tin1S&)tin0P).pEther = 0 ;
                        TELL( "DONEpART0: testing poolOld" ) ;

                        }
                            ((tin1S&)tin0P).pEtScratch->delF( tin0P , psttThreadFile ) ;
                            ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , psttThreadFile ) ;
                            TELL( "DONEpART0: deleting thread file" ) ;
                        {
                        if( psttThreadFile )
                    {
                    if( pEtThread ) /*THREADS THAT DELETE etThread EARLY: tmWindowsF*/
                    TINSL /*THIS IS NEEDED BECAUSE tin0P WAS DELETED IF I AM tmWindowsF */
                {

                }
                    }
                        if( ((tin1S&)tin0P).glass.idThread <= ClOWtHREADS && !( ++ processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tin1S&)tin0P).glass.idThread ] ) ) { BLAMMO ; }
                        if( ((tin1S&)tin0P).idPhase1 < ifcIDpHASEtHREAD_EPILOGnOkIDS ) ((tin1S&)tin0P).idPhase1 = ifcIDpHASEtHREAD_EPILOGnOkIDS ;
                        }
                            TELL( "DONEpART0: destroying all adam objects that remain on the thread stack" ) ;
                            }
                                while( ((tin1S&)tin0P).cKidThreads ) { ++ s ; thirdC::dosSleepRawIF( tin0P , 250 ) ; }
                                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                            {
                            TELL( "DONEpART0: waiting for my kid threads to end" ) ;

                            if( F(thirdC::third_flagsModeAdam1I_IF(tin0P)) & flADAMmODE1_WHEREaLL && !( F(((tin123S&)tin0P).where.flagsThreadModeWhere) & flTHREADmODEwHERE_NOwHERE ) ) etThread.etherWhereF( tin0P , ifcIDaCTIONwHERE_UNWATCH ) ;
                            TELL( "DONEpART0: conditionally calling etherWhereF" ) ;
                        {
                        else
                        if( !pEtThread ) ; /*THIS IS NEEDED BECAUSE tin0P WAS DELETED IF I AM tmWindowsF */

                        TELL( "DONEpART0: after returning from application code" ) ;
                        ((tin1S&)tin0P).idPhase2 = 0 ;
                        if( ((tin1S&)tin0P).idPhase1 < ifcIDpHASEtHREAD_EPILOGkIDS ) ((tin1S&)tin0P).idPhase1 = ifcIDpHASEtHREAD_EPILOGkIDS ;
                        if( ((tin1S&)tin0P).glass.idThread <= ClOWtHREADS && !( ++ processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tin1S&)tin0P).glass.idThread ] ) ) { BLAMMO ; }
                        TINSL /*THIS IS NEEDED BECAUSE tin0P WAS DELETED IF I AM tmWindowsF */
                    {
                    /*DO NOT CLOSE THE CODE BLOCK HERE BECAUSE KID THREADS MIGHT BE USING OBJECTS THAT WOULD DT HERE*/
                                                                                                                                                                    \






//U::DONE( tmListServeF )

}
    }
        DEL( psoP ) ;
        if( POOP ) POOPR

        }
            psoP->writeF( tin0P , sOut ) ;
            }
                }
                    break ;
                    __1 ;
                    __( idCmd ) ;
                {
                default :
                }
                    break ;

                    DELlIST( fieldEditParamOutC , pOutMaster ) ;
                    puseC puseAT( tin0P , ifcIDpOOL_ADAMtEMP ) ;     //20240807@1521: ADDED W/O ANALYSIS OR TESTING
                    if( !POOP ) sOut << ( postzEmail ? (strokeS*)T(postzEmail) : (strokeS*)0 ) ;

                    if( !POOP && pOutMaster && pOutMaster->spBlob ) postzEmail = pOutMaster->spBlob ;
                    ZE( const osTextT* , postzEmail ) ;

                    }
                        PUSE( tin0P , *(byteT**)&pczIdAccount ) ;
                        }
                            THREADmODE2rESTORE
                            }
                                }
                                    listC::fieldIF( tin0P , pOutMaster , hList , pczField ,  _fe_queryC() , LF ) ; ___( pOutMaster ) ;
                                    countT pczField[] = { /*postEmail*/0x87654321 , 0 } ;
                                            
                                    listC::openIF( tin0P , hList , pczIdAccount ) ;
                                    handleC hList( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                        
                                    grabitC grabitx( tin0P , TAG( TAGiDnULL ) ) ;
                                {

                                puseC puseMaster( puseMasterP ) ;
                            {
                            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                            //CONoUTrAW( T(pczIdAccount)+T("\r\n") ) ;
                            etherC::strStretchIF( tin0P , pczIdAccount , count2S( LISTnAMEsYS_ROOTaPPLICATION ) , idAccount ) ;
                            pczIdAccount[ offo ] = 0 ;
                            for( countT offo = 0 ; offo < ccMaster ; offo ++ ) pczIdAccount[ offo ] = LISTnAMEsYS_PLACEhOLDER ;
                        {
                        if( pczIdAccount )
                        countT* pczIdAccount = (countT*)PUSE.newF( tin0P , LF , sizeof( countT ) * ( ccMaster + 1 ) ) ; ___( pczIdAccount ) ;
                        const countT ccMaster = 1 + sizeof idAccount ;
                    {
                    if( idAccount )
                    ZE( fieldEditParamOutC* , pOutMaster ) ;

                    sIn >> idAccount ; //I WILL RETUIRN 0 FOR EMAIL IF IDACCOUNT DOES NOT EXIST; I WILL NEVER CREATE AN ACCOUNT
                    ZE( countT , idAccount ) ;
                    _IO_
                {
                case ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKeMAILfROMiDaCCOUNT :
                }
                    break ;

                    if( !POOP ) sOut << idAccount ;

                    }
                        PUSE( tin0P , *(byteT**)&pczEmail ) ;
                        }
                            THREADmODE2rESTORE
                            }
                                }
                                    DELlIST( fieldEditParamOutC , pOutMaster ) ;
                                    puseC puseAT( tin0P , ifcIDpOOL_ADAMtEMP ) ;     //20240807@1521: ADDED W/O ANALYSIS OR TESTING
                                {
                                //DELlIST( fieldEditParamOutC , pOutMaster ) ;

                                }
                                    }
                                        }
                                            __1
                                            CONoUTrAW( T("[helper,new] : \"")+T(postzEmail)+T("\" \"")+tEmail+T("\"\r\n") ) ;
                                            LOGrAW( T("[helper,master] : \"")+T(postzEmail)+T("\" \"")+tEmail+T("\"\r\n") ) ;
                                            LOGrAW( "EXCEPTION: a new idAccount value was dispensed for an email, but that new idAccount value already existed in the master list, so the master was not modified:\r\nthis leaves the master and helper in an inconsistent state\r\n" ) ;
                                        {
                                        if( thirdC::c_strcmpIF( tin0P , postzEmail , tEmail ) )
                                    {
                                    if( !POOP )
                                    __Z( postzEmail ) ;
                                    const osTextT* postzEmail = pOutMaster->spBlob ;
                                {
                                if( !POOP )
                
                                PUSE( tin0P , *(byteT**)&pczIdAccount ) ;
                                }
                                    }
                                        __Z( pOutMaster ) ;
                                        flagsT flagsRC = listC::fieldIF( tin0P , pOutMaster , hList , pczField , _fe_modePushIfNotExistC() | _fe_pushC( (osTextT*)tEmail ) | _fe_modeQueryNewC() |  _fe_queryC() , LF ) ; ___( pOutMaster ) ;
                                        countT pczField[] = { /*postEmail*/0x87654321 , 0 } ;
                                            
                                        listC::openIF( tin0P , hList , pczIdAccount ) ;
                                        handleC hList( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                        
                                        grabitC grabitx( tin0P , TAG( TAGiDnULL ) ) ;
                                    {

                                    puseC puseMaster( puseMasterP ) ;
                        
                                    //CONoUTrAW( T(pczIdAccount)+T("\r\n") ) ;
                                    etherC::strStretchIF( tin0P , pczIdAccount , count2S( LISTnAMEsYS_ROOTaPPLICATION ) , idAccount ) ;
                                    pczIdAccount[ offo ] = 0 ;
                                    for( countT offo = 0 ; offo < ccMaster ; offo ++ ) pczIdAccount[ offo ] = LISTnAMEsYS_PLACEhOLDER ;
                                {
                                if( pczIdAccount )
                                ZE( fieldEditParamOutC* , pOutMaster ) ;
                                countT* pczIdAccount = (countT*)PUSE.newF( tin0P , LF , sizeof( countT ) * ( ccMaster + 1 ) ) ; ___( pczIdAccount ) ;
                                const countT ccMaster = 1 + sizeof idAccount ;
                                puseC puseat( tin0P , ifcIDpOOL_ADAMtEMP ) ;
                            {
                            if( bNew ) // IF WASN'T ON THE HELPER LIST THEN ADD THIS ACCOUNT TO THE MASTER LIST

                            }
                                }
                                    DELlIST( fieldEditParamOutC , pOutHelper ) ;
                                    puseC puseAT( tin0P , ifcIDpOOL_ADAMtEMP ) ;     //20240807@1521: ADDED W/O ANALYSIS OR TESTING
                                {
                                //DELlIST( fieldEditParamOutC , pOutHelper ) ;
                                }
                                    }
                                        if( !POOP ) idAccount = *pczIdAccount ;
                                        __Z( pczIdAccount ) ;
                                        const countT* pczIdAccount = pOutHelper->spCount ;
                                    {
                                    if( !POOP )
                                    __( !pOutHelper->spCount ) ;
                                {
                                if( !POOP )

                                }
                                    __Z( pOutHelper ) ;
                                    bNew = !!( F(flLISTwALKrETURNcODE_NEWlISTING) & listC::fieldIF( tin0P , pOutHelper , hList , pczField , _fe_modePushIfNotExistC() | _fe_pushIdSerialC( "idAccount" ) | _fe_modeQueryNewC() |  _fe_queryC() ) , LF ) ; ___( pOutHelper ) ;
                                    countT pczField[] = { /*U::idAccount*/0x87654321 , 0 } ;
                        
                                    listC::openIF( tin0P , hList , pczEmail ) ;
                                    handleC hList( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
    
                                    grabitC grabitx( tin0P , TAG( TAGiDnULL ) ) ;
                                {
                                ZE( fieldEditParamOutC* , pOutHelper ) ;
    
                                puseC puseHelper( puseHelperP ) ;
                            {
                            ZE( boolT , bNew ) ;
                            THREADmODE2oN( flTHREADmODE2_UNLOCKpOOLiDENTITY )

                            //
                            // THE FOLLOWING CODE EXERCISES THE QUERY CALLS THAT WILL BE NEEDED, BUT ASSUMES THAT I AM THE ONLY CELL
                            //
                            //  IF UNK, QUERY THE PREFERRED CELL, ALLOWING IT TO ATTACH
                            //  IF UNK, QUERY ALL OTHER CELLS, SPECIFYING "NO ATTACH"
                            //  QUERY THE PREFERRED CELL, SPECIFYING "NO ATTACH"
                            //  IDENTIFY THE "PREFERRED" CELL FOR THAT EMAIL ADDRESS (USING E.G. A HASH MAPPING OR SIMPLY A HARDCODED IDENTITY) AT ANY GIVEN TIME, THE MAPPING MUST BE DETERMINATE; ALL CELLS WILL MAP TO THE SAME PREFERRED CELL
                            //
                            // RECIPE
                            //
                            // WHEN THERE ARE MULTIPLE CELLS, THE CELL THAT RECIEVES A REQUEST FROM APPLICATION CODE MUST COORDINATE WITH ALL OTHER CELLS, AS FOLLOWS
                            // I AM A SINGLE CELL OF A POTENTIALLY MULTICELL LIST SERVER FOR THIS DATA

                            //CONoUTrAW( T(pczEmail)+T("\r\n") ) ;
                            etherC::strStretchIF( tin0P , pczEmail , count2S( LISTnAMEsYS_ROOTaPPLICATION ) , tEmail ) ;
                            pczEmail[ offo ] = 0 ;
                            for( countT offo = 0 ; offo < ccHelper ; offo ++ ) pczEmail[ offo ] = LISTnAMEsYS_PLACEhOLDER ;
                        {
                        if( pczEmail )
                        countT* pczEmail = (countT*)PUSE.newF( tin0P , LF , sizeof( countT ) * ( ccHelper + 1 ) ) ; ___( pczEmail ) ;
                        const countT ccHelper = 1 + tEmail.csF( tin0P ) ;
                    {
                    if( tEmail.csF( tin0P ) )
                    ZE( countT , idAccount ) ;

                    etThread.delF( tin0P , psttEmail ) ;
                    TN( tEmail , "" ) ; tEmail = T(psttEmail) ;
                    if( psttEmail ) etThread.strConvertToLowerCaseF( tin0P , psttEmail ) ;
                    sIn >> psttEmail ; ___( psttEmail ) ;
                    ZE( strokeS* , psttEmail ) ;
                    _IO_
                {
                case ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKiDaCCOUNTfROMeMAIL :
            {
            switch( idCmd )

            sOut << (countT)1 ; //idFormat
            sOut << (countT)FINGERnEG_LISTsERVERrEPLY ;
            soulC sOut( tin0P , TAG( TAGiDnULL ) ) ;

            sIn >> idCmd ;
            ZE( countT , idCmd ) ;

            __( idFormat - 1 ) ;
            sIn >> idFormat ;
            ZE( countT , idFormat ) ;

            __( finger - FINGERnEG_LISTsERVERcMD ) ;
            sIn >> finger ;
            ZE( countT , finger ) ;

            psoP->readF( tin0P , sIn ) ;
            soulC sIn( tin0P , TAG( TAGiDnULL ) ) ;
            _IO_
        {
        while( !ether && !POOP )

        psoP->etherF( tin0P , *((tin1S&)tin0P).pEtScratch ) ;
        SCOOPS
    {
    IFsCRATCH

    puseC&    puseHelperP =  *(puseC*)pTaskP->c3 ;
    puseC&    puseMasterP =  *(puseC*)pTaskP->c2 ;
    socketC*  psoP      = (socketC*)pTaskP->c1 ;
    TELL( "setting up" )
    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmListServeF )

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_LISTsERVEReMAILiDaCCOUNT" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

