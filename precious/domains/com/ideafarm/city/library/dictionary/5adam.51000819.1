
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("ok") ) ;

//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
#endif
}
    jotFiles.reportF( tinBaseP ) ;

//                       jotFiles.writeF( tinBaseP , "f2br1p2" , 0 , 0 , 0 , idjSoilRoot , flJOTfILEScwRITE_APPENDpART  , 0 , 0x5555 , 0x11111111 ) ;

//                       jotFiles.writeF( tinBaseP , "f2br1p1" , 0 , 0 , 0 , idjSoilRoot , flJOTfILEScwRITE_REPLACEfILE , 0 , 0x4444 , 0x11111111 ) ;

                         jotFiles.writeF( tinBaseP , "f1br2p1" , 0 , 0 , 0 , idjSoilRoot , flJOTfILEScwRITE_null        , 0 , 0x3333 , 0x11111111 ) ;

//                       jotFiles.writeF( tinBaseP , "f1br1p2" , 0 , 0 , 0 , idjSoilRoot , flJOTfILEScwRITE_APPENDpART  , 0 , 0x2222 , 0x11111111 ) ;

    countT idjSoilRoot = jotFiles.writeF( tinBaseP , "f1br1p1" , 0 , 0 , 0 , 0           , flJOTfILEScwRITE_null        , 0 , 0x1111 , 0x11111111 ) ;

    jotFilesC jotFiles( tinBaseP , "foo" , flJOTc_WRITE ) ;
    tlsAllocStackExp_a_C tls( tinBaseP ) ;
{
#if defined( NEVERdEFINED )
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************
//**********************************************************************************************************************************************************************************************

DEL( pJotSortedShort ) ;

}
    }
        }
            }
                }
                    }
                        if( !pbw || !cbw ) break ;

                        }
                            bWoth = 0 ;
//((tinFullS&)tinBaseP).pc Utility[ 0 ] -- ; //U:: TO FIND A BUG
                            idjSoilRoot = archive.writeToNameF( tinBaseP , tPrefixMe+tDot+tType , 0 , pbw , cbw , 0 , 0 , bWoth ? flJOTfILEScwRITE_ALLoRsOME : flJOTfILEScwRITE_ALLoRsOME | flJOTfILEScwRITE_APPENDpART  , 0 , 0x2222 , 0x11111111 ) ;
//((tinFullS&)tinBaseP).pc Utility[ 0 ] ++ ; //U:: TO FIND A BUG
                            //etThread.traceF( tinBaseP , T("file window [cbw]:    ")+TF4(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0x10,0xa)+tb4+tShort ) ;
                        {
                        if( bWoth || ( pbw && cbw ) )

                        fwsIn.getF( tinBaseP , pbw , cbw ) ;
                        ZE( countT , cbw ) ;
                        ZE( byteT* , pbw ) ;
                    {
                    while( !ether )
                    boolT bWoth = 1 ;

                    fileWindowsC fwsIn( tinBaseP , etThread , tPathIn+tShort ) ;
                {
                ZE( countT , idjSoilRoot ) ;
            {
            if( bData )

            }
                tPrefix = tPrefixMe ;
                //else etThread.traceF( tinBaseP , T("prefix has changed") ) ;
                }
                    __1
                    etThread.traceF( tinBaseP , T("!exception: prefix has changed and file is meta not data") ) ;
                {
                if( !bData )
            {
            if( etThread.strCompareF( tinBaseP , tPrefixMe , tPrefix ) )

            if( !tPrefix.csF( tinBaseP ) ) tPrefix = tPrefixMe ;

            }
                etThread.delF( tinBaseP , psttPrefixMe ) ;
                //etThread.traceF( tinBaseP , T("[prefix]:    ")+tPrefixMe ) ;
                if( !POOP ) tPrefixMe = T(psttPrefixMe) ;

                }
                    }
                        __1
                        etThread.traceF( tinBaseP , T("!exception: file is neither data nor meta") ) ;
                        etThread.delF( tinBaseP , psttPrefixMe ) ;
                    {
                    else
                    }
                        //etThread.traceF( tinBaseP , T("[meta type]:    ")+tType ) ;
                        etThread.delF( tinBaseP , psttType ) ;
                        tType = T(psttType) ;
                        etThread.strSubstringF( tinBaseP , psttType , idf , countTC() , tShort , 0 ) ; ___( psttType ) ;
                        ZE( strokeS* , psttType ) ;
                        bMeta = 1 ;
                    {
                    if( idf )                                                                                                           // THIS WORKS BECAUSE tDotMetaDot MUST BE FOLLOWED BY THE META TYPE
                    etThread.strSubstringF( tinBaseP , psttPrefixMe , idf , sttq , tDotMetaDot , tShort , 0 , 0 ) ; ___( psttPrefixMe ) ;
                    idf = 1 ;            
                    etThread.delF( tinBaseP , psttPrefixMe ) ;
                {
                else
                }
                    //etThread.traceF( tinBaseP , T("[data type]:    ")+tType ) ;
                    etThread.delF( tinBaseP , psttType ) ;
                    tType = T(psttType) ;
                    etThread.strSubstringF( tinBaseP , psttType , idf , countTC() , tShort , 0 ) ; ___( psttType ) ;
                    ZE( strokeS* , psttType ) ;
                    bData = 1 ;
                {
                if( idf )                                                                                                               // THIS WORKS BECAUSE tDotDataDot MUST BE FOLLOWED BY THE FILE TYPE (NTFS FILE NAME "EXTENSION")
                etThread.strSubstringF( tinBaseP , psttPrefixMe , idf , sttq , tDotDataDot , tShort , 0 , 0 ) ; ___( psttPrefixMe ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                countT idf = 1 ;
                ZE( strokeS* , psttPrefixMe ) ;
            {
            ZE( boolT , bMeta ) ;
            ZE( boolT , bData ) ;
            TN( tType     , "" ) ;
            TN( tPrefixMe , "" ) ;

            }
                countT foo = 2 ;
            {
            if( idFile >= 0xe3e )

            if( !( idFile % TUCK ) ) etThread.traceF( tinBaseP , T("[idFile,tShort]:    ")+TF2(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
            TN( tShort , (byteT*)(const byteT*)pageShort ) ;
            ++ idFile ;
        {
        else
        if( !pageShort ) break ;

        pageC pageShort = jotShort ;
    {
    while( !ether && !POOP )
    ZE( countT , idFile ) ;
    TN( tDotMetaDot , ".meta." ) ;
    TN( tDotDataDot , ".data." ) ;
    TN( tPrefix     , ""       ) ;
    TN( tDot        , "."      ) ;

    jotC& jotShort = *pJotSortedShort ;
    
    jotFilesNamedC archive( tinBaseP , etThread , osfnArchive /*"d:\\tmp\\dut.out.jotfiles\\archive"*/ , flJOTc_WRITE | flJOTc_NOsHORTfILENAMEpREFIX ) ;
    tlsAllocStackExp_a_C tls( tinBaseP ) ;
{
if( pJotSortedShort )

}
    etThread.delF( tinBaseP , psttName ) ;
    sortF( tinBaseP , etThread , countTC() , pJotSortedShort , jotShortFileNames , psttName , T("doodle.sorted.short.filenames") , TICK , TUCK << 0 , flSORTERc_SILENTLYsUPPRESSdUPLICATES , flJOTc_null , idFile , sizeof( count04T ) ) ;
    ZE( strokeS* , psttName ) ;

    while( !ether && ~hFindOuter && !POOP && idFile < CfILES ) ;
    }
        DEL( pInfoOuter ) ;
        }
            if( !( idFile % TUCK ) ) etThread.traceF( tinBaseP , T("[idFile,idJot,tShort]:    ")+TF2(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
            countT idJot = jotShortFileNames.writeF( tinBaseP , tShort , tShort.csF( tinBaseP ) + 1 ) ;
            }
                etThread.delF( tinBaseP , psttShort ) ;
                etThread.delF( tinBaseP , psttPath ) ;
                tShort = T(psttShort) ;
                tPath  = T(psttPath) ;
                etThread.strBisectF( tinBaseP , psttPath , psttShort , tFileNameData , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttPath ) ;
            {
            TN( tShort , "" ) ;
            TN( tPath  , "" ) ;
    
            TN( tFileNameData , pInfoOuter->psttIfoName ) ;

            ++ idFile ;
        {
        else
        }
            break ;
            DEL( pInfoOuter ) ;
        {
        if( !pInfoOuter || !pInfoOuter->psttIfoName )
    
        etThread.diskFindFileOrDirF( tinBaseP , pInfoOuter , hFindOuter , tPathIn ) ;
        ZE( infoFileS* , pInfoOuter ) ;
    {
    do
    handleC hFindOuter( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    ZE( countT , idFile ) ;

    jotC jotShortFileNames( tinBaseP , "short.file.names" , flJOTc_WRITE | flJOTc_PRIVATE | flJOTc_DELETE | flJOTc_PURGEoNcT , 1 ) ;
{
ZE( jotC* , pJotSortedShort ) ;

osFileNameC osfnArchive( tinBaseP , etThread , tArchiveLong ) ;
TN( tArchiveLong , "///d/tmp//dut.out.jotfiles//archive" ) ;
TN( tPathIn      , "///d/tmp/dut.in.archived/" ) ;
TN( tb4          , "    " ) ;

TODO

//~sexC leak found [LF,LF-TAGGED]:    f0021015(f6 == 111_9 )    0(0)

#define CfILES ( TUCK << 4 )

/*1*/WAKEsHOW( "doodle.move.archive.filesets.into.jotfiles" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
