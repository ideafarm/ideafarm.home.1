
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//



#undef OFFbOOKsLOTnOW

#undef NEWbOOK2sETfLAG

#undef BOOKnOWrESETfLAG

#undef NEWbOOK1bLAMMOiFcT                                                                 

#undef BOOKnOWeXISTS

#undef BOOKnOWmASK

#undef DELzOMBIEbOOKbACKnOWiF

}
    THREADmODE3rESTORE

    }
        THREADmODE1rESTORE
        }
            }
                }
                    }
                        ++ s ; ((tin123S&)tin0P).pEther->osSleepF( tin0P , TOCK ) ;
                
                        if( pbQuitP && *pbQuitP ) break ;
                
                        if( pcpIdBookMinP || F(flagsCt) & flBOOKSc_WRITER ) break ;
                
                        while( ~hFind ) ;
                        }
                            DEL( pInfo ) ;
                            //if( ((tin123S&)tin0P).pEther && pInfo ) ((tin123S&)tin0P).pEther->trace F( tin0P , T("idBookMinMaxF inspected  [psttIfoName]:    ")+T(pInfo->psttIfoName) ) ;
                            }
                                }
                                    }
                                        PUSE( tin0P , *(byteT**)&pcpIdBookThis ) ;
                    
                                        }
                                            if( pcpIdBookMaxP ) thirdC::c_memcpyIF( tin0P , (byteT*)pcpIdBookMaxP , (byteT*)pcpIdBookThis , cba ) ;
                                            PUSE.newF( tin0P , LF , *(byteT**)&pcpIdBookMaxP , cba ) ; ___( pcpIdBookMaxP ) ;
                                            countT cba = sizeof( countT ) * ( 1 + *pcpIdBookThis ) ;
                                            PUSE( tin0P , *(byteT**)&pcpIdBookMaxP ) ;
                                        {
                                        if( sgn < 0 )
                                        PUSE( tin0P , *(byteT**)&pcpnu ) ;
                                        sgn = subtractF( tin0P , pcpnu , pcpIdBookMaxP , pcpIdBookThis ) ; ___( pcpnu ) ;
                    
                                        }
                                            if( pcpIdBookMinP ) thirdC::c_memcpyIF( tin0P , (byteT*)pcpIdBookMinP , (byteT*)pcpIdBookThis , cba ) ;
                                            PUSE.newF( tin0P , LF , *(byteT**)&pcpIdBookMinP , cba ) ; ___( pcpIdBookMinP ) ;
                                            countT cba = sizeof( countT ) * ( 1 + *pcpIdBookThis ) ;
                                            PUSE( tin0P , *(byteT**)&pcpIdBookMinP ) ;
                                        {
                                        if( sgn > 0 )
                                        PUSE( tin0P , *(byteT**)&pcpnu ) ;
                                        sCountT sgn = subtractF( tin0P , pcpnu , pcpIdBookMinP , pcpIdBookThis ) ; ___( pcpnu ) ;
                    
                                        ZE( countT* , pcpnu ) ;
                                    {
                                    else
                                    }
                                        if( !POOP ) thirdC::c_memcpyIF( tin0P , (byteT*)pcpIdBookMaxP , (byteT*)pcpIdBookMinP , sizeof( countT ) * ( 1 + *pcpIdBookMinP ) ) ;
                                        __Z( pcpIdBookMaxP ) ;
                                        PUSE.newF( tin0P , LF , *(byteT**)&pcpIdBookMaxP , sizeof( countT ) * ( 1 + *pcpIdBookMinP ) ) ; ___( pcpIdBookMaxP ) ;
                                        pcpIdBookMinP = pcpIdBookThis ; pcpIdBookThis = 0 ;
                                    {
                                    if( !pcpIdBookMinP )
                    
                                    ((tin123S&)tin0P).pEther->delF( tin0P , pstt1w ) ;
                                    }
                                        }
                                            else                       pco -- ;
                                            if( pco == pcpIdBookThis ) pco = pcpIdBookThis + cWords - 1 ;
                                            *pco = ((tin123S&)tin0P).pEther->strDigitsToSCountF( tin0P , psttc1 , 0 , 1 ) ;
                                        {
                                        FORsTRINGSiN1( pstt1w )
                    
                                        countT* pco = pcpIdBookThis ;
                                    {
                                    if( pcpIdBookThis )
                                    PUSE.newF( tin0P , LF , *(byteT**)&pcpIdBookThis , sizeof( countT ) * cWords ) ; ___( pcpIdBookThis ) ;
                                    ZE( countT* , pcpIdBookThis ) ;
                                    ((tin123S&)tin0P).pEther->delF( tin0P , psttw ) ;
                                    countT cWords = ((tin123S&)tin0P).pEther->strWordsOldF( tin0P , pstt1w , psttw , sttq , tDot ) ; ___( pstt1w ) ;
                                    ZE( strokeS* , pstt1w ) ;
                    
                                    ((tin123S&)tin0P).pEther->strSubstringF( tin0P , psttw , idf , sttq , tAfter , pInfo->psttIfoName ) ; ___( psttw ) ;
                                    ((tin123S&)tin0P).pEther->delF( tin0P , psttw ) ;
                                    ((tin123S&)tin0P).pEther->strSubstringF( tin0P , psttw , idf , sttq , tBefore , pInfo->psttIfoName ) ; ___( psttw ) ;
                                    countT idf = 1 ;
                                    ZE( strokeS* , psttw ) ;
                                {
                                else
                                }
                                    if( POOP ) { POOPR ; }
                                    ((tin123S&)tin0P).pEtScratch->diskFileOrDirDeleteF( tin0P , pInfo->psttIfoName , flFILEoRdIRdELETE_null , 1 ) ;
                                    SCOOPS
                                {
                                if( F(flagsP) & flBOOKScsELECT_PURGE )
                            {
                            if( pInfo && !( F(pInfo->flags) & flFILEaTTR1_DIRECTORY ) )

                            //if( ((tin123S&)tin0P).pEther && pInfo ) ((tin123S&)tin0P).pEther->trace F( tin0P , T("idBookMinMaxF inspecting [psttIfoName]:    ")+T(pInfo->psttIfoName) ) ;
                            }
                                }
                                    break ;
                                    
                                    etherC::etRockIF( tin0P ).traceF( tin0P , T("!exception: idBookMinMaxF / diskFindFileOrDirF failed [rc,psttFindLike]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttFindLike) ) ;
                                    POOPRqUIET
                                    countT rc = POOP ;
                                {
                                if( POOP )
                                ((tin123S&)tin0P).pEtScratch->diskFindFileOrDirF( tin0P , pInfo , hFind , fnLike.pathF() , &pat ) ; ___( pInfo ) ;
                                SCOOPS
                            {
                            ZE( infoFileS* , pInfo ) ;
                        {
                        do
                        handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                        patternC pat( tin0P , *((tin123S&)tin0P).pEther , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                        fileNameC fnLike( tin0P , *((tin123S&)tin0P).pEther , psttFindLike ) ;
                    {
                    for(;;)
                {
                IFsCRATCH
                TN( tDot , "." ) ;
                strokeS sttDot( '.' ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                TN( tAfter  , ".bookC" ) ;
                TN( tBefore , ".booksC.1.book." ) ;
                TN( tb4 , "    " ) ;
            {
            else
            }
                }
                    ++ s ; ((tin123S&)tin0P).pEther->osSleepF( tin0P , TOCK ) ;

                    if( pbQuitP && *pbQuitP ) break ;
            
                    if( pcpIdBookMinP || F(flagsCt) & flBOOKSc_WRITER ) break ;
            
                    while( ~hFind ) ;
                    }
                        //if( ((tin123S&)tin0P).pEther ) ((tin123S&)tin0P).pEther->trace F( tin0P , T("idBookMinMazF inspected  [postName]:    ")+T(postName) ) ;
                        }
                            }
                                if( sgn < 0 ) thirdC::c_memcpyIF( tin0P , (byteT*)pcpIdBookScratchMax , (byteT*)pcpIdBookScratch1 , cbToCopy ) ;

                                __NZ( pcpnu ) ;
                                sgn = subtractF( tin0P , pcpnu , pcpIdBookScratchMax , pcpIdBookScratch1 ) ;
            
                                if( sgn > 0 ) thirdC::c_memcpyIF( tin0P , (byteT*)pcpIdBookScratchMin , (byteT*)pcpIdBookScratch1 , cbToCopy ) ;

                                __NZ( pcpnu ) ;
                                sCountT sgn = subtractF( tin0P , pcpnu , pcpIdBookScratchMin , pcpIdBookScratch1 ) ;
                                ZE( countT* , pcpnu ) ;
                                //CONoUTrAW7( "comparing " , pcpIdBookScratch1[ 1 ] , " to [min,max]: [" , pcpIdBookScratchMin[ 1 ] , "," , pcpIdBookScratchMax[ 1 ] , "]\r\n" ) ;
                            {
                            else
                            }
                                pcpIdBookMaxP = pcpIdBookScratchMax ;
                                pcpIdBookMinP = pcpIdBookScratchMin ;

                                thirdC::c_memcpyIF( tin0P , (byteT*)pcpIdBookScratchMax , (byteT*)pcpIdBookScratch1 , cbToCopy ) ;
                                thirdC::c_memcpyIF( tin0P , (byteT*)pcpIdBookScratchMin , (byteT*)pcpIdBookScratch1 , cbToCopy ) ;
                            {
                            if( !pcpIdBookMinP )

                            }
                                }
                                    else        offo -- ;
                                    if( !offo ) offo = cWords - 1 ;

                                    posti = poste + 1 ;
                                    pcpIdBookScratch1[ offo ] = thirdC::c_atoiForeignIF( posti ) ;
                                    *poste = 0 ;                                // EXAMPLE: "00000001"

                                    if( !poste ) break ; //SHOULD NEVER OCCUR
                                    poste = thirdC::c_strstrIF( tin0P , posti , "." ) ;
                                {
                                while( cToDo -- )
                                countT cToDo = cWords ;
                                ZE( osTextT* , poste ) ;
                                ZE( countT , offo ) ;
                                const osTextT* posti = postv ;
                            {                                       // SET pcpIdBookScratch1 FROM THE FILE NAME

                            }
                                while( posti ) ;
                                }
                                    }
                                        cWords ++ ;
                                        posti ++ ;
                                    {
                                    if( posti )
                                    posti = thirdC::c_strstrIF( tin0P , posti , "." ) ;
                                {
                                do
                                const osTextT* posti = postv ;
                            {
                            if( *postv )
                            ZE( countT , cWords ) ;

                            //CONoUTrAW( "\"\r\n" ) ;
                            //CONoUTrAW( postv ) ;
                            //CONoUTrAW( "found pcp value \"" ) ;
                            osTextT* postv = postName + costPrefix ; // EXAMPLE: "00000001.0000001c.bookC"
                        {
                        else
                        }
                            if( POOP ) { POOPR ; }
                            thirdC::dosDeleteIF( tin0P , postName ) ;
                        {
                        if( F(flagsP) & flBOOKScsELECT_PURGE )

                        }
                            break ;
                            __( ~hFind ) ;
                        {
                        if( !postName[ 0 ] )
                        //if( ((tin123S&)tin0P).pEther ) ((tin123S&)tin0P).pEther->trace F( tin0P , T("idBookMinMazF inspecting [postName]:    ")+T(postName) ) ;
                        thirdC::dosFindFileOrDirSimpleIF( tin0P , postName , sizeof postName , hFind , postFindLike ) ;
                        postName[ 0 ] = 0 ;
                        osTextT postName[ TUCK << 1 ] ;
                    {
                    do
                    handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                {
                for(;;)
                if( cbToCopy > ccMaxIdBook * sizeof( countT ) ) *(countT*)&cbToCopy = ccMaxIdBook * sizeof( countT ) ;
                const countT cbToCopy = ccMaxIdBook * sizeof( countT ) ;

                __( !!((tin123S&)tin0P).pPoolUse ) ; //subtractF TESTS THIS AND WILL RETURN A POINTER THAT I DO NOT EXPECT IF IT IS TRUE

                }
                    thirdC::c_strcpyIF( tin0P , postFindLike , ostoLike ) ;

                    OStEXTAK( ostoLike , "*" ) ;
                    OStEXTA(  ostoLike , ostoPrefix ) ;
                    OStEXT(   ostoLike , TUCK << 2 ) ;

                    costPrefix = ostoPrefix.costF() ;
                    }
                        ((tin123S&)tin0P).pEther->diskMakeDirIfNeededF( tin0P , T(iffn) ) ;  //DO THIS ONLY IF EXPLICIT PATH, WHICH SHOULD AVOID NONMONOTONIC GRABBING SINCE IT WILL AVOID bksTelemetry AND bksTrace* booksC FILES
                        ifFileNameC iffn( tin0P , *((tin123S&)tin0P).pEther , ostoPrefix ) ;

                        OStEXTAK( ostoPrefix , ".booksC.1.book." ) ;
                        OStEXTA(  ostoPrefix , postShort ) ;
                        }
                            OStEXTAK( ostoPrefix , "." ) ;
                            OStEXTC(  ostoPrefix , idStateSpace , 0 ) ;
                            OStEXTAK( ostoPrefix , "." ) ;
                            OStEXTCF( ostoPrefix , idMemorySpace ? idMemorySpace : ((tin1S&)tin0P).pag1->idMemorySpace , '0' ) ;
                            OStEXTAK( ostoPrefix , "." ) ;
                            OStEXTA(  ostoPrefix , thirdC::postUserNameIF() ) ;
                        {
                        if( !( F(flagsCt) & flBOOKSc_NOsHORTfILENAMEpREFIX ) )
                        OStEXTA(  ostoPrefix , postPath ) ;

                        if( POOP ) { BLAMMO ; }

                        SCOOP
                        poopC poop ;
                    {
                    else
                    }
                        OStEXTAK( ostoPrefix , ".booksC.1.book." ) ;
                        OStEXTA(  ostoPrefix , postShort ) ;
                        OStEXTAK( ostoPrefix , "\\" ) ;
                        OStEXTC(  ostoPrefix , idStateSpace , 0 ) ;                                                               thirdC::dosCreateDirIF( tin0P , ostoPrefix ) ;
                        OStEXTAK( ostoPrefix , "\\" ) ;
                        OStEXTAK( ostoPrefix , "\\stateSpaces" ) ;                                                                thirdC::dosCreateDirIF( tin0P , ostoPrefix ) ;
                        OStEXTCF( ostoPrefix , idMemorySpace ? idMemorySpace : ((tin1S&)tin0P).pag1->idMemorySpace , '0' ) ;         thirdC::dosCreateDirIF( tin0P , ostoPrefix ) ;
                        OStEXTAK( ostoPrefix , "\\" ) ;
                        OStEXTA(  ostoPrefix , thirdC::postUserNameIF() ) ;                                                       thirdC::dosCreateDirIF( tin0P , ostoPrefix ) ;
                        OStEXTAK( ostoPrefix , "\\" ) ;
                        OStEXTAK( ostoPrefix , "\\memorySpaces" ) ;                                                               thirdC::dosCreateDirIF( tin0P , ostoPrefix ) ;
                        OStEXTAK( ostoPrefix , "\\ipdos" ) ;                                                                      thirdC::dosCreateDirIF( tin0P , ostoPrefix ) ;
                        OStEXTAK( ostoPrefix , "\\ideafarm" ) ;                                                                   thirdC::dosCreateDirIF( tin0P , ostoPrefix ) ;
                        OStEXTAK( ostoPrefix , "\\com" ) ;                                                                        thirdC::dosCreateDirIF( tin0P , ostoPrefix ) ;
                        OStEXTAK( ostoPrefix , "\\domains" ) ;                                                                    thirdC::dosCreateDirIF( tin0P , ostoPrefix ) ;
                        OStEXTAK( ostoPrefix , "\\backed.up.daily" ) ;                                                            thirdC::dosCreateDirIF( tin0P , ostoPrefix ) ;
                        OStEXTAK( ostoPrefix , "\\ephemeral" ) ;                                                                  thirdC::dosCreateDirIF( tin0P , ostoPrefix ) ;
                        OStEXTA(  ostoPrefix , postHome ) ;                                                                       thirdC::dosCreateDirIF( tin0P , ostoPrefix ) ;

                        if( POOP ) { BLAMMO ; }
                        thirdC::diskFindHomeIF( tin0P , postHome , sizeof postHome , "ideafarm" ) ;
                        osTextT postHome[ TUCK << 1 ] ;

                        SCOOP
                        poopC poop ;
                    {
                    if( !*postPath )
                    OStEXT( ostoPrefix , TUCK << 1 ) ;
                    //CS:CODEsYNC: 350fa004 360fa005 360fb012
                {
                ZE( countT , costPrefix ) ;
            {
            if( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE ) //BOTH FLAVORS ARE RETAINED IN ORDER TO HAVE TRUE UNLIMITED CAPACITY WHEN PUSE EXISTS
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        {
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    {                                                               //U:: ENUMERATE SHARED MEMORY RATHER THAN BACKING FILES
    if( idStateSpace )

    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )

    _IO_

    }
        if( POOP ) return ;
        }
            FV( flBOOKScsELECT , flagsP ) ;
            __( ((tin123S&)tin0P).monitor.idThread != 1 ) ; //I WILL USE STATIC STORAGE SO WILL NOT BE THREAD SAFE; INTENDED ONLY FOR CT/DT OF INSTANCES IN STATIC STORAGE
        {
        if( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE )
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT booksC::idBookMinMaxF( tin0S& tin0P , countT*& pcpIdBookMinP , countT*& pcpIdBookMaxP , const flagsT flagsP , const boolT* pbQuitP )/*1*/

/**/
*/
 pcpIdBookMinP
 tin0P
arguments
so caller must detect !pcpIdBookMinP
but if pbQuitP and *pbQuitP will return even if no file was ever found
if !pbQuitP or !*pbQuitP then will block until at least wo file is found
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

