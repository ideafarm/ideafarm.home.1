
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return flagsListWalkRetCode ;

    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    }
        }
            }
                flagsListWalkRetCode |= flLISTwALKcALLbACKrETURNcODE_QUIT ;

                }
                    pListFoundP = pNew ;
                    }
                        pNew->openF( tin0P , *ppHand[ !offWoth ] , 0 , ((tin123S&)tin0P).ta.retained.u.listWalk.walk.idGrabLayer ) ;
                        _IO_
                    {
                    ppHand[ !offWoth ] = new( 0 , tin0P , pbh , SIZEOF_handleC ) handleC( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                    }
                        DELzOMBIE( ppHand[ !offWoth ] ) ;
                        _IO_
                    {
                    byteT* pbh = (byteT*)ppHand[ !offWoth ] ;
                    listC* pNew = pNewF( tin0P , ppPreP , idNameWantP , bOfSetP ) ;
                    _IO_
                {
                else
                if( F(flagsP) & flLISToPEN_IFeXISTS ) ((tin123S&)tin0P).ta.pushed.u.listWalk.walk.flagsWalkP &= ~( F(flLISTwALK_DOnOTuNGRABoOTHaTeNDoFwALK) ) ;
            {
            else if( idNameWantP < idNameAt )
            }
                flagsListWalkRetCode |= flLISTwALKcALLbACKrETURNcODE_QUIT ;

                else                                          ((tin123S&)tin0P).ta.pushed.u.listWalk.walk.flagsWalkP &= ~( F(flLISTwALK_DOnOTuNGRABoOTHaTeNDoFwALK) ) ;
                if( !( F(flagsP) & flLISToPEN_IFnOTeXISTS ) ) pListFoundP = (listC*)pListing ;
            {
            if( idNameWantP == idNameAt )
            countT idNameAt = pListing->nameF() ;
        {
        )
            && ( listingC::bIsListingIF( tin0P , aptListing , fliLISTINGc_MIXINlIST ) || listingC::bIsListingIF( tin0P , aptListing , fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM ) )
            !POOP
        (
        if

        __( !listingC::bIsListingIF( tin0P , aptListing ) ) ;
        aptC aptListing( tin0P , pListing ) ;
    {
    else
    }
        }
            pListFoundP = pNew ;
            pNew->openF( tin0P , *ppHand[ !offWoth ] , 0 , ((tin123S&)tin0P).ta.retained.u.listWalk.walk.idGrabLayer ) ;
            listC* pNew = pNewF( tin0P , ppPreP , idNameWantP , bOfSetP ) ;
            _IO_
        {
        if( !( F(flagsP) & flLISToPEN_IFeXISTS ) )
    {
    if( !pListing )
    flagsT flagsListWalkRetCode = flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE ;

    listC*&   pListFoundP       = *(listC**)&((tin123S&)tin0P).ta.pushed.u.listWalk.util.pcP[ 2 ] ;
    flagsT    flagsP            =            ((tin123S&)tin0P).ta.pushed.u.listWalk.util.pcP[ 1 ] ;
    countT    idNameWantP       =            ((tin123S&)tin0P).ta.pushed.u.listWalk.util.pcP[ 0 ] ;

    boolT     bOfSetP           =            ((tin123S&)tin0P).ta.retained.u.listWalk.util.pcP[ 4 ] ;

    listC**   ppPreP            = ((tin123S&)tin0P).ta.pushed.u.listWalk.cbf.ppPreallocatedListsP ;

    countT&   offWoth           = *((tin123S&)tin0P).ta.pushed.u.listWalk.walk.pOffWothP ;
    handleC*  ppHand[ 2 ]       = { ((tin123S&)tin0P).ta.pushed.u.listWalk.walk.pHandleLoP , ((tin123S&)tin0P).ta.pushed.u.listWalk.walk.pHandleHiP } ;
    listingC* pListing          = ((tin123S&)tin0P).ta.pushed.u.listWalk.cbf.pListingP ;
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    const boolT  bOfSet = F(flagsPoolFormat) & flPOOLfORMAT_SETS ;
    const flagsT flagsPoolFormat = !((tin1S&)tin0P).pPoolUse ? 0 : PUSE.flagsPoolFormatF() ;

    if( tin0P.idTypeTin - ifcIDtYPEtIN_123 ) { BLAMMOiD( 0x12121212 ) ; }

    _IO_
{
/*1*/flagsT listWalkAttachListIfCBF( tin0S& tin0P )/*1*/

}
    return pNew ;

    }
        }
            if( !((tin123S&)tin0P).ta.pushed.u.listWalk.cbf.pNewP ) ((tin123S&)tin0P).ta.pushed.u.listWalk.cbf.pNewP = pNew ;
            __( ((tin123S&)tin0P).ta.pushed.u.listWalk.cbf.pNewP ) ;

            //CONoUTrAW3( "\r\n[pNew]:    " , pNew , "    dispensed" ) ;

            *pNew = idNameWantP ;
            *pNew = *((tin123S&)tin0P).ta.pushed.u.listWalk.cbf.pDadP ;
        {
        if( pNew )

        }
            }
                break ;
                       ppPreP[ offi ] = 0 ;
                pNew = ppPreP[ offi ] ;
            {
            if( !ppPreP[ offi + 1 ] ) //IF offi POINTS TO LEAF
        {
        for( countT offi = 0 ; ppPreP[ offi ] ; offi ++ )
    {
    else
    }
        ___( pNew ) ;
        ;
            : new( 0 , tin0P , LF ) listC(      tin0P ,              *((tin123S&)tin0P).ta.pushed.u.listWalk.cbf.pDadP , idNameWantP )
            ? new( 0 , tin0P , LF ) listOfSetC( tin0P , *(listOfSetC*)((tin123S&)tin0P).ta.pushed.u.listWalk.cbf.pDadP , idNameWantP )
        pNew = bOfSetP
    {
    if( !ppPreP )
    ZE( listC* , pNew ) ;

    if( tin0P.idTypeTin - ifcIDtYPEtIN_123 ) { BLAMMOiD( 0x12121212 ) ; }
{
listC* pNewF( tin0S& tin0P , listC** ppPreP , const countT idNameWantP , const boolT bOfSetP )

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

