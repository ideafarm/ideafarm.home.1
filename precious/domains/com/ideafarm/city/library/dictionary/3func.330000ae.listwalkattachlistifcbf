
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return flagsListWalkRetCode ;

    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    }
        }
            }
                flagsListWalkRetCode |= flLISTwALKcALLbACKrETURNcODE_QUIT ;

                }
                    pListFoundP = pNew ;
                    }
                        pNew->openF( tinP , *ppHand[ !offWoth ] , 0 , ((tinNormalS&)tinP).ta.retained.u.listWalk.walk.idGrabLayer ) ;
                        _IO_
                    {
                    ppHand[ !offWoth ] = new( 0 , tinP , pbh , SIZEOF_handleC ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                    }
                        DELzOMBIE( ppHand[ !offWoth ] ) ;
                        _IO_
                    {
                    byteT* pbh = (byteT*)ppHand[ !offWoth ] ;
                    listC* pNew = pNewF( tinP , ppPreP , idNameWantP , bOfSetP ) ;
                    _IO_
                {
                else
                if( F(flagsP) & flLISToPEN_IFeXISTS ) ((tinNormalS&)tinP).ta.pushed.u.listWalk.walk.flagsWalkP &= ~( F(flLISTwALK_DOnOTuNGRABoOTHaTeNDoFwALK) ) ;
            {
            else if( idNameWantP < idNameAt )
            }
                flagsListWalkRetCode |= flLISTwALKcALLbACKrETURNcODE_QUIT ;

                else                                          ((tinNormalS&)tinP).ta.pushed.u.listWalk.walk.flagsWalkP &= ~( F(flLISTwALK_DOnOTuNGRABoOTHaTeNDoFwALK) ) ;
                if( !( F(flagsP) & flLISToPEN_IFnOTeXISTS ) ) pListFoundP = (listC*)pListing ;
            {
            if( idNameWantP == idNameAt )
            countT idNameAt = pListing->nameF() ;
        {
        )
            && ( listingC::bIsListingIF( tinP , aptListing , fliLISTINGc_MIXINlIST ) || listingC::bIsListingIF( tinP , aptListing , fliLISTINGc_MIXINlIST | fliLISTINGc_MIXINdATUM ) )
            !POOP
        (
        if

        __( !listingC::bIsListingIF( tinP , aptListing ) ) ;
        aptC aptListing( tinP , pListing ) ;
    {
    else
    }
        }
            pListFoundP = pNew ;
            pNew->openF( tinP , *ppHand[ !offWoth ] , 0 , ((tinNormalS&)tinP).ta.retained.u.listWalk.walk.idGrabLayer ) ;
            listC* pNew = pNewF( tinP , ppPreP , idNameWantP , bOfSetP ) ;
            _IO_
        {
        if( !( F(flagsP) & flLISToPEN_IFeXISTS ) )
    {
    if( !pListing )
    flagsT flagsListWalkRetCode = flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE ;

    listC*&   pListFoundP       = *(listC**)&((tinNormalS&)tinP).ta.pushed.u.listWalk.util.pcP[ 2 ] ;
    flagsT    flagsP            =            ((tinNormalS&)tinP).ta.pushed.u.listWalk.util.pcP[ 1 ] ;
    countT    idNameWantP       =            ((tinNormalS&)tinP).ta.pushed.u.listWalk.util.pcP[ 0 ] ;

    boolT     bOfSetP           =            ((tinNormalS&)tinP).ta.retained.u.listWalk.util.pcP[ 4 ] ;

    listC**   ppPreP            = ((tinNormalS&)tinP).ta.pushed.u.listWalk.cbf.ppPreallocatedListsP ;

    countT&   offWoth           = *((tinNormalS&)tinP).ta.pushed.u.listWalk.walk.pOffWothP ;
    handleC*  ppHand[ 2 ]       = { ((tinNormalS&)tinP).ta.pushed.u.listWalk.walk.pHandleLoP , ((tinNormalS&)tinP).ta.pushed.u.listWalk.walk.pHandleHiP } ;
    listingC* pListing          = ((tinNormalS&)tinP).ta.pushed.u.listWalk.cbf.pListingP ;
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    const boolT  bOfSet = F(flagsPoolFormat) & flPOOLfORMAT_SETS ;
    const flagsT flagsPoolFormat = !((tinNormalS&)tinP).pPoolUse ? 0 : PUSE.flagsPoolFormatF() ;

    _IO_
{
/*1*/flagsT listWalkAttachListIfCBF( tinBaseS& tinP )/*1*/

}
    return pNew ;

    }
        }
            if( !((tinNormalS&)tinP).ta.pushed.u.listWalk.cbf.pNewP ) ((tinNormalS&)tinP).ta.pushed.u.listWalk.cbf.pNewP = pNew ;
            __( ((tinNormalS&)tinP).ta.pushed.u.listWalk.cbf.pNewP ) ;

            *pNew = idNameWantP ;
            *pNew = *((tinNormalS&)tinP).ta.pushed.u.listWalk.cbf.pDadP ;
        {
        if( pNew )

        }
            }
                break ;
                       ppPreP[ offi ] = 0 ;
                pNew = ppPreP[ offi ] ;
            {
            if( !ppPreP[ offi + 1 ] ) //IF offi POINTS TO LEAF
        {
        for( countT offi = 0 ; ppPreP[ offi ] ; offi ++ )
    {
    else
    }
        ___( pNew ) ;
        ;
            : new( 0 , tinP , LF ) listC(      tinP ,              *((tinNormalS&)tinP).ta.pushed.u.listWalk.cbf.pDadP , idNameWantP )
            ? new( 0 , tinP , LF ) listOfSetC( tinP , *(listOfSetC*)((tinNormalS&)tinP).ta.pushed.u.listWalk.cbf.pDadP , idNameWantP )
        pNew = bOfSetP
    {
    if( !ppPreP )
    ZE( listC* , pNew ) ;
{
listC* pNewF( tinBaseS& tinP , listC** ppPreP , const countT idNameWantP , const boolT bOfSetP )

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

