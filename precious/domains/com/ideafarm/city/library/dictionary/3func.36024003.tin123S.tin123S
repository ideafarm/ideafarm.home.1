
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( this == &tin0SelfOrElderP && monitor.idThread > 3 ) flagsThreadMode4 &= ~( F(flTHREADmODE4_INoUTfRAMEdEFERwRITINGaPPtELEMETRY) ) ;

    }
        //SAYnAME( " tin123S/-\r\n" )
    
        }
            }
                }
                    *(countT*)pbPendingInOutFramePackets = 0 ;

                    }
                        pbPendingInOutFramePackets = pbn ;
                        PUSE.newF( tin0P , LF , pbn , cba ) ; ___( pbn ) ;
                        ZE( byteT* , pbn ) ;                                // pbn IS USED TO PREVENT pbPendingInOutFramePackets FROM BEING USED BEFORE ITS WOTH countT IS INITIALIZED
                    {
                    else
                    if( !pPoolUse ) pbPendingInOutFramePackets = processGlobal4I.heap.newF( tin0P , LF , cba ) ;

                    countT cba = sizeof( countT ) + CmAXpENDINGiNoUTfRAMEpACKETS * sizeof( tellInfoAppInOutFrameS ) ;
                {
                if( !pbPendingInOutFramePackets )
            {
            if( monitor.idThread > 3 && !( F(flags) & flTINs_NOiNoUTfRAMEsUPPORT ) ) // FOR THREAD 1, SEE do3; THREAD 2 3 ARE tinHeart AND tinBreak

            if( idTinNamed == ifcIDtINnAMED_tinBreakI ) thirdC::c_strncpyIF( tin0P , postTell , "refusalsToClose:0    logoffsSeen:0" , sizeof postTell ) ; //CODEsYNC: 12f0006 10200cc
            thirdC::c_strncpyIF( tin0P , postTell , "tin123S::tin123S: i am now registered" , sizeof postTell ) ;
            }
                TELLsYSc3LIFI( idTypeSay , (byteT*)&info , sizeof info , idLineCt , idiFileCt )
                info.idiFileCt  = idiFileCt ;
                info.idLineCt   = idLineCt ;
                info.idTinNamed = idTinNamed ;
                thirdC::c_strncpyIF( tin0P , info.postThreadName , postThreadName , sizeof info.postThreadName ) ;
                info.idTin      = idTin ;
                //info.ip       = aptMe ? aptMe : (countT)this ;
                info.ip         = (countT)this ;
                info.idSerial   = idSerial ;
                tellInfoSysTinS info ;
                //countT idTypeSay = aptMe ? ifcIDtYPEtELLsYS_TINcTI : ifcIDtYPEtELLsYS_TINcTP ;
                countT idTypeSay = ifcIDtYPEtELLsYS_TINcTP ;
                //ap_artmentOldC aptMe( tin0P , (byteT*)this ) ;
                thirdC::c_strncpyIF( tin0P , postTell , "tin123S::tin123S: registering myself" , sizeof postTell ) ;
            {
            if( !( F(flags) & flTINs_CONSTRUCTqUIETLY ) )
    
            }
                }
                    TELLsYSc3LIFI( ifcIDtYPEtELLsYS_LIFInAME , (byteT*)&info , sizeof info , idLineCt , idiFileCt ) ;
                    info.costName = thirdC::c_strlenIF( tin0P , info.postName ) ;
                    thirdC::c_strncpyIF( tin0P , info.postName , postOverride , sizeof info.postName ) ;
                    info.idiFile = idiFileCt ;
                    info.idLine = idLineCt & 0xfff ;
                    tellInfoSysLifiS info ;
    
                    osTextT* postOverride = idiFileCt != 0x3000b71 ? postn : "earlyLate" ;
                {
                if( postn )
        
                }
                    if( idTinNamed == ifcIDtINnAMED_tinHeartI || idTinNamed == ifcIDtINnAMED_tinBreakI ) thirdC::c_strncpyIF( tin0P , postThreadName , postn , sizeof postThreadName ) ;
                    }
                        }
                            break ;
                            if( !setIfZeAM( bDone , 1 ) ) postn = "earlyLateOrException" ;
                            static countT bDone ;
                        {
                        case ifcIDtINnAMED_tinEarlyLate :
                        case ifcIDtINnAMED_tinBreakI    : { postn = "tmBreakF" ; break ; }
                        case ifcIDtINnAMED_tinHeartI    : { postn = "tmHeartF" ; break ; }
                    {
                    switch( idTinNamed )
                {
                ZE( osTextT* , postn ) ;
            {
            if( idTinNamed == ifcIDtINnAMED_tinHeartI || idTinNamed == ifcIDtINnAMED_tinBreakI || idTinNamed == ifcIDtINnAMED_tinEarlyLate )
        
            if( idTinNamed == ifcIDtINnAMED_tin9VeryVeryEarlyLateMainI && monitor.idThread <= ClOWtHREADS && !( ++ processGlobal2I.pcPhaseLow[ monitor.idThread ] ) ) { BLAMMO ; }

            TELL( "tin123S: after setting processGlobal2I.flCt flag" )
            }
                }
                    }
                        etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;

                        OStEXTAK( ostoSay , "_" ) ;
                        OStEXTCF( ostoSay , pbThreadStackEnd , '0' ) ;
                        OStEXTAK( ostoSay , "_    " ) ;
                        OStEXTCF( ostoSay , pbThreadStackStart , '0' ) ;
                        OStEXTAK( ostoSay , "    " ) ;
                        OStEXTC(  ostoSay , cbStack , 0 ) ;
                        OStEXTAK( ostoSay , "    " ) ;
                        OStEXTC(  ostoSay , monitor.idThread , 0 ) ;
                        OStEXTAK( ostoSay , "_9    " ) ;
                        OStEXTC9( ostoSay , osTid ) ;
                        OStEXTAK( ostoSay , "_9    " ) ;
                        OStEXTC9( ostoSay , osPid ) ;
                        OStEXTAK( ostoSay , "tin123S [osPid,osTid,idThread,cbStack,pbThreadStackStart,pbThreadStackEnd]:    " ) ;
                        OStEXT(   ostoSay , TUCK << 1 ) ;

                        countT cbStack = pbThreadStackEnd - pbThreadStackStart ;

                        // EXAMPLE: tin123S [osPid,osTid,idThread,cbStack,pbThreadStackStart,pbThreadStackEnd]:    12308_9    8168_9    00000000    00004000    000a0000_    000e0000_
                        //          123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
                        //          0              1               2               3               4               5               6               7               8               9               a               b               c               d               e               f               0
                    {
                    if( F(thirdC::third_flagsModeProcess2I_IF()) & flMODEpROCESS2_CHATTERtHREADsTACK && ( idTinNamed == ifcIDtINnAMED_tinInPoolMain || this == &tin0SelfOrElderP ) )

                    }
                        etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , /*flTRACE_LOOP |*/ flTRACE_PARAMETERiSoStEXT ) ;

                        OStEXTAK( ostoSay , " ++++" ) ;
                        OStEXTA(  ostoSay , postThreadName ) ;
                        OStEXTAK( ostoSay , "_9    " ) ;
                        OStEXTC9( ostoSay , osTid ) ;
                        OStEXTAK( ostoSay , "_9    " ) ;
                        OStEXTC9( ostoSay , osPid ) ;
                        OStEXTAK( ostoSay , "tin123S [osPid,osTid]:    " ) ;
                        OStEXT(   ostoSay , TUCK >> 0 ) ;

                        tin0S& tin0P = *this ;
                    {
                    if( F(thirdC::third_flagsModeProcess2I_IF()) & flMODEpROCESS2_CHATTERtHREADcTdT )
                {
                if( idTinNamed == ifcIDtINnAMED_tinInPoolMain || ( this == &tin0SelfOrElderP && idTinNamed != ifcIDtINnAMED_tinHeartI && idTinNamed != ifcIDtINnAMED_tinBreakI && idTinNamed != ifcIDtINnAMED_tin9VeryVeryEarlyLateMainI ) )
            {
            //if( F(processGlobal2I.flCt) & flCTdTg_WITHINlIFETIMEoFmAIN && !( F(processGlobal2I.flDt) & flCTdTg_WITHINlIFETIMEoFmAIN ) )                                                                       //THIS IS TO AVOID CLUTTERING THE LOG FILE

            }
                }
                    case ifcIDtINnAMED_tinInPoolMain             : { processGlobal2I.flCt |= flCTdTg_tinMainInPool             ; break ; }
                    case ifcIDtINnAMED_tin9VeryEarlyLateMainI     : { processGlobal2I.flCt |= flCTdTg_tin9VeryEarlyLateMainI     ; break ; }
                    case ifcIDtINnAMED_tin9VeryVeryEarlyLateMainI : { processGlobal2I.flCt |= flCTdTg_tin9VeryVeryEarlyLateMainI ; break ; }
                {
                switch( idTinNamed )
    
                if( pTinF() != this ) { BLAMMO } ;
            {
            if( idTinNamed != ifcIDtINnAMED_tinHeartI && idTinNamed != ifcIDtINnAMED_tinBreakI )
            TELL( "tin123S: setting processGlobal2I.flCt flag and testing pTinF()" )
        
            TINSL
    
            }
                *(countT*)&pbThreadStackEnd   = (countT)info.BaseAddress + info.RegionSize ;
                *(countT*)&pbThreadStackStart = (countT)info.AllocationBase ;
                VirtualQuery( (byteT*)ebpP , &info , sizeof info ) ;
                MEMORY_BASIC_INFORMATION info ;
                //CONoUTrAW3( "\r\ntin123S / setting [pbThreadStackStart,pbThreadStackEnd] / [idTinNamed]:    " , idTinNamed , "\r\n" ) ;
            {
            if( !pbThreadStackStart )

            }
                thirdC::c_strncpyIF( tin0P , postTell , "tin123S::tin123S: my image is now valid by raw construction" , sizeof postTell ) ;
                putNegAM( fingerprint , FINGERnEG_TINs ) ; //MY IMAGE IS NOW COMPLETELY VALID
                where.idDirty ++ ;
        
                }
                    thirdC::c_strncpyIF( tin0P , processGlobal3I.pLowThread[ monitor.idThread ].postThreadName , postThreadName , sizeof processGlobal3I.pLowThread[ monitor.idThread ].postThreadName ) ;
                    processGlobal3I.pLowThread[ monitor.idThread ].osTid = osTid ;
                    if( processGlobal3I.pLowThread[ monitor.idThread ].osTid ) { BLAMMO ; }
                {
                if( monitor.idThread <= ClOWtHREADS )
                
                //U::WILL pPoop WORK?: declareVmUsageTypeGF( tin0P , (byteT*)((tin123S&)tin0P).pPoop , flVMuSAGEtYPE_CPUsTACK , monitor.idThread , postThreadName ) ;
                thirdC::c_strncpyIF( tin0P , postThreadName , postThreadNameP , sizeof postThreadName ) ;
        
                //where.pLFnest[ 3 ] = idiFileCt ;
                //where.pLFnest[ 2 ] = idLineCt & ~fliSTEP_FLAGmASK ;
                //where.cInNest = 1 ; //ENSURES THAT THE MONITOR WILL NEVER SEE A NULL where.cInNest (IF IT DOES, THERE IS A BUG)
                
                }
                    thirdC::c_memsetIF( tin0P , postTellIf          , sizeof postTellIf ) ;
                    thirdC::c_memsetIF( tin0P , postTellWait        , sizeof postTellWait ) ;
                    thirdC::c_strncpyIF( tin0P , postTell , "constructing this tin123S, object" , sizeof postTell ) ;
                {
                //thirdC::c_memsetIF( tin0P , (byteT*)ppTinKid   , sizeof ppTinKid    ) ;
                thirdC::c_memsetIF( tin0P , (byteT*)pcUtility04  , sizeof pcUtility04 ) ;
                thirdC::c_memsetIF( tin0P , (byteT*)pcUtility    , sizeof pcUtility   ) ;
                }
            
                    pFlagsThreadLevelMode[ off ] = flTHREADlEVELmODE_null ;
                    pIdProgressNest[       off ] = 0 ;
                    pEIPInNest[            off ] = 0 ;
                    pIdInNest[             off ] = 0 ;
                {
                for( countT off = 0 ; off <= OFFsLOTtINnESTmAX ; off ++ )
                {for( countT off = 0 ; off < sizeof where.pLFnest / sizeof where.pLFnest[ 0 ] ; off ++ ) where.pLFnest[ off ] = 0 ;}
                //O: USE thirdC::c_memsetIF
                
                {for( countT off = 0 ; off < sizeof pLFstep / sizeof pLFstep[ 0 ] ; off ++ ) pLFstep[ off ] = 0 ;}
                where.idDirty ++ ;
                
                const boolT bComments = !( F(flags) & flTINs_DISABLEcOMMENTS  ) ;
        
                }
                    }
                        countT foo = 2 ;
                    {
                    if( thirdC::c_strstrIF( *this , postThreadName , "tmExecutive" ) )

                    LOGrAW( "+\r\n" ) ;
                    LOGrAW( postThreadNameP ) ;
                    //CONoUTnOtIN2( postThreadNameP , 1 ) ;
                {
                if( F(thirdC::third_flagsModeAdam2I_IF(*this)) & flADAMmODE2_THREADcHATTER )
        
                }
                    }
                        //LOG rAW3nOtIN( "/" , monitor.idThread , "/+\r\n" ) ;
                        //LOG rAWnOtIN( postThreadNameP ) ;
                        //LOG rAW3nOtIN( "" , pag1->idAdam , " " ) ;
                    {
                    //if( !thirdC::c_strcmpIF( postThreadNameP , "tmKillSocketF" ) )
                {
                if( F(thirdC::third_flagsModeAdam2I_IF(*this)) & flADAMmODE2_THREADcHATTER )

                TINSL
                ctTellCopyDoneF( (countT)this ) ;
            {
            else
            }
                if( pTin9Prior->pPoop != &pTin9Prior->poop ) { BLAMMO ; }
        
                thirdC::c_strncpyIF( postTell , "tin123S::tin123S: my image is now valid by copying my elder" , sizeof postTell ) ;

                if( thirdC::c_memcpyWithCallBackIF( (byteT*)this + sizeof( tin0S ) , (byteT*)pTin9Prior + sizeof( tin0S ) , sizeof( tin123S ) - sizeof( tin0S ) , ctTellCopyDoneF , (countT)this ) ) { BLAMMO ; } //CODE SYNC: 003002a 12f0002 12f0003

                putNegAM(     pTin0Prior->fingerprint   ,  FINGERnEG_TINszOMBIE ) ; //FROM NOW UNTIL I REGISTER MYSELF, MONITOR WILL NOT BE ABLE TO SEE A tin123S FOR THIS THREAD
                if( getNegAM( pTin0Prior->fingerprint ) != FINGERnEG_TINs       ) BLAMMO ;

                //SAYnAME( " tin123S/ " ) CONoUTrAW( " copying from " ) ; CONoUTrAW( NAME( pTin0Prior->idTinNamed ) ) ; CONoUTrAW( "\r\n" ) ;
                tin123S*   pTin9Prior = (tin123S*)&tin0SelfOrElderP ;
                *(tin0S**)&pTin0Prior   =              &tin0SelfOrElderP ;
            {
            if( !( F(flags) & flTINs_NOeLDER ) )
        
            }
                idSerial  = ph ? 1 + incv02AM( ph->idSerialLath ) : 0 ;
                homeS* ph = processGlobal1I.pHome ;
            {
            //U::VALIDATE flags...NOTE THAT flags IS NOT VALIDATED. THIS IS BECAUSE I DO NOT HAVE AN POOP TO SET U::CONJ: IT COULD BE VALIDATED NOW THAT I KNOW WHETHER I CAN USE tin0P AS MY ELDER)    
        
            idDesireSetBySelfProcess = thirdC::dosPriorityProcessIF( tin0SelfOrElderP ) ;
            idDesireSetBySelf = thirdC::dosPriorityIF( tin0SelfOrElderP ) ;
        {

        else                                                 thirdC::c_memcpyIF( tin0SelfOrElderP , (byteT*)ppJot                       , (byteT*)((tin123S*)pTin0DadP)->ppJot , sizeof ppJot                       ) ;
        if( !( F(flags) & flTINs_INHERITjOTrEGISTRATIONS ) ) thirdC::c_memsetIF( tin0SelfOrElderP , (byteT*)ppJot                                                                    , sizeof ppJot                       ) ;
                                                             thirdC::c_memsetIF( tin0SelfOrElderP , (byteT*)postThreadName                                                           , sizeof postThreadName              ) ;
                                                             thirdC::c_memsetIF( tin0SelfOrElderP , (byteT*)pPanLifiRecurseGrabbedLevel                                              , sizeof pPanLifiRecurseGrabbedLevel ) ;
                                                             thirdC::c_memsetIF( tin0SelfOrElderP , (byteT*)pBookMark                                                                , sizeof pBookMark                   ) ;
                                                             thirdC::c_memsetIF( tin0SelfOrElderP , (byteT*)pcGrabitRecurse                                                          , sizeof pcGrabitRecurse             ) ;
                                                             thirdC::c_memsetIF( tin0SelfOrElderP , (byteT*)pcGrabitOsTid                                                            , sizeof pcGrabitOsTid               ) ;
                                                             thirdC::c_memsetIF( tin0SelfOrElderP , (byteT*)ppbGrabitRecurse                                                         , sizeof ppbGrabitRecurse            ) ;
    
        //SAYnAME( " tin123S/+\r\n" )

        if( !idTinNamedP ) { BLAMMO ; }
    {
{
tin_part3_S( tin0SelfOrElderP , idThreadP )
tin_part2_S( tin0SelfOrElderP ) ,
tin_part1_S( tin0SelfOrElderP , pTin0DadP , idTinNamedP , pbTlsP , cbTlsP ) ,
tin0S( tin0SelfOrElderP , idLineCtP , idiFileCtP , pbBitsCtP , ifcIDtYPEtIN_123 , pTin0DadP , flagsP , idTinNamedP ) ,
/*1*/tin123S::tin123S( tin0S& tin0SelfOrElderP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const countT ebpP , const countT idThreadP , tin0S* const pTin0DadP , const osTextT* const postThreadNameP , const flagsT flagsP , const countT idTinNamedP , byteT* const pbTlsP , const countT cbTlsP )/*1*/ :

// "tin0SelfOrElderP": USUALLY SO, BUT NOT ALWAYS (AN EXCEPTION TIN WILL BE, YOU GUESSED IT, AN EXCEPTION (S))

//CONJ: THE PRECEDING COMMENT IS OBSOLETE AND NO LONGER TRUE
// THIS DEFINITION MUST WORK WHEN tin0P REFERENCES BYTES THAT ARE ALL SET TO 0 ("tin123S. processGlobal4I.tin9VeryVeryEarlyLateMain( processGlobal4I.tin9VeryVeryEarlyLateMain , TAG( TAGiDnULL ) , flTINs_CONSTRUCTqUIETLY ) ;")

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
