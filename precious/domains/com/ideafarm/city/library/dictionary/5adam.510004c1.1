
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    etThread.loafIF( tin0P ) ;

    }
        ++ s ; ether.osSleepF( tin0P , TOCK ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        etThread.strokeF( tin0P , T("\r\n") ) ;
        for( countT idg = 1 ; idg <= CgORILLAS && cToDo -- ; idg ++ ) etThread.strokeF( tin0P , TF3(pcTally[idg],flFORMAT_UNSIGNED,9) ) ;
        etThread.strokeF( tin0P , TF1((measureT)grabMe.stat.cCollisions/(measureT)grabMe.stat.cAcquisitions)+T(" | ")+TF3(grabMe.stat.cAcquisitions,flFORMAT_UNSIGNED,9)+TF3(grabMe.stat.cCollisions,flFORMAT_UNSIGNED,9)+TF3(grabMe.stat.cCollisionsNew,flFORMAT_UNSIGNED,9)+T("| ") ) ;
        countT cToDo = 0x6 ;
    {
    while( !ether && !etThread )

    while( cGorillas -- ) etThread.osThreadF( tin0P , countTC() , tmGorillaF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&ru , (countT)&grabMe , (countT)pcTally ) ;
    countT cGorillas = CgORILLAS ;

    etThread.strokeF( tin0P , T("idMe: ")+TF1(grabMe.idMe)+T("\r\n") ) ;

    etThread.memSetF( tin0P , (byteT*)pcTally , sizeof pcTally ) ;
    countT pcTally[ 1 + CgORILLAS ] ;
    grabS  grabMe( tin0P , TAG( TAGiDnULL ) ) ;
    ranUniC ru( TUCK , 1 ) ;
{

TODO

#define CgORILLAS 0x200

DONE( tmGorillaF )
THREADmODE2rESTORE
}
    }
        grabMe.ungrabF( tin0P ) ;

        //}
        //    ++ s ; ether.osSleepF( tin0P , ru * ((tin123S&)tin0P).monitor.idThread ) ;
        //    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        //{
        //if( !( ru % 2 ) )
        //thirdC::dosWriteStdOutIF( post2 ) ;

        pcTally[ idMe ] ++ ;

        grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {
    while( !etThread && !ether )
    const osTextT post2[] = { 'a' + ((tin123S&)tin0P).monitor.idThread % 26 , 0 } ;

    const countT idMe = 1 + incv02AM( idMeLath ) ;
    static countT idMeLath ;

    countT*  pcTally =   (countT*)pTaskP->c3 ;
    grabS&   grabMe  =   *(grabS*)pTaskP->c2 ;
    ranUniC& ru      = *(ranUniC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
//etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIEST ) ;
TASK( tmGorillaF )

countT idTrial ;

STATE0

/*1*/WAKEhIDE( "tool.gorilla.grabS" )/*1*/
/**/
*/
initially, use homogeneous gorillas that sleep a random time
 the mean sleep of the gorillas is a multiple of S such that there are 3 bunch levels
 G heterogeneous gorilla threads that sleep random times and periodically bunch
specs
obsoletes f940104
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

