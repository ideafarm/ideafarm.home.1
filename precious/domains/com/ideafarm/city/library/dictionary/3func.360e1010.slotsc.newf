
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbo ;

    }
        }
            }
                }
                    }
                        inc02AM( pcTallyOut[ offs ] ) ;
                        pGrabNewElt[ offs ].ungrabF( tin0P ) ; // -------------------------------------------------------------------------------------------------

                        }
                            ppSex[ offs ] = pSexNew ;

                                                           pPoolContainsMe->pSexLifoConstructed = pSexNew ;
                            pSexNew->pSexLifoConstructed = pPoolContainsMe->pSexLifoConstructed           ;
                        {
                        else
                        if( POOP ) { DELzOMBIE( pSexNew ) ; }

                        }
                            if( !POOP ) dropHeader = dropHeader << CbITSeXPsLOTS | ( offs - expSlotsMin ) ;
                            IMPOTENCEiFsHIFTlEFTwOULDlOSEbITS( dropHeader , CbITSeXPsLOTS ) ;
                            countT& dropHeader = ((countT*)pbo)[ - 1 ] ;
                        {
                        if( pbo && cbDropHeader )

                        //20180509@1131:  WHEN sexC NESTING IS DISABLED, sexC INSTANCES CAN BE CONSTRUCTED WITH NO SLOTS AVAILABLE, SO CANNOT DO THIS:  if( !pbo ) { B LAMMO ; } // TO MAKE SURE THAT sexC::sexC SETS IMPOTENCE IF IT FAILS FOR EITHER REASON (RECURSION OR INSUFFICIENT CONTIGUOUS MEMORY)
                        pbo = pSexNew->newF( tin0P , idLineP , idiFileP ) ;
                        _IO_
                    {
                    else
                    }
                        inc02AM( pcTallyOut[ offs ] ) ;
                        pGrabNewElt[ offs ].ungrabF( tin0P ) ; // -------------------------------------------------------------------------------------------------
                        DELzOMBIE( pSexNew ) ;
                        _IO_
                    {
                    if( (const poopC&)*pSexNew ) // *pSexNew CT FAILED, EITHER BECAUSE IT DETECTED THAT IT CT'D ITSELF RECURSIVELY OR BECAUSE INSUFFICIENT CONTIGUOUS MEMORY IS AVAILABLE
                {
                else
                }
                    inc02AM( pcTallyOut[ offs ] ) ;
                    pGrabNewElt[ offs ].ungrabF( tin0P ) ; // --------------------------------------------------------------------------------------------
                {
                if( !pSexNew )

                }
                    pSexNew = new( 0 , tin0P , pbzaUse , sizeof( sexC ) ) sexC( tin0P , TAG( TAGiDnULL ) , idLineP , idiFileP , ostoName , expCbDrop , cbDropAdjust , offs , cbDropSeparator , flagsc , idStateSpace , idMemorySpace , pPoolContainsMe ) ;
                    tlsAllocStackExp_a_C tls( tin0P ) ;
                {
                ZE( sexC* , pSexNew ) ;

                __( pbzaUse == (byteT*)ppSex[ offs ] ) ;
                byteT* pbzaUse = pbza + offs * sizeof( sexC ) ;

                OStEXTCF( ostoName , offs , '0' ) ;
                OStEXTAK( ostoName , ".slotsC.sex." ) ;
                OStEXTA(  ostoName , postName ) ;
                OStEXT(   ostoName , TUCK << 2 )

                const flagsT maskExpSlots  = 1 << offs      ;
                const flagsT maskExpCbDrop = 1 << expCbDrop ;

                //WHEN GET HERE, I HAVE GRABBED AN offs VALUE FOR WHICH !ppSex[ offs ]
            {
            if( !POOP )

            __( offs == sizeof ppSex / sizeof ppSex[ 0 ] ) ;
            }
                }
                    inc02AM( pcTallyOut[ offs ] ) ;
                    pGrabNewElt[ offs ].ungrabF( tin0P ) ; // --------------------------------------------------------------------------------------------
                    _IO_
                {
                else
                if( pGrabNewElt[ offs ].cGrabbedF() == 1 && !ppSex[ offs ] ) break ;        //20250430@1057: ADD !ppSex[ offs ] TEST, AND ELIMINATE "RETRY FROM BEGINNING", TO ELIMINATE INFINITE LOOP

                inc02AM( pcTallyIn[ offs ] ) ;
                pGrabNewElt[ offs ].grabF( tin0P , TAG( TAGiDnULL ) ) ; // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            {
            for( ; offs < sizeof ppSex / sizeof ppSex[ 0 ] ; offs ++ )                              // INCREMENT offs UNTIL IT DOES NOT POINT TO A sexC THAT THIS THREAD HAS ALREADY GRABBED
            // SET offs TO POINT TO THE SMALLEST UNGRABBED OFFSET FOR WHICH sexC INSTANCE DOES NOT YET EXIST (SERIALIZED)

            }
                break ;
                inc02AM( pcTallyOut[ offs ] ) ;

                }
                    continue ; // INTENTIONALLY NOT SERIALIZED, FOR SPEED.  WILL BE RECHECKED WITHIN SERIALIZED BLOCK OF CODE
                    inc02AM( pcTallyOut[ offs ] ) ;
                {
                if( ppSex[ offs ] )
                inc02AM( pcTallyIn[ offs ] ) ;
                _IO_
            {
            for( ; offs < sizeof ppSex / sizeof ppSex[ 0 ] ; offs ++ )
            countT offs = expSlotsMin ;
            // SET offs TO POINT TO THE SMALLEST UNALLOCATED OFFSET (NOT SERIALIZED)

            if( F(flagsCt) & flSLOTSc_NOdROPhEADERS ) flagsc |= fliSEXc_NOdROPhEADERS ;
            if( F(flagsCt) & flSLOTSc_NOsEXiNpOOL   ) flagsc |= fliSEXc_NOsEXiNpOOL   ;
            if( F(flagsCt) & flSLOTSc_NOTES         ) flagsc |= fliSEXc_NOTES         ;
            if( F(flagsCt) & flSLOTSc_READoNLY      ) flagsc |= fliSEXc_READoNLY      ;
            flagsT flagsc                                     = fliSEXc_null          ;

            //ALLOCATE THE SMALLEST UNALLOCATED sexC EXTENT
            _IO_
        {
        if( !POOP && !pbo && !( F(flagsP) & flSLOTScnEW_DOnOTcTsEXc ) )

        }
            inc02AM( pcTallyOut[ offs ] ) ;
            }
                }
                    break ;
                    inc02AM( pcTallyOut[ offs ] ) ;

                    }
                        }
                            #endif
                                }
                                    putNegAM( pDropNote->finger , FINGERnEG_dropNoteSlotsHasAdjustedDropHeader ) ;
                                    pDropNote->dropHeaderCopy = dropHeader ;
                                {
                                if( pDropNote )
                            #if defined( ENABLEdROPnOTES )

                            dropHeader = dropHeader << CbITSeXPsLOTS | ( offs - expSlotsMin ) ;
                        {
                        if( !POOP )

                        IMPOTENCEiFsHIFTlEFTwOULDlOSEbITS( dropHeader , CbITSeXPsLOTS ) ;
                        countT& dropHeader = ((countT*)pbo)[ - 1 ] ;
                    {
                    if( cbDropHeader )

                    #endif
                        if( pDropNote ) putNegAM( pDropNote->finger , FINGERnEG_dropNoteSlotsIsAdjustingDropHeader ) ;
                        dropNoteS* pDropNote = ppSex[ offs ]->pDropNoteF( tin0P , pbo ) ;
                    #if defined( ENABLEdROPnOTES )

                    _IO_
                {
                if( pbo )

                pbo = ppSex[ offs ]->newF( tin0P , idLineP , idiFileP ) ;

                //}
                //    }
                //        pGrabNewElt[ offs ].ungrabF( tin0P ) ; // --------------------------------------------------------------------------------------------
                //        pGrabNewElt[ offs ].grabF( tin0P , TAG( TAGiDnULL ) ) ; // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                //    {
                //    if( !( idIn % ( TUCK >> 2 ) ) )             // SO I DON'T SLOW THINGS DOWN TOO MUCH
                //    countT idIn = 1 + incv02AM( idInLath ) ;
                //    static countT idInLath ;
                //{
                //TO FIND A BUG (NONMONOTONIC GRAB IN booksC::writeF)

                //}
                //    countT foo = 2 ;
                //{
                //if( idIn == 1 )
                //countT idIn = 1 + incv02AM( idInLath ) ;
                //static countT idInLath ;
                _IO_
            {
            if( ppSex[ offs ] )
            inc02AM( pcTallyIn[ offs ] ) ;
            _IO_
        {
        for( sCountT offs = sizeof ppSex / sizeof ppSex[ 0 ] - 1 ; - 1 + (sCountT)expSlotsMin < offs ; offs -- )
        // TRYING TO ALLOCATE FROM EXISTING sexC INSTANCES, LARGEST WOTH ; USE THE LARGEST AVAILABLE SEX TO ALLOW SMALLER EXTENTS TO BECOME EMPTY AND BE DELETED ; THIS ENCOURAGES DENSITY SO REDUCES PAGING

        _IO_
    {
    ZE( byteT* , pbo ) ;

    //}
    //    }
    //        countT foo = 2 ;
    //    {
    //    if( idIn == 0x39 || idIn == 0xac )
    //    //if( idIn == 0xac )
    //
    //    CONoUTrAW3( "\r\nslotsC::newF [idIn]:    " , idIn , "\r\n" ) ;
    //    countT idIn = 1 + incv02AM( idInLath ) ;
    //    static countT idInLath ;
    //{
    //if( ((tin1S&)tin0P).pc Utility[ 0 ] )

    }
        if( POOP ) return 0 ;
        __( F(flagsCt) & flSLOTSc_READoNLY ) ;
        __( F(((tin1S&)tin0P).flagsThreadMode2) & flTHREADmODE2_DISALLOWpUSE ) ;
        FV( flSLOTScnEW , flagsP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL                 //20131223@1504: ADDED WITHOUT ANALYSIS; BEFORE, I WOULD DO WORK EVEN IF POOP

    POOPIE                      //P:PERSONALITY: I FAIL SILENTLY ; CALLER MUST INSPECT MY RETURN VALUE TO DETECT NULL
{
/*1*/byteT* slotsC::newF( tin0S& tin0P , const countT idLineP , const countT idiFileP , const flagsT flagsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

