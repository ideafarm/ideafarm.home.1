
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbo ;

    }
        THREADmODE1rESTORE
        }
            //}
            //    ++ s ; thirdC::dosSleepRWinkIF( tin0P ) ;
            //    _IO_
            //{
            //
            //if( pbo || F(flagsP) & flSLOTScnEW_DOnOTbLOCK ) break ;       //IF !flSLOTScnEW_DOnOTbLOCK, WILL BLOCK UNTIL SUCCEED IN GETTING A DROP ALLOCATED
            //20250429@1316: P:PERSONALITY: CHANGED SO NOW I ONLY TRY WO TIME AND ALWAYS RETURN, SO CALLER MUST CHECK TO SEE WHETHER I RETURN A NULL VALUE

            break ;

            }
                }
                    }
                        }
                            inc02AM( pcTallyOut[ offs ] ) ;
                            pGrabNewElt[ offs ].ungrabF( tin0P ) ; // -------------------------------------------------------------------------------------------------

                            }
                                ppSex[ offs ] = pSexNew ;

                                                               pPoolContainsMe->pSexLifoConstructed = pSexNew ;
                                pSexNew->pSexLifoConstructed = pPoolContainsMe->pSexLifoConstructed           ;
                            {
                            else
                            if( POOP ) { DELzOMBIE( pSexNew ) ; }

                            }
                                if( !POOP ) dropHeader = dropHeader << CbITSeXPsLOTS | ( offs - expSlotsMin ) ;
                                IMPOTENCEiFsHIFTlEFTwOULDlOSEbITS( dropHeader , CbITSeXPsLOTS ) ;
                                countT& dropHeader = ((countT*)pbo)[ - 1 ] ;
                            {
                            if( pbo && cbDropHeader )

                            //20180509@1131:  WHEN sexC NESTING IS DISABLED, sexC INSTANCES CAN BE CONSTRUCTED WITH NO SLOTS AVAILABLE, SO CANNOT DO THIS:  if( !pbo ) { B LAMMO ; } // TO MAKE SURE THAT sexC::sexC SETS IMPOTENCE IF IT FAILS FOR EITHER REASON (RECURSION OR INSUFFICIENT CONTIGUOUS MEMORY)
                            pbo = pSexNew->newF( tin0P , idLineP , idiFileP ) ;
                            _IO_
                        {
                        else
                        }
                            inc02AM( pcTallyOut[ offs ] ) ;
                            pGrabNewElt[ offs ].ungrabF( tin0P ) ; // -------------------------------------------------------------------------------------------------
                            DELzOMBIE( pSexNew ) ;
                            _IO_
                        {
                        if( (const poopC&)*pSexNew ) // *pSexNew CT FAILED, EITHER BECAUSE IT DETECTED THAT IT CT'D ITSELF RECURSIVELY OR BECAUSE INSUFFICIENT CONTIGUOUS MEMORY IS AVAILABLE
                    {
                    else
                    }
                        inc02AM( pcTallyOut[ offs ] ) ;
                        pGrabNewElt[ offs ].ungrabF( tin0P ) ; // --------------------------------------------------------------------------------------------
                    {
                    if( !pSexNew )

                    }
                        pSexNew = new( 0 , tin0P , pbzaUse , sizeof( sexC ) ) sexC( tin0P , TAG( TAGiDnULL ) , idLineP , idiFileP , ostoName , expCbDrop , cbDropAdjust , offs , cbDropSeparator , flagsc , idStateSpace , idMemorySpace , pPoolContainsMe ) ;
                        tlsAllocStackExp_a_C tls( tin0P ) ;
                    {
                    ZE( sexC* , pSexNew ) ;
                {
                if( !POOP )

                __( pbzaUse == (byteT*)ppSex[ offs ] ) ;
                byteT* pbzaUse = pbza + offs * sizeof( sexC ) ;

                OStEXTCF( ostoName , offs , '0' ) ;
                OStEXTAK( ostoName , ".slotsC.sex." ) ;
                OStEXTA(  ostoName , postName ) ;
                OStEXT(   ostoName , TUCK << 2 )

                const flagsT maskExpSlots  = 1 << offs      ;
                const flagsT maskExpCbDrop = 1 << expCbDrop ;

                }
                    continue ;
                    offPass = - 1 ;
                    inc02AM( pcTallyOut[ offs ] ) ;
                    pGrabNewElt[ offs ].ungrabF( tin0P ) ; // --------------------------------------------------------------------------------------------
                    _IO_
                {
                if( ppSex[ offs ] )
                // IF THIS OFFSET HAS A sexC INSTANCE THEN START OVER FROM THE BEGINNING

                }
                    }
                        inc02AM( pcTallyOut[ offs ] ) ;
                        pGrabNewElt[ offs ].ungrabF( tin0P ) ; // --------------------------------------------------------------------------------------------
                        _IO_
                    {
                    else
                    if( pGrabNewElt[ offs ].cGrabbedF() == 1 ) break ;

                    inc02AM( pcTallyIn[ offs ] ) ;
                    pGrabNewElt[ offs ].grabF( tin0P , TAG( TAGiDnULL ) ) ; // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                {
                for( ; offs < sizeof ppSex / sizeof ppSex[ 0 ] ; offs ++ )                              // INCREMENT offs UNTIL IT DOES NOT POINT TO A sexC THAT THIS THREAD HAS ALREADY GRABBED
                // SET offs TO POINT TO THE SMALLEST UNGRABBED OFFSET (SERIALIZED)

                }
                    break ;
                    inc02AM( pcTallyOut[ offs ] ) ;

                    }
                        continue ; // INTENTIONALLY NOT SERIALIZED, FOR SPEED.  WILL BE RECHECKED WITHIN SERIALIZED BLOCK OF CODE
                        inc02AM( pcTallyOut[ offs ] ) ;
                    {
                    if( ppSex[ offs ] )
                    inc02AM( pcTallyIn[ offs ] ) ;
                    _IO_
                {
                for( ; offs < sizeof ppSex / sizeof ppSex[ 0 ] ; offs ++ )
                countT offs = expSlotsMin ;
                // SET offs TO POINT TO THE SMALLEST UNALLOCATED OFFSET (NOT SERIALIZED)

                if( F(flagsCt) & flSLOTSc_NOdROPhEADERS ) flagsc |= fliSEXc_NOdROPhEADERS ;
                if( F(flagsCt) & flSLOTSc_NOsEXiNpOOL   ) flagsc |= fliSEXc_NOsEXiNpOOL   ;
                if( F(flagsCt) & flSLOTSc_NOTES         ) flagsc |= fliSEXc_NOTES         ;
                if( F(flagsCt) & flSLOTSc_READoNLY      ) flagsc |= fliSEXc_READoNLY      ;
                flagsT flagsc                                     = fliSEXc_null          ;

                //ALLOCATE THE SMALLEST UNALLOCATED sexC EXTENT
                _IO_
            {
            if( !( F(flagsP) & flSLOTScnEW_DOnOTcTsEXc ) )

            if( POOP || pbo ) break ;

            }
                inc02AM( pcTallyOut[ offs ] ) ;
                }
                    }
                        break ;
                        inc02AM( pcTallyOut[ offs ] ) ;

                        }
                            }
                                #endif
                                    }
                                        putNegAM( pDropNote->finger , FINGERnEG_dropNoteSlotsHasAdjustedDropHeader ) ;
                                        pDropNote->dropHeaderCopy = dropHeader ;
                                    {
                                    if( pDropNote )
                                #if defined( ENABLEdROPnOTES )

                                dropHeader = dropHeader << CbITSeXPsLOTS | ( offs - expSlotsMin ) ;
                            {
                            if( !POOP )

                            IMPOTENCEiFsHIFTlEFTwOULDlOSEbITS( dropHeader , CbITSeXPsLOTS ) ;
                            countT& dropHeader = ((countT*)pbo)[ - 1 ] ;
                        {
                        if( cbDropHeader )

                        #endif
                            if( pDropNote ) putNegAM( pDropNote->finger , FINGERnEG_dropNoteSlotsIsAdjustingDropHeader ) ;
                            dropNoteS* pDropNote = ppSex[ offs ]->pDropNoteF( tin0P , pbo ) ;
                        #if defined( ENABLEdROPnOTES )

                        _IO_
                    {
                    if( pbo )

                    pbo = ppSex[ offs ]->newF( tin0P , idLineP , idiFileP ) ;

                    //}
                    //    }
                    //        pGrabNewElt[ offs ].ungrabF( tin0P ) ; // --------------------------------------------------------------------------------------------
                    //        pGrabNewElt[ offs ].grabF( tin0P , TAG( TAGiDnULL ) ) ; // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                    //    {
                    //    if( !( idIn % ( TUCK >> 2 ) ) )             // SO I DON'T SLOW THINGS DOWN TOO MUCH
                    //    countT idIn = 1 + incv02AM( idInLath ) ;
                    //    static countT idInLath ;
                    //{
                    //TO FIND A BUG (NONMONOTONIC GRAB IN booksC::writeF)

                    //}
                    //    countT foo = 2 ;
                    //{
                    //if( idIn == 1 )
                    //countT idIn = 1 + incv02AM( idInLath ) ;
                    //static countT idInLath ;
                    _IO_
                {
                if( ppSex[ offs ] )
                inc02AM( pcTallyIn[ offs ] ) ;
                _IO_
            {
            for( sCountT offs = sizeof ppSex / sizeof ppSex[ 0 ] - 1 ; - 1 + (sCountT)expSlotsMin < offs ; offs -- )
            // TRYING TO ALLOCATE FROM EXISTING sexC INSTANCES, LARGEST WOTH ; USE THE LARGEST AVAILABLE SEX TO ALLOW SMALLER EXTENTS TO BECOME EMPTY AND BE DELETED ; THIS ENCOURAGES DENSITY SO REDUCES PAGING

            _IO_
        {
        for( countT offPass = 0 ; !offPass ; offPass ++ )           // SEE THE continue STATEMENT ; DONE THIS WAY FOR SPEED, TO AVOID SERIALIZATION

        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        _IO_
    {
    ZE( byteT* , pbo ) ;

    //}
    //    }
    //        countT foo = 2 ;
    //    {
    //    if( idIn == 0x39 || idIn == 0xac )
    //    //if( idIn == 0xac )
    //
    //    CONoUTrAW3( "\r\nslotsC::newF [idIn]:    " , idIn , "\r\n" ) ;
    //    countT idIn = 1 + incv02AM( idInLath ) ;
    //    static countT idInLath ;
    //{
    //if( ((tin1S&)tin0P).pc Utility[ 0 ] )

    }
        if( POOP ) return 0 ;
        __( F(flagsCt) & flSLOTSc_READoNLY ) ;
        __( F(((tin1S&)tin0P).flagsThreadMode2) & flTHREADmODE2_DISALLOWpUSE ) ;
        FV( flSLOTScnEW , flagsP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL                 //20131223@1504: ADDED WITHOUT ANALYSIS; BEFORE, I WOULD DO WORK EVEN IF POOP

    POOPIE                      //P:PERSONALITY: I FAIL SILENTLY ; CALLER MUST INSPECT MY RETURN VALUE TO DETECT NULL
{
/*1*/byteT* slotsC::newF( tin0S& tin0P , const countT idLineP , const countT idiFileP , const flagsT flagsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

