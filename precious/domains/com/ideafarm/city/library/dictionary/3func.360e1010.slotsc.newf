
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbo ;

    }
        THREADmODE2rESTORE
        }
            }
                ++ s ; thirdC::dosSleepRWinkIF( tinP ) ;
                _IO_
            {

            if( pbo || F(flagsP) & flSLOTScnEW_DOnOTbLOCK ) break ;

            }
                }
                    inc02AM( pcTallyOut[ offs ] ) ;
                    pGrabNewElt[ offs ].ungrabF( tinP ) ; // -------------------------------------------------------------------------------------------------

                    ppSex[ offs ] = pSexNew ;

                                                   pPoolContainsMe->pSexLifoConstructed = pSexNew ;
                    pSexNew->pSexLifoConstructed = pPoolContainsMe->pSexLifoConstructed           ;

                    }
                        dropHeader = dropHeader << CbITSeXPsLOTS | ( offs - expSlotsMin ) ;
                        BLAMMOiFsHIFTlEFTwOULDlOSEbITS( dropHeader , CbITSeXPsLOTS ) ;
                        countT& dropHeader = ((countT*)pbo)[ - 1 ] ;
                    {
                    if( pbo )

                    //20180509@1131:  WHEN sexC NESTING IS DISABLED, sexC INSTANCES CAN BE CONSTRUCTED WITH NO SLOTS AVAILABLE, SO CANNOT DO THIS:  if( !pbo ) { BLAMMO ; } // TO MAKE SURE THAT sexC::sexC SETS IMPOTENCE IF IT FAILS FOR EITHER REASON (RECURSION OR INSUFFICIENT CONTIGUOUS MEMORY)
                    pbo = pSexNew->newF( tinP , idLineP , idiFileP ) ;
                    _IO_
                {
                else //U::BUG: SHOULD BE "else if( pSexNew )"
                }
                    inc02AM( pcTallyOut[ offs ] ) ;
                    pGrabNewElt[ offs ].ungrabF( tinP ) ; // -------------------------------------------------------------------------------------------------
                    DELzOMBIE( pSexNew ) ;
                    _IO_
                {
                if( pSexNew && (const poopC&)*pSexNew ) // *pSexNew CT FAILED, EITHER BECAUSE IT DETECTED THAT IT CT'D ITSELF RECURSIVELY OR BECAUSE INSUFFICIENT CONTIGUOUS MEMORY IS AVAILABLE

                sexC* pSexNew = new( 0 , tinP , pbzaUse , sizeof( sexC ) ) sexC( tinP , TAG( TAGiDnULL ) , idLineP , idiFileP , ostoName , expCbDrop , cbDropAdjust , offs , cbDropSeparator , flagsc , idStateSpace , idMemorySpace , pPoolContainsMe ) ;

                if( pbzaUse == (byteT*)ppSex[ offs ] ) { BLAMMO ; }
                byteT* pbzaUse = pbza + offs * sizeof( sexC ) ;

                OStEXTCF( ostoName , offs , '0' ) ;
                OStEXTAK( ostoName , ".slotsC.sex." ) ;
                OStEXTA(  ostoName , postName ) ;
                OStEXT(   ostoName , TUCK << 2 )

                const flagsT maskExpSlots  = 1 << offs      ;
                const flagsT maskExpCbDrop = 1 << expCbDrop ;

                }
                    continue ;
                    offPass = - 1 ;
                    inc02AM( pcTallyOut[ offs ] ) ;
                    pGrabNewElt[ offs ].ungrabF( tinP ) ; // --------------------------------------------------------------------------------------------
                    _IO_
                {
                if( ppSex[ offs ] )

                }
                    }
                        inc02AM( pcTallyOut[ offs ] ) ;
                        pGrabNewElt[ offs ].ungrabF( tinP ) ; // --------------------------------------------------------------------------------------------
                        _IO_
                    {
                    else
                    if( pGrabNewElt[ offs ].cGrabbedF() == 1 ) break ;

                    inc02AM( pcTallyIn[ offs ] ) ;
                    pGrabNewElt[ offs ].grabF( tinP , TAG( TAGiDnULL ) ) ; // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                {
                for( ; offs < sizeof ppSex / sizeof ppSex[ 0 ] ; offs ++ )                              // INCREMENT offs UNTIL IT DOES NOT POINT TO A sexC THAT THIS THREAD HAS ALREADY GRABBED

                }
                    break ;
                    inc02AM( pcTallyOut[ offs ] ) ;

                    }
                        continue ; // INTENTIONALLY NOT SERIALIZED, FOR SPEED.  WILL BE RECHECKED WITHIN SERIALIZED BLOCK OF CODE
                        inc02AM( pcTallyOut[ offs ] ) ;
                    {
                    if( ppSex[ offs ] )
                    inc02AM( pcTallyIn[ offs ] ) ;
                    _IO_
                {
                for( ; offs < sizeof ppSex / sizeof ppSex[ 0 ] ; offs ++ )
                countT offs = expSlotsMin ;                                         //ALLOCATE THE SMALLEST UNALLOCATED EXTENT

                if( F(flagsCt) & flSLOTSc_NOsEXiNpOOL ) flagsc |= fliSEXc_NOsEXiNpOOL ;
                if( F(flagsCt) & flSLOTSc_NOTES       ) flagsc |= fliSEXc_NOTES       ;
                if( F(flagsCt) & flSLOTSc_READoNLY    ) flagsc |= fliSEXc_READoNLY    ;
                flagsT flagsc                                   = fliSEXc_null        ;
                _IO_
            {
            if( !( F(flagsP) & flSLOTScnEW_DOnOTcTsEXc ) )

            if( pbo ) break ;

            }
                inc02AM( pcTallyOut[ offs ] ) ;
                }
                    }
                        break ;
                        inc02AM( pcTallyOut[ offs ] ) ;

                        }
                            putNegAM( pDropNote->finger , FINGERnEG_dropNoteSslotsC2 ) ;
                            pDropNote->dropHeaderCopy = dropHeader ;
                        {
                        if( pDropNote )

                        dropHeader = dropHeader << CbITSeXPsLOTS | ( offs - expSlotsMin ) ;
                        BLAMMOiFsHIFTlEFTwOULDlOSEbITS( dropHeader , CbITSeXPsLOTS ) ;

                        countT& dropHeader = ((countT*)pbo)[ - 1 ] ;

                        if( pDropNote ) putNegAM( pDropNote->finger , FINGERnEG_dropNoteSslotsC1 ) ;

                        dropNoteS* pDropNote = ppSex[ offs ]->pDropNoteF( tinP , pbo ) ;
                        _IO_
                    {
                    if( pbo )

                    pbo = ppSex[ offs ]->newF( tinP , idLineP , idiFileP ) ;

                    //}
                    //    }
                    //        pGrabNewElt[ offs ].ungrabF( tinP ) ; // --------------------------------------------------------------------------------------------
                    //        pGrabNewElt[ offs ].grabF( tinP , TAG( TAGiDnULL ) ) ; // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                    //    {
                    //    if( !( idIn % ( TUCK >> 2 ) ) )             // SO I DON'T SLOW THINGS DOWN TOO MUCH
                    //    countT idIn = 1 + incv02AM( idInLath ) ;
                    //    static countT idInLath ;
                    //{
                    //TO FIND A BUG (NONMONOTONIC GRAB IN booksC::writeF)

                    //}
                    //    countT foo = 2 ;
                    //{
                    //if( idIn == 1 )
                    //countT idIn = 1 + incv02AM( idInLath ) ;
                    //static countT idInLath ;
                    _IO_
                {
                if( ppSex[ offs ] )
                inc02AM( pcTallyIn[ offs ] ) ;
                _IO_
            {
            for( sCountT offs = sizeof ppSex / sizeof ppSex[ 0 ] - 1 ; - 1 + (sCountT)expSlotsMin < offs ; offs -- )

            if( offPass > 1 ) { BLAMMO ; }
            _IO_
        {
        for( countT offPass = 0 ; ; offPass ++ ) //IF !flSLOTScnEW_DOnOTbLOCK, WILL BLOCK UNTIL SUCCEED IN GETTING A DROP ALLOCATED

        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        //THIS ENCOURAGES DENSITY SO REDUCES PAGING
        //USE THE LARGEST AVAILABLE SEX TO ALLOW SMALLER EXTENTS TO BECOME EMPTY AND BE DELETED
        if( F(flagsCt) & flSLOTSc_READoNLY ) { BLAMMO ; }
        if( F(tinP.flagsThreadMode3) & flTHREADmODE3_DISALLOWpUSE ) { BLAMMO ; }
        _IO_
    {
    ZE( byteT* , pbo ) ;

    //}
    //    }
    //        countT foo = 2 ;
    //    {
    //    if( idIn == 0x39 || idIn == 0xac )
    //    //if( idIn == 0xac )
    //
    //    CONoUTrAW3( "\r\nslotsC::newF [idIn]:    " , idIn , "\r\n" ) ;
    //    countT idIn = 1 + incv02AM( idInLath ) ;
    //    static countT idInLath ;
    //{
    //if( tinP.pc Utility[ 0 ] )

    }
        if( POOP ) return 0 ;
        FV( flSLOTScnEW , flagsP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL                 //20131223@1504: ADDED WITHOUT ANALYSIS; BEFORE, I WOULD DO WORK EVEN IF POOP
{
/*1*/byteT* slotsC::newF( tinS& tinP , const countT idLineP , const countT idiFileP , const flagsT flagsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

