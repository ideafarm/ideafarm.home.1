
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbo ;

    }
        THREADmODE2rESTORE
        }
            }
                ++ s ; thirdC::dosSleepRWinkIF( tinP ) ;
                _IO_
            {

            if( pbo || F(flagsP) & flSLOTScnEW_DOnOTbLOCK ) break ;

            }
                }
                    inc02AM( pcTallyOut[ offs ] ) ;
                    pGrabNewElt[ offs ].ungrabF( tinP ) ; // -------------------------------------------------------------------------------------------------

                    ppSex[ offs ] = pSexNew ;

                                                   pPoolContainsMe->pSexLifoConstructed = pSexNew ;
                    pSexNew->pSexLifoConstructed = pPoolContainsMe->pSexLifoConstructed           ;

                    }
                        dropHeader = dropHeader << CbITSeXPsLOTS | ( offs - expSlotsMin ) ;
                        BLAMMOiFsHIFTlEFTwOULDlOSEbITS( dropHeader , CbITSeXPsLOTS ) ;
                        countT& dropHeader = ((countT*)pbo)[ - 1 ] ;
                    {
                    if( pbo )

                    //20180509@1131:  WHEN sexC NESTING IS DISABLED, sexC INSTANCES CAN BE CONSTRUCTED WITH NO SLOTS AVAILABLE, SO CANNOT DO THIS:  if( !pbo ) { BLAMMO ; } // TO MAKE SURE THAT sexC::sexC SETS IMPOTENCE IF IT FAILS FOR EITHER REASON (RECURSION OR INSUFFICIENT CONTIGUOUS MEMORY)
                    pbo = pSexNew->newF( tinP , idLineP , idiFileP ) ;
                    _IO_
                {
                else //U::BUG: SHOULD BE "else if( pSexNew )"
                }
                    inc02AM( pcTallyOut[ offs ] ) ;
                    pGrabNewElt[ offs ].ungrabF( tinP ) ; // -------------------------------------------------------------------------------------------------
                    DELzOMBIE( pSexNew ) ;
                    _IO_
                {
                if( pSexNew && (const poopC&)*pSexNew ) // *pSexNew CT FAILED, EITHER BECAUSE IT DETECTED THAT IT CT'D ITSELF RECURSIVELY OR BECAUSE INSUFFICIENT CONTIGUOUS MEMORY IS AVAILABLE

                sexC* pSexNew = new( 0 , tinP , pbzaUse , sizeof( sexC ) ) sexC( tinP , TAG( TAGiDnULL ) , idLineP , idiFileP , ostoName , expCbDrop , offs , flagsc , idStateSpace , idMemorySpace , pPoolContainsMe ) ;

                if( pbzaUse == (byteT*)ppSex[ offs ] ) { BLAMMO ; }
                byteT* pbzaUse = ( !bNested ? pbza1 : pbza2 ) + offs * sizeof( sexC ) ;

                OStEXTCF( ostoName , offs , '0' ) ;
                OStEXTAK( ostoName , ".slotsC.sex." ) ;
                OStEXTA(  ostoName , postName ) ;
                OStEXT(   ostoName , TUCK << 2 )

                boolT bNest2 = !!( tinP.fliSexCtPendingExpSlots  & maskExpSlots  ) ;
                boolT bNest1 = !!( tinP.fliSexCtPendingExpCbDrop & maskExpCbDrop ) ;
                const flagsT maskExpSlots  = 1 << offs      ;
                const flagsT maskExpCbDrop = 1 << expCbDrop ;

                //if( bNested > 1 ) { BLAMMO ; }
                //countT bNested = pGrabNewElt[ offs ].cGrabbedF() - 1 ;
                //20170928@1030: DISABLED WITHOUT ANALYIS TO WORKAROUND: SEE PRECEDING CODE THAT NOW MERELY CONTNINUES THE LOOP

                }
                    continue ;
                    offPass = - 1 ;
                    inc02AM( pcTallyOut[ offs ] ) ;
                    pGrabNewElt[ offs ].ungrabF( tinP ) ; // --------------------------------------------------------------------------------------------
                    _IO_
                {
                if( ppSex[ offs ] )

                }
                    continue ;
                    offPass = - 1 ;
                    inc02AM( pcTallyOut[ offs ] ) ;
                    pGrabNewElt[ offs ].ungrabF( tinP ) ; // --------------------------------------------------------------------------------------------
                    _IO_
                {
                if( bNested > 1 )
                countT bNested = pGrabNewElt[ offs ].cGrabbedF() - 1 ;              //20170928@1030: ADDED WITHOUT ANALYIS TO WORKAROUND: SEE THE COMMENTED OUT BLAMMO CODE THAT FOLLOWS

                inc02AM( pcTallyIn[ offs ] ) ;
                pGrabNewElt[ offs ].grabF( tinP , TAG( TAGiDnULL ) ) ; // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

                }
                    break ;
                    inc02AM( pcTallyOut[ offs ] ) ;

                    }
                        continue ; // INTENTIONALLY NOT SERIALIZED, FOR SPEED.  WILL BE RECHECKED WITHIN SERIALIZED BLOCK OF CODE
                        inc02AM( pcTallyOut[ offs ] ) ;
                    {
                    if( ppSex[ offs ] )
                    inc02AM( pcTallyIn[ offs ] ) ;
                    _IO_
                {
                for( ; offs < sizeof ppSex / sizeof ppSex[ 0 ] ; offs ++ )
                countT offs = expSlotsMin ;                                         //ALLOCATE THE SMALLEST UNALLOCATED EXTENT

                if( F(flagsCt) & flSLOTSc_NOTES    ) flagsc |= fliSEXc_NOTES    ;
                if( F(flagsCt) & flSLOTSc_READoNLY ) flagsc |= fliSEXc_READoNLY ;
                if( F(flagsCt) & flSLOTSc_BROWSE   ) flagsc |= fliSEXc_BROWSE   ;
                flagsT flagsc = fliSEXc_null ;
                _IO_
            {
            if( !( F(flagsP) & flSLOTScnEW_DOnOTcTsEXc ) )

            if( pbo ) break ;

            }
                inc02AM( pcTallyOut[ offs ] ) ;
                }
                    }
                        break ;
                        inc02AM( pcTallyOut[ offs ] ) ;

                        }
                            putNegAM( pDropNote->finger , FINGERnEG_dropNoteSslotsC2 ) ;
                            pDropNote->dropHeaderCopy = dropHeader ;
                        {
                        if( pDropNote )

                        dropHeader = dropHeader << CbITSeXPsLOTS | ( offs - expSlotsMin ) ;
                        BLAMMOiFsHIFTlEFTwOULDlOSEbITS( dropHeader , CbITSeXPsLOTS ) ;

                        countT& dropHeader = ((countT*)pbo)[ - 1 ] ;

                        if( pDropNote ) putNegAM( pDropNote->finger , FINGERnEG_dropNoteSslotsC1 ) ;

                        dropNoteS* pDropNote = ppSex[ offs ]->pDropNoteF( tinP , pbo ) ;
                        _IO_
                    {
                    if( pbo )

                    pbo = ppSex[ offs ]->newF( tinP , idLineP , idiFileP ) ;

                    //}
                    //    }
                    //        pGrabNewElt[ offs ].ungrabF( tinP ) ; // --------------------------------------------------------------------------------------------
                    //        pGrabNewElt[ offs ].grabF( tinP , TAG( TAGiDnULL ) ) ; // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                    //    {
                    //    if( !( idIn % ( TUCK >> 2 ) ) )             // SO I DON'T SLOW THINGS DOWN TOO MUCH
                    //    countT idIn = 1 + incv02AM( idInLath ) ;
                    //    static countT idInLath ;
                    //{
                    //TO FIND A BUG (NONMONOTONIC GRAB IN booksC::writeF)

                    //}
                    //    countT foo = 2 ;
                    //{
                    //if( idIn == 1 )
                    //countT idIn = 1 + incv02AM( idInLath ) ;
                    //static countT idInLath ;
                    _IO_
                {
                if( ppSex[ offs ] )
                inc02AM( pcTallyIn[ offs ] ) ;
                _IO_
            {
            for( sCountT offs = sizeof ppSex / sizeof ppSex[ 0 ] - 1 ; - 1 + (sCountT)expSlotsMin < offs ; offs -- )

            if( offPass > 1 ) { BLAMMO ; }
            _IO_
        {
        for( countT offPass = 0 ; ; offPass ++ ) //IF !flSLOTScnEW_DOnOTbLOCK, WILL BLOCK UNTIL SUCCEED IN GETTING A DROP ALLOCATED

        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        //THIS ENCOURAGES DENSITY SO REDUCES PAGING
        //USE THE LARGEST AVAILABLE SEX TO ALLOW SMALLER EXTENTS TO BECOME EMPTY AND BE DELETED
        if( F(flagsCt) & flSLOTSc_READoNLY ) { BLAMMO ; }
        if( F(tinP.flagsThreadMode3) & flTHREADmODE3_DISALLOWpUSE ) { BLAMMO ; }
        _IO_
    {
    ZE( byteT* , pbo ) ;

    }
        if( POOP ) return 0 ;
        FV( flSLOTScnEW , flagsP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL                 //20131223@1504: ADDED WITHOUT ANALYSIS; BEFORE, I WOULD DO WORK EVEN IF POOP
{
/*1*/byteT* slotsC::newF( tinS& tinP , const countT idLineP , const countT idiFileP , const flagsT flagsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

