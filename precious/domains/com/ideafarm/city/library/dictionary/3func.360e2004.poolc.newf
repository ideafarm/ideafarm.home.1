
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        countT foo = 2 ;
        CONoUTrAW( "=======================================\r\n" ) ;
    {
    if( (countT)pbP == 0x20950808 )

    }
        //}
        //    }
        //        }
        //            countT foo = 2 ;
        //        {
        //        if( idIn == TUCK )
        //
        //        countT idIn = 1 + incv02AM( idInLath ) ;
        //        static countT idInLath ;
        //    {
        //    if( cbP == 0x241b0 )
        //    CONoUTrAW3( "\r\npoolC::newF - [cbP]: " , cbP , "" ) ;
        //{
        //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) //TO FIND A BUG

        }
            }
                BLAMMOiD( ((countT*)pbP)[ - 2 ] ) ;
            {
            if( pbP && face.cbDropSeparator == sizeof( countT ) && getNegAM( ((countT*)pbP)[ - 2 ] ) != FINGERnEG_dropSeparator )

            //}
            //    }
            //        CONoUTrAW5( "poolC::newF / after  [offs,guts.ppSlots[offs]:    " , offs , "    " , guts.ppSlots[ offs ] , "\r\n" ) ;
            //    {
            //    for( countT offs = 0 ; offs < sizeof guts.ppSlots / sizeof guts.ppSlots[ 0 ] ; offs ++ )
            //    CONoUTrAW( "\r\nslotsC instances:\r\n" ) ;
            //{
            //if( ((tin1S&)tin0P).pc Utility[ 0 ] )
            //U::DISABLE THIS IN PRODUCTION ; TO FIND A BUG

            }
                }
                    __1
                    __( cbP ) ;
                {
                if( !pbP /*&& !bDoNotBlock*/ )      //20221228@1503: PERSONALITY CHANGE: NOW ADAM TEMP POOL DOES NOT BLOCK, AND HERE I ALWAYS CAUSE IMPOTENCE IF ALLOCATION FAILED, SO CALLING CODE CAN HANDLE GRACEFULLY

                THREADmODE4rESTORE

                }
                    }
                        }
                            putNegAM( pDropNote->finger , FINGERnEG_dropNotePoolHasAdjustedDropHeader ) ;
                            pDropNote->dropHeaderCopy = dropHeader ;
                        {
                        if( pDropNote )

                        dropHeader = dropHeader << guts.cBitsExpCbDrop | offs - guts.expCbDropMin ;

                        BLAMMOiFsHIFTlEFTwOULDlOSEbITS( dropHeader , guts.cBitsExpCbDrop ) ;

                        countT& dropHeader = ((countT*)pbP)[ - 1 ] ;
                    {
                    if( face.cbDropHeader == CBsEXdROPhEADER )

                    if( pDropNote ) putNegAM( pDropNote->finger , FINGERnEG_dropNotePoolIsAdjustingDropHeader ) ;

                    dropNoteS* pDropNote = guts.ppSlots[ offs ]->pDropNoteF( tin0P , pbP ) ;
                {
                else
                }
                    etherC::etRockIF( tin0P ).traceF( tin0P , T("poolC::newF / could not obtain a drop") ) ;
                {
                if( !pbP )

                pbP = guts.ppSlots[ offs ]->newF( tin0P , idLineP , idiFileP , flagsSlots ) ;

                THREADmODE4oN( flTHREADmODE4_DOnOTtESTdROPhEADERS )

                //if( offs == 0x18 ) etherC::etRockIF( tin0P ).traceF( tin0P , T("++++++++ new") ) ; //U::20140808@1936: TO FIND A BUG

                if( bDoNotBlock                        ) flagsSlots |= flSLOTScnEW_DOnOTbLOCK  ;
                if( F(flagsP) & flPOOLcnEW_DOnOTcTsEXc ) flagsSlots |= flSLOTScnEW_DOnOTcTsEXc ;
                flagsT flagsSlots = flSLOTScnEW_null ;
                boolT bDoNotBlock = F(guts.flagsCt) & flPOOLc_DOnOTbLOCK || F(flagsP) & flPOOLcnEW_DOnOTbLOCK ;

                }
                    guts.pGrabNewElt[ offs ].ungrabF( tin0P ) ;
                    }
                        THREADmODE1rESTORE
                        guts.ppSlots[ offs ] = new( 0 , tin0P , guts.pbza + offs * sizeof( slotsC ) , sizeof( slotsC ) ) slotsC( tin0P , TAG( TAGiDnULL ) , idLineP , idiFileP , ostoName , guts.cBitsExpCbDrop , offs , face.pcCbDropAdjust[ offs ] , face.cbDropSeparator , flagsc , guts.idStateSpace , guts.idMemorySpace , this ) ;
                        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                
                        if( F(guts.flagsCt) & flPOOLc_NOdROPhEADERS ) flagsc |= flSLOTSc_NOdROPhEADERS ;
                        if( F(guts.flagsCt) & flPOOLc_NOsEXiNpOOL   ) flagsc |= flSLOTSc_NOsEXiNpOOL   ;
                        if( F(guts.flagsCt) & flPOOLc_NOTES         ) flagsc |= flSLOTSc_NOTES         ;
                        if( F(guts.flagsCt) & flPOOLc_READoNLY      ) flagsc |= flSLOTSc_READoNLY      ;
                        flagsT flagsc = flSLOTSc_null ;

                        OStEXTCF( ostoName , offs , '0' ) ;
                        OStEXTAK( ostoName , ".slots." ) ;
                        OStEXTAK( ostoName , ".poolC" ) ;
                        OStEXTA(  ostoName , guts.postName ) ;
                        OStEXT(   ostoName , TUCK << 2 )
                    {
                    if( !guts.ppSlots[ offs ] )
                    guts.pGrabNewElt[ offs ].grabF( tin0P , TAG( TAGiDnULL ) ) ;
                {
                if( !guts.ppSlots[ offs ] )
            {
            if( offs != - 1 && offs <= guts.expCbDropMax )

            countT offs = expCbDropBigEnoughF( cbP ) ;

            //}
            //    }
            //        CONoUTrAW5( "poolC::newF / before [offs,guts.ppSlots[offs]:    " , offs , "    " , guts.ppSlots[ offs ] , "\r\n" ) ;
            //    {
            //    for( countT offs = 0 ; offs < sizeof guts.ppSlots / sizeof guts.ppSlots[ 0 ] ; offs ++ )
            //    CONoUTrAW( "\r\nslotsC instances:\r\n" ) ;
            //{
            //if( ((tin1S&)tin0P).pc Utility[ 0 ] )
            //DISABLE THIS IN PRODUCTION ; TO FIND A BUG

            if( F(((tin1S&)tin0P).flagsThreadMode2) & flTHREADmODE2_DISALLOWpUSE ) { BLAMMO ; }
            if( this != ((tin1S&)tin0P).pag1->pPoolAdamTemp && !( F(((tin1S&)tin0P).flagsThreadMode2) & flTHREADmODE2_ALLOWnEWdROPnOTiNaDAMtEMP ) ) { BLAMMO ; }

            if( F(guts.flagsCt) & flPOOLc_READoNLY ) { BLAMMO ; }
        {
        else
        else if( F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_POOLaLLOCATEfROMhEAP ) pbP = processGlobal4I.heap.newF( tin0P , idLineP , idiFileP , cbP ) ;
        }
            pbP          = (byteT*)idJot ;
            countT idJot = juse.writeF( tin0P , 0 , cbP ) ;
            jotC&  juse  = *((tin123S&)tin0P).ppJot[ (countT)pbP - JrEQUEST_min ] ;
            if( tin0P.idTypeTin - ifcIDtYPEtIN_123 ) { BLAMMOiD( tin0P.idTypeTin - ifcIDtYPEtIN_123 ) ; }
        {
        if( pbP ) // IF I AM TO DIVERT THIS REQUEST TO A SPECIFIED jotC INSTANCE RATHER THAN ALLOCATE FROM MY sexC INSTANCES

        //}
        //    CONoUTrAW3( "\r\npoolC::newF + [cbP]: " , cbP , "" ) ;
        //{
        //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) //TO FIND A BUG

        //    }
        //        BLAMMOiFcALLEDbY( "bookC" )
        //        BLAMMOiFcALLEDbY( "booksC" )
        //    {
        //    if( thirdC::third_idPhaseAdam_IF( tin0P ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 )
        //    //U:: 20180208@0638: TO ELIMINATE ALL USE OF poolC BY booksC AND bookC

        _IO_
    {

    //}
    //    ((tin1S&)tin0P).pEther->traceF( tin0P , T("poolC::newF called for wo of these suckas") ) ;
    //    BLAMMO ;
    //{
    //if( /*((tin1S&)tin0P).pEther &&*/ idLineP == 0x120 && idiFileP == 0x36008003 )

    }
        if( POOP ) return ;
        FV( flPOOLcnEW , flagsP ) ;
        __Z( ISnULLjpOINTER( pbP ) ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    SCOOP ;  // THIS IS INTENDED TO PREVENT AMBIENT IMPOTENCE FROM AFFECTING ME ; WO REASON IS TO ENSURE THAT C++ CALLS TO OVERLOADED OPERATOR new RETURN A NONZE POINTER IF POSSIBLE ; WHEN AN OVERLOADD new RETURNS 0, C++ (WATCOM) JUMPS IMMEDIATELY BEYOND THE ASSOCIATED CT'OR CALL AND CALLS DT'OR FOR TEMPORARIES (bitsC) THAT WERE NEVER CT'D ; THE ROOT PROBLEM HERE IS THAT THE COMPILER DOES NOT GENERATE CORRECT CODE; THE GENERATED CODE SHOULD JUMP BEYOND THE DT'OR CALLS FOR THE TEMPORARIES
    poopC poop ;
{
/*1*/voidT poolC::newF( tin0S& tin0P , const countT idLineP , const countT idiFileP , byteT*& pbP , const countT cbP , const flagsT flagsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

