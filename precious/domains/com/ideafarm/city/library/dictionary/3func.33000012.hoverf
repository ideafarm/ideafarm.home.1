
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    third.delF( tin0P , postHome ) ;

    }
        thirdC::c_strncpyIF( tin0P , postHoverP , ostoHover , costa ) ;
        third.newF( tin0P , LF , postHoverP , costa ) ; ___( postHoverP ) ;
        countT costa = ostoHover.costF() + 1 ;
        }
            }
                break ;
                cdF( tin0P , third , ostoHover ) ;
                }
                    default                   : { OStEXTAK( ostoHover  , "hover\\"  ) ; break ; }
                    case ifcIDhOVERdIR_MASTER : { OStEXTAK( ostoHover  , "master\\" ) ; break ; }
                {
                switch( idHoverDirP )
                OStEXTAK( ostoHover , "1\\"        ) ; cdF( tin0P , third  , ostoHover ) ;
                OStEXTAK( ostoHover , "exedll\\"   ) ; cdF( tin0P , third  , ostoHover ) ;
            {
            default :
            case ifcIDhOVERdIR_DRIVER : { OStEXTAK( ostoHover , "driver\\"   ) ; cdF( tin0P , third  , ostoHover ) ; break ; }
        {
        switch( idHoverDirP )
        OStEXTAK( ostoHover , "park\\"     ) ; cdF( tin0P , third  , ostoHover ) ;
        OStEXTAK( ostoHover , "city\\"     ) ; cdF( tin0P , third  , ostoHover ) ;
        OStEXTAK( ostoHover , "ideafarm\\" ) ; cdF( tin0P , third  , ostoHover ) ;
        OStEXTAK( ostoHover , "com\\"      ) ; cdF( tin0P , third  , ostoHover ) ;
        OStEXTAK( ostoHover , "domains\\"  ) ; cdF( tin0P , third  , ostoHover ) ;
        OStEXTA( ostoHover , postHome     ) ; cdF( tin0P , third  , ostoHover ) ;
        OStEXT( ostoHover , 0x200 ) //ASSUME: THIS IS LARGE ENOUGH TO HOLD A FILE NAME OF MAX LENGTH

        #endif
            third.dosSetDefaultDiskF( tin0P , postDisk ) ;
        #ifdef __OS2__
    {
    // HOVER

    }
        }
            }
                }
                    third.dosCreateDirF( tin0P , postHome ) ;

                    *postHome = ostDiskBest ;

                    }
                        DEL( pInfo1 ) ;
                        }
                            }
                                ostDiskBest = ostDisk3 ;
                                cbFreeBest = cbFree ;
                            {
                            if( cbFreeBest < cbFree )
                            countT cbFree = pInfo1->cBytesPerSector * pInfo1->cSectorsPerAllocationUnit * pInfo1->cUnusedUnits ;
                        {
                        if( pInfo1 && F(pInfo1->flags) & flINFOdISK1s_LOCAL && third.c_zDiskFLongFileNamesOKF( tin0P , postDisk ) )
                        third.dosQueryFSInfoF( tin0P , pInfo1 , postDisk ) ; ___( pInfo1 ) ;
                        ZE( infoDisk1S* , pInfo1 ) ;
                    {
                    for( ostDisk3 = 'z' ; ostDisk3 >= 'c' ; ostDisk3 -- )
                    ZE( countT , cbFreeBest ) ;
                    ZE( osTextT , ostDiskBest ) ;
                {
                if( !third )

                }
                    //U:COMMENTED OUT WHEN LOGGING SUPPORT REPLACED: thirdC::( tin0P , ostom ) ;

                    OStEXTAK( ostom  , "\" was not found at the root of any local disk" ) ;
                    OStEXTA( ostom  , postHome ) ;
                    OStEXTAK( ostom  , "a folder called \"" ) ;

                    ) ;
                        "\r\n"
                        "to have me create this folder on the disk with the most space, press \"ok\"\r\n"
                        "\r\n"
                        "if you want it to be on a specific disk, select \"cancel\"\r\n"
                        "then manually create the folder at the root of the preferred disk\r\n"
                        "then open me again and i will seach for the folder and use it\r\n"
                        "aok/cmd/log/"
                    OStEXTAK( ostom  , 
                    OStEXT( ostom , 0x800 )
                {

                *postHome = '?' ;
            {
            if( ostDisk3 < 'c' ) // IF DIDN'T FIND HOME

            }
                if( bFound ) break ;
                DEL( pInfo1 ) ;
                }
                    if( bFileOrDirExistsF( tin0P , third , postHome ) && third.c_zDiskFLongFileNamesOKF( tin0P , postDisk ) ) bFound = 1 ;
                    *postHome = ostDisk3 ;
                {
                if( pInfo1 && F(pInfo1->flags) & flINFOdISK1s_LOCAL )
                third.dosQueryFSInfoF( tin0P , pInfo1 , postDisk ) ; ___( pInfo1 ) ;
                ZE( infoDisk1S* , pInfo1 ) ;
                ZE( boolT , bFound ) ;
            {
            for( ostDisk3 = 'z' ; ostDisk3 >= 'c' ; ostDisk3 -- )
        {
        if( postHome )

        }
            third.c_memcpyIF( tin0P , postHome , ostoHome , ostoHome.costF() + 1 ) ;
            third.newF( tin0P , LF , postHome , ostoHome.costF() + 1 ) ; ___( postHome ) ;

            third.delF( tin0P , posth ) ;
            OStEXTAK( ostoHome  , "\\" )
            OStEXTA( ostoHome  , posth )
            OStEXTAK( ostoHome  , "?:\\" )
            OStEXT( ostoHome , 0x200 )

            }
                third.c_memcpyIF( tin0P , posth , ostov , ostov.costF() + 1 ) ;
                third.newF( tin0P , LF , posth , ostov.costF() + 1 ) ; ___( posth ) ;
                OStEXTC( ostov , processGlobal2I.idHome , 0 ) ;
                OStEXTAK( ostov , "ideafarm.home." ) ; //A: ASSUME: sizeof( countT ) <= 81
                OStEXT( ostov , 0x40 )
            {
            if( !posth )
            third.dosScanEnvF( tin0P , posth , "ideafarm" ) ; ___( posth ) ;
            ZE( osTextT* , posth ) ;
        {
    {
    osTextT& ostDisk3 = ((osTextT*)postDisk)[ 3 ] ;
    const osTextT postDisk[] = "///?" ;
    ZE( osTextT* , postHome ) ;
    // FIND HOME
    _IO_

    }
        if( third ) return ;
        __NZ( postHoverP ) ;
        if( third ) return ;
    {
    IFbEcAREFUL    
{
/*1*/voidT __export hoverF( tin0S& tin0P , thirdC& third , osTextT*& postHoverP , const countT idHoverDirP )/*1*/
/**/
*/
   else the current directory is set to the specified directory
   if 0 then the hover directory is implied
  can be 0
 idHoverDirP
  the caller is responsible for deleting this poolOld drop
  after i return, will contain the full name of a directory
  must be 0
 postHoverP
 third
 tin0P
arguments
\<A HREF=\"5.0c00006.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$hoverF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

