
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

thirdC::third_flagsModeProcess2I_IF() &= ~( F(flMODEpROCESS2_SUPPRESSiNoUTfRAMEc) ) ;
etThread.traceF( tinBaseP , T("i've been fired") ) ;

etherC::loafIF( tinBaseP ) ;

//etherC::etherFireGroupIF( tinBaseP ) ; //U:: TO FIND A BUG

//thirdC::ctrlCIF( tinBaseP ) ;

etThread.traceF( tinBaseP , T("ok") ) ;

}
    etThread.traceMemoryGrainRptF( tinBaseP ) ;

    etThread.traceF( tinBaseP , T("all are ready now") ) ;
    }
        ++ s ; ether.osSleepF( tinBaseP , TOCK >> 2 ) ;
        etThread.traceF( tinBaseP , T("[pending]:    ")+TF2(CwORKERS-cReady,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( cReady < CwORKERS )

    cAlive = 0 ;
    etThread.traceF( tinBaseP , T("all are alive now") ) ;
    }
        ++ s ; ether.osSleepF( tinBaseP , TOCK >> 2 ) ;
        etThread.traceF( tinBaseP , T("[pending]:    ")+TF2(CwORKERS-cAlive,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( cAlive < CwORKERS )
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

    THREADmODE2rESTORE
    }
        etThread.osThreadF( tinBaseP , countTC() , tmWorkF , 0 , &cAlive , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT | flTHREADlAUNCH_NOtINiNpOOL , CBsTACKmIN << 0 , 0 , (countT)&cReady ) ;
    {
    while( cDo -- )
    THREADmODE2oN( flTHREADmODE2_SUPPRESStELLmONITOR )
    countT cDo = CwORKERS ;
    ZE( countT , cReady ) ;
    ZE( countT , cAlive ) ;
{
if( !ether )

thirdC::third_flagsModeProcess2I_IF() |= flMODEpROCESS2_SUPPRESSiNoUTfRAMEc ;

TODO



        }
            return c_threadTry1OuterF( 0 , c_osh , (countT)tmWorkF_workF , (countT)argP , (countT)"tmWorkF" ) ;

            countT c_osh = !processGlobal1S::_processGlobal1I_IF().phExceptionHandler ? 0 : processGlobal1S::_processGlobal1I_IF().phExceptionHandler->osNoTinF( ifcIDtYPEhANDLE_EXCEPTIONhANDLER ) ;

            /* VirtualQuery( &foo , &info , sizeof info ) ;  */
            /* static MEMORY_BASIC_INFORMATION info ;        */
            /* static countT addr2 = (countT)&goo ;          */
            /* static countT addr1 = (countT)&foo ;          */
            /* ZE( countT , goo ) ;                          */
            /* ZE( countT , foo ) ;                          */
            /* 20210321@2028: ADDED TO INSPECT STACK SIZE    */
            /* TO USE THIS CODE, REPLACE "DONE" WITH THIS DEFINITION AND THEN REMOVE THE COMMENT DELIMITERS */
        {
        TASK0PROTO( tmWorkF )

        }
            return POOP ? ifcEXITcODE_THREADiMPOTENT : ifcEXITcODE_THREADaOK ;
            }
                idSubType = POOP ;
                TINSL ;
            {
            ZE( countT , idSubType ) ;

    //#define DONE1

        //DONE1

        }
            }
                dec02AM( cAllThreads ) ; /* MUST BE THE VERY LAST THING THAT THIS THREAD DOES */
                if( ((tinNormalS&)tinBaseP).monitor.idThread <= ClOWtHREADS ) processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tinNormalS&)tinBaseP).monitor.idThread ] = - 1 ;
                TELL( "DONE0: i am outa here" )

                }
                    DEL( pTaskP ) ;
                    /* THE PROCESS MUST SLEEP AFTER RECEIVING THIS SIGN BEFORE ENDING, SO THAT THIS THREAD CAN COMPLETE */
                    /* MUST BE AS LATE AS POSSIBLE BECAUSE IT GIVES THE SIGN THAT THE THREAD IS DONE.                   */
                {
                if( !bFake )
                boolT bFake = pTaskP ? !!( F(pTaskP->flags) & flTHREADlAUNCH_FAKE ) : 0 ;

                }
                    THREADmODE5oFF( flTHREADmODE5_TINiSnOTiNpOOL ) ;
                {
                if( pTaskP && F(pTaskP->flags) & flTHREADlAUNCH_NOtINiNpOOL )

                ;
                    : thirdC::os_cAllKidThreadsI_IF( tinBaseP )
                    ? thirdC::os_cAllOrphanThreadsI_IF( tinBaseP )
                countT& cAllThreads = bOrphan
                boolT bOrphan = pTaskP ? !!( F(pTaskP->flags) & flTHREADlAUNCH_ORPHAN ) : 0 ;
                TELL( "DONE0: deregistering myself from either cAllOrphanThreadsI or cAllKidThreadsI (my final act)" )
                TINSL /*THIS IS NEEDED BECAUSE tinBaseP WAS DELETED IF I AM tmWindowsF */
            {

            }
                }
                    }
                        }
                            /*TINSL*/
                            /*DELzOMBIE( pEtThread ) ;*/ /* tinBaseP IS DESTROYED HERE */
                        {
                        /*if( *(countT*)&pEtThread )*/
                        /*DELzOMBIE( ((tinNormalS&)tinBaseP).pEtScratch ) ;*/
                        /*DELzOMBIE( ((tinNormalS&)tinBaseP).pScoopEtThread ) ;*/ /*CODEsYNC: 0010056 1020171 */
                        TELL( "DONE0: deleting etThread (and tinBaseP)" ) ;
                        ((tinNormalS&)tinBaseP).pEther = 0 ;
                        TELL( "DONE0: testing poolOld" ) ;

                        }
                            ((tinNormalS&)tinBaseP).pEtScratch->delF( tinBaseP , psttThreadFile ) ;
                            ((tinNormalS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , psttThreadFile ) ;
                            TELL( "DONE0: deleting thread file" ) ;
                        {
                        if( psttThreadFile )
                    {
                    /*if( pEtThread )*/ /*THREADS THAT DELETE etThread EARLY: tmWindowsF*/
                    TINSL /*THIS IS NEEDED BECAUSE tinBaseP WAS DELETED IF I AM tmWindowsF */
                {

                ((tinNormalS&)tinBaseP).pSgnUtility = 0 ;

                }
                    }
                        if( ((tinNormalS&)tinBaseP).monitor.idThread <= ClOWtHREADS && !( ++ processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tinNormalS&)tinBaseP).monitor.idThread ] ) ) { BLAMMO ; }
                        if( ((tinNormalS&)tinBaseP).idPhase1 < ifcIDpHASEtHREAD_EPILOGnOkIDS ) ((tinNormalS&)tinBaseP).idPhase1 = ifcIDpHASEtHREAD_EPILOGnOkIDS ;
                        }
                            TELL( "DONE0: destroying all adam objects that remain on the thread stack" ) ;
                            }
                                }
                                    ++ s ; thirdC::dosSleepRawIF( tinBaseP , 250 ) ;
                                    etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("DONE0 / napping a wink for my kids to end [((tinNormalS&)tinBaseP).cKidThreads]:    ")+TF2(((tinNormalS&)tinBaseP).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                {
                                while( ((tinNormalS&)tinBaseP).cKidThreads )
                                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ; /* WILL BLAMMO IF ANYTHING IS GRABBED (THIS IS DESIRABLE BEHAVIOR) */
                            {
                            TELL( "DONE0: waiting for my kid threads to end" ) ;

                            /*if( F(thirdC::third_flagsModeAdam1I_IF(tinBaseP)) & flADAMmODE1_WHEREaLL && !( F(((tinNormalS&)tinBaseP).monitor.flagsThreadMode1) & flTHREADmODE1_NOwHERE ) ) etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_UNWATCH ) ;*/
                            TELL( "DONE0: conditionally calling etherWhereF" ) ;
                        {
                        /*else*/
                        /*if( !pEtThread ) ;*/ /*THIS IS NEEDED BECAUSE tinBaseP WAS DELETED IF I AM tmWindowsF */

                        }
                            /*etThread.traceF( tinBaseP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;*/
                            OStEXTC(  ostoSay , ((tinNormalS&)tinBaseP).cOsHandles , '0' ) ;
                            OStEXTAK( ostoSay , "." ) ;
                            OStEXTC(  ostoSay , ((tinNormalS&)tinBaseP).cSpins4 , '0' ) ;
                            OStEXTAK( ostoSay , "." ) ;
                            OStEXTC(  ostoSay , ((tinNormalS&)tinBaseP).cSpins3 , '0' ) ;
                            OStEXTAK( ostoSay , "." ) ;
                            OStEXTC(  ostoSay , ((tinNormalS&)tinBaseP).cSpins2 , '0' ) ;
                            OStEXTAK( ostoSay , "." ) ;
                            OStEXTC(  ostoSay , ((tinNormalS&)tinBaseP).cSpins1 , '0' ) ;
                            OStEXTAK( ostoSay , "    " ) ;
                            OStEXTC(  ostoSay , ((tinNormalS&)tinBaseP).pag1->cYieldHighWater , 0 ) ;
                            OStEXTAK( ostoSay , "    " ) ;
                            OStEXTC(  ostoSay , ((tinNormalS&)tinBaseP).pag1->idAdam , 0 ) ;
                            OStEXTAK( ostoSay , "DONE0     [idAdam,cYieldHighWater,cSpins1,cSpins2,cSpins3,cSpins4,cOsHandles]:    " ) ;
                            OStEXT(   ostoSay , TUCK << 2 ) ;
                        {
                        if( ((tinNormalS&)tinBaseP).pag1->cYieldHighWater )

                        TELL( "DONE0: after returning from application code" ) ;
                        ((tinNormalS&)tinBaseP).idPhase2 = 0 ;
                        if( ((tinNormalS&)tinBaseP).idPhase1 < ifcIDpHASEtHREAD_EPILOGkIDS ) ((tinNormalS&)tinBaseP).idPhase1 = ifcIDpHASEtHREAD_EPILOGkIDS ;
                        if( ((tinNormalS&)tinBaseP).monitor.idThread <= ClOWtHREADS && !( ++ processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tinNormalS&)tinBaseP).monitor.idThread ] ) ) { BLAMMO ; }
                        TINSL /*THIS IS NEEDED BECAUSE tinBaseP WAS DELETED IF I AM tmWindowsF */
                    {

                    ether.osThreadSwitchingDesireF( tinBaseP , ifcTHREADpRIORITY_PUSHY ) ; /*TO PREVENT LAME DUCK THREADS FROM ACCUMULATING AND CLOGGING SYS*/

                    /*DO NOT CLOSE THE CODE BLOCK HERE BECAUSE KID THREADS MIGHT BE USING OBJECTS THAT WOULD DT HERE*/

//#define DONE0nOeTHERS

                        //DONE0nOeTHERS

    //#define DONEnOeTHERS(taskFP)

//DONEnOeTHERS( tmWorkF )

#endif
THREADmODE4rESTORE
}
    etherC::loafIF( tinBaseP ) ;
    inc02AM( cReadyP ) ;

    countT& cReadyP = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
THREADmODE4oN( flTHREADmODE4_NOsEXiNpOOL ) ;
#if defined( NEVERdEFINED )


                    if( ((tinNormalS&)tinBaseP).monitor.idThread <= ClOWtHREADS && !( ++ processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tinNormalS&)tinBaseP).monitor.idThread ] ) ) { BLAMMO ; }
                    _IO_
                    if( ((tinNormalS&)tinBaseP).idPhase1 < ifcIDpHASEtHREAD_WORKING ) ((tinNormalS&)tinBaseP).idPhase1 = ifcIDpHASEtHREAD_WORKING ;
                    /*(countT&)_tlsBlobStackTop = espAM() ;                      */
                    /*tlsBlobC _tlsBlobStackTop( tinBaseP , "appStackTop" , "tin" ) ;*/
                    TELL( "TASK0: entering application code" )
                    /*if( F(thirdC::third_flagsModeAdam1I_IF(tinBaseP)) & flADAMmODE1_WHEREaLL && !( F(((tinNormalS&)tinBaseP).monitor.flagsThreadMode1) & flTHREADmODE1_NOwHERE ) ) etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_WATCH ) ;*/
                    }
                        ether.boxPutF(    tinBaseP , psttThreadFile , "T" ) ;
                        ether.strMakeF(    tinBaseP , LF , psttThreadFile , T("///ideafarm/ephemeral/tmp/threads/")+TF1(((tinNormalS&)tinBaseP).osPid)+tDot+TF1(DDNUMB)+tDot+T("tmWorkF")+tDot+TF1(((tinNormalS&)tinBaseP).monitor.idThread) ) ; ___( psttThreadFile ) ;
                        TN( tDot , "." ) ;
                    {
                    if( F(thirdC::third_flagsModeAdam1I_IF(tinBaseP)) & flADAMmODE1_SEEtHREADSaSfILES )
                    ether.osTimeNowF(    tinBaseP , ((tinNormalS&)tinBaseP).time1 , ((tinNormalS&)tinBaseP).time2 ) ;
                    /*etherC::ifcSayIF( T("ADAM CELL (idAdam,osPid): ")+TF1(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T(" ")+TF1(((tinNormalS&)tinBaseP).osPid)+T(" ")+TF1(((tinNormalS&)tinBaseP).osTid)+T(" \"")+T(((tinNormalS&)tinBaseP).postThreadName)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;*/
                {

                /*((tinNormalS&)tinBaseP).pSgnUtility = &_sgnUtility ;*/
                /*signC _sgnUtility( tinBaseP , TAG( TAGiDnULL ) ) ;*/

                /*((tinNormalS&)tinBaseP).pEther = &etThread ;*/
                TELL( "TASK0: final setup" )

                /*POPUP( TF1(((tinNormalS&)tinBaseP).monitor.idThread)+T(" ")+T(((tinNormalS&)tinBaseP).postThreadName)+T("\r\n") ) ;*/

                /*((tinNormalS&)tinBaseP).pScoopEtThread = new( 0 , tinBaseP , pbScoop , sizeof pbScoop ) scoopC( tinBaseP , LF , etThread ) ; ___( ((tinNormalS&)tinBaseP).pScoopEtThread  ) ;*/
                /*byteT pbScoop[ sizeof( scoopC ) ] ;*/
                /*etherC& etThread  = *pEtThread ;*/
            {
            /*if( pEtThread   && ((tinNormalS&)tinBaseP).pEtScratch   )*/
            ZE( strokeS* , psttThreadFile ) ;
            TELL( "TASK0: after newing etThread" )
            /*TESTsCRATCH ;*/
            /*((tinNormalS&)tinBaseP).pEtScratch   = new( 0 , tinBaseP , pbEther2 , sizeof pbEther2 ) etherC( tinBaseP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ;*/
            /*etherC* pEtThread = new( 0 , tinBaseP , pbEther1 , sizeof pbEther1 ) etherC( tinBaseP , TAG( TAGiDnULL ) , flTHIRDmODE_TINoWNER | flagsThirdModeP ) ;*/
            /*byteT pbEther2[ sizeof( etherC ) ] ;*/
            /*byteT pbEther1[ sizeof( etherC ) ] ;*/
            TELL( "TASK0: newing etThread" )

            if( pTaskP && F( pTaskP->flagsThreadMode1Dad ) & flTHREADmODE1_NOwHERE                 ) ((tinNormalS&)tinBaseP).monitor.flagsThreadMode1 |= flTHREADmODE1_NOwHERE                 ;
            if( pTaskP && F( pTaskP->flagsThreadMode2Dad ) & flTHREADmODE2_SUPPRESStELLmONITOR     )         ((tinNormalS&)tinBaseP).flagsThreadMode2 |= flTHREADmODE2_SUPPRESStELLmONITOR     ;
            if( pTaskP && F( pTaskP->flagsThreadMode2Dad ) & flTHREADmODE2_YELL                    )         ((tinNormalS&)tinBaseP).flagsThreadMode2 |= flTHREADmODE2_YELL                    ;
            if( pTaskP && F( pTaskP->flagsThreadMode2Dad ) & flTHREADmODE2_WATCHfORaSYNCHiMPOTENCE )         ((tinNormalS&)tinBaseP).flagsThreadMode2 |= flTHREADmODE2_WATCHfORaSYNCHiMPOTENCE ;
            if( pTaskP && F( pTaskP->flagsThreadMode2Dad ) & flTHREADmODE2_QUIETiMPOTENCE          )         ((tinNormalS&)tinBaseP).flagsThreadMode2 |= flTHREADmODE2_QUIETiMPOTENCE          ;
            if( pTaskP && F( pTaskP->flagsThreadMode2Dad ) & flTHREADmODE2_SHOWpROGRESS            )         ((tinNormalS&)tinBaseP).flagsThreadMode2 |= flTHREADmODE2_SHOWpROGRESS            ;
            TELL( "TASK0: setting flagsThreadMode2" )
            /*CODEsYNC: 00100df 0010055*/

            /*etRock.traceF( tinBaseP , T("TASK0 [osTid]: ")+TF4(((tinNormalS&)tinBaseP).osTid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) , flTRACE_FORCEnOsILENCE ) ;*/

            ((tinNormalS&)tinBaseP).pcQuit = &(const countT&)ether ;
            ((tinNormalS&)tinBaseP).monitor.idProcessOld = thirdC::third_idProcessOldI_IF( tinBaseP ) ;
            ((tinNormalS&)tinBaseP).idlTask  = ifcLINE ;
            ((tinNormalS&)tinBaseP).idiTask  = DDNUMB ;
            TELL( "TASK0: setting miscellaneous fields in tinBaseP" )
            etherC& etRock = etherC::etRockIF( tinBaseP ) ;
            etherC& ether = etherC::etPrimeIF( tinBaseP ) ;
            thirdC::osTraceWrongNodeIF( tinBaseP , (byteT*)tmWorkF_workF , "tmWorkF" , "_workF" ) ;
            TINSL
        {
        if( bTinOk )
        TELL( "TASK0: after newing either a tinNormalS in the working poolOld" )
        /* AFTER THIS LINE, DO NOT CONSTRUCT ANY OBJECTS THAT HAVE DESTRUCTORS (BECAUSE DECREMENTING cAllKidThreadsI cAllOrphanThreadsI MUST BE THE VERY LAST THING THAT THIS THREAD DOES) */

        }
            }
                ___( pTin ) ;
                TINSL
                /*pTinF() = pTin ;*/
                bTinOk = 1 ;
            {
            if( pTin )
            tinBaseS* pTin = new( 0 , tinBaseP , LF ) tinNormalS( tinBaseP , TAG( TAGiDnULL ) , ebpAM() , pTaskP->idThread , pTinBaseDad , "tmWorkF" , F(pTaskP->flags) & flTHREADlAUNCH_INHERITjOTrEGISTRATIONS ? flTINs_INHERITjOTrEGISTRATIONS : flTINs_null , ifcIDtINnAMED_tinInPool ) ;
            TELL( "TASK0: newing a tinNormalS in the working poolOld" )
            tinBaseS* const pTinBaseDad = F(pTaskP->flags) & flTHREADlAUNCH_ORPHAN ? 0 : pTaskP->pTinBaseDad ;
        {
        else
        }
            THREADmODE5oN( flTHREADmODE5_TINiSnOTiNpOOL ) ;
            bTinOk = 1 ;
        {
        if( F(pTaskP->flags) & flTHREADlAUNCH_NOtINiNpOOL )                     /*20240919@1534: I DON'T REMEMBER WHAT THE BENEFIT IS OF CT'ING tinNormalS IN POOL*/
        ZE( boolT , bTinOk ) ;

        }
            }
                ++ s ; thirdC::dosSleepIF( tinBaseP , TOCK >> 3 ) ;
            {
            while( *pTaskP->pcAlive )
            inc02AM( *pTaskP->pcAlive ) ;
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        {
        if( pTaskP->pcAlive )   /* ALLOWS THE LAUNCHING THREAD TO LAUNCH MANY THREADS, WAIT FOR ALL THREAD STACKS TO BE ALLOCATED, AND THEN SAY "GO" TO HAVE THEM ALL PROCEED, IN ORDER TO REDUCE FRAGMENTATION OF ADDRESS SPACE */

        thirdC::osTraceWrongNodeIF( tinBaseP , (byteT*)&pTaskP , "tmWorkF" , "_workF: pTaskP" ) ;
        thirdC::osTraceWrongNodeIF( tinBaseP , (byteT*)argP , "tmWorkF" , "_workF: argP"      ) ;
        taskS* pTaskP = (taskS*)argP ;
        TELL( "TASK0: workF+" )

        /*OStEXTcLEAR( _ostoTmp )                                                                                                              */
        /*osTextC _ostRangerTag( _ostoTmp.costF() + 1 , _ostoTmp , _tlsBlobStatRangerTag , _tlsBlobStatRangerTag.cbF() ) ;                     */
        /*tlsBlobC _tlsBlobStatRangerTag( tinBaseP , "rangerTag" , "sys" , 2 * sizeof( countT ) + _ostoTmp.costF() + 1 , ifcIDtYPEtLSbLOBc_FOOT ) ;*/
        /*tlsAllocStackExp_8_C tlsForMe( tinBaseP ) ;                                                                                              */
        /*OStEXTC(  _ostoTmp , ((tinNormalS&)tinBaseP).monitor.idThread , 0 )                                                                                     */
        /*OStEXTAK( _ostoTmp , "." )                                                                                                           */
        /*OStEXTA(  _ostoTmp , ((tinNormalS&)tinBaseP).postThreadName )                                                                                           */
        /*OStEXTAK( _ostoTmp , "RangerTag:threadStack." )                                                                                      */
        /*OStEXTAK( _ostoTmp , "!ifc" )                                                                                                        */
        /*OStEXT(   _ostoTmp , 0x80 )                                                                                                          */

        _IO_ TELLsYSlIFInAME( "tmWorkF" )
        if( ((tinNormalS&)tinBaseP).monitor.idThread <= ClOWtHREADS && !( ++ processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tinNormalS&)tinBaseP).monitor.idThread ] ) ) { BLAMMO ; }
        TINSL
    {
    countT tmWorkF_workF( countT argP )


//     1044_            BEFORE SLASHING
//
// PARAMETER TO __GRO


// 15b8feac                AT ENTRY POINT tmWorkF_workF ; __GRO 1044_
// 15b8feac                AT CALL TO *pThreadWorkF
// 15b8ff00                AT ENTRY POINT threadLocalStorage ; __GRO 9084_ ; sizeof( tlsStackFrameS ) is 8d96_ ; sizeof( tinNormalS ) is 8d76_ ; stack allocation is [15b70000_,15b90000_)
// 15b8ff00                AT CALL TO threadLocalStorageF
// 15b8ff44                AT ENTRY POINT threadTry2InnerF ; __GRO 54_
// 15b8ff44                AT CALL TO threadTry2InnerF
// 15b8ff64                AT ENTRY POINT c_threadTry1OuterF ; __GRO 50_
// 15b8ff64                AT CALL TO c_threadTry1OuterF
// 15b8ff80_               AT ENTRY POINT tmWorkF ; __GRO 24_ ; ebp is 80_ below end of stack allocation at 15b90000_
//
// NOTES IN ebp DURING INIT OF tmWorkF

//#define TASK0nOeTHERS(tmWorkF,flagsThirdModeP)

//#define TASKnOeTHERS(tmWorkF) TASK0nOeTHERS( tmWorkF , flTHIRDmODE_null )
//TASKnOeTHERS( tmWorkF )

//#define CwORKERS ( 0x1000 + 99 )

#define CwORKERS ( 1 )
//#define CwORKERS ( 0x40 )
//REDUCED TO MAKE ADDRESS SPACE AVAILABLE FOR THE traceF CALLS DURING TERMINATION

//G BUT FAILS DURING QUIT: #define CwORKERS ( 0x1000 + 99 )
//G:#define CwORKERS ( 0x1000 + 99 )
//G:#define CwORKERS ( 0x1000 + 98 )
//G:#define CwORKERS 0x1000
//G:#define CwORKERS 0x800
//WITHOUT RESETTING cAlive (I.E DO NOT CT tinNormalS AND etThread ON THE KID THREADS)

//B:#define CwORKERS 0x600
//B:#define CwORKERS 0x800
//G:#define CwORKERS 0x3f2
//20240918@1819: WITH 2 TOCK THREAD STACKS

//#define CwORKERS 0x8
//G:#define CwORKERS 0x3f2
//B:#define CwORKERS 1050
//B:#define CwORKERS 1100
//G:#define CwORKERS 1010

/*1*/WAKEsHOWtEXT( "example.other.3func.36002065.etherc.osthreadf.launching.many.threads" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
