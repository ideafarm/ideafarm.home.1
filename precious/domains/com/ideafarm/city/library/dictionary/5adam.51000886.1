
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etherC::loafIF( tin0P ) ;
    //etThread.traceF( tin0P , T("ok [idDisk]:    ")+TF3(idDisk,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ;
    etThread.traceF( tin0P , T("ok") ) ;

    etThread.delF( tin0P , pstt1Cookies ) ;
    }
        }
            }
                etThread.traceF( tin0P , T("socket is impotent") ) ;
                POOPRqUIET
            {
            if( POOP )

            //etThread.traceF( tin0P , T("[nonce]:    ")+tValueNonce ) ;

            }
                DEL( pSwPathValue ) ;

                }
                    }
                        etThread.delF( tin0P , psttValue ) ;

                        }
                            }
                                etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                *pptValue[ offe ] = T(psttValue) ;
                            {
                            if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                        {
                        for( countT offe = 0 ; offe < cPaths ; offe ++ )

                        if( cPaths - cValues ) { BLAMMO ; }
                        countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                        countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                        //etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                        //etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;

                        strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                        psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                        _IO_
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                    _IO_
                {
                if( !POOP )

                //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                ;
                }
                    &tPathNonce     ,
                    &tPathError     ,
                    &tPathErrorCode ,
                {
                textC* pptPath[] =

                TN( tPathNonce     , "\"nonce\"/"   ) ;
                TN( tPathError     , "\"error\"/"   ) ;
                TN( tPathErrorCode , "\"errcode\"/" ) ;

                ;
                }
                    &tValueNonce     ,
                    &tValueError     ,
                    &tValueErrorCode ,
                {
                textC* pptValue[] =

                TN( tValueError     , "" ) ;
                TN( tValueErrorCode , "" ) ;

                __Z( pSwPathValue ) ;
                }
                    }
                        etThread.traceF( tin0P , T("!exception / could not parse json") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                ZE( switchC* , pSwPathValue ) ;
                ZE( strokeS* , psttPath     ) ;
                _IO_
            {

            etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , T(postj)                                                                                                               , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- response body:") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , T(posth)                                                                                                               , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- response head:") , flTRACE_NOpREFIX                    ) ;

            }
                }
                    }
                        if( !cNest ) break ;
                        costj ++ ;

                        else if( postj[ costj ] == '}' ) cNest -- ;
                             if( postj[ costj ] == '{' ) cNest ++ ;

                        if( !cbIn ) break ;
                        countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                    {
                    else
                    }
                        costh ++ ;

                        bHead = 0 ;
                        )
                            )
                                )
                                    posth[ costh - 2 ] == '\n'
                                    &&
                                    posth[ costh - 1 ] == '\r'
                                (
                                ||
                                posth[ costh - 1 ] == '\n'
                            (
                            &&
                            posth[ costh ] == '\n'
                            &&
                            costh
                        (
                        if

                        if( !cbIn ) break ;
                        countT cbIn = sockc.readF( tin0P , posth + costh , 1 ) ;
                    {
                    if( bHead )
                {
                for(;;)
                ZE( countT , cNest ) ;
                _IO_
            {
            ZE( countT , costj ) ;
            ZE( countT , costh ) ;
            boolT bHead = 1 ;
            thirdC::c_memsetIF( tin0P , postj , sizeof postj , 0 ) ;
            thirdC::c_memsetIF( tin0P , posth , sizeof posth , 0 ) ;

            sockc.writeF( tin0P , (osTextT*)tSay ) ;
            sockc.connectF( tin0P , 443 , nnServer ) ;
            socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

            countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
            countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
            countT timeAllowedConnected = TICK >> 2 ;

            nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
            nicNameC nnServer ;

            tSay += T("\r\n")+tBody ;

            etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , tBody                                                                                                                  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- request  body:") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , tSay                                                                                                                   , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- request  head:") , flTRACE_NOpREFIX                    ) ;

            tSay += T("Content-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n") ;

            }
                tSay += T("Cookie: ")+T(psttc1)+T("\r\n") ;
            {
            FORsTRINGSiN1( pstt1Cookies )

            ) ;

                "Accept: application/json\r\n"
                "Content-Type: application/json\r\n"
                "Authorization: Basic ")+tApiCredentials64Users+T("\r\n"
                "Host: ")+tServer+T("\r\n"
                "POST /rest/v4/payments HTTP/1.1\r\n"

            TN( tSay , "" ) ; tSay = T(

            countT costBody = tBody.csF( tin0P ) ;

            ) ;

                "}\r\n"
                "    \"purpose\": \"GP0002\"\r\n"
              //"    \"purpose\": \"OTHER\"\r\n"
                "    \"programToken\": \"")+tHyperwalletProgramTokenSandboxFunding+T("\"\r\n"
                "    \"destinationToken\": \"")+tValueUserToken+T("\",\r\n"
                "    \"currency\": \"USD\",\r\n"
                "    \"clientPaymentId\": \"")+tTime+T("\",\r\n"
                "    \"amount\": \"22.13\",\r\n"
                "{\r\n"

            TN( tBody , "" ) ; tBody = T(
            TN( tServer , "uat-api.paylution.com" ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        TN( tValueNonce , "" ) ;
        _IO_
    {

//#endif

    }
        }
            }
                etThread.traceF( tin0P , T("socket is impotent") ) ;
                POOPRqUIET
            {
            if( POOP )

            //etThread.traceF( tin0P , T("[nonce]:    ")+tValueNonce ) ;

            }
                DEL( pSwPathValue ) ;

                }
                    }
                        etThread.delF( tin0P , psttValue ) ;

                        }
                            }
                                etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                *pptValue[ offe ] = T(psttValue) ;
                            {
                            if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                        {
                        for( countT offe = 0 ; offe < cPaths ; offe ++ )

                        if( cPaths - cValues ) { BLAMMO ; }
                        countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                        countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                        //etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                        //etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;

                        strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                        psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                        _IO_
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                    _IO_
                {
                if( !POOP )

                //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                ;
                }
                    &tPathNonce     ,
                    &tPathError     ,
                    &tPathErrorCode ,
                {
                textC* pptPath[] =

                TN( tPathNonce     , "\"nonce\"/"   ) ;
                TN( tPathError     , "\"error\"/"   ) ;
                TN( tPathErrorCode , "\"errcode\"/" ) ;

                ;
                }
                    &tValueNonce     ,
                    &tValueError     ,
                    &tValueErrorCode ,
                {
                textC* pptValue[] =

                TN( tValueError     , "" ) ;
                TN( tValueErrorCode , "" ) ;

                __Z( pSwPathValue ) ;
                }
                    }
                        etThread.traceF( tin0P , T("!exception / could not parse json") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                ZE( switchC* , pSwPathValue ) ;
                ZE( strokeS* , psttPath     ) ;
                _IO_
            {

            etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , T(postj)                                                                                                               , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- response body:") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , T(posth)                                                                                                               , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- response head:") , flTRACE_NOpREFIX                    ) ;

            }
                }
                    }
                        if( !cNest ) break ;
                        costj ++ ;

                        else if( postj[ costj ] == '}' ) cNest -- ;
                             if( postj[ costj ] == '{' ) cNest ++ ;

                        if( !cbIn ) break ;
                        countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                    {
                    else
                    }
                        costh ++ ;

                        bHead = 0 ;
                        )
                            )
                                )
                                    posth[ costh - 2 ] == '\n'
                                    &&
                                    posth[ costh - 1 ] == '\r'
                                (
                                ||
                                posth[ costh - 1 ] == '\n'
                            (
                            &&
                            posth[ costh ] == '\n'
                            &&
                            costh
                        (
                        if

                        if( !cbIn ) break ;
                        countT cbIn = sockc.readF( tin0P , posth + costh , 1 ) ;
                    {
                    if( bHead )
                {
                for(;;)
                ZE( countT , cNest ) ;
                _IO_
            {
            ZE( countT , costj ) ;
            ZE( countT , costh ) ;
            boolT bHead = 1 ;
            thirdC::c_memsetIF( tin0P , postj , sizeof postj , 0 ) ;
            thirdC::c_memsetIF( tin0P , posth , sizeof posth , 0 ) ;

            sockc.writeF( tin0P , (osTextT*)tSay ) ;
            sockc.connectF( tin0P , 443 , nnServer ) ;
            socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

            countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
            countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
            countT timeAllowedConnected = TICK >> 2 ;

            nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
            nicNameC nnServer ;

            tSay += T("\r\n")+tBody ;

            etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , tBody                                                                                                                  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- request  body:") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , tSay                                                                                                                   , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- request  head:") , flTRACE_NOpREFIX                    ) ;

            ) ;

                "Content-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n"
                "Accept: application/json\r\n"
                "Content-Type: application/json\r\n"
                "Authorization: Basic ")+tApiCredentials64Users+T("\r\n"
                "Host: ")+tServer+T("\r\n"
                "POST /rest/v4/users/")+tValueUserToken+T("/bank-accounts HTTP/1.1\r\n"

            TN( tSay , "" ) ; tSay = T(

            countT costBody = tBody.csF( tin0P ) ;

            ) ;

                "}\r\n"
                "    \"bankAccountId\": \"1736404611\"\r\n"
                "    \"bankAccountPurpose\": \"CHECKING\",\r\n"
                "    \"branchId\": \"121122676\",\r\n"
                "    \"type\": \"BANK_ACCOUNT\",\r\n"
                "    \"transferMethodCurrency\": \"USD\",\r\n"
                "    \"transferMethodCountry\": \"US\",\r\n"
                "{\r\n"

            TN( tBody , "" ) ; tBody = T(
            TN( tServer , "uat-api.paylution.com" ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        TN( tValueNonce , "" ) ;
        _IO_
    {

//#if defined( NEVERdEFINED )

#endif

    }
        }
            }
                etThread.traceF( tin0P , T("socket is impotent") ) ;
                POOPRqUIET
            {
            if( POOP )

            //etThread.traceF( tin0P , T("[nonce]:    ")+tValueNonce ) ;

            }
                DEL( pSwPathValue ) ;

                }
                    }
                        etThread.delF( tin0P , psttValue ) ;

                        }
                            }
                                etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                *pptValue[ offe ] = T(psttValue) ;
                            {
                            if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                        {
                        for( countT offe = 0 ; offe < cPaths ; offe ++ )

                        if( cPaths - cValues ) { BLAMMO ; }
                        countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                        countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                        //etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                        //etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;

                        strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                        psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                        _IO_
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                    _IO_
                {
                if( !POOP )

                //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                ;
                }
                    &tPathNonce     ,
                    &tPathError     ,
                    &tPathErrorCode ,
                {
                textC* pptPath[] =

                TN( tPathNonce     , "\"nonce\"/"   ) ;
                TN( tPathError     , "\"error\"/"   ) ;
                TN( tPathErrorCode , "\"errcode\"/" ) ;

                ;
                }
                    &tValueNonce     ,
                    &tValueError     ,
                    &tValueErrorCode ,
                {
                textC* pptValue[] =

                TN( tValueError     , "" ) ;
                TN( tValueErrorCode , "" ) ;

                __Z( pSwPathValue ) ;
                }
                    }
                        etThread.traceF( tin0P , T("!exception / could not parse json") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                ZE( switchC* , pSwPathValue ) ;
                ZE( strokeS* , psttPath     ) ;
                _IO_
            {

            etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , T(postj)                                                                                                               , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- response body:") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , T(posth)                                                                                                               , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- response head:") , flTRACE_NOpREFIX                    ) ;

            }
                }
                    }
                        if( !cNest ) break ;
                        costj ++ ;

                        else if( postj[ costj ] == '}' ) cNest -- ;
                             if( postj[ costj ] == '{' ) cNest ++ ;

                        if( !cbIn ) break ;
                        countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                    {
                    else
                    }
                        costh ++ ;

                        bHead = 0 ;
                        )
                            )
                                )
                                    posth[ costh - 2 ] == '\n'
                                    &&
                                    posth[ costh - 1 ] == '\r'
                                (
                                ||
                                posth[ costh - 1 ] == '\n'
                            (
                            &&
                            posth[ costh ] == '\n'
                            &&
                            costh
                        (
                        if

                        if( !cbIn ) break ;
                        countT cbIn = sockc.readF( tin0P , posth + costh , 1 ) ;
                    {
                    if( bHead )
                {
                for(;;)
                ZE( countT , cNest ) ;
                _IO_
            {
            ZE( countT , costj ) ;
            ZE( countT , costh ) ;
            boolT bHead = 1 ;
            thirdC::c_memsetIF( tin0P , postj , sizeof postj , 0 ) ;
            thirdC::c_memsetIF( tin0P , posth , sizeof posth , 0 ) ;

            sockc.writeF( tin0P , (osTextT*)tSay ) ;
            sockc.connectF( tin0P , 443 , nnServer ) ;
            socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

            countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
            countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
            countT timeAllowedConnected = TICK >> 2 ;

            nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
            nicNameC nnServer ;

            tSay += T("\r\n")+tBody ;

            etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , tBody                                                                                                                  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- request  body:") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , tSay                                                                                                                   , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- request  head:") , flTRACE_NOpREFIX                    ) ;

            ) ;

                "Content-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n"
                "Accept: application/json\r\n"
                "Content-Type: application/json\r\n"
                "Authorization: Basic ")+tApiCredentials64Users+T("\r\n"
                "Host: ")+tServer+T("\r\n"
                "POST /rest/v4/users/")+tValueUserToken+T("/transfer-methods HTTP/1.1\r\n"

            TN( tSay , "" ) ; tSay = T(

            countT costBody = tBody.csF( tin0P ) ;

            ) ;

                "}\r\n"
                "    \"type\": \"OTHER\"\r\n"
                "    \"transferMethodCurrency\": \"USD\",\r\n"
                "    \"transferMethodCountry\": \"US\",\r\n"
                "{\r\n"

            TN( tBody , "" ) ; tBody = T(
            TN( tServer , "uat-api.paylution.com" ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        TN( tValueNonce , "" ) ;
        _IO_
    {

#if defined( NEVERdEFINED )

    //}
    //    etThread.traceF( tin0P , T("[cookie]:    ")+T(psttc1) ) ;
    //{
    //FORsTRINGSiN1( pstt1Cookies )

    }
        }
            }
                etThread.traceF( tin0P , T("socket is impotent") ) ;
                POOPRqUIET
            {
            if( POOP )

            //etThread.traceF( tin0P , T("[nonce]:    ")+tValueUserToken ) ;

            }
                DEL( pSwPathValue ) ;

                }
                    }
                        etThread.delF( tin0P , psttValue ) ;

                        }
                            }
                                //etThread.traceF( tin0P , T("======================================================>    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                *pptValue[ offe ] = T(psttValue) ;
                            {
                            if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                        {
                        for( countT offe = 0 ; offe < cPaths ; offe ++ )

                        if( cPaths - cValues ) { BLAMMO ; }
                        countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                        countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                        //etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                        //etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;

                        strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                        psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                        _IO_
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                    _IO_
                {
                if( !POOP )

                //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                ;
                }
                    &tPathUserToken ,
                    &tPathError     ,
                    &tPathErrorCode ,
                {
                textC* pptPath[] =

                TN( tPathUserToken     , "\"token\"/"   ) ;
                TN( tPathError     , "\"error\"/"   ) ;
                TN( tPathErrorCode , "\"errcode\"/" ) ;

                ;
                }
                    &tValueUserToken     ,
                    &tValueError     ,
                    &tValueErrorCode ,
                {
                textC* pptValue[] =

                TN( tValueError     , "" ) ;
                TN( tValueErrorCode , "" ) ;

                __Z( pSwPathValue ) ;
                }
                    }
                        etThread.traceF( tin0P , T("!exception / could not parse json") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                ZE( switchC* , pSwPathValue ) ;
                ZE( strokeS* , psttPath     ) ;
                _IO_
            {

            }
                }
                    etThread.strFuseSeparateF( tin0P , pstt1Cookies , T(postzCookie) ) ;

                    }
                        }
                            break ;
                            *postzc = 0 ;
                        {
                        if( *postzc == '\r' || *postzc == '\n' )
                    {
                    for( osTextT* postzc = postzCookie ; ; postzc ++ )

                    st_postCookie >> *(countT*)&postzCookie ;
                    ZE( osTextT* , postzCookie ) ;
                {
                while( st_postCookie )

                }
                    }
                        st_postCookie << (countT)postc ;
                        postc += sizeof postSmall - 1 ;

                        if( !postc ) break ;
                        postc = thirdC::c_strstrIF( tin0P , postc, postSmall ) ;
                    {
                    for(;;)
                    osTextT* postc = posth ;
                    osTextT  postSmall[] = { "Set-Cookie: " } ;
                {

                stackC st_postCookie( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_countT ) ;
            {

            etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , T(postj)                                                                                                               , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- response body:") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , T(posth)                                                                                                               , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- response head:") , flTRACE_NOpREFIX                    ) ;

            }
                }
                    }
                        if( !cNest ) break ;
                        costj ++ ;

                        else if( postj[ costj ] == '}' ) cNest -- ;
                             if( postj[ costj ] == '{' ) cNest ++ ;

                        if( !cbIn ) break ;
                        countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                    {
                    else
                    }
                        costh ++ ;

                        bHead = 0 ;
                        )
                            )
                                )
                                    posth[ costh - 2 ] == '\n'
                                    &&
                                    posth[ costh - 1 ] == '\r'
                                (
                                ||
                                posth[ costh - 1 ] == '\n'
                            (
                            &&
                            posth[ costh ] == '\n'
                            &&
                            costh
                        (
                        if

                        if( !cbIn ) break ;
                        countT cbIn = sockc.readF( tin0P , posth + costh , 1 ) ;
                    {
                    if( bHead )
                {
                for(;;)
                ZE( countT , cNest ) ;
                _IO_
            {
            ZE( countT , costj ) ;
            ZE( countT , costh ) ;
            boolT bHead = 1 ;
            thirdC::c_memsetIF( tin0P , postj , sizeof postj , 0 ) ;
            thirdC::c_memsetIF( tin0P , posth , sizeof posth , 0 ) ;

            sockc.writeF( tin0P , (osTextT*)tSay ) ;
            sockc.connectF( tin0P , 443 , nnServer ) ;
            socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

            countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
            countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
            countT timeAllowedConnected = TICK >> 2 ;

            nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
            nicNameC nnServer ;

            tSay += T("\r\n")+tBody ;

            etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , tBody                                                                                                                  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- request  body:") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , tSay                                                                                                                   , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- request  head:") , flTRACE_NOpREFIX                    ) ;

            ) ;

                "Content-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n"
                "Accept: application/json\r\n"
                "Content-Type: application/json\r\n"
                "Authorization: Basic ")+tApiCredentials64Users+T("\r\n"
                "Host: ")+tServer+T("\r\n"
                "POST /rest/v4/users HTTP/1.1\r\n"

            TN( tSay , "" ) ; tSay = T(

            countT costBody = tBody.csF( tin0P ) ;

            ) ;

                "}\r\n"
                "    \"programToken\": \"")+tHyperwalletProgramTokenSandboxUsers+T("\"\r\n"
                "    \"postalCode\": \"94105\",\r\n"
                "    \"stateProvince\": \"CA\",\r\n"
                "    \"country\": \"US\",\r\n"
                "    \"city\": \"San Francisco\",\r\n"
                "    \"addressLine1\": \"575 Market St\",\r\n"
                "    \"dateOfBirth\": \"1991-02-15\",\r\n"
                "    \"email\": \"test.h.")+tTime+T("@ideafarm.com\",\r\n"
                "    \"lastName\": \"Developer\",\r\n"
                "    \"firstName\": \"John\",\r\n"
                "    \"clientUserId\": \"")+tTime+T("\",\r\n"
                "    \"profileType\": \"INDIVIDUAL\",\r\n"
                "{\r\n"

            TN( tBody , "" ) ; tBody = T(

            etThread.traceF( tin0P , T("---- [tServer]:    ")+tServer , flTRACE_NOpREFIX ) ;
            TN( tServer , "uat-api.paylution.com" ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        _IO_
    {
    etThread.strMakeF( tin0P , LF , pstt1Cookies , 0 , TUCK << 3 ) ; ___( pstt1Cookies ) ;
    ZE( strokeS* , pstt1Cookies ) ;
    TN( tValueUserToken , "" ) ;

    }
        }
            }
                etThread.traceF( tin0P , T("socket is impotent") ) ;
                POOPRqUIET
            {
            if( POOP )

            }
                DEL( pSwPathValue ) ;

                }
                    }
                        etThread.delF( tin0P , psttValue ) ;

                        }
                            }
                                //etThread.traceF( tin0P , T("======================================================>    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                *pptValue[ offe ] = T(psttValue) ;
                            {
                            if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                        {
                        for( countT offe = 0 ; offe < cPaths ; offe ++ )

                        if( cPaths - cValues ) { BLAMMO ; }
                        countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                        countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                        //etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                        //etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;

                        strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                        psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                        _IO_
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                    _IO_
                {
                if( !POOP )

                //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                ;
                }
                    &tPathError     ,
                    &tPathErrorCode ,
                {
                textC* pptPath[] =

                TN( tPathError     , "\"error\"/"   ) ;
                TN( tPathErrorCode , "\"errcode\"/" ) ;

                ;
                }
                    &tValueError     ,
                    &tValueErrorCode ,
                {
                textC* pptValue[] =

                TN( tValueError     , "" ) ;
                TN( tValueErrorCode , "" ) ;

                __Z( pSwPathValue ) ;
                }
                    }
                        etThread.traceF( tin0P , T("!exception / could not parse json") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                ZE( switchC* , pSwPathValue ) ;
                ZE( strokeS* , psttPath     ) ;
                _IO_
            {

            etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , T(postj)                                                                                                               , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- response body:") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , T(posth)                                                                                                               , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- response head:") , flTRACE_NOpREFIX                    ) ;

            }
                }
                    }
                        if( !cNest ) break ;
                        costj ++ ;

                        else if( postj[ costj ] == '}' ) cNest -- ;
                             if( postj[ costj ] == '{' ) cNest ++ ;

                        if( !cbIn ) break ;
                        countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                    {
                    else
                    }
                        costh ++ ;

                        bHead = 0 ;
                        )
                            )
                                )
                                    posth[ costh - 2 ] == '\n'
                                    &&
                                    posth[ costh - 1 ] == '\r'
                                (
                                ||
                                posth[ costh - 1 ] == '\n'
                            (
                            &&
                            posth[ costh ] == '\n'
                            &&
                            costh
                        (
                        if

                        if( !cbIn ) break ;
                        countT cbIn = sockc.readF( tin0P , posth + costh , 1 ) ;
                    {
                    if( bHead )
                {
                for(;;)
                ZE( countT , cNest ) ;
                _IO_
            {
            ZE( countT , costj ) ;
            ZE( countT , costh ) ;
            boolT bHead = 1 ;
            thirdC::c_memsetIF( tin0P , postj , sizeof postj , 0 ) ;
            thirdC::c_memsetIF( tin0P , posth , sizeof posth , 0 ) ;

            sockc.writeF( tin0P , (osTextT*)tSay ) ;
            sockc.connectF( tin0P , 443 , nnServer ) ;
            socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

            countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
            countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
            countT timeAllowedConnected = TICK >> 2 ;

            nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
            nicNameC nnServer ;

            tSay += T("\r\n") ;

            etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX                    ) ;
            etThread.traceF( tin0P , tSay                                                                                                                   , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------- request  head:") , flTRACE_NOpREFIX                    ) ;

            ) ;

                "Accept: application/json\r\n"
                "Content-Type: application/json\r\n"
                "Authorization: Basic ")+tApiCredentials64Users+T("\r\n"
                "Host: ")+tServer+T("\r\n"
                "GET /rest/v4/payments HTTP/1.1\r\n"

            TN( tSay , "" ) ; tSay = T(

            etThread.traceF( tin0P , T("---- [tServer]:    ")+tServer , flTRACE_NOpREFIX ) ;
            TN( tServer , "uat-api.paylution.com" ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        _IO_
    {

    etThread.traceF( tin0P , T("[tHyperwalletProgramTokenSandboxUsers]:    ")+tHyperwalletProgramTokenSandboxUsers , flTRACE_NOpREFIX ) ;
    }
        etThread.delF( tin0P , psttw ) ;
        tHyperwalletProgramTokenSandboxUsers = T(psttw) ;
        if( psttw && psttw->idAdam ) tHyperwalletProgramTokenSandboxUsers = T(psttw) ;

        ZE( strokeS* , psttw ) ; etThread.querySettingF( tin0P , psttw , T("!ipdos.hyperwallet.sandbox.program.token.users" ) ) ; ___( psttw ) ;
    {
    TN( tHyperwalletProgramTokenSandboxUsers , "" ) ;

    etThread.traceF( tin0P , T("[tHyperwalletProgramTokenSandboxFunding]:    ")+tHyperwalletProgramTokenSandboxFunding , flTRACE_NOpREFIX ) ;
    }
        etThread.delF( tin0P , psttw ) ;
        tHyperwalletProgramTokenSandboxFunding = T(psttw) ;
        if( psttw && psttw->idAdam ) tHyperwalletProgramTokenSandboxFunding = T(psttw) ;

        ZE( strokeS* , psttw ) ; etThread.querySettingF( tin0P , psttw , T("!ipdos.hyperwallet.sandbox.program.token.funding" ) ) ; ___( psttw ) ;
    {
    TN( tHyperwalletProgramTokenSandboxFunding , "" ) ;

    etThread.traceF( tin0P , T("[tApiCredentials64Users]:    ")+tApiCredentials64Users , flTRACE_NOpREFIX ) ;
    }
        etThread.delF( tin0P , psttw ) ;
        tApiCredentials64Users = T(psttw) ;
        if( psttw && psttw->idAdam ) tApiCredentials64Users = T(psttw) ;

        ZE( strokeS* , psttw ) ; etThread.querySettingF( tin0P , psttw , T("!ipdos.credentials64.hyperwallet.sandbox.users" ) ) ; ___( psttw ) ;
    {
    TN( tApiCredentials64Users , "" ) ;

    etThread.traceF( tin0P , T("[tApiCredentials64Funding]:    ")+tApiCredentials64Funding , flTRACE_NOpREFIX ) ;
    }
        etThread.delF( tin0P , psttw ) ;
        tApiCredentials64Funding = T(psttw) ;
        if( psttw && psttw->idAdam ) tApiCredentials64Funding = T(psttw) ;

        ZE( strokeS* , psttw ) ; etThread.querySettingF( tin0P , psttw , T("!ipdos.credentials64.hyperwallet.sandbox.funding" ) ) ; ___( psttw ) ;
    {
    TN( tApiCredentials64Funding , "" ) ;

    TN( tTime , "" ) ; tTime = TTF(timeN1,timeN2) ;
    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT  , timeN1 ) ;

    _IO_
{
if( pTaskP )
TASK( tmWorkF )

osTextT postj[ TOCK << 0 ] ;
osTextT posth[ TOCK << 0 ] ;

/*1*/WAKEsHOWtEXT( "dut.hyperwallet" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
