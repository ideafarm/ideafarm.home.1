
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
    
        ((tin1S&)tin0P).pag3->_socketC_.grab.ungrabF( tin0P ) ;
        pOdometer->cbWrite += ((tin1S&)tin0P).odoSockCbWrite - _odoSockCbWriteOpen ;
        pOdometer->cbRead  += ((tin1S&)tin0P).odoSockCbRead  - _odoSockCbReadOpen  ;
        pOdometer = (sockOdometerS*)&(countT&)*((tin1S&)tin0P).pag3->_socketC_.pSwOdometer ;
        ((tin1S&)tin0P).pag3->_socketC_.nnLever = nnPeer ;
        ((tin1S&)tin0P).pag3->_socketC_.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    
        bRead.ungrabF( tin0P ) ;
    
        if( idleTimeAllowedRead ) FRESHtIMEaTOMIC( *pEther , timeLathRead.time1 , timeLathRead.time2 )
    
        }
            }
                pEther->delF( tin0P , pbIn2 ) ;
                pEther->delF( tin0P , pbAll ) ;
                }
                    }
                        }
                            soulP.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_soulC , pbAll , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                            _IO_
                        {
                        if( cbIn2 ) pEther->memCopyF( tin0P , pbAll + 3 * sizeof( countT ) , pbIn2 , cbIn2 ) ;
                                  ((countT*)pbAll)[ 2 ] = length   ;
                                  ((countT*)pbAll)[ 1 ] = idFormat ;
                        putNegAM( ((countT*)pbAll)[ 0 ] , finger ) ;
                        _IO_
                    {
                    if( pbAll )
                    pEther->newF( tin0P , LF , pbAll , 3 * sizeof( countT ) + length ) ; ___( pbAll ) ;
                {
                if( !POOP )
                ZE( byteT* , pbAll ) ;
    
                }
                    pEther->delF( tin0P , pcCode2 ) ;
                    }
                        }        
                            __( cbIn2 - length ) ;
                            dad( tin0P , pbIn2 , cbIn2 , pcCode2 , length ) ; ___( pbIn2 ) ;
                            _IO_
                        {
                        if( !POOP )
                        readF( tin0P , (byteT*)pcCode2 , sizeof( count01T ) * length , flSOCKETcrEAD_null , time1P , time2P ) ;
                        _IO_
                    {
                    if( pcCode2 )
                    pEther->newF( tin0P , LF , pcCode2 , length ) ; ___( pcCode2 ) ;
                    ZE( count01T* , pcCode2 ) ;
                    _IO_
                {
                if( !POOP && length )
                ZE( countT , cbIn2 ) ;
                ZE( byteT* , pbIn2 ) ;
    
                }    
                    }
                        pEther->delF( tin0P , pbIn1 ) ;
                        }
                            __( length & BM_HIGH           ) ;      // WEAK TEST TO DETECT GARBAGE (VALID length WILL NEVER HAVE BM_HIGH BIT SET)
                            __( idFormat - 1               ) ;
                            __( finger   - FINGERnEG_SOULc ) ;

                            length   = ((countT*)pbIn1)[ 2 ] ;
                            idFormat = ((countT*)pbIn1)[ 1 ] ;
                            finger   = getNegAM( ((countT*)pbIn1)[ 0 ] ) ;
                            _IO_
                        {
                        if( !POOP )
                        __( cbIn1 - 3 * sizeof( countT ) ) ;
                        __Z( pbIn1 ) ;
                        dad( tin0P , pbIn1 , cbIn1 , pcCode1 , 3 * sizeof( countT ) ) ; ___( pbIn1 ) ;
                        ZE( countT , cbIn1 ) ;
                        ZE( byteT* , pbIn1 ) ;
                        _IO_
                    {
                    if( !POOP )
            
                    readF( tin0P , (byteT*)( pcCode1 + 1 ) , sizeof pcCode1 - sizeof pcCode1[ 0 ] , flSOCKETcrEAD_null , time1P , time2P ) ;
                    count01T pcCode1[ 3 * sizeof( countT ) ] = { woth } ;
                    _IO_
                {
                ZE( countT , length   ) ;
                ZE( countT , idFormat ) ;
                ZE( countT , finger   ) ;
                _IO_
            {
            else
            }
                }
                    pEther->delF( tin0P , pcCodeE ) ;
                    }
                        }
                            pEther->delF( tin0P , pbIn1 ) ;
                            soulP.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_soulC , pbIn1 , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ; //WILL NOT BE DONE IF PEER JUST SENT A PIN REFERENCE
                            __Z( cbIn1 ) ;
                            __Z( pbIn1 ) ;
                            dad( tin0P , pbIn1 , cbIn1 , pcCodeE , ccCodeE ) ; ___( pbIn1 ) ;
                            ZE( countT , cbIn1 ) ;
                            ZE( byteT* , pbIn1 ) ;
                            _IO_
                        {
                        if( !POOP )
            
                        readF( tin0P , (byteT*)( pcCodeE + 3 ) , sizeof( count01T ) * pcCodeEp[ 2 ] , flSOCKETcrEAD_null , time1P , time2P ) ;
                        pcCodeE[ 2 ] = pcCodeEp[ 2 ] ;
                        pcCodeE[ 1 ] = pcCodeEp[ 1 ] ;
                        pcCodeE[ 0 ] = pcCodeEp[ 0 ] ;
                        _IO_
                    {
                    if( pcCodeE )
                    pEther->newF( tin0P , LF , pcCodeE , ccCodeE ) ; ___( pcCodeE ) ;
                    countT ccCodeE = 3 + pcCodeEp[ 2 ] ;
                    ZE( count01T* , pcCodeE ) ;
                    _IO_
                {
                if( pcCodeEp[ 2 ] )
                readF( tin0P , (byteT*)( pcCodeEp + 1 ) , sizeof pcCodeEp - sizeof pcCodeEp[ 0 ] , flSOCKETcrEAD_null , time1P , time2P ) ;
                count01T pcCodeEp[ 3 ] = { woth } ; //"Ep": "ESCAPE SEQUENCE PREFIX: NULL IDcMD CCaRG"
                _IO_
            {
            if( !woth ) //THIS SOUL'S ENCODING IS AN ESCAPE SEQUENCE
            readF( tin0P , (byteT*)&woth , sizeof woth , flSOCKETcrEAD_null , time1P , time2P ) ;
            ZE( count01T , woth ) ;
            _IO_
        {
        else if( !POOP )
        }
            THREADmODE1rESTORE

            }
                pEther->sockReadF( tin0P , soulP , handle , time1P , time2P ) ;
                //etherC::etRockIF( tin0P ).traceF( tin0P , T("flSOCKETc_CRYPTfOREIGNsSL is not set") ) ;
                _IO_
            {
            else
            }
                /*U::pEther->openSslTls_readF( tin0P ,  , handle )*/ ;
                //armSslC armMe( tin0P , flagsOpenSslFails ) ;
                //etherC::etRockIF( tin0P ).traceF( tin0P , T("flSOCKETc_CRYPTfOREIGNsSL is     set") ) ;
                //_IO_
            {
            if( F(flags) & flSOCKETc_CRYPTfOREIGNsSL ) 

            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            _IO_
        {
        if( F(flags) & flSOCKETc_NOsECRECY )
    
        }
            }
                }
                    }
                        break ;
                        __1
                        __( idCmd ) ;
                        _IO_
                    {
                    default :
                    }
                        break ;
    
                        (*pEther)( tin0P , psFinger ) ;
                        }
                            __( finger - FINGERnEG_SOCKETsECREThANDSHAKE ) ;
                            *psFinger >> finger ;
                            ZE( countT , finger ) ;
                            readF( tin0P , *psFinger ) ;
                            _IO_
                        {
                        if( psFinger )
                        (*pEther)( tin0P , psFinger , TAG( TAGiDnULL ) ) ;
                        ZE( soulC* , psFinger ) ;
    
                        }
                            }
                                pEther->delF( tin0P , pcCode ) ;
                                }
                                    }
                                        __NZ( pbIn1 ) ;
                                        dad( tin0P , pbIn1 , cbIn1 , pcCode , ccCode ) ; ___( pbIn1 ) ;
                                        ZE( countT , cbIn1 ) ;
                                        ZE( byteT* , pbIn1 ) ;
                                        _IO_
                                    {
                                    if( !POOP )
                
                                    readF( tin0P , (byteT*)pcCode , ccCode * sizeof( count01T ) ) ; //CANNOT USE soulC BECAUSE PIN HAS ALREADY BEEN APPLIED TO PEER AND I DO NOT WANT TO FIDDLE WITH MY flags MEMBER BECAUSE I AM NOT SERIALIZED WRT writeF
                                    _IO_
                                {
                                if( pcCode )
                                pEther->newF( tin0P , LF , pcCode , ccCode ) ; ___( pcCode ) ;
                                ZE( count01T* , pcCode ) ;
                                _IO_
                            {
                            else
                            if( !ccCode ) __1
    
                            readF( tin0P , (byteT*)&ccCode , sizeof ccCode ) ;
                            ZE( countT , ccCode ) ;
                            _IO_
                        {
                        _IO_
                    {
                    case ifcIDcMDsOCKETtOPsECRET_3APPLYtHISpINrEFERENCE :
                    }
                        break ;
    
                        }
                            }
                                }
                                    //CONoUTrAW( TF1(((tin1S&)tin0P).glass.idThread)+T(".- ")+T(((tin123S&)tin0P).postThreadName)+T("\r\n") ) ;
                                    pEther->delF( tin0P , pbKey ) ;
                            
                                    }
                                        (*pEther)( tin0P , psSecret ) ;
                                        (*pEther)( tin0P , psTo ) ;
                                        }
                                            }
                                                pEther->cioPutSecretF( tin0P , etherC::etPrimeIF( tin0P ) , *psSecret , *psTo , count8S( ifcIDaDAM_3BANG , ifcOLDiDcHANNELfUNCTION_SECREThANDsHAKEkEY ) ) ;
                                                CONoUTrAW( "whispering\r\n" ) ;
                                                _IO_
                                            {
                                            //if( !incv02AM( cIn ) && idHomeDisk == 2 ) //U::TO FIND A BUG
                                            //static countT cIn ;
        
                                            //CONoUTrAW( TF1(((tin1S&)tin0P).glass.idThread)+T(".")+T(((tin123S&)tin0P).postThreadName)+T(": whispering\r\n")+T(pczKeyTopSecret)+T("\r\n") ) ; //U::
                                            psSecret->shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_byteTptr , pbKey , cbKey ) ;
                                            *psSecret << pczKeyTopSecret ;
                                            idptRelayTopSecretPeer >> *psTo ;
                                            _IO_
                                        {
                                        if( psSecret && psTo )
                                        (*pEther)( tin0P , psTo , TAG( TAGiDnULL ) ) ;
                                        ZE( soulC* , psTo ) ;
                                        (*pEther)( tin0P , psSecret , TAG( TAGiDnULL ) ) ;
                                        ZE( soulC* , psSecret ) ;
                                        _IO_
                                    {
                                    else
                                    if( !pbKey || !cbKey ) __1
                            
                                    if( POOP ) break ;
                                    pEther->boxGetShadowF( tin0P , pbKey , cbKey , tLong , 1 ) ; ___( pbKey ) ;
                                    ZE( countT , cbKey ) ;
                                    ZE( byteT* , pbKey ) ;
                            
                                    TN( tLong , "" ) ; tLong = T("///desk/" POSTfOLDERsECURITYkEYdEPOSITORY)+(idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/")+tShort ;
                                    countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;
                                    textC tShort( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , (countT*)pczKeyTopSecret , flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE , 8 , 0 , tDot ) ;
                                    TN( tDot , "." ) ;
                
                                    timeLathTopSecretPinSend.time2 = timeN2 ;
                                    timeLathTopSecretPinSend.time1 = timeN1 ;
                                    //CONoUTrAW( TT(timeD1,timeD2)+T("\r\n")+TF1(((tin1S&)tin0P).glass.idThread)+T(".+ ")+T(((tin123S&)tin0P).postThreadName)+T("\r\n") ) ;
                                    //CONoUTrAW( "request not ignored 2\r\n" ) ;
                                    _IO_
                                {
                                if( timeD2 || timeD1 > TOCK * 0x40 ) //THIS TEST ELIMINATES REDUNDANT JOB ORDERS TO SECRET SERVICE
            
                                pEther->osTimeSubtractF( tin0P , timeD1 , timeD2 , timeLathTopSecretPinSend.time1 , timeLathTopSecretPinSend.time2 ) ;
                                sCountT timeD2 = timeN2 ;
                                countT timeD1 = timeN1 ;
                                //CONoUTrAW( "request not ignored 1\r\n" ) ;
                                _IO_
                            {
                            if( timeD2 || timeD1 > TOCK * 0x40 ) //U::TICK
                            //THE NEXT LINE SUPPRESSES TOP SECRECY FOR INFANT CONNECTIONS, TO REDUCE THE LOAD ON THE SECRET SERVERS
        
                            pEther->osTimeSubtractF( tin0P , timeD1 , timeD2 , timeWothTopSecretPinRequestReceived.time1 , timeWothTopSecretPinRequestReceived.time2 ) ;
                            sCountT timeD2 = timeN2 ;
                            countT timeD1 = timeN1 ;
                            _IO_
                        {
                        else
                        }
                            timeWothTopSecretPinRequestReceived.time2 = timeN2 ;
                            timeWothTopSecretPinRequestReceived.time1 = timeN1 ;
                            //CONoUTrAW( "woth request received\r\n" ) ;
                            _IO_
                        {
                        if( !timeWothTopSecretPinRequestReceived.time1 && !timeWothTopSecretPinRequestReceived.time2 )
    
                        pEther->osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                        ZE( sCountT , timeN2 ) ;
                        ZE( countT , timeN1 ) ;
                        _IO_
                    {
                    case ifcIDcMDsOCKETtOPsECRET_2SENDpINiMAGEsECRETLY :
                    }
                        break ;
    
                        (*pEther)( tin0P , pSoul ) ;
                        }
                            idptRelayTopSecretPeer << *pSoul ;
                            *pSoul >> pczKeyTopSecretPeer ; ___( pczKeyTopSecretPeer ) ;
                            readF( tin0P , *pSoul ) ;
                        {
                        if( pSoul )
                        (*pEther)( tin0P , pSoul , TAG( TAGiDnULL ) ) ;
                        ZE( soulC* , pSoul ) ;
                        _IO_
                    {
                    case ifcIDcMDsOCKETtOPsECRET_1MYpINnAMEiS :
                    }
                        break ;
                        bPayload = 1 ;
                        _IO_
                    {
                    case ifcIDcMDsOCKETtOPsECRET_PAYLOAD :
                {
                switch( idCmd )
                readF( tin0P , (byteT*)&idCmd , sizeof idCmd ) ;
        
                ZE( countT , idCmd ) ;
                _IO_
            {
            while( !POOP && !bPayload )
            ZE( boolT , bPayload ) ;
            _IO_
        {
        if( F(flags) & flSOCKETc_TOPsECRET )
    
        bRead.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    
        const countT _odoSockCbWriteOpen = ((tin1S&)tin0P).odoSockCbWrite ;
        const countT _odoSockCbReadOpen  = ((tin1S&)tin0P).odoSockCbRead  ;

        _IO_
    
        }
            }
                return ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )

            __( !(const byteT*)soulP ) ;

            }
                return ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL    
        SCOOPP
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/voidT socketC::readF( tin0S& tin0P , soulC& soulP , const countT time1P , const sCountT time2P )/*1*/

/**/
*/
\<A HREF=\"5.1070026.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$readF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

