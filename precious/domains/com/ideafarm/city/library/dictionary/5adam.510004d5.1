
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
__( thUnserializedPool ) ;
bFrozen = 1 ;
etThread.etherReadFromCyrcleOldF( tinBaseP , pNapMonitor , cirMonitorF , cParm , bQuitMonitoring , T("napMonitor") , CBmONITORbUFFER ) ;
U::NEED TO PASS IN A bitsC REFERENCE
OStEXTAK( napHomeJot  , postNAPhOSTjOTsTATUSrEADY ) ;
ZE( napkinC* , pNapMonitor ) ;
countT cParm = (countT)&c8p ;
count8S c8p( (countT)&stGrab , (countT)&stTin , (countT)&stTinWhere , (countT)&pNapLog , (countT)&cFreeze , (countT)&bFrozen ) ;

//etThread.osThreadF( tinBaseP , countTC() , tmFireMyselfF ) ; //U::
etThread.osThreadF( tinBaseP , countTC() , tmWhereRptF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&c2p ) ;
etThread.osThreadF( tinBaseP , countTC() , tmWhereF    , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&c2p ) ;
count2S c2p( (countT)&c8t1 , (countT)&c8t2 ) ;
count8S c8t2 ; // ADDITIONAL PARAMS CAN BE PASSED HERE
count8S c8t1( (countT)&bNewWhereRpt , (countT)&pczLever , (countT)&lifiLever , (countT)&swTally1 , (countT)&swTally2 , (countT)&swTally3 , (countT)&swTally4 , (countT)&stTinWhere ) ;
switchC swTally4( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pczLever ) ; // "
switchC swTally3( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pczLever ) ; // "
switchC swTally2( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , (byteT*)&lifiLever , sizeof lifiLever ) ; // "
switchC swTally1( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , (byteT*)&lifiLever , sizeof lifiLever ) ; //swTally* OBJECTS ARE SERIALIZED BY GRABBING stTinWhere
count2S lifiLever ;
ZE( countT* , pczLever ) ;
ZE( boolT , bNewWhereRpt ) ;

etThread.osThreadF( tinBaseP , countTC() , tmRptF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&c8p1 , (countT)&c8p2 ) ;
count8S c8p2( (countT)&stTin , (countT)&pNapLog , (countT)&bQuitLogging , (countT)&bQuitMonitoring , (countT)&bDone_tmLogF , (countT)&cFreeze , (countT)&bFrozen ) ;
count8S c8p1( (countT)&stGrab , (countT)&stGrabbed , (countT)&stWanters , (countT)&stChecked , (countT)&stLoopedTmp , (countT)&stLooped , (countT)&stOsTidLoopedTmp , (countT)&stOsTidLooped ) ;

}
    while( !pNapLog && !etThread ) { ++ s ; etThread.osSleepF( tinBaseP ) ; }
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
{
etThread.osThreadF( tinBaseP , countTC() , tmLogF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&bDone_tmLogF , (countT)&pNapLog , (countT)&bQuitLogging ) ;
ZE( boolT , bDone_tmLogF ) ;

ZE( boolT , bFrozen ) ;
ZE( countT , cFreeze ) ;
ZE( napkinC* , pNapLog ) ;
stackC stTinWhere(       tinBaseP , etThread           , TAG( TAGiDnULL ) , flSTACKc_null           | flSTACKc_BLOB , sizeof( tinEntryS )  ) ;
stackC stTin(            tinBaseP , thUnserializedPool , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , sizeof( tinEntryS )  ) ;
stackC stOsTidLooped(    tinBaseP , thUnserializedPool , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE                                       ) ;
stackC stOsTidLoopedTmp( tinBaseP , thUnserializedPool , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE                                       ) ;
stackC stLooped(         tinBaseP , thUnserializedPool , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , sizeof( grabEntryS ) ) ;
stackC stLoopedTmp(      tinBaseP , thUnserializedPool , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE                                       ) ;
stackC stChecked(        tinBaseP , thUnserializedPool , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE                                       ) ;
stackC stWanters(        tinBaseP , thUnserializedPool , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE                                       ) ;
stackC stGrabbed(        tinBaseP , thUnserializedPool , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , sizeof( grabEntryS ) ) ;
stackC stGrab(           tinBaseP , thUnserializedPool , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , sizeof( grabEntryS ) ) ;
ZE( boolT , bQuitLogging ) ;
//THESE ARE HERE SO THAT tmRptF DOES NOT GENERATE grabOldS CT/DT NOTES

thirdC thUnserializedPool( tinBaseP , TAG( TAGiDnULL ) , poolOldSetOldUnserialized  ) ;
p oolC poolOldSetOldUnserialized( tinBaseP , T("monitor.unserialized.main.")+TF1(((tinNormalS&)tinBaseP).osPid)+T(".")+TF1(((tinNormalS&)tinBaseP).monitor.idThread) ) ; U::ENHANCE TO SUPPORT FLAGS SUCH AS "UNSERIALIZED"
    
//U::{ countT idAdam = ifcIDaDAMoLD_CHATsERVER ; ether.ifcHireF( tinBaseP , T("city.monitor") , idAdam , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ; }
//{ countT idAdam = 0x40104de ; ether.ifcHireF( tinBaseP , T("city.monitor") , idAdam , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ; }
    
//etThread.osThreadF( tinBaseP , countTC() , tmWantF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , 3 , (countT)&grabA , (countT)&grabB , (countT)&grabC ) ;
//etThread.osThreadF( tinBaseP , countTC() , tmWantF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , 2 , (countT)&grabA , (countT)&grabB , (countT)&grabC ) ;
//etThread.osThreadF( tinBaseP , countTC() , tmWantF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , 1 , (countT)&grabA , (countT)&grabB , (countT)&grabC ) ;
//grabOldS grabC( tinBaseP , TAG( TAGiDnULL ) ) ;
//grabOldS grabB( tinBaseP , TAG( TAGiDnULL ) ) ;
//grabOldS grabA( tinBaseP , TAG( TAGiDnULL ) ) ;
//etThread.osThreadF( tinBaseP , countTC() , tmRawSleepF ) ;

etThread.osThreadF( tinBaseP , countTC() , tmTellF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&bQuitMonitoring ) ;
ZE( boolT , bQuitMonitoring ) ;

OStEXTAK( napHomeJot  , "monitor: getting ready" ) ;

}
    napHomeJot.formattingIsDoneF( tinBaseP ) ;
    if( !etThread ) *napHomeJot = 0 ;
{
if( !( F(napHomeJot.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
__( !(byteT*)napHomeJot ) ;
__( (countT)napHomeJot - CBnAPjOT ) ;
napkinC napHomeJot( tinBaseP , LF , (byteT*)bits , "napHomeJot" , 0 , CBnAPjOT ) ;
bitsC bits( tinBaseP , CbITSlIFI , 0 , 1 ) ;

TODO

DONE( tmFireMyselfF )
FIREmYSELF ;
ether.osSleepF( tinBaseP , ru ) ;
ranUniC ru( TOCK * 8 ) ;
TASK( tmFireMyselfF )

DONE( tmTellF )
}
    }
        etThread.osSleepF( tinBaseP , TUCK * 0x40 ) ;
        TELLsYSc1( ifcIDtYPEtELLsYS_NOOP ) ;
    {
    while( !etThread && !bQuitMonitoring )

    boolT&  bQuitMonitoring =  *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )

TASK( tmTellF )

DONE( tmWhereRptF )
}
    }
        }
            ether.osSleepF( tinBaseP , TOCK * 0x10 ) ;
            CONoUTrAW( "W" ) ; //U::
    
            etThread.delF( tinBaseP , postr ) ;
            }
                BOSpOOP
                BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                BOSpOOP
                BOS( WHATgbo , BOSoK , WriteFile( osh , postr , costr , &cba , 0 ) )
                ZE( DWORD , cba ) ;
                HANDLE osh = (HANDLE)((tinNormalS&)tinBaseP).brcRaw ;
                BOSpOOP
                BOS( WHATgbo , BOShANDLE , CreateFile( ostoFile , GENERIC_WRITE , 0 , &sa , CREATE_ALWAYS , FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN , 0 ) )
                OStEXTAK( ostoFile , ".log.monitor.where" ) ;
                OStEXTC( ostoFile , etherC::ifc_idHomeI_IF() , 0 ) ;
                OStEXTAK( ostoFile , "\\ideafarm." ) ;
                OStEXT( ostoFile , 0x100 )
                BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                SECURITYaTTRIBUTE_saUNRESTRICTED( 0 ) ;
                POOPIES
            {
            etThread.delF( tinBaseP , psttr ) ;
            countT costr = etThread.strMakeF( tinBaseP , LF , postr , psttr ) ; ___( postr ) ;
            ZE( osTextT* , postr ) ;
    
            ) ;
        
                tb+T("outward tally: tally from the innermost callee outward")+tc2
                T("[TO]")+tc+
                tb+T("inward tally: tally from the outermost caller inward")+tc2+
                T("[TI]")+tc+
                tb+T("fine tally: tally of the innermost callee")+tc2+
                T("[TF]")+tc+
                tb+T("gross tally: tally of the outermost caller")+tc2+
                T("[TG]")+tc+
                tb+T("idReport: the number of generations of this report written since the IdeaFarm " "(tm) Operating System was started on this computer")+tc2+
                tb+T("the time of the report is represented according to the customs of IdeaFarm " "(tm) City")+tc+
                tb+T("(\"01 tock\" means 16 (base 10) tocks, or approximately 30 seconds)")+tc+
                tb+T("(a tock is approximately 1.33 seconds")+tc+
                tb+T("Local Monitor Report: this report is written every 01 tock by the IdeaFarm " "(tm) Operating System")+tc+
                tb+T("these programs are called \"IdeaFarm " "(tm) Cells\"")+tc+
                tb+T("some programs on this computer are using the IdeaFarm " "(tm) Operating System")+tc+
                tb+T("IdeaFarm " "(tm) Operating System: runs \"on top of\" this computer's base operating system (e.g. MS Windows)")+tc+
                tb+T("for support, see http://www.ideafarm.com or call Wo'O Ideafarm US 650-759-5306")+tc+
                T("[ID]")+tc+
                TPS(" \r\nexplanatory notes ",0x40,S1C('-'))+tc2+
        
            etThread.strFuseF( tinBaseP , psttr ,
    
            ((tinNormalS&)tinBaseP).flagsThreadMode2 &= ~( F(flTHREADmODE2_DISALLOWtELLmONITOR) ) ;
            stTinWhereP.ungrabF( tinBaseP ) ;

            }
                etThread.delF( tinBaseP , pbc2 ) ;
                }
                    }
                        else off ++ ;
                        }
                            etThread.strFuseF( tinBaseP , psttr , TP("",7+off)+TF3(pczLeverP[off++],flFORMAT_UNSIGNED,8)+T("\"")+T(postf)+T("\"\r\n") ) ;
                            osTextT* postf = processGlobal8I.source.postFileTitleF( tinBaseP , processGlobal8I.source.idFileRankF( tinBaseP , pczLeverP[ off ] ) ) ;
                        {
                        if( off < 2 || off % 2 )
                    {
                    while( pczLeverP[ off ] )
                    countT off = 2 ;
                    etThread.strFuseF( tinBaseP , psttr , TF3(swTally4P,flFORMAT_UNSIGNED,9)+TF1(pczLeverP)+T("\r\n") ) ;
                    pczLeverP = (countT*)swTally4P.leverF( tinBaseP , c2f.c2 ) ;
                    count2S& c2f = *(count2S*)pbc2 ;
                {
                if( pbc2 )
                stFlavor >> pbc2 ;
                ZE( byteT* , pbc2 ) ;
            {
            while( stFlavor )
    
            }
                stFlavor.sinkF( tinBaseP , countTC() , (byteT*)&c2f , flSTACKsINK_null , subtractTallyF ) ; //U::NEXT: GET THIS TO SORT PROPERLY ON swTally4P
                count2S c2f( swTally4P , idf ) ;
                pczLeverP = (countT*)swTally4P.leverF( tinBaseP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            cFlavors = swTally4P.cFlavorsF( tinBaseP ) ;

            etThread.strFuseF( tinBaseP , psttr , T(" \r\n[TO]\r\n") ) ; ___( psttr ) ;
    
            }
                etThread.delF( tinBaseP , pbc2 ) ;
                }
                    }
                        else off ++ ;
                        }
                            etThread.strFuseF( tinBaseP , psttr , TP("",7+off)+TF3(pczLeverP[off++],flFORMAT_UNSIGNED,8)+T("\"")+T(postf)+T("\"\r\n") ) ;
                            osTextT* postf = processGlobal8I.source.postFileTitleF( tinBaseP , processGlobal8I.source.idFileRankF( tinBaseP , pczLeverP[ off ] ) ) ;
                        {
                        if( off < 2 || off % 2 )
                    {
                    while( pczLeverP[ off ] )
                    countT off = 2 ;
                    etThread.strFuseF( tinBaseP , psttr , TF3(swTally3P,flFORMAT_UNSIGNED,9)+TF1(pczLeverP)+T("\r\n") ) ;
                    pczLeverP = (countT*)swTally3P.leverF( tinBaseP , c2f.c2 ) ;
                    count2S& c2f = *(count2S*)pbc2 ;
                {
                if( pbc2 )
                stFlavor >> pbc2 ;
                ZE( byteT* , pbc2 ) ;
            {
            while( stFlavor )
    
            }
                stFlavor.sinkF( tinBaseP , countTC() , (byteT*)&c2f , flSTACKsINK_null , subtractTallyF ) ; //U::NEXT: GET THIS TO SORT PROPERLY ON swTally3P
                count2S c2f( swTally3P , idf ) ;
                pczLeverP = (countT*)swTally3P.leverF( tinBaseP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            cFlavors = swTally3P.cFlavorsF( tinBaseP ) ;

            etThread.strFuseF( tinBaseP , psttr , T(" \r\n[TI]\r\n") ) ; ___( psttr ) ;
    
            }
                etThread.delF( tinBaseP , pbc2 ) ;
                }
                    etThread.strFuseF( tinBaseP , psttr , TF3(swTally2P,flFORMAT_UNSIGNED,9)+TF4(lifiLeverP.c1,flFORMAT_UNSIGNED,0xc,0xa)+TF3(lifiLeverP.c2,flFORMAT_UNSIGNED,9)+tb+T(processGlobal8I.source.postFileTitleF(tinBaseP,processGlobal8I.source.idFileRankF(tinBaseP,lifiLeverP.c2)))+T("\r\n") ) ;
                    lifiLeverP = *(count2S*)(byteT*)swTally2P.leverF( tinBaseP , c2f.c2 ) ;
                    count2S& c2f = *(count2S*)pbc2 ;
                {
                if( pbc2 )
                stFlavor >> pbc2 ;
                ZE( byteT* , pbc2 ) ;
            {
            while( stFlavor )
    
            }
                stFlavor.sinkF( tinBaseP , countTC() , (byteT*)&c2f , flSTACKsINK_null , subtractTallyF ) ; //U::NEXT: GET THIS TO SORT PROPERLY ON swTally2P
                count2S c2f( swTally2P , idf ) ;
                lifiLeverP = *(count2S*)(byteT*)swTally2P.leverF( tinBaseP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            cFlavors = swTally2P.cFlavorsF( tinBaseP ) ;

            etThread.strFuseF( tinBaseP , psttr , T(" \r\n[TF]\r\n") ) ; ___( psttr ) ;

            }
                etThread.delF( tinBaseP , pbc2 ) ;
                }
                    etThread.strFuseF( tinBaseP , psttr , TF3(swTally1P,flFORMAT_UNSIGNED,9)+TF4(lifiLeverP.c1,flFORMAT_UNSIGNED,0xc,0xa)+TF3(lifiLeverP.c2,flFORMAT_UNSIGNED,9)+tb+T(processGlobal8I.source.postFileTitleF(tinBaseP,processGlobal8I.source.idFileRankF(tinBaseP,lifiLeverP.c2)))+T("\r\n") ) ;
                    lifiLeverP = *(count2S*)(byteT*)swTally1P.leverF( tinBaseP , c2f.c2 ) ;
                    count2S& c2f = *(count2S*)pbc2 ;
                {
                if( pbc2 )
                stFlavor >> pbc2 ;
                ZE( byteT* , pbc2 ) ;
            {
            while( stFlavor )
    
            }
                stFlavor.sinkF( tinBaseP , countTC() , (byteT*)&c2f , flSTACKsINK_null , subtractTallyF ) ; //U::NEXT: GET THIS TO SORT PROPERLY ON swTally1P
                count2S c2f( swTally1P , idf ) ;
                lifiLeverP = *(count2S*)(byteT*)swTally1P.leverF( tinBaseP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swTally1P.cFlavorsF( tinBaseP ) ;

            etThread.strMakeF( tinBaseP , LF , psttr , T("[ID]\r\nIdeaFarm " "(tm) Operating System\r\nLocal Monitor Where Tallies\r\n(see the explanatory notes at the end of this report)\r\n")+TT(timeN1,timeN2)+T("\r\nidReport: ")+TF1(++idReport)+T("\r\n \r\n[TG]\r\n") , 0x100000 ) ; ___( psttr ) ;
            ZE( strokeS* , psttr ) ;
    
            etThread.osTimeNowF( tinBaseP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;

            stTinWhereP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
            ((tinNormalS&)tinBaseP).flagsThreadMode2 |= flTHREADmODE2_DISALLOWtELLmONITOR ;
            bNewWhereRptP = 0 ;
        {
        if( bNewWhereRptP && ( !stTinWhereP || idCycle % 0x10 == 1 ) ) //ONLY EVERY TICK IF AM WATCHING WHERE WO OR MORE THREADS ARE
        idCycle ++ ;
    {
    while( !ether && !etThread )
    stackC stFlavor( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , 2 * sizeof( countT ) ) ;
    TN( tb , " " ) ;
    TN( tc2 , "\r\n \r\n" ) ;
    TN( tc , "\r\n" ) ;
    ZE( countT , idReport ) ;
    ZE( countT , idCycle ) ;

    stackC&  stTinWhereP   =    *(stackC*)c8t1P.c8 ;
    switchC& swTally4P     =   *(switchC*)c8t1P.c7 ;
    switchC& swTally3P     =   *(switchC*)c8t1P.c6 ;
    switchC& swTally2P     =   *(switchC*)c8t1P.c5 ;
    switchC& swTally1P     =   *(switchC*)c8t1P.c4 ;
    count2S& lifiLeverP    =   *(count2S*)c8t1P.c3 ;
    countT*& pczLeverP     =   *(countT**)c8t1P.c2 ;
    boolT&   bNewWhereRptP =     *(boolT*)c8t1P.c1 ;
    count8S& c8t2P         =    *(count8S*)c2pP.c2 ;
    count8S& c8t1P         =    *(count8S*)c2pP.c1 ;
    count2S& c2pP          = *(count2S*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmWhereRptF )

DONE( tmWhereF )
}
    }
        OSsLEEPf( 0x40 ) ;
        CONoUTrAW( "." ) ; //U::

        stTinWhereP.ungrabF( tinBaseP ) ;
        }
            while( !stTinWhereP.third && ~hDown ) ;
            }
                }
                    if( !bNewWhereRptP ) bNewWhereRptP = 1 ;

                    ++ swTally4P ;
                    pczLeverP = pcloOut ;
    
                    ++ swTally3P ;
                    pczLeverP = pcloIn ;

                    }
                        pcloOut[ offo ++ ] = whereCopy.pLFnest[ ( ( idn & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
                        pcloOut[ offo ++ ] = whereCopy.pLFnest[   ( idn & OFFsLOTtINnESTmAX ) << 1       ] ;
                    {
                    for( countT idn = whereCopy.monitor.cInNest ; idn >= idnf ; idn -- )
                    offo = 2 ;

                    }
                        pcloIn[ offo ++ ] = whereCopy.pLFnest[ ( ( idn & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
                        pcloIn[ offo ++ ] = whereCopy.pLFnest[   ( idn & OFFsLOTtINnESTmAX ) << 1       ] ;
                    {
                    for( countT idn = idnf ; idn <= whereCopy.monitor.cInNest ; idn ++ )
    
                    countT offo = 2 ;
                    pcloOut[ 1 ] = pcloIn[ 1 ] = 0x20 ; //U::PLACEHOLDER FOR idPhase3 idPhase
                    pcloOut[ 0 ] = pcloIn[ 0 ] = 0x10 ; //U::PLACEHOLDER FOR idPhase3 idPhase
                    thirdC::c_memsetIF( tinBaseP , (byteT*)pcloOut , sizeof pcloOut ) ;
                    thirdC::c_memsetIF( tinBaseP , (byteT*)pcloIn , sizeof pcloIn ) ;
                    countT pcloOut[ 3 + sizeof whereCopy.pLFnest / sizeof whereCopy.pLFnest[ 0 ] ] ;
                    countT pcloIn[  3 + sizeof whereCopy.pLFnest / sizeof whereCopy.pLFnest[ 0 ] ] ;
    
                    ++ swTally2P ;
                    lifiLeverP.c2 = whereCopy.pLFnest[ ( ( whereCopy.monitor.cInNest & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
                    lifiLeverP.c1 = whereCopy.pLFnest[   ( whereCopy.monitor.cInNest & OFFsLOTtINnESTmAX ) << 1       ] ;

                    ++ swTally1P ;
                    lifiLeverP.c2 = whereCopy.pLFnest[ ( ( idnf & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
                    lifiLeverP.c1 = whereCopy.pLFnest[   ( idnf & OFFsLOTtINnESTmAX ) << 1       ] ;
    
                    if( (sCountT)idnf < 1 ) idnf = 1 ;
                    idnf = whereCopy.monitor.cInNest - OFFsLOTtINnESTmAX ;
                {
                if( bOk )

                else thirdC::dosReadProcessMemoryIF( tinBaseP , (byteT*)&whereCopy , sizeof whereCopy , bOk , (voidT*)( entry.ip + ( (byteT*)&((tinNormalS&)tinBaseP).monitor.cInNest - (byteT*)&tinBaseP ) ) , entry.osPid ) ;
                }
                    bOk = 1 ;
                    thirdC::c_memcpyIF( tinBaseP , (byteT*)&whereCopy , (byteT*)pWhere , sizeof whereCopy ) ; //A COPY IS MADE EVEN IF IDA TO INCREASE THE PROBABILITY THAT THE DATA ARE CONSISTENT
                    whereOldS* pWhere = (whereOldS*)( (byteT*)ap_artmentOldC( tinBaseP , entry.ip ) + ( (byteT*)&((tinNormalS&)tinBaseP).monitor.cInNest - (byteT*)&tinBaseP ) ) ;
                {
                if( entry.bIda )
                ZE( boolT , bOk ) ;
                ZE( countT , idnf ) ;
                whereCopy ;
                }
                    countT pLFnest[ ( 1 + OFFsLOTtINnESTmAX ) << 1 ] ;
                    countT cNest ;
                {
                struct whereOldS
            
                idp ++ ;
                tinEntryS& entry = *(tinEntryS*)&stTinWhereP.downF( tinBaseP , hDown ) ;
            {
            do
            handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , idp ) ; //U::
        {
        if( stTinWhereP )
        stTinWhereP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
    {
    while( !ether && !etThread )
    //etThread.osThreadSwitchingDesireF( tinBaseP , ifcTHREADpRIORITY_SPINLOCK ) ;

    stackC&  stTinWhereP   =    *(stackC*)c8t1P.c8 ;
    switchC& swTally4P     =   *(switchC*)c8t1P.c7 ;
    switchC& swTally3P     =   *(switchC*)c8t1P.c6 ;
    switchC& swTally2P     =   *(switchC*)c8t1P.c5 ;
    switchC& swTally1P     =   *(switchC*)c8t1P.c4 ;
    count2S& lifiLeverP    =   *(count2S*)c8t1P.c3 ;
    countT*& pczLeverP     =   *(countT**)c8t1P.c2 ;
    boolT&   bNewWhereRptP =     *(boolT*)c8t1P.c1 ;
    count8S& c8t2P         =    *(count8S*)c2pP.c2 ;
    count8S& c8t1P         =    *(count8S*)c2pP.c1 ;
    count2S& c2pP          = *(count2S*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmWhereF )

DONE( tmLogF )
}
    bDone_tmLogF = 1 ;
    etThread.etherReadFromCyrcleOldF( tinBaseP , pNapLog , cirLogF , countTC() , bQuitLogging , T(POSTlOG) , CBlOG ) ;
U::NEED TO PASS IN A bitsC REFERENCE
    boolT&    bQuitLogging =    *(boolT*)pTaskP->c3 ;
    napkinC*& pNapLog      = *(napkinC**)pTaskP->c2 ;
    boolT&    bDone_tmLogF =    *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmLogF )

}
    return 0 ;

    etherP.delF( tinBaseP , pbData ) ;
    }
        }
            thirdC::dosWriteProcessMemoryIF( tinBaseP , countTC() , (voidT*)( (byteT*)head.ipMe + ( (byteT*)&head.ipMe - (byteT*)&head ) ) , head.osPid , (byteT*)&ze , sizeof ze ) ;
            ZE( countT , ze ) ;
        {
        else
        if( head.bIda ) ( (tellS*)(byteT*)ap_artmentOldC( tinBaseP , head.ipMe ) )->ipMe = 0 ;
    {
    if( head.ipMe ) // bSynchronous

    }
        }
            }
                break ;

                stTinWhereP.ungrabF( tinBaseP ) ;
                stTinWhereP.extractF( 0 , tinBaseP ) ;
                if( !ids ) { BLAMMO ; }
                stTinWhereP.sinkF( tinBaseP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_tinEntryS_F ) ;
                stTinWhereP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                ids = 0 ; // stTinP stTinWhereP ARE REDUNDANT SO THAT tmWhereF tmWhereRptF DO NOT TOUCH THE stackC OBJECT THAT tmRptF USES

                stTinP.ungrabF( tinBaseP ) ;
                stTinP.extractF( 0 , tinBaseP ) ;
                if( !ids ) { BLAMMO ; }
                stTinP.sinkF( tinBaseP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_tinEntryS_F ) ;
                stTinP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                ZE( countT , ids ) ;

if( entry.osPid != ((tinNormalS&)tinBaseP).osPid ) { CONoUTrAW( TF3(entry.idSerial,flFORMAT_UNSIGNED,9)+TF3(entry.osPid,flFORMAT_UNSIGNED,9)+TF3(entry.bIda,flFORMAT_UNSIGNED,9)+TF3(entry.ip,flFORMAT_UNSIGNED,9)+T("\"")+T(entry.postThreadName)+T("\" -\r\n") ) ; } //U::
                tinEntryS entry( tinBaseP , info.idSerial , head.osPid , head.idType == ifcIDtYPEtELLsYS_TINdTI , info.ip , info.idTin , head.idThread , info.postThreadName ) ;
                tellInfoSysTinS& info = *(tellInfoSysTinS*)pbData ;

                if( head.cbData != sizeof( tellInfoSysTinS ) ) { BLAMMO ; }
            {
            case ifcIDtYPEtELLsYS_TINdTP :
            case ifcIDtYPEtELLsYS_TINdTI :
            }
                break ;

                if( !ids ) { BLAMMO ; }
                stTinWhereP.sinkF( tinBaseP , ids , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_tinEntryS_F ) ;
                ids = 0 ;

                if( !ids ) { BLAMMO ; }
                stTinP.sinkF( tinBaseP , ids , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_tinEntryS_F ) ;
                ZE( countT , ids ) ;

if( entry.osPid != ((tinNormalS&)tinBaseP).osPid ) { CONoUTrAW( TF3(entry.idSerial,flFORMAT_UNSIGNED,9)+TF3(entry.osPid,flFORMAT_UNSIGNED,9)+TF3(entry.bIda,flFORMAT_UNSIGNED,9)+TF3(entry.ip,flFORMAT_UNSIGNED,9)+T("\"")+T(entry.postThreadName)+T("\" +\r\n") ) ; } //U::
                tinEntryS entry( tinBaseP , info.idSerial , head.osPid , head.idType == ifcIDtYPEtELLsYS_TINcTI , info.ip , info.idTin , head.idThread , info.postThreadName ) ;
                tellInfoSysTinS& info = *(tellInfoSysTinS*)pbData ;

                if( head.cbData != sizeof( tellInfoSysTinS ) ) { BLAMMO ; }
            {
            case ifcIDtYPEtELLsYS_TINcTP :
            case ifcIDtYPEtELLsYS_TINcTI :
            }
                break ;

                stGrabP.ungrabF( tinBaseP ) ;
                stGrabP.extractF( 0 , tinBaseP ) ;
                if( !ids ) { BLAMMO ; }
                stGrabP.sinkF( tinBaseP , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_grabEntryS_F ) ;
                stGrabP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                ZE( countT , ids ) ;
                grabEntryS entry( tinBaseP , info.idSerial , head.osPid , head.idType == ifcIDtYPEtELLsYS_GRABdTI || head.idType == ifcIDtYPEtELLsYS_GRABdEI , info.ip , info.idLineCt , info.idiFileCt ) ;
                tellInfoSysGrabS& info = *(tellInfoSysGrabS*)pbData ;

                if( head.cbData != sizeof( tellInfoSysGrabS ) ) { BLAMMO ; }
            {
            case ifcIDtYPEtELLsYS_GRABdEP :
            case ifcIDtYPEtELLsYS_GRABdEI :
            case ifcIDtYPEtELLsYS_GRABdTP :
            case ifcIDtYPEtELLsYS_GRABdTI :
            }
                break ;

                if( !ids ) { BLAMMO ; }
                stGrabP.sinkF( tinBaseP , ids , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_grabEntryS_F ) ;
                ZE( countT , ids ) ;
                grabEntryS entry( tinBaseP , info.idSerial , head.osPid , head.idType == ifcIDtYPEtELLsYS_GRABcTI || head.idType == ifcIDtYPEtELLsYS_GRABaTI , info.ip , info.idLineCt , info.idiFileCt ) ;
                tellInfoSysGrabS& info = *(tellInfoSysGrabS*)pbData ;

                if( head.cbData != sizeof( tellInfoSysGrabS ) ) { BLAMMO ; }
            {
            case ifcIDtYPEtELLsYS_GRABaTP :
            case ifcIDtYPEtELLsYS_GRABaTI :
            case ifcIDtYPEtELLsYS_GRABcTP :
            case ifcIDtYPEtELLsYS_GRABcTI :
            }
                break ;

                etherP.delF( tinBaseP , psttl ) ;
                if( psttl ) thirdC::thirdWriteToCyrcleOldIF( tinBaseP , napLogP , T(psttl) , psttl->idAdam + 1 ) ;
                tin.strFuseF( tinBaseP , etherP , psttl , 0 , flTINrPT1_null , flTINrPT2_null , flTINrPT1_pLFstepAll , flTINrPT2_null , 0 , 2 ) ; ; ___( psttl ) ;
                etherP.strFuseF( tinBaseP , psttl , T(" tinNormalS\r\n") ) ; ___( psttl ) ;
                else if( info.idException == ifcIDeVENTeXCEPTIONmONITORED_GRUNT       ) etherP.strFuseF( tinBaseP , psttl , T(" rc" ": ")+TF1(info.pcInfo[0])+T("\r\n idLine: ")+TF1(info.pcInfo[1])+T("\r\n idiFile: ")+TF1(info.pcInfo[2])+T("\r\n") ) ;
                else if( info.idException == ifcIDeVENTeXCEPTIONmONITORED_ACCESSvIOLATION ) etherP.strFuseF( tinBaseP , psttl , T(" bWrite: ")+TF1(info.pcInfo[0])+T("\r\n pvTarget: ")+TF1(info.pcInfo[1])+T("\r\n") ) ;
                     if( info.idException == ifcIDeVENTeXCEPTIONmONITORED_NOTlISTED       ) etherP.strFuseF( tinBaseP , psttl , T(" raw exception code: ")+TF1(info.pcInfo[0])+T("\r\n") ) ;
                etherP.strFuseF( tinBaseP , psttl , T(processGlobal4I.mapExceptionType(info.idException))+T(" exception\r\n pvOffendingCode: ")+TF1((countT)info.pvOffendingCode)+T("\r\n") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ 0x10000 ) ; ___( psttl ) ;
                ZE( strokeS* , psttl ) ;
                tinBaseS& tinBase = *(tinBaseS*)info.pbTin ;

                tellInfoSysExceptionS& info = *(tellInfoSysExceptionS*)pbData ;

                if( head.cbData != sizeof( tellInfoSysExceptionS ) ) { BLAMMO ; }
            {
            case ifcIDtYPEtELLsYS_ERROReXCEPTION :
        {
        switch( head.idType )

        }
            etherP.memCopyF( tinBaseP , pbData , pbP + sizeof( tellS ) , head.cbData ) ;
            pbData[ head.cbData ] = 0 ;
        {
        if( pbData )
        etherP.newF( tinBaseP , LF , pbData , head.cbData + 1 ) ; ___( pbData ) ;
    {
    if( head.cbData )
    ZE( byteT* , pbData ) ;

    //if( head.idType != ifcIDtYPEtELLsYS_NOOP && ( head.idType > ifcIDtYPEtELLsYS_GRABdEP || head.idType < ifcIDtYPEtELLsYS_GRABcTI ) ) { CONoUTrAW( TF1(++idEat)+T("  ")+T(processGlobal4I.mapSay(head.idType))+T("\r\n") ) ; }

    __( cbP - sizeof head - head.cbData ) ;

    __( getNegAM( head.finger1 ) - ( FINGERnEG_TELEMETRY1 & 0xffffff00 ) ) ; //ASSUME HARDWARE: countT IS 4 BYTES
    tellS& head = *(tellS*)pbP ;

    bFrozenP = 0 ;
    }
        while( cFreezeP ) { ++ s ; thirdC::dosSleepIF( tinBaseP , TUCK * 0x40 ) ; }
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    {
    bFrozenP = 1 ;

    boolT&    bFrozenP    =     *(boolT*)c8p.c6 ;
    countT&   cFreezeP    =    *(countT*)c8p.c5 ;
    napkinC&  napLogP     = **(napkinC**)c8p.c4 ;
    stackC&   stTinWhereP =    *(stackC*)c8p.c3 ;
    stackC&   stTinP      =    *(stackC*)c8p.c2 ;
    stackC&   stGrabP     =    *(stackC*)c8p.c1 ;
    count8S&  c8p         = *(count8S*)cParmP ;
{
countT cirMonitorF( tinBaseS& tinBaseP , etherC& etherP , countT& cParmP , const byteT* const pbP , const countT cbP )

}
    return 0 ;
    if( ((tinNormalS&)tinBaseP).fingerprint && etherP && cParmP && pbP && cbP ) ;
    //CONoUTrAW( pbP ) ;
{
countT cirLogF( tinBaseS& tinBaseP , etherC& etherP , countT& cParmP , const byteT* const pbP , const countT cbP )

countT idEat ; //U::

DONE( tmRptF )
}
    bQuitMonitoring = 1 ;
    ((tinNormalS&)tinBaseP).pEtText = 0 ;
    ((tinNormalS&)tinBaseP).flagsThreadMode2 &= ~( F(flTHREADmODE2_DISALLOWgRAB) ) ;
    thirdC::third_flagsModeProcess1I_IF() |= flMODEpROCESS1_NOsYNCHRONOUStELLS ;
    }
        }
            while( !ether && cToDo -- ) thirdC::dosSleepIF( tinBaseP , TOCK ) ;
            countT cToDo = 0x1 ; //U::10
    
            CONoUTrAW( "R" ) ;
            //CONoUTrAW(T("report ")+TF1(idReport)+T(" written\r\n") ) ; //U::
            etThread.delF( tinBaseP , postr ) ;
            }
                BOSpOOP
                BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                BOSpOOP
                BOS( WHATgbo , BOSoK , WriteFile( osh , postr , costr , &cba , 0 ) )
                ZE( DWORD , cba ) ;
                HANDLE osh = (HANDLE)((tinNormalS&)tinBaseP).brcRaw ;
                BOSpOOP
                BOS( WHATgbo , BOShANDLE , CreateFile( ostoFile , GENERIC_WRITE , 0 , &sa , CREATE_ALWAYS , FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN , 0 ) )
                OStEXTAK( ostoFile , ".log.monitor" ) ;
                OStEXTC( ostoFile , etherC::ifc_idHomeI_IF() , 0 ) ;
                OStEXTAK( ostoFile , "\\ideafarm." ) ;
                OStEXT( ostoFile , 0x100 )
                BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                SECURITYaTTRIBUTE_saUNRESTRICTED( 0 ) ;
                POOPIES
            {
            etThread.delF( tinBaseP , psttr ) ;
            countT costr = etThread.strMakeF( tinBaseP , LF , postr , psttr ) ; ___( postr ) ;
            ZE( osTextT* , postr ) ;
    
            ) ;
    
                tb+T("see tinNormalS::strFuseF for a description of this report")+tc2
                tb+T("a thread is interesting if it is involved in a grab loop")+tc+
                tb+T("detailed list of \"interesting\" threads")+tc+
                T("[TD]")+tc+
                tb+T("thread: postThreadName: the name of the thread")+tc2+
                tb+T("pid: the raw process id")+tc+
                tb+T("osTid: the raw thread id")+tc+
                tb+T("a thread is interesting if it is involved in a grab loop")+tc+
                tb+T("summary list of \"interesting\" threads")+tc+
                T("[TS]")+tc+
                tb+T("(a grabOldS object that is viewed by multiple cells appears in this list only wo time)")+tc2+
                tb+T("pid: osPid: the raw process id of the cell that constructed this grabOldS object")+tc+
                tb+T("line: idLineCt: the source code line in that file that constructs this grabOldS object")+tc+
                tb+T("file: idiFileCt: the source code file that contains the code line that constructs this grabOldS object")+tc+
                tb+T("idSerial: the serial number of the grabOldS object")+tc+
                tb+T("a grabOldS is interesting if it is involved in a grab loop")+tc+
                tb+T("list of \"interesting\" grabOldS objects")+tc+
                T("[GS]")+tc+
                tb+T(" and each has a grabOldS object that another wants")+tc2+
                tb+T("(def) grab loop: a set of threads that are deadlocked because each has grabbed a grabOldS object that another wants,")+tc+
                tb+T("each of these multiline entries reports a \"grab loop\"")+tc+
                T("[GL]")+tc+
                tb+T("lists the grabOldS object views that are grabbed")+tc2+
                T("[GG]")+tc+
                tb+T("if 3 cells have opened a view to a grabOldS object that is grabbed, then that object contributes 3 to this tally")+tc2+
                tb+T("recursion does not affect the tallies reported here")+tc+
                tb+T("a thread that has grabbed a grabOldS can recursively grab that object (unless the grabOldS object is configured to disallow recursion)")+tc+
                tb+T("only wo thread at a time can grab a grabOldS object")+tc+
                T("[GT]")+tc+
                tb+T("(example) grabOldS object views: if there are 11 grabOldS objects, and wo of them can be seen by 3 cells, then there are 31 views")+tc2+
                tb+T("(def) grabOldS object views: this is the sum, over all grabOldS objects on the local host, of the number of cells that have opened a view of the grabOldS object")+tc+
                tb+T("some grabOldS objects can be viewed by multiple cells (processes) on the local host")+tc+
                tb+T("(please report all violations of this design specification)")+tc+
                tb+T("an ifc thread cannot stop (\"lock up\", \"hang\", etc.) without \"grabbing a grabOldS object\".")+tc+
                T("[RG]")+tc+
                tb+T("idSerialLath: The lath (highest) serial number obtained on this host (by any cell)")+tc2+
                T("[SL]")+tc+
                tb+T("group 01 is reserved for cells that fire other cells")+tc2+
                tb+T("group f is reserved for the monitor (the cell that writes this report)")+tc+
                tb+T("cells are assigned to group 5 unless specified otherwise in the adam definition")+tc+
                tb+T("cHeartBeats: each cell increments this until its main function returns")+tc+
                tb+T("gr: idFireAllGroup")+tc+
                T("[FA]")+tc+
                tb+T("idReport: the number of generations of this report written since the IdeaFarm " "(tm) Operating System was started on this computer")+tc2+
                tb+T("the time of the report is represented according to the customs of IdeaFarm " "(tm) City")+tc+
                tb+T("(\"01 tock\" means 16 (base 10) tocks, or approximately 30 seconds)")+tc+
                tb+T("(a tock is approximately 1.33 seconds")+tc+
                tb+T("Local Monitor Report: this report is written every 01 tock by the IdeaFarm " "(tm) Operating System")+tc+
                tb+T("these programs are called \"IdeaFarm " "(tm) Cells\"")+tc+
                tb+T("some programs on this computer are using the IdeaFarm " "(tm) Operating System")+tc+
                tb+T("IdeaFarm " "(tm) Operating System: runs \"on top of\" this computer's base operating system (e.g. MS Windows)")+tc+
                tb+T("for support, see http://www.ideafarm.com or call Wo'O Ideafarm US 650-759-5306")+tc+
                T("[ID]")+tc+
                TPS(" \r\nexplanatory notes ",0x40,S1C('-'))+tc2+
    
            etThread.strFuseF( tinBaseP , psttr ,
        
            cFreeze -- ; // stGrab stTin MUST NOT BE REFERENCED AFTER THIS
            }
                stChecked.purgeF( tinBaseP ) ;
                stWanters.purgeF( tinBaseP ) ;
                stGrabbed.purgeF( tinBaseP ) ;
                }
                    while( !stGrabbed.third && ~hDown ) ;
                    }
                        etThread.delF( tinBaseP , entry.pbCopy ) ;
                        grabEntryS& entry = *(grabEntryS*)&stGrabbed.downF( tinBaseP , hDown ) ;
                    {
                    do
                    handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stGrabbed )
    
                stOsTidLooped.purgeF( tinBaseP ) ;
    
                }
                    while( !stTin.third && ~hDown ) ;
                    }
                        etThread.delF( tinBaseP , entry.pbCopy ) ;
                        tinEntryS& entry = *(tinEntryS*)&stTin.downF( tinBaseP , hDown ) ;
                    {
                    do
                    handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stTin )
    
                }
                    while( !stTin.third && ~hDown ) ;
                    }
                        }
                            }
                                tin.strFuseF( tinBaseP , etThread , psttr , 0 , flTINrPT1_null , flTINrPT2_null , flTINrPT1_pLFstepAll ) ;
                                etThread.strFuseF( tinBaseP , psttr , T(" \r\n[TD]\r\n") ) ;
                            {
                            if( !tin.monitor.cNewSteps || stOsTidLooped( tin.osTid ) )
                            tinBaseS& tinBase = *(tinBaseS*)entry.pbCopy ;
                        {
                        if( entry.pbCopy )
    
                        tinEntryS& entry = *(tinEntryS*)&stTin.downF( tinBaseP , hDown ) ;
                    {
                    do
                    handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stTin )
    
                }
                    while( !stTin.third && ~hDown ) ;
                    }
                        }
                            }
                                if( !tin.monitor.cNewSteps || stOsTidLooped( tin.osTid ) ) etThread.strFuseF( tinBaseP , psttr , TF3(tin.osTid,flFORMAT_UNSIGNED,9)+TF3(tin.osPid,flFORMAT_UNSIGNED,9)+T("\"")+T(tin.postThreadName)+T("\"\r\n") ) ;
                                tinBaseS& tinBase = *pCopy ;
    
                                etThread.memCopyF( tinBaseP , entry.pbCopy , pbCopy , sizeof pbCopy ) ;
                                etThread.newF( tinBaseP , LF , entry.pbCopy , sizeof pbCopy ) ; ___( entry.pbCopy ) ;
                            {
                            if( pCopy ) // pCopy IS EITHER 0 OR A VALID IMAGE OF A tinNormalS
        
                            }
                                }
                                    if( !bOk || getNegAM( pc2[ 0 ] ) != FINGERnEG_TINs || entry.idSerial != pc2[ 1 ] ) pCopy = 0 ;
                                    thirdC::dosReadProcessMemoryIF( tinBaseP , (byteT*)pc2 , sizeof pc2 , bOk , (voidT*)entry.ip , entry.osPid ) ;
                                    bOk = 0 ;
                                    countT pc2[ 2 ] ; //CODE SYNC: ad40104 003002a: fingerprint idSerial MUST BE AT OFFSETS 0 4
                                {
                                else
                                if( !bOk || getNegAM( pCopy->fingerprint ) != FINGERnEG_TINs || entry.idSerial != pCopy->idSerial ) pCopy = 0 ;
                                thirdC::dosReadProcessMemoryIF( tinBaseP , pbCopy , sizeof( tinNormalS ) , bOk , (voidT*)entry.ip , entry.osPid ) ;
                                ZE( boolT , bOk ) ;
                            {
                            else
                            }
                                if( getNegAM( pCopy->fingerprint ) != FINGERnEG_TINs || entry.idSerial != pCopy->idSerial ) pCopy = 0 ;
                                etThread.memCopyF( tinBaseP , pbCopy , (byteT*)pCopyI , sizeof( tinNormalS ) ) ;
                                tinBaseS* pCopyI = (tinBaseS*)(byteT*)ap_artmentOldC( tinBaseP , entry.ip ) ;
                            {
                            if( entry.bIda )
                            tinBaseS* pCopy = (tinBaseS*)pbCopy ;
                            byteT pbCopy[ sizeof( tinNormalS ) ] ;
                        {
                        else
                        if( entry.pbCopy ) { BLAMMO ; }
    
                        tinEntryS& entry = *(tinEntryS*)&stTin.downF( tinBaseP , hDown ) ;
                    {
                    do
                    handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stTin )
    
                }
                    while( !stTin.third && ~hDown ) ;
                    }
                        }
                            }
                                //CONoUTrAW( T(entry.postThreadName)+T(": ")+T(monitor.mStepsPerTuck)+T("\r\n") ) ; //U::
                                thirdC::dosWriteProcessMemoryIF( tinBaseP , countTC() , (voidT*)( entry.ip + ( (byteT*)&((tinNormalS&)tinBaseP).monitor - (byteT*)&tinBaseP ) ) , entry.osPid , (byteT*)&monitor , sizeof monitor ) ;
                                stampF( tinBaseP , etThread , monitor , idStep ) ;
                                monitorOldS& monitor = *(monitorOldS*)( &idStep + 1 ) ;
                                countT&   idStep  = *(countT*)pbCopy ;
                            {
                            if( bOk )
                            thirdC::dosReadProcessMemoryIF( tinBaseP , pbCopy , sizeof pbCopy , bOk , (voidT*)( entry.ip + ( (byteT*)&((tinNormalS&)tinBaseP).monitor.idStep - (byteT*)&tinBaseP ) ) , entry.osPid ) ;
                            ZE( boolT , bOk ) ;
                            byteT pbCopy[ sizeof( countT ) + sizeof( monitorOldS ) ] ;
                        {
                        else
                        }
                            //CONoUTrAW( T(entry.postThreadName)+T(": ")+T(monitor.mStepsPerTuck)+T("\r\n") ) ; //U::
                            stampF( tinBaseP , etThread , monitor , idStep ) ;
                            monitorOldS& monitor = *(monitorOldS*)( &idStep + 1 ) ;
                            countT&   idStep  = *(countT*)( (byteT*)ap_artmentOldC( tinBaseP , entry.ip ) + ( (byteT*)&((tinNormalS&)tinBaseP).monitor.idStep - (byteT*)&tinBaseP ) ) ;
                        {
                        if( entry.bIda )
    
                        tinEntryS& entry = *(tinEntryS*)&stTin.downF( tinBaseP , hDown ) ;
                    {
                    do
                    handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stTin )
    
                etThread.strFuseF( tinBaseP , psttr , T(" \r\n[TS]\r\n")+TPS("osTid",8,sttu)+T(" ")+TPS("pid",8,sttu)+T(" ")+TPS("thread",0x20,sttu)+T("\r\n") ) ;
    
                }
                    etThread.delF( tinBaseP , pbEntry ) ;
                    }
                        etThread.strFuseF( tinBaseP , psttr , TF3(entry.idSerial,flFORMAT_UNSIGNED,9)+TF3(entry.idiFileCt,flFORMAT_UNSIGNED,9)+TF3(entry.idLineCt,flFORMAT_UNSIGNED,9)+TF3(entry.osPid,flFORMAT_UNSIGNED,9)+T("\r\n") ) ;
                        grabEntryS& entry = *(grabEntryS*)pbEntry ;
                    {
                    if( pbEntry )
                    stLooped >> pbEntry ;
                    ZE( byteT* , pbEntry ) ;
                {
                while( stLooped )
                etThread.strFuseF( tinBaseP , psttr , T(" \r\n[GS]\r\n")+TPS("idSerial",8,sttu)+T(" ")+TPS("file",8,sttu)+T(" ")+TPS("line",8,sttu)+T(" ")+TPS("pid",8,sttu)+T("\r\n") ) ;
                strokeS sttu('-') ;
    
                }
                    while( !stGrabbed.third && ~hDown ) ;
                    }
                        }
                            }
                                stOsTidLooped.sinkF( tinBaseP , countTC() , osTid , flSTACKsINK_UNIQUE ) ;
                                stOsTidLoopedTmp >> osTid ;
                                ZE( countT , osTid ) ;
                            {
                            while( stOsTidLoopedTmp )
    
                            }
                                stLooped.sinkF( tinBaseP , countTC() , (byteT*)pEntry , flSTACKsINK_UNIQUE , subtract_grabEntryS_F ) ;
                                stLoopedTmp >> *(countT*)&pEntry ;
                                ZE( grabEntryS* , pEntry ) ;
                            {
                            while( stLoopedTmp )
                        {
                        else
                        }
                            stOsTidLoopedTmp.purgeF( tinBaseP ) ;
                            stLoopedTmp.purgeF( tinBaseP ) ;
                        {
                        if( !bLoop )
    
                        stWanters.purgeF( tinBaseP ) ;
                        stChecked.sinkF( tinBaseP , countTC() , entry.idSerial , flSTACKsINK_UNIQUE ) ;
    
                        etThread.delF( tinBaseP , psttrTmp ) ;
                        if( bLoop ) etThread.strFuseF( tinBaseP , psttr , psttrTmp ) ;
                        boolT bLoop = wantersF( tinBaseP , etThread , stWanters , psttrTmp , entry , hoodWant , stGrabbed , stChecked , stLoopedTmp , stOsTidLoopedTmp , cIndent ) ;
                        etThread.strFuseF( tinBaseP ,psttrTmp , T(" \r\n[GL]\r\n") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ 0x10000 ) ; ___( psttrTmp ) ;
                        ZE( strokeS* , psttrTmp ) ;
                        ZE( countT , cIndent ) ;
                        grabEntryS& entry = *(grabEntryS*)&stGrabbed.downF( tinBaseP , hDown ) ;
                    {
                    do
                    handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    etThread.strFuseF( tinBaseP , psttr , T("[GT] ")+TF1(stGrabbed)+T(" grabOldS object views are grabbed\r\n \r\n") ) ;
                {
                if( stGrabbed )
    
                }
                    while( !stGrab.third && ~hDown ) ;
                    }
                        }
                            stGrabbed << (byteT*)&entry ;
                            etThread.memCopyF( tinBaseP , entry.pbCopy , (byteT*)pCopy , sizeof( grabOldS ) ) ;
                            etThread.newF( tinBaseP , LF , entry.pbCopy , sizeof( grabOldS ) ) ; ___( entry.pbCopy ) ;
                        {
                        if( pCopy && pCopy->scGrab ) // pCopy IS EITHER 0 OR A VALID IMAGE OF A grabOldS
    
                        }
                            }
                                if( !bOk || pCopy2->fingerprint != FINGERnEG_grabOldS || entry.idSerial != pCopy2->idSerial ) pCopy = 0 ;
                                thirdC::dosReadProcessMemoryIF( tinBaseP , pbCopy2 , sizeof( grabOldS ) , bOk , (voidT*)entry.ip , entry.osPid ) ;
                                bOk = 0 ;
                                grabOldS* pCopy2 = (grabOldS*)pbCopy2 ;
                                byteT pbCopy2[ sizeof( grabOldS ) ] ;
                            {
                            else
                            if( !bOk || pCopy->fingerprint != FINGERnEG_grabOldS || entry.idSerial != pCopy->idSerial ) pCopy = 0 ;
                            thirdC::dosReadProcessMemoryIF( tinBaseP , pbCopy , sizeof( grabOldS ) , bOk , (voidT*)entry.ip , entry.osPid ) ;
                            ZE( boolT , bOk ) ;
                        {
                        else
                        }
                            }
                                if( pCopyI->fingerprint != FINGERnEG_grabOldS || entry.idSerial != pCopyI->idSerial ) pCopy = 0 ;
                                etThread.memCopyF( tinBaseP , pbCopy , (byteT*)pCopyI , sizeof( grabOldS ) ) ;
                            {
                            if( pCopyI->fingerprint == FINGERnEG_grabOldS && entry.idSerial == pCopyI->idSerial )
                            grabOldS* pCopyI = (grabOldS*)(byteT*)ap_artmentOldC( tinBaseP , entry.ip ) ;
                        {
                        if( entry.bIda )
                        grabOldS* pCopy = (grabOldS*)pbCopy ;
                        byteT pbCopy[ sizeof( grabOldS ) ] ;
    
                        grabEntryS& entry = *(grabEntryS*)&stGrab.downF( tinBaseP , hDown ) ;
                    {
                    do
                    handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stGrab )
        
                etThread.strFuseF( tinBaseP , psttr , T(" \r\n[RG] ")+TF1(stGrab)+T(" grabOldS object views are registered\r\n \r\n") ) ;
            {
        
            etThread.strFuseF( tinBaseP , psttr , T(" \r\n[SL] idSerialLath: ")+TF1(host.idSerialLath)+T("\r\n") ) ;
        
                etThread.strFuseF( tinBaseP , psttr , TF3(off+1,flFORMAT_UNSIGNED,3)+TF1(pfa[ off ].cHeartBeats )+T("\r\n") ) ;
            for( countT off = 0 ; off < CfIREaLLrANKS ; off ++ )
        
            etThread.strMakeF( tinBaseP , LF , psttr , T("[ID]\r\nIdeaFarm " "(tm) Operating System\r\nLocal Monitor Report\r\n(see the explanatory notes at the end of this report)\r\n")+TT(timeN1,timeN2)+T("\r\nidReport: ")+TF1(idReport)+T("\r\n \r\n[FA]\r\ngr cHeartBeats\r\n") , 0x100000 ) ; ___( psttr ) ;
            ZE( strokeS* , psttr ) ;

            }
                etThread.delF( tinBaseP , pbCircle ) ;
                writeLogF( tinBaseP , etThread , pbCircle + offBegin , cbCircle - offBegin , ++ idReport , timeN1 , timeN2 ) ;
                etThread.etherSnapCyrcleOldF( tinBaseP , pbCircle , cbCircle , offBegin , pNapLog , T(POSTlOG) , CBlOG ) ;
                ZE( countT , offBegin ) ;
                ZE( countT , cbCircle ) ;
                ZE( byteT* , pbCircle ) ;
                __Z( pNapLog ) ;
            {
            if( pNapLog )

            }
                if( bDone_tmLogF ) { DEL( pNapLog ) ; }
                bQuitLogging = 1 ;
            {
            if( pNapLog && etherC::os_cAllKidThreadsI_IF( tinBaseP ) < 5 )
    
            etThread.osTimeNowF( tinBaseP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
    
            }
                if( !bFrozen ) { CONoUTrAW( "warning: cirMonitorF is not frozen, or is frozen at an unknown code location\r\n" ) ; }
                while( !bFrozen && cTries -- ) thirdC::dosSleepIF( tinBaseP , TUCK * 0x40 ) ;
                countT cTries = 0x10 ;
            {
            if( !bFrozen )
            thirdC::dosSleepIF( tinBaseP , TOCK ) ;
            cFreeze ++ ;
        {
        while( !etThread && etherC::os_cAllKidThreadsI_IF( tinBaseP ) > 3 ) //THIS WORKS BECAUSE tmTimeNowF EXISTS UNTIL I AM FIRED; THE 3 KID THREADS EXPECTED TO HANG AROUND: watch, tell, rpt
    {
    ((tinNormalS&)tinBaseP).pEtText = &etThread ;
    ((tinNormalS&)tinBaseP).flagsThreadMode2 |= flTHREADmODE2_DISALLOWgRAB ;
    ZE( countT , idStepReporterLath ) ;
    boolT bWoth = 1 ;
    TN( tFile , "///d/ideafarm.rpt.monitor" ) ;
    ZE( countT , idReport ) ;
    hoodC hoodWant( tinBaseP , "grabOldS.hoodWant" , sizeof( grabWantOldS ) , 0x10000 ) ; //CODE SYNC: ad40104 0a00001

    thirdC::dosPriorityIF( tinBaseP , idDesireSave ) ;
    thirdC::dosPriorityIF( tinBaseP , ifcTHREADpRIORITY_RUSH ) ;
    const countT idDesireSave = ((tinNormalS&)tinBaseP).idDesireSetBySelf ;
    U::ALL CODE THAT CALLS thugC::grabF MUST BE RUSH

    strokeS sd( '-' ) ;
    TN( tb , " " ) ;
    TN( tc2 , "\r\n \r\n" ) ;
    TN( tc , "\r\n" ) ;
    fireAllS* pfa = (fireAllS*)( pcn + 2 ) ;
    CTnAPfIREaLL

    homeS& host = homeS::homeIF() ;

    boolT&    bFrozen          =    *(boolT*)c8p2.c7 ;
    countT&   cFreeze          =   *(countT*)c8p2.c6 ;
    boolT&    bDone_tmLogF     =    *(boolT*)c8p2.c5 ;
    boolT&    bQuitMonitoring  =    *(boolT*)c8p2.c4 ;
    boolT&    bQuitLogging     =    *(boolT*)c8p2.c3 ;
    napkinC*& pNapLog          = *(napkinC**)c8p2.c2 ;
    stackC&   stTin            =   *(stackC*)c8p2.c1 ;
    stackC&   stOsTidLooped    =   *(stackC*)c8p1.c8 ;
    stackC&   stOsTidLoopedTmp =   *(stackC*)c8p1.c7 ;
    stackC&   stLooped         =   *(stackC*)c8p1.c6 ;
    stackC&   stLoopedTmp      =   *(stackC*)c8p1.c5 ;
    stackC&   stChecked        =   *(stackC*)c8p1.c4 ;
    stackC&   stWanters        =   *(stackC*)c8p1.c3 ;
    stackC&   stGrabbed        =   *(stackC*)c8p1.c2 ;
    stackC&   stGrab           =   *(stackC*)c8p1.c1 ;

    count8S&    c8p2      = *(count8S*)pTaskP->c2 ; // THERE ARE 2 tmRptF THREADS: THE NORMAL WO AND THE "WATCHDOG"
    count8S&    c8p1      = *(count8S*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmRptF )

}
    }
        mP.mStepsPerTuck = timeDelta2 ? 0.0 : (measureT)mP.cNewSteps * TUCK / timeDelta1 ;
        etThread.osTimeSubtractF( tinBaseP , timeDelta1 , timeDelta2 , timeOld1 , timeOld2 ) ;
        sCountT timeDelta2 = mP.time2 ;
        countT  timeDelta1 = mP.time1 ;
    {
    if( timeOld1 || timeOld2 )

    mP.cNewSteps = mP.idStepLast - idStepLastOld ;

    countT idStepLastOld = mP.idStepLast ; mP.idStepLast = idStepP ;

    etThread.osTimeNowF( tinBaseP , mP.time1 , mP.time2 ) ;
    sCountT timeOld2 = mP.time2 ; mP.time2 = 0 ;
    countT  timeOld1 = mP.time1 ; mP.time1 = 0 ;

    mP.idMonitorTock ++ ;
    mP.idMonitor = 1 ;
{
voidT stampF( tinBaseS& tinBaseP , etherC& etThread , monitorOldS& mP , countT idStepP )

}
    etThread.delF( tinBaseP , postl ) ;
    }
        BOSpOOP
        BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
        BOSpOOP
        BOS( WHATgbo , BOSoK , WriteFile( osh , postl , costl , &cba , 0 ) )
        ZE( DWORD , cba ) ;
        HANDLE osh = (HANDLE)((tinNormalS&)tinBaseP).brcRaw ;
        BOSpOOP
        BOS( WHATgbo , BOShANDLE , CreateFile( ostoFile , GENERIC_WRITE , 0 , &sa , CREATE_ALWAYS , FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN , 0 ) )
        OStEXTAK( ostoFile , ".log.monitor" ) ;
        OStEXTC( ostoFile , etherC::ifc_idHomeI_IF() , 0 ) ;
        OStEXTAK( ostoFile , "\\ideafarm." ) ;
        OStEXT( ostoFile , 0x100 )

        BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
        SECURITYaTTRIBUTE_saUNRESTRICTED( 0 ) ;
        POOPIES
    {
    etThread.delF( tinBaseP , psttl ) ;
    countT costl = etThread.strMakeF( tinBaseP , LF , postl , psttl ) ; ___( postl ) ;
    ZE( osTextT* , postl ) ;

    ) ;

        tb+T("(the most recent text is at the end of this section")+tc2
        tb+T("the text written most recently to the circular log buffer")+tc+
        T("[LO]")+tc+
        tb+T("idReport: the number of generations of this report written since the IdeaFarm " "(tm) Operating System was started on this computer")+tc2+
        tb+T("the time of the report is represented according to the customs of IdeaFarm " "(tm) City")+tc+
        tb+T("(\"01 tock\" means 16 (base 10) tocks, or approximately 30 seconds)")+tc+
        tb+T("(a tock is approximately 1.33 seconds")+tc+
        tb+T("Local Monitor Log: this report is written every 01 tock by the IdeaFarm " "(tm) Operating System")+tc+
        tb+T("these programs are called \"IdeaFarm " "(tm) Cells\"")+tc+
        tb+T("some programs on this computer are using the IdeaFarm " "(tm) Operating System")+tc+
        tb+T("IdeaFarm " "(tm) Operating System: runs \"on top of\" this computer's base operating system (e.g. MS Windows)")+tc+
        tb+T("for support, see http://www.ideafarm.com or call Wo'O Ideafarm US 650-759-5306")+tc+
        T("[ID]")+tc+
        TPS(" \r\nexplanatory notes ",0x40,S1C('-'))+tc2+

    etThread.strFuseF( tinBaseP , psttl ,
    TN( tb , " " ) ;
    TN( tc2 , "\r\n \r\n" ) ;
    TN( tc , "\r\n" ) ;
    
    if( pbc != pbe ) { BLAMMO ; }
    }
        etThread.strFuseF( tinBaseP , psttl , T(pbData) ) ;

        }
            BLAMMO ;
        {
        if( cbDataVerify != cbData )

        countT&            cbDataVerify = *(countT*)pbc ; pbc += sizeof( countT ) ;
        const byteT* const pbData       =           pbc ; pbc += cbData ;
        countT&            cbData       = *(countT*)pbc ; pbc += sizeof( countT ) ;
    {
    while( pbc < pbe )
    etThread.strFuseF( tinBaseP , psttl , T("[ID]\r\nIdeaFarm " "(tm) Operating System\r\nLocal Monitor Log\r\n[see the explanatory notes at the end of this report]\r\n")+TT(timeN1P,timeN2P)+T("\r\nidReport: ")+TF1(idReportP)+T("\r\n \r\n[LO]\r\n") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ cbCyrcleOldP + 0x1000 /*TITLE + EXPLANATORY NOTES*/ ) ;
    ZE( strokeS* , psttl ) ;

    const byteT* const pbe = pbCircleP + cbCyrcleOldP ;
    const byteT*       pbc = pbCircleP ;
{
voidT writeLogF( tinBaseS& tinBaseP , etherC& etThread , const byteT* const pbCircleP , const countT cbCyrcleOldP , const countT idReportP , const countT timeN1P , const sCountT timeN2P )

}
    return sgn ;
    if( ((tinNormalS&)tinBaseP).fingerprint && c3P ) ;

    }                       
        else if( pe1->ip       < pe2->ip       ) sgn = - 1 ;
        else if( pe1->ip       > pe2->ip       ) sgn =   1 ;
        else if( pe1->bIda     < pe2->bIda     ) sgn = - 1 ;
        else if( pe1->bIda     > pe2->bIda     ) sgn =   1 ;
        else if( pe1->osPid    < pe2->osPid    ) sgn = - 1 ;
        else if( pe1->osPid    > pe2->osPid    ) sgn =   1 ;
        else if( pe1->idSerial < pe2->idSerial ) sgn = - 1 ;
             if( pe1->idSerial > pe2->idSerial ) sgn =   1 ;
    {
    if( pe1 && pe2 )
    ZE( sCountT , sgn ) ;

    tinEntryS* pe2 = (tinEntryS*)c2P ;
    tinEntryS* pe1 = (tinEntryS*)c1P ;

    }
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )

    }
    {
    IFbEcAREFUL
{
countT subtract_tinEntryS_F( tinBaseS& tinBaseP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return - sgn ; // HIGHEST TALLY IS "LIGHTEST"
    if( ((tinNormalS&)tinBaseP).fingerprint && c3P ) ;

    }                       
        else if( pc1->c2 > pc2->c2 ) sgn = - 1 ;
        else if( pc1->c2 < pc2->c2 ) sgn =   1 ; // LOWEST idf (LOWEST LEVER VALUE) IS LIGHTEST
        else if( pc1->c1 < pc2->c1 ) sgn = - 1 ;
             if( pc1->c1 > pc2->c1 ) sgn =   1 ;
    {
    if( pc1 && pc2 )
    ZE( sCountT , sgn ) ;

    count2S* pc2 = (count2S*)c2P ;
    count2S* pc1 = (count2S*)c1P ;

    }
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )

    }
    {
    IFbEcAREFUL
{
countT subtractTallyF( tinBaseS& tinBaseP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return sgn ;
    if( ((tinNormalS&)tinBaseP).fingerprint && c3P ) ;

    }                       
        else if( pe1->ip       < pe2->ip       ) sgn = - 1 ;
        else if( pe1->ip       > pe2->ip       ) sgn =   1 ;
        else if( pe1->bIda     < pe2->bIda     ) sgn = - 1 ;
        else if( pe1->bIda     > pe2->bIda     ) sgn =   1 ;
        else if( pe1->osPid    < pe2->osPid    ) sgn = - 1 ;
        else if( pe1->osPid    > pe2->osPid    ) sgn =   1 ;
        else if( pe1->idSerial < pe2->idSerial ) sgn = - 1 ;
             if( pe1->idSerial > pe2->idSerial ) sgn =   1 ;
    {
    if( pe1 && pe2 )
    ZE( sCountT , sgn ) ;

    grabEntryS* pe2 = (grabEntryS*)c2P ;
    grabEntryS* pe1 = (grabEntryS*)c1P ;

    }
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )

    }
    {
    IFbEcAREFUL
{
countT subtract_grabEntryS_F( tinBaseS& tinBaseP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    return bLoop ;

    }
        cIndentP -- ;
        }
            }
                }
                    }
                        while( !stGrabbedP.third && ~hDown ) ;
                        }
                            }
                                stCheckedP.sinkF( tinBaseP , countTC() , entry.idSerial , flSTACKsINK_UNIQUE ) ;
    
                                cIndentP -- ;
                                bLoop = wantersF( tinBaseP , etThread , stWantersP , psttrP , entry , hoodWantP , stGrabbedP , stCheckedP , stLoopedTmpP , stOsTidLoopedTmpP , cIndentP ) ;
                                cIndentP ++ ;
                            {
                            if( bWant )
                
                            }
                                if( copy.osTidHave == osTidWant ) bWant = 1 ;
                                grabOldS& copy = *(grabOldS*)entry.pbCopy ;
                            {
                            else if( entry.pbCopy )
                            }
                                if( pFrom && pFrom->osTidHave == osTidWant ) bWant = 1 ;
                                grabOldS* pFrom = (grabOldS*)(byteT*)ap_artmentOldC( tinBaseP , entry.ip ) ;
                            {
                            if( entry.bIda )
                            grabEntryS& entry = *(grabEntryS*)&stGrabbedP.downF( tinBaseP , hDown ) ;
                            ZE( boolT , bWant ) ;
                        {
                        do
                        handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( stGrabbedP )
                    //RECURSIVELY CALL MYSELF FOR EACH ENTRY THAT osTidWant HAS, TO GET THE INDIRECT WANTERS
        
                    pThugMe = pThugKid ;
                    //pThugMe->ungrabF() ;
                    //if( pThugKid ) pThugKid->grabF() ;
                    thugC* pThugKid = pThugMe->pKidF() ;
                
                    etThread.strFuseF( tinBaseP , psttrP , TP("",cIndentP)+T("wanted by ")+TF1(osTidWant)+T("\r\n") ) ;
                {
                else
                }
                    //pThugMe->ungrabF() ;
                    etThread.strFuseF( tinBaseP , psttrP , TP("",cIndentP)+T("**** LOOP! ****\r\n") ) ;
                    bLoop = 1 ;
                {
                if( !ids )
                stWantersP.sinkF( tinBaseP , ids , osTidWant , flSTACKsINK_UNIQUE ) ;
                ZE( countT , ids ) ;
                stOsTidLoopedTmpP << osTidWant ;
            {
            else
            if( !osTidWant ) break ; // hoodWant IS VOLATILE
            countT osTidWant = ( (grabWantOldS*)&pThugMe[ 1 ] )->osTid ;
        {
        while( pThugMe && !bLoop )
        thugC* pThugMe = pThugRoot ;
        etThread.strFuseF( tinBaseP , psttrP , TP("",cIndentP++)+TF1(entryP.idSerial)+T(" grabbed by ")+TF1(osTidHave)+T("\r\n") ) ;
            
        //if( pThugRoot ) pThugRoot->grabF() ;
        thugC* pThugRoot = !idThugRoot ? 0 : hoodWantP[ idThugRoot - 1 ] ;
            
        //etThread.strFuseF( tinBaseP , psttrP , TP("",cIndentP)+T("grabOldS  pv grabbed: ")+TF1(entryP.idSerial)+T(" ")+TF1(entryP.osPid)+T(" ")+TF1(entryP.bIda)+T(" ")+TF1(entryP.ip)+T(" ")+TF1(entryP.idLineCt)+T(" ")+TF1(entryP.idiFileCt)+T(" ")+T("\r\n") ) ;
        countT osTidHave = copy.osTidHave ;
        countT idThugRoot = copy.idThugWant ;
        if( !copy.scGrab ) { BLAMMO ; }
        grabOldS& copy = *(grabOldS*)entryP.pbCopy ;
        if( !entryP.pbCopy ) { BLAMMO ; }

        stLoopedTmpP << (countT)&entryP ;
    {
    if( !stCheckedP( entryP.idSerial ) )
    ZE( boolT , bLoop ) ;
{
boolT wantersF( tinBaseS& tinBaseP , etherC& etThread , stackC& stWantersP , strokeS*& psttrP , grabEntryS& entryP , hoodC& hoodWantP , stackC& stGrabbedP , stackC& stCheckedP , stackC& stLoopedTmpP , stackC& stOsTidLoopedTmpP , countT& cIndentP )

DONE( tmWantF )
}
    }
        }
            break ;
            grabF( tinBaseP , grabA ) ;
            etThread.osSleepF( tinBaseP , TOCK ) ;
            grabF( tinBaseP , grabC ) ;
        {
        case 3 :
        }
            break ;
            grabF( tinBaseP , grabC ) ;
            etThread.osSleepF( tinBaseP , TOCK ) ;
            grabF( tinBaseP , grabB ) ;
        {
        case 2 :
        }
            break ;
            grabF( tinBaseP , grabB ) ;
            etThread.osSleepF( tinBaseP , TOCK ) ;
            grabF( tinBaseP , grabA ) ;
        {
        case 1 :
    {
    switch( idGrabber )

    grabOldS& grabC     = *(grabOldS*)pTaskP->c4 ;
    grabOldS& grabB     = *(grabOldS*)pTaskP->c3 ;
    grabOldS& grabA     = *(grabOldS*)pTaskP->c2 ;
    countT idGrabber =          pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmWantF )

DONE( tmRawSleepF )
OSsLEEPf( 0x10000 ) ;
TASK( tmRawSleepF )

}
    thirdC::c_strncpyIF( tinBaseP , postThreadName , postThreadNameP , sizeof postThreadName ) ;
{
idThread( idThreadP )
idTin( idTinP ) ,
pbCopy( 0 ) ,
ip( ipP ) ,
bIda( bIdaP ) ,
osPid( osPidP ) ,
idSerial( idSerialP ) ,
tinEntryS::tinEntryS( tinBaseS& tinBaseP , countT idSerialP , countT osPidP , boolT bIdaP , countT ipP , countT idTinP , countT idThreadP , const osTextT* const postThreadNameP ) :

}
{
idiFileCt( idiFileCtP )
idLineCt( idLineCtP ) ,
pbCopy( 0 ) ,
ip( ipP ) ,
bIda( bIdaP ) ,
osPid( osPidP ) ,
idSerial( idSerialP ) ,
grabEntryS::grabEntryS( tinBaseS& tinBaseP , countT idSerialP , countT osPidP , boolT bIdaP , countT ipP , countT idLineCtP , countT idiFileCtP ) :

;
}
    tinEntryS( tinBaseS& tinBaseP , countT idSerialP , countT osPidP , boolT bIdaP , countT ipP , countT idTinP , countT idThreadP , const osTextT* const postThreadNameP ) ;

    osTextT postThreadName[ COSTmAXtHREADnAME + 1 ] ;
    countT idThread ;
    countT idTin ;
    byteT* pbCopy ;
    countT ip ;
    boolT  bIda ;
    countT osPid ;
    countT idSerial ;
{
struct tinEntryS

;
}
    voidT logF( tinBaseS& tinBaseP , const boolT bDieP = 0 ) ;
    grabEntryS( tinBaseS& tinBaseP , countT idSerialP , countT osPidP , boolT bIdaP , countT ipP , countT idLineCtP , countT idiFileCtP ) ;

    countT idiFileCt ;
    countT idLineCt ;
    byteT* pbCopy ;
    countT ip ;
    boolT  bIda ;
    countT osPid ;
    countT idSerial ;
{
struct grabEntryS

#define CBlOG 0x10000
#define POSTlOG "napLog"

/*1*/WAKEhIDE( "ifcIDaDAMoLD_CELLmONITOR.craft.monitor.read" )/*1*/
/**/
*/
i read the monitor circle and the log circle 
i must be alive whenever another cell is alive on the local host
i am designed to be the woth cell hired on each host
like 9d4 but i know when i am looking at a length prefix
obsoleted by 2e40104
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

