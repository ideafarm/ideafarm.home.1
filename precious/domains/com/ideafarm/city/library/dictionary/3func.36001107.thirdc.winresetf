
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    DECoShANDLES
    BOS( WHATsww , BOSoK , DeleteObject( hbrush ) )
    DECoShANDLES
    BOS( WHATsww , BOSoK , DeleteObject( hpen ) )
    BOSdOnOTtEST( WHATgbo , SelectObject( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , hbrusho ) ) //U::DEVELOP ERROR CHECKING THAT WILL WORK FOR SelectObject
    BOSdOnOTtEST( WHATgbo , SelectObject( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , hpeno ) ) //U::DEVELOP ERROR CHECKING THAT WILL WORK FOR SelectObject
    
    winSetPaintTypeF( tin0P , hDrawP ) ;
    
    //}
    //    paperP.mIdRow = mIdRowSave ;
    //    paperP.mIdCol = mIdColSave ;
    //
    //    //winLineF( tin0P , wP , wP.mColsF() , wP.mRowsF() ) ;
    //    //winMoveF( tin0P , wP ) ;
    //    //paperP.mIdCol = paperP.mIdRow = 1 ;
    //
    //    winDrawTextF( tin0P , wP , countTC() , countTC() , tn , tn.csF( tin0P ) ) ;
    //    winMoveF( tin0P , wP ) ;
    //    paperP.mIdRow = wP.mRowsF() - crt ;
    //    paperP.mIdCol = 1 ;
    //
    //    winDrawTextF( tin0P , wP , countTC() , countTC() , tn , tn.csF( tin0P ) ) ;
    //    winMoveF( tin0P , wP ) ;
    //    paperP.mIdRow = wP.mRowsF() - crt ;
    //    paperP.mIdCol = wP.mColsF() - cct ;
    //
    //    winDrawTextF( tin0P , wP , countTC() , countTC() , tn , tn.csF( tin0P ) ) ;
    //    winMoveF( tin0P , wP ) ;
    //    paperP.mIdRow = 1 ;
    //    paperP.mIdCol = wP.mColsF() - cct ;
    //
    //    winDrawTextF( tin0P , wP , cct , crt , tn , tn.csF( tin0P ) ) ;
    //    ZE( countT , crt ) ;
    //    ZE( countT , cct ) ;
    //    winMoveF( tin0P , wP ) ;
    //    paperP.mIdRow = 1 ;
    //    paperP.mIdCol = 1 ;
    //
    //    TN( tn , "" ) ; tn = TF1(idErase) ;
    //    countT idErase = &wP == p WinRoot ? 1 + incv02AM( idEraseLath ) : 0 ;
    //    static countT idEraseLath ;
    //    const measureT mIdRowSave = paperP.mIdRow ;
    //    const measureT mIdColSave = paperP.mIdCol ;
    //
    //    //winMoveF( tin0P , wP ) ;
    //    //paperP.mIdRow = wP.mRowsF() / 2 ;
    //    //paperP.mIdCol = wP.mColsF() / 2 ;
    //
    //    //winLineF( tin0P , wP , mColMin , mRowMin ) ;
    //    //winLineF( tin0P , wP , mColMin , mRowMax ) ;
    //    //winLineF( tin0P , wP , mColMax , mRowMax ) ;
    //    //winLineF( tin0P , wP , mColMax , mRowMin ) ;
    //    //winMoveF( tin0P , wP ) ;
    //    //paperP.mIdRow = mRowMin ;
    //    //paperP.mIdCol = mColMin ;
    //    //measureT mRowMax = wP.mRowsF() / 2 + 0x20 ;
    //    //measureT mColMax = wP.mColsF() / 2 + 0x20 ;
    //    //measureT mRowMin = wP.mRowsF() / 2 - 0x20 ;
    //    //measureT mColMin = wP.mColsF() / 2 - 0x20 ;
    //
    //    //winLineF( tin0P , wP , wP.mColsF() , 0 , 1        ) ;
    //    //winMoveF( tin0P , wP ) ;
    //    //paperP.mIdRow = wP.mRowsF() ;
    //    //paperP.mIdCol = 1 ;
    //    //winLineF( tin0P , wP , wP.mColsF() , 0 , wP.mRowsF() ) ;
    //    //winLineF( tin0P , wP , 1        , 0 , 1        ) ;
    //    //winLineF( tin0P , wP , 1        , 0 , wP.mRowsF() ) ;
    //    //winLineF( tin0P , wP , wP.mColsF() , 0 , wP.mRowsF() ) ;
    //    //winLineF( tin0P , wP , wP.mColsF() , 0 , 1        ) ;
    //    //winMoveF( tin0P , wP ) ;
    //    //paperP.mIdCol = paperP.mIdRow = 1 ;
    //{
    //U::FOR DEBUGGING ONLY; COMMENT OUT IN PRODUCTION
    
    winRectangleF( tin0P , hDrawP , 1.0 , 1.0 , wP.mColsF() , wP.mRowsF() ) ;
    winSetPaintTypeF( tin0P , hDrawP , ifcIDtYPEpAINT_OPAQUE ) ;
    
    INCoShANDLES
    HBRUSH hbrusho = (HBRUSH)((tin1S&)tin0P).brcRaw ;
    BOSdOnOTtEST( WHATgbo , SelectObject( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , hbrush ) ) //U::DEVELOP ERROR CHECKING THAT WILL WORK FOR SelectObject

    INCoShANDLES
    HPEN   hpeno   = (HPEN)((tin1S&)tin0P).brcRaw ;
    BOSdOnOTtEST( WHATgbo , SelectObject( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , hpen ) ) //U::DEVELOP ERROR CHECKING THAT WILL WORK FOR SelectObject

    INCoShANDLES
    HBRUSH hbrush  = (HBRUSH)((tin1S&)tin0P).brcRaw ;
    BOSpOOP
    BOS( WHATsww , BOSoK , CreateSolidBrush(         RGB( 0x00 , 0x00 , 0x00 ) ) )

    INCoShANDLES
    HPEN hpen = (HPEN)((tin1S&)tin0P).brcRaw ;
    BOSpOOP
    BOS( WHATsww , BOSoK , CreatePen( PS_SOLID , 1 , RGB( 0x00 , 0x00 , 0x00 ) ) )

    //LOGrAWtID2( "text color is now: " , GetTextColor( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) ) ) ;
    //BOSpOOP
    //BOS( WHATsww , BOSoK , SetTextColor( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , RGB( 0xff , 0xff , 0xff ) ) )

    //LOGrAWtID2( "bk color is now: " , GetBkColor( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) ) ) ;
    //BOSpOOP
    //BOS( WHATsww , BOSoK , SetBkColor( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , RGB( 0x00 , 0x00 , 0x00 ) ) )

    //BOSpOOP
    //BOS( WHATsww , BOSoK , SetBkMode( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , /*TRANSPARENT*/OPAQUE ) )


    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT thirdC::winResetF( tin0S& tin0P , const handleC& hDrawP , windowOldC& wP )/*1*/

/**/
*/
 wP
 tin0P
arguments
\<A HREF=\"5.102013e.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$winResetF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

