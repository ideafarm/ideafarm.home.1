
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    DECoShANDLES
    BOS( WHATsww , BOSoK , DeleteObject( hbrush ) )
    DECoShANDLES
    BOS( WHATsww , BOSoK , DeleteObject( hpen ) )
    BOSdOnOTtEST( WHATgbo , SelectObject( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , hbrusho ) ) //U::DEVELOP ERROR CHECKING THAT WILL WORK FOR SelectObject
    BOSdOnOTtEST( WHATgbo , SelectObject( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , hpeno ) ) //U::DEVELOP ERROR CHECKING THAT WILL WORK FOR SelectObject
    
    winSetPaintTypeF( tinBaseP , hDrawP ) ;
    
    //}
    //    paperP.mIdRow = mIdRowSave ;
    //    paperP.mIdCol = mIdColSave ;
    //
    //    //winLineF( tinBaseP , wP , wP.mColsF() , wP.mRowsF() ) ;
    //    //winMoveF( tinBaseP , wP ) ;
    //    //paperP.mIdCol = paperP.mIdRow = 1 ;
    //
    //    winDrawTextF( tinBaseP , wP , countTC() , countTC() , tn , tn.csF( tinBaseP ) ) ;
    //    winMoveF( tinBaseP , wP ) ;
    //    paperP.mIdRow = wP.mRowsF() - crt ;
    //    paperP.mIdCol = 1 ;
    //
    //    winDrawTextF( tinBaseP , wP , countTC() , countTC() , tn , tn.csF( tinBaseP ) ) ;
    //    winMoveF( tinBaseP , wP ) ;
    //    paperP.mIdRow = wP.mRowsF() - crt ;
    //    paperP.mIdCol = wP.mColsF() - cct ;
    //
    //    winDrawTextF( tinBaseP , wP , countTC() , countTC() , tn , tn.csF( tinBaseP ) ) ;
    //    winMoveF( tinBaseP , wP ) ;
    //    paperP.mIdRow = 1 ;
    //    paperP.mIdCol = wP.mColsF() - cct ;
    //
    //    winDrawTextF( tinBaseP , wP , cct , crt , tn , tn.csF( tinBaseP ) ) ;
    //    ZE( countT , crt ) ;
    //    ZE( countT , cct ) ;
    //    winMoveF( tinBaseP , wP ) ;
    //    paperP.mIdRow = 1 ;
    //    paperP.mIdCol = 1 ;
    //
    //    TN( tn , "" ) ; tn = TF1(idErase) ;
    //    countT idErase = &wP == p WinRoot ? 1 + incv02AM( idEraseLath ) : 0 ;
    //    static countT idEraseLath ;
    //    const measureT mIdRowSave = paperP.mIdRow ;
    //    const measureT mIdColSave = paperP.mIdCol ;
    //
    //    //winMoveF( tinBaseP , wP ) ;
    //    //paperP.mIdRow = wP.mRowsF() / 2 ;
    //    //paperP.mIdCol = wP.mColsF() / 2 ;
    //
    //    //winLineF( tinBaseP , wP , mColMin , mRowMin ) ;
    //    //winLineF( tinBaseP , wP , mColMin , mRowMax ) ;
    //    //winLineF( tinBaseP , wP , mColMax , mRowMax ) ;
    //    //winLineF( tinBaseP , wP , mColMax , mRowMin ) ;
    //    //winMoveF( tinBaseP , wP ) ;
    //    //paperP.mIdRow = mRowMin ;
    //    //paperP.mIdCol = mColMin ;
    //    //measureT mRowMax = wP.mRowsF() / 2 + 0x20 ;
    //    //measureT mColMax = wP.mColsF() / 2 + 0x20 ;
    //    //measureT mRowMin = wP.mRowsF() / 2 - 0x20 ;
    //    //measureT mColMin = wP.mColsF() / 2 - 0x20 ;
    //
    //    //winLineF( tinBaseP , wP , wP.mColsF() , 0 , 1        ) ;
    //    //winMoveF( tinBaseP , wP ) ;
    //    //paperP.mIdRow = wP.mRowsF() ;
    //    //paperP.mIdCol = 1 ;
    //    //winLineF( tinBaseP , wP , wP.mColsF() , 0 , wP.mRowsF() ) ;
    //    //winLineF( tinBaseP , wP , 1        , 0 , 1        ) ;
    //    //winLineF( tinBaseP , wP , 1        , 0 , wP.mRowsF() ) ;
    //    //winLineF( tinBaseP , wP , wP.mColsF() , 0 , wP.mRowsF() ) ;
    //    //winLineF( tinBaseP , wP , wP.mColsF() , 0 , 1        ) ;
    //    //winMoveF( tinBaseP , wP ) ;
    //    //paperP.mIdCol = paperP.mIdRow = 1 ;
    //{
    //U::FOR DEBUGGING ONLY; COMMENT OUT IN PRODUCTION
    
    winRectangleF( tinBaseP , hDrawP , 1.0 , 1.0 , wP.mColsF() , wP.mRowsF() ) ;
    winSetPaintTypeF( tinBaseP , hDrawP , ifcIDtYPEpAINT_OPAQUE ) ;
    
    INCoShANDLES
    HBRUSH hbrusho = (HBRUSH)((tinFullS&)tinBaseP).brcRaw ;
    BOSdOnOTtEST( WHATgbo , SelectObject( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , hbrush ) ) //U::DEVELOP ERROR CHECKING THAT WILL WORK FOR SelectObject

    INCoShANDLES
    HPEN   hpeno   = (HPEN)((tinFullS&)tinBaseP).brcRaw ;
    BOSdOnOTtEST( WHATgbo , SelectObject( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , hpen ) ) //U::DEVELOP ERROR CHECKING THAT WILL WORK FOR SelectObject

    INCoShANDLES
    HBRUSH hbrush  = (HBRUSH)((tinFullS&)tinBaseP).brcRaw ;
    BOSpOOP
    BOS( WHATsww , BOSoK , CreateSolidBrush(         RGB( 0x00 , 0x00 , 0x00 ) ) )

    INCoShANDLES
    HPEN hpen = (HPEN)((tinFullS&)tinBaseP).brcRaw ;
    BOSpOOP
    BOS( WHATsww , BOSoK , CreatePen( PS_SOLID , 1 , RGB( 0x00 , 0x00 , 0x00 ) ) )

    //LOGrAWtID2( "text color is now: " , GetTextColor( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) ) ) ;
    //BOSpOOP
    //BOS( WHATsww , BOSoK , SetTextColor( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , RGB( 0xff , 0xff , 0xff ) ) )

    //LOGrAWtID2( "bk color is now: " , GetBkColor( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) ) ) ;
    //BOSpOOP
    //BOS( WHATsww , BOSoK , SetBkColor( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , RGB( 0x00 , 0x00 , 0x00 ) ) )

    //BOSpOOP
    //BOS( WHATsww , BOSoK , SetBkMode( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) , /*TRANSPARENT*/OPAQUE ) )


    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT thirdC::winResetF( tinBaseS& tinBaseP , const handleC& hDrawP , windowOldC& wP )/*1*/

/**/
*/
 wP
 tinBaseP
arguments
\<A HREF=\"5.102013e.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$winResetF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

