
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    walkF( tinBaseP , slotsWalkCBF , cArg ) ;
    countT cArg = (countT)pcArg ;
    countT pcArg[] = { (countT)&etherP , (countT)&soulP } ;
    _IO_

    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT poolC::reportF( tinBaseS& tinBaseP , etherC& etherP , soulC& soulP )/*1*/

}
    }
        etherP.delF( tinBaseP , pstte ) ;
        etherP.strFuseF( tinBaseP , soulRptP , pstte ) ;

        }
            }
                }
                    }
                        etherP.delF( tinBaseP , psttLine ) ;
                        etherP.strFuseF( tinBaseP , pstte , psttLine ) ;
                        etherP.strDumpIF( tinBaseP , psttLine , pbDataP + offb * cbSlot , cbSlot , 0x10 , 4 , '.' ) ; ___( psttLine ) ;
                        ZE( strokeS* , psttLine ) ;
                    {
                    else
                    }
                        etherP.delF( tinBaseP , psttLine ) ;
                        etherP.strFuseF( tinBaseP , pstte , tqcr ) ;
                        etherP.strFuseF( tinBaseP , pstte , psttLine ) ;
                        etherP.strFuseF( tinBaseP , pstte , tq ) ;
                        etherP.strDumpStrokesIF( tinBaseP , psttLine , psttc ) ; ___( psttLine ) ;

                        etherP.delF( tinBaseP , psttLine ) ;
                        etherP.strFuseF( tinBaseP , pstte , tqcr ) ;
                        etherP.strFuseF( tinBaseP , pstte , psttLine ) ;
                        etherP.strFuseF( tinBaseP , pstte , TF3(offb,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+tb+TF3(ptUsed,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,3)+tb+TF3(cbOriginal,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,6)+tb+TF3(csttOriginal,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,6)+tbq ) ;

                        }
                            etherP.delF( tinBaseP , psttd ) ;
                            etherP.strSubstringF( tinBaseP , psttLine , idf , idl , psttd ) ; ___( psttLine ) ;
                            countT idl = TUCK ;
                            countT idf = 1 ;

                                             psttLine = 0 ;
                            strokeS* psttd = psttLine ;
                        {
                        if( psttLine->idAdam > TUCK )

                        etherP.strReplaceAnyF( tinBaseP , psttLine , psttc , tWhite , tb , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttLine ) ;
                        ZE( strokeS* , psttLine ) ;

                        countT ptUsed = ( cbOriginal << 8 ) / cbSlot ;
                        countT cbOriginal = ( CSpREFIX + csttOriginal ) * sizeof( strokeS ) ;
                        countT csttOriginal = psttc->idAdam ;
                    {
                    if( ISsTRING( psttc ) )
                    const strokeS* psttc = (const strokeS*)( pbDataP + offb * cbSlot ) ;
                {
                if( pbBitsOwnedP[ offByte ] >> offBit & 1 )

                countT offBit  = offb % SB ;
                countT offByte = offb / SB ;
            {
            for( countT offb = 0 ; offb < cBits ; offb ++ )
            countT cbSlot = 1 << pHeadP->expCbDrop ;
            TN( tWhite , TbLACK ) ;
            TN( tqcr , "\"\r\n" ) ;
            TN( tb , " " ) ;
            TN( tbq , " \"" ) ;
            TN( tq , "\"" ) ;

            etherP.strFuseF( tinBaseP , pstte , T("\r\n\r\nvalues:\r\noffset-- ptu cbUsed cUsed-\r\n") ) ;
        {
        else
        if( !cFound ) etherP.strFuseF( tinBaseP , pstte , tcr ) ;

        }
            else etherP.strFuseF( tinBaseP , pstte , tDash ) ;                                                                        //A:1
            }
                etherP.strFuseF( tinBaseP , pstte , tAt ) ;                                                                           //A:1
                cFound ++ ;
            {
            if( pbBitsOwnedP[ offByte ] >> offBit & 1 )

            countT offBit  = offb % SB ;
            countT offByte = offb / SB ;
        {
        for( countT offb = 0 ; offb < cBits ; offb ++ )
        ZE( countT , cFound ) ;
        TN( tDash , "-" ) ;
        TN( tAt , "@" ) ;
        TN( tcr , "\r\n" ) ;
        countT cBits = 1 << pHeadP->expSlots ;

        }
            //U::etherP.strMakeF( tinBaseP , LF , pstte , tEntry , TUCK + ( TUCK << 1 ) * ( 1 << pHeadP->expSlots ) ) ; ___( pstte ) ;                 //A:1
            etherP.strMakeF( tinBaseP , LF , pstte , tEntry , TICK ) ; ___( pstte ) ; //U::TO FIND A BUG

            ) ;

                "owned bits: "
                "cSlotsAvoidHi" ":")+TF2(pHeadP->cSlotsAvoidHi,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n"
                "cSlotsAvoidLo:")+TF2(pHeadP->cSlotsAvoidLo,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n"
                "flagsCt:")+TF2(pHeadP->flagsCt,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n"
                "postName   : \"")+T(pHeadP->postName)+T("\"\r\n"
                "expSlots   : ")+TF2(pHeadP->expSlots,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n"
                "expCbDrop  : ")+TF2(pHeadP->expCbDrop,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n"
                "cRef       : ")+TF2(pHeadP->cRef,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n"
                "\r\n"
                "sexHeadS:\r\n"
                "\r\n"
                "\r\n"

            TN( tEntry , "" ) ; tEntry = T(
        {
        ZE( strokeS* , pstte ) ;

        soulC&   soulRptP  =  *(soulC*)pcArgP[ 1 ] ;
        etherC&  etherP    = *(etherC*)pcArgP[ 0 ] ;
        countT*  pcArgP    = (countT*)cArgP ;
    {
    if( cArgP )
{
voidT slotsWalkCBF( tinBaseS& tinBaseP , countT& cArgP , const sexHeadS* pHeadP , const byteT* pbBitsOwnedP , const dropNoteS* pNotesP , const byteT* pbDataP )

/**/

*/
 it is unuseably slow
U::this needs more development
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

