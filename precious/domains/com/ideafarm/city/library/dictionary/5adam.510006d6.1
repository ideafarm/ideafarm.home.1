
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

//btCloudFileNames.traceF( tin0P , countTC() ) ;

while( ~hFind && !ether ) ;
}
    }
        DEL( pInfo ) ;
        etThread.delF( tin0P , postQuery ) ;

        etThread.traceF( tin0P , T(bFound?"    found: ":"not found: ")+tShort ) ;
        boolT bFound = btCloudFileNames.queryF( tin0P , postQuery , 0 , costQuery * SB ) ;

        for( countT offr = 0 ; offr < costQuery ; offr ++ ) postQuery[ offr ] = reverseBitsF( postQuery[ offr ] ) ;

        countT costQuery = etThread.strMakeF( tin0P , LF , postQuery , tShort ) ; ___( postQuery ) ;
        ZE( osTextT* , postQuery ) ;

        }
            etThread.delF( tin0P , psttShort ) ;
            tShort = T(psttShort) ;
            etThread.delF( tin0P , psttnu ) ;
            etThread.strBisectF( tin0P , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
            ZE( strokeS* , psttShort ) ;
            ZE( strokeS* , psttnu ) ;
        {
        TN( tShort , "" ) ;
    {
    if( pInfo && pInfo->psttIfoName && pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam != '/' )
    etThread.diskFindFileOrDirOldF( tin0P , pInfo , hFind , tLike ) ;
    ZE( infoFileS* , pInfo ) ;
{
do
handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
TN( tSlash       , "/" ) ;
TN( tLike        , ""  ) ; tLike = tPathArchive+T("*") ;
TN( tPathArchive , "///d/ideafarm.home.101/IdeaFarm (tm)/SYSTEM/2.1. Drop Files Here To Archive Them/" ) ;

btCloudFileNames.walkF( tin0P , pbBuffer , sizeof pbBuffer , cNest , myCBF ) ;

etThread.traceF( tin0P , T("loaded  btCloudFileNames") ) ;
while( !ether && !etThread && cloudRax.listFilesF( tin0P , T("archive") , btCloudFileNames , tMarker ) ) ;
TN( tMarker , "" ) ;
etThread.traceF( tin0P , T("loading btCloudFileNames") ) ;

cloudRax.getCloudInfoF( tin0P ) ;

}
    etThread.traceF( tin0P , T("tenant      : ")+cloudInfo.tRackspaceTenantId    ) ;
    etThread.traceF( tin0P , T("internal url: ")+cloudInfo.tRackspaceInternalUrl ) ;
    etThread.traceF( tin0P , T("url         : ")+cloudInfo.tRackspacePublicUrl   ) ;
    etThread.traceF( tin0P , T("password    : ")+cloudInfo.tRackspaceAccessToken ) ;
    cloudInfoS& cloudInfo = cloudRax ;
{

cloudC cloudRax( tin0P , ifcIDcLOUD_RACKSPACE , T("IAD") , T("ideafarm") , T("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx") ) ;

bitTreeC btCloudFileNames( tin0P , "bt.cloud.file.names" /*, 0*/ ) ;

TODO

}
    return 0 ;

    etherC::etRockIF( tin0P ).traceF( tin0P , T("file: \"")+T(pbBufferDisplay)+T("\"") ) ;

    for( countT offr = 0 ; offr < costfn ; offr ++ ) pbBufferDisplay[ offr ] = reverseBitsF( pbBufferDisplay[ offr ] ) ;

    pbBufferDisplay[ costfn ] = 0 ;
    thirdC::c_memcpyIF( tin0P , pbBufferDisplay , pbBuffer , costfn ) ;
    countT costfn = cNest / SB ;
{
countT myCBF( tin0S& tin0P , countT& cP )

byteT pbBufferDisplay[ TUCK ] ;
byteT pbBuffer[        TUCK ] ;
countT cNest ;

/*1*/WAKEsHOWtEXT( "example.other.1snip.15000171.cloudC" )/*1*/
/**/
*/
i am obsoleted in that cloudC instances now maintain a bitTreeC of cloud file names and another bitTreeC of local file names
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

