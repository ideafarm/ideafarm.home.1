
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //((tin123S&)tin0P).pEther->traceF( tin0P , T("$$$$")+T(psttP)+T("$$$$") ) ; //U:: TO FIND A BUG
    ether.delF( tin0P , psttRead ) ;
    }
        ether.strFuseF( tin0P , psttP , tle ) ;
        }
            ether.delF( tin0P , psttRead ) ;
            ether.strFuseF( tin0P , psttP , psttRead ) ;
        {
        if( psttRead )
    {
    if( bPerLineP && ( cbP + cPadSave ) % bPerLineP )
    //((tin123S&)tin0P).pEther->traceF( tin0P , T("@@@@")+T(psttP)+T("@@@@") ) ; //U:: TO FIND A BUG

    }
        }
            }
                ether.strFuseF( tin0P , psttP , tge ) ;
            {
            else if( bPerGroupP && !( idb % bPerGroupP ) )
            }
                ether.strFuseF( tin0P , psttP , tle ) ;
                }
                    ether.strMakeF( tin0P , LF , psttRead , T(" ") , bPerLineP * 2 ) ; ___( psttRead ) ;
                    ether.delF( tin0P , psttRead ) ;
                    ether.strFuseF( tin0P , psttP , psttRead ) ;
                {
                if( psttRead )
            {
            if( bPerLineP  && !( idb % bPerLineP ) )
    
            if( psttRead ) ether.strFuseF( tin0P , psttRead , tp1 ) ;
            ether.strFuseF( tin0P , psttP , tp2 ) ;
            cPad -- ;
        {
        else
        }
            pbP ++ ;
            }
                }
                    ether.strFuseF( tin0P , psttRead , tge ) ;
                {
                if( bPerGrouprP && !( idb % bPerGrouprP ) )
                ether.strFuseF( tin0P , psttP , tge ) ;
            {
            else if( bPerGroupP && !( idb % bPerGroupP ) )
            }
                ether.strFuseF( tin0P , psttP , tle ) ;
                }
                    ether.strMakeF( tin0P , LF , psttRead , T(" ") , bPerLineP * 2 ) ; ___( psttRead ) ;
                    ether.delF( tin0P , psttRead ) ;
                    ether.strFuseF( tin0P , psttP , psttRead ) ;
                {
                if( psttRead )
            {
            if( bPerLineP  && !( idb % bPerLineP ) )
    
            }
                ether.strFuseF( tin0P , psttRead , T(pb2) ) ;
                if( *pb2 < 0x20 || *pb2 > 0x7f ) *pb2 = bReadableP ;
                osTextT pb2[] = { *pbP , 0 } ;
            {
            if( psttRead )
            ether.strFuseF( tin0P , psttP , TF3(*pbP,fl3,2) ) ;

            ;
                : flFORMAT_UNSIGNED | flFORMAT_FILLzE | flFORMAT_NObIGITvALUES
                ? flFORMAT_UNSIGNED | flFORMAT_FILLzE | flFORMAT_NObIGITvALUES | flFORMAT_FOREIGN
            flagsT fl3 = F(flagsP) & flSTRdUMP_FOREIGN

        {
        if( pbP < pbe )
        ++ idb ;

        //((tin123S&)tin0P).pEther->traceF( tin0P , T("!!!!")+T(psttP)+T("!!!!") ) ; //U:: TO FIND A BUG
    {
    while( pbP < pbe || cPad )
    ZE( countT , idb ) ;
    const byteT* pbe = pbP + cbP ;
    TN( tp1 , " " ) ;
    TN( tp2 , "  " ) ;
    TN( tge , " " ) ;
    TN( tle , "\r\n" ) ;

    if( bReadableP ) { ether.strMakeF( tin0P , LF , psttRead , T(" ") , bPerLineP * 2 ) ; ___( psttRead ) ; }
    ZE( strokeS* , psttRead ) ;

    ether.strMakeF( tin0P , LF , psttP , T("") , 2 * ( cbP + cPad + cLineEnds ) + cGroupEnds + cGrouprEnds + !!bReadableP * cLineEnds * ( 1 + bPerLineP ) ) ; //CALLER MUST TAG ___( psttP ) ;

    ;
            : ( cbP + cPad ) / bPerGrouprP + ( cbP + cPad ) % bPerGrouprP - cLineEnds
            ? 0
        : !bPerGrouprP
        ? 0
    countT cGrouprEnds = !bReadableP
    countT cGroupEnds  = bPerGroupP  ? ( cbP + cPad ) / bPerGroupP  + ( cbP + cPad ) % bPerGroupP  - cLineEnds : 0 ;
    countT cLineEnds   = bPerLineP   ? ( cbP + cPad ) / bPerLineP   + ( cbP + cPad ) % bPerLineP   : 0 ;
    countT cPadSave    = cPad ;
    countT cPad        = bPerLineP   ? ( bPerLineP - cbP % bPerLineP ) % bPerLineP : 0 ;
    etherC& ether = *((tin123S&)tin0P).pEther ;

    _IO_
    
    }
        if( POOP ) return ;
        FV(flSTRdUMP,flagsP) ;
        __( !((tin123S&)tin0P).pEther ) ;
        __( bReadableP && ( bReadableP < 0x20 || bReadableP > 0x7f ) ) ;
        __( bPerGrouprP && bPerLineP % bPerGrouprP ) ;
        __( bPerGrouprP && !bReadableP ) ;
        __( bPerGrouprP && !bPerLineP ) ;
        __( bPerGroupP && bPerLineP % bPerGroupP ) ;
        __( bPerGroupP && !bPerLineP ) ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT etherC::strDumpIF( tin0S& tin0P , strokeS*& psttP , const byteT* pbP , const countT cbP , const flagsT flagsP , const countT bPerLineP , const countT bPerGroupP , const byteT bReadableP , const countT bPerGrouprP )/*1*/

/**/
*/
 bPerGrouprP
   '~'
   '@'
   '*'
   ' '
   '.'
  example values
  must either be 0 or a readable ascii value
  will be displayed in place of a byte value < 0x20 or > 0x7f
 bReadableP
  if not 0 then bPerLineP must be an integral multiple of bPerGroupP
  bytes per group
 bPerGroupP
  bytes per line
 bPerLineP
 cbP
 pbP
 psttP
 tin0P
arguments
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

