
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
#endif

    ether.delF( tin0P , psttRead ) ;
    }
        ether.strFuseF( tin0P , psttP , tle ) ;
        }
            ether.delF( tin0P , psttRead ) ;
            ether.strFuseF( tin0P , psttP , psttRead ) ;
        {
        if( psttRead )
    {
    if( bPerLineP && ( cbP + cPadSave ) % bPerLineP )

    }
        }
            }
                ether.strFuseF( tin0P , psttP , tge ) ;
            {
            else if( bPerGroupP && !( idb % bPerGroupP ) )
            }
                ether.strFuseF( tin0P , psttP , tle ) ;
                }
                    ether.strMakeF( tin0P , LF , psttRead , T(" ") , bPerLineP * 2 ) ; ___( psttRead ) ;
                    ether.delF( tin0P , psttRead ) ;
                    ether.strFuseF( tin0P , psttP , psttRead ) ;
                {
                if( psttRead )
            {
            if( bPerLineP  && !( idb % bPerLineP ) )
    
            if( psttRead ) ether.strFuseF( tin0P , psttRead , tp1 ) ;
            ether.strFuseF( tin0P , psttP , tp2 ) ;
            cPad -- ;
        {
        else
        }
            pbP ++ ;
            }
                }
                    ether.strFuseF( tin0P , psttRead , tge ) ;
                {
                if( bPerGrouprP && !( idb % bPerGrouprP ) )
                ether.strFuseF( tin0P , psttP , tge ) ;
            {
            else if( bPerGroupP && !( idb % bPerGroupP ) )
            }
                ether.strFuseF( tin0P , psttP , tle ) ;
                }
                    ether.strMakeF( tin0P , LF , psttRead , T(" ") , bPerLineP * 2 ) ; ___( psttRead ) ;
                    ether.delF( tin0P , psttRead ) ;
                    ether.strFuseF( tin0P , psttP , psttRead ) ;
                {
                if( psttRead )
            {
            if( bPerLineP  && !( idb % bPerLineP ) )
    
            }
                ether.strFuseF( tin0P , psttRead , T(pb2) ) ;
                if( *pb2 < 0x20 || *pb2 > 0x7f ) *pb2 = bReadableP ;
                osTextT pb2[] = { *pbP , 0 } ;
            {
            if( psttRead )
            ether.strFuseF( tin0P , psttP , TF3(*pbP,fl3,2) ) ;

            ;
                : flFORMAT_UNSIGNED | flFORMAT_FILLzE | flFORMAT_NObIGITvALUES
                ? flFORMAT_UNSIGNED | flFORMAT_FILLzE | flFORMAT_NObIGITvALUES | flFORMAT_FOREIGN
            flagsT fl3 = F(flagsP) & flSTRdUMP_FOREIGN

        {
        if( pbP < pbe )
        ++ idb ;

        //((tin1S&)tin0P).pEther->traceF( tin0P , T("!!!!")+T(psttP)+T("!!!!") ) ; //U:: TO FIND A BUG
    {
    while( pbP < pbe || cPad )
    ZE( countT , idb ) ;
    const byteT* pbe = pbP + cbP ;
//U::CODEmINE

#else


    ether.delF( tin0P , psttRead ) ;
    }
        ether.strFuseF( tin0P , psttP , tle ) ;
        }
            ether.delF( tin0P , psttRead ) ;
            ether.strFuseF( tin0P , psttP , psttRead ) ;
        {
        if( psttRead )
    {
    if( bPerLineP && ( cbP + cPadSave ) % bPerLineP )

    }
        }
            ether.strFuseF( tin0P , psttP , tge ) ;
        {
        else if( bPerGroupP && !( idm % bPerGroupP ) )
        }
            ether.strFuseF( tin0P , psttP , tle ) ;
            }
                ether.strMakeF( tin0P , LF , psttRead , T(" ") , bPerLineP * 2 ) ; ___( psttRead ) ;
                ether.delF( tin0P , psttRead ) ;
                ether.strFuseF( tin0P , psttP , psttRead ) ;
            {
            if( psttRead )
        {
        if( bPerLineP  && !( idm % bPerLineP ) )

        if( psttRead ) ether.strFuseF( tin0P , psttRead , tp1 ) ;
        ether.strFuseF( tin0P , psttP , tp2 ) ;

        idm ++ ;
    {
    while( cPad -- )

    }
        }
            }
                ether.strFuseF( tin0P , psttRead , tge ) ;
            {
            if( bPerGrouprP && !( idm % bPerGrouprP ) )
            ether.strFuseF( tin0P , psttP , tge ) ;
        {
        else if( bPerGroupP && !( idm % bPerGroupP ) )
        }
            ether.strFuseF( tin0P , psttP , tle ) ;
            }
                ether.strMakeF( tin0P , LF , psttRead , T(" ") , bPerLineP * 2 ) ; ___( psttRead ) ;
                ether.delF( tin0P , psttRead ) ;
                ether.strFuseF( tin0P , psttP , psttRead ) ;
            {
            if( psttRead )
        {
        if( bPerLineP  && !( idm % bPerLineP ) )
    
        ether.strFuseF( tin0P , psttP , TF4(vv,flagsUse,1,radix) ) ;
        //ether.traceF( tin0P , TF4(vv,flagsUse,1,radix) ) ;

        vv  &= mask ;
        vv >>= oib  ;

        countT vv        = *(count01T*)pbc ;

        countT oib       =       offbMunch % SB   ;      /* "oib" : "offset of bit in byte" */
        const byteT* pbc = pbP + offbMunch / SB   ;
        countT offbMunch = offMunch * cBitsPerMunch ;

        idm ++ ;
    {
    for( countT offMunch = 0 ; offMunch < cMunch ; offMunch ++ )
    ZE( countT , idm ) ;

    const countT cMunch = cBitsAll / cBitsPerMunch + !!cCrumb ;

    const countT cCrumb = cBitsAll % cBitsPerMunch            ;

    ;
            : 0xf
            ? 0x1f
        : F(flagsP) & flSTRdUMP_5bITS
        ? 0x3f
    const countT mask = F(flagsP) & flSTRdUMP_6bITS

    ;
            : 4
            ? 5
        : F(flagsP) & flSTRdUMP_5bITS
        ? 6
    const countT cBitsPerMunch = F(flagsP) & flSTRdUMP_6bITS

    const countT cBitsAll = cbP * SB ;

    ;
            : 0x10
            ? 0x20
        : F(flagsP) & flSTRdUMP_5bITS
        ? 0x40
    const countT radix = F(flagsP) & flSTRdUMP_6bITS

    ;
        : flFORMAT_UNSIGNED | flFORMAT_NObASE | flFORMAT_FILLzE | flFORMAT_NObIGITvALUES
        ? flFORMAT_UNSIGNED | flFORMAT_NObASE | flFORMAT_FILLzE | flFORMAT_NObIGITvALUES | flFORMAT_FOREIGN
    const flagsT flagsUse = F(flagsP) & flSTRdUMP_FOREIGN

#if defined( NEVERdEFINED )

    TN( tp1 , " " ) ;
    TN( tp2 , "  " ) ;
    TN( tge , " " ) ;
    TN( tle , "\r\n" ) ;

    if( bReadableP ) { ether.strMakeF( tin0P , LF , psttRead , T(" ") , bPerLineP * 2 ) ; ___( psttRead ) ; }
    ZE( strokeS* , psttRead ) ;

    ether.strMakeF( tin0P , LF , psttP , T("") , 2 * ( cbP + cPad + cLineEnds ) + cGroupEnds + cGrouprEnds + !!bReadableP * cLineEnds * ( 1 + bPerLineP ) ) ; //CALLER MUST TAG ___( psttP ) ;

    ;
            : ( cbP + cPad ) / bPerGrouprP + ( cbP + cPad ) % bPerGrouprP - cLineEnds
            ? 0
        : !bPerGrouprP
        ? 0
    countT cGrouprEnds = !bReadableP
    countT cGroupEnds  = bPerGroupP  ? ( cbP + cPad ) / bPerGroupP  + ( cbP + cPad ) % bPerGroupP  - cLineEnds : 0 ;
    countT cLineEnds   = bPerLineP   ? ( cbP + cPad ) / bPerLineP   + ( cbP + cPad ) % bPerLineP   : 0 ;
    countT cPadSave    = cPad ;
    countT cPad        = bPerLineP   ? ( bPerLineP - cbP % bPerLineP ) % bPerLineP : 0 ;
    etherC& ether = *((tin1S&)tin0P).pEther ;

    _IO_
    
    }
        if( POOP ) return ;
        if( F(flagsP) & flSTRdUMP_6bITS && pbP[ cbP ]                    ) { BLAMMOiD( 0x22222222 ) ; }
        if( F(flagsP) & flSTRdUMP_5bITS && pbP[ cbP ]                    ) { BLAMMOiD( 0x11111111 ) ; }
        if( F(flagsP) & flSTRdUMP_6bITS && bReadableP                    ) { __1 } ;
        if( F(flagsP) & flSTRdUMP_5bITS && bReadableP                    ) { __1 } ;
        if( F(flagsP) & flSTRdUMP_6bITS && F(flagsP) & flSTRdUMP_FOREIGN ) { __1 } ;
        if( F(flagsP) & flSTRdUMP_5bITS && F(flagsP) & flSTRdUMP_FOREIGN ) { __1 } ;
        if( F(flagsP) & flSTRdUMP_5bITS && F(flagsP) & flSTRdUMP_6bITS   ) { __1 } ;
        FV(flSTRdUMP,flagsP) ;
        __( !((tin1S&)tin0P).pEther ) ;
        __( bReadableP && ( bReadableP < 0x20 || bReadableP > 0x7f ) ) ;
        __( bPerGrouprP && bPerLineP % bPerGrouprP ) ;
        __( bPerGrouprP && !bReadableP ) ;
        __( bPerGrouprP && !bPerLineP ) ;
        __( bPerGroupP && bPerLineP % bPerGroupP ) ;
        __( bPerGroupP && !bPerLineP ) ;
        __Z( cbP ) ;
        __Z( pbP ) ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT etherC::strDumpIF( tin0S& tin0P , strokeS*& psttP , const byteT* pbP , const countT cbP , const flagsT flagsP , const countT bPerLineP , const countT bPerGroupP , const byteT bReadableP , const countT bPerGrouprP )/*1*/

/**/
*/
 bPerGrouprP
   '~'
   '@'
   '*'
   ' '
   '.'
  example values
  must either be 0 or a readable ascii value
  will be displayed in place of a byte value < 0x20 or > 0x7f
 bReadableP
  if not 0 then bPerLineP must be an integral multiple of bPerGroupP
  bytes per group
 bPerGroupP
  bytes per line
 bPerLineP
  if flSTRdUMP_5bITS or flSTRdUMP_6bITS then the input must be null terminated, i.e. pbP[ cbP ] must be accessible and contain 0
 flagsP
 cbP
 pbP
 psttP
 tin0P
arguments
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

