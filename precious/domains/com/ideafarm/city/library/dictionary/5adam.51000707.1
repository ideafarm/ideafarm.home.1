
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tinBaseP ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tinBaseP , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etThread.traceF( tinBaseP , T("bye") ) ;

    }
        ++ s ; ether.osSleepF( tinBaseP , TOCK ) ;
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

        }
            etThread.strokeF( tinBaseP , tOut ) ;

            etThread.boxPutF( tinBaseP , T("///ideafarm/tmp/time.ttt") , tOut , tOut.csF( tinBaseP ) ) ;

            etThread.delF( tinBaseP , pstto ) ;
            TN( tOut , pstto ) ;

            etThread.strFuseF( tinBaseP , pstto , T("\r\n") ) ;

            }
                etThread.delF( tinBaseP , psttc ) ;
                etThread.strFuseF( tinBaseP  , pstto , psttc ) ;
                etThread.strCalendarF( tinBaseP , psttc , time2 ) ; ___( psttc ) ;
                ZE( strokeS* , psttc ) ;

            {

            etThread.strFuseF( tinBaseP , pstto , T("\r\nminute: ")+TF2(minute,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n\r\n") ) ;

            etThread.strMakeF( tinBaseP , LF , pstto , 0 , TOCK ) ; ___( pstto ) ;
            ZE( strokeS* , pstto ) ;

            }
                }
                    //etThread.traceF( tinBaseP , tSay ) ;
                    //}
                    //    else                                   tSay += TF2(pcTallyInDelta[offt],(bDone?flFORMAT_NObIGITvALUES:flFORMAT_NObIGITvALUES|flFORMAT_FILLzE)) ;
                    //    if( !pcTallyInDelta[ offt ] && bDone ) break ;
                    //
                    //    }
                    //        }
                    //            break ;
                    //            bDone = 0 ;
                    //        {
                    //        if( pcTallyInDelta[ offt2 ] )
                    //    {
                    //    for( countT offt2 = offt + 1 ; offt2 < sizeof pcTallyInDelta / sizeof pcTallyInDelta[ 0 ] ; offt2 ++ )
                    //    boolT bDone = 1 ;
                    //{
                    //for( countT offt = 0 ; offt < sizeof pcTallyInDelta / sizeof pcTallyInDelta[ 0 ] ; offt ++ )
                    //TN( tSay , "home speed [inOutFrameC ct per minute]: " ) ;
                    //REPORT DELTA

                    thirdC::c_memcpyIF( tinBaseP , (byteT*)pcTallyInLath , (byteT*)pcTallyInSnap , sizeof pcTallyInLath ) ;

                    }
                        pcTallyInDelta[ offt ] -= pcTallyInLath[ offt ] ;

                        }
                            else          bBorrow ++ ;
                            if( bBorrow ) { BLAMMO ; } //IMPOSSIBLE
                        {
                        if( pcTallyInDelta[ offt ] < pcTallyInLath[ offt ] )

                        }
                            pcTallyInDelta[ offt ] -- ;
                            bBorrow = !pcTallyInDelta[ offt ] ;
                        {
                        if( bBorrow )
                    {
                    for( countT offt = 0 ; offt < sizeof pcTallyInDelta / sizeof pcTallyInDelta[ 0 ] ; offt ++ )
                    ZE( boolT , bBorrow ) ;

                    thirdC::c_memcpyIF( tinBaseP , (byteT*)pcTallyInDelta , (byteT*)pcTallyInSnap , sizeof pcTallyInDelta ) ;
                    countT pcTallyInDelta[ CCtALLYiN ] ;

                    thirdC::c_memcpyIF( tinBaseP , (byteT*)pcTallyInSnap , (byteT*)ph->pcTallyIn , sizeof pcTallyInSnap ) ;
                    countT pcTallyInSnap[ CCtALLYiN ] ;
                {
                if( ph )

                homeS* ph = &homeS::homeIF() ;
            {

            minuteLath = minute ;
        {
        if( minuteLath != minute)

        countT minute = time1 >> 0x14 ;
        etThread.osTimeNowF( tinBaseP , time1 , time2 ) ;
        ZE( sCountT , time2 ) ;
        ZE( countT , time1 ) ;
    {
    while( !ether && !POOP )
    static countT pcTallyInLath[ CCtALLYiN ] ;
    ZE( countT , minuteLath ) ;

    if( !bSandbox ) ether.ifcHireF( tinBaseP , T("ifcIDaDAM_TIME") , ifcIDaDAM_ROOTmAILoUT , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; // flHIRE_DISPLAYaUTO CAN BE COMMENTED OUT TO AVOID WDW FOR ROOT CLOUD INSTANCE WHICH IS USUALLY NOT INTERESTING 
    bSandbox = 0 ;
    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;
{
if( pTaskP )
TASK( tmWorkF )

/*1*/WAKEhIDE( "ifcIDaDAM_TIME" )/*1*/
/**/
*/
\<A HREF=\"5.7b30104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

