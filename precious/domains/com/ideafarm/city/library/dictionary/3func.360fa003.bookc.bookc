
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        //}
        //    LOGrAW(   ostoSay ) ;
        //    OStEXTAK( ostoSay , "\r\n" ) ;
        //    OStEXTA(  ostoSay , postShortOrLongP ) ;
        //    OStEXTAK( ostoSay ,"    " ) ;
        //    OStEXTC(  ostoSay , this , '0' ) ;
        //    OStEXTAK( ostoSay , "bookC: ++ " ) ;
        //    OStEXT(   ostoSay , TUCK << 2 ) ;
        //{

        // if( ((tinFullS&)tinBaseP).pEther ) ((tinFullS&)tinBaseP).pEther->trace F( tinBaseP , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": bookC constructed") ) ; //U:: TO FIND A BUG

        }
            if( !bMemoryExisted ) napkin.formattingIsDoneF( tinBaseP ) ;

            provisionF( tinBaseP , napkin , napkin , flagsProvision , bFillP ) ;

            if( bMemoryExisted || bFileExisted ) flagsProvision &= ~( F(flBOOK0pROVISION_FORMAT) ) ; //U::20201124@1544: POSSIBLE BUG: HOW CAN FILE PREEXIST WITHOUT MEMORY ALSO PREEXISTING?

            boolT bMemoryExisted = F(napkin.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ;

            napkinC& napkin = *(napkinC*)pbNapkin ;
            }
                ) ;
                    idMemorySpaceP
                    - 1 ,
                    ) ,
                        | ( F(flagsP) & flBOOKc_DOnOTsERIALIZEnAPKIN       ? flNAPKINc_DOnOTsERIALIZEcT           : flNAPKINc_null )
                        | ( F(flagsP) & flBOOKc_LOCK                       ? flNAPKINc_LOCK                       : flNAPKINc_null )
                          ( F(flagsP) & flBOOKc_USEgRABmEMORYsPACEoVERRIDE ? flNAPKINc_USEgRABmEMORYsPACEoVERRIDE : flNAPKINc_null )
                    (
                    ifcOPENsHAREDmEMORYhOW_nCeO ,
                    sizeof( bookHeadS ) + cbP ,
                    ) ,
                            : (const handleC*)*(fileC*)pbFile
                            ? 0
                        !idStateSpaceP
                    (
                    ostoBuf ,
                    pbBitsCtP ,
                    idiFileCtP ,
                    idLineCtP ,
                    tinBaseP ,
                (
                new( 0 , tinBaseP , pbNapkin , sizeof pbNapkin ) napkinC

                }
                    OStEXTCF( ostoBuf , idStateSpaceP , '0' ) ;
                    OStEXTAK( ostoBuf , "." ) ;
                {
                if( idStateSpaceP )                                 // APPENDING idStateSpaceP ENSURES THAT SHARED MEMORY NAME IS DISTINCT FOR EACH BACKING FILE; ADDED 20190104@1712 WITHOUT ANALYSIS
                OStEXTA(  ostoBuf , postShort ) ;
                OStEXTAK( ostoBuf , "book0C/" ) ;
                OStEXT(   ostoBuf , TUCK << 2 ) ;
            {

            else                flagsCt        |= flBOOKc_FILEeXISTED ;
            if( !bFileExisted ) flagsProvision |= flBOOK0pROVISION_RESETcREFoNcT ;      //20230501@1058: ADDED

            }
                }
                    }
                        }
                            if( !cbP ) cbP = info.cbUsed - sizeof( napkinHeaderS ) - sizeof( bookHeadS ) ;

                            if( cbP && cbP != info.cbUsed - sizeof( napkinHeaderS ) - sizeof( bookHeadS ) ) { BLAMMO ; }
                        {
                        //if( cbHead == sizeof head && info.cbUsed == sizeof head + head.cbBody )
                    
                        //thirdC::dosReadIF( tinBaseP , (byteT*)&head , cbHead , (const handleC&)file ) ;
                        //countT cbHead = sizeof head ;
                        //bookHeadS head ;
                    {
                    if( info.cbUsed >= sizeof( napkinHeaderS ) + sizeof( bookHeadS ) )

                    thirdC::dosQueryFileInfoIF( tinBaseP , pInfo , file ) ;
                    infoFileS* pInfo = &info ;
                    infoFileS info( tinBaseP ) ;
                {
                //if( bFileExisted )

                bFileExisted = file.idOpenResultF( tinBaseP  ) == ifcOPENrESULT_EXISTED ;

                fileC& file = *(fileC*)pbFile ;
                ctFileF( tinBaseP , postShort , postShort ? postPath : 0 , idStateSpaceP , idMemorySpaceP ) ;
            {
            if( idStateSpaceP )
            ZE( boolT , bFileExisted ) ;
        {
        else
        }
            provisionF( tinBaseP , pbFromHeap , cba , flagsProvision , bFillP ) ;
            pbFromHeap = processGlobal4I.heap.newF( tinBaseP , idLineCtP , idiFileCtP , cba ) ;
            countT cba = sizeof( bookHeadS ) + cbP ;
        {
        if( F(flagsCt) & flBOOKc_USEhEAPnOTnAPKIN )

        if( F(flagsCt) & flBOOKc_PRIORbOOKnOTcONTINUEDhERE ) flagsProvision |= flBOOK0pROVISION_PRIORbOOKnOTcONTINUEDhERE ;
        if( F(flagsCt) & flBOOKc_RESETcREFoNcT             ) flagsProvision |= flBOOK0pROVISION_RESETcREFoNcT             ;      //20180816@1339: ADDED WITHOUT ANALYSIS OTHER THAN TO NOTICE THAT flBOOKc_RESETcREFoNcT IS NOWHERE ELSE INSPECTED
        if( F(flagsCt) & flBOOKc_DOnOTiNITIALIZEdATA       ) flagsProvision |= flBOOK0pROVISION_DOnOTiNITIALIZE           ;
        flagsT flagsProvision = flBOOK0pROVISION_FORMAT ;

        if( F(flagsCt) & flBOOKc_USEhEAPnOTnAPKIN ) flagsCt |= flBOOKc_RESETcREFoNcT | flBOOKc_PRIORbOOKnOTcONTINUEDhERE ;

        // if( ((tinFullS&)tinBaseP).pEther ) ((tinFullS&)tinBaseP).pEther->trace F( tinBaseP , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": bookC constructing") ) ; //U:: TO FIND A BUG

        //}
        //    CONoUTrAW(   ostoSay ) ;
        //    OStEXTAK( ostoSay , "\r\n" ) ;
        //    OStEXTA(  ostoSay , postShortOrLongP ) ;
        //    OStEXTAK( ostoSay ,"    " ) ;
        //    OStEXTC(  ostoSay , this , '0' ) ;
        //    OStEXTAK( ostoSay , "bookC: +  " ) ;
        //    OStEXT(   ostoSay , TUCK << 2 ) ;
        //{
    {
    if( !POOP )

    }
        __( thirdC::c_strchrIF( tinBaseP , postShort , ':' ) ) ;
        __( thirdC::c_strchrIF( tinBaseP , postShort , '\\' ) ) ;
    {
    if( postShort )

    }
        }
            postPath = postPathBuf ;
            thirdC::c_memcpyIF( tinBaseP , postPathBuf , postShortOrLongP , postShort - postShortOrLongP ) ;
            thirdC::c_memsetIF( tinBaseP , postPathBuf , sizeof postPathBuf , 0 ) ;
            postShort ++ ;
        {
        if( postShort )
        postShort = thirdC::c_strrchrIF( tinBaseP , postShort , '\\' ) ;
    {
    )
        postShort[ 2 ] == '\\'
        &&
        postShort[ 0 ] <= 'z'
        &&
        postShort[ 0 ] >= 'a'
        &&
        postShort[ 1 ] == ':'
        &&
        postShort
    (
    if                                              //IF LONG
    const osTextT* postShort = postShortOrLongP ;
    osTextT postPathBuf[ TUCK << 2 ] ;
    ZE(osTextT* , postPath ) ;

    _IO_

    }
        if( POOP ) return ;
        __( idMemorySpaceP && !( F(((tinFullS&)tinBaseP).flagsThreadMode4) & flTHREADmODE4_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tinBaseP ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tinBaseP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        }
            __( !*postShortOrLongP ) ;
            if( POOP ) return ;
            __Z( postShortOrLongP ) ;
        {
        else
        }
            __( idMemorySpaceP   ) ;
            __( idStateSpaceP    ) ;
            __( postShortOrLongP ) ;
        {
        if( F(flagsCt) & flBOOKc_USEhEAPnOTnAPKIN )
        __( cbP && !( F(flagsCt) & flBOOKc_WRITER ) ) ;
        __( F(flagsP) & flBOOKc_FILEiScONSTRUCTED ) ; //THIS FLAG IS FOR INTERNAL USE ONLY; CALLER MAY NOT SPECIFY IT
        __( F(flagsP) & flBOOKc_NOsTATEsPACE      ) ; //THIS FLAG IS FOR INTERNAL USE ONLY; CALLER MAY NOT SPECIFY IT (IT IS IMPLIED BY !idStateSpaceP)
        FV( flBOOKc , flagsP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
{
pbFromHeap( 0 )
) ,
        : flagsP | flBOOKc_NOsTATEsPACE
        ? flagsP
    idStateSpaceP
(
flagsCt
book0C( tinBaseP , 0 , 0 ) ,
/*1*/bookC::bookC( tinBaseS& tinBaseP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postShortOrLongP , const countT idStateSpaceP , const flagsT flagsP , countT cbP , const byteT bFillP , const countT idMemorySpaceP ) :/*1*/

/**/
*/
 idMemorySpaceP
 bFillP
 cbP
 flagsP
 idStateSpaceP
 postP
 pbBitsCtP
 idiFileCtP
 idLineCtP
 tinBaseP
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

