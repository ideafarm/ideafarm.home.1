
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        //}
        //    LOGrAW(   ostoSay ) ;
        //    OStEXTAK( ostoSay , "\r\n" ) ;
        //    OStEXTA(  ostoSay , postShortOrLongP ) ;
        //    OStEXTAK( ostoSay ,"    " ) ;
        //    OStEXTC(  ostoSay , this , '0' ) ;
        //    OStEXTAK( ostoSay , "bookC: ++ " ) ;
        //    OStEXT(   ostoSay , TUCK << 2 ) ;
        //{

        // if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->trace F( tin0P , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": bookC constructed") ) ; //U:: TO FIND A BUG

        }
            if( bFormat ) napkin.formattingIsDoneF( tin0P ) ;

            provisionF( tin0P , napkin , napkin , flagsProvision , bFillP ) ;

            }
                flagsProvision &= ~( F(flBOOK0pROVISION_FORMAT) ) ; //U::20201124@1544: POSSIBLE BUG: HOW CAN FILE PREEXIST WITHOUT MEMORY ALSO PREEXISTING?
                bFormat = 0 ;
            {
            )
                )
                    F(flagsP) & flBOOKc_DOnOTfORMATeXISTINGfILE
                    &&
                    bFileExisted
                (
                ||
                bMemoryExisted
            (
            if
            boolT bFormat = 1 ;

            boolT bMemoryExisted = F(napkin.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ;

            napkinC& napkin = *(napkinC*)pbNapkin ;
            }
                ) ;
                    idMemorySpaceP
                    - 1 ,
                    ) ,
                        | ( F(flagsP) & flBOOKc_DOnOTfORMATeXISTINGfILE    ? flNAPKINc_UNGRABmEMORYiFfILEeXISTED  : flNAPKINc_null )
                        | ( F(flagsP) & flBOOKc_DOnOTsERIALIZEnAPKIN       ? flNAPKINc_DOnOTsERIALIZEcT           : flNAPKINc_null )
                        | ( F(flagsP) & flBOOKc_LOCK                       ? flNAPKINc_LOCK                       : flNAPKINc_null )
                          ( F(flagsP) & flBOOKc_USEgRABmEMORYsPACEoVERRIDE ? flNAPKINc_USEgRABmEMORYsPACEoVERRIDE : flNAPKINc_null )
                    (
                    ifcOPENsHAREDmEMORYhOW_nCeO ,
                    sizeof( bookHeadS ) + cbP ,
                    ) ,
                            : (const handleC*)*(fileC*)pbFile
                            ? 0
                        !idStateSpaceP
                    (
                    ostoBuf ,
                    pbBitsCtP ,
                    idiFileCtP ,
                    idLineCtP ,
                    tin0P ,
                (
                new( 0 , tin0P , pbNapkin , sizeof pbNapkin ) napkinC

                }
                    OStEXTCF( ostoBuf , (countT)thirdC::cpuCyclesIF() , '0' ) ;
                    OStEXTAK( ostoBuf , ".uniquified." ) ;
                {
                if( F(flagsP) & flBOOKc_UNIQUEsHAREDmEMORY )

                }
                    OStEXTCF( ostoBuf , idStateSpaceP , '0' ) ;
                    OStEXTAK( ostoBuf , "." ) ;
                {
                if( idStateSpaceP )                                 // APPENDING idStateSpaceP ENSURES THAT SHARED MEMORY NAME IS DISTINCT FOR EACH BACKING FILE; ADDED 20190104@1712 WITHOUT ANALYSIS
                OStEXTA(  ostoBuf , postShort ) ;
                OStEXTAK( ostoBuf , "book0C/" ) ;
                OStEXT(   ostoBuf , TUCK << 2 ) ;
            {

            else                flagsCt        |= flBOOKc_FILEeXISTED ;
            if( !bFileExisted ) flagsProvision |= flBOOK0pROVISION_RESETcREFoNcT ;      //20230501@1058: ADDED

            }
                }
                    }
                        }
                            if( !cbP ) cbP = info.cbUsed - sizeof( napkinHeaderS ) - sizeof( bookHeadS ) ;

                            if( cbP && cbP != info.cbUsed - sizeof( napkinHeaderS ) - sizeof( bookHeadS ) ) { BLAMMO ; }            //20250126@1535: OBSERVED ON CLOUD SERVER (DUE POSSIBLY TO NATIONWIDE POWER SURGE)
                        {
                        //if( cbHead == sizeof head && info.cbUsed == sizeof head + head.cbBody )
                    
                        //thirdC::dosReadIF( tin0P , (byteT*)&head , cbHead , (const handleC&)file ) ;
                        //countT cbHead = sizeof head ;
                        //bookHeadS head ;
                    {
                    if( info.cbUsed >= sizeof( napkinHeaderS ) + sizeof( bookHeadS ) )

                    thirdC::dosQueryFileInfoIF( tin0P , pInfo , file ) ;
                    infoFileS* pInfo = &info ;
                    infoFileS info( tin0P ) ;
                {
                //if( bFileExisted )

                bFileExisted = file.idOpenResultF( tin0P  ) == ifcOPENrESULT_EXISTED ;

                fileC& file = *(fileC*)pbFile ;
                ctFileF( tin0P , postShort , postShort ? postPath : 0 , idStateSpaceP , idMemorySpaceP ) ;
            {
            if( idStateSpaceP )
            ZE( boolT , bFileExisted ) ;

}
    countT foo = 2 ;
{
if( idIn == 0x31 )
countT idIn = 1 + incv02AM( idInLath ) ;
static countT idInLath ;

        {
        else
        }
            provisionF( tin0P , pbFromHeap , cba , flagsProvision , bFillP ) ;
            pbFromHeap = processGlobal4I.heap.newF( tin0P , idLineCtP , idiFileCtP , cba ) ;
            countT cba = sizeof( bookHeadS ) + cbP ;
        {
        if( F(flagsCt) & flBOOKc_USEhEAPnOTnAPKIN )

        if( F(flagsCt) & flBOOKc_PRIORbOOKnOTcONTINUEDhERE ) flagsProvision |= flBOOK0pROVISION_PRIORbOOKnOTcONTINUEDhERE ;
        if( F(flagsCt) & flBOOKc_RESETcREFoNcT             ) flagsProvision |= flBOOK0pROVISION_RESETcREFoNcT             ;      //20180816@1339: ADDED WITHOUT ANALYSIS OTHER THAN TO NOTICE THAT flBOOKc_RESETcREFoNcT IS NOWHERE ELSE INSPECTED
        if( F(flagsCt) & flBOOKc_DOnOTiNITIALIZEdATA       ) flagsProvision |= flBOOK0pROVISION_DOnOTiNITIALIZE           ;
        flagsT flagsProvision = flBOOK0pROVISION_FORMAT ;

        if( F(flagsCt) & flBOOKc_USEhEAPnOTnAPKIN ) flagsCt |= flBOOKc_RESETcREFoNcT | flBOOKc_PRIORbOOKnOTcONTINUEDhERE ;

        //if( ((tin1S&)tin0P).pEther && thirdC::c_strstrIF( tin0P , postShortOrLongP , "clean.menu" ) ) ((tin1S&)tin0P).pEther->traceF( tin0P , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": bookC constructing [postShortOrLongP]:    ")+T(postShortOrLongP) ) ; //U:: TO FIND A BUG

        //}
        //    CONoUTrAW(   ostoSay ) ;
        //    OStEXTAK( ostoSay , "\r\n" ) ;
        //    OStEXTA(  ostoSay , postShortOrLongP ) ;
        //    OStEXTAK( ostoSay ,"    " ) ;
        //    OStEXTC(  ostoSay , this , '0' ) ;
        //    OStEXTAK( ostoSay , "bookC: +  " ) ;
        //    OStEXT(   ostoSay , TUCK << 2 ) ;
        //{
    {
    if( !POOP )

    }
        __( thirdC::c_strchrIF( tin0P , postShort , ':' ) ) ;
        __( thirdC::c_strchrIF( tin0P , postShort , '\\' ) ) ;
    {
    if( postShort )

    }
        }
            postPath = postPathBuf ;
            thirdC::c_memcpyIF( tin0P , postPathBuf , postShortOrLongP , postShort - postShortOrLongP ) ;
            thirdC::c_memsetIF( tin0P , postPathBuf , sizeof postPathBuf , 0 ) ;
            postShort ++ ;
        {
        if( postShort )
        postShort = thirdC::c_strrchrIF( tin0P , postShort , '\\' ) ;
    {
    )
        )
            )
                postShort[ 1 ] == '\\'
                &&                                  // NETWORK FILE NAME
                postShort[ 0 ] == '\\'
            (
            ||
            )
                postShort[ 2 ] == '\\'
                &&
                postShort[ 0 ] <= 'z'
                &&                                  // LOCAL FILE NAME
                postShort[ 0 ] >= 'a'
                &&
                postShort[ 1 ] == ':'
            (
        (
        &&
        postShort
    (
    if                                              //IF LONG
    const osTextT* postShort = postShortOrLongP ;
    osTextT postPathBuf[ TUCK << 2 ] ;
    ZE(osTextT* , postPath ) ;

    _IO_

    }
        if( POOP ) return ;
        __( idMemorySpaceP && !( F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tin0P ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tin0P ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        }
            __( !*postShortOrLongP ) ;
            if( POOP ) return ;
            __Z( postShortOrLongP ) ;
        {
        else
        }
            __( idMemorySpaceP   ) ;
            __( idStateSpaceP    ) ;
            __( postShortOrLongP ) ;
        {
        if( F(flagsCt) & flBOOKc_USEhEAPnOTnAPKIN )
        __( cbP && !( F(flagsCt) & flBOOKc_WRITER ) ) ;
        __( F(flagsP) & flBOOKc_FILEiScONSTRUCTED ) ; //THIS FLAG IS FOR INTERNAL USE ONLY; CALLER MAY NOT SPECIFY IT
        __( F(flagsP) & flBOOKc_NOsTATEsPACE      ) ; //THIS FLAG IS FOR INTERNAL USE ONLY; CALLER MAY NOT SPECIFY IT (IT IS IMPLIED BY !idStateSpaceP)
        FV( flBOOKc , flagsP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
{
pbFromHeap( 0 )
) ,
        : flagsP | flBOOKc_NOsTATEsPACE
        ? flagsP
    idStateSpaceP
(
flagsCt
book0C( tin0P , 0 , 0 ) ,
/*1*/bookC::bookC( tin0S& tin0P , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postShortOrLongP , const countT idStateSpaceP , const flagsT flagsP , countT cbP , const byteT bFillP , const countT idMemorySpaceP ) :/*1*/

/**/
*/
 idMemorySpaceP
 bFillP
 cbP
 flagsP
 idStateSpaceP
 postP
 pbBitsCtP
 idiFileCtP
 idLineCtP
 tin0P
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

