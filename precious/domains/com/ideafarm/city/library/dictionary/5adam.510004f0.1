
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.loafIF( tinBaseP ) ;

while( cTries -- ) etThread.osThreadF( tinBaseP , countTC() , tmClientF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&stIdPort ) ;
cTries = CcLIENTS ;

}
    }
        ++ s ; etThread.osSleepF( tinBaseP , TUCK * 0x40 ) ;
    {
    while( stIdPort < CsERVERS )
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
{

while( cTries -- ) etThread.osThreadF( tinBaseP , countTC() , tmServerF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&stIdPort , (countT)(const osTextT*)ostoSpoke , (countT)(const osTextT*)ostoWheel ) ;
countT cTries = CsERVERS ;

OStEXTV( ostoWheel , "\r.a" )
OStEXTV( ostoSpoke , "|/-\\" ) // MUST BE LEN 4 EXCL TERMINATOR
stackC stIdPort( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmServerF )
}
    }
        DEL( pso ) ;

        }
            *((tinNormalS&)tinBaseP).zEtScratch = 0 ;
            pso->readF( tinBaseP , sIn ) ; //WILL FAIL

            }
                }
                    }
                        sock.writeF( tinBaseP , sIn ) ;
                        sock.connectF( tinBaseP , idPortExplode2 ) ;
                        socketC sock( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
                    {
                    if( idPortExplode2 )
    
                    }
                        sock.writeF( tinBaseP , sIn ) ;
                        sock.connectF( tinBaseP , idPortExplode1 ) ;
                        socketC sock( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
                    {
                    if( idPortExplode1 )
                {
                else
                }
                    sock.writeF( tinBaseP , sIn ) ;
                    sock.connectF( tinBaseP , idPortImplode ) ;
                    socketC sock( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
                {
                if( idPortImplode )

                idBang ++ ;
                if( bIncoming ) bIncoming = 0 ;
            {
            else
            }
                sock.writeF( tinBaseP , sIn ) ;
                sock.connectF( tinBaseP , idPortMin ) ;
                socketC sock( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;

                bIncoming = 0 ;
            {
            if( bIncoming && !bImplosion && idPort != idPortMin )

            CONoUTrAW( TF1(ideMe)+T(": received ")+TF1(idSerial)+T(" from ")+T(nnHim)+tcr ) ;

            stIdPort.ungrabF( tinBaseP ) ;
            countT idPortExplode2 = !bImplosion && stIdPort >= ideMe * 2 + 1 ? stIdPort[ ideMe * 2 + 1 ] : 0 ;
            countT idPortExplode1 = !bImplosion && stIdPort >= ideMe * 2     ? stIdPort[ ideMe * 2     ] : 0 ;
            countT idPortImplode  =  bImplosion && ideMe != 1                ? stIdPort[ ideMe / 2     ] : 0 ;
            countT idPortMin   = stIdPort[ 1 ] ;
            countT ideMe = stIdPort( idPort ) ;
            countT cRelays = stIdPort ;
            stIdPort.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

            osTextT* postIn      = sIn.pbFieldF( tinBaseP , countTC() , countTC() , countTC() , 9 ) ;
            countT   idCmd       = sIn.cFieldF( tinBaseP , 8 ) ;
            countT   idSerial    = sIn.cFieldF( tinBaseP , 7 ) ;
            nicNameC nnHim       = sIn.nicNameFieldF( tinBaseP , 6 ) ;
            countT&  idBang      = sIn.cFieldF( tinBaseP , 5 ) ;
            countT   bImplosion  = sIn.cFieldF( tinBaseP , 4 ) ;
            countT&  bIncoming   = sIn.cFieldF( tinBaseP , 3 ) ;
            countT   idFormat    = sIn.cFieldF( tinBaseP , 2 ) ;
            countT   fingerprint = sIn.cFieldF( tinBaseP , 1 ) ;

            pso->readF( tinBaseP , sIn ) ;
            soulC sIn( tinBaseP , TAG( TAGiDnULL ) ) ;

            countT idClient = 1 + incv02AM( offClientNext ) ;

            pso->etherF( tinBaseP , *((tinNormalS&)tinBaseP).zEtScratch ) ;
        {
        if( !ether && pso )

        sListen.acceptF( tinBaseP , pso , idPortPeer , nnPeer , countTC() ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        ZE( socketC* , pso ) ;
    {
    while( !etThread && !ether )
    sListen.listenF( tinBaseP ) ;

    stIdPort.sinkF( tinBaseP , countTC() , idPort , flSTACKsINK_UNIQUE ) ;
    countT idPort = sListen.bindF( tinBaseP ) ;
    socketC sListen( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;

    TN( tcr , "\r\n" ) ;

    static countT offClientNext ;

    osTextT* postWheel = (osTextT*)pTaskP->c3 ;
    osTextT* postSpoke = (osTextT*)pTaskP->c2 ;
    stackC& stIdPort   = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmServerF )

DONE( tmClientF )
}
    }
        }
            sock.writeF( tinBaseP , sOut ) ;
    
            sock.connectF( tinBaseP , stIdPort.randomF( tinBaseP ) ) ;
            socketC sock( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
    
            sOut << ostoOut ;
            sOut << (countT)IDcMDwRITE ;
            sOut << idSerial ;
            sOut << nnMe ;
            sOut << (countT)0 ; //idBang
            sOut << (countT)1 ; //bImplosion
            sOut << (countT)1 ; //bIncoming
            sOut << (countT)1 ; //idFormat
            sOut << (countT)FINGERnEG ;
            soulC sOut( tinBaseP , TAG( TAGiDnULL ) ) ;
    
            OStEXTV( ostoOut , "This is the day that the Lord has made.  Let us rejoice!\r\n" )
    
            countT idSerial = 1 + incv02AM( host.idSerialLath ) ;
            homeS& host = homeS::homeIF() ;
            nicNameC nnMe = socketC::nicNameIF( tinBaseP , etThread ) ;
        {
        if( idMe == 1 )
    {
    //while( !ether && !etThread )

    TN( tcr , "\r\n" ) ;
    TN( tJotPrefix , "" ) ; tJotPrefix = T("client ") + TF1(idMe) + T(": ") ;
    countT idMe = 1 + incv02AM( offNext ) ;
    static countT offNext ;

    stackC& stIdPort = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmClientF )

#define IDcMDwRITE 0x1
#define FINGERnEG 0x87654321
#define CcLIENTS 0x1
#define CsERVERS 0xf

/*1*/WAKEhIDE( "doodle.2.power.explosion.transient.connections" )/*1*/
/**/
*/
objective: explore distributed blob storage
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

