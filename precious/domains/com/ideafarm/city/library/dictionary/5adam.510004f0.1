
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.loafIF( tin0P ) ;

while( cTries -- ) etThread.osThreadF( tin0P , countTC() , tmClientF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&stIdPort ) ;
cTries = CcLIENTS ;

}
    }
        ++ s ; etThread.osSleepF( tin0P , TUCK * 0x40 ) ;
    {
    while( stIdPort < CsERVERS )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
{

while( cTries -- ) etThread.osThreadF( tin0P , countTC() , tmServerF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&stIdPort , (countT)(const osTextT*)ostoSpoke , (countT)(const osTextT*)ostoWheel ) ;
countT cTries = CsERVERS ;

OStEXTV( ostoWheel , "\r.a" )
OStEXTV( ostoSpoke , "|/-\\" ) // MUST BE LEN 4 EXCL TERMINATOR
stackC stIdPort( tin0P , etThread , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmServerF )
}
    }
        DEL( pso ) ;

        }
            *((tin9S&)tin0P).zEtScratch = 0 ;
            pso->readF( tin0P , sIn ) ; //WILL FAIL

            }
                }
                    }
                        sock.writeF( tin0P , sIn ) ;
                        sock.connectF( tin0P , idPortExplode2 ) ;
                        socketC sock( tin0P , etThread , TAG( TAGiDnULL ) ) ;
                    {
                    if( idPortExplode2 )
    
                    }
                        sock.writeF( tin0P , sIn ) ;
                        sock.connectF( tin0P , idPortExplode1 ) ;
                        socketC sock( tin0P , etThread , TAG( TAGiDnULL ) ) ;
                    {
                    if( idPortExplode1 )
                {
                else
                }
                    sock.writeF( tin0P , sIn ) ;
                    sock.connectF( tin0P , idPortImplode ) ;
                    socketC sock( tin0P , etThread , TAG( TAGiDnULL ) ) ;
                {
                if( idPortImplode )

                idBang ++ ;
                if( bIncoming ) bIncoming = 0 ;
            {
            else
            }
                sock.writeF( tin0P , sIn ) ;
                sock.connectF( tin0P , idPortMin ) ;
                socketC sock( tin0P , etThread , TAG( TAGiDnULL ) ) ;

                bIncoming = 0 ;
            {
            if( bIncoming && !bImplosion && idPort != idPortMin )

            CONoUTrAW( TF1(ideMe)+T(": received ")+TF1(idSerial)+T(" from ")+T(nnHim)+tcr ) ;

            stIdPort.ungrabF( tin0P ) ;
            countT idPortExplode2 = !bImplosion && stIdPort >= ideMe * 2 + 1 ? stIdPort[ ideMe * 2 + 1 ] : 0 ;
            countT idPortExplode1 = !bImplosion && stIdPort >= ideMe * 2     ? stIdPort[ ideMe * 2     ] : 0 ;
            countT idPortImplode  =  bImplosion && ideMe != 1                ? stIdPort[ ideMe / 2     ] : 0 ;
            countT idPortMin   = stIdPort[ 1 ] ;
            countT ideMe = stIdPort( idPort ) ;
            countT cRelays = stIdPort ;
            stIdPort.grabF( tin0P , TAG( TAGiDnULL ) ) ;

            osTextT* postIn      = sIn.pbFieldF( tin0P , countTC() , countTC() , countTC() , 9 ) ;
            countT   idCmd       = sIn.cFieldF( tin0P , 8 ) ;
            countT   idSerial    = sIn.cFieldF( tin0P , 7 ) ;
            nicNameC nnHim       = sIn.nicNameFieldF( tin0P , 6 ) ;
            countT&  idBang      = sIn.cFieldF( tin0P , 5 ) ;
            countT   bImplosion  = sIn.cFieldF( tin0P , 4 ) ;
            countT&  bIncoming   = sIn.cFieldF( tin0P , 3 ) ;
            countT   idFormat    = sIn.cFieldF( tin0P , 2 ) ;
            countT   fingerprint = sIn.cFieldF( tin0P , 1 ) ;

            pso->readF( tin0P , sIn ) ;
            soulC sIn( tin0P , TAG( TAGiDnULL ) ) ;

            countT idClient = 1 + incv02AM( offClientNext ) ;

            pso->etherF( tin0P , *((tin9S&)tin0P).zEtScratch ) ;
        {
        if( !ether && pso )

        sListen.acceptF( tin0P , pso , idPortPeer , nnPeer , countTC() ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        ZE( socketC* , pso ) ;
    {
    while( !etThread && !ether )
    sListen.listenF( tin0P ) ;

    stIdPort.sinkF( tin0P , countTC() , idPort , flSTACKsINK_UNIQUE ) ;
    countT idPort = sListen.bindF( tin0P ) ;
    socketC sListen( tin0P , etThread , TAG( TAGiDnULL ) ) ;

    TN( tcr , "\r\n" ) ;

    static countT offClientNext ;

    osTextT* postWheel = (osTextT*)pTaskP->c3 ;
    osTextT* postSpoke = (osTextT*)pTaskP->c2 ;
    stackC& stIdPort   = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmServerF )

DONE( tmClientF )
}
    }
        }
            sock.writeF( tin0P , sOut ) ;
    
            sock.connectF( tin0P , stIdPort.randomF( tin0P ) ) ;
            socketC sock( tin0P , etThread , TAG( TAGiDnULL ) ) ;
    
            sOut << ostoOut ;
            sOut << (countT)IDcMDwRITE ;
            sOut << idSerial ;
            sOut << nnMe ;
            sOut << (countT)0 ; //idBang
            sOut << (countT)1 ; //bImplosion
            sOut << (countT)1 ; //bIncoming
            sOut << (countT)1 ; //idFormat
            sOut << (countT)FINGERnEG ;
            soulC sOut( tin0P , TAG( TAGiDnULL ) ) ;
    
            OStEXTV( ostoOut , "This is the day that the Lord has made.  Let us rejoice!\r\n" )
    
            countT idSerial = 1 + incv02AM( host.idSerialLath ) ;
            homeS& host = homeS::homeIF() ;
            nicNameC nnMe = socketC::nicNameIF( tin0P , etThread ) ;
        {
        if( idMe == 1 )
    {
    //while( !ether && !etThread )

    TN( tcr , "\r\n" ) ;
    TN( tJotPrefix , "" ) ; tJotPrefix = T("client ") + TF1(idMe) + T(": ") ;
    countT idMe = 1 + incv02AM( offNext ) ;
    static countT offNext ;

    stackC& stIdPort = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmClientF )

#define IDcMDwRITE 0x1
#define FINGERnEG 0x87654321
#define CcLIENTS 0x1
#define CsERVERS 0xf

/*1*/WAKEhIDE( "doodle.2.power.explosion.transient.connections" )/*1*/
/**/
*/
objective: explore distributed blob storage
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

