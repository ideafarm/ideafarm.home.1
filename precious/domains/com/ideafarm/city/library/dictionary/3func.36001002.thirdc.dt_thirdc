
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        tinP.pag1->_thirdC_.cThirdObjects -- ;
        //}
        //    JOTA( ostob ) ;
        //    OStEXTAK( ostob , "-\r\n" ) ;
        //    OStEXTC( ostob , idLineCt , 0 ) ;
        //    OStEXTAK( ostob , "L" ) ;
        //    OStEXTC( ostob , idiFileCt , 0 ) ;
        //    OStEXTAK( ostob , "F" ) ;
        //    OStEXT( ostob , 0x100 )
        //{
    
        if( POOP & ~fliEC_QUITTING ) *this = 0 ;
        thirdTestF( tinP ) ;
    
        delF( tinP , postThreadNameMadeMe ) ;
        //delF( tinP , pcFunctionEntries ) ;
        //delF( tinP , pcFunctionExits   ) ;
        //delF( tinP , pcFunctionTime1   ) ;
        //delF( tinP , pcFunctionTime2   ) ;
    
        }
            tinP.pag1->_thirdC_.pStk_pThird->ungrabF( tinP ) ;
            tinP.pag1->_thirdC_.pStk_pThird->grabF( tinP , TAG( TAGiDnULL ) ) ;
    
            }
                }
                    ++ s ; thirdC::dosSleepRawIF( tinP , 250 ) ;
    
                    }
                        stThird.ungrabF( tinP ) ;
                        }
                            while( ~hDown ) ;
                            }
                                etherC::ifcSayIF( ostob , flSAY_LOG | flSAY_APPEND ) ;
                                OStEXTAK( ostob , "\r\n" ) ;
    
                                dosTellMonitorIF( tinP , tellC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEtELLsYS_LOG , ostob , ostob.costF() + 1 ) , ifcIDbOOKStELL_SYS ) ;
        
                                OStEXTAK( ostob , ")" ) ;
                                OStEXTC( ostob , pThird->idLineCt , 0 ) ;
                                OStEXTAK( ostob , "(" ) ;
                                OStEXTC( ostob , pThird->idiFileCt , 0 ) ;
                                OStEXTAK( ostob , ": " ) ;
                                OStEXTC( ostob , ++ ido , 0 ) ;
                                OStEXTAK( ostob , "leftover thirdC object " ) ;
                                OStEXT( ostob , 0x80 )
        
                                if( !pThird ) break ; // WILL HAPPEN IF *tinP.pag1->_thirdC_.pStk_pThird IS IMPOTENT
                                thirdC* pThird = (thirdC*)stThird.downF( tinP , hDown ) ;
                            {
                            do
                            handleC hDown( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            ZE( countT , ido ) ;
                        {
                        else
                        }
                            dosTellMonitorIF( tinP , tellC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEtELLsYS_LOG , ostom , ostom.costF() + 1 ) , ifcIDbOOKStELL_SYS ) ;
                            OStEXTV( ostom , "leftover thirdC object: tinP.pag1->_thirdC_.cThirdObjects is nonze but tinP.pag1->_thirdC_.pStk_pThird is empty" )
                        {
                        if( !stThird )
                        stThird.grabF( tinP , TAG( TAGiDnULL ) ) ;
    
                        stackC& stThird = *tinP.pag1->_thirdC_.pStk_pThird ;
                    {
                    if( !( ++ cCycle % 0x10 ) && tinP.pag1->_thirdC_.pStk_pThird )
                {
                /* if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_etThreadONmainISiMPOTENT ) ) */ while( tinP.pag1->_thirdC_.cThirdObjects > 2 )
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                ZE( countT , cCycle ) ;
            {
    
            }
                TELLsYSc3LIFI( ifcIDtYPEtELLsYS_FIREDdTP , (byteT*)&info , sizeof info , idLineCt , idiFileCt ) 
                countT info = (countT)&tinP.pag1->_thirdC_.bFired01 ;
            {
        {
        if( tinP.pag1->_thirdC_.pThPrime == this )
    
        }
            tinP.pag1->_thirdC_.pStk_pThird->ungrabF( tinP ) ;
            if( (*tinP.pag1->_thirdC_.pStk_pThird)( (countT)this ) ) tinP.pag1->_thirdC_.pStk_pThird->extractF( tinP ) ;
            tinP.pag1->_thirdC_.pStk_pThird->grabF( tinP , TAG( TAGiDnULL ) ) ;
        {
        if( tinP.pag1->_thirdC_.pStk_pThird && !( F(flagsMode) & flTHIRDmODE_DISABLEiNSPECTION ) )
        SCOOP
    {
    _IO_
    TINSL
{
/*1*/thirdC::~thirdC( voidT )/*1*/

/**/
*/
static applications only: for secondary thirdC objects, waits for POOP to be seen before doing anything
tests for integrity
  \<A HREF=\"5.1b00104.1.1.0.html\"\>1b00104:  WAKEsHOW( "example.simplest.func.1020002.thirdC.dt_thirdC" )\</A\>
 simplest
examples
\<A HREF=\"5.1020002.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

