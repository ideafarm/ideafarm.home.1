
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cItems ;

    else __1
    }
        }
            ether.delF( tin0P , pstt1m ) ;
            soulP << pstt1m ;
        {
        if( pstt1m  )

        ether.delF( tin0P , psttR ) ;
        cItems = ether.diskFindFileOrDirF( tin0P , pstt1m , fnLike.pathF() , &pat , flDISKfIND_null , &soulP , pGrabP , 0 , cMaxP ) ; ___( pstt1m ) ;
        ZE( strokeS* , pstt1m ) ;
        
        patternC pat( tin0P , ether , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        fileNameC fnLike( tin0P , ether , psttR ) ;

        ether.strFuseF( tin0P , psttR , psttName ) ; ___( psttR ) ;
        ether.strMakeF( tin0P , LF , psttR , T("///hose/") , psttName->idAdam ) ; ___( psttR ) ;
        ZE( strokeS* , psttR ) ;
    {
    else if( !psttHost->idAdam && !ether.strCompareF( tin0P , psttType , T("hose") ) )
    }
        }
            ether.delF( tin0P , pstt1m ) ;
            soulP << pstt1m ;
        {
        if( pstt1m )

        ether.delF( tin0P , psttM ) ;
        cItems = ether.diskFindFileOrDirF( tin0P , pstt1m , fnLike.pathF() , &pat , flDISKfIND_null , &soulP , pGrabP , 0 , cMaxP ) ; ___( pstt1m ) ;
        ZE( strokeS* , pstt1m ) ;

        patternC pat( tin0P , ether , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        fileNameC fnLike( tin0P , ether , psttM ) ;

        //U::SOUL: cItems = ether.diskFindFileOrDirF( tin0P , soulP , fnLike.pathF() , &pat , 0 , cMaxP ) ;
        //U::patternC pat( tin0P , ether , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        //U::fileNameC fnLike( tin0P , ether , psttM ) ;

        ether.delF( tin0P , psttR ) ;
        ether.diskMapFileNameF( tin0P , psttM , psttR ) ; ___( psttM ) ;
        ZE( strokeS* , psttM ) ;
        ether.strFuseF( tin0P , psttR , psttName ) ; ___( psttR ) ;
        ether.strMakeF( tin0P , LF , psttR , T("///") , psttName->idAdam ) ; ___( psttR ) ;
        ZE( strokeS* , psttR ) ;
    {
    else if( !psttHost->idAdam && !psttType->idAdam )
    }
        ether.delF( tin0P , psttRaw ) ;
        ether.delF( tin0P , psttWord ) ;
        ether.strFuseSeparateF( tin0P , soulP , psttWord , 0 , 0 , pGrabP ) ;
        ether.strSubstringF( tin0P , psttWord , idf , sttq , S1C(' ') , psttRaw ) ; ___( psttWord ) ;
        ether.delF( tin0P , psttWord ) ;
        ether.strFuseSeparateF( tin0P , soulP , psttWord , 0 , 0 , pGrabP ) ;
        ether.strSubstringF( tin0P , psttWord , idf , sttq , S1C(' ') , psttRaw ) ; ___( psttWord ) ;
        ether.delF( tin0P , psttWord ) ;
        ether.strSubstringF( tin0P , psttWord , idf , sttq , S1C(' ') , psttRaw ) ; ___( psttWord ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;
        ZE( strokeS* , psttWord ) ;
        }
            __( rc != 211 ) ;
            countT rc = pSControl->readWoReplyF( tin0P , psttRaw ) ; ___( psttRaw ) ;
        {
        if( !POOP )
        { textC txt = T("group ")+T(psttName)+T("\r\n") ; pSControl->writeF( tin0P , (osTextT*)txt ) ; }
        ZE( strokeS* , psttRaw ) ;
    {
    else if( psttHost->idAdam && !ether.strCompareF( tin0P , psttType , T("news") ) && pSControl )
    }
        ether.delF( tin0P , psttReply ) ;

        }
            if( idf ) { ether.strSubstringF( tin0P , psttLine , idf , sttq , T("\r\n") , psttReply ) ; ___( psttLine ) ; }
            ether.delF( tin0P , psttLine ) ;
            }
                }
                    ether.strFuseSeparateF( tin0P , soulP , TF1(idi)+T(" ")+TF1(cbi) , 0 , 0 , pGrabP ) ;
                    cItems ++ ;

                    }
                        ether.delF( tin0P , psttw ) ;
                        cbi = ether.strDigitsToSCountF( tin0P , psttw , 0xa , 1 ) ;
                        ether.strSubstringF( tin0P , psttw , idf , sttq , T(" ") , psttLine , 1 ) ; ___( psttw ) ;

                        ether.delF( tin0P , psttw ) ;
                        idi = ether.strDigitsToSCountF( tin0P , psttw , 0xa , 1 ) ;
                        ether.strSubstringF( tin0P , psttw , idf , sttq , T(" ") , psttLine , 1 ) ; ___( psttw ) ;

                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                        countT idf = 1 ;
                        ZE( strokeS* , psttw ) ;
                    {
                    ZE( countT , cbi ) ;
                    ZE( countT , idi ) ;
                {
                if( !cMaxP || cItems < cMaxP )
            {
            if( psttLine->idAdam )
        {
        while( !ether && psttLine )
        ether.strSubstringF( tin0P , psttLine , idf , sttq , T("\r\n") , psttReply ) ; ___( psttLine ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;
        ZE( strokeS* , psttLine ) ;

        pSControl->readWoMultilineF( tin0P , psttReply , T(".") , TUCK/*csttEstimateP*//*U::SOUL*/ ) ; ___( psttReply ) ;
        ZE( strokeS* , psttReply ) ;

        verifyReplyF( tin0P ) ;
        pSControl->writeF( tin0P , (osTextT*)T("list\r\n") ) ;
    {
    else if( psttHost->idAdam && !ether.strCompareF( tin0P , psttType , T("pop") ) && pSControl )
    }
        verifyReplyF( tin0P , 226 ) ;
        verifyReplyF( tin0P , 150 ) ;

        }
            ether.delF( tin0P , pstt1Prefix ) ;
            ether.delF( tin0P , psttEntry ) ;
            __NZ( psttEntry ) ;
            }
                }
                    ether.strFuseF( tin0P , psttEntry , psttIn4 ) ; ___( psttEntry ) ;
                    if( !psttEntry ) { ether.strMakeF( tin0P , LF , psttEntry , pstt1Prefix ) ; ___( psttEntry ) ; }
                    psttIn4[ CSpREFIX ] = bIn ;
                {
                else
                }
                    ether.delF( tin0P , psttEntry ) ;
                    }
                        ether.strFuseSeparateF( tin0P , soulP , psttEntry , 0 , 0 , pGrabP ) ;
                        cItems ++ ;
                    {
                    if( !cMaxP || cItems < cMaxP )
                {
                if( bIn == '\n' )

                cbIn ++ ;
            {
            while( !ether && sData.readF( tin0P , &bIn , 1 , flSOCKETcrEAD_STILLhUNGRYiSoK ) )
            psttIn4[ CSpREFIX ] = 0 ;
            SETpREFIX( psttIn4 , 1 , 0 ) ;
            strokeS psttIn4[ CSpREFIX + 1 ] ;
            ZE( byteT , bIn ) ;
            ZE( countT , cbIn ) ;

            ZE( strokeS* , psttEntry ) ;

            ether.strFuseF( tin0P , pstt1Prefix , T("///") ) ; ___( pstt1Prefix ) ;
            ether.strFuseF( tin0P , pstt1Prefix , psttType ) ; ___( pstt1Prefix ) ;
            ether.strFuseF( tin0P , pstt1Prefix , T("/") ) ; ___( pstt1Prefix ) ;
            ether.strMakeF( tin0P , LF , pstt1Prefix , psttHost , 4 + ( psttType ? psttType->idAdam : 0 ) ) ; ___( pstt1Prefix ) ;
            ZE( strokeS* , pstt1Prefix ) ;
        {
        if( !POOP )

        sData.connectF( tin0P , idPortData , nicNameData ) ;
        socketC sData( tin0P , ether , TAG( TAGiDnULL ) ) ;

        { textC txt = T("nlst ")+T(psttName)+T("\r\n") ; pSControl->writeF( tin0P , (osTextT*)txt ) ; }

        }
            __Z( idPortData ) ;
            __Z( nicNameData ) ;
            __( rc != 227 ) ;
            ether.delF( tin0P , psttReply ) ;
            readNicNameIdPortF( tin0P , nicNameData , idPortData , psttReply ) ;
            countT rc = pSControl->readWoReplyF( tin0P , psttReply ) ; ___( psttReply ) ;
            ZE( strokeS* , psttReply ) ;
        {
        if( !POOP )
        ZE( countT , idPortData ) ;
        nicNameC nicNameData ;

        pSControl->writeF( tin0P , (osTextT*)T("pasv\r\n") ) ;
    {
    if( psttHost->idAdam && !ether.strCompareF( tin0P , psttType , T("ftp") ) && pSControl )

    ZE( countT , cItems ) ;

    _IO_

    }
        if( POOP ) return 0 ;
        __Z( psttName ) ;
        __Z( psttType ) ;
        __Z( psttHost ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/countT boxC::menuF( tin0S& tin0P , soulC& soulP , grabC* pGrabP , const countT cMaxP )/*1*/
/**/
*/
  if not 0 then this is the maximum nunber of items reported in pstt1P and in the returned value
  can be 0
 cMaxP
 pGrabP
 soulP
arguments
this function will fail if the resulting length of pstt1P would be larger than about 0x100000 strokes
evaluates to the number of matching items
 //hose/name: lists the hoses that match /hose/name
 ///name: lists the files that match //name
  each line consists of two numbers separated by a blank
 host//news/group: obtains the range of item id's available for the group
   the second number is the item's size, in bytes
   the first number is the item's id
  each line consists of two numbers separated by a blank
 host//pop:  obtains a list of the mail items waiting to be retrieved
 host//ftp/name:  obtains the "nlst name"
obtains a menu
  \<A HREF=\"5.c120104.1.1.0.html\"\>c120104:  WAKEsHOW( "example.simplest.func.109000e.boxC.menuF" )\</A\>
  \<A HREF=\"5.1a20104.1.1.0.html\"\>1a20104:  WAKEsHOW( "example.simplest.func.109000e.boxC.menuF" )\</A\>
 simplest
examples
\<A HREF=\"5.109000e.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$menuF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

