
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bCallerMustDelete ;

    //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: 0 [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    THREADmODE3rESTORE

    }
        grabBookNow.ungrabF( tin0P ) ;

        }
            }
                if( cRefWas == -1 ) { BLAMMO ; }

                //}
                //    etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_LOOP | flTRACE_PARAMETERiSoStEXT ) ;
                //
                //    OStEXTAK( ostoSay , " +" ) ;
                //    OStEXTC(  ostoSay , cRefWas , 0 ) ;
                //    OStEXTAK( ostoSay , "    " ) ;
                //    OStEXTC(  ostoSay , pcRef , 0 ) ;
                //    OStEXTAK( ostoSay , "    " ) ;
                //    OStEXTCmIN( ostoSay , this , 8 ) ;
                //    OStEXTAK( ostoSay , "booksC [this,pcRef,cRefWas]:    " ) ;
                //    OStEXT(   ostoSay , TUCK << 2 ) ;
                //{
                //if( ((tin1S&)tin0P).pag1->idAdam == ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE1 )
        
                countT cRefWas = incv02AM( *pcRef ) ;
                countT* pcRef = &head.cRef ;
            {
            else
            }
                if( cRefWas == -1 ) { BLAMMO ; }
                countT cRefWas = incv02AM( head.cRef ) ;
            {
            if( !((tin1S&)tin0P).pEther )
        
            bookHeadS& head = BOOKnOW ;
        {
        if( pbP && F(flagsP) & flBOOKScrEAD_INCREMENTrEFERENCEcOUNTiF && !bCallerMustDelete )    //20181210@1318: ADDED "&& !bCallerMustDelete" BECAUSE I AM RETURNING A pbP THAT POINTS TO A poolC DROP RATHER THAN INTO A bookC INSTANCE

        }
            }
                PUSE( tin0P , pbw ) ;
                stSnip >> pbw ;
                ZE( byteT* , pbw ) ;
            {
            while( stSnip )
        {
        else
        }
            //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: 1 [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                }
                    *pbo = 0 ;
                    if( pbzSnip && cbzSnip ) { thirdC::c_memcpyIF( tin0P , pbo , pbzSnip , cbzSnip ) ; pbo += cbzSnip ; }

                    }
                        PUSE( tin0P , pbw ) ;
                        thirdC::c_memcpyIF( tin0P , pbo , pbw + sizeof( countT ) , *(countT*)pbw ) ; pbo += *(countT*)pbw ;
                        stSnip >> pbw ;
                        ZE( byteT* , pbw ) ;
                    {
                    while( stSnip )
                    byteT* pbo = (byteT*)pbP ;
                {
                if( !POOP )

                cbP = cbaAll ; //20131204@1219: ADDED WITHOUT ANALYSIS
                __Z( pbP ) ;
                PUSE.newF( tin0P , LF , *(byteT**)&pbP , cbaAll + 1 ) ; ___( pbP ) ;
            {
            if( cbaAll )

            __NZ( pbP ) ;

            while( ~hWalk ) ;
            }
                cbaAll += *(countT*)pbw ;
                byteT* pbw = (byteT*)stSnip.downF( tin0P , hWalk ) ;
            {
            do
            countT cbaAll = cbzSnip ;

            handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

            __NZ( F(flagsP) & flBOOKScrEAD_CURRENTbOOKoNLY ) ;

            //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: 2 [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        else if( !bQuit )                                                       //U:: 20250124@1120: CONJ: !!bCallerMustDelete IS IMPOSSIBLE IF bNullRead
        }
            //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: 3 [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                cbP = cbzSnip ;
                pbP = pbzSnip ;
            {
            else if( cbzSnip || bNullRead )
            if( !pbzSnip ) cbP = 0 ;

            //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: 4 [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        else if( !bCallerMustDelete )
        if( POOP ) ;
        bCallerMustDelete = stSnip ;

        //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: 5 [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        }
            if( bNullRead ) break ;

            }
                }
                    //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: 6 [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    else                                                           cbToDo  = 0       ;
                    if( cbzSnip && !( F(flagsP) & flBOOKScrEAD_CURRENTbOOKoNLY ) ) cbToDo -= cbzSnip ;

                    //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: 7 [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    }
                        }
                            pBook->writeF( tin0P , flResult , (byteT*)&c2AppNote , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLoRnONE | flBOOK0cwRITE_PURGEiFfULL ) ;
                            countT cb1 = sizeof c2AppNote ;
                            ZE( flagsT , flResult ) ;
                            bookC* pBook = (bookC*)phCursorP->osF( ifcIDtYPEhANDLE_BOOKSrEADcURSOR ) ;
                        {
                        if( pbzSnip && phCursorP && ~*phCursorP )          //PSEUDOdUPLICATEcODE: 360fb006 360fb006
                        //IF READ SUCCEEDED THEN ADVANCE PERSISTENT CURSOR *phCursorP

                        //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U::  [pbzSnip,cbzSnip]:    ")+tb4+TF2((countT)pbzSnip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbzSnip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        BOOKnOW.readF( tin0P , pbzSnip , cbzSnip , c2AppNote.c1 ) ;
                        cbzSnip = cbToDo ;
                    {
                    if( cbToDo || bNullRead )

                    //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: 8 [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    __NZ( cbzSnip ) ;
                    __NZ( pbzSnip ) ;
                    }
                        cbzSnip = 0 ;
                        pbzSnip = 0 ;

                        }
                            }
                                stSnip << pbw ; pbw = 0 ;
                                thirdC::c_memcpyIF( tin0P , pbw + sizeof( countT ) , pbzSnip , cbzSnip ) ;
                                *(countT*)pbw = cbzSnip ;
                            {
                            if( !POOP )

                            __Z( pbw ) ;
                            PUSE.newF( tin0P , LF , *(byteT**)&pbw , sizeof( countT ) + cbzSnip ) ; ___( pbw ) ;
                            ZE( byteT* , pbw ) ;
                        {
                        if( !POOP )

                        if( !bStackUsed ) bStackUsed = 1 ;
                        __Z( cbzSnip ) ;

                        //if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / prior snip [pbzSnip,cbzSnip]:    ")+TF2((countT)pbzSnip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cbzSnip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( pbzSnip )
                    // MOVE A PRIOR SNIP OUT OF THE WAY
                {

                //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: 9 [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                }
                    if( POOP ) break ;
                    __Z( cbToDo ) ;                                                                                                         // SHOULD BE IMPOSSIBLE
                    cbToDo = head.cbUsed - head.cbFill - c2AppNote.c1 ;
                {
                if( cbToDo == - 1 )                                             // -1 INDICATES THAT CALLER WANTS ME TO RETURN THE REMAINDER OF THE BOOK

                bookHeadS& head = BOOKnOW ;
            {
            if( cbToDo || bNullRead )

            //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: a [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            if( bHandleAdjusted ) continue ;

            }
                }
                    }
                        }
                            pBook->writeF( tin0P , flResult , (byteT*)&c2AppNote , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLoRnONE | flBOOK0cwRITE_PURGEiFfULL ) ;
                            countT cb1 = sizeof c2AppNote ;
                            ZE( flagsT , flResult ) ;
                            bookC* pBook = (bookC*)phCursorP->osF( ifcIDtYPEhANDLE_BOOKSrEADcURSOR ) ;
                        {
                        if( phCursorP && ~*phCursorP )          //PSEUDOdUPLICATEcODE: 360fb006 360fb006

                        c2AppNote.c2 = pcpOffIdBookWant[ 2 ] ;
                        c2AppNote.c1 = pcpOffIdBookWant[ 1 ] ;
                        handleP.osF( ifcIDtYPEhANDLE_BOOKS , FINGERnEG_HANDLEbOOKSjOT ) ;

                        handleP.closeIfF() ;

                        __Z( pcpOffIdBookWant[ 2 ] ) ;                                                                                              // ONLY LENGTH 1 IDbOOK STRINGS ARE ALLOWED.  FOR MORE CAPACITY, EDIT THIS CODE AND INCREASE THE SIZE OF handleC::c2AppNote
                        pcpOffIdBookWant[ 2 ] ++ ;
                        pcpOffIdBookWant[ 1 ] = 0 ;

                        bHandleAdjusted = 1 ;

                        }
                            }
                                break ;
                                cbToDo = 0 ;
                            {
                            if( POOP || pcpOffIdBookWant[ 2 ] >= pcpIdBookMax[ 1 ] )
                            __( pcpIdBookMax[ 0 ] - 1 ) ;                                                                                           // ONLY LENGTH 1 IDbOOK STRINGS ARE ALLOWED.  FOR MORE CAPACITY, EDIT THIS CODE AND INCREASE THE SIZE OF handleC::c2AppNote
                            idBookMinMaxF( tin0P , pcpIdBookMin , pcpIdBookMax , flBOOKScsELECT_null , &bQuit ) ;
                        {
                        if( idStateSpace )
                        ZE( countT* , pcpIdBookMax ) ;
                        ZE( countT* , pcpIdBookMin ) ;
                    {
                    else if( head.cbUsed == head.cbBody )
                    }
                        break ;
                        cbToDo = 0 ;
                    {
                    if( head.cbUsed < head.cbBody )
                {
                else if( c2AppNote.c1 == offe )
                if( POOP ) break ;
                __( offe        < c2AppNote.c1 ) ;
                __( head.cbUsed < head.cbFill  ) ;
                countT offe = head.cbUsed - head.cbFill ;
                bookHeadS& head = BOOKnOW ;
            {
            ZE( boolT , bHandleAdjusted ) ;                                                                                                                                   //ADJUST handleP IF IT POINTS TO THE END OF THE CURRENT BOOK

            //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: b [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                }
                    THREADmODE3rESTORE
                    THREADmODE1rESTORE ;
                    }
                        NEWbOOK2sETfLAG
                        new( 0 , tin0P , PBbOOKbACKnOW , SIZEOF_bookC ) bookC( tin0P , TAG( TAGiDnULL ) , tName , idStateSpace , flagsCtBook & ~( F(flBOOKSc_WRITER) ) , 0 , bFill , idMemorySpace ) ; // A:ASSUME: CALLER ALWAYS WANTS TO READ THE NEW BOOK ; TO SUPPORT A WRITER, A FLAG CAN BE DEFINED TO CHANGE THIS BEHAVIOR
                        NEWbOOK1bLAMMOiFcT

                        //CONoUTrAW( "\r\n" ) ;
                        //CONoUTrAW( tName ) ;
                        //CONoUTrAW( "opening " ) ;
                    {
                    else
                    }
                        offBookBackNow -- ;
                        PUSE( tin0P , *(byteT**)&PCPiDbOOKnOW ) ; //AT THE BEGINNING OF THIS BLOCK, I DELETED THIS BOOK.  CODE THAT LOOKS AT THE BOOK INSTANCES MUST CHECK FOR !PCPiDbOOKnOW TO AVOID ACCESSING A DELETED INSTANCE.  RACE CONDITION EXIST IF MULTIPLE THREADS ARE READING, BUT MULTITHREADED READING PROBABLY IS UNSUPPORTABLE ANYWAY
                        cbToDo = 0 ;
                    {
                    if( F(flagsP) & flBOOKScrEAD_STILLhUNGRYiSoK && !bookC::bFileExistsIF( tin0P , *((tin1S&)tin0P).pEther , tName , 0 , idStateSpace , idMemorySpace , flagsCtBook ) )
                    THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )

                    //20181107@1116: THIS BUG WAS WORKED AROUND BY EDITING OTHER CODE SO THAT THIS CODE ISN'T EXERCIZED.  THIS CODE IS INCORRECT.  CORRECT CODE WILL AVOID DELETING A bookC AND THEN ATTEMPTING TO UNDO THAT DELETION
                    //U:: BUG: THIS WILL CREATE A ZOMBIE POINTER TO book0C; REWRITE TO AVOID DELETING THE BOOK

                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;

                    ;
                        : T(postPath)+T(postShort)+T(".booksC.1.book.")+tIdBook
                        ? T(postShort)+T(".booksC.1.book.")+tIdBook
                    TN( tName , "" ) ; tName = !*postPath

                    }
                        for( countT offi = *PCPiDbOOKnOW ; offi ; offi -- ) tIdBook += tDot+TF3(PCPiDbOOKnOW[offi],flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ;
                        TN( tDot , "." ) ;
                        tIdBook = TF3(*PCPiDbOOKnOW,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ;
                    {
                    TN( tIdBook , "" ) ;

                    thirdC::c_memcpyIF( tin0P , (byteT*)( PCPiDbOOKnOW + 1 ) , (byteT*)( pcpOffIdBookWant + 2 ) , sizeof( countT ) * ( *pcpOffIdBookWant - 1 ) ) ;
                    *PCPiDbOOKnOW = *pcpOffIdBookWant - 1 ;
                    PUSE.newF( tin0P , LF , *(byteT**)&PCPiDbOOKnOW , sizeof( countT ) * *pcpOffIdBookWant ) ; ___( PCPiDbOOKnOW ) ;

                    PUSE( tin0P , *(byteT**)&PCPiDbOOKnOW ) ;
                    DELzOMBIEbOOKbACKnOWiF
                    offBookBackNow ++ ;

                    //}
                    //    ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / ct'ing a book") ) ;
                    //{
                    //if( ((tin1S&)tin0P).pc Utility[ 0 ] )
                {
                if( !bFound )

                }
                    if( !bFound ) offBookBackNow = save ;

                    }
                        }
                            break ;
                            bFound = 1 ;
                            //LOGrAW3( "found! setting [offBookBackNow]:    " , offBookBackNow , "\r\n" ) ;
                        {
                        if( PCPiDbOOKnOW && *pcpOffIdBookWant - 1 == *PCPiDbOOKnOW && !thirdC::c_memcmpIF( tin0P , (byteT*)( pcpOffIdBookWant + 2 ) , (byteT*)( PCPiDbOOKnOW + 1 ) , sizeof( countT ) * *PCPiDbOOKnOW ) )
                        offBookBackNow ++ ;
                    {
                    while( cDo -- )
                    countT cDo = CbOOKsLOTS - 1 ; // "- 1" BECAUSE ALREADY KNOW THAT CURRENT BOOK IS WRONG
                    countT save = offBookBackNow ;
                {
                ZE( boolT , bFound ) ;
            {
            if( bWrongBook )

            //if( bWrongBook ) { LOGrAW5( "[offBookBackNow,bWrongBook]:    " , offBookBackNow , "    " , bWrongBook , "\r\n" ) ; }

            }
                else        continue ;
                if( bQuit ) break ;
            
                grabBookNow.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                THREADmODE1rESTORE
                }
                    ++ s ; thirdC::dosSleepWinkIF( tin0P ) ; // THIS SHOULD BE LONG ENOUGH TO MAKE IT UNLIKELY THAT I WILL GET LUCKY AND "GET IN" IF ANOTHER THREAD IS ACTIVELY READING THE CURRENT BOOK
                    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                {
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                grabBookNow.ungrabF( tin0P ) ;
            {
            if( bWrongBook && ((bookHeadS&)BOOKnOW).cRef )
            //20180707@0801: RESTORED: MUST DO THIS NOW BECAUSE BLOCKING DURING DT WILL RESULT IN DEADLOCK SINCE I HAVE GRABBED grabBookNow
            //20180620@2009: ELIMINATED WITHOUT ANALYSIS: cRef MIGHT WELL BE NONZE AND THAT IS TAKEN CARE OF BY cKeepInactive AND BY DT'OR

            //}
            //    CONoUTrAW( ostoSay ) ;
            //
            //    OStEXTAK( ostoSay , "\r\n" ) ;
            //    OStEXTC(  ostoSay , PCPiDbOOKnOW[ 1 ] , 0 ) ;
            //    OStEXTAK( ostoSay , "    " ) ;
            //    OStEXTC(  ostoSay , pcpOffIdBookWant[ 2 ] , 0 ) ;
            //    OStEXTAK( ostoSay , "    " ) ;
            //    OStEXTC(  ostoSay , this , 0 ) ;
            //    OStEXTAK( ostoSay , "    " ) ;
            //    OStEXTA(  ostoSay , ((tin123S&)tin0P).postThreadName ) ;
            //    OStEXTAK( ostoSay , "    " ) ;
            //    OStEXTC(  ostoSay , ((tin1S&)tin0P).glass.idThread , 0 ) ;
            //    OStEXTAK( ostoSay , "\r\nbooksC::readF/ wants book [idThread,postThreadName,this,idBookWant,idBookHave]:    " ) ;
            //    OStEXT(   ostoSay , TUCK << 2 ) ;
            //{
            //if( bWrongBook )

            }
                ;
        
                    thirdC::c_memcmpIF( tin0P , (byteT*)pcWant , (byteT*)pcNow , sizeof( countT ) * ccNow )
                    ||
                    *pcpOffIdBookWant - 1 != *PCPiDbOOKnOW
    
                bWrongBook =

                //}
                //    ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / book [have,want]:")+T("    ")+TF2(*pcNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(*pcWant,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                //{
                //if( ((tin1S&)tin0P).pc Utility[ 0 ] )

                countT* pcWant =  pcpOffIdBookWant + 2 ;
                countT* pcNow  =  PCPiDbOOKnOW     + 1 ;
                countT  ccNow  = *PCPiDbOOKnOW         ;
            {
            ZE( boolT , bWrongBook ) ;

            //}
            //    ((tin1S&)tin0P).pEther->trace F( tin0P , T("booksC::readF / wanted [offInBook,idBook]:")+T("    ")+TF2(pcpOffIdBookWant[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pcpOffIdBookWant[2],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG
            //    offWantedLath = offWanted ;
            //{
            //if( ((tin1S&)tin0P).pc Utility[ 0 ] /*&& offWanted >> 0x10 != offWantedLath >> 0x10*/ )
            countT offWanted = pcpOffIdBookWant[ 1 ] ;
            //static countT offWantedLath ; //U:: TO FIND A BUG

            //LOAD THE BOOK THAT I WANT TO READ FROM

            countT pcpOffIdBookWant[] = { 2 , c2AppNote.c1 , c2AppNote.c2 } ;
            HANDLEaPPnOTEScOUNTcLASS& c2AppNote = handleP ;

            //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: c [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {                                                                                                                                       //20140508@1952: LOOP NOW ALSO IS USED TO BLOCK IF I WANT TO CHANGE BOOKS AND THE CURRENT BOOK HAS A PENDING SMART POINTER
        while( ( cbToDo || bNullRead ) && ~handleP )                                                                                            // THE ONLY PURPOSE OF LOOPING IS TO OBTAIN A BLOB SPANNED OVER MULTIPLE BOOKS; WILL BREAK OUT OF LOOP IF F(flagsP) & flBOOKScrEAD_CURRENTbOOKoNLY
        ZE( boolT , bBecameMaster ) ;
        ZE( boolT , bStackUsed ) ;
        stackC stSnip( tin0P , *((tin1S&)tin0P).pEther , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY , ifcSTACKtYPE_PTR_byteT ) ;
        ZE( countT , cbzSnip ) ;
        ZE( const byteT* , pbzSnip ) ; //AFTER LOOP, WILL CONTAIN THE LATH SNIP RETRIEVED
        countT cbToDo = cbP ;

        grabBookNow.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {
    if( ~handleP )                                                                                                                              //20210705@0924: ADDED
    ZE( boolT , bCallerMustDelete ) ;

    }
        if( bQuit ) handleP.resetF() ;

        }
            c2AppNote.c2 = pcpIdBookMin && pcpIdBookMin[ 0 ] == 1 ? pcpIdBookMin[ 1 ] : 1 ; //20210705@0924: NO CHANGE TO MY CODE SINCE IT ALREADY TESTS WHETHER pcpIdBookMin

            //c2AppNote.c2 = PCPiDbOOKnOW[ 1 ] ;  //20140831@1232: CHANGED WITHOUT ANALYSIS SO THAT NULL HANDLE WILL DEFAULT TO BEGINNING OF WOTH BOOK RATHER THAN CURRENT BOOK
            c2AppNote.c1 = 0 ;

            if( idStateSpace ) idBookMinMaxF( tin0P , pcpIdBookMin , pcpIdBookMax , flBOOKScsELECT_null , &bQuit ) ;  //20210705@0924: idBookMinMaxF NOW NO LONGER SETS IMPOTENCE IF QUITTING AND NO BOOK EVER FOUND
            ZE( countT* , pcpIdBookMax ) ;
            ZE( countT* , pcpIdBookMin ) ;
        {
        if( !c2AppNote.c2 ) // 20140427@1312: IF CALLER HAS INITIALIZED c2AppNote.c2 THEN I WILL USE THEM ; THIS ENABLES CALLER TO BEGIN READING AT A POINT OTHER THAN THE BEGINNING OF THE WOTH BOOK

        c2AppNote = cursor ;

        HANDLEaPPnOTEScOUNTcLASS& c2AppNote = handleP ;
        handleP.osF( ifcIDtYPEhANDLE_BOOKS , FINGERnEG_HANDLEbOOKSjOT ) ;
    {
    if( !handleP )

    }
        else cursor = *phCursorP ;
        }
            }
                }
                    if( pbzi ) cursor = *(HANDLEaPPnOTEScOUNTcLASS*)pbzi ;      //WILL SILENTLY DO NOTHING IF BACKING FILE IS TOO SMALL
                    pBook->readF( tin0P , pbzi , cbzi , offi ) ;
                    ZE( countT , offi ) ;
                    countT cbzi = sizeof cursor ;
                    ZE( const byteT* , pbzi ) ;
                {
                if( F(flResult) & flBOOK0cwRITErESULT_COULDnOTwRITEaLL )

                phCursorP->osF( ifcIDtYPEhANDLE_BOOKSrEADcURSOR , (countT)pBook ) ;
                pBook->writeF( tin0P , flResult , (byteT*)&ze , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLoRnONE ) ; //FORMATS IFF NOT YET FORMATTED
                countT cb1 = sizeof ze ;
                ZE( flagsT , flResult ) ;

                HANDLEaPPnOTEScOUNTcLASS ze ;
            {
            if( !POOP )
            __Z( pBook ) ;
            bookC* pBook = new( 0 , tin0P , LF ) bookC( tin0P , TAG( TAGiDnULL ) , tName , ifcIDsTATEsPACE_SINGLEaDAM( tin0P ) , flBOOKc_WRITER | flBOOKc_PRIORbOOKnOTcONTINUEDhERE , sizeof HANDLEaPPnOTEScOUNTcLASS ) ;
            TN( tName , "" ) ; tName = T("bkCursor.")+TF3(((tin1S&)tin0P).pag1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(".")+TF3(idCursorP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ;
        {
        if( !*phCursorP )
    {
    if( phCursorP )
    HANDLEaPPnOTEScOUNTcLASS cursor ;

    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )

    const boolT& bQuit = pbQuitP ? *pbQuitP : bnu ;
    ZE( boolT , bnu ) ;

    const boolT bNullRead = !cbP ; //20231114@1246: SUPPORT "NULL READ", WHICH SETS pbP BUT DOES NOT ADVANCE THE OFFSET

    //if( ((tin123S&)tin0P).pcUtility[ 0 ] ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("booksC::readF / U:: d [pbP,cbP]:    ")+tb4+TF2((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    TN( tb4 , "    " ) ;

    _IO_

    }
        if( POOP ) return 0 ;
        }
            __( idType - ifcIDtYPEhANDLE_BOOKSrEADcURSOR ) ;
            countT idType = phCursorP->idTypeF() ;
        {
        else
        }
            //U:: ENABLE IN PRODUCTION AFTER COMPLETING CRAFTWORK TO SUPPORT phCursorP: __( idCursorP - 1 ) ;  // DEFAULT VALUE IS 1, WHICH SHOULD NEVER BE OVERRIDDEN IF phCursorP 0 (IF 0 THEN idCursorP IS IGNORED)
        {
        if( !phCursorP )
        FV( flBOOKScrEAD , flagsP ) ;
        __( *PCPiDbOOKnOW != 1 ) ; // IDbOOK VALUES ARE UNLIMITED.  BUT ONLY LENGTH 1 IDbOOK VALUES CAN BE STORED WITHIN A handleC.  FOR MORE CAPACITY, INCREASE THE SIZE OF handleC::c2AppNote
        __( !((tin1S&)tin0P).pPoolUse ) ; // booksC INSTANCES CAN BE CT/DT AND WRITTEN TO EARLY AND LATE, BUT readF CAN ONLY BE CALLED WHEN PUSE EXISTS
        //__Z( cbP ) ;
        __NZ( pbP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/boolT booksC::readF( tin0S& tin0P , const byteT*& pbP , countT& cbP , handleC& handleP , const flagsT flagsP , const boolT* pbQuitP , handleC* const phCursorP , const countT idCursorP )/*1*/

//20231114@1238: UNDO THAT ; NOW !cbP MEANS EXACTLY THAT: DO A READ AT THE CURRENT OFFSET BUT DO NOT ADVANCE THE OFFSET (TO READ REMAINDER, SET cb1P TO - 1 AND SPECIFY flBOOKScrEAD_STILLhUNGRYiSoK ; (CODE WAS CHANGED IN WO PLACE THAT USED 0)
//20180816@1429: ENHANCE TO READ REMAINDER OF CURRENT BOOK IF !cbP

/**/
*/
 idCursorP
 pbQuitP
 flagsP
 handleP
  if 0 then i read the remainder of the current book
 cbP
 pbP
 tin0P
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

