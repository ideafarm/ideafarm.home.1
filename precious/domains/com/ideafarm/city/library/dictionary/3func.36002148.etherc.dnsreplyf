
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        cbP = cba ;
        }
            __( pbc - pbe ) ;
            }
                delF( tin0P , pc2s ) ;
                }
                    delF( tin0P , (byteT*&)pc2s->c1 ) ;
                    pbc += pc2s->c2 ;

                    }
                        header.swabF() ;

                        }
                            }
                                __1
                                __( idErrorP ) ;
                            {
                            default:
                            case ifcIDeRRORdNS_QUERYrEFUSED      : { header.idError = (byteT)5 ; break ; }
                            case ifcIDeRRORdNS_QUERYnOTsUPPORTED : { header.idError = (byteT)4 ; break ; }
                            case ifcIDeRRORdNS_NAMEnOTdEFINED    : { header.idError = (byteT)3 ; break ; }
                            case ifcIDeRRORdNS_TRYaGAINlATER     : { header.idError = (byteT)2 ; break ; }
                            case ifcIDeRRORdNS_CANNOTpARSEqUERY  : { header.idError = (byteT)1 ; break ; }
                            case ifcIDeRRORdNS_AOK               : { header.idError = (byteT)0 ; break ; }
                        {
                        switch( idErrorP )

                        header.cNotes          = (count01T)cNote ;
                        header.cAuthorities    = (count01T)cAuth ;
                        header.cAnswers        = (count01T)cAnsw ;
                        header.reserved1       = 0 ;
                        header.bCanRecurse     = 0 ;
                        header.bTruncated      = 0 ;
                        header.bAuthoritative  = (byteT)bAuthoritativeP ;
                        header.bReply          = 1 ;

                        header.swabF() ;
                        dnsMsgHeaderS& header = *(dnsMsgHeaderS*)pbc ;
                    {
                    if( pbc == pbP )

                    memCopyF( tin0P , pbc , (byteT*)pc2s->c1 , pc2s->c2 ) ;

                    __( pbc + pc2s->c2 >  pbe ) ;
                    __( pbc            >= pbe ) ;
                {
                if( pc2s )
                stSnip >> pc2s ;
                ZE( count2S* , pc2s ) ;
            {
            while( stSnip && !POOP )
            byteT* const pbe = pbc + cba ;
            byteT*       pbc = pbP ;

            pbP[ cba ] = 0 ;
        {
        if( pbP )
        newF( tin0P , LF , pbP , cba + 1 ) ; ___( pbP ) ;

        while( !POOP && ~hDown ) ;
        }
            if( pc2s ) cba += pc2s->c2 ;
            count2S* pc2s = (count2S*)stSnip.downF( tin0P , hDown ) ;
        {
        do
        handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( !POOP && stSnip )
    ZE( countT , cba ) ; // STEP 3: MAKE THE FINAL IMAGE BY CONCATENATING THE SNIPPETS

    //}
    //    }
    //        ifcSayIF( T("label registered at offset ")+TF1(swOff)+T(": \"")+T(psttl)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;
    //        psttl = (strokeS*)swOff.leverF( tin0P , idf ) ;
    //    {
    //    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    //    countT cFlavors = swOff.cFlavorsF( tin0P ) ;
    //{
    //DEBUGGING

    }
        DEL( pSoul ) ;
        }
            }
                cbData = SWABnET2( cbData ) ;
                }
                    }
                        break ;
                        __1
                        __( idType ) ;

                        traceF( tin0P , T("dnsReplyF / !exception / unexpected query [idType]:    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    default :
                    }
                        break ;

                        }
                            }
                                pc2s = 0 ;
                                cbData += (count01T)pc2s->c2 ;
                                offo += pc2s->c2 ;
                                stSnip << pc2s ;
                                soul.shiftRightF( tin0P , (byteT*&)pc2s->c1 , pc2s->c2 , ifcIDtYPEsOULiTEM_byteTptr ) ; ___( (byteT*&)pc2s->c1 ) ;
                                pc2s->c2 = pc2s->c1 = 0 ;
                            {
                            if( pc2s )
                            newF( tin0P , LF , pc2s ) ; ___( pc2s ) ;
                        {

                        }
                            }
                                pc2s = 0 ;
                                cbData += (count01T)pc2s->c2 ;
                                offo += pc2s->c2 ;
                                stSnip << pc2s ;
                                if( pc2s->c1 ) *(byteT*)pc2s->c1 = (byteT)cProtocol ;
                                newF( tin0P , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                                pc2s->c2 = 1 ;
                                pc2s->c1 = 0 ;
                            {
                            if( pc2s )
                            newF( tin0P , LF , pc2s ) ; ___( pc2s ) ;

                            soul >> cProtocol ;
                            ZE( countT , cProtocol ) ;
                        {

                        }
                            }
                                pc2s = 0 ;
                                cbData += (count01T)pc2s->c2 ;
                                offo += pc2s->c2 ;
                                stSnip << pc2s ;
                                if( pc2s->c1 ) *(count02T*)pc2s->c1 = SWABnET4( (count02T)*(const countT*)nicName ) ;
                                newF( tin0P , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                                pc2s->c2 = sizeof( count02T ) ;
                                pc2s->c1 = 0 ;
                            {
                            if( pc2s )
                            newF( tin0P , LF , pc2s ) ; ___( pc2s ) ;
                            nicName << soul ;
                            nicNameC nicName ;
                        {
                    {
                    case ifcIDtYPEdNSqUERY_WKS :
                    }
                        break ;

                        }
                            }
                                pc2s = 0 ;
                                cbData += (count01T)pc2s->c2 ;
                                offo += pc2s->c2 ;
                                stSnip << pc2s ;
                                if( pc2s->c1 ) *(count02T*)pc2s->c1 = SWABnET4( ss ) ;
                                newF( tin0P , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                                pc2s->c2 = sizeof( count02T ) ;
                                pc2s->c1 = 0 ;
                            {
                            if( pc2s )
                            newF( tin0P , LF , pc2s ) ; ___( pc2s ) ;

                            count02T ss = third.secondsFromTimeIF( tin0P , time1 , time2 ) ;
                            soul >> (countT&)time2 ;
                            soul >> time1 ;
                            ZE( sCountT , time2 ) ;
                            ZE( countT  , time1 ) ;
                        {
                        while( cTries -- )
                        countT cTries = 4 ; // REFRESH RETRY EXPIRE MINIMUM

                        }
                            pc2s = 0 ;
                            cbData += (count01T)pc2s->c2 ;
                            offo += pc2s->c2 ;
                            stSnip << pc2s ;
                            if( pc2s->c1 ) *(count02T*)pc2s->c1 = SWABnET4( (count02T)cSerial ) ;
                            newF( tin0P , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                            pc2s->c2 = sizeof( count02T ) ;
                            pc2s->c1 = 0 ;
                        {
                        if( pc2s )
                        newF( tin0P , LF , pc2s ) ; ___( pc2s ) ;

                        soul >> cSerial ;
                        ZE( countT , cSerial ) ;

                        pushLabelsF( tin0P , *this , stSnip , offo , cbData , soul , swOff , psttl ) ;
                        pushLabelsF( tin0P , *this , stSnip , offo , cbData , soul , swOff , psttl ) ;
                    {
                    case ifcIDtYPEdNSqUERY_SOA :
                    }
                        break ;
                        __1 //U:
                        traceF( tin0P , T("dnsReplyF / !exception / ifcIDtYPEdNSqUERY_NULL received") ) ;
                    {
                    case ifcIDtYPEdNSqUERY_NULL :
                    }
                        break ;

                        pushLabelsF( tin0P , *this , stSnip , offo , cbData , soul , swOff , psttl ) ;

                        }
                            pc2s = 0 ;
                            cbData += (count01T)pc2s->c2 ;
                            offo += pc2s->c2 ;
                            stSnip << pc2s ;
                            if( pc2s->c1 ) *(count01T*)pc2s->c1 = SWABnET2( (count01T)cRank ) ;
                            newF( tin0P , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                            pc2s->c2 = sizeof( count01T ) ;
                            pc2s->c1 = 0 ;
                        {
                        if( pc2s )
                        newF( tin0P , LF , pc2s ) ; ___( pc2s ) ;

                        soul >> cRank ;
                        ZE( countT , cRank ) ;
                    {
                    case ifcIDtYPEdNSqUERY_MX :
                    }
                        break ;

                        }
                            delF( tin0P , psttw ) ;
                            }
                                }
                                    pc2s = 0 ;
                                    cbData += (count01T)pc2s->c2 ;
                                    offo += pc2s->c2 ;
                                    stSnip << pc2s ;
                                    }
                                        for( countT ids = 1 ; ids <= psttw->idAdam ; ids ++ ) *( pbc ++ ) = (byteT)psttw[ CSpREFIX - 1 + ids ].idAdam ;
                                        *( pbc ++ ) = (byteT)psttw->idAdam ;
                                        byteT* pbc = (byteT*)pc2s->c1 ;
                                    {
                                    if( pc2s->c1 )
                                    newF( tin0P , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                                    pc2s->c2 = 1 + psttw->idAdam ;
                                    pc2s->c1 = 0 ;
                                {
                                if( pc2s )
                                newF( tin0P , LF , pc2s ) ; ___( pc2s ) ;
                            {
                            if( psttw )
                            soul >> psttw ; ___( psttw ) ;
                            ZE( strokeS* , psttw ) ;
                        {
                        while( cText -- )

                        soul >> cText ;
                        ZE( countT , cText ) ;
                    {
                    case ifcIDtYPEdNSqUERY_TXT :
                    case ifcIDtYPEdNSqUERY_HINFO :
                    }
                        break ;
                        pushLabelsF( tin0P , *this , stSnip , offo , cbData , soul , swOff , psttl ) ;
                    {
                    case ifcIDtYPEdNSqUERY_PTR :
                    case ifcIDtYPEdNSqUERY_MR :
                    case ifcIDtYPEdNSqUERY_MG :
                    case ifcIDtYPEdNSqUERY_MB :
                    case ifcIDtYPEdNSqUERY_CNAME :
                    case ifcIDtYPEdNSqUERY_NS :
                    }
                        pushLabelsF( tin0P , *this , stSnip , offo , cbData , soul , swOff , psttl ) ; // INTENTIONAL FALLTHROUGH
                    {
                    case ifcIDtYPEdNSqUERY_MINFO :
                    }
                        break ;
                        }
                            pc2s = 0 ;
                            cbData += (count01T)pc2s->c2 ;
                            offo += pc2s->c2 ;
                            stSnip << pc2s ;
                            }
                                pco[ 0 ] = SWABnET4( pci[ 3 ] ) ;
                                pco[ 1 ] = SWABnET4( pci[ 2 ] ) ;
                                pco[ 2 ] = SWABnET4( pci[ 1 ] ) ;
                                pco[ 3 ] = SWABnET4( pci[ 0 ] ) ;

                                const count02T* pci = (const countT*)nicName ;
                                count02T*       pco = (count02T*)pc2s->c1 ;
                            {
                            if( pc2s->c1 )
                            newF( tin0P , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                            pc2s->c2 = sizeof( nicNameC ) ;
                            pc2s->c1 = 0 ;
                        {
                        if( pc2s )
                        newF( tin0P , LF , pc2s ) ; ___( pc2s ) ;
                        nicName << soul ;
                        nicNameC nicName ;
                    {
                    case ifcIDtYPEdNSqUERY_AAAA :
                    }
                        break ;
                        }
                            pc2s = 0 ;
                            cbData += (count01T)pc2s->c2 ;
                            offo += pc2s->c2 ;
                            stSnip << pc2s ;
                            if( pc2s->c1 ) *(count02T*)pc2s->c1 = SWABnET4( (count02T)*(const countT*)nicName ) ;
                            newF( tin0P , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                            pc2s->c2 = sizeof( count02T ) ;
                            pc2s->c1 = 0 ;
                        {
                        if( pc2s )
                        newF( tin0P , LF , pc2s ) ; ___( pc2s ) ;
                        nicName << soul ;
                        nicNameC nicName ;
                    {
                    case ifcIDtYPEdNSqUERY_A :
                    }
                        break ;
                        //U:ECHO BACK THE OPTION INFORMATION
                    {
                    case ifcIDtYPEdNSqUERY_OPTION :
                {
                switch( idType )

                count01T& cbData = *p_cbData ;
            {
            if( p_cbData )

            }
                pc2s = 0 ;
                offo += pc2s->c2 ;
                stSnip << pc2s ;
                }
                    p_cbData = &rMiddle.cbData ;
                    rMiddle.swabF() ;
                    rMiddle.cbData              = 0 ; //WILL BE ACCUMULATED AND THEN SWABBED
                    rMiddle.secondsToLive       = third.secondsFromTimeIF( tin0P , time1 , time2 ) ;
                    rMiddle.idClass             = (count01T)idClass ;
                    rMiddle.idType              = (count01T)idType ;
                    dnsResourceMiddleS& rMiddle = *(dnsResourceMiddleS*)pc2s->c1 ;
                {
                if( pc2s->c1 )
                newF( tin0P , LF , (byteT*&)pc2s->c1 , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                pc2s->c2 = sizeof( dnsResourceMiddleS ) ;
                pc2s->c1 = 0 ;
            {
            if( pc2s )
            newF( tin0P , LF , pc2s ) ; ___( pc2s ) ;
            ZE( count01T* , p_cbData ) ;

            if( POOP ) traceF( tin0P , T("dnsReplyF / !exception / step 2 / could not pull all input from soul [POOP]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            soul >> (countT&)time2 ;
            ZE( sCountT , time2 ) ;
            soul >> time1 ;
            ZE( countT , time1 ) ;
            soul >> idClass ;
            ZE( countT , idClass ) ;
            soul >> idType ;
            ZE( countT , idType ) ; // THE MIDDLE OF THE RR

            { ZE( count01T , cnu ) ; pushLabelsF( tin0P , *this , stSnip , offo , cnu , soul , swOff , psttl ) ; }

            ZE( count2S* , pc2s ) ;
            ZE( strokeS* , psttw1 ) ;

            }
                }
                    __1
                    __( idTypeAnswer ) ;
                    traceF( tin0P , T("dnsReplyF / !exception / step 2 / unexpected reply type [idTypeAnswer]:    ")+TF2(idTypeAnswer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                default:
                case ifcIDtYPEdNSrEPLY_NOTE      : { cNote ++ ; break ; }
                case ifcIDtYPEdNSrEPLY_AUTHORITY : { cAuth ++ ; break ; }
                case ifcIDtYPEdNSrEPLY_ANSWER    : { cAnsw ++ ; break ; }
            {
            switch( idTypeAnswer )
            soul >> idTypeAnswer ;
            ZE( countT , idTypeAnswer ) ; // ACCUMULATE COUNTERS FOR LATER INSERTION INTO HEADER

            soulC& soul = *pSoul ;
        {
        if( pSoul )
        stsRepliesP >> pSoul ;
        ZE( soulC* , pSoul ) ;
    {
    while( !POOP && stsRepliesP ) // EACH soulC OBJECT DEFINES A SINGLE RR (RESOURCE RECORD)
    TN( tDot , "." ) ;
    ZE( countT , cNote ) ;
    ZE( countT , cAuth ) ;
    ZE( countT , cAnsw ) ;
    // RATIONALE: (1) NO BENEFIT UNLESS EXCEED DATAGRAM SIZE (2) IFC NAMES WILL BE SHORT, AND REPLIES WILL BE FEW (3) CAN EDIT THIS CODE TO USE COMPRESSION LATER, IF IT IS NEEDED
    // DNS COMPRESSION IS -NOT- USED; EACH NAME IS WRITTEN IN FULL
    // STEP 2: MAKE EACH REMAINING SNIPPET THAT IS TO APPEAR IN THE FINAL IMAGE

    }
        }
            }
                offo += pc2s->c2 ;
                stSnip << pc2s ;
                memCopyF( tin0P      , (byteT*&)pc2s->c1 , pbQueryP , pc2s->c2 ) ;
                newF(     tin0P , LF , (byteT*&)pc2s->c1            , pc2s->c2 ) ; ___( (byteT*&)pc2s->c1 ) ;
                pc2s->c2 = pbe - pbQueryP ;
                pc2s->c1 = 0 ;
            {
            if( pc2s )
            newF( tin0P , LF , pc2s ) ; ___( pc2s ) ;
            ZE( count2S* , pc2s ) ;
        {
        else
        if( POOP ) traceF( tin0P , T("dnsReplyF / !exception / step 1 / could not accumulate label offsets ") ) ;

        }
            }
                pbe += 2 * sizeof( count01T ) ;

                delF( tin0P , psttl ) ;
                swOff = offl ;
                traceF( tin0P , T("label at offset ")+TF1(offl)+T(": \"")+T(psttl)+T("\"") ) ;
                dnsLabelsF( tin0P , psttl , pbe , (dnsMsgHeaderS*)pbQueryP ) ; ___( psttl ) ;
                countT offl = pbe - pbQueryP ;
            {
            while( !POOP && cq -- )
            header.swabF() ;
            countT cq = header.cQuerys ;
            header.swabF() ;
            pbe = pbQueryP + sizeof( dnsMsgHeaderS ) ; // QNAME
            dnsMsgHeaderS header = *(dnsMsgHeaderS*)pbQueryP ;  //U::BUG: SHOULD THIS BE A REFERENCE RATHER THAN A COPY?
        {
        ZE( const byteT* , pbe ) ;
    {
    // STEP 1: MAKE THE UNEDITED HEADER/QUERY SNIPPET (THIS SNIPPET WILL NEED TO BE EDITED BEFORE USE)

    switchC swOff( tin0P , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttl ) ;
    ZE( strokeS* , psttl ) ;
    ZE( countT , offo ) ; //WHERE I AM IN THE OUTPUT IMAGE; THIS NEEDS TO BE KNOWN TO CALCULATE LABEL COMPRESSION WHILE MAKING THE SNIPPETS

    stackC stSnip( tin0P , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_count2S ) ; // [ pb , cb ]

    _IO_

    }
        if( POOP ) return ;                 //20250322@1223: ADDED W/O ANALYSIS
        __( bAuthoritativeP > 1 ) ;
        __Z( pbQueryP ) ;
        __( cbP ) ;
        __NZ( pbP ) ;
        if( POOP ) return ;                 //20250322@1223: ADDED W/O ANALYSIS
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::dnsReplyF( tin0S& tin0P , byteT*& pbP , countT& cbP , const byteT* const pbQueryP , stackC& stsRepliesP , const boolT bAuthoritativeP , const countT idErrorP )/*1*/

/**/
*/
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00101b4.ifcIDeRRORdNS!||
 idErrorP
 bAuthoritativeP
 stsRepliesP
 pbQueryP
 cbP
 pbP
 tin0P
arguments
 if the caller is to send a truncated record via datagram, be sure to patch pbP to set the bTruncated bit in the header
the caller must verify cbP <= 002 if pbP will be sent using a datagram
\<A HREF=\"5.103018c.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dnsReplyF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

