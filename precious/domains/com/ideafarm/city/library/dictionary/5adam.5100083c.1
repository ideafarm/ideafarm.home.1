
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;


#endif

    }
        ++ s ; ether.osSleepF( tin0P , TOCK ) ;
    {
    while( cWalkers )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    etThread.delF( tin0P , pstt1PseudoVolumes ) ;
    }
        etThread.osThreadF( TaRG1( tmWorkerF ) , (countT)&cWalkers , (countT)psttRootFolder ) ; psttRootFolder = 0 ;
        inc02AM( cWalkers ) ;
        etThread.strMakeF( tin0P , LF , psttRootFolder , T(psttc1)+T("ideafarm.archives.rejects/") ) ; ___( psttRootFolder ) ;
        ZE( strokeS* , psttRootFolder ) ;

        if( ether ) break ;
    {
    FORsTRINGSiN1( pstt1PseudoVolumes )
    etThread.diskFindFileOrDirF( tin0P , pstt1PseudoVolumes , tLikePseudoVolumes ) ; ___( pstt1PseudoVolumes ) ;
    ZE( strokeS* , pstt1PseudoVolumes ) ;
    TN( tLikePseudoVolumes , "///d/ideafarm.home.101/devices/" ) ;

    ZE( countT , cWalkers ) ;

#else

    etThread.diskWalkF( tin0P , cDirs , cFiles , T("///e/") , ether , flDISKwALK_null , workCBF , 0 , 0 , 0 ) ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs  ) ;

#if defined( PRELUDE )


TODO

DONE( tmWorkerF )
}
    etThread.traceF( tin0P , T("end:      ")+TF2(cWalkersP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tRootFolder ) ;
    dec02AM( cWalkersP ) ;

    }
        }
            etThread.traceF( tin0P , T("failed:   ")+tRootFolder ) ;
            POOPRqUIET
        {
        if( POOP )
        ((tin9S&)tin0P).pEtScratch->diskWalkF( tin0P , cDirs , cFiles , tRootFolder , ether , flDISKwALK_null , workCBF , 0 , 0 , 0 ) ;
        SCOOPS
    {
    IFsCRATCH    
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs  ) ;

    etThread.traceF( tin0P , T("begin:    ")+tRootFolder ) ;

    etThread.delF( tin0P , psttRootFolderP ) ;
    TN( tRootFolder , psttRootFolderP ) ;
    TN( tb4    , "    " ) ;

    strokeS* psttRootFolderP = (strokeS*)pTaskP->c2 ;
    countT&  cWalkersP       = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmWorkerF )

}
    return 0 ;

    }
        }
            }
                etThread.delF( tin0P , psttLower ) ;
                etThread.delF( tin0P , pstt1w ) ;
                }
                    }
                        }
                            }
#endif
                                etThread.delF( tin0P , psttFind ) ;

                                }
                                    }
                                        while( !ether && ~hFindFile && !POOP ) ;
                                        }
                                            DEL( pInfoFile ) ;
                                            }
                                                }
                                                    bFound = 1 ;
                                                    }
                                                        etThread.traceF( tin0P , T("zapped:     ")+tLong ) ;
                                                        etThread.boxZapF( tin0P , tLong ) ;
                                                        etThread.traceF( tin0P , T("zapping:    ")+tLong ) ;
                                                    {
                                                    else
                                                    }
                                                        etThread.traceF( tin0P , T("found2: [timeWritten,name]:    ")+TT(timeWrittenArchive.time1,timeWrittenArchive.time2)+tb4+tShort ) ;
                                                        etThread.traceF( tin0P , T("found1: [timeWritten,name]:    ")+TT(pInfoFile->timeWritten1,pInfoFile->timeWritten2)+tb4+tShort ) ;
                                                        etThread.traceF( tin0P , T("elapse:                        ")+TT(timeE.time1,timeE.time2) ) ;
                                                    {
                                                    if( timeE.time2 > 0 || ( !timeE.time2 && timeE.time1 > TICK ) )
                                                    etThread.osTimeSubtractF( tin0P , timeE.time1 , timeE.time2 , timeWrittenArchive.time1 , timeWrittenArchive.time2 ) ;
                                                    timeS timeE = timeWrittenReject ;

                                                    }
                                                        thirdC::getFileTimeIF( tin0P , fir , &timeWrittenArchive , 0 , 0 ) ;
                                                        fileC fir( tin0P , pInfoFile->psttIfoName , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 0 , 0 ) ;
                                                    {
                                                    timeS timeWrittenArchive = timeS() ;
                                                {
                                                else
                                                }
                                                    bFound = 1 ;
                                                    etThread.traceF( tin0P , T("folder found: ")+tShort ) ;

                                                    }
                                                        etThread.delF( tin0P , psttShort ) ;
                                                        etThread.delF( tin0P , psttnu ) ;
                                                        tShort  = T(psttShort) ;
                                                        etThread.strBisectF( tin0P , psttnu , psttShort , pInfoFile->psttIfoName , T("/") , - 2 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttShort ) ;
                                                        ZE( strokeS* , psttShort ) ;
                                                        ZE( strokeS* , psttnu ) ;
                                                    {
                                                {
                                                if( !tShort.csF( tin0P ) )        // IF A DIRECTORY

                                                }
                                                    etThread.delF( tin0P , psttShort ) ;
                                                    etThread.delF( tin0P , psttnu ) ;
                                                    tShort  = T(psttShort) ;
                                                    etThread.strBisectF( tin0P , psttnu , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttShort ) ;
                                                    ZE( strokeS* , psttShort ) ;
                                                    ZE( strokeS* , psttnu ) ;
                                                {
                                                TN( tShort , "" ) ;
                                            {
                                            else
                                            }
                                                break ;
                                                DEL( pInfoFile ) ;
                                                if( !bFound ) etThread.traceF( tin0P , T("not found") ) ;
                                            {
                                            if( !pInfoFile || !pInfoFile->psttIfoName )

                                            etThread.traceF( tin0P , T("called  diskFindFileOrDirF") ) ;
                                            etThread.diskFindFileOrDirF( tin0P , pInfoFile , hFindFile , tPath , &pat ) ; ___( pInfoFile ) ;
                                            etThread.traceF( tin0P , T("calling diskFindFileOrDirF") ) ;
                                            ZE( infoFileS* , pInfoFile ) ;
                                        {
                                        do
                                        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                                        handleC hFindFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                    {
                                    ZE( boolT , bFound ) ;

                                    patternC pat( tin0P , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                                {

                                //etThread.traceF( tin0P , tPath+tb4+tPattern ) ;
                                TN( tPattern , "" ) ; tPattern = T("*")+T(psttFind)+T("*") ;
                                TN( tPath    , "" ) ; tPath    = T("///e/ideafarm.archives/wo.ideafarm/")+tYear+T("/") ;

                                //etThread.traceF( tin0P , tYear+tb4+T(psttFind) ) ;
                                etThread.strSubstringF( tin0P , psttFind , idf , idl , psttc1 , 0 ) ; ___( psttFind ) ;
                                ZE( strokeS* , psttFind ) ;

                                countT idl = etThread.strIdF( tin0P , T(".") , psttc1 , 8 ) ;
                                countT idf = etThread.strIdF( tin0P , T(".") , psttc1 , 5 ) ;

                                // !ideafarm.a.2.00000000.00000001.20001231@1617.20170131@0335.9a088138d0158dd07a8035d87a7cbdce.001.fset.zip
                                //                                |------------------------------------------------------------|

                                //etThread.traceF( tin0P , tYear+tb4+T(psttc1) ) ;
#if defined( NEVERdEFINED )

if( !( cRejectsWas % TUCK ) ) etThread.traceF( tin0P , TF2(cRejectsWas,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
countT cRejectsWas = incv02AM( cRejects ) ;
                            {
                            else
                            if( 1 != etThread.strIdF( tin0P , T("!ideafarm.") , psttc1 , 1 ) ) bNope = 1 ;
                        {
#endif

                        case 9:
                        case 8: { tYear = T(psttc1)                                                                          ; break ; }
                        case 7: { if( 1 != etThread.strIdF( tin0P , T("wo.ideafarm"              ) , psttc1 , 1 ) ) bNope = 1 ; break ; }
                        case 5: { if( 1 != etThread.strIdF( tin0P , T("ideafarm.archives.rejects") , psttc1 , 1 ) ) bNope = 1 ; break ; }

                        // | 9        !ideafarm.a.2.00000000.00000001.20001231@1617.20170131@0335.9a088138d0158dd07a8035d87a7cbdce.001.fset.zip
                        // | 8        2008
                        // | 7        wo.ideafarm
                        // | 6        000b46a0.f01ba6aa.3c259f6f.8f010000.0d010000
                        // | 5        ideafarm.archives.rejects
                        // | 4        ssd2.arc.209901
                        // | 3        devices
                        // | 2        ideafarm.home.101
                        // | 1        d
                        // | ///d/ideafarm.home.101/devices/ssd2.arc.209901/ideafarm.archives.rejects/000b46a0.f01ba6aa.3c259f6f.8f010000.0d010000/wo.ideafarm

#else
                        case 7:
                        case 6: { tYear = T(psttc1)                                                                          ; break ; }
                        case 5: { if( 1 != etThread.strIdF( tin0P , T("wo.ideafarm"              ) , psttc1 , 1 ) ) bNope = 1 ; break ; }
                        case 3: { if( 1 != etThread.strIdF( tin0P , T("ideafarm.archives.rejects") , psttc1 , 1 ) ) bNope = 1 ; break ; }
                        case 2: { if( 1 != etThread.strIdF( tin0P , T("from."                    ) , psttc1 , 1 ) ) bNope = 1 ; break ; }

                        // | 7        !ideafarm.a.2.00000000.00000001.20001231@1617.20170131@0335.9a088138d0158dd07a8035d87a7cbdce.001.fset.zip
                        // | 6        2008
                        // | 5        wo.ideafarm
                        // | 4        000b46d2.b5f08edd.3c259f6f.40c10000.09a20000
                        // | 3        ideafarm.archives.rejects
                        // | 2        from.hdd4.arc.2021062201
                        // | 1        e
                        // | ///e/from.hdd4.arc.2021062201/ideafarm.archives.rejects/000b46d2.b5f08edd.3c259f6f.40c10000.09a20000/wo.ideafarm/2008/!ideafarm.a.2.00000000.00000001.20001231@1617.20170131@0335.9a088138d0158dd07a8035d87a7cbdce.001.fset.zip

#if defined( PRELUDE )
                    {
                    switch( ++ idw )

                    //etThread.traceF( tin0P , TF3((countT)(idw+1),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(psttc1) ) ;

                    if( bNope ) break ;
                {
                FORsTRINGSiN1( pstt1w )
                TN( tYear  , ""     ) ;
                ZE( boolT  , bNope  ) ;
                ZE( countT , idw    ) ;

                etThread.strWordsF( tin0P , pstt1w , psttLower , sttq , T("/") ) ; ___( pstt1w ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , pstt1w ) ;

                // ///e/from.ssd2.arc.years01/ideafarm.archives.rejects/000b46a1.f1086dbc.3c259f6f.45b00000.05700000/wo.ideafarm/2009/!ideafarm.a.2.00000000.00000001.20090508@2258.20150910@0342.23a33919970b0e2827e5350b0079f255.001.fset.zip

                //etThread.traceF( tin0P , psttLower ) ;
                etThread.strConvertToLowerCaseF( tin0P , psttLower , psttzLong ) ; ___( psttLower ) ;
                ZE( strokeS* , psttLower ) ;

                //etThread.traceF( tin0P , T("reject: [timeWritten,name]:    ")+TT(timeWrittenReject.time1,timeWrittenReject.time2)+tb4+tLong ) ;
                //etThread.traceF( tin0P , tLong ) ;

                }
                    thirdC::getFileTimeIF( tin0P , fir , &timeWrittenReject , 0 , 0 ) ;
                    fileC fir( tin0P , (strokeS*)tLong , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 0 , 0 ) ;
                {
                timeS timeWrittenReject = timeS() ;
                TN( tb4    , "    " ) ;
            {
            if( !bDir )
            boolT bDir = psttzLong[ CSpREFIX - 1 + psttzLong->idAdam ].idAdam == '/' ;

            strokeS* psttzLong = tLong ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            TN( tLong , iffn ) ;
            ifFileNameC iffn( tin0P , etThread , postNameP ) ;
        {
        if( !bQuitP )

        etherC& ether    = etherC::etPrimeIF() ;
        etherC& etThread = *((tin9S&)tin0P).pEther ;

        _IO_
    {
    if( postNameP && *postNameP )

    _IO_
{
boolT workCBF( tin0S& tin0P , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

countT cRejects ;

//#define PRELUDE

/*1*/WAKEsHOWtEXT( "tool.archives.purge.rejected.files" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
