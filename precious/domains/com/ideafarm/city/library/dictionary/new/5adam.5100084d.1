
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    etThread.delF( tin0P , postiShortAll ) ;

    }
        ++ s ; ether.osSleepF( tin0P , TOCK ) ;

        //if( cWorkers < cWorkersSpec ) etThread.traceF( tin0P , T("[cWorkers]:    ")+TF2(cWorkers,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( cWorkers )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

#endif

    }
        etThread.osThreadF( TaRG1( tmWorkerF ) , (countT)&cWorkers , ++ idWorker , (countT)postizWindow , (countT)ppostEnd ) ;
        inc02AM( cWorkers ) ;
    {
    while( cDo -- )
    ZE( countT , idWorker ) ;
    countT cDo = cWorkersSpec ;

#else

    etThread.osThreadF( TaRG1( tmWorkerF ) , (countT)&cWorkers , cWorkersSpec , (countT)postizWindow , (countT)ppostEnd ) ;
    inc02AM( cWorkers ) ;

#if defined( NEVERdEFINED )

    ZE( countT , cWorkers ) ;

    if( ppostEnd[ cWorkersSpec - 1 ] != postizWindow + costizWindow ) { BLAMMOiD( 0x98761234 ) ; }                            // ALL PARTITIONS ARE NOW VERIFIED TO BEGIN WITH '!' AND NOT BE NULL LENGTH
    }
        if( ppostEnd[ offe ] <= ppostEnd[ offe - 1 ] ) { BLAMMOiD( 0x72737372 ) ; }
    {
    for( countT offe = 1 ; offe < cWorkersSpec ; offe ++ )
 
    }
        if(    *ppostEnd[ offe ] != '!' ) { BLAMMOiD( 0x44448888 ) ; }
        while( *ppostEnd[ offe ] != '!' ) ppostEnd[ offe ] ++ ;                                                              // ADJUST END FOR EACH WORKER EXCEPT LATH SO THAT END POINTS TO A '!'
    {
    for( countT offe = 0 ; offe < cWorkersSpec - 1 ; offe ++ )
 
    ppostEnd[ cWorkersSpec - 1 ] = postizWindow + costizWindow ;                                                              // ppostEnd[] NOW PARTITIONS postizWindow, BUT PARTITIONS DO NOT BEGIN WITH '!' (THE WOTH CHAR OF A SHORT NAME)
    for( countT offe = 1 ; offe < cWorkersSpec - 1 ; offe ++ ) ppostEnd[ offe ] = ppostEnd[ offe - 1 ] + cEltPerWorkerRaw ;

    ppostEnd[ 0 ] = postizWindow + cEltPerWorkerRaw ;
    osTextT* ppostEnd[ CwORKERS ] ;

    const countT cEltPerWorkerRaw = costizWindow / cWorkersSpec ;

    if( costizWindow < cWorkersSpec ) { BLAMMOiD( 0x55556666 ) ; } //ENSURES THAT cEltPerWorkerRaw IS NOT 0

    postizWindow[ costizWindow ] = 0 ;

    etThread.traceF( tin0P , T("input window [offiWindow,offieWindow]:    0x")+TF3(postizWindow-postiShortAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+T("0x")+TF3(offieWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ;
    countT offieWindow = postizWindow + costizWindow - postiShortAll ;
    while( postizWindow[ costizWindow ] && postizWindow[ costizWindow ] != '!' ) costizWindow ++ ;

    countT   costizWindow = costiShortAll / 4 ;

    //osTextT* postizWindow = postiShortAll + 0x168bb41e ;
    //osTextT* postizWindow = postiShortAll + 0x0f07cd84 ;
    //osTextT* postizWindow = postiShortAll + 0x0783e692 ;
      osTextT* postizWindow = postiShortAll              ;
    // CS:CODEsYNC: THE OFFSET HARDCODED HERE MUST BE SET MANUALLY TO THE VALUE DISPLAYED IN THE "input window" TRACE LINE WRITTEN BY THE PRIOR EXECUTION OF ME
    //DO THE INPUT IN PARTS SO DO NOT EXHAUST MEMORY

    // input window [offiWindow,offieWindow]:    0x0f07cd84    0x168bb41e
    // input window [offiWindow,offieWindow]:    0x0783e692    0x0f07cd84
    // input window [offiWindow,offieWindow]:    0x00000000    0x0783e692

    etThread.traceF( tin0P , T("[costiShortAll]:    ")+TF4(costiShortAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;

      etThread.boxGetShadowF( tin0P , postiShortAll , costiShortAll , T("///d/tmp/lost8.before.all.w.dup.ttt") ) ; ___( postiShortAll ) ;
    //etThread.boxGetShadowF( tin0P , postiShortAll , costiShortAll , T("///d/tmp/lost.after.ttt") ) ; ___( postiShortAll ) ;
    //etThread.boxGetShadowF( tin0P , postiShortAll , costiShortAll , T("///d/tmp/lost.before.uscore.to.dot.reformat.uniquifier.seq.ttt") ) ; ___( postiShortAll ) ;
    //etThread.boxGetShadowF( tin0P , postiShortAll , costiShortAll , T("///d/tmp/lost.dut2.ttt") ) ; ___( postiShortAll ) ;
    ZE( countT   , costiShortAll ) ;
    ZE( osTextT* , postiShortAll ) ;
    TN( tb4 , "    " ) ;
{

TODO

DONE( tmWorkerF )
}
    etThread.traceF( tin0P , T("worker finished [cWorkersBefore,idWorkerP]:    ")+TF2(cWorkersBefore,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE)+tb4+TF2(idWorkerP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE) ) ;
    countT cWorkersBefore = decv02AM( cWorkersP ) ;
                                                                    // CS:CODEsYNC: THIS BIGIT MUST BE INCREMENTED MANUALLY FOR EACH PART
    }                                                               // |
        etThread.delF( tin0P , posto ) ;                             // ^
          etThread.boxPutF( tin0P , T("///d/tmp/lost8.before.uniquified.1." )+TF3(idWorkerP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,2)+T(".ttt") , posto , postoc - posto ) ;
        //etThread.boxPutF( tin0P , T("///d/tmp/lost6.after." )+TF3(idWorkerP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,2)+T(".ttt") , posto , postoc - posto ) ;
        //etThread.boxPutF( tin0P , T("///d/tmp/lost6.before.")+TF3(idWorkerP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,2)+T(".ttt") , posto , postoc - posto ) ;
        //etThread.boxPutF( tin0P , T("///d/tmp/lost6.dut2.")+TF3(idWorkerP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,2)+T(".ttt") , posto , postoc - posto ) ;

        etThread.traceF( tin0P , T("writing output file") ) ;

        memcpy( postoc , postSeparator , costSeparator ) ; postoc += costSeparator ;
        _IO_
    {
    if( !ether )

    }
        if( postic >= postieMe ) break ;
        postic = postieWoGross + 2 ;

        }
            if( !( cWritten % TUCK ) ) etThread.traceF( tin0P , TF2(cWritten,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            cWritten ++ ;
            postiLathWritten = postic ;

            memcpy( postoc , "\r\n" , 2           ) ; postoc += 2           ;
            memcpy( postoc , postic , costicGross ) ; postoc += costicGross ;
            _IO_
        {
        if( !bSkip )

        //etThread.traceF( tin0P , T("      [postiLathWritten]:    ")+T(postiLathWritten) ) ;
        //etThread.traceF( tin0P , T("                [postic]:    ")+T(postic) ) ;
        //etThread.traceF( tin0P , T("debug  [bSkip,costicNet]:    ")+TF2(bSkip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(costicNet,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;

        boolT bSkip = postiLathWritten && !memcmp( postic , postiLathWritten , costicNet ) ;

        countT costicNet   = postieWoNet   - postic ;
        countT costicGross = postieWoGross - postic ;

        if( !postieWoNet ) postieWoNet = postieWoGross ;
        osTextT* postieWoNet = strstr( postic , " bad" ) ;        // GROSS: THE FULL LINE ; NET: THE LINE UP TO BUT EXCLUDING " bad"

        *postieWoGross = 0 ;
        if( !postieWoGross ) break ;
        osTextT* postieWoGross = strstr( postic , "\r\n" ) ;        // THE INTENT IS TO DO THE COMPARE ONLY FOR THE NET PART, SO THAT " bad" WILL ONLY APPEAR IN THE OUTPUT IF THE SAME SHORT NAME DOES NOT ALSO APPEAR WITHOUT " bad" (SINCE SUCH A LINE WILL BE COLLATED WOTH)
        _IO_
    {
    while( !ether )
    ZE( countT , cWritten ) ;
    ZE( osTextT* , postiLathWritten ) ;

    osTextT* postoc = posto ;
    etThread.newF( tin0P , LF , posto , costiMe + costSeparator ) ; ___( posto ) ;
    ZE( osTextT* , posto ) ;

    osTextT* postic   = postiMe ;
    countT   costiMe  = postieMe - postiMe ;
    osTextT* postieMe = ppostEndP[ idWorkerP - 1 ] ;
    ;
        : ppostEndP[ idWorkerP - 2 ]
        ? postizWindowP
    osTextT* postiMe = idWorkerP == 1

    etThread.traceF( tin0P , T("worker started [cWorkersP,idWorkerP]:    ")+TF2(cWorkersP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE)+tb4+TF2(idWorkerP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE) ) ;

    TN( tb4 , "    " ) ;

    osTextT** const ppostEndP      = (osTextT**)pTaskP->c4 ;
    osTextT* const  postizWindowP  =  (osTextT*)pTaskP->c3 ;
    const countT    idWorkerP      =            pTaskP->c2 ;
    countT&         cWorkersP      =  *(countT*)pTaskP->c1 ;

    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmWorkerF )

const countT  costSeparator   = sizeof postSeparator - 1 ;
const osTextT postSeparator[] = "--------------------------\r\n" ;

countT cWorkersSpec = CwORKERS ;
#define CwORKERS 0xc

//P:PERSONALITY: EACH THREAD ADJUSTS ITS WINDOW UPWARD TO BEGIN AND END AT AN '!'

//A:ASSUME: BOTH INPUT FILES ARE SORTED ; BOTH MAY CONTAIN DUPLICATE LINES

/*1*/WAKEsHOWtEXT( "doodle.remove.duplicate.lines.multithreaded" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
