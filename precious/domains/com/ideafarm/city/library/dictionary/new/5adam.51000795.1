
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    }
        etThread.osThreadF( TaRG1( tmWorkerF ) , (countT)pvsp ) ;
        blobVSP* pvsp = new( 0 , tin0P , LF ) blobVSP( sp1 ) ; ___( pvsp ) ;
    {
    while( cDo -- )
    countT cDo = 8 ;

    blobVSP sp1( pbBack + 2 * sizeof( countT ) , myCBF ) ;

    etThread.memCopyF( tin0P , pbBack + 2 * sizeof( countT ) , postBlob , cbaBlob ) ;

    //etThread.traceF( tin0P , T("[pbBack]:    ")+TF3((countT)pbBack,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ;
    ((countT*)pbBack)[ 1 ] = cbaBlob ;
    ((countT*)pbBack)[ 0 ] = 0 ;
    etThread.newF( tin0P , LF , pbBack , 2 * sizeof( countT ) + cbaBlob ) ; ___( pbBack ) ;
    ZE( byteT* , pbBack ) ;

    osTextT* postBlob = tBlob ;
    countT cbaBlob = tBlob.csF( tin0P ) + 1 ;
{
TN( tBlob , "This is the day that the Lord has made!  Let us rejoice and be glad in Him!" ) ;

TODO

DONE( tmWorkerF )
}
    //etThread.traceF( tin0P , T("bye") ) ;
    }
        DEL( pvspP ) ;
        etThread.traceF( tin0P , T(postBlob) ) ;
        const osTextT* postBlob = *pvspP ;
    {
    if( pvspP )
    blobVSP* pvspP = (blobVSP*)pTaskP->c1 ;
    //etThread.traceF( tin0P , T("hello") ) ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmWorkerF )

}
    }
        }
            break ;
            }
                ((tin1S&)tin0P).pEther->delF( tin0P , pbDoomed ) ;
                byteT* pbDoomed = (byteT*)( (countT)( (const byteT*)*(blobSP*)pbvspP - 2 * sizeof( countT ) ) ) ;
                blobSP& blobsp = *(blobSP*)pbvspP ;
                etherC::etRockIF( tin0P ).traceF( tin0P , T("deleting") ) ;
            {
            else
            if( cRefNewLaterP ) etherC::etRockIF( tin0P ).traceF( tin0P , T("not deleting") ) ;
        {
        case ifcIDeVENTvsp_DT :
    {
    switch( idEventP )
{
voidT myCBF( tin0S& tin0P , byteT* pbvspP , countT idEventP , countT cRefOldP , countT cRefNewLaterP , countT cArgP )

/*1*/WAKEsHOWtEXT( "example.simplest.1snip.11200470.verysmartpointerclassdef.automatic.garbage.collection" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

