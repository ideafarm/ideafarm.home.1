
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( swsYP.cFlavorsF( tin0P ) && swMarkerP.cFlavorsF( tin0P ) && idStyleP && flagsP ) ;

    strFuseF( tin0P , psttP , T("")+S2(0,scOld_POPoRIGIN)+OLDmOVEtO(cColP,0)+S2(0,scOld_POPoRIGIN) ) ;

    bLeverP.ungrabF( tin0P ) ;

    }
        strFuseF( tin0P , psttP , T("")+S2(0,scOld_POPcOLOR) ) ;

        }
            while( !swsXP.third && !swsYP.third && ~hDownX && ~hDownY ) ;
            }
                }
                    if( !hDownX ) strFuseF( tin0P , psttP , T("")+OLDlINEtO(xx+0.5,yy+0.5) ) ;
                    bWoth = 0 ;
                {
                if( bWoth )

                //strFuseF( tin0P , psttP , T("")+OLDmOVE(-2,-2)+OLDlINE(4,0)+OLDlINE(0,4)+OLDlINE(-4,0)+OLDlINE(0,-4)+OLDmOVE(2,2) ) ; //U: HARDCODED MARKER

                strFuseF( tin0P , psttP , T("")+(bWoth?OLDmOVEtO(xx+0.5,yy+0.5):OLDlINEtO(xx+0.5,yy+0.5)) ) ;
                measureT yy = scaleY * ( *(measureT*)&swsYP.downF( tin0P , hDownY ) + biasY ) ;
                measureT xx = scaleX * ( *(measureT*)&swsXP.downF( tin0P , hDownX ) + biasX ) ;
            {
            do
            handleC hDownY( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            handleC hDownX( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            boolT bWoth = 1 ;
        {
        if( swsXP )

        strFuseF( tin0P , psttP , T("")+S2((countT)swColorP,scOld_cPUSHcOLOR) ) ;

        continue ;
        )
            ( pczLeverExcludeP &&  strIdNewF( pczLeverExcludeP , leverP ) )
            ( pczLeverIncludeP && !strIdNewF( pczLeverIncludeP , leverP ) ) ||
        (
        if
        leverP = swsXP.leverF( tin0P , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    cFlavors = swsXP.cFlavorsF( tin0P ) ;

    }
        scaleY = bSingleY ? 1 : ( cRowP - 3 /* - crMarker */ ) / ( mMaxAllY - mMinAllY ) ;
        scaleX = bSingleX ? 1 : ( cColP - 3 /* - ccMarker */ ) / ( mMaxAllX - mMinAllX ) ;
        biasY  = bSingleY ? ( cRowP - 2 /* - crMarker */ ) / 2 - mMinAllY : - mMinAllY ;
        biasX  = bSingleX ? ( cColP - 2 /* - ccMarker */ ) / 2 - mMinAllX : - mMinAllX ;
        boolT bSingleY = mMaxAllY < mMinAllY + 1e-10 ;
        boolT bSingleX = mMaxAllX < mMinAllX + 1e-10 ;
        }
            if( F(flagsP) & flSTRgRAPH_ORIGINxiSzE && 0.0 < mMinAllX ) mMinAllX = 0.0 ;
            if( F(flagsP) & flSTRgRAPH_ORIGINyiSzE && 0.0 < mMinAllY ) mMinAllY = 0.0 ;

            }
                }
                    if( mMaxAllY < mMaxY ) mMaxAllY = mMaxY ;
                    if( mMinAllY > mMinY ) mMinAllY = mMinY ;
                    statisticsF( tin0P , mMinY , mMaxY , mMeanY , mMedianY , mStdDeviationY , swsYP ) ;
                    ZE( measureT , mStdDeviationY ) ;
                    ZE( measureT , mMedianY ) ;
                    ZE( measureT , mMeanY ) ;
                    ZE( measureT , mMaxY ) ;
                    ZE( measureT , mMinY ) ;
        
                    if( mMaxAllX < mMaxX ) mMaxAllX = mMaxX ;
                    if( mMinAllX > mMinX ) mMinAllX = mMinX ;
                    statisticsF( tin0P , mMinX , mMaxX , mMeanX , mMedianX , mStdDeviationX , swsXP ) ;
                    ZE( measureT , mStdDeviationX ) ;
                    ZE( measureT , mMedianX ) ;
                    ZE( measureT , mMeanX ) ;
                    ZE( measureT , mMaxX ) ;
                    ZE( measureT , mMinX ) ;
                {
                if( swsXP )
        
                continue ;
                )
                    ( pczLeverExcludeP &&  strIdNewF( pczLeverExcludeP , leverP ) )
                    ( pczLeverIncludeP && !strIdNewF( pczLeverIncludeP , leverP ) ) ||
                (
                if
                leverP = swsXP.leverF( tin0P , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            mMaxAllY = mMaxAllX = - MAXmEASUREt ;
            mMinAllY = mMinAllX =   MAXmEASUREt ;
        {
        if( cFlavors )
        ZE( measureT , mMaxAllY ) ;
        ZE( measureT , mMaxAllX ) ;
        ZE( measureT , mMinAllY ) ;
        ZE( measureT , mMinAllX ) ;
    {
    ZE( measureT , scaleY ) ;
    ZE( measureT , biasY ) ;
    ZE( measureT , scaleX ) ;
    ZE( measureT , biasX ) ;
    countT cFlavors = swsXP.cFlavorsF( tin0P ) ;

    bLeverP.grabF( tin0P , TAG( TAGiDnULL ) ) ;

    strFuseF( tin0P , psttP , T("")+S2(0,scOld_cPUSHoRIGIN)+OLDmOVEtO(1,1)+S2(0,scOld_cPUSHoRIGIN)+OLDmOVE(1,0)+T(psttNoteP)+S2(0,scOld_POPoRIGIN)+OLDmOVEtO(0,0)+OLDlINEtO(cColP-1,0)+OLDlINEtO(cColP-1,cRowP-1)+OLDlINEtO(0,cRowP-1)+OLDlINEtO(0,0)+OLDmOVEtO(1/*+ccMarker/2*/,1/*+crMarker/2*/)+S2(0,scOld_cPUSHoRIGIN) ) ; //CALLER MUST TAG __(  )

    //const countT crMarker = 4 ;
    //const countT ccMarker = 4 ; //WITH CURRENT CODE, THESE MUST BE EVEN

    if( !psttP ) strMakeF( tin0P , LF , psttP , T("") , 0x100000 ) ; //U: SIZE ACCORDING TO AMOUNT OF DATA

    _IO_

    }
        if( POOP ) return ;
        FV( flSTRgRAPH , flagsP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::strGraphF( tin0S& tin0P , strokeS*& psttP , countT& leverP , batonC& bLeverP , switchStackC& swsXP , switchStackC& swsYP , switchC& swColorP , switchC& swMarkerP , const countT cColP , const countT cRowP , const countT idStyleP , const flagsT flagsP , const strokeS* const psttNoteP , const countT* pczLeverIncludeP , const countT* pczLeverExcludeP )/*1*/

/**/
*/
\<A HREF=\"5.10301a8.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strGraphF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

