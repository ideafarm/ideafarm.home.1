
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( psttP ) { strTrimF( tin0P , psttP ) ; ___( psttP ) ; }
    delF( tin0P , psttKey ) ;

    }
        delF( tin0P , psttl ) ;
        delF( tin0P , psttk ) ;

        }
            }
                if( bWoth ) bWoth = 0 ;

                }
                    strSubstringF( tin0P , psttP , idf2 , idl2 , psttl , csttExtraP ) ; ___( psttP ) ;
                    ZE( countT , idl2 ) ;
                {
                else
                if( !idf2 ) { strMakeF( tin0P , LF , psttP , T("") ) ; ___( psttP ) ; }
            {
            if( !strCompareF( tin0P , psttk , psttKey ) )
            strConvertToLowerCaseF( tin0P , psttk ) ; ___( psttk ) ;
        {
        if( psttk && psttk->idAdam < psttl->idAdam ) // IF A COLON WAS FOUND

        strSubstringF( tin0P , psttk , idf2 , sttq2 , S1C(':') , psttl ) ; ___( psttk ) ;
        ZE( strokeS* , psttk ) ;
        strokeS sttq2( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf2 = 1 ;

        }
            break ;
            delF( tin0P , psttl ) ;
        {
        else if( !psttl->idAdam )
        if( !psttl ) break ;
        strSubstringLineF( tin0P , psttl , idf , sttq , psttAllP , 1 ) ; ___( psttl ) ;
        ZE( strokeS* , psttl ) ;
    {
    while( !POOP && idf && !psttP )
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    boolT bWoth = 1 ;
    countT idf = 1 ;

    strConvertToLowerCaseF( tin0P , psttKey , psttKeyP ) ; ___( psttKey ) ;
    ZE( strokeS* , psttKey ) ;

    _IO_

    }
        if( POOP ) return ;
        }
            __( strIdAnyF( tin0P , 0 , flSTRmATCH_null , idf , sttq , T(TbLACK) , psttKeyP ) ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        if( POOP ) return ;
        __Z( psttKeyP ) ;
        __Z( psttAllP ) ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/**//*1*/voidT etherC::strSubstringMimeHeaderF( tin0S& tin0P , strokeS*& psttP , const strokeS* const psttAllP , const strokeS* const psttKeyP , const countT csttExtraP )/*1*/
*/
 csttExtraP
   see the TbLACK symbolic constant
  must not contain a blank or other white space stroke
  must not be 0
 psttKeyP
  should be the string returned by strGetMimeHeaderF, which unwraps key:value pairs that occupy multiple lines
  must not be 0
 psttAllP
  must be 0
 psttP
arguments
if the colon is at the end of the line, psttP will be set to a null length value
if not found, psttP will be null and impotence will -not- occur
 the key is matched case insensitively
 the value is trimmed
 if found, psttP is filled with the value that is to the right of the colon
 this function searches header lines for a line beginning with the specified key
 there might be white space immediately before and/or after the colon
 a header line of MIME text contains a key and a value, separated by a colon (':')
 MIME text consists of header lines followed by a null length line, followed by body lines
finds the value of the specified MIME header line
  \<A HREF=\"5.6430104.1.1.0.html\"\>6430104:  WAKEsHOW( "example.simplest.func.1030105.etherC.strSubstringMimeHeaderF" )\</A\>
 simplest
examples
\<A HREF=\"5.1030105.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strSubstringMimeHeaderF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

