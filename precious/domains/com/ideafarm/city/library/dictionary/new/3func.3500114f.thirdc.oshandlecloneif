
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return oshClone ;

    }
        }
            break ;

            #endif
        

                }
                    }
                        //}
                        //    //etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                        //    LOGrAW(   ostoSay ) ;
                        //    OStEXTAK( ostoSay , " + (file mapping) / osHandleCloneIF\r\n" ) ;
                        //    OStEXTC(  ostoSay , save , '0' ) ;
                        //    OStEXT(   ostoSay , TUCK >> 2 ) ;
                        //{
                        //if( !POOP && ((tin1S&)tin0P).pc Utility[ 0 ] )

                        __Z( noteP ) ;
                        countT save = ((tin1S&)tin0P).brcRaw ;
                        noteP = ((tin1S&)tin0P).brcRaw ;
                        BOS( WHATgbo , BOSoK , MapViewOfFileExNuma( (HANDLE)oshClone , FILE_MAP_WRITE , 0 , 0 , 0 , 0 , thirdC::osOffNumaNodeValidChosenIF( processGlobal2I.idNumaNode ) ) )
                    {
                    if( !POOP && idTypeP == ifcIDtYPEhANDLE_SHAREDmEMORY )
                {
                if( !noteP ) //CODEsYNCH: 175000c 1020191

                }
                    BLAMMO ; //2008.10.07 OBSERVED rc : aa5 1450_9 ERROR_NO_SYSTEM_RESOURCES (ON VIRTUAL DEDICATED SERVER GODADDY)
                    LOGrAWtID2( "DuplicateHandle error code:" , ((tin1S&)tin0P).brcRaw ) ;
                    BOSdOnOTtEST( WHATgbo , GetLastError() )
                {
                if( ((tin1S&)tin0P).bosFail )
                BOS( WHATgbo , BOSoK , DuplicateHandle( oshFrom , (HANDLE)oshP , oshTo , (HANDLE*)&oshClone , 0 , 1 , DUPLICATE_SAME_ACCESS ) )
                POOPIES

                HANDLE oshFrom = (HANDLE)( oshProcessFromP ? oshProcessFromP : osOpenProcessIF() ) ;
                HANDLE oshTo   = (HANDLE)( oshProcessToP   ? oshProcessToP   : osOpenProcessIF() ) ;

            #elif defined( __NT__ )
        
                //U:
        
            #ifdef __OS2__
        {
        default :
        case ifcIDtYPEhANDLE_TREEwALK  :                { oshClone = oshP ; break ; }
        case ifcIDtYPEhANDLE_STACKwALK :
    {
    switch( idTypeP )
    ZE( countT , oshClone ) ;

    _IO_

    }
        if( idTypeP == ifcIDtYPEhANDLE_LISTING         ) { BLAMMO ; } //U:LIST ALL NONCLONABLE TYPES HERE
        if( idTypeP == ifcIDtYPEhANDLE_CRITICALsECTION ) { BLAMMO ; } //U:LIST ALL NONCLONABLE TYPES HERE
        if( idTypeP == ifcIDtYPEhANDLE_WINDOW          ) { BLAMMO ; } //U:LIST ALL NONCLONABLE TYPES HERE
        if( !idTypeP ) { BLAMMO ; }
        //CS:PSEUDOdUPLICATE: 3500114f 3605300c

        //I WORK EVEN IF THREAD IS IMPOTENT, SO THAT grabC::grabF WILL WORK UNCONDITIONALLY
    {
    IFbEcAREFUL    
{
/*1*/countT thirdC::osHandleCloneIF( tin0S& tin0P , countT& noteP , const countT oshP , const countT idTypeP , const countT oshProcessToP , const countT oshProcessFromP )/*1*/

//U::THIS IS UNSAFE (LEAKAGE); EDIT TO RETURN handleC RATHER THAN countT

/**/
*/
  specify any nonze value to suppress this
  iff 0 then i will set this
 noteP
 tin0P
arguments
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

