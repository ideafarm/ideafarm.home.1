
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cItems ;

    }
        }
            }
                if( !pstt1FoundP && !pGrabP ) { strFuseF( tin0P , pstt1FoundP , T("") , pSoulP , pGrabP , csttExtraP ) ; ___( pstt1FoundP ) ; }

                }
                    delF( tin0P , psttw ) ;
                    }
                        strFuseSeparateF( tin0P , pstt1FoundP , psttw , 0 , 0 , pSoulP , pGrabP , cstte ) ; ___( pstt1FoundP ) ;
                        cItems ++ ;
                    {
                    if( !bDup )

                    }
                        }
                            }
                                break ;
                                bDup = 1 ;
                            {
                            if( !strCompareF( tin0P , psttc1 , psttw ) )
                        {
                        FORsTRINGSiN1( pstt1FoundP )
                    {
                    if( pstt1FoundP )
                    ZE( boolT , bDup ) ;

                    stFound >> psttw ;
                    ZE( strokeS* , psttw ) ;
                {
                while( stFound )

                }
                    while( !POOP && ~hDown ) ;
                    }
                        else if( psttw ) cstte += CSpREFIX + psttw->idAdam ;
                        if( bWoth ) bWoth = 0 ;
                        strokeS* psttw = (strokeS*)stFound.downF( tin0P , hDown ) ;
                    {
                    do
                    handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    boolT bWoth = 1 ;
                {
                if( stFound )
                countT cstte = csttExtraP ;
            {
            if( !POOP )

            delF( tin0P , psttPath ) ;
            }
                }
                    }
                        if( POOP ) { POOPRqUIET ; }
                        ((tin1S&)tin0P).pEtScratch->diskFindFileOrDirF( tin0P , psttA , handle , psttPath , pPatternP ) ; ___( psttA ) ;
                        SCOOPS
                    {
                    IFsCRATCHoK

                    }
                        break ;
                        if( ~handle ) handle.closeIfF() ;
                    {
                    if( ( ((tin1S&)tin0P).pcQuit && *((tin1S&)tin0P).pcQuit ) || ( cMaxP && !cRem ) )

                    else delF( tin0P , psttA ) ;
                    }
                        if( cRem ) cRem -- ;
                        stFound << psttA ; psttA = 0 ;
                    {
                    if( !bDots )

                    }
                        delF( tin0P , psttw ) ;
                        ;
                            !strCompareF( tin0P , psttw , T(".") )
                            !strCompareF( tin0P , psttw , T("..") ) ||
                        bDots = 

                        strWordF( tin0P , psttw , psttA , sttq , S1C('/') , - 1 - bDir ) ; ___( psttw ) ;
                        ZE( strokeS* , psttw ) ;
                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;

                        boolT bDir = psttA && psttA[ CSpREFIX - 1 + psttA->idAdam ].idAdam == '/' ;
                    {
                    ZE( boolT , bDots ) ;
                    //if( !( cRem % TUCK ) ) { CONoUTrAW( "." ) ; }
                {
                if( !POOP ) while( psttA )
                countT cRem = cMaxP ;

                __( idImpotence ) ;
                }
                    }
                        POOPRqUIET ;
                        //if( ((tin1S&)tin0P).pEther ) etherC::etRockIF( tin0P ).traceF( tin0P , T("[POOP,psttDisk]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(psttDisk) ) ;

                        }
                            }
                                break ;
                                POOPRqUIET
                                idImpotence = POOP ;
                            {
                            default :
                            }
                                break ;
                                POOPRqUIET
                            {
                            //20230117@1320: REMOVED W/O ANALYSIS FOR CORRECT FUNCTION: case ifcIDiMPOTENCEbASEeRRORcODE_NOTrEADY :
                            case ifcIDiMPOTENCEbASEeRRORcODE_PATHnOTfOUND :
                        {
                        switch( POOP )
                    {
                    if( POOP )
                    ((tin1S&)tin0P).pEtScratch->diskFindFileOrDirF( tin0P , psttA , handle , psttPath , pPatternP ) ; ___( psttA ) ;
                    SCOOPS
                {
                IFsCRATCHoK
                ZE( countT , idImpotence ) ;
                ZE( strokeS* , psttA ) ;
                handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {
            else
            }
                __( idImpotence ) ;

                idImpotence |= idDiskCulprit << 0x18 ;
                idImpotence &= 0x00ffffff ; //A:ASSUME: countT IS 02 BITS

                }
                    if( ( ((tin1S&)tin0P).pcQuit && *((tin1S&)tin0P).pcQuit ) || ( cMaxP && !cRem ) ) break ;
                
                    }
                        DEL( pInfoDisk ) ;
                        }
                            delF( tin0P , psttPath2 ) ;
                            cRem   -= cFoundHere ;
                            delF( tin0P , pstt2Found ) ;
                            }
                                stFound << psttv ;
                                strokeS* psttv = psttOldC( tin0P , *this , psttc2 ) ; ___( psttv ) ; //U::O: CONVERT THIS FUNCTION TO TAKE A stackC PARAMETER, AND WRITE AN OVERLOAD WRAPPER TO RETURN A STRING OF STRINGS
                            {
                            FORsTRINGSiN2( pstt2Found )

                            }
                                }
                                    POOPRqUIET ;
                                    //if( ((tin1S&)tin0P).pEther ) etherC::etRockIF( tin0P ).traceF( tin0P , T("[POOP,psttDisk]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(psttDisk) ) ;

                                    }
                                        }
                                            break ;
                                            POOPRqUIET
                                            idDiskCulprit = postDisk[ 3 ] ;
                                            idImpotence = POOP ;
                                        {
                                        default :
                                        }
                                            break ;
                                            POOPRqUIET
                                        {
                                        //20230117@1320: REMOVED W/O ANALYSIS FOR CORRECT FUNCTION: case ifcIDiMPOTENCEbASEeRRORcODE_NOTrEADY :
                                        case ifcIDiMPOTENCEbASEeRRORcODE_PATHnOTfOUND :
                                    {
                                    switch( POOP )
                                {
                                if( POOP )
                                cFoundHere = ((tin1S&)tin0P).pEtScratch->diskFindFileOrDirF( tin0P , pstt2Found , psttPath2 , pPatternP , flDISKfIND_null , pSoulP , pGrabP , csttExtraP , cRem ) ; ___( pstt2Found ) ;
                                SCOOPS
                            {
                            IFsCRATCHoK
                            ZE( countT , cFoundHere ) ;
                            //traceF( tin0P , T("calling diskFindFileOrDirF [psttPath2]:    ")+T(psttPath2) ) ;
                            ZE( strokeS* , pstt2Found ) ;
                            delF( tin0P , psttTmp ) ;
                            strFuseF( tin0P , psttPath2 , psttTmp ) ; ___( psttPath2 ) ;
                            strSubstringF( tin0P , psttTmp , idf , idLathI , psttPath ) ; ___( psttTmp ) ;
                            ZE( countT , idLathI ) ;
                            countT idf = 5 ;
                            ZE( strokeS* , psttTmp ) ;
                            strMakeF( tin0P , LF , psttPath2 , psttDisk , psttPath ? psttPath->idAdam : 0 ) ; ___( psttPath2 ) ;
                            ZE( strokeS* , psttPath2 ) ;
                        {
                        //if( F(pInfoDisk->flags) & flINFOdISK1s_LOCAL )
                        //20221124@1718: BEHAVIOR CHANGE: FROM NOW ON, I RETURN NETWORK AS WELL AS LOCAL MATCHES.  THIS CHANGE WAS MADE WITHOUT ANALYSIS SO WILL BREAK OLD CODE THAT REQUIRES A "LOCAL ONLY" RESTRICTION.  IF NECESSARY, A flagsP PARAMETER CAN BE ADDED TO ALLOW CALLER TO SPECIFY WHETHER THE SEARCH IS TO BE LIMITED TO LOCAL DRIVES
                    {
                    if( !POOP && pInfoDisk )

                    }
                        }
                            POOPRqUIET ;
                            //if( ((tin1S&)tin0P).pEther ) etherC::etRockIF( tin0P ).traceF( tin0P , T("[POOP,psttDisk]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(psttDisk) ) ;

                            }
                                }
                                    break ;
                                    POOPRqUIET
                                    idDiskCulprit = postDisk[ 3 ] ;
                                    idImpotence = POOP ;
                                {
                                default :
                                }
                                    break ;
                                    POOPRqUIET
                                    }
                                        idDiskCulprit = postDisk[ 3 ] ;
                                        idImpotence = POOP ;
                                    {
                                    if( !( F(flagsP) & flDISKfIND_IGNOREdEVICESnOTrEADY ) )
                                {
                                case ifcIDiMPOTENCEbASEeRRORcODE_NOTrEADY :
                                }
                                    break ;
                                    POOPRqUIET
                                {
                                case ifcIDiMPOTENCEbASEeRRORcODE_PATHnOTfOUND :
                            {
                            switch( POOP )
                        {
                        if( POOP )
                        ((tin1S&)tin0P).pEtScratch->diskInfoF( tin0P , pInfoDisk , psttDisk , 1 ) ; ___( pInfoDisk ) ; //U::NOT IN HERE
                        SCOOPS
                    {
                    IFsCRATCHoK
                    ZE( infoDiskS* , pInfoDisk ) ;
                    //if( ((tin1S&)tin0P).pEther ) etherC::etRockIF( tin0P ).traceF( tin0P , T("looking for [psttDisk]:    ")+T(psttDisk) ) ;

                    osTextT* postDisk = tDisk ;
                    TN( tDisk , psttDisk ) ;

                    if( psttExcludeDeviceLettersP && strIdF( tin0P , psttDisk[ CSpREFIX + 3 ] , psttExcludeDeviceLettersP ) ) continue ;
                {
                for( psttDisk[ CSpREFIX + 3 ] = S1C('a') ; !idImpotence && psttDisk[ CSpREFIX + 3 ] <= S1C('z') ; ++ psttDisk[ CSpREFIX + 3 ] )
                ZE( countT , idDiskCulprit ) ;
                ZE( countT , idImpotence ) ;

                countT cRem = cMaxP ;
                psttDisk[ CSpREFIX + 3 ] = 0 ;
                psttDisk[ CSpREFIX + 2 ] = '/' ;
                psttDisk[ CSpREFIX + 1 ] = '/' ;
                psttDisk[ CSpREFIX     ] = '/' ;
                SETpREFIX( psttDisk , 4 ,0 ) ;
                strokeS psttDisk[ CSpREFIX + 4 ] ;
            {
            else if( psttPath && ( psttPath[ CSpREFIX + 3 ] == S1C('*') || psttPath[ CSpREFIX + 3 ] == S1C('?') ) )
            if( POOP ) ;

            else { diskMapFileNameF( tin0P , psttPath , psttPathP ) ; ___( psttPath ) ; }
            }
                strFuseF(            tin0P , psttPath , psttPathP ) ; ___( psttPath ) ;
            {
            )
                )
                    )
                       && psttPathP[ CSpREFIX + 4 ] == S1C('/')
                          psttPathP[ CSpREFIX + 3 ] != S1C('/')           // LOCAL MAPPED NAME OF FORM "///d/path/short"
                    (
                    ||
                    )
                       && psttPathP[ CSpREFIX + 4 ] != S1C('/')
                          psttPathP[ CSpREFIX + 3 ] == S1C('/')           // NETBIOS      NAME OF FORM "////netbios/d/path/short"
                    (
                (
                &&
                && psttPathP[ CSpREFIX + 2 ] == S1C('/')
                && psttPathP[ CSpREFIX + 1 ] == S1C('/')
                   psttPathP[ CSpREFIX     ] == S1C('/')
            (
            if
            ZE( strokeS* , psttPath ) ;
        {
        stackC stFound( tin0P , third , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
    {
    IFsCRATCHoK
    ZE( countT , cItems ) ;

    _IO_

    }
        if( POOP ) return 0 ;
        __( psttPathP->idCaste != sc_PREFIXlENGTH ) ;
        __( psttPathP->idAdam < 5 ) ;
        if( POOP ) return 0 ;
        FV(flDISKfIND,flagsP)
        __Z( psttPathP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/countT etherC::diskFindFileOrDirF( tin0S& tin0P , strokeS*& pstt1FoundP , const strokeS* const psttPathP , const patternC* pPatternP , flagsT flagsP , soulC* pSoulP , grabC* pGrabP , const countT csttExtraP , const countT cMaxP , const strokeS* const psttExcludeDeviceLettersP )/*1*/

/**/
*/
  example: T("abxyz")
  string of device letters to exclude, in lower case
 psttExcludeDeviceLettersP
  if not 0, then is the maximum number of matching files to report in pstt1FoundP
  can be 0
 cMaxP
 csttExtraP
  must not specify a root directory, e.g. T("///x/")
  must not be 0
 psttPathP
  if no files are found, pstt1FoundP will be set to the null string
   use the FORsTRINGSiN1 macro to obtain each string
  will contain a string of strings
   a file will not be included in the append if it is already present in the list
  if not 0 then must be a string of strings, and my results will be appended
  can be 0 or not 0
 pstt1FoundP
arguments
i will not 
 if i quit early for this reason, my results are useable but incomplete
i will silently quit early if *((tin1S&)tin0P).pcQuit
if a wildcard ("*" or "?") is specified for the disk, remote drives are excluded from the search
evaluates to the number of files found
 simplest
examples
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

