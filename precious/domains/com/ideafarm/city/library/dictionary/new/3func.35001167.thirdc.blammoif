
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    thirdC::dosRaiseExceptionIF( tin0P , ifcIDeVENTeXCEPTIONmONITORED_BLAMMO , pcArgs , sizeof pcArgs / sizeof pcArgs[ 0 ] ) ;
    countT pcArgs[] = { idLineP , idiFileP , idLineCtP , idiFileCtP , idBlammoP , ((tin1S&)tin0P).idTinNamed , ((tin1S&)tin0P).glass.idThread , ((tin1S&)tin0P).osTid , osTidIF() } ;

    }
        //etherC::etRockIF( tin0P ).traceF( tin0P , (strokeS*)(const osTextT*)"blammoIF: raising exception" , flTRACE_PARAMETERiSoStEXT ) ;
        //LOGrAW( "blammoIF: raising exception ; an exception handler is registered, so an exception report file should be written to the \\tmp folder of the current drive (the same folder that contains this log file)\r\n" ) ;
    {
    else
    }
        //etherC::etRockIF( tin0P ).traceF( tin0P , (strokeS*)(const osTextT*)"blammoIF: raising exception with no exception handler registered" , flTRACE_PARAMETERiSoStEXT ) ;
        LOGrAW( "blammoIF: raising exception ; **** no exception handler is registered ****\r\n" ) ;
    {
    if( !( F(processGlobal2I.flCt) & flCTdTg_EXCEPTIONhANDLERrEGISTERED ) || F(processGlobal2I.flDt) & flCTdTg_EXCEPTIONhANDLERrEGISTERED )

    //LOGrAW( "**************************** BLAMMO ******************************\r\n" ) ;

    }
        ((tin1S&)tin0P).pag1->idBlammo        = idBlammoP  ;
        ((tin1S&)tin0P).pag1->idiFileBlammoCt = idiFileCtP ;
        ((tin1S&)tin0P).pag1->idLineBlammoCt  = idLineCtP  ;
        ((tin1S&)tin0P).pag1->idiFileBlammo   = idiFileP   ;
        ((tin1S&)tin0P).pag1->idLineBlammo    = idLineP    ;
    {
    if( c_pTin )
    countT c_pTin = (countT)&tin0P ;

    }
        pg1.idBlammo        = idBlammoP  ;
        pg1.idiFileBlammoCt = idiFileCtP ;
        pg1.idLineBlammoCt  = idLineCtP  ;
        pg1.idiFileBlammo   = idiFileP   ;
        pg1.idLineBlammo    = idLineP    ;

        processGlobal2S& pg1 = processGlobal2S::_processGlobal2I_IF() ;
    {

    }
        //etherC::etRockIF( tin0P ).traceF( tin0P , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
        //U:: PERHAPS USE RESTART HERE ; IF THIS FAILS, IT CAN BLOW THE STACK AND PREVENT AN EXCEPTION REPORT FROM BEING WRITTEN

        //LOGrAW( ostoSay ) ; //JUST IN CASE traceF FAILS

        OStEXTAK( ostoSay , "\r\n" ) ;
        if( tin0P.idTypeTin == ifcIDtYPEtIN_123 ) OStEXTA(  ostoSay , &tin0P ? ((tin123S&)tin0P).postThreadName : "[&tin0P is 0]" ) ;
        OStEXTAK( ostoSay , ") on thread " ) ;
        OStEXTC( ostoSay , idiFileCtP , 0 ) ;
        OStEXTAK( ostoSay , "(" ) ;
        OStEXTC( ostoSay , idLineCtP , 0 ) ;
        OStEXTAK( ostoSay , ") ct at " ) ;
        OStEXTC( ostoSay , idiFileP , 0 ) ;
        OStEXTAK( ostoSay , "(" ) ;
        OStEXTC( ostoSay , idLineP , 0 ) ;
        OStEXTAK( ostoSay , "BLAMMO at " ) ;
        OStEXT(  ostoSay , TUCK << 2 ) ;
    {

    TINSL
{
/*1*/voidT thirdC::blammoIF( const countT idLineP , const countT idiFileP , const countT idLineCtP , const countT idiFileCtP , const countT idBlammoP )/*1*/

/**/
*/
it is illegal to refer to this symbol most anywhere
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

