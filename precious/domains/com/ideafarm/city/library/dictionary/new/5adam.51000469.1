
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    //etThread.osSleepF( tin0P , TOCK ) ;

    etThread.strokeF( tin0P , T("S") ) ;
    __( idType - IDtYPE ) ;
    scs.readF( tin0P , idType ) ;
    idType = 0 ;
    scs.writeF( tin0P , IDtYPE ) ;
    scs.connectF( tin0P , idPortMe ) ;
    scs.bindF( tin0P ) ;
    socketC scs( tin0P , etThread , TAG( TAGiDnULL ) ) ;

    etThread.strokeF( tin0P , T("D") ) ;
    __( idType - IDtYPE ) ;
    scd.readF( tin0P , idType , idPort , nicName ) ;
    nicNameC nicName ;
    ZE( countT , idPort ) ;
    ZE( countT , idType ) ;
    scd.writeF( tin0P , idPortMe , nicNameC() , IDtYPE ) ;
{
while( !etThread && !ether )

scd.bindF( tin0P ) ;
socketC scd( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

}
    etThread.strokeF( tin0P , T("main: saw sReadyS\r\n") ) ;
    sReadyS.waitF( tin0P ) ;
    etThread.strokeF( tin0P , T("main: waiting for sReadyS\r\n") ) ;
    etThread.osThreadF( tin0P , countTC() , tmServeStreamF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&sReadyS ) ;
    signC sReadyS( tin0P , TAG( TAGiDnULL ) ) ;
{

}
    etThread.strokeF( tin0P , T("main: saw sReadyD; idPortMe: ")+TF1(idPortMe)+T("\r\n") ) ;
    sReadyD.waitF( tin0P ) ;
    etThread.strokeF( tin0P , T("main: waiting for sReadyD\r\n") ) ;
    etThread.osThreadF( tin0P , countTC() , tmServeDatagramF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&sReadyD ) ;
    signC sReadyD( tin0P , TAG( TAGiDnULL ) ) ;
{

TODO

DONE( tmServeDatagramF )
}
    }
        ssd.writeF( tin0P , idPort , nicName , idType ) ;
        etThread.strokeF( tin0P , T("d") ) ;
        __( idType - IDtYPE ) ;
        ssd.readF( tin0P , idType , idPort , nicName ) ;
        nicNameC nicName ;
        ZE( countT , idPort ) ;
        ZE( countT , idType ) ;
    {
    while( !etThread && !ether )

    ++ sReadyD ;
    idPortMe = ssd.bindF( tin0P ) ;
    socketC ssd( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    signC& sReadyD = *(signC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmServeDatagramF )

DONE( tmServeStreamF )
}
    }
        DEL( pso ) ;
        }
            pso->readF( tin0P , &bb , 1 , flSOCKETcrEAD_STILLhUNGRYiSoK ) ;
            ZE( byteT , bb ) ;
            pso->writeF( tin0P , idType ) ;
            etThread.strokeF( tin0P , T("s") ) ;
            __( idType - IDtYPE ) ;
            pso->readF( tin0P , idType ) ;
            ZE( countT , idType ) ;
        {
        else if( pso )
        if( ether ) { DEL( pso ) ; }
        sss.acceptF( tin0P , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        ZE( socketC* , pso ) ;
    {
    while( !etThread && !ether )

    ++ sReadyS ;
    sss.listenF( tin0P ) ;
    __( sss.bindF( tin0P , idPortMe ) - idPortMe ) ;
    socketC sss( tin0P , etThread , TAG( TAGiDnULL ) ) ;

    signC& sReadyS = *(signC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmServeStreamF )

countT idPortMe ;

#define IDtYPE   0x13924829

/*1*/WAKEhIDE( "example.other.func.1070005.socketC.bindF" )/*1*/
/**/
*/
i bind both a datagram and a stream socket to the same idPort value
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

