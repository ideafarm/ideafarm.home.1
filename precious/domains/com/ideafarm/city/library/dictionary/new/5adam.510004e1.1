
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.delF( tin0P , psttNameOn   ) ;
etThread.delF( tin0P , psttNameFrom ) ;
etThread.delF( tin0P , psttNameTo   ) ;

}
    etThread.delF( tin0P , pbAll ) ;
    ((tin1S&)tin0P).zEtScratch->boxPutF( tin0P , psttNameTo , pbAll , cbAll ) ;
    
    }
        off += cbf ;
        ((tin1S&)tin0P).zEtScratch->delF( tin0P , pbf ) ;
        ((tin1S&)tin0P).zEtScratch->memCopyF( tin0P , pbAll + off , pbf , cbf ) ;
        ((tin1S&)tin0P).zEtScratch->strokeF( tin0P , T("got ")+TF1(cbf)+T(" bytes at offset ")+TF1(off)+T("\r\n") ) ;
        }
            }
                etThread.strokeF( tin0P , T("retrying query for bytes at offset ")+TF1(off)+T("\r\n") ) ;
                ((tin1S&)tin0P).zEtScratch->delF( tin0P , pbf ) ;
                *((tin1S&)tin0P).zEtScratch = 0 ;
            {
            else
            if( !*((tin1S&)tin0P).zEtScratch ) break ;
            getF( tin0P , *((tin1S&)tin0P).zEtScratch , pbf , cbf , cbr , psttNameFrom , nnOn , off , CBeACH ) ; ___( pbf ) ;
        {
        for(;;)
        ZE( countT , cbr ) ;
        ZE( countT , cbf ) ;
        ZE( byteT* , pbf ) ;
    {
    while( off < cbAll )
    ZE( countT , off ) ;
    
    if( pbAll ) pbAll[ cbAll ] = 0 ;
    ((tin1S&)tin0P).zEtScratch->newF( tin0P , LF , pbAll , cbAll + 1 ) ; ___( pbAll ) ;
    countT cbAll = cbr ;
    ZE( byteT* , pbAll ) ;
    
    ((tin1S&)tin0P).zEtScratch->delF( tin0P , pbf ) ;
    }
        }
            etThread.strokeF( tin0P , T("retrying (file size query)\r\n") ) ;
            ((tin1S&)tin0P).zEtScratch->delF( tin0P , pbf ) ;
            *((tin1S&)tin0P).zEtScratch = 0 ;
        {
        else
        if( !*((tin1S&)tin0P).zEtScratch ) break ;
        getF( tin0P , *((tin1S&)tin0P).zEtScratch , pbf , cbf , cbr , psttNameFrom , nnOn , 0 , 0 ) ; ___( pbf ) ;
    {
    for(;;)
    ZE( countT , cbr ) ;
    ZE( countT , cbf ) ;
    ZE( byteT* , pbf ) ;
    
    if( !psttNameTo ) { etThread.strMakeF( tin0P , LF , psttNameTo , psttNameFrom ) ; ___( psttNameTo ) ; }
    
    if( psttNameOn ) nnOn = etThread.sockNicNameF( tin0P , psttNameOn ) ;
    nicNameC nnOn ;
{
if( psttNameFrom )

}
    }
        }
            default: { __( idArm ) ; }
            case 3 : { idArm = 0 ; etThread.delF( tin0P , psttNameOn   ) ; etThread.strMakeF( tin0P , LF , psttNameOn   , psttc1 ) ; ___( psttNameOn   ) ;  break ; }
            case 2 : { idArm = 0 ; etThread.delF( tin0P , psttNameFrom ) ; etThread.strMakeF( tin0P , LF , psttNameFrom , psttc1 ) ; ___( psttNameFrom ) ;  break ; }
            case 1 : { idArm = 0 ; etThread.delF( tin0P , psttNameTo   ) ; etThread.strMakeF( tin0P , LF , psttNameTo   , psttc1 ) ; ___( psttNameTo   ) ;  break ; }
            }
                break ;
                else if( !etThread.strCompareF( tin0P , psttc1 , tOn   ) ) idArm = 3 ;
                else if( !etThread.strCompareF( tin0P , psttc1 , tFrom ) ) idArm = 2 ;
                     if( !etThread.strCompareF( tin0P , psttc1 , tTo   ) ) idArm = 1 ;
            {
            case 0 :
        {
        switch( idArm )
        
        etThread.strokeF( tin0P , T("parm: \"")+T(psttc1)+T("\"\r\n") ) ;
    {
    FORsTRINGSiN1( pstt1pp )
    strokeS*& pstt1pp = etThread.ether_pstt1_processParametersI_F( tin0P ) ;
    ZE( countT , idArm ) ;
    TN( tOn   , "!on" ) ;
    TN( tFrom , "!from" ) ;
    TN( tTo   , "!to" ) ;
{
ZE( strokeS* , psttNameOn   ) ;
ZE( strokeS* , psttNameFrom ) ;
ZE( strokeS* , psttNameTo   ) ;

TODO

}
    etherP.strokeF( tin0P , T("got it\r\n") ) ;
    sIn.shiftRightF( tin0P , pbP , cbP ) ; ___( pbP ) ;
    sIn >> cbrP ;
    
    sock.readF( tin0P , sIn ) ;
    soulC sIn( tin0P , TAG( TAGiDnULL ) ) ;
    
    sock.writeF( tin0P , sOut ) ;
    etherP.strokeF( tin0P , T("requesting \"")+T(psttP)+T("\" offset ")+TF1(offP)+T("\r\n") ) ;
    sock.connectF( tin0P , ifcPORToLD2_IFCfTP , nnOnP , 0 , TOCK * 0x20 ) ;
    etherP.strokeF( tin0P , T("connecting\r\n") ) ;
    socketC sock( tin0P , etherP , TAG( TAGiDnULL ) ) ;

    sOut << cbwP ;
    sOut << offP ;
    sOut << psttP ;
    soulC sOut( tin0P , TAG( TAGiDnULL ) ) ;
{
voidT getF( tin0S& tin0P , etherC& etherP , byteT*& pbP , countT& cbP , countT& cbrP , const strokeS* const psttP , nicNameC& nnOnP , const countT offP = 0 , const countT cbwP = - 1 )

#define CBeACH 0x10000

/*1*/WAKEhIDE( "tool.client.blob" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

