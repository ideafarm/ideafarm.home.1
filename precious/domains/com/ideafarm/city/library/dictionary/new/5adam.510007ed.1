
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

etThread.traceF( tin0P , T("mp3 [cHit]:    ")+TF2(cHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
etThread.traceF( tin0P , T("walked  ")+tRoot+T(" [cDirs,cFiles]:    ")+TF2(cDirs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
etThread.diskWalkF( tin0P , cDirs , cFiles , tRoot , ether , flDISKwALK_null , workCBF , pcArgInner , 0 , 0 ) ;
ZE( countT , cFiles ) ;
ZE( countT , cDirs ) ;
etThread.traceF( tin0P , T("walking ")+tRoot ) ;

countT pcArgInner[] = { (countT)&etThread , (countT)&cHit , (countT)&tb4 , (countT)&tExtWant , (countT)&sttCR } ;

ZE( countT , cHit ) ;

strokeS sttCR( '\r' ) ;
TN( tExtWant , "currentname" ) ;
TN( tb4  , "    " ) ;
TN( tRoot , "///e/ideafarm.archives/" ) ;

TODO


}
    return 0 ;

    }
        }
            etherP.delF( tin0P , psttLine ) ;
            etherP.traceF( tin0P , tSay , flTRACE_NOpREFIX ) ;

            tSay += tb4P+T(psttLine) ;

            etherP.strWordF( tin0P , psttLine , T(pbw) , sttq , sttCRP , 1 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , psttLine ) ;

            fwsIn.getF( tin0P , pbw , cbw , TUCK << 1 ) ;
            ZE( countT , cbw ) ;
            ZE( byteT* , pbw ) ;
            fileWindowsC fwsIn( tin0P , etherP , tName ) ;

            //etherP.traceF( tin0P , tShortest , flTRACE_NOpREFIX ) ;

            TN( tSay , (strokeS*)tShortest ) ;

            }
                etherP.delF( tin0P , psttnu ) ;
                etherP.delF( tin0P , psttShortest ) ;

                tShortest  = T(psttShortest) ;
                etherP.strBisectF( tin0P , psttShortest , psttnu , tName , T(".") , - 3 , flSTRbISECT_null ) ; ___( psttShortest ) ; ___( psttnu ) ;
                ZE( strokeS* , psttnu ) ;
                ZE( strokeS* , psttShortest ) ;
            {
            TN( tShortest  , "" ) ;

            cHitP ++ ;
        {
        if( bWant )

        boolT bWant = !etherP.strCompareF( tin0P , tExt , tExtWantP ) ;

        //etherP.traceF( tin0P , T("ext  :    ")+tExt ) ;

        }
            etherP.delF( tin0P , psttExt ) ;
            etherP.delF( tin0P , psttShorter ) ;
            tExt = T(psttExt) ;
            etherP.strConvertToLowerCaseF( tin0P , psttExt ) ;

            tShorter  = T(psttShorter) ;
            etherP.strBisectF( tin0P , psttShorter , psttExt , tName , T(".") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttShorter ) ; ___( psttExt ) ;
            ZE( strokeS* , psttExt ) ;
            ZE( strokeS* , psttShorter ) ;
        {
        TN( tExt , "" ) ;
        TN( tShorter  , "" ) ;

        }
            etherP.delF( tin0P , psttShort ) ;
            etherP.delF( tin0P , psttPath ) ;
            tShort = T(psttShort) ;
            tPath  = T(psttPath) ;
            etherP.strBisectF( tin0P , psttPath , psttShort , tName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
            ZE( strokeS* , psttShort ) ;
            ZE( strokeS* , psttPath ) ;
        {
        TN( tShort , "" ) ;
        TN( tPath  , "" ) ;
                                                                            
        //etherP.traceF( tin0P , T("file :    ")+tName ) ;

        TN( tName , ifName ) ;
        ifFileNameC ifName( tin0P , *((tin1S&)tin0P).pEther , postNameP ) ;
    {
    else
    }
        //etherP.traceF( tin0P , T("directory:    ")+tName ) ;

        TN( tName , ifName ) ;
        ifFileNameC ifName( tin0P , etherP , postNameP ) ;
    {
    else if( postNameP[ thirdC::c_strlenIF( tin0P , postNameP ) - 1 ] == '\\' ) // IF DIRECTORY
    }
        //etherP.traceF( tin0P , T("scan completed for a directory") ) ;
    {
    if( !postNameP )

    strokeS& sttCRP    = *(strokeS*)pcArgP[ 4 ] ;
    textC&  tExtWantP  =   *(textC*)pcArgP[ 3 ] ;
    textC&  tb4P       =   *(textC*)pcArgP[ 2 ] ;
    countT& cHitP      =  *(countT*)pcArgP[ 1 ] ;
    etherC& etherP     =  *(etherC*)pcArgP[ 0 ] ;
{
boolT workCBF( tin0S& tin0P , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )


/*1*/WAKEsHOWtEXT( "tool.accumulate.currentnames" )/*1*/
/**/
*/
parameter: !dir: the directory to scan, in ipdos file name format
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
