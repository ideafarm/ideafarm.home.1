
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

etThread.delF( tin0P , pNicNameWhite ) ;
sgnDone_tmUdpFilesEndpointThrowerF.waitF( tin0P ) ;
etThread.traceF( tin0P , T("waiting for endpoints to end") ) ;
bQuit = 1 ;

}
    ++ s ; ether.osSleepF( tin0P , TICK ) ;

    etThread.diskWalkF( tin0P , cDirs , cFiles , tFilesOut , ether , flDISKwALK_null , workCBF , pcArg , 0 , 0 ) ;
    countT pcArg[] = { (countT)&secretToUse } ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs  ) ;
{
while( !ether )
TN( tFilesOut , "///ideafarm/files.out/" ) ;

}
    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
{
while( !secretToUse && !ether )
sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

etThread.osThreadF( TaRG2sGNdONE( tmUdpFilesEndpointThrowerF , sgnDone_tmUdpFilesEndpointThrowerF ) , (countT)&bQuit , (countT)&psoEndpointThrower , (countT)&grab_psoEndpointThrower , (countT)&pNicNameWhite , (countT)&cNicNameWhite , (countT)&grab_pNicNameWhite , (countT)&nicNameToUse , (countT)&secretToUse ) ;
signC sgnDone_tmUdpFilesEndpointThrowerF(   tin0P , TAG( TAGiDnULL ) ) ;
ZE( boolT , bQuit ) ;
grabC grab_psoEndpointThrower(   tin0P , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS ) ;
ZE( socketC* , psoEndpointThrower ) ;
ZE( countT , secretToUse ) ;
nicNameC nicNameToUse ;
TN( tb4 , "    " ) ;
ZE( countT    , cNicNameWhite ) ;
ZE( nicNameC* , pNicNameWhite ) ;
grabC grab_pNicNameWhite( tin0P , TAG( TAGiDnULL ) ) ;

TODO

}
    return 0 ;

    }
        }
            }
                etThread.ifcUdpFileThrowFileF( tin0P , ether , idGram , secretToUseP , cThrown , cb04Thrown , psttzLongOut ) ;
                ZE( count04T , cb04Thrown ) ;
                ZE( countT   , cThrown    ) ;
                ZE( countT   , idGram     ) ;
            {
            if( !bDir )
            etThread.traceF( tin0P , T("=========================================================== ")+tLongOut ) ;
            boolT bDir = psttzLongOut[ CSpREFIX - 1 + psttzLongOut->idAdam ].idAdam == '/' ;

            strokeS* psttzLongOut = tLongOut ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            TN( tLongOut , iffn ) ;
            ifFileNameC iffn( tin0P , etThread , postNameP ) ;
        {
        if( !bQuitP )

        countT& secretToUseP = *(countT*)pcArgP[ 0 ] ;

        etherC& ether    = etherC::etPrimeIF() ;
        etherC& etThread = *((tin1S&)tin0P).pEther ;

        _IO_
    {
    if( postNameP && *postNameP )

    _IO_
{
boolT workCBF( tin0S& tin0P , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

DONE( tmUdpFilesEndpointThrowerF )
}
    etThread.ifcUdpFilesEndpointF( tin0P , bQuitP , idPortEndpointThrowerNU , TICK >> 0 , psoEndpointP , grab_psoEndpointP , pNicNameWhiteP , cNicNameWhiteP , grab_pNicNameWhiteP , pNicNameToUseP , pSecretToUseP ) ;
    ZE( countT , idPortEndpointThrowerNU ) ;

    countT*          pSecretToUseP         =           (countT*)pTaskP->c8 ;
    nicNameC*        pNicNameToUseP        =         (nicNameC*)pTaskP->c7 ;
    grabC&           grab_pNicNameWhiteP   =           *(grabC*)pTaskP->c6 ;
    countT&          cNicNameWhiteP        =          *(countT*)pTaskP->c5 ;
    const nicNameC*& pNicNameWhiteP        = *(const nicNameC**)pTaskP->c4 ;
    grabC&           grab_psoEndpointP     =           *(grabC*)pTaskP->c3 ;
    socketC*&        psoEndpointP          =        *(socketC**)pTaskP->c2 ;
    boolT&           bQuitP                =           *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmUdpFilesEndpointThrowerF )

//U:: INTEGRATE THIS FUNCTION INTO THE ENDPOINT ; (I CAN ONLY BE HIRED WHEN BUNDLE IS NOT ALIVE, BECAUSE BUNDLE OWNS THE ENDPOINT PORT ifcIDpORT_UDPfILEcATCHER)

//BASELINE: 51000833

/*1*/WAKEsHOWtEXT( "doodle udp file throw" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
