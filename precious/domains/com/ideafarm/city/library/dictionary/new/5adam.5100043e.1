
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

REST

}
    }
        }
            ++ s ; ether.osSleepF( tin0P , TOCK ) ;
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        {
        if( !cIn )
        TELL( "taking my cycle nap" ) ;

        }
            etThread.delF( tin0P , pstt1m ) ;
            }
                etThread.osThreadF( tin0P , countTC() , tmSuperF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)psttFile , ++ idFile , (countT)&bFace ) ;
                etThread.diskMoveFileOrDirF( tin0P , psttFile , psttc1 ) ;
                etThread.strMakeF( tin0P , LF , psttFile , tStage2+TI(ifcIDtEXTgEN_UNIQUE) ) ; ___( psttFile ) ;
                ZE( strokeS* , psttFile ) ;
            {
            FORsTRINGSiN1( pstt1m )
            etThread.boxMenuF( tin0P , soul1m , tStage1+tStar ) ; ___( pstt1m ) ;
            ZE( strokeS* , pstt1m ) ;
        {
        TELL( "promoting each stage 1 file to stage 2 and launching a supervisor thread for it" ) ;

        }
            etThread.delF( tin0P , pstt1m ) ;
            FORsTRINGSiN1( pstt1m ) etThread.diskMoveFileOrDirF( tin0P , tStage1+TI(ifcIDtEXTgEN_UNIQUE) , psttc1 ) ;
            cIn = etThread.boxMenuF( tin0P , soul1m , tIn+tStar ) ; ___( pstt1m ) ;
            ZE( strokeS* , pstt1m ) ;
        {
        ZE( countT , cIn ) ;
        TELL( "moving new job files into the stage 1 directory" ) ;

        bFace.ungrabF( tin0P ) ;
        etThread.strokeF( tin0P , T("\r")+TT(timeN1,timeN2) ) ;
        bFace.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        TN( tStage2  , "" ) ; tStage2 = T("///ideafarm/ephemeral/domains/com/ideafarm/")+T(DDNUMB)+T("/2/") ;
        TN( tStage1  , "" ) ; tStage1 = T("///ideafarm/ephemeral/domains/com/ideafarm/")+T(DDNUMB)+T("/1/") ;
        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT , timeN1 ) ;
    {
    while( !ether && !etThread )
    TN( tIn , "" ) ; tIn = T("///ideafarm/ephemeral/domains/com/ideafarm/")+T(DDNUMB)+T("/in/" ) ;
    strokeS sttr('-') ;
    TN( tStar    , "*" ) ;
    ZE( countT , idFile ) ;

    boxC boxDebug( tin0P , etThread , T("///ideafarm/ephemeral/domains/com/ideafarm/debug/")+TF1(DDNUMB) ) ; //U::WORKAROUND TO PREVENT LOCKUP
    stateS state( tin0P , etThread ) ;
    TELL( "setting up" )
{
batonC bFace( tin0P , TAG( TAGiDnULL ) ) ;

//U::HIRE( T("mail.out") , 0 , 0x1000000 , 0 , 0x1000000 )
//{ countT idAdam = 0x40104c5 ; etThread.ifcHireF( tin0P , T("port..expireTime") , idAdam , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ; }
//{ countT idAdam = 0x40104b8 ; etThread.ifcHireF( tin0P , T("port..expireTime") , idAdam , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ; }
HIRE( T("mail.out") , 0x4010418 , 0x1000000 , 0 , 0x1000000 )
//ENABLE WHEN WANT GORILLA TESTERS TO BE ACTIVE

//{ countT idAdam = 0x401048c ; etThread.ifcHireF( tin0P , T("port..expireTime") , idAdam , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ; }
//ENABLE WHEN AM EDITING THE SITE OR THE DICTIONARY

TELL( "preparing for work" ) ;
etThread.winSetTitleF( tin0P , TF1(DDNUMB) ) ; //U::
TODO

DONE( tmSuperF )
}
    doWoF( tin0P , etThread , psttFile , idFile , bFace ) ;

    batonC&  bFace    = *(batonC*)pTaskP->c3 ;
    countT   idFile   =           pTaskP->c2 ;
    strokeS* psttFile = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmSuperF )

}
    etThread.delF( tin0P , psttFileP ) ;
    etThread = 0 ;
    etThread.boxZapF( tin0P , psttFileP ) ;
    TELL( "deleting a new job file" ) ;

    etThread.delF( tin0P , posti ) ;
    etThread.delF( tin0P , psttu ) ;
    etThread.boxPutUniqueF( tin0P , psttu , T("///ideafarm/ephemeral/domains/com/ideafarm/")+T(DDNUMB)+T(bFail?"/tryLater":"/aok")+T("/item") , posti , costi ) ;
    ZE( strokeS* , psttu ) ;
    TELL( "archiving a new job file to aok" )

    etThread.strokeF( tin0P , T("\r\n")+TF1(idFileP)+T("| ")+T(psttFileP)+T(bFail?": TRYlATER\r\n":": AOK\r\n") ) ;
    boolT bFail = mailItemF( tin0P , *((tin1S&)tin0P).zEtScratch , T(posti) ) ;
    TELL( "handling a new job file" )

    etThread.boxGetShadowF( tin0P , posti , costi , psttFileP ) ; ___( posti ) ;
    ZE( countT   , costi ) ;
    ZE( osTextT* , posti ) ;
    bFaceP.ungrabF( tin0P ) ;
    etThread.strokeF( tin0P , T("\r\n")+TF1(idFileP)+T("| ")+T(psttFileP)+T(": BEGUN\r\n") ) ;
    bFaceP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    TELL( "reading a new job file" ) ;
{
voidT doWoF( tin0S& tin0P , etherC& etThread , strokeS* psttFileP , const countT idFileP , batonC& bFaceP )

}
    return bFail ;
    if( bFail ) *((tin1S&)tin0P).zEtScratch = 0 ;
    boolT bFail = !!*((tin1S&)tin0P).zEtScratch ;
    //((tin1S&)tin0P).zEtScratch->ifcSayF( tin0P , TF1(DDNUMB)+T("/hired ")+TF1(ifcIDaDAMoLD_MAILcLERK)+T(" to do a !mailOut job") , flSAY_APPEND | flSAY_LOG ) ;
    ((tin1S&)tin0P).zEtScratch->ifcJobF( tin0P , stCourses , ifcIDaDAMoLD_MAILcLERK , sOrder , stOrders , TF1(DDNUMB)+T("mail.out/!mailOut/")+TF1((countT)st_psttTo) , 1 ) ;
    //((tin1S&)tin0P).zEtScratch->ifcSayF( tin0P , TF1(DDNUMB)+T("/hiring ")+TF1(ifcIDaDAMoLD_MAILcLERK)+T(" to do a !mailOut job") , flSAY_APPEND | flSAY_LOG ) ;
    stOrders << new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) ) ;
    stackC stOrders(  tin0P , *((tin1S&)tin0P).zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stCourses( tin0P , *((tin1S&)tin0P).zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;

    ((tin1S&)tin0P).zEtScratch->delF( tin0P , psttBody ) ;
    sOrder << psttBody ;

    }
        ((tin1S&)tin0P).zEtScratch->delF( tin0P , psttTo ) ;
        sOrder << psttTo ;
        st_psttTo >> psttTo ;
        ZE( strokeS* , psttTo ) ;
    {
    while( st_psttTo )
    sOrder << (countT)st_psttTo ;

    sOrder << (countT)1 ;
    sOrder << (strokeS*)tJob ;
    soulC sOrder( tin0P , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDjOBoRDER_NAMED ) ;

    TN( tJob , "!mailOut" ) ;

    ((tin1S&)tin0P).zEtScratch->strConcatenateF( tin0P , psttBody , st_psttLines , T("\r\n") ) ; ___( psttBody ) ;
    ZE( strokeS* , psttBody ) ;

    }
        }
            ((tin1S&)tin0P).zEtScratch->delF( tin0P , psttw1 ) ;
            else                                                ((tin1S&)tin0P).zEtScratch->delF( tin0P , psttl ) ;
            if( ((tin1S&)tin0P).zEtScratch->strCompareF( tin0P , psttw1 , tBcc ) ) st_psttLines << psttl ;

            }
                else                                                                       ((tin1S&)tin0P).zEtScratch->delF( tin0P , psttw2 ) ;
                if( psttw2 && psttw2->idAdam && ((tin1S&)tin0P).zEtScratch->strIdF( tin0P , sttAt , psttw2 ) ) st_psttTo << psttw2 ;
                ((tin1S&)tin0P).zEtScratch->strTrimF( tin0P , psttw2 , 0 , T(TbLACKnEWlINE) , T(" ") ) ; ___( psttw2 ) ;                                  // "abc@foobar.com"

                }
                    psttw2 = psttw3 ;
                    ((tin1S&)tin0P).zEtScratch->delF( tin0P , psttw2 ) ;
                    ((tin1S&)tin0P).zEtScratch->strSubstringF( tin0P , psttw3 , idf3 , sttq3 , sttGT , psttw2 ) ; ___( psttw3 ) ;         // " abc@foobar.com "
                    ((tin1S&)tin0P).zEtScratch->delF( tin0P , psttw3 ) ;
                    ((tin1S&)tin0P).zEtScratch->strSubstringF( tin0P , psttw3 , idf3 , sttq3 , sttLT , psttw2 ) ; ___( psttw3 ) ;         // " \"Anthony B. Cullen\" "
                    ZE( strokeS* , psttw3 ) ;
                    strokeS sttq3( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf3 = 1 ;
                {
                if( idLT && idLT < idGT )
                countT idGT = ((tin1S&)tin0P).zEtScratch->strIdF( tin0P , sttGT , psttw2 ) ;
                countT idLT = ((tin1S&)tin0P).zEtScratch->strIdF( tin0P , sttLT , psttw2 ) ;
                ((tin1S&)tin0P).zEtScratch->strWordF( tin0P , psttw2 , psttl , sttq , sttColon , 2 ) ; ___( psttw2 ) ;                    // " \"Anthony B. Cullen\" < abc@foobar.com > "
                ZE( strokeS* , psttw2 ) ;
                //sttq = ze ;
            {
            if( !((tin1S&)tin0P).zEtScratch->strCompareF( tin0P , psttw1 , tTo ) || !((tin1S&)tin0P).zEtScratch->strCompareF( tin0P , psttw1 , tBcc ) || !((tin1S&)tin0P).zEtScratch->strCompareF( tin0P , psttw1 , tCc ) )

            ((tin1S&)tin0P).zEtScratch->strConvertToLowerCaseF( tin0P , psttw1 ) ; ___( psttw1 ) ;                                     // "to"
            ((tin1S&)tin0P).zEtScratch->strTrimF( tin0P , psttw1 , 0 , T(TbLACKnEWlINE) , T(" ") ) ; ___( psttw1 ) ;                                  // "TO"
            ((tin1S&)tin0P).zEtScratch->strWordF( tin0P , psttw1 , psttl , sttq , sttColon , 1 ) ; ___( psttw1 ) ;                    // " TO "
            ZE( strokeS* , psttw1 ) ;
            //sttq = ze ;

            if( !psttl ) break ;
            ((tin1S&)tin0P).zEtScratch->strSubstringLineF( tin0P , psttl , idf , sttq , psttP ) ; ___( psttl ) ;
            ZE( strokeS* , psttl ) ;
        {
        while( !*((tin1S&)tin0P).zEtScratch && idf )
        countT idf = 1 ;
        TN( tBcc , "bcc" ) ;
        TN( tCc  , "cc" ) ;
        TN( tTo  , "to" ) ;
        strokeS sttGT('>') ;
        strokeS sttLT('<') ;
        strokeS sttAt('@') ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        strokeS sttColon(':') ;

        }
            st_psttLines << psttl ;

            }
                psttl = psttOldC( tin0P , *((tin1S&)tin0P).zEtScratch , T("from: \"Oo'o Ideafarm\" <" ifcEMAIL_OLDfROM ">") ) ; ___( psttl ) ;
                ((tin1S&)tin0P).zEtScratch->delF( tin0P , psttl ) ;
            {
            if( ((tin1S&)tin0P).zEtScratch->diskIdF( tin0P , T("///c") ) == 0x2c1f032d )

            strokeS* psttl = psttOldC( tin0P , *((tin1S&)tin0P).zEtScratch , T("from: \"Wo'O Ideafarm\" <" ifcEMAIL_OLDfROM ">") ) ; ___( psttl ) ;
        {
    {
    stackC st_psttLines( tin0P , *((tin1S&)tin0P).zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC st_psttTo(    tin0P , *((tin1S&)tin0P).zEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
{
boolT mailItemF( tin0S& tin0P , const strokeS* const psttP )

}
{
stateC( tin0P , etherP , sizeof *this , 0 , translateStateF )
stateS::stateS( tin0S& tin0P , etherC& etherP ) :

TRANSLATEsTATE_END
    state.idMe ++ ;
TRANSLATEsTATE_MIDDLE
               state.idTransLast = stateOther.idTransLast ; }
    case 1 : { state.idMe        = stateOther.idMe        ;
TRANSLATEsTATE_BEGIN( stateS , 1 )

;
}
    stateS( tin0S& tin0P , etherC& etherP ) ;

    countT idTransLast ;
    countT idMe ;
    countT idVersion ;
{
struct stateS : public stateC

    "i am 1440104, made by Wo'O Ideafarm.  i am now on the job\r\n"
    "\r\n"                                                                                                                          \
    "subject: 1440104 has been hired to handle your outgoing mail\r\n"                                                              \
    "to: " ifcEMAIL_OLDfROM "\r\n"                                                                                                        \
                                                                                                                                    \
#define postSEASONtHEpAN                                                                                                            \

/*1*/WAKEhIDE( "mail.out" )/*1*/
/**/
*/
   f340104/smtp   : delivers text item to smtp server via telnet
  f340104/f340104 : initiate and supervise jobs that each specify the recipients for wo smtp server
 1440104/f340104  : initiate and supervise a job that specifies all recipients
 human/1440104    : places text file into a new file with an arbitrary name into "///ideafarm/ephemeral/backed.up.daily/mailOut/new/"
pseudocode for how an outgoing mail item destined for nnn@i deafarm.com is handled
i am hardcoded to work only for " ifcEMAIL_OLDfROM "
i mail out each file that appears
i continuously watch for the appearance of files in a particular directory
i mail out email
\<A HREF=\"5.1440104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

