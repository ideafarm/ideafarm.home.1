
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    return pco - pcP ;

    }
        }
            else                         pci ++   ;
            if( bCopy ) *( pco ++ ) = *( pci ++ ) ;

            }
                }
                    break ;                                                          // cbGot SHOULD ALWAYS BE 0 EXCEPT FOR ODD LENGTH LISTnAMEsYS_STRETCHbEGINoStEXTsTRZ
                    if( pc_cbString ) pc_cbString = 0 ;
                    }
                        bBits = got = cbGot = 0 ;
                          *( pco ++ ) = got ;
                        //*( pco ++ ) = got || bBits ? got : BM_HIGH ;
                    {
                    if( cbGot || ( bBits && *pc_cbString % SB ) )
                    mode = 0 ;
                {
                case LISTnAMEsYS_STRETCHeND :
                }
                    break ;
                    mode = 1 ;
                {
                case LISTnAMEsYS_STRETCHbEGINcOUNT :
                }
                    break ;
                    pc_cbString = pco ++ ;
                    *( pco ++ ) = *pci ;
                    bCopy = 0 ;
                    mode = 2 ;
                {
                case LISTnAMEsYS_STRETCHbEGINoStEXTsTRZ :
                }
                    break ;
                    mode = 3 ;
                {
                case LISTnAMEsYS_STRETCHbEGINcOUNTsTRZ :
                }
                    break ;
                    pc_cbString = pco ++ ;
                    *( pco ++ ) = *pci ;
                    bCopy = 0 ;
                    bBits = 1 ;
                    mode = 4 ;
                {
                case LISTnAMEsYS_STRETCHbEGINbITS :
            {
            switch( *pci )

            }
                }
                    break ;
                {
                default :
                }
                    break ;
                    }
                        got = cbGot = 0 ;
                        *( pco ++ ) = got ;
                    {
                    if( cbGot == sizeof( countT ) )
                    if( !( *pc_cbString % SB ) ) ++ cbGot ;
                    got = got << 1 | ( *pci & 3 ) - 1 ;
                    ++ *pc_cbString ;
                    bCopy = 0 ;
                {
                case 4 :                                                     //U:: CONJ: BUG: DOES THIS HANDLE ALL ENDING BITS 0?
                }
                    break ;
                    }
                        got = cbGot = 0 ;
                          *( pco ++ ) = got ;
                        //*( pco ++ ) = got ? got : BM_HIGH ;
                    {
                    if( ++ cbGot == sizeof( countT ) )
                    got = got << 8 | *pci & 0xff ;
                    bCopy = 0 ;
                {
                case 3 :
                case 1 :
                }
                    // INTENTIONAL FALLTHROUGH
                    ++ *pc_cbString ;
                {
                case 2  :
            {
            switch( mode )
            boolT bCopy = 1 ;

            }
                mode = 0 ;
                __Z( mode ) ;
            {
            if( *pci == LISTnAMEsYS_STRETCHeND )
        {
        while( *pci )
        ZE( boolT   , bBits ) ;
        ZE( countT* , pc_cbString ) ;
        ZE( countT  , cbGot ) ;
        ZE( countT  , got ) ;
        ZE( countT  , mode ) ;               // 1:SHRINK COUNT ; 2 : SHRINK COUNT STRING ; 3 : SHRINK BYTES
        const countT* pci = pczInP ;
        pco = pcP ;
    {
    if( pcP )
    ZE( countT* , pco ) ;

    }
        if( pcP ) thirdC::c_memsetIF( tin0P , (byteT*)pcP , ( cco + 1 ) * sizeof( countT ) ) ;
        PUSE.newF( tin0P , LF , *(byteT**)&pcP , ( cco + 1 ) * sizeof( countT ) ) ; ___( pcP ) ;
        const countT cco = thirdC::c_strlenIF( tin0P , pczInP ) ; //U::O: CALCULATE LENGTH NEEDED
    {
    if( !pcP )                                                                                                                             // IFF (IF AND ONLY IF) ALLOCATED NOW, OUTPUT IS ENTIRELY INITIALIZED TO PLACEhOLDER

    _IO_

    }
        if( POOP ) return 0 ;
        __Z( pczInP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/countT etherC::strSquishIF( tin0S& tin0P , countT*& pcP , const countT* pczInP )/*1*/

//20240828@1049: CHANGED BEHAVIOR: NOW DOES NOT EMIT BM_HIGH WHEN !got ; NOW RETURNS LENGTH OF OUTPUT STRING ; CALLERS MUST NOW USE THAT LENGTH AND HANDLE NULL VALUES WITHIN THE OUTPUT STRING

/**/
*/
 pczInP
  if the input string contains stretches of type LISTnAMEsYS_STRETCHbEGINbITS, the resulting output string cannot always be processed by searching for a null terminator because the shrunk bit string can contain runs of 0's
  if preallocated, must be sufficiently large (overrun will not be detected)
  may be preallocated
 pcP
 tin0P
arguments
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

