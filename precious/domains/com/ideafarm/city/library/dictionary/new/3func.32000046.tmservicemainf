
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmServiceMainF )
}
    bServiceAdamReturnedG = 1 ; //U::DO THIS LATER
    }
        TELL( "tmServiceMainF: cleaning up" )
        }
            }
                TELL( "the driver has been fired" )
                ((thirdC&)etThread).osDriverFireF( tin0P , ((tin1S&)tin0P).pag1->postServiceName ) ;
                bServiceAdamReturnedG = 1 ;
                TELL( "firing the driver" )
            {
            if( /*ether &&*/ !bServiceFired )
            //THIS IS ILLEGAL; win32 SILENTLY CRAPS WHEN A SERVICE CALLS HIRE AND/OR FIRE FOR A SERVICE
    
            ((tin1S&)tin0P).flagsThreadMode1 &= ~( F(flTHREADmODE1_DRIVERaDAM) ) ;
            if( !( ++ processGlobal2I.pcPhaseLow[ ((tin1S&)tin0P).glass.idThread ] ) ) { BLAMMO ; }
            TELL( "pMainF has returned" )
            (*pMainF)( &main ) ; //ASSUME: DEFINITION BLOCKS UNTIL QUITTING
            if( !( ++ processGlobal2I.pcPhaseLow[ ((tin1S&)tin0P).glass.idThread ] ) ) { BLAMMO ; }
            ((tin1S&)tin0P).flagsThreadMode1 |= flTHREADmODE1_DRIVERaDAM ;
            TELL( "calling the adam" )
        {
        if( pMainF )
        BOSpOOP
        BOS( WHATgbo , BOSoK , SetServiceStatus( (SERVICE_STATUS_HANDLE)((tin1S&)tin0P).pag1->oshServiceStatus , (SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus ) )
        ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwWaitHint = 0 ;
        ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwCheckPoint = 0 ;
        ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwCurrentState = SERVICE_RUNNING ;
    
        mainS main( tin0P , ether , etThread , hDll , T("cid ")+tCid+T(" level 1") ) ;
        TNCID ;
        __Z( pMainF ) ;
        etThread.dllEntryF( tin0P , pMainF , hDll , T("mainF") ) ;
        ZE( mainFT , pMainF ) ;
        __Z( hDll ) ;
        etThread.delF( tin0P , psttDll ) ;
        etThread.dllOpenF( tin0P , hDll , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.")+T(psttDll)+T(".ipdos-wd") ) ;
    {

    }
        etThread.delF( tin0P , psttw ) ;
        etThread.strSubstringF( tin0P , psttDll , idf , countTC() , psttw ) ; ___( psttDll ) ;
        countT idf = 2 ;
        etThread.strWordF( tin0P , psttw , T(*ppostHowP) , sttq , S1C('.') , 3 ) ; ___( psttw ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , psttw ) ;
        __Z( cHowP ) ;
    {
    ZE( strokeS* , psttDll ) ;

    BOSpOOP
    BOS( WHATgbo , BOSoK , SetServiceStatus( (SERVICE_STATUS_HANDLE)((tin1S&)tin0P).pag1->oshServiceStatus , (SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus ) )
    ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwWaitHint = 0x4000 ;
    ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwCheckPoint ++ ;
    ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwWin32ExitCode = NO_ERROR ;
    ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN ;
    ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwCurrentState = SERVICE_START_PENDING ;

    ((tin1S&)tin0P).pag1->oshServiceStatus = ((tin1S&)tin0P).brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , RegisterServiceCtrlHandler( ((tin1S&)tin0P).pag1->postServiceName , serviceHandlerF ) )
    if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_NOsYSTEMtHREADS ) ) { __( ((tin1S&)tin0P).glass.idThread - ifcIDtHREADlOW_tmWindowsOrServiceMainF ) ; }

    thirdC::third_flagsModeProcess1I_IF() |= flMODEpROCESS1_SERVICE ;

    handleC&  hDll      = *(handleC*)pTaskP->c3 ;
    osTextT** ppostHowP = (osTextT**)pTaskP->c2 ;
    countT    cHowP     =            pTaskP->c1 ;
    thirdC&   thThread = etThread ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )

/*1*/TASK( tmServiceMainF ) // THIS THREAD WAS LAUNCHED BY THE O.S.; "TASK" AND "DONE" ARE BEING USED TO PROVIDE tin0P, ether, etThread/*1*/

}
    }
        }
            break ;

            BOSpOOP
            BOS( WHATgbo , BOSoK , SetServiceStatus( (SERVICE_STATUS_HANDLE)((tin1S&)tin0P).pag1->oshServiceStatus , (SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus ) )
            ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwWaitHint = 0 ;
            ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwCheckPoint = 0 ;
            ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwCurrentState = SERVICE_STOPPED ;

            }
                }
                    ++ s; thirdC::dosSleepRawIF( tin0P , 250 ) ; //MUST BE MUCH LOWER THAN THE dwWaitHint VALUE
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , SetServiceStatus( (SERVICE_STATUS_HANDLE)((tin1S&)tin0P).pag1->oshServiceStatus , (SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus ) )
                    ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwWaitHint = 8000 ;
                    ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwCheckPoint ++ ;
                {
                while( !bServiceAdamReturnedG && !etThread )
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            {
            FIREmYSELF ;
            bServiceFired = 1 ;

            //POPUP( "SERVICE_STOP_PENDING" ) ;
            BOSpOOP
            BOS( WHATgbo , BOSoK , SetServiceStatus( (SERVICE_STATUS_HANDLE)((tin1S&)tin0P).pag1->oshServiceStatus , (SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus ) )
            ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwWaitHint = 8000 ;
            ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwCheckPoint ++ ;
            ((SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus)->dwCurrentState = SERVICE_STOP_PENDING ;
            etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUSH ) ;
        {
        case SERVICE_CONTROL_SHUTDOWN :
        case SERVICE_CONTROL_STOP :
        }
            break ;
            BOSpOOP
            BOS( WHATgbo , BOSoK , SetServiceStatus( (SERVICE_STATUS_HANDLE)((tin1S&)tin0P).pag1->oshServiceStatus , (SERVICE_STATUS*)((tin1S&)tin0P).pag1->pcServiceStatus ) )
        {
        case SERVICE_CONTROL_INTERROGATE :
    {
    switch( fdwControl )
    ZE( boolT , bRemoveMyself ) ;

    tin0S& tin0P = *processGlobal2I.pTin0DadService ; //THIS HAS BEEN VERIFIED FOR WINDOWS: I EXECUTE ON THE SAME THREAD THAT CALLED THE DISPATCHER
    etherC& etThread = *processGlobal2I.pEtThreadServiceEventHandler ;
    if( !processGlobal2I.pEtThreadServiceEventHandler ) return ;
{
VOID WINAPI serviceHandlerF( DWORD fdwControl ) // CALLED WITHIN StartServiceCtrlDispatcher; GUARANTEED TO BE ON THREAD 1

boolT bServiceAdamReturnedG ;
boolT bServiceFired ;

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

