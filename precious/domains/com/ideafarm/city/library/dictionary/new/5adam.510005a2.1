
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    LOGrAW( tSay ) ;
    CONoUTrAW( tSay ) ;

    etThread.delF( tin0P , psttu ) ;
    TN( tSay , "" ) ; tSay = TF2(cUploadsRemaining,flFORMAT_NObIGITvALUES)+T("| uploed received: ")+T(psttu)+T("\r\n") ;

    etThread.diskMoveFileOrDirUniqueF( tin0P , psttu , tFileIn ) ; ___( psttu ) ;
    ZE( strokeS* , psttu ) ;

    }
        etThread.delF( tin0P , pbChunk ) ;
        }
            }
                DEL( pso ) ;
                else        POOPR ;
                if( !POOP ) pso->writeF( tin0P , "ok\r\n" ) ;
                }
                    cbFile -= cbChunk ;
                    if( !POOP ) etThread.fileWriteF( tin0P , hFile , pbChunk , cbChunk ) ;
                    pso->readF( tin0P , pbChunk , cbChunk ) ;
                    countT cbChunk = cbFile < CBcHUNK ? cbFile : CBcHUNK ;
                {
                while( !POOP && cbFile )
                pso->readF( tin0P , (byteT*)&cbFile , sizeof cbFile ) ;
                ZE( countT , cbFile ) ;
                
                CONoUTrAW( "client connection accepted\r\n" ) ;
                sIn.acceptF( tin0P , pso , countTC() , nicNameC() , countTC() ) ; ___( pso ) ;
                ZE( socketC* , pso ) ;
                sIn.listenF( tin0P ) ;
                etThread.strokeF( tin0P , T("listening on port ")+TF2(idPort,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
                countT idPort = sIn.bindF( tin0P , 81 ) ;
                socketC sIn( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;

                SCOOPS
            {
            IFsCRATCHoK
        {
        if( pbChunk )
        etThread.newF( tin0P , LF , pbChunk , CBcHUNK ) ; ___( pbChunk ) ;
        ZE( byteT* , pbChunk ) ;
        etThread.fileOpenF( tin0P , hFile , countTC() , tFileIn , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
        handleC hFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
    {

    TN( tFileIn , "///d/tmp/blob.in" ) ;
{
else while( !ether && !etThread && cUploadsRemaining -- )
}
    etThread.delF( tin0P , pbChunk ) ;
    }
        sIn.writeF( tin0P , "ok\r\n" ) ;
        }
            cbFile -= cbChunk ;
            etThread.fileWriteF( tin0P , hFile , pbChunk , cbChunk ) ;
            sIn.readF( tin0P , pbChunk , cbChunk ) ;
            countT cbChunk = cbFile < CBcHUNK ? cbFile : CBcHUNK ;
        {
        while( cbFile )
        sIn.readF( tin0P , (byteT*)&cbFile , sizeof cbFile ) ;
        ZE( countT , cbFile ) ;
        
        CONoUTrAW( "connected\r\n" ) ;
        sIn.connectF( tin0P , 81 , socketC::nicNameIF( tin0P , etThread , T("72.167.92.180") ) ) ;
        CONoUTrAW( "connecting\r\n" ) ;
        sIn.bindF( tin0P ) ;
        socketC sIn( tin0P , etThread , TAG( TAGiDnULL ) ) ;
    {
    if( pbChunk )
    etThread.newF( tin0P , LF , pbChunk , CBcHUNK ) ; ___( pbChunk ) ;
    ZE( byteT* , pbChunk ) ;
    etThread.fileOpenF( tin0P , hFile , countTC() , T("///d/tmp/blob.in") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
    handleC hFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
{
if( bLaptop )
countT cUploadsRemaining = 0x10 ; //DEFENDS AGAINST DOS ATTACK

const boolT bCenter = IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 == etThread.diskIdF( tin0P , T("///c") ) ;
const boolT bLaptop = IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0     == etThread.diskIdF( tin0P , T("///c") ) ;

TODO

#define CBcHUNK TOCK

/*1*/WAKEsHOWtEXT( "tool.blob.in" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

