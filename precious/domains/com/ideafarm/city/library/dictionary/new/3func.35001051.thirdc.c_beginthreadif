
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            dec02AM( ((tin1S&)tin0P).cKidThreads ) ; //ADDED RECENTLY CAUSE ABSENCE SEEMED TO BE A BUG
            dec02AM( ((tin1S&)tin0P).pag1->_thirdC_.cAllKidThreads ) ;
        {
        else
        if( F(flagsP) & flTHREADlAUNCH_ORPHAN ) dec02AM( ((tin1S&)tin0P).pag1->_thirdC_.cAllOrphanThreads ) ;
    {
    if( POOP )

    if( POOP && tidP ) tidP = 0 ;
    __( tidP == - 1 ) ;

    #endif

        }
            }
                }
                    }
                        hThreadKid.resetF() ;
                        ((tin1S&)tin0P).pag4->_thirdC_grab_lOsTid.ungrabF( tin0P ) ;
                        *((tin1S&)tin0P).pag1->_thirdC_.pSwThreadHandle = hThreadKid.osF( ifcIDtYPEhANDLE_THREAD ) ;
                        ((tin1S&)tin0P).pag1->_thirdC_.lOsTid = tidP ;
                        ((tin1S&)tin0P).pag4->_thirdC_grab_lOsTid.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                    {
                    if( tidP && tidP != - 1 )
        
                    __( ((tin1S&)tin0P).brcRaw != 1 ) ;
                    BOSpOOP
                    BOS( WHATgbo , BOSmAXcOUNTT , ResumeThread( (HANDLE)hThreadKid.osF( ifcIDtYPEhANDLE_THREAD ) ) )
                    BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
        
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , SetThreadPriority( (HANDLE)hThreadKid.osF( ifcIDtYPEhANDLE_THREAD ) , idpDad ) )
                    BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
        
                    //}
                    //    thirdC::osSelectProcessorsIF( tin0P , idType , &hThreadKid ) ;
                    //
                    //    ;
                    //                : ifcIDtYPEtHREAD_WORKhORSE
                    //                ? ifcIDtYPEtHREAD_SHOWpONY
                    //            : F(flagsP) & flTHREADlAUNCH_SHOWpONY
                    //            ? ifcIDtYPEtHREAD_GLASS2
                    //        : ((tin1S&)tin0P).pag1->idCell < 3
                    //        ? ifcIDtYPEtHREAD_WORKhORSE
                    //    countT idType = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS || etherC::ifc_idHomeIdisk_IF() < 0x100
                    //{
                    //20170213@1456: COMMENTED OUT WITHOUT ANALYSIS TO PERHAPS FIX UNEXPECTED PROCESSOR AFFINITY FOR GLASS2 ADAM
        
                    __Z( hThreadKid ) ;
                    hThreadKid.osF( ifcIDtYPEhANDLE_THREAD , (countT)((tin1S&)tin0P).brcRaw ) ;
                {
                if( !POOP )

                BOSpOOP
                BOS( WHATgbo , BOSoK , CreateThread( &sa , cbStackP , (tmfosFT)tmFP , pvP , CREATE_SUSPENDED | STACK_SIZE_PARAM_IS_A_RESERVATION , (ULONG*)&tidP ) )

                BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                SECURITYaTTRIBUTE_saUNRESTRICTED( 0 ) ;
                int idpDad = ((tin1S&)tin0P).brcRaw ;
            {
            if( !POOP )
            BOSpOOP
            BOS( WHATgbo , BOStHREADERcODE , GetThreadPriority( (HANDLE)((tin1S&)tin0P).brcRaw ) )
            BOSdOnOTtEST( WHATgbo , GetCurrentThread() )
            BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
            handleC hThreadKid( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_THREAD ) ;
        {

    #elif defined( __NT__ )

        __Z( tidP ) ;
        BOSpOOP
        BOSI( WHATgbo , BOSfAIL , DosCreateThread( (ULONG*)&tidP , (tmfosFT)tmFP , (ULONG)pvP , 0 , 0 ) )

    #ifdef __OS2__

    //PSEUDODUPLICATED CODE: 1020057 1610003

    inc02AM( ((tin1S&)tin0P).pag1->ctWatch ) ;
    //CONoUTrAW3( "c_beginThreadIF [cThreadsFor _tmWatchF_toWatch] <-- " , 1 + incv02AM( ((tin1S&)tin0P).pag1->cThreadsFor _tmWatchF_toWatch ) , "\r\n" ) ;

    }
        inc02AM( ((tin1S&)tin0P).cKidThreads ) ;
        inc02AM( ((tin1S&)tin0P).pag1->_thirdC_.cAllKidThreads ) ;
    {
    else
    if( F(flagsP) & flTHREADlAUNCH_ORPHAN ) inc02AM( ((tin1S&)tin0P).pag1->_thirdC_.cAllOrphanThreads ) ;
    third_flagsProcessStateI_IF( tin0P , flPROCESSsTATE_MAINtHREADiSaLONE , 0 ) ;

    }
        //while( !POOP && ((tin1S&)tin0P).pag1->_thirdC_.cAllKidThreads > 0x100 ) { ++ s ; dosSleepWinkIF( tin0P ) ; }
        //sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    {
    //U::PROVIDE A PARAMETER OR PERHAPS A PROCESS MODE TO ENABLE THIS OVERRUN PROTECTION

    //if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("c_beginthreadIF / ++") ) ; //U:: TO FIND A BUG

    _IO_

    }
        if( POOP ) return ;
            __( !( F(processGlobal2I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal2I.flDt) & flCTdTg_tinMainInPool ) ) ) ;
        #endif
            __( sizeof( countT ) != sizeof( ULONG ) || fnu ) ;
            __( sizeof( countT ) != sizeof( DWORD ) || fnu ) ;
        #elif defined( __NT__ )
            __( sizeof( countT ) != sizeof( TID ) || fnu ) ;
        #ifdef __OS2__
        ZE( boolT , fnu ) ;
        if( POOP ) return ;
        __( !((tin1S&)tin0P).pag1->_thirdC_.pSwThreadHandle ) ;
        __Z( tmFP ) ;
        __( tidP ) ;
        FV( flTHREADlAUNCH , flagsP )
        if( POOP ) return ;
    {
    IFbEcAREFUL    
{
/*1*/voidT thirdC::c_beginthreadIF( tin0S& tin0P , countT& tidP , voidT* const tmFP , voidT* pvP , const flagsT flagsP , const countT cbStackP )/*1*/

#endif
    typedef ULONG (OSF *tmfosFT)( voidT* argP ) ;
#elif defined( __NT__ )
    typedef voidT (OSF *tmfosFT)( ULONG argP ) ;
#ifdef __OS2__
//DUPLICATED CODE: 1020057 1610008

/**/
*/
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00100f6.flTHREADlAUNCH!||
 flagsP
 pvP
 tmFP
 tidP
arguments
  then cc can be passed to the thread
  countT& cc = third.os_cAllKidThreadsI_IF( tin0P )
 example
 to do this, pass a reference to the thread so it can decrement
the thread must decrement this counter just before ending
cAllKidThreadsI or ((tin1S&)tin0P).pag1->_thirdC_.cAllOrphanThreads is incremented
the new thread inherits the priority of the calling thread
creates a new thread of execution
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.1020057.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$c_beginthreadIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

