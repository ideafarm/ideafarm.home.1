
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#undef L2
#undef M2

}
    moonThePhotographersF( tin0P ) ;

    ungrabF( tin0P ) ;

    }
        }
            }
                if( pPaper->pcSize[ pPaper->offos ] ) ++ pPaper->offos ;

                SETtAILiF
            {
            else
            }
                stq_bDetached.purgeF( tin0P ) ;
                stq_grid.purgeF( tin0P ) ;

                }
                    }
                        //LOGrAW9( "swgt [idf,rgb,cGlyph,cPoint]: " , idf , " " , cLever_rgb , " " , gt.cGlyph , " " , gt.cPoint , "\r\n" ) ;

                        new( 0 , tin0P , (byteT*)pPaper , sizeof( paperS ) ) paperS( tin0P , gt.cGlyph , gt.cPoint ) ;
                        paperS* pPaper = (paperS*)&(countT&)swPaper ;
                    {
                    if( gt.cGlyph && gt.cPoint )
                    glyphTallyS& gt = *(glyphTallyS*)&(countT&)swgt ;
                    cLever_rgb = swgt.leverF( tin0P , idf ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                countT cFlavors = swgt.cFlavorsF( tin0P ) ;

                }
                                   cPointNew = 0 ;
                    pgt->cPoint += cPointNew ;
                    pgt->cGlyph ++ ;
                {
                if( cPointNew )
            {
            if( !offPass )

            }
                pGrid->advanceGridIfF( *pGridDad , psttP[ offi ].idCaste , ptLag1 ) ;

                }
                    }
                        break ;
                        }
                            else            pGrid->flags &= ~( F(flGRIDs_DETACHED) ) ;
                            if( bDetached ) pGrid->flags |= flGRIDs_DETACHED ;

                            stq_bDetached >> bDetached ;
                            ZE( boolT , bDetached ) ;
                        {
                        if( stq_bDetached )
                    {
                    case sc_POPdETACHaTTACH :
                    }
                        break ;
                        pGrid->flags &= ~( F(flGRIDs_DETACHED) ) ;
                        stq_bDetached << (boolT)!!( F(pGrid->flags) & flGRIDs_DETACHED ) ;
                    {
                    case sc_PUSHaTTACH :
                    }
                        break ;
                        pGrid->flags |= flGRIDs_DETACHED ;
                        stq_bDetached << (boolT)!!( F(pGrid->flags) & flGRIDs_DETACHED ) ;
                    {
                    case sc_PUSHdETACH :
                    }
                        break ;
                        }
                            case 'O'  : { M2(0,0) L2(6,0)  L2(6,6) L2(0,6) L2(0,0) break ; } //M2(1,1) L2(5,1)  L2(5,5) L2(1,5) L2(1,1)
                            case ' '  : {                                          break ; }
                        {
                        switch( psttP[ offi ].idAdam )

                        SEThEADiF
                    {
                    case sc_cSYMBOL1 :
                    }
                        break ;
                        }
                            pGrid    = (gridS*)&stq_grid[ stq_idGrid[ 1 ]                                  ] ;
                            pGridDad = (gridS*)&stq_grid[ stq_idGrid[ 1 ] + ( stq_idGrid[ 1 ] < stq_grid ) ] ;
                            stq_idGrid >> idg ;
                            ZE( countT , idg ) ;
                        {
                        if( stq_idGrid > 1 )
                    {
                    case sc_cPOPiDgRID :
                    }
                        break ;
                        }
                            pGrid    = (gridS*)&stq_grid[ stq_idGrid[ 1 ]                                  ] ;
                            pGridDad = (gridS*)&stq_grid[ stq_idGrid[ 1 ] + ( stq_idGrid[ 1 ] < stq_grid ) ] ;
                            stq_idGrid << psttP[ offi ].idAdam ;
                        {
                        if( psttP[ offi ].idAdam && psttP[ offi ].idAdam <= stq_grid )
                    {
                    case sc_cPUSHiDgRID :
                    }
                        break ;
                        }
                            //((tin123S&)tin0P).pEther->traceF( tin0P , T("sc_mmLINEtO [x,y]:    ")+TF2(ptLag1.x,flFORMAT_NObIGITvALUES)+T("    ")+TF2(ptLag1.y,flFORMAT_NObIGITvALUES) ) ;
                            //LOGrAW5( "paper mmLINEtO [x,y]: " , ptLag1.x , " " , ptLag1.y , "\r\n" ) ;
                            pGridDad->highWaterF( ptLag1 ) ;
                            pPaper->pPoint[ pPaper->offop ++ ] = ptLag1 ;

                            SETlAG( pGrid->offCol + pGrid->offColMax * *(measureT*)&psttP[ offi ].idAdam , pGrid->offRow + pGrid->offRowMax * *(measureT*)&psttP[ offi ].cNote )
                            //LOGrAW7( "mmLINEtO calculation of y [pGrid->offRow,pGrid->offRowMax,R(*(measureT*)&psttP[ offi ].cNote)]: " , pGrid->offRow , " " , pGrid->offRowMax , " " , R( *(measureT*)&psttP[ offi ].cNote ) , "\r\n" ) ;

                            ++ pPaper->pcSize[ pPaper->offos ] ;

                            }
                                pGridDad->highWaterF( ptLag1 ) ;
                                pPaper->pPoint[ pPaper->offop ++ ] = ptLag1 ;
                                ++ pPaper->pcSize[ pPaper->offos ] ;
                            {
                            if( !pPaper->pcSize[ pPaper->offos ] )

                            if( pPaper->offos >= pPaper->cGlyph ) { BLAMMO ; }

                            SEThEADiF
                        {
                        else
                        if( !offPass ) cPointNew += 1 + !cPointNew ;
                    {
                    case sc_mmLINEtO :
                    }
                        break ;
                        }
                            //LOGrAW5( "paper ccLINEpEL [x,y]: " , ptLag1.x , " " , ptLag1.y , "\r\n" ) ;
                            pGridDad->highWaterF( ptLag1 ) ;
                            pPaper->pPoint[ pPaper->offop ++ ] = ptLag1 ;

                            SETlAG( ptLag1.x + psttP[ offi ].idAdam , ptLag1.y + psttP[ offi ].cNote )

                            ++ pPaper->pcSize[ pPaper->offos ] ;
                            }
                                pGridDad->highWaterF( ptLag1 ) ;
                                pPaper->pPoint[ pPaper->offop ++ ] = ptLag1 ;
                                ++ pPaper->pcSize[ pPaper->offos ] ;
                            {
                            if( !pPaper->pcSize[ pPaper->offos ] )

                            if( pPaper->offos >= pPaper->cGlyph ) { BLAMMO ; }

                            SEThEADiF
                        {
                        else
                        }
                            cPointNew += 1 + !cPointNew ;
                        {
                        if( !offPass )
                    {
                    case sc_ccLINEpEL :
                    }
                        break ;

                        }
                            //LOGrAW5( "paper mmMOVEpEL [x,y]: " , ptLag1.x , " " , ptLag1.y , "\r\n" ) ;
                            SETlAG( ptLag1.x + psttP[ offi ].idAdam , ptLag1.y + psttP[ offi ].cNote )

                            if( pPaper && pPaper->pcSize[ pPaper->offos ] ) ++ pPaper->offos ;

                            SETtAILiF
                        {
                        else
                        }
                            }
                                               cPointNew = 0 ;
                                pgt->cPoint += cPointNew ;
                                pgt->cGlyph ++ ;
                            {
                            if( cPointNew )
                        {
                        if( !offPass )
                    {
                    case sc_ccMOVEpEL :
                    }
                        break ;
                        }
                            //((tin123S&)tin0P).pEther->traceF( tin0P , T("sc_mmMOVEtO [x,y]:    ")+TF2(ptLag1.x,flFORMAT_NObIGITvALUES)+T("    ")+TF2(ptLag1.y,flFORMAT_NObIGITvALUES) ) ;
                            //LOGrAW5( "\r\npaper mmMOVEtO [x,y]: " , ptLag1.x , " " , ptLag1.y , "\r\n" ) ;
                            SETlAG( p00.x , p00.y )                                                                                                                     \
                            cPoint2S p00 = { pGrid->offCol + pGrid->offColMax * *(measureT*)&psttP[ offi ].idAdam , pGrid->offRow + pGrid->offRowMax * *(measureT*)&psttP[ offi ].cNote } ;
                            //LOGrAW7( "mmMOVEtO calculation of y [pGrid->offRow,pGrid->offRowMax,R(*(measureT*)&psttP[ offi ].cNote)]: " , pGrid->offRow , " " , pGrid->offRowMax , " " , R( *(measureT*)&psttP[ offi ].cNote ) , "\r\n" ) ;

                            if( pPaper && pPaper->pcSize[ pPaper->offos ] ) ++ pPaper->offos ;

                            SETtAILiF
                        {
                        else
                        }
                            }
                                               cPointNew = 0 ;
                                pgt->cPoint += cPointNew ;
                                pgt->cGlyph ++ ;
                            {
                            if( cPointNew )
                        {
                        if( !offPass )
                    {
                    case sc_mmMOVEtO :
                    }
                        break ;

                        }
                            }
                                pPaper = (paperS*)&(countT&)swPaper ;
                                cLever_rgb = psttP[ offi ].idAdam ;
                            {
                            if( swPaper.idSlotOfLeverF( tin0P , psttP[ offi ].idAdam ) )

                            if( pPaper && pPaper->pcSize[ pPaper->offos ] ) ++ pPaper->offos ;
                        {
                        else
                        }
                            pgt = (glyphTallyS*)&(countT&)swgt ;
                            cLever_rgb = psttP[ offi ].idAdam ;

                            if( !pgt->cGlyph ) swgt.freeF( tin0P ) ;

                            }
                                               cPointNew = 0 ;
                                pgt->cPoint += cPointNew ;
                                pgt->cGlyph ++ ;
                            {
                            if( cPointNew )
                        {
                        if( !offPass )
                    {
                    case sc_cCOLOR :
                {
                switch( psttP[ offi ].idCaste )

                }
                    }
                        //LOGrAW5( "\r\nwrapping to [offCol,offRow]: " , pGrid->offCol , " " , pGrid->offRow , "\r\n" ) ;
                        if( pGrid->offRow < pGridDad->cRowHighWater + pGrid->cRowPad ) pGrid->offRow = pGridDad->cRowHighWater + pGrid->cRowPad ;

                        //pGrid->offRow += pGrid->cRowPad + pGrid->offRowMax + 1 ;
                        //U::PROVIDE A FLAG THAT DECLARES THAT WRAP SHOULD ALWAYS RISE BY AT LEAST THE GRID HEIGHT
                        //BECAUSE SCREEN REAL ESTATE IS SCARCE, WRAP GOES TO HIGH WATER, WHICH MIGHT PRODUCE A VERY THIN ROW (E.G. IF IT IS ALL UNDERSCORES '_')

                        pGrid->offCol = 0 ;
                    {
                    if( offColEnd < offColNew )

                    //LOGrAW9( "\r\ninspecting for wrap [offi,csttWordHere,offColEnd,offColNew]: " , offi , " " , csttWordHere , " " , offColEnd , " " , offColNew , "\r\n" ) ;
                    countT offColNew = pGrid->offCol + ( pGrid->cColPad + pGrid->offColMax + 1 ) * csttWordHere ;
                    countT offColEnd = pGridDad->offCol + pGridDad->offColMax + 1 ;

                    stq_bDetachedFuture.purgeF( tin0P ) ;
                    }
                        csttWordHere ++ ;

                        else if( bContinue ) continue ;
                        if( bBreak ) break ;

                        }
                            default : { bBreak = 1 ; break ; }

                            }
                                break ;
                                if( ( F(pGrid->flags) & flGRIDs_DETACHEDaLWAYS || F(flagsLater) & flGRIDs_DETACHED ) && cOver ++ ) bContinue = 1 ; //A:ASSUME: ALL MOVES AND LINES ARE WITHIN THE GRID (IF NOT TRUE THEN MIGHT NEED A WRAP THAT I WILL NOT DO)
                            {
                            case sc_mmLINEtO :
                            case sc_ccLINEpEL :
                            case sc_ccMOVEpEL :
                            case sc_mmMOVEtO :
                            // EACH MOVE AND LINE IS ASSUMED TO RESULT IN POINTS THAT ARE ALL WITHIN THE GRID ; IF FALSE THEN THOSE OUT OF BOUNDS PELS MIGHT EXTEND BEYOND THE WRAPPING BOUNDARY
                            // CASTES THAT COUNT TOWARD WORD LENGTH GO HERE

                            }
                                //INTENTIONAL FALLTHROUGH
                                if( psttP[ offi2 ].idAdam == ' ' ) bBreak = 1 ;
                            {
                            case sc_cSYMBOL1 :
                            // THIS CASTE NORMALLY COUNTS TOWARD WORD LENGTH, BUT IF ' ' IT DOES NOT AND ALSO IT TERMINATES COUNTING

                            }
                                break ;
                                bContinue = 1 ;
                            {
                            case sc_cCOLOR :
                            // CASTES THAT DO NOT COUNT TOWARD WORD LENGTH GO HERE

                            }
                                break ;
                                bBreak = 1 ;
                            {
                            case sc_cPOPiDgRID :
                            case sc_cPUSHiDgRID :
                            // CASTES THAT TERMINATE A WORD GO HERE (A WORD IS ALSO TERMINATED BY A ' ')

                            }
                                break ;
                                bContinue = 1 ;
                                }
                                    else            flagsLater &= ~( F(flGRIDs_DETACHED) ) ;
                                    if( bDetached ) flagsLater |= flGRIDs_DETACHED ;

                                    stq_bDetachedFuture >> bDetached ;
                                    ZE( boolT , bDetached ) ;
                                {
                                if( stq_bDetachedFuture )
                            {
                            case sc_POPdETACHaTTACH :
                            }
                                break ;
                                bContinue = 1 ;
                                stq_bDetachedFuture << (boolT)!!( F(pGrid->flags) & flGRIDs_DETACHED ) ;
                            {
                            case sc_PUSHaTTACH :
                            }
                                break ;
                                bContinue = 1 ;
                                stq_bDetachedFuture << (boolT)!!( F(pGrid->flags) & flGRIDs_DETACHED ) ;
                            {
                            case sc_PUSHdETACH :
                            // CASTES THAT CONTROL THE COUNTING OF WORD LENGTH GO HERE
                        {
                        switch( psttP[ offi2 ].idCaste )
                        ZE( boolT , bBreak    ) ;
                        ZE( boolT , bContinue ) ;
                    {
                    for( countT offi2 = offi ; offi2 < offe ; offi2 ++ )
                    ZE( countT , cOver ) ;
                    flagsT flagsLater = pGrid->flags ;
                    ZE( countT , csttWordHere ) ;
                {
                if( offPass && F(pGrid->flags) & flGRIDs_WRAP && !( F(pGrid->flags) & ( flGRIDs_DETACHED | flGRIDs_DETACHEDaLWAYS ) ) )
                //A:ASSUME: DECISION TO WRAP DOES NOT AFFECT THE NUMBER OF POINTS (IF NOT TRUE THEN DO WRAP ON BOTH PASSES)
            {
            for( countT offi = CSpREFIX ; offi < offe ; offi ++ )
            countT offe = CSpREFIX + psttP->idAdam ;
            ZE( countT , offo ) ;
            ZE( countT , cPointNew ) ;
            cPoint2S ptLag1 = { 0 , 0 } ; //A REASONABLE IMPLIED STARTING POINT SO THAT OMISSION OF AN EXPLICIT MOVE WILL PRODUCE REASONABLE OUTPUT
            cPoint2S ptLag2 = { 0 , 0 } ;
            staqC stq_bDetachedFuture( tin0P ) ;
            staqC stq_bDetached( tin0P ) ;
            ZE( countT , offpInGlyph ) ;
            ZE( countT , offosHead ) ;
            ZE( paperS* , pPaperHead ) ;
            cPoint2S ptHead = { 0 , 0 } ;

            }
                if( idf ) pPaper = (paperS*)&swPaper[ idf ] ;
                countT idf = swPaper.idSlotOfLeverF( tin0P , ifcRGB_W4 ) ;
            {
            else
            }
                pgt->cPoint = pgt->cGlyph = 0 ;
                pgt = (glyphTallyS*)&(countT&)swgt ;
                cLever_rgb = ifcRGB_W4 ;
            {
            if( !offPass )
            ZE( glyphTallyS* , pgt ) ;
            ZE( paperS* , pPaper ) ;

            gridS* pGrid    = (gridS*)&stq_grid[ stq_idGrid[ 1 ]                                  ] ;
            gridS* pGridDad = (gridS*)&stq_grid[ stq_idGrid[ 1 ] + ( stq_idGrid[ 1 ] < stq_grid ) ] ;

            stq_idGrid << (countT)1 ;
            staqC stq_idGrid( tin0P , sizeof( countT ) , 8 ) ;

            }
                new( 0 , tin0P , (byteT*)pGridText , sizeof( gridS ) ) gridS( pGridDeviceNet->offCol , pGridDeviceNet->offRow , cColPer , cRowPer , /*flGRIDs_PAD |*/ flGRIDs_WRAP ) ;
                pGridText = (gridS*)&(countT&)stq_grid[ 1 ] ;
                stq_grid << (byteT*)0 ;

                countT cRowPer = 1 + pGridDeviceNet->offRowMax / 0x4/*0x18*/ ;
                countT cColPer = 1 + pGridDeviceNet->offColMax / 0x10/*0x60*/ ;
            {
            ZE( gridS* , pGridText ) ; // 06 COLS BY 81 ROWS

            }
                new( 0 , tin0P , (byteT*)pGridDeviceNet , sizeof( gridS ) ) gridS( cColMargin , cRowMargin , 1 + pGridDeviceGross->offColMax - ( cColMargin << 1 ) , 1 + pGridDeviceGross->offRowMax - ( cRowMargin << 1 ) , flGRIDs_DETACHEDaLWAYS ) ;
                pGridDeviceNet = (gridS*)&(countT&)stq_grid[ 1 ] ;
                stq_grid << (byteT*)0 ;
                countT cRowMargin = 0/*pGridDeviceGross->cRow / ( TUCK >> 2 )*/ ;
                countT cColMargin = 0/*pGridDeviceGross->cCol / ( TUCK >> 2 )*/ ;
            {
            ZE( gridS* , pGridDeviceNet ) ;

            }
                new( 0 , tin0P , (byteT*)pGridDeviceGross , sizeof( gridS ) ) gridS( 0 , 0 , cCol , cRow , flGRIDs_DETACHEDaLWAYS ) ;
                pGridDeviceGross = (gridS*)&(countT&)stq_grid[ 1 ] ;
                stq_grid << (byteT*)0 ;
            {
            ZE( gridS* , pGridDeviceGross ) ;
            staqC stq_grid( tin0P , sizeof( gridS ) , 8 ) ;

            //LOGrAW3( "********************************************************************* [offPass]: " , offPass , "\r\n" ) ;
        {
        for( countT offPass = 0 ; offPass <= 1 ; offPass ++ )
        switchC swgt( tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cLever_rgb , 0 , sizeof( glyphTallyS ) ) ;
    {
    if( psttP && psttP->idAdam )

    }
        swPaper.freeAllF( tin0P ) ;
        }
            DELzOMBIE( pPaper ) ;
            paperS* pPaper = (paperS*)&(countT&)swPaper ;
            cLever_rgb = swPaper.leverF( tin0P , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swPaper.cFlavorsF( tin0P ) ;
    {

    grabF( tin0P , TAG( TAGiDnULL ) ) ;
{
/*1*/voidT paperC::strokeF( tin0S& tin0P , const strokeS* const psttP )/*1*/

    }
        /*LOGrAW5( "paper L2 [x,y]: " , ptLag1.x , " " , ptLag1.y , "\r\n" ) ;*/                                                                    \
        pGridDad->highWaterF( ptLag1 ) ;                                                                                                            \
        pPaper->pPoint[ pPaper->offop ++ ] = ptLag1 ;                                                                                               \
                                                                                                                                                    \
        SETlAG( pGrid->offCol + pGrid->pcOffColSym[ offColP ] , pGrid->offRow + pGrid->pcOffRowSym[ offRowP ] )                                     \
                                                                                                                                                    \
        ++ pPaper->pcSize[ pPaper->offos ] ;                                                                                                        \
                                                                                                                                                    \
        }                                                                                                                                           \
            pGridDad->highWaterF( ptLag1 ) ;                                                                                                        \
            pPaper->pPoint[ pPaper->offop ++ ] = ptLag1 ;                                                                                           \
            ++ pPaper->pcSize[ pPaper->offos ] ;                                                                                                    \
        {                                                                                                                                           \
        if( !pPaper->pcSize[ pPaper->offos ] )                                                                                                      \
                                                                                                                                                    \
        if( pPaper->offos >= pPaper->cGlyph ) { BLAMMO ; }                                                                                          \
    {                                                                                                                                               \
    else                                                                                                                                            \
    }                                                                                                                                               \
        cPointNew += 1 + !cPointNew ;                                                                                                               \
    {                                                                                                                                               \
    if( !offPass )                                                                                                                                  \
                                                                                                                                                    \
#define L2(offColP,offRowP)                                                                                                                         \

#define SETlAG(xP,yP) { ptLag2 = ptLag1 ; ptLag1.x = (xP) ; ptLag1.y = (yP) ; }

    }
        /*LOGrAW5( "\r\npaper M2 [x,y]: " , ptLag1.x , " " , ptLag1.y , "\r\n" ) ;*/                                                                \
        SETlAG( p00.x , p00.y )                                                                                                                     \
        cPoint2S p00 = { pGrid->offCol + pGrid->pcOffColSym[ offColP ] , pGrid->offRow + pGrid->pcOffRowSym[ offRowP ] } ;                          \
                                                                                                                                                    \
        if( pPaper && pPaper->pcSize[ pPaper->offos ] ) ++ pPaper->offos ;                                                                          \
    {                                                                                                                                               \
    else                                                                                                                                            \
    }                                                                                                                                               \
        }                                                                                                                                           \
                           cPointNew = 0 ;                                                                                                          \
            pgt->cPoint += cPointNew ;                                                                                                              \
            pgt->cGlyph ++ ;                                                                                                                        \
        {                                                                                                                                           \
        if( cPointNew )                                                                                                                             \
    {                                                                                                                                               \
    if( !offPass )                                                                                                                                  \
                                                                                                                                                    \
#define M2(offColP,offRowP)                                                                                                                         \

    }
        }                                                                                                                                           \
            pPaperHead->pPointTail[ offosHead ] = ptLag2 ;                                                                                          \
            pPaperHead->pFlagsTail[ offosHead ] = flTAIL_SET ;                                                                                      \
        {                                                                                                                                           \
        if( ptHead == ptLag1 )                                                                                                                      \
                                                                                                                                                    \
        offpInGlyph = 0 ;                                                                                                                           \
    {                                                                                                                                               \
    if( offpInGlyph )                                                                                                                               \
                                                                                                                                                    \
#define SETtAILiF                                                                                                                                   \

    }
        ptHead     = ptLag1 ;                                                                                                                       \
        offosHead  = pPaper->offos ;                                                                                                                \
        pPaperHead = pPaper ;                                                                                                                       \
    {                                                                                                                                               \
    if( !( offpInGlyph ++ ) )                                                                                                                       \
                                                                                                                                                    \
#define SEThEADiF                                                                                                                                   \

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

