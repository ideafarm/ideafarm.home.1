
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;

}
    ++ s ; ether.osSleepF( tinP , TOCK << 0 ) ;
    etThread.traceF( tinP , T("[speedPull,speedPush,deltaTime,deltaPush,deltaPull,diff]:    ")+TF2(speedPull,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(speedPush,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TT(timeE1,timeE2)+tb4+TF2(deltaPush,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(deltaPull,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(deltaPush-deltaPull,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    countT speedPush = (countT)deltaPush / ( timeE1 >> 2 ) ;
    countT speedPull = (countT)deltaPull / ( timeE1 >> 2 ) ;

    timeLag2 = timeN2 ;
    timeLag1 = timeN1 ;

    etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeLag1 , timeLag2 ) ;
    sCountT timeE2 = timeN2 ;
    countT  timeE1 = timeN1 ;

    etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
    ZE( sCountT  , timeN2 ) ;
    ZE( countT   , timeN1 ) ;

    snapPush = nowPush ;
    snapPull = nowPull ;

    count04T deltaPush = nowPush - snapPush ;
    count04T deltaPull = nowPull - snapPull ;

    count04T nowPush = tallyPush ;
    count04T nowPull = tallyPull ;
{
while( !ether )
sleepC s( tinP , TAG( TAGiDnULL ) ) ;
TN( tb4 , "    " ) ;
ZE( count04T , snapPush ) ;
ZE( count04T , snapPull ) ;
ZE( sCountT  , timeLag2 ) ;
ZE( countT   , timeLag1 ) ;

while( cDo -- ) etThread.osThreadF( TaRG3fLAGScBtLS( tmPushF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&fun , (countT)&tallyPush ) ;
cDo = CwORKERS ;

while( cDo -- ) etThread.osThreadF( TaRG3fLAGScBtLS( tmPullF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&fun , (countT)&tallyPull ) ;
countT cDo = CwORKERS ;

ZE( count04T , tallyPull ) ;
ZE( count04T , tallyPush ) ;
funnelHornC fun( tinP , etThread , ether , 1 , TOCK >> 0 ) ;

TODO

DONE( tmPullF )
}
    }
        }
            if( -1 == incv02AM( tally1 ) ) inc02AM( tally2 ) ;
            //etThread.traceF( tinP , T("read [pb2]:    ")+T(pb2) ) ;
        {
        if( pbi )
        byteT pb2[] = { (byteT)( !pbi ? 0 : *pbi ) , 0 } ;
        const byteT* pbi = funP.readF( tinP ) ;
    {
    while( !ether )

    countT&      tally2  = ((countT*)&tallyP)[ 1 ] ;
    countT&      tally1  = ((countT*)&tallyP)[ 0 ] ;

    count04T&    tallyP  =    *(count04T*)pTaskP->c2 ;
    funnelHornC& funP    = *(funnelHornC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmPullF )

DONE( tmPushF )
}
    }
        }
            if( -1 == incv02AM( tally1 ) ) inc02AM( tally2 ) ;
            funP.writeF( tinP , pb2 ) ;
        {
        for( pb2[ 0 ] = 'a' ; pb2[ 0 ] <= 'z' && !ether ; pb2[ 0 ] ++ )
    {
    while( !ether )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    byteT pb2[] = { 0 , 0 } ;

    countT&      tally2  = ((countT*)&tallyP)[ 1 ] ;
    countT&      tally1  = ((countT*)&tallyP)[ 0 ] ;

    count04T&    tallyP  =    *(count04T*)pTaskP->c2 ;
    funnelHornC& funP    = *(funnelHornC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmPushF )

#define CwORKERS ( TUCK >> 3 )
// ( TUCK >> 3 ) IS THE MOST THAT CAN BE ACCOMMODATED WITHOUT MEMORY EXHAUSTION

/*1*/WAKEsHOW( "example.other.1snip.150001a5.funnelHornC.gorilla" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
