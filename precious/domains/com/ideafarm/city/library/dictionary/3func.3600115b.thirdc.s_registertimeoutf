
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pks ;
    ((tinNormalS&)tinBaseP).pag1->_thirdC_.pSwKillSocket->ungrabF( tinBaseP ) ;
    }
        }
            pks->timeExpire2 = timeEN2 ;
            pks->timeExpire1 = timeEN1 ;
        {
        if( timeEN2 < pks->timeExpire2 || ( timeEN2 == pks->timeExpire2 && timeEN1 < pks->timeExpire1 ) )
        osTimeSubtractF( tinBaseP , timeEN1 , timeEN2 , pks->timeExpire1 , pks->timeExpire2 ) ;
        sCountT timeD2 = timeEN2 ;
        countT  timeD1 = timeEN1 ;
        osTimeAddIF( tinBaseP , timeEN1 , timeEN2 , time1P , time2P ) ;
        osTimeNowF( tinBaseP , timeEN1 , timeEN2 ) ;
        ZE( sCountT , timeEN2 ) ;
        ZE( countT  , timeEN1 ) ; //"en": "expire new"
    {
    else
    }
        osTimeAddIF( tinBaseP , pks->timeExpire1 , pks->timeExpire2 , time1P , time2P ) ;
        osTimeNowF( tinBaseP , pks->timeExpire1 , pks->timeExpire2 ) ;
    {
    if( !incv02AM( pks->cRef ) )
    pks = (killSocketS*)&(countT&)*((tinNormalS&)tinBaseP).pag1->_thirdC_.pSwKillSocket ;
    ((tinNormalS&)tinBaseP).pag1->_thirdC_.cLever_pSwKillSocket = (countT)&handleP ;
    ((tinNormalS&)tinBaseP).pag1->_thirdC_.pSwKillSocket->grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
    ZE( killSocketS* , pks ) ;
    SCOOP
{
/*1*/killSocketS* thirdC::s_registerTimeoutF( tinBaseS& tinBaseP , const handleC& handleP , const countT time1P , const sCountT time2P )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

