
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bMatch ;

    bMatch = 0 ;
    )
        !bArmedStar && cArmedQuestion < cWildRemain                                 // TOO MANY WILD REMAIN
        ||
        cWildRemain < cArmedQuestion                                                // NOT ENOUGH WILD REMAIN
    (
    if

    countT cWildRemain = psttP->idAdam - cOk ;

    delF( tin0P , pstt1w ) ;
    }
        }
            cArmedQuestion = bArmedStar = 0 ;

            }
                else cOk = idf ? idf - 1 : psttP->idAdam ;
                }
                    break ;
                    bMatch = 0 ;
                {
                )
                    !bArmedStar && cArmedQuestion < cWildEat                        // TOO MANY WILD EATEN
                    ||
                    cWildEat < cArmedQuestion                                       // NOT ENOUGH WILD EATEN
                    ||
                    !idHit                                                          // NOT FOUND
                (
                if

                ;
                    :             0
                    ?             idHit -  cOk - 1
                countT cWildEat = idHit >= cOk + 1

                countT idHit = strIdF( tin0P , countTC( 1 ) , 0 , flSTRmATCH_null , idf , sttq , psttc1 , psttP ) ;            
                countT idf = cOk + 1 ;
            {
            else
            }
                break ;
                bMatch = 0 ;
            {
            if( psttP->idAdam - cOk < psttc1->idAdam )                              // IF NOT ENOUGH THEN QUIT
        {
        if( !cWild )

        }
            while( idfq && strIdF( tin0P , countTC( 1 ) , 0 , flSTRmATCH_null , idfq , sttq , tQuestion , psttc1 ) ) { cArmedQuestion ++ ; cWild ++ ; }
            countT idfq = 1 ;
        {

        if( strIdF( tin0P , countTC( 1 ) , tStar , psttc1 ) ) cWild = bArmedStar = 1 ;              // MULTIPLE ASTERISKS ARE REDUNDANT AND ONLY WO WILL BE COUNTED
        ZE( countT , cWild ) ;                                                      // THIS IS ONLY USED AS A BOOLEAN

        //traceF( tin0P , T("like: ")+T(psttc1) ) ;
    {
    FORsTRINGSiN1( pstt1w )
    ZE( countT , cArmedQuestion ) ;
    ZE( boolT , bArmedStar ) ;
    TN( tQuestion , "?" ) ;
    TN( tStar , "*" ) ;
    strWordsF( tin0P , pstt1w , psttLikeP , sttq , T("*?") , flSTRwORDS_DELIMITERS ) ; ___( pstt1w ) ;
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , pstt1w ) ;

    ZE( countT , cOk ) ;

    boolT bMatch = 1;

    //traceF( tin0P , T("[psttP]    : ")+T(psttP    ) ) ;
    //traceF( tin0P , T("[psttLikeP]: ")+T(psttLikeP) ) ;

    }
        if( POOP ) return 0 ;
        __Z( *psttLikeP ) ;
        if( POOP ) return 0 ;
        __Z( psttP ) ;
        __Z( psttLikeP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/boolT etherC::strFileMatchF( tin0S& tin0P , const strokeS* const psttLikeP , const strokeS* const psttP )/*1*/

/**/

*/
 i was tested using Windows 7
i am intended to produce exactly the same result that would be produced by the base operating system
 any other stroke matches only itself
 '?' matches exactly wo strokes
 '*' matches ze or more strokes
 the pattern is a string containing '*', '?', and other strokes
i return true iff psttP satisfies the pattern specified in psttLikeP
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

