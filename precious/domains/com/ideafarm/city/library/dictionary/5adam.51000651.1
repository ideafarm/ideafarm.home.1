
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etThread.osThreadSwitchingDesireF( tin0P , idDesireSave ) ;

    }
        }
            }
                sgnKidHired.giveF( tin0P ) ;

                ether.osSleepF( tin0P , TIMEnAPdURINGsERVICEsTARTUP ) ;

                else            ;//ether.traceF( tin0P , T("sandbox so not hiring SNAPwORDS") ) ;
                if( !bSandbox ) ether.ifcHireF( tin0P , T("PISS") , ifcIDaDAM_SNAPwORDS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; // flHIRE_DISPLAYaUTO CAN BE COMMENTED OUT TO AVOID WDW FOR ROOT CLOUD INSTANCE WHICH IS USUALLY NOT INTERESTING
                bSandbox = 0 ;
                boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;
                bWoth = 0 ;
                _IO_
            {                           //20240809@1306: COULD NOT DESTROY soulAsciiIn on tmObeySoilF ; CONJ: BUNDLE CONTINUED TO HIRE OTHER ADAMS, WO OR MORE OF WHICH OPENED A BACKING booksC FILE WITH THE SAME NAME
            if( bWoth )                 //A:ASSUME: ALL SOIL FILES PRESENT WHEN I STARTED HAVE BEEN COMPLETELY OBEYED, SO THAT ANY CHANGES TO SETTINGS HAVE BEEN COMPLETELY DONE

            }
                while( cFail ) ;
                }
                    if( cFail ) { ++ s ; ether.osSleepF( tin0P , TOCK ) ; }

                    }
                        FORsTRINGSiNsPANNEDcOMBINEDtAIL1
                        }
                            }
                                }
                                    }
                                        sgnDone_tmObeySoilF.waitF( tin0P ) ;
                                        etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmObeySoilF , sgnDone_tmObeySoilF , CBsTACKmIN << 3 ) , (countT)&cFail , (countT)&grabObey , (countT)(strokeS*)t14PickSoil , (countT)(strokeS*)t13Bounce , (countT)psttFileName , (countT)psttTmpKtCodeSoii , (countT)posti , costi ) ; psttFileName = 0 ; posti = 0 ;
                                        signC sgnDone_tmObeySoilF( tin0P , TAG( TAGiDnULL ) ) ;
                                        etThread.strMakeF( tin0P , LF , psttFileName , tFileBeingEaten ) ; ___( psttFileName ) ;
                                        ZE( strokeS* , psttFileName ) ;
                                        _IO_
                                    {

                                    }
                                        etThread.boxPutF( tin0P , psttTmpKtCodeSoii , tNow , tNow.csF( tin0P ) ) ;

                                        }
                                            etThread.strMakeF( tin0P , LF , psttTmpKtCodeSoii , tFileTmpSoii ) ; ___( psttTmpKtCodeSoii ) ;
                                            etThread.delF( tin0P , psttu ) ;
                                            tFileTmpSoii = T("///ideafarm/tmp/")+TfORsTRING(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T("/kt.code.")+T(psttu)+T(".soii") ;
                                            etThread.strUniqueF( tin0P , psttu ) ; ___( psttu ) ;
                                            ZE( strokeS* , psttu ) ;
                                            TN( tFileTmpSoii , "" ) ;
                                            _IO_
                                        {

                                        etThread.delF( tin0P , psttNow ) ;
                                        TN( tNow , psttNow ) ;
                                        etThread.strReplaceF( tin0P , psttNow , tWas , ifcIDtYPEsTRrEPLACE_KTsOIIdISPLAYfROMsOURCEsOIL , 0 , flSTRrEPLACE_null ) ;
                                        ZE( strokeS* , psttNow ) ;
                                        TN( tWas , posti ) ;
                                        _IO_
                                    {
                                    ZE( strokeS* , psttTmpKtCodeSoii ) ;
                                    //WRITE AN HTML-DISPLAYABLE IMAGE OF THE INPUT FILE
                                    _IO_
                                {
                                else if(  posti )
                                     if( !costi ) etThread.delF( tin0P , posti ) ;

                                }
                                    }
                                        }
                                            //etThread.traceF( tin0P , T("could not input ")+tFileBeingEaten+T(" ; will nap, then retry") ) ;
                                            cFail ++ ;
                                            POOPRqUIET
                                        {
                                        if( POOP )
                                        ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , tFileBeingEaten , 1 ) ; ___( posti ) ;
                                        SCOOPS
                                    {
                                    IFsCRATCHoK
                                    _IO_
                                {
                                ZE( countT   , costi ) ;
                                ZE( osTextT* , posti ) ;

                                }
                                    }
                                        }
                                            continue ;
                                            //etThread.traceF( tin0P , T("!exception / could not move to ")+tFileBeingEaten+T(" from ")+T(psttc1) ) ;
                                            cFail ++ ;
                                            POOPRqUIET
                                        {
                                        if( POOP )
                                        ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tFileBeingEaten , psttc1 , 1 ) ;
                                        SCOOPS
                                    {
                                    IFsCRATCHoK

                                    etThread.delF( tin0P , psttShort ) ;
                                    etThread.delF( tin0P , psttPath ) ;
                                    tFileBeingEaten = t12EatingSoil+T(psttShort) ;
                                    ___( psttShort ) ;
                                    ___( psttPath ) ;
                                    countT ids = etThread.etherC::strBisectF( tin0P , psttPath , psttShort , psttc1 , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                                    ZE( strokeS* , psttShort ) ;
                                    ZE( strokeS* , psttPath ) ;
                                    _IO_
                                {
                                TN( tFileBeingEaten , "" ) ;
                                _IO_            
                            {
                            if( psttc1[ CSpREFIX - 1 + psttc1->idAdam ].idAdam != '/' )                                 // IF NOT DIRECTORY

                            //CONoUTrAW( T("inspecting: ")+T(psttc1)+T("\r\n") ) ;
                            _IO_
                        {
                        FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
                    {
                    IFsCRATCHoK
                    if( !cFiles ) break ;
                    countT cFiles = etThread.boxMenuF( tin0P , soul1m , t11DropSoil+T("*.soil") , 0 , TUCK ) ; // FOR ALL FILES OR DIRS "*.soil"
                    soulC soul1m( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.eat.menu" ) ;

                    cFail = 0 ;
                    _IO_
                {
                do
                ZE( countT , cFail ) ;
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                _IO_
            {
            if( bWoth || etThread.etherC::diskWaitDirF( tin0P , hWait , ether , t11DropSoil , TOCK << 4 , flWAITdIR_FILEnAME ) )     // ORDER OF TESTING DOES NOT MATTER SINCE diskWaitDirF WILL ALWAYS RETURN TRUE THE WOTH TIME THAT IT IS CALLED FOR A WAIT OBJECT ; AS WRITTEN, THE CODE DOES NOT DEPEND UPON THIS
            _IO_
        {
        while( !ether && !POOP )
        handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
        boolT bWoth = 1 ;
        _IO_
    {
    grabC grabObey( tin0P , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS ) ;        //THIS IS REDUNDANT SINCE CODE USES sgnDone_tmObeySoilF TO WAIT FOR EACH THREAD TO END BEFORE LAUNCHING THE NEXT WO

    const countT idDesireSave = etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIER ) ;

    //}
    //    //ether.osThread AdamF( tin0P , ifcIDaDAM_ROOThTTPsERVER ) ;
    //    //THIS IS THE WO TO USE, BUT ONLY IF MASTER: ether.ifc HireF( tin0P , T("U::TO FIND A WINDOWS RESOURCE LEAK") , ifcIDaDAM_ROOThTTPsERVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; //U:: TO FIND A WINDOWS RESOURCE LEAK
    //{
    //if( !etThread.strCompareF( tin0P , tComputerName , T("ifo.master") ) )
    //20230905@1549: COMMENTED THIS OUT BECAUSE IT IS PROBABLY OBSOLETE

    etThread.osThreadF( TaRG2cBsTACK( tmCleanF , CBsTACKmIN << 1 ) , (countT)(strokeS*)t13Bounce , (countT)(strokeS*)t11DropSoil , (countT)&sgnKidHired ) ;

    signC sgnKidHired( tin0P , TAG( TAGiDnULL ) ) ;   //20250316@2029: THIS IS USED TO WORKAROUND THE TRANSIENT ERROR THAT THE BASE O.S. THINKS THAT SOME OR ALL OF MY KID PROCESSES HAVE AN OPEN HANDLE TO THE BACKING OBJECT OF A soulC INSTANCE THAT tmCleanF USES

    //etThread.osThreadF( TaRG1( tmPingF ) ) ; //U::COMMENTED OUT BECAUSE SAW A FAILURE IN s_writeF 20121219@2102

    //etThread.osThreadF( TaRG1( tmFixArcNamesF ) ) ; // REDUNDANT, JUST IN CASE A FILE WITH A BAD NAME HAS GOTTEN INTO THE ARCHIVE ; U::ADD bQuitP PARAMETER
    //20161112@1559: DISABLED AS PART OF ENHANCING 6d9 TO OPTIONALLY RENAME ALL LOCAL MASTER FILES TO NUMERIC NAMES, PRESERVING THE ORIGINAL NAME IN A HASH LOOKUP FILE

    }
        etThread.osThreadF( TaRG2cBsTACK( tmRenameF , CBsTACKmIN << 1 ) , (countT)pstt21DropArchive ) ;

        //etThread.strMakeF( tin0P , LF , psttNeverDropHere , tNeverDropHere ) ; ___( psttNeverDropHere ) ;
        etThread.strMakeF( tin0P , LF , pstt21DropArchive , t21DropArchive ) ; ___( pstt21DropArchive ) ;
        //ZE( strokeS* , psttNeverDropHere ) ;
        ZE( strokeS* , pstt21DropArchive ) ;
        _IO_
    {

    //) ;
    //
    //    "If you generate too much of data within a single quarter, divide the quarter into 2 or 4 or 8 reporting periods.\r\n"
    //    "When each quarter ends, use a final version of the file for that quarter to obtain IdeaFarm " "(tm) Hoe reports for that quarter.\r\n"
    //    "Workaround: Limit your input file to data for the current IdeaFarm " "(tm) City calendar quarter.\r\n"
    //    "\r\n"
    //    "IPDOS (tm) will not realize this architectural potential until it is ported to the 04 bit cpu architecture.\r\n"
    //    "IPDOS (tm) is designed to run quickly and efficiently on 04 bit (64_9 bit) computers with lots of memory available.\r\n"
    //    "The file that you have dropped is larger than ")+TF2(costiMax,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" bytes (")+TF4(costiMax,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,0,0xa)+T(" bytes).\r\n"
    //    "\r\n"
    //    "Error: The input file is too large.\r\n"
    //
    //TN( tErrorFileTooBig , "" ) ; tErrorFileTooBig = T(
    //const countT costiMax = CSTTmAXsOIL ;

    etThread.boxPutF( tin0P , t21DropArchive+T("readme.txt") , tReadMe , tReadMe.csF( tin0P ) ) ;

    ;
    )

        "Please report any problems or questions by opening an issue on GitHub, using the link above.\r\n"
        "\r\n"
        "        https://www.pkware.com/\r\n"
        "        PKWARE, Inc.\r\n"
        "\r\n"
        "maximizing speed or minimizing file size is important, purchase and install pkzipc.exe:\r\n"
        "zip.exe bundled with IPDOS (tm) will be used.  If the value of your archive is high, or if\r\n"
        "Archive healing will use PKWare's pkzipc.exe if it is installed.  Otherwise, the InfoZip\r\n"
        "\r\n"
        "his archive to eliminate all anomalies.\r\n"
        "easily have confidence in his archive, detect data rot and other data loss early, and \"heal\"\r\n"
        "fully automated.  But with IdeaFarm (tm) Archive Healer, such an administrator can much more\r\n"
        "archive of valuable information up-to-date and secure is an administrative task that cannot be\r\n"
        "keep some of them offsite, and whether you possess unhealed reference copies.  Keeping an\r\n"
        "Success will depend upon how many volumes you have kept up-to-date by healing, whether you\r\n"
        "\r\n"
        "device failures.\r\n"
        "and continue the healing, repeating as needed until healing is proceeding without frequent\r\n"
        "more, so it is usually best practice to remove the failing device, delete the volume lists,\r\n"
        "aware that these device errors are occurring.  Such errors will slow healing down by 10x or\r\n"
        "device errors, which it often does. But you should be reading the trace file so that you are\r\n"
        "even rebooting the computer in the hope that remounting all devices will correct persistent\r\n"
        "Healer is processing a device that is failing, it will retry its I/O operations valiantly,\r\n"
        "It is a good practice to run the chkdsk utility before healing.  When IdeaFarm (tm) Archive\r\n"
        "\r\n"
        "other tools, such as the chkdsk utility.\r\n"
        "and malicious tampering.  Generally speaking, you will need to use this tool together with\r\n"
        "Healer is a tool that you can use to detect data loss due to data rot, damage, human error,\r\n"
        "by itself, especially when devices are failing due to hardware damage.  IdeaFarm (tm) Archive\r\n"
        "to turn the screw.  Similarly, IdeaFarm (tm) Archive Healer cannot heal your archive data all\r\n"
        "A screwdriver will not turn a screw into wood all by itself.  It is a tool that you can use\r\n"
        "\r\n"
        "will reveal any data rot or missing or added files.\r\n"
        "These commands will not detect discrepancies in meta information, such as file times, but\r\n"
        "\r\n"
        "        for %f in (*) do @if     exist r:%f fc   %f r:%f\r\n"
        "        for %f in (*) do @if not exist r:%f echo %f     \r\n"
        "\r\n"
        "        u:\r\n"
        "\r\n"
        "        for %f in (*) do @if     exist u:%f fc   %f u:%f\r\n"
        "        for %f in (*) do @if not exist u:%f echo %f     \r\n"
        "\r\n"
        "        cd \"\\ideafarm.archives\\Joe Smith Personal\\2024\"\r\n"
        "        r:\r\n"
        "        cd \"\\ideafarm.archives\\Joe Smith Personal\\2024\"\r\n"
        "        u:\r\n"
        "\r\n"
        "reference volume:\r\n"
        "known good reference volume, and U is the drive letter of the volume to be compared with the\r\n"
        "done manually at a command prompt as follows.  In this example, R is the drive letter of a\r\n"
        "volumes to each other and/or to other volumes without making any changes.  This can also be\r\n"
        "Advanced users can use IdeaFarm (tm) Archive Healer with nondefault settings to compare such\r\n"
        "\r\n"
        "to set the READ ONLY attribute for each volume.\r\n"
        "You can ensure that such reference volumes are never accidentally \"healed\" by using DISKPART\r\n"
        "periodically compare them with the copies that are maintained by IdeaFarm (tm) Archive Healer.\r\n"
        "uncorrupted and complete and preserve them unhealed for use as reference copies so that you can\r\n"
        "with high value data, you should isolate at least re copies of your archive that you know to be\r\n"
        "In particular, your use of IdeaFarm (tm) Archive Healer is at your own risk.  When using it\r\n"
        "DISCLAIMER:  IdeaFarm (tm) Bundle is offered \"as-is\" with no warranty expressed or implied.\r\n"
        "\r\n"
        "of data loss but does not eliminate the possibility completely.\r\n"
        "scenarios involving devices that are failing.  IdeaFarm (tm) Archive Healer reduces the probability\r\n"
        "maliciously by somewo else who gains access to your computer.  Data loss can also occur in some\r\n"
        "in the archive with the same name.  This can result in data loss if the updating is done\r\n"
        "files whose names begin with a pair of explicit timestamps, those files will replace any file\r\n"
        "instead, it moves rejected files out of its way, into a \"rejects\" folder.  But when you drop\r\n"
        "WARNING: IdeaFarm (tm) Archive Healer is designed to do its work safely.  It never deletes files;\r\n"
        "\r\n"
        "\"rejects\" folder on the same drive and replaced with the updated fset file.\r\n"
        "that IdeaFarm (tm) Bundle updates the archive, each of those stale copies will be moved into a\r\n"
        "match the name of the fset file copies in the archive that it is to replace.  The next time\r\n"
        "name of the resulting fset file will have those timestamps so the full name will exactly\r\n"
        "When you drop a revised file with a name that begins with an explicit pair of timestamps, the\r\n"
        "\r\n"
        "   value stored within the fset file.  The discrepancy will be a millisecond or less.\r\n"
        "6. There will be a small discrepancy between the FILETIME value reported by NTFS and the FILETIME\r\n"
        "\r\n"
        "   changes in NTFS time lath accessed from interfering with healing.)\r\n"
        "   well as for all of the NTFS time values for the fset file itself.  (This is mainly to prevent\r\n"
        "   The time lath written value will be used for all timestamp values within the fset file, as\r\n"
        "5. The NTFS time created and time last accessed values will NOT be preserved in the fset file.\r\n"
        "\r\n"
        "   fset file.  The time last written, as reported by NTFS, will be used as the oo'th timestamp.\r\n"
        "4. If only a single timestamp is found, that will be the woth timestamp in the name of the\r\n"
        "\r\n"
        "   position within the file name, if they are in a format that is recognized.\r\n"
        "   This will also be done if the file name contains oo timestamps in another format or in another\r\n"
        "   that file that exist in the archive, assuming that they were archived with exactly the same name.\r\n"
        "   double timestamp will be used, and the new fset file will replace any older versions of\r\n"
        "3. If the file name begins with a double timestamp in the format shown in the example, then that\r\n"
        "\r\n"
        "   of the file name in the format shown in the example.\r\n"
        "   an archived file in the future, rename it to include a double timestamp at the beginning\r\n"
        "   name.  Support for other formats is subject to change.  If you want to be able to update\r\n"
        "2. Do not rely on the recognition of other formats and positions for timestamps in the file\r\n"
        "\r\n"
        "   generated using the time that the file was lath written, as reported by NTFS.\r\n"
        "1. If the file name does not contain a recognizable timestamp, a double timestamp will be\r\n"
        "\r\n"
        "        20140131@1600.20240415@1200.any.name\r\n"
        "\r\n"
        "by including an explicit double timestamp in the file name, as in this example:\r\n"
        "is generated for the fset file will be the last modified time of the file.  You can override this\r\n"
        "Once archived, files with arbitrary names cannot be revised, because the double timestamp that\r\n"
        "\r\n"
        "A file whose image does not match any other copy will always be rejected.\r\n"
        "Healing is intended to minimize the probability of data loss including \"data rot\" corruption.\r\n"
        "\r\n"
        "copy and then all copies that differ from it are moved to a \"reject folder\" on the same device.\r\n"
        "each file is exactly the same.  When file images differ, voting is used to select an authoritative\r\n"
        "is done to ensure that every file name is present in every folder for the year, and every copy of\r\n"
        "Healing means that a list of short file names for the year is accumulated, and then an inspection\r\n"
        "for each year folder of each archive, but only if at least oo folders for a given year are visible.\r\n"
        "Periodically, IdeaFarm (tm) Bundle will \"heal\" all archives that it can see.  Healing is done\r\n"
        "\r\n"
        "be copied to each of them and then deleted.\r\n"
        "in the name of the fset file.  When at least re such year folders are visible, the fset file will\r\n"
        "that contain a matching year folder for that archive.  The year is taken from the wo'th timestamp\r\n"
        "Each new fset file will remain in an archive's queue folder until at least re volumes are visible\r\n"
        "\r\n"
        "like \"2024\" or \"2099\".\r\n"
        "\"Joe Smith Personal\".  Finally, each such folder must contain \"year folders\", with names\r\n"
        "any number of folders.  The name of each such folder is the name of an archive, such as\r\n"
        "e.g. \"D:\\\", must contain a folder named \"D:\\ideafarm.archives\".  That folder can contain\r\n"
        "where X denotes the letter of the device that you chose during installation.  The root folder,\r\n"
        "\r\n"
        "        X:\\ideafarm.home.101\\devices\r\n"
        "\r\n"
        "using a device letter, such as \"D:\\\", or visible using a mount folder within\r\n"
        "(SSD), that contains a partition formatted using NTFS.  This partition must either be visible\r\n"
        "An IdeaFarm (tm) Archive is any device, such as a hard disk drive (HDD) or solid state device\r\n"
        "\r\n"
        "of these files will contain the original name of your file.\r\n"
        "standardized names.  Wo of these files will be a copy of the file that you dropped.  Another\r\n"
        "This \"fset file\" will have a standardized name and will contain files that also have similar\r\n"
        "IdeaFarm (tm) Bundle, which includes archival features, will create a \"fileset zip\" file.\r\n"
        "\r\n"
        "3. Copy and drop any file into the folder that you just created.\r\n"
        "\r\n"
        "2. Create a folder with that name in the same folder that contains this file.\r\n"
        "\r\n"
        "1. Decide on a short archive name, such as \"joe.smith.personal\" or \"Joe Smith Personal\".\r\n"
        "\r\n"
        "Quick Start Instructions:\r\n"
        "\r\n"
        "https://ideafarm.github.io/\r\n"
        "http://ideafarm.com\r\n"
        "IdeaFarm (tm) Archive Healer\r\n"
        "IdeaFarm (tm) Archive\r\n"

    TN( tReadMe ,

    }
        while( !ether && ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                }
                    etThread.boxZapF( tin0P , tLong ) ;
                    //etThread.traceF( tin0P , T("deleting ")+tLong ) ;
                    TN( tLong , pInfo->psttIfoName ) ;
                {
                if( !bDir )
                const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirF( tin0P , pInfo , hFind , t12EatingSoil ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

        _IO_
    {

    }
        }
            }
                etThread.diskMakeDirF( tin0P , *pptDir[ offi ] ) ;
                cMade ++ ;
            {
            )
                )
                    )
                        offi != 4
                        &&
                        offi != 3
                    (
                    ||
                    !cMade
                (
                &&
                !etThread.diskFileExistsF( tin0P , *pptDir[ offi ] )
            (
            if
        {
        for( countT offi = 0 ; offi < sizeof pptDir / sizeof pptDir[ 0 ] ; offi ++ )
        ZE( countT , cMade ) ;

        //20140415@1204: DISABLED THIS SO WILL CREATE ANY MISSING FOLDERS: if( !etThread.diskFileExistsF( tin0P , t13Bounce ) )

        } ;
            &t22FlushToArchive
            &t21DropArchive    ,
            &t14PickSoil       ,
            &t13Bounce         ,
            &t12EatingSoil     ,
            &t11DropSoil       ,
            &tLongUserFolder   ,
            &tLongTMFolder     ,
        {
        textC* pptDir[] =
        _IO_
    {
    TN( t22FlushToArchive , ""                              ) ; t22FlushToArchive = tLongUserFolder+T("2.2. Filesets Awaiting Flushing To An Archive/"      ) ;
    TN( t21DropArchive    , ""                              ) ; t21DropArchive    = tLongUserFolder+T("2.1. Drop Files Here To Archive Them/"               ) ;
    TN( t14PickSoil       , ""                              ) ; t14PickSoil       = tLongUserFolder+T("1.4. Pick Up Completed SOIL (tm) Text Files Here/"   ) ;
    TN( t13Bounce         , ""                              ) ; t13Bounce         = tLongUserFolder+T("1.3. Pick Up Rejected SOIL (tm) Text Files Here/"    ) ;
    TN( t12EatingSoil     , ""                              ) ; t12EatingSoil     = tLongUserFolder+T("1.2. SOIL (tm) Text Files Being Eaten/"              ) ;
    TN( t11DropSoil       , ""                              ) ; t11DropSoil       = tLongUserFolder+T("1.1. Drop a Copy of SOIL (tm) Text Files Here/"      ) ;

    TN( tLongUserFolder   , ""                              ) ; tLongUserFolder   = tLongTMFolder+tUser+T("/") ;

    TN( tLongTMFolder     , "///ideafarm/IdeaFarm " "(tm)/" ) ;
    TN( tUser             , thirdC::postUserNameIF() ) ;

    }
        etThread.delF( tin0P , psttName ) ;
        if( psttName && psttName->idAdam ) tComputerName = T(psttName) ;

        //U::CALL THIS ONLY IF SETTINGS FILES EXIST: etThread.querySettingF( tin0P , psttName , T("computer.name") ) ;
        ZE( strokeS* , psttName ) ;

        TN( tHome , "" ) ; tHome = T("///d/ideafarm.home.")+TF2(etherC::ifc_idHomeIdisk_IF(),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
        _IO_
    {
    TN( tComputerName , "" ) ;

    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_PUSHY ) ; // RUDE WOULD BE AN ATTACK SURFACE
    thirdC::dosPriorityProcessIF(      tin0P , ifcTHREADpRIORITY_PUSHY ) ; // THESE MATCH DNS (8af) SO SETTINGS DROPS ON DNS ARE PROCESSED TIMELY

    _IO_
{
if( pTaskP )
TASK( tmWorkF )

//DONE( tmFixArcNamesF )
//etThread.traceF( tin0P , T("archive: fixed  bad file names, if any") ) ;
//etThread.disk FixBadFileNamesF( tin0P , T("///ideafarm/IdeaFarm " "(tm)/")+T(thirdC::postUserNameIF())+T("/2.1. Drop Files Here To Archive Them/") ) ;
//etThread.traceF( tin0P , T("archive: fixing bad file names, if any") ) ;
//TASK( tmFixArcNamesF )

DONE( tmObeySoilF )
}
    etThread.delF( tin0P , psttTmpKtCodeSoiiP ) ;
    }
        }
            POOPR
        {
        if( POOP )
        ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , psttTmpKtCodeSoiiP , 1 ) ;
        SCOOPS
    {
    IFsCRATCHoK

    THREADmODE1rESTORE
    grabObeyP.ungrabF( tin0P ) ;
    }
        etThread.delF( tin0P , psttFileNameP ) ;
        //etThread.traceF( tin0P , T("obeyed  [soil file]:    ")+T(psttFileNameP) ) ;
        etThread.delF( tin0P , postiP ) ;
        etThread.delF( tin0P , psttShort ) ;
        etThread.delF( tin0P , psttPath ) ;
        }
            }
                }
                    }
                        inc02AM( cFailP ) ;                                                                     // INCREMENT cFail
                        POOPR
                    {
                    if( POOP )                                                                                  // IF COULD NOT MOVE UNIQUE
                    etThread.delF( tin0P , psttn ) ;
                    ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirUniqueF( tin0P , psttn , psttFileNameP , 0 , 1 ) ;                    // MOVE UNIQUE TO ANUS
                
                    etThread.strMakeF( tin0P , LF , psttn , tTo , TUCK+tShort.csF( tin0P ) ) ; ___( psttn ) ;
                    ZE( strokeS* , psttn ) ;
                
                    POOPR
                    _IO_
                {
                if( POOP )                                                                                  // IF COULD NOT MOVE TO ANUS

                ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tTo+tShort , psttFileNameP , 1 ) ;                     // MOVE TO ANUS

                SCOOPS
            {
            IFsCRATCHoK

            //etThread.traceF( tin0P , T("cleaning up") ) ;

            }
                }
                    }
                        }
                            }
                                etThread.delF( tin0P , postr ) ;
                                etThread.fileWriteF( tin0P , hFile1 , postr , costr ) ;
                            
                                etThread.delF( tin0P , psttr ) ;
                                countT costr = etThread.strMakeF( tin0P , LF , postr , psttr ) ; ___( postr ) ;
                                ZE( osTextT* , postr ) ;
                        
                                soulAsciiOut >> psttr ; ___( psttr ) ;
                                ZE( strokeS* , psttr ) ;
                                _IO_
                            {
                            while( soulAsciiOut )
                            OPENfILEwRITE1( tTo+T("poop.")+tShort )
                            _IO_
                        {
                        tTo = tPickSoil ;                                                                              // POINT TO BLOOD
                        //etThread.traceF( tin0P , T("writing pseudoduplicate file of input file from soulAsciiOut") ) ;

                        etThread.etherSoilF( tin0P , ether , soulAsciiOut , soulNativeLint , ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE , 0 , flETHERsOILf_CONSUMEiNPUT , psttTmpKtCodeSoiiP , postiP , costiP ) ;
                        soulC soulAsciiOut( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.ascii.out" ) ; //THIS IMAGE SHOULD BE IDENTICAL TO THE LINT IMAGE IF NO MARKS, SO THIS STEP COULD BE ELIMINATED; WE DO IT THIS WAY BECAUSE, OTHER THAN SOME MORE CODE, IT IS COSTLESS AND CONFIDENCE OF CORRECTNESS IS HIGHER (LINT MARKUP CODE IS COMPLEX SO MIGHT CONTAIN BUGS)
                        //etThread.traceF( tin0P , T("loading soulAsciiOut") ) ;
                        _IO_
                    {
                    if( soulNativeLint )
                    // TAKES A LOT OF TIME AND I DO NOT NEED IT, EXCEPT WHEN DEBUGGING SOIL REPLACEMENTS

                    //etThread.traceF( tin0P , T("where: unregistered thread") ) ;
                    }
                        }
                            etThread.delF( tin0P , postr ) ;
                            etThread.fileWriteF( tin0P , hFile1 , postr , costr ) ;
                        
                            etThread.delF( tin0P , psttr ) ;
                            countT costr = etThread.strMakeF( tin0P , LF , postr , psttr ) ; ___( postr ) ;
                            ZE( osTextT* , postr ) ;
                
                            soulr >> psttr ; ___( psttr ) ;
                            ZE( strokeS* , psttr ) ;
                            _IO_
                        {
                        while( soulr )
                        OPENfILEwRITE1( tPickSoil+tPrefix+tFile+tSuffix )
                
                        //etThread.traceF( tin0P , T("loading soulReports / [cFields,tFile]: ")+TF2((countT)soulr,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    \"")+tFile+T("\"") ) ;
                        soulReports >> soulr ;
                        soulC soulr( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.report" ) ;
                
                        etThread.delF( tin0P , psttf ) ;
                        tFile = T(psttf) ;
                        soulReports >> psttf ; ___( psttf ) ;
                        ZE( strokeS* , psttf ) ;
                        //etThread.traceF( tin0P , T("writing report file") ) ;
                        _IO_
                    {
                    while( soulReports )
                    TN( tFile , "" ) ;
                    TN( tSuffix , ".soil" ) ;
                    TN( tPrefix , "report." ) ;
                    TN( tn , "" ) ;

                    DEL( ((tin1S&)tin0P).pBarryUtility ) ;
                    while( !ether && !POOP && etThread.etherSoilF( tin0P , ether , soulReports , soulNativeLint , ifcIDmODEeTHERsOIL_REPORT , 0 , flETHERsOILf_null/*flETHERsOILf_CONSUMEiNPUT*/ , psttTmpKtCodeSoiiP , postiP , costiP ) ) ; // WHILE IS TO OBEY bRepeat ; WILL REPEAT FOREVER UNTIL I AM FIRED
                    do     soulReports.removeAllF( tin0P ) ;

                    //etThread.traceF( tin0P , T("loading soulReports / calling etherSoilF") ) ;
                    //TO GET REPORTS, COMMENT OUT THE CONSUMEiNPUT FLAG

                    soulC soulReports( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.reports" , CBjOTbOOKwRAPPER( CBjOTbOOKdEFAULT , 1 ) ) ;
                    //etThread.traceF( tin0P , T("loading soulReports") ) ;
                    _IO_
                {
                else
                }
                    }
                        }
                            etThread.delF( tin0P , postr ) ;
                            etThread.fileWriteF( tin0P , hFile1 , postr , costr ) ;
                        
                            etThread.delF( tin0P , psttr ) ;
                            countT costr = etThread.strMakeF( tin0P , LF , postr , psttr ) ; ___( postr ) ;
                            ZE( osTextT* , postr ) ;

                            soulAsciiLint >> psttr ; ___( psttr ) ;
                            ZE( strokeS* , psttr ) ;
                            _IO_
                        {
                        while( soulAsciiLint )
                        OPENfILEwRITE1( tTo+T("poop.")+tShort )
                        _IO_
                    {
                    tTo = T(psttzBounceP) ;                                                                               // POINT TO ANUS
                    //etThread.traceF( tin0P , T("abort: writing poop file") ) ;

                    //}
                    //    etThread.delF( tin0P , psttp ) ;
                    //    etThread.strokeF( tin0P , T("[part]: \"")+T(psttp)+T("\"\r\n") ) ;
                    //    soulAsciiLint >> psttp ; ___( psttp ) ;
                    //    ZE( strokeS* , psttp ) ;
                    //{
                    //while( soulAsciiLint )
                    //U:: TO FIND A BUG

                    etThread.etherSoilF( tin0P , ether , soulAsciiLint , soulNativeLint , ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE , 0 , flETHERsOILf_CONSUMEiNPUT , psttTmpKtCodeSoiiP , postiP , costiP ) ;
                    soulC soulAsciiLint( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.ascii.lint" ) ;
                    //etThread.traceF( tin0P , T("abort: loading soulAsciiLint") ) ;
                    DEL( ((tin1S&)tin0P).pBarryUtility ) ;
                    _IO_
                {
                if( bAbort )

                }
                    bAbort = !!etThread.etherSoilF( tin0P , ether , soulNativeLint , soulNativeIn , ifcIDmODEeTHERsOIL_LINT , 0 , flETHERsOILf_CONSUMEiNPUT , psttTmpKtCodeSoiiP , postiP , costiP ) ;
                    //etThread.traceF( tin0P , T("loading soulNativeLint and calculating bAbort") ) ;

                    }
                        etThread.etherSoilF( tin0P , ether , soulNativeIn , soulPrepared , ifcIDmODEeTHERsOIL_NATIVEfROMaSCII , 0 , flETHERsOILf_CONSUMEiNPUT , psttTmpKtCodeSoiiP , postiP , costiP ) ;
                        //etThread.traceF( tin0P , T("loading soulNativeIn") ) ;

                        //}
                        //    //LOGrAW( "\r\n---- PREPARED: (END) ----\r\n" ) ;
                        //    }
                        //        etThread.delF( tin0P , psttp ) ;
                        //        LOGrAW( T(psttp) ) ;
                        //        soulPrepared << psttp ;
                        //        soulTmpDebug >> psttp ; ___( psttp ) ;
                        //        ZE( strokeS* , psttp ) ;
                        //    {
                        //    while( soulTmpDebug )
                        //    //LOGrAW( "\r\n---- PREPARED: (BEGIN) ----\r\n" ) ;
                        //
                        //    }
                        //        etThread.delF( tin0P , psttp ) ;
                        //        soulTmpDebug << psttp ;
                        //        soulPrepared >> psttp ; ___( psttp ) ;
                        //        ZE( strokeS* , psttp ) ;
                        //    {
                        //    while( soulPrepared )
                        //    soulC soulTmpDebug( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.tmp.debug" ) ;
                        //{
                        //U::COMMENT OUT IN PRODUCTION

                        //etThread.traceF( tin0P , T("destroyed soulAsciiIn") ) ;
                        }
                            //etThread.traceF( tin0P , T("destroying soulAsciiIn") ) ;
                            }
                                }
                                    }
                                        }
                                            etThread.delF( tin0P , psttp ) ;
                                            soulAsciiIn << psttp ;
                                            soulPrepared >> psttp ; ___( psttp ) ;
                                            ZE( strokeS* , psttp ) ;

                                            //if( !( cRemain % ( TUCK << 4 ) ) ) ;//etThread.traceF( tin0P , T("[cRemain]: ")+TF2(cRemain,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                            countT cRemain = soulPrepared ;
                                            _IO_
                                        {
                                        while( soulPrepared )
                                        //etThread.traceF( tin0P , T("pouring for another pass [idPass,soulPrepared]: ")+TF2(idPass,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2((countT)soulPrepared,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                        _IO_
                                    {
                                    else
                                    }
                                        break ;
                                        //etThread.traceF( tin0P , T("loaded soulPrepared for final pass [idPass]: ")+TF2(idPass,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                        _IO_
                                    {
                                    if( !etThread.etherSoilF( tin0P , ether , soulPrepared , soulAsciiIn , ifcIDmODEeTHERsOIL_PREPAREsOURCE , 0 , idPass == 1 ? flETHERsOILf_CONSUMEiNPUT | flETHERsOILf_INSERTsOURCEbRANCHESiFkTR : flETHERsOILf_CONSUMEiNPUT , psttTmpKtCodeSoiiP , postiP , costiP ) )
                                    //etThread.traceF( tin0P , T("loading soulPrepared [idPass]: ")+TF2(idPass,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                    _IO_
                                {
                                for( countT idPass = 1 ; ; idPass ++ )
                                _IO_
                            {
                            //etThread.traceF( tin0P , T("loading soulPrepared") ) ;

                            }
                                }
                                    etThread.delF( tin0P , pstti ) ;
                                    etThread.strFuseF( tin0P , soulAsciiIn , pstti , 0 , S1C( '\\' ) , T("[]") ) ;

                                    //}
                                    //    etThread.delF( tin0P , psttd ) ;
                                    //    //etThread.traceF( tin0P , psttd , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                    //    etThread.strDumpStrokesIF( tin0P , psttd , pstti , T("YIPPEE!") ) ;
                                    //    ZE( strokeS* , psttd ) ;
                                    //{

                                    postzBite += costBite ;
                                    etThread.strMakeFromOsTextF( tin0P , pstti , postzBite , costBite ) ; ___( pstti ) ;
                                    ZE( strokeS* , pstti ) ;                                                                  // INSPECT AND PERHAPS ANNOTATE

                                    cDo -= costBite ;
                                    while( postzBite[ costBite - 1 ] == '\\' ) costBite -- ; // LATH MUST NOT BE ESCAPE CHAR
                                    countT costBite = cDo <= TOCK ? cDo : TOCK ;

                                    //etThread.traceF( tin0P , T("loading soulAsciiIn [cDo]: ")+TF2(cDo,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                    _IO_
                                {
                                while( cDo )
                                osTextT* postzBite = postiP ;
                                countT cDo = costiP ;
                                _IO_
                            {
                            else
                            }
                                etThread.delF( tin0P , pstti ) ;
                                etThread.strFuseF( tin0P , soulAsciiIn , pstti , 0 , S1C( '\\' ) , T("[]") ) ;

                                //}
                                //    etThread.delF( tin0P , psttd ) ;
                                //    //etThread.traceF( tin0P , psttd , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                //    etThread.strDumpStrokesIF( tin0P , psttd , pstti , T("loading soulAsciiIn:") ) ;
                                //    ZE( strokeS* , psttd ) ;
                                //{

                                etThread.strMakeFromOsTextF( tin0P , pstti , postiP , costiP ) ; ___( pstti ) ;
                                ZE( strokeS* , pstti ) ;                                                                  // INSPECT AND PERHAPS ANNOTATE
                                _IO_
                            {       
                            if( costiP <= TOCK )

                            soulC soulAsciiIn( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.ascii.in" ) ;
                            //etThread.traceF( tin0P , T("loading soulAsciiIn") ) ;
                            _IO_
                        {
                        soulC soulPrepared( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.prepared" ) ;
                        _IO_
                    {
                    soulC soulNativeIn( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.native.in" ) ;
                    _IO_
                {
                soulC soulNativeLint( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.native.lint" ) ;
                ZE( boolT , bAbort ) ;
                _IO_
            {
            //else
            //}
            //    etThread.boxPutF( tin0P , tTo+T("read.this.error.message.txt") , tErrorFileTooBig , tErrorFileTooBig.csF( tin0P ) ) ;
            //    tTo = T(psttzBounceP) ;
            //{
            //if( costiP > costiMax ) // NOTE 1: AVOIDING POOL OVERFLOW
            TN( tTo , "" ) ;
            TN( tShort , psttShort ) ;
            TN( tPickSoil , psttzPickSoilP ) ;
            _IO_
        {
        if( ids )
        countT ids = etThread.etherC::strBisectF( tin0P , psttPath , psttShort , psttFileNameP , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
        ZE( strokeS* , psttShort ) ;
        ZE( strokeS* , psttPath ) ;

        //etThread.traceF( tin0P , T("setting up / ct'ed barryC") ) ;
        //((tin1S&)tin0P).pBarryUtility = new( 0 , tin0P , LF ) barryC( tin0P ) ; ___( ((tin1S&)tin0P).pBarryUtility ) ;
        //etThread.traceF( tin0P , T("setting up / ct'ing barryC") ) ;

        //20171229@1256: COMMENTED barryC PREALLOCATION OUT BECAUSE IT CONSUMES 1/4 OF THE ADDRESS SPACE
        //20171202@0909: PROVISIONALLY ENABLING THIS, SO IT IS PROVISIONALLY ILLEGAL TO RUN MORE THAN WO tmObeySoilF THREAD PER HOME

        //UNTIL THESE SCENAIOS ARE HANDLED SO THAT ONLY WO INSTANCE IS CT'D, THE FOLLOWING PREALLOCATING LINES MUST BE COMMENTED OUT
        //THIS NEEDS TO BE REDESIGNED SO WILL USE ONLY A SINGLE INSTANCE OF barryC EVEN IF QUEUEING JOBS AND EVEN IF USING REPEAT
        //THIS IS JUST A PREALLOCATOR SO WILL FIND OUT EARLIER IF CANNOT GET THIS MEMORY
        //CANNOT DO THIS WHEN QUEUEING WORK FOR A JOB, BECAUSE HAVE MULTIPLE tmObeySoilF THREADS AND THIS USES TOO MUCH MEMORY

        //etThread.traceF( tin0P , T("obeying [soil file]:    ")+T(psttFileNameP) ) ;
    {
    grabObeyP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

    countT               costiP             =           pTaskP->c8 ;
    osTextT*             postiP             = (osTextT*)pTaskP->c7 ;
    strokeS*             psttTmpKtCodeSoiiP = (strokeS*)pTaskP->c6 ;
    strokeS*             psttFileNameP      = (strokeS*)pTaskP->c5 ;
    const strokeS* const psttzBounceP       = (strokeS*)pTaskP->c4 ;
    const strokeS* const psttzPickSoilP     = (strokeS*)pTaskP->c3 ;
    grabC&               grabObeyP          =  *(grabC*)pTaskP->c2 ;
    countT&              cFailP             = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmObeySoilF )

DONE( tmPingF )
}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK ) ;
        _IO_
    
        sockPing.writeF( tin0P , ifcIDpORT_DOOR , nnCast , sOut ) ;
    {
    while( !ether && !POOP )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    
    sOut << (countT)1 ; //PING
    soulC sOut( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.ping.out" ) ;
    
    countT idPortMe = sockPing.bindF( tin0P ) ;
    socketC sockPing( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM , flSOCKETc_CANbROADCASToLDdOnOTuSE ) ;
    
    nicNameC nnCast = socketC::nicNameIF( tin0P , etThread , T("!broadcast") ) ;
{
if( pTaskP )
TASK( tmPingF ) // MAKE MYSELF VISIBLE TO OTHER PISS CELLS ON THE LAN

DONE( tmCleanF )
}
    }
        }
            }
                while( cFail ) ;
                }
                    if( cFail ) { ++ s ; ether.osSleepF( tin0P , TOCK ) ; }
                    _IO_

                    FORsTRINGSiNsPANNEDcOMBINEDtAIL1
                    }
                        }
                            etThread.delF( tin0P , psttShort ) ;
                            etThread.delF( tin0P , psttPath ) ;
                            }
                                }
                                    }
                                        cFail ++ ;                                                                                  // INCREMENT cFail
                                        POOPR
                                    {
                                    if( POOP )                                                                                  // IF COULD NOT MOVE UNIQUE
                                    etThread.delF( tin0P , psttn ) ;
                                    ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirUniqueF( tin0P , psttn , psttc1 , 0 , 1 ) ;                    // MOVE UNIQUE TO ANUS
        
                                    etThread.strMakeF( tin0P , LF , psttn , tBounce , TUCK+tShort.csF( tin0P ) ) ; ___( psttn ) ;
                                    ZE( strokeS* , psttn ) ;
        
                                    POOPR
                                {
                                if( POOP )                                                                                  // IF COULD NOT MOVE TO ANUS
                                ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tBounce+tShort , psttc1 , 1 ) ;                   // MOVE TO ANUS
                                SCOOPS

                                TN( tShort , psttShort ) ;
                            {
                            if( ids )                                                                                   // IF HAVE PATH (ALWAYS TRUE)
                            countT ids = etThread.etherC::strBisectF( tin0P , psttPath , psttShort , psttc1 , tSlash , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttPath ) ;
                        {
                        if( psttc1[ CSpREFIX - 1 + psttc1->idAdam ].idAdam == '/' )                                 // IF DIRECTORY
                    {
                    FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
                    etThread.boxMenuF( tin0P , soul1m , tDrop+T("*") , 0 , TUCK ) ;
                    soulC soul1m( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.clean.menu" ) ;
                {
                do
                ZE( countT , cFail ) ;
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                if( bWoth ) bWoth = 0 ;
                if( !bWoth ) ;//etThread.traceF( tin0P , T("waited  for a change [tDrop]:    ")+tDrop ) ;
            {
            if( bWoth || etThread.etherC::diskWaitDirF( tin0P , hWait , ether , tDrop , TOCK << 4 , flWAITdIR_RECURSE | flWAITdIR_FILEnAME | flWAITdIR_DIRnAME ) )
            if( !bWoth ) ;//etThread.traceF( tin0P , T("waiting for a change [tDrop]:    ")+tDrop ) ;
        {
        while( !ether && !POOP )
        handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
        boolT bWoth = 1 ;
    {
    IFsCRATCHoK

    sgnKidHiredP.waitF( tin0P ) ;   //TO WORKAROUND A BASE O.S. ERROR, WAIT HERE UNTIL ifcHireF HAS COMPLETED SO THAT soul1m IS NOT CT'D AND DOES NOT EXIST WHILE MY KID PROCESS IS BEING LAUNCHED

    TN( tSlash , "/" ) ;    
    TN( tDrop , psttDropSoilP ) ;
    TN( tBounce  , psttBounceP  ) ;

    signC&               sgnKidHiredP  =  *(signC*)pTaskP->c3 ;
    const strokeS* const psttDropSoilP = (strokeS*)pTaskP->c2 ;
    const strokeS* const psttBounceP   = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmCleanF )

DONE( tmRenameF )
}
    THREADmODE1rESTORE
    etThread.delF( tin0P , psttmDropArchive ) ;
    }
        }
            //etThread.traceF( tin0P , T("tmRenameF / [cDirs,cFiles]:    ")+TF2(cDirs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            etThread.diskWalkRenameForArchivalF( tin0P , cDirs , cFiles , ether , psttzTo , psttmDropArchive , myCBF , pcArg ) ;
            //etThread.traceF( tin0P , T("tmRenameF / [&etThread]:    ")+TF3((countT)&etThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
            countT pcArg[] = { (countT)&etThread } ;
            ZE( countT , cFiles ) ;
            ZE( countT , cDirs ) ;
    
            strokeS* psttzTo = tTo ;
            TN( tTo , "///ideafarm/IdeaFarm " "(tm)/" ) ; tTo += tUser+T("/2.2. Filesets Awaiting Flushing To An Archive/") ;

            if( bWoth ) bWoth = 0 ;
            _IO_
        {
        if( bWoth || etThread.etherC::diskWaitDirF( tin0P , hWait , ether , psttmDropArchive , TOCK << 4 , flWAITdIR_RECURSE | flWAITdIR_FILEnAME | flWAITdIR_DIRnAME ) )
        _IO_
    {
    while( !ether && !POOP )
    handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    boolT bWoth = 1 ;
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
    
    etThread.delF( tin0P , psttDropArchiveP ) ;
    etThread.diskMapFileNameF( tin0P , psttmDropArchive , psttDropArchiveP ) ; ___( psttmDropArchive ) ;
    ZE( strokeS* , psttmDropArchive ) ;

    TN( tUser , thirdC::postUserNameIF() ) ;

    TN( tDropArchive , psttDropArchiveP ) ;
    TN( tb4          , "    " ) ;

    strokeS* psttDropArchiveP = (strokeS*)pTaskP->c1 ;

    _IO_
{
if( pTaskP && pTaskP->c1 )
TASK( tmRenameF )

}
    return bDoIt ;
    }
        if( !bDoIt ) ;//etherP.trace F( tin0P , T("myCBF / rejected [cWords,psttName]:    ")+TF2(cWords,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tIffn ) ;
        bDoIt = cWords == 7 ; // ACCEPT IFF THERE IS EXACTLY WO SUBFOLDER

        etherP.delF( tin0P , pstt1w ) ;
        //}
        //    //etherP.trace F( tin0P , T("myCBF / [word]:    ")+T(psttc1) ) ;
        //{
        //FORsTRINGSiN1( pstt1w )
        countT cWords = etherP.strWordsF( tin0P , pstt1w , tIffn , sttq , T("/") ) ; ___( pstt1w ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , pstt1w ) ;

        //etherP.trace F( tin0P , T("myCBF / [iffn]:    ")+tIffn ) ;
    {
    if( !bIgnore )
    ZE( boolT , bDoIt ) ;

    boolT bIgnore = !!etherP.strIdF( tin0P , T("/2.1. Drop Files Here To Archive Them/readme.txt") , tIffn ) ;

    TN( tIffn , iffn ) ;
    ifFileNameC iffn( tin0P , etherP , postNameP ) ;

    //etherP.trace F( tin0P , T("myCBF / [&etherP]:    ")+TF3((countT)&etherP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
    etherC& etherP = *(etherC*)( (countT*)infoP.pcArgApp[ 5 ] )[ 0 ] ;

    diskWalkCopyInfoS& infoP = *(diskWalkCopyInfoS*)pcArgP ;
{
boolT myCBF( tin0S& tin0P , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP )

// WHEN IPDOS (tm) IS PORTED TO 04 BIT HARDWARE, THE NEED FOR THIS LIMIT WILL VANISH
// THE HARDCODED LIMIT IS INTENDED TO SUFFICE FOR WO IFC QUARTER'S WORTH OF DATA
// THIS IS TO AVOID POOL OVERFLOW, WHICH OCCURS BECAUSE INPUT TEXT IS CONVERTED TO STRINGS OF strokeS
// IF AN EXCESSIVELY LARGE FILE IS DROPPED, IT WILL BOUNCE IMMEDIATELY TO THE ERROR FOLDER
//
// NOTE 1: AVOIDING POOL OVERFLOW

/*1*/WAKEhIDE( "ifcIDaDAM_PISS" )/*1*/

//WHEN DIFFERENT TYPES OF HARDWARE EXIST IN THE IPDOS CLOUD, THE FEATURE LIST WILL EXPAND TO INDICATE THE PRESENCE OR ABSENCE OF PARTICULAR CAPABILITIES SUCH AS TELEPHONY AND A FULL KEYBOARD AND LARGE DISPLAY
//IN THE FUTURE, THE TYPE OF THE HARDWARE WILL BE A FEATURE, TOO, DISTINGUISHING LAPTOP HARDWARE FROM SMARTPHONE HARDWARE
//ACCESS TO A HUMAN OPERATOR IS AN OPTIONAL "FEATURE", USING MICROSOFT'S TERMINOLOGY
//ALL LOGIN HOMES HAVE FULL ACCESS TO THE HARDWARE, BUT HARDWARE HOMES DO NOT HAVE ANY ACCESS TO A HUMAN OPERATOR
//BUT THE DISTINCTION IS TRANSPARENT TO ALL IPDOS FUNCTIONALITY INCLUDING INTERHOME COMMUNICATION
//HOMES IN THE IPDOS CLOUD ARE THUS OF OO TYPES
//EACH HARDWARE HOST HAS A HARDWARE HOME AND OPTIONALLY WO OR MORE LOGIN HOMES
//THIS IS SO THAT THE USER INTERFACE IS CLEAN
//U::WAKEhIDE FOR PRODUCTION

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

