
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( this == &tinBaseSelfOrElderP && monitor.idThread > 3 ) flagsThreadMode5 &= ~( F(flTHREADmODE5_INoUTfRAMEdEFERwRITINGaPPtELEMETRY) ) ;

    }
        //SAYnAME( " tinNormalS/-\r\n" )
    
        }
            }
                }
                    *(countT*)pbPendingInOutFramePackets = 0 ;

                    }
                        pbPendingInOutFramePackets = pbn ;
                        PUSE.newF( tinBaseP , LF , pbn , cba ) ; ___( pbn ) ;
                        ZE( byteT* , pbn ) ;                                // pbn IS USED TO PREVENT pbPendingInOutFramePackets FROM BEING USED BEFORE ITS WOTH countT IS INITIALIZED
                    {
                    else
                    if( !pPoolUse ) pbPendingInOutFramePackets = processGlobal4I.heap.newF( tinBaseP , LF , cba ) ;

                    countT cba = sizeof( countT ) + CmAXpENDINGiNoUTfRAMEpACKETS * sizeof( tellInfoAppInOutFrameS ) ;
                {
                if( !pbPendingInOutFramePackets )
            {
            if( monitor.idThread > 3 && !( F(flags) & flTINs_NOiNoUTfRAMEsUPPORT ) ) // FOR THREAD 1, SEE do3; THREAD 2 3 ARE tinHeart AND tinBreak

            if( idTinNamed == ifcIDtINnAMED_tinBreakI ) thirdC::c_strncpyIF( tinBaseP , postTell , "refusalsToClose:0    logoffsSeen:0" , sizeof postTell ) ; //CODEsYNC: 12f0006 10200cc
            thirdC::c_strncpyIF( tinBaseP , postTell , "tinNormalS::tinNormalS: i am now registered" , sizeof postTell ) ;
            }
                TELLsYSc3LIFI( idTypeSay , (byteT*)&info , sizeof info , idLineCt , idiFileCt )
                info.idiFileCt  = idiFileCt ;
                info.idLineCt   = idLineCt ;
                info.idTinNamed = idTinNamed ;
                thirdC::c_strncpyIF( tinBaseP , info.postThreadName , postThreadName , sizeof info.postThreadName ) ;
                info.idTin      = idTin ;
                //info.ip       = aptMe ? aptMe : (countT)this ;
                info.ip         = (countT)this ;
                info.idSerial   = idSerial ;
                tellInfoSysTinS info ;
                //countT idTypeSay = aptMe ? ifcIDtYPEtELLsYS_TINcTI : ifcIDtYPEtELLsYS_TINcTP ;
                countT idTypeSay = ifcIDtYPEtELLsYS_TINcTP ;
                //ap_artmentOldC aptMe( tinBaseP , (byteT*)this ) ;
                thirdC::c_strncpyIF( tinBaseP , postTell , "tinNormalS::tinNormalS: registering myself" , sizeof postTell ) ;
            {
            if( !( F(flags) & flTINs_CONSTRUCTqUIETLY ) )
    
            }
                }
                    TELLsYSc3LIFI( ifcIDtYPEtELLsYS_LIFInAME , (byteT*)&info , sizeof info , idLineCt , idiFileCt ) ;
                    info.costName = thirdC::c_strlenIF( tinBaseP , info.postName ) ;
                    thirdC::c_strncpyIF( tinBaseP , info.postName , postOverride , sizeof info.postName ) ;
                    info.idiFile = idiFileCt ;
                    info.idLine = idLineCt & 0xfff ;
                    tellInfoSysLifiS info ;
    
                    osTextT* postOverride = idiFileCt != 0x3000b71 ? postn : "earlyLate" ;
                {
                if( postn )
        
                }
                    if( idTinNamed == ifcIDtINnAMED_tinHeartI || idTinNamed == ifcIDtINnAMED_tinBreakI ) thirdC::c_strncpyIF( tinBaseP , postThreadName , postn , sizeof postThreadName ) ;
                    }
                        }
                            break ;
                            if( !setIfZeAM( bDone , 1 ) ) postn = "earlyLateOrException" ;
                            static countT bDone ;
                        {
                        case ifcIDtINnAMED_tinEarlyLate :
                        case ifcIDtINnAMED_tinBreakI    : { postn = "tmBreakF" ; break ; }
                        case ifcIDtINnAMED_tinHeartI    : { postn = "tmHeartF" ; break ; }
                    {
                    switch( idTinNamed )
                {
                ZE( osTextT* , postn ) ;
            {
            if( idTinNamed == ifcIDtINnAMED_tinHeartI || idTinNamed == ifcIDtINnAMED_tinBreakI || idTinNamed == ifcIDtINnAMED_tinEarlyLate )
        
            if( idTinNamed == ifcIDtINnAMED_tinNormalVeryVeryEarlyLateMainI && monitor.idThread <= ClOWtHREADS && !( ++ processGlobal2I.pcPhaseLow[ monitor.idThread ] ) ) { BLAMMO ; }

            TELL( "tinNormalS: after setting processGlobal2I.flCt flag" )
            }
                }
                    }
                        etherC::etRockIF( tinBaseP ).traceF( tinBaseP , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;

                        OStEXTAK( ostoSay , "_" ) ;
                        OStEXTCF( ostoSay , pbThreadStackEnd , '0' ) ;
                        OStEXTAK( ostoSay , "_    " ) ;
                        OStEXTCF( ostoSay , pbThreadStackStart , '0' ) ;
                        OStEXTAK( ostoSay , "    " ) ;
                        OStEXTC(  ostoSay , cbStack , 0 ) ;
                        OStEXTAK( ostoSay , "    " ) ;
                        OStEXTC(  ostoSay , monitor.idThread , 0 ) ;
                        OStEXTAK( ostoSay , "_9    " ) ;
                        OStEXTC9( ostoSay , osTid ) ;
                        OStEXTAK( ostoSay , "_9    " ) ;
                        OStEXTC9( ostoSay , osPid ) ;
                        OStEXTAK( ostoSay , "tinNormalS [osPid,osTid,idThread,cbStack,pbThreadStackStart,pbThreadStackEnd]:    " ) ;
                        OStEXT(   ostoSay , TUCK << 1 ) ;

                        countT cbStack = pbThreadStackEnd - pbThreadStackStart ;

                        // EXAMPLE: tinNormalS [osPid,osTid,idThread,cbStack,pbThreadStackStart,pbThreadStackEnd]:    12308_9    8168_9    00000000    00004000    000a0000_    000e0000_
                        //          123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
                        //          0              1               2               3               4               5               6               7               8               9               a               b               c               d               e               f               0
                    {
                    if( idTinNamed == ifcIDtINnAMED_tinInPoolMain || this == &tinBaseSelfOrElderP )

                    }
                        etherC::etRockIF( tinBaseP ).traceF( tinBaseP , (const strokeS* const)(const osTextT* const)ostoSay , /*flTRACE_LOOP |*/ flTRACE_PARAMETERiSoStEXT ) ;

                        OStEXTAK( ostoSay , " ++++" ) ;
                        OStEXTA(  ostoSay , postThreadName ) ;
                        OStEXTAK( ostoSay , "_9    " ) ;
                        OStEXTC9( ostoSay , osTid ) ;
                        OStEXTAK( ostoSay , "_9    " ) ;
                        OStEXTC9( ostoSay , osPid ) ;
                        OStEXTAK( ostoSay , "tinNormalS [osPid,osTid]:    " ) ;
                        OStEXT(   ostoSay , TUCK >> 0 ) ;

                        tinBaseS& tinBaseP = *this ;
                    {
                    if( F(thirdC::third_flagsModeProcess2I_IF()) & flMODEpROCESS2_CHATTERtHREADcTdT )
                {
                if( idTinNamed == ifcIDtINnAMED_tinInPoolMain || ( this == &tinBaseSelfOrElderP && idTinNamed != ifcIDtINnAMED_tinHeartI && idTinNamed != ifcIDtINnAMED_tinBreakI && idTinNamed != ifcIDtINnAMED_tinNormalVeryVeryEarlyLateMainI ) )
            {
            //if( F(processGlobal2I.flCt) & flCTdTg_WITHINlIFETIMEoFmAIN && !( F(processGlobal2I.flDt) & flCTdTg_WITHINlIFETIMEoFmAIN ) )                                                                       //THIS IS TO AVOID CLUTTERING THE LOG FILE

            }
                }
                    case ifcIDtINnAMED_tinInPoolMain             : { processGlobal2I.flCt |= flCTdTg_tinMainInPool             ; break ; }
                    case ifcIDtINnAMED_tinNormalVeryEarlyLateMainI     : { processGlobal2I.flCt |= flCTdTg_tinNormalVeryEarlyLateMainI     ; break ; }
                    case ifcIDtINnAMED_tinNormalVeryVeryEarlyLateMainI : { processGlobal2I.flCt |= flCTdTg_tinNormalVeryVeryEarlyLateMainI ; break ; }
                {
                switch( idTinNamed )
    
                if( pTinF() != this ) { BLAMMO } ;
            {
            if( idTinNamed != ifcIDtINnAMED_tinHeartI && idTinNamed != ifcIDtINnAMED_tinBreakI )
            TELL( "tinNormalS: setting processGlobal2I.flCt flag and testing pTinF()" )
        
            TINSL
    
            }
                *(countT*)&pbThreadStackEnd   = (countT)info.BaseAddress + info.RegionSize ;
                *(countT*)&pbThreadStackStart = (countT)info.AllocationBase ;
                VirtualQuery( (byteT*)ebpP , &info , sizeof info ) ;
                MEMORY_BASIC_INFORMATION info ;
                //CONoUTrAW3( "\r\ntinNormalS / setting [pbThreadStackStart,pbThreadStackEnd] / [idTinNamed]:    " , idTinNamed , "\r\n" ) ;
            {
            if( !pbThreadStackStart )

            }
                thirdC::c_strncpyIF( tinBaseP , postTell , "tinNormalS::tinNormalS: my image is now valid by raw construction" , sizeof postTell ) ;
                putNegAM( fingerprint , FINGERnEG_TINs ) ; //MY IMAGE IS NOW COMPLETELY VALID
                monitor.idDirty ++ ;
        
                }
                    thirdC::c_strncpyIF( tinBaseP , processGlobal3I.pLowThread[ monitor.idThread ].postThreadName , postThreadName , sizeof processGlobal3I.pLowThread[ monitor.idThread ].postThreadName ) ;
                    processGlobal3I.pLowThread[ monitor.idThread ].osTid = osTid ;
                    if( processGlobal3I.pLowThread[ monitor.idThread ].osTid ) { BLAMMO ; }
                {
                if( monitor.idThread <= ClOWtHREADS )
                
                //U::WILL pPoop WORK?: declareVmUsageTypeGF( tinBaseP , (byteT*)((tinNormalS&)tinBaseP).pPoop , flVMuSAGEtYPE_CPUsTACK , monitor.idThread , postThreadName ) ;
                thirdC::c_strncpyIF( tinBaseP , postThreadName , postThreadNameP , sizeof postThreadName ) ;
        
                //monitor.pLFnest[ 3 ] = idiFileCt ;
                //monitor.pLFnest[ 2 ] = idLineCt & ~fliSTEP_FLAGmASK ;
                //monitor.cInNest = 1 ; //ENSURES THAT THE MONITOR WILL NEVER SEE A NULL monitor.cInNest (IF IT DOES, THERE IS A BUG)
                
                }
                    thirdC::c_memsetIF( tinBaseP , postTellIf          , sizeof postTellIf ) ;
                    thirdC::c_memsetIF( tinBaseP , postTellWait        , sizeof postTellWait ) ;
                    thirdC::c_strncpyIF( tinBaseP , postTell , "constructing this tinNormalS, object" , sizeof postTell ) ;
                {
                //thirdC::c_memsetIF( tinBaseP , (byteT*)ppTinKid   , sizeof ppTinKid    ) ;
                thirdC::c_memsetIF( tinBaseP , (byteT*)pcUtility04  , sizeof pcUtility04 ) ;
                thirdC::c_memsetIF( tinBaseP , (byteT*)pcUtility    , sizeof pcUtility   ) ;
                }
            
                    pFlagsThreadLevelMode[ off ] = flTHREADlEVELmODE_null ;
                    pIdProgressNest[       off ] = 0 ;
                    pEIPInNest[            off ] = 0 ;
                    pIdInNest[             off ] = 0 ;
                {
                for( countT off = 0 ; off <= OFFsLOTtINnESTmAX ; off ++ )
                {for( countT off = 0 ; off < sizeof monitor.pLFnest / sizeof monitor.pLFnest[ 0 ] ; off ++ ) monitor.pLFnest[ off ] = 0 ;}
                //O: USE thirdC::c_memsetIF
                
                {for( countT off = 0 ; off < sizeof pLFstep / sizeof pLFstep[ 0 ] ; off ++ ) pLFstep[ off ] = 0 ;}
                monitor.idDirty ++ ;
                
                const boolT bComments = !( F(flags) & flTINs_DISABLEcOMMENTS  ) ;
        
                }
                    }
                        countT foo = 2 ;
                    {
                    if( thirdC::c_strstrIF( *this , postThreadName , "tmExecutive" ) )

                    LOGrAW( "+\r\n" ) ;
                    LOGrAW( postThreadNameP ) ;
                    //CONoUTnOtIN2( postThreadNameP , 1 ) ;
                {
                if( F(thirdC::third_flagsModeAdam2I_IF(*this)) & flADAMmODE2_THREADcHATTER )
        
                }
                    }
                        //LOG rAW3nOtIN( "/" , monitor.idThread , "/+\r\n" ) ;
                        //LOG rAWnOtIN( postThreadNameP ) ;
                        //LOG rAW3nOtIN( "" , pag1->idAdam , " " ) ;
                    {
                    //if( !thirdC::c_strcmpIF( postThreadNameP , "tmKillSocketF" ) )
                {
                if( F(thirdC::third_flagsModeAdam2I_IF(*this)) & flADAMmODE2_THREADcHATTER )

                TINSL
                ctTellCopyDoneF( (countT)this ) ;
            {
            else
            }
                if( ((tinNormalS*)pTinOld)->pPoop != &((tinNormalS*)pTinOld)->poop ) { BLAMMO ; }
        
                thirdC::c_strncpyIF( postTell , "tinNormalS::tinNormalS: my image is now valid by copying my elder" , sizeof postTell ) ;

                if( thirdC::c_memcpyWithCallBackIF( (byteT*)this + CBtINpREFIX , (byteT*)&tinBaseSelfOrElderP + CBtINpREFIX , sizeof( tinNormalS ) - CBtINpREFIX - CBtINsUFFIX , ctTellCopyDoneF , (countT)this ) ) { BLAMMO ; } //CODE SYNC: 003002a 12f0002 12f0003

                putNegAM( ((tinNormalS&)tinBaseSelfOrElderP).fingerprint , FINGERnEG_TINszOMBIE ) ; //FROM NOW UNTIL I REGISTER MYSELF, MONITOR WILL NOT BE ABLE TO SEE A tinNormalS FOR THIS THREAD
                if( getNegAM( ((tinNormalS&)tinBaseSelfOrElderP).fingerprint ) != FINGERnEG_TINs ) BLAMMO ;

                //SAYnAME( " tinNormalS/ " ) CONoUTrAW( " copying from " ) ; CONoUTrAW( NAME( ((tinNormalS&)tinBaseSelfOrElderP).idTinNamed ) ) ; CONoUTrAW( "\r\n" ) ;
                *(tinBaseS**)&pTinOld = &tinBaseSelfOrElderP ;
            {
            if( !( F(flags) & flTINs_NOeLDER ) )
        
            }
                idSerial  = ph ? 1 + incv02AM( ph->idSerialLath ) : 0 ;
                homeS* ph = processGlobal1I.pHome ;
            {
            //U::VALIDATE flags...NOTE THAT flags IS NOT VALIDATED. THIS IS BECAUSE I DO NOT HAVE AN POOP TO SET U::CONJ: IT COULD BE VALIDATED NOW THAT I KNOW WHETHER I CAN USE tinBaseP AS MY ELDER)    
        
            idDesireSetBySelfProcess = thirdC::dosPriorityProcessIF( tinBaseSelfOrElderP ) ;
            idDesireSetBySelf = thirdC::dosPriorityIF( tinBaseSelfOrElderP ) ;
        {

        thirdC::c_memsetIF( tinBaseSelfOrElderP , (byteT*)postPad2                    , sizeof postPad2                    ) ;

        thirdC::c_memsetIF( tinBaseSelfOrElderP , (byteT*)postThreadName              , sizeof postThreadName              ) ;

        thirdC::c_memsetIF( tinBaseSelfOrElderP , (byteT*)postPad1                    , sizeof postPad1                    ) ;

        thirdC::c_memsetIF( tinBaseSelfOrElderP , (byteT*)pPanLifiRecurseGrabbedLevel , sizeof pPanLifiRecurseGrabbedLevel ) ;

        thirdC::c_memsetIF( tinBaseSelfOrElderP , (byteT*)pBookMark                   , sizeof pBookMark                   ) ;

        else                                            thirdC::c_memsetIF( tinBaseSelfOrElderP , (byteT*)ppJot                           , sizeof ppJot ) ;
        if( F(flags) & flTINs_INHERITjOTrEGISTRATIONS ) thirdC::c_memcpyIF( tinBaseSelfOrElderP , (byteT*)ppJot , (byteT*)((tinNormalS*)pTinBaseDadP)->ppJot , sizeof ppJot ) ;

        thirdC::c_memsetIF( tinBaseSelfOrElderP , (byteT*)pcGrabitRecurse             , sizeof pcGrabitRecurse             ) ;
        thirdC::c_memsetIF( tinBaseSelfOrElderP , (byteT*)pcGrabitOsTid               , sizeof pcGrabitOsTid               ) ;
        thirdC::c_memsetIF( tinBaseSelfOrElderP , (byteT*)ppbGrabitRecurse            , sizeof ppbGrabitRecurse            ) ;
    
        //SAYnAME( " tinNormalS/+\r\n" )

        if( !idTinNamedP ) { BLAMMO ; }
    {
{
//idDesireSetBySelf_cGrab_pTinKid( 0 )
pSexLifoConstructing( 0 )
pSgnUtility( 0 ) ,
pTlsHeader( (tlsHeaderS*)pbTls ) ,
cOsHandles( 0 ) ,
cSpins4( 0 ) ,
cSpins3( 0 ) ,
cSpins2( 0 ) ,
cSpins1( 0 ) ,
bSuppressInOutTrace( 0 ) ,
pbRecursiveParameters( 0 ) ,
pBarryUtility( 0 ) ,
cPoolDropDt( 0 ) ,
cPoolDropCt( 0 ) ,
valueExpectedByInOut( 0 ) ,
pcWatchedByInOut( 0 ) ,
cTls( 0 ) ,
flagsTrace_soulC( flTRACEsOULc_ON | flTRACEsOULc_INHERIT | flTRACEsOULc_countT | flTRACEsOULc_DUMP ) ,
cArmTrace_soulC( 0 ) ,
pClean( 0 ) ,
ta( tinBaseSelfOrElderP ) ,
pBk0TraceScratch( 0 ) ,
pBk0TelemetryAppScratch( 0 ) ,
pBk0TelemetrySysScratch( 0 ) ,
pAdam( 0 ) ,
pPoolUse( ((tinNormalS&)tinBaseSelfOrElderP).pag1->pPoolAdamTemp ) ,
odoSockCbWrite( 0 ) ,
odoSockCbRead( 0 ) ,
pSwsRecycle( 0 ) ,
pczl_pSwsRecycle( 0 ) ,
ccExitsWhere( sizeof ((tinNormalS&)tinBaseSelfOrElderP).pag1->pcExitsWhere / sizeof ((tinNormalS&)tinBaseSelfOrElderP).pag1->pcExitsWhere[ 0 ] ) ,
pcExitsWhere( ((tinNormalS&)tinBaseSelfOrElderP).pag1->pcExitsWhere ) ,
pPoop( &poop ) ,
poop( flPOOP_SMELLY ) ,
pzTieLath( 0 ) ,
//idiFileMileDad( 0 ) ,
//idLineMileDad( 0 ) ,
idiFileMile( 0 ) ,
idLineMile( 0 ) ,
cbTls( cbTlsP ) ,
pbTls( pbTlsP ) ,
cYield( 0 ) ,
idTinNamed( idTinNamedP ) ,
pTinOld( 0 ) ,
pRestart( 0 ) ,
pEtScratch( 0 ) ,
pEtText( 0 ) ,
pcQuit( 0 ) ,
//cGrab_pTinKid( 0 ) ,
//pTinBro( 0 ) ,
//pTinKid( 0 ) ,
//pTinBaseDad( pTinBaseDadP ) ,                                     //U::20180630@1405: WHY ARE THESE COMMENTED OUT?  CONJ: THEY ARE SET DURING COPYING OF THE IMAGE FROM DAD TO ME
ranUni( tinBaseSelfOrElderP , MAXcOUNTT , idThreadP ) ,
cGrabitC_unregistered( 0 ) ,
cGrabitC_registered( 0 ) ,
cGrabitC_reset( 0 ) ,
cGrabitC_set( 0 ) ,
zap_pPanLifiRecurseGrabbedLevel_( (byteT*)pPanLifiRecurseGrabbedLevel , sizeof pPanLifiRecurseGrabbedLevel, flZAP_CT ) ,
msSleepWhenGrabbing( 0x40 + ( osTid & 0x1f ) << 3 ) ,
grabPseudo( tinBaseSelfOrElderP , idLineCtP , idiFileCtP , 0 , flGRABc_tINSoBJECT | flGRABc_DISABLED | flGRABc_PSEUDO ) ,
pEther( 0 ) ,
pbPendingInOutFramePackets( 0 ) ,
cTime2Or5Lath( 0 ) ,
cCpuCycles2Or5Lath( 0 ) ,
pInOutFrame( 0 ) ,
cTellsWriteInOutTelemetry( 0 ) ,
cTimeWriteInOutTelemetry( 0 ) ,
cCpuCyclesWriteInOutTelemetry( 0 ) ,
pbThreadStackLowest( (const byteT*)( - 1 ) ) ,
pbThreadStackEnd( 0 ) ,
pbThreadStackStart( 0 ) ,
pScoops( 0 ) ,
pScoopEtThread( 0 ) ,
monitor( tinBaseSelfOrElderP , idThreadP ) ,
idBlammo( 0 ) ,
idiFile_brcLath( 0 ) ,
idLine_brcLath( 0 ) ,
brcLath( 0 ) ,
brcQuery( 0 ) ,
bosFail( 0 ) ,
brcm04Raw( 0 ) ,
brcRaw( 0 ) ,
cKidThreads( 0 ) ,
flagsThreadMode5( this == &tinBaseSelfOrElderP ? flTHREADmODE5_INoUTfRAMEdEFERwRITINGaPPtELEMETRY : flTHREADmODE5_null ) ,
flagsThreadMode4( flTHREADmODE4_INoUTfRAMErEGISTERcALLnEST ) ,
flagsThreadMode3( flTHREADmODE3_null      ) ,
flagsThreadMode2( flTHREADmODE2_UPDATEtIN ) ,
idPhase3( 0 ) ,
idPhase2( 0 ) ,
idPhase1( ifcIDpHASEtHREAD_PROLOG ) ,
idlTask( 0 ) ,
idiTask( 0 ) ,
cManna( 0 ) ,
cRain( 0 ) ,
time2( 0 ) ,
time1( 0 ) ,
osPid( osPidIF( tinBaseSelfOrElderP ) ) ,
osTid( ( this == &processGlobal6I.tinBreak || this == &processGlobal5I.tinHeart ) ? 0 : osTidIF() ) ,
idDesireSetBySelfProcess( 0 ) ,
idDesireSetBySelf( 0 ) ,
pag6( pTinBaseDadP ? ((tinNormalS*)pTinBaseDadP)->pag6 : ( idTinNamedP == ifcIDtINnAMED_tinInPool ? ((tinNormalS&)tinBaseSelfOrElderP).pag6 : &rootAdamGlobal6I ) ) ,
pag5( pTinBaseDadP ? ((tinNormalS*)pTinBaseDadP)->pag5 : ( idTinNamedP == ifcIDtINnAMED_tinInPool ? ((tinNormalS&)tinBaseSelfOrElderP).pag5 : &rootAdamGlobal5I ) ) ,
pag4( pTinBaseDadP ? ((tinNormalS*)pTinBaseDadP)->pag4 : ( idTinNamedP == ifcIDtINnAMED_tinInPool ? ((tinNormalS&)tinBaseSelfOrElderP).pag4 : &rootAdamGlobal4I ) ) ,
pag3( pTinBaseDadP ? ((tinNormalS*)pTinBaseDadP)->pag3 : ( idTinNamedP == ifcIDtINnAMED_tinInPool ? ((tinNormalS&)tinBaseSelfOrElderP).pag3 : &rootAdamGlobal3I ) ) ,
pag2( pTinBaseDadP ? ((tinNormalS*)pTinBaseDadP)->pag2 : ( idTinNamedP == ifcIDtINnAMED_tinInPool ? ((tinNormalS&)tinBaseSelfOrElderP).pag2 : &rootAdamGlobal2I ) ) ,
pag1( pTinBaseDadP ? ((tinNormalS*)pTinBaseDadP)->pag1 : ( idTinNamedP == ifcIDtINnAMED_tinInPool ? ((tinNormalS&)tinBaseSelfOrElderP).pag1 : &rootAdamGlobal1I ) ) ,
idiFileCt( idiFileCtP ) ,
idLineCt( idLineCtP ) ,
) ,
    )
            : flTINs_null
            ? flTINs_NOiNoUTfRAMEsUPPORT
        this != &tinBaseSelfOrElderP && F(((tinNormalS&)tinBaseSelfOrElderP).flags) & flTINs_NOiNoUTfRAMEsUPPORT
    (
    |
    flagsP
(
flags
tally( tinBaseSelfOrElderP ) ,
) ,
    (countT)this
    ,
        : (countT*)0
        ? (countT*)&pTinMainI
    idTinNamedP == ifcIDtINnAMED_tinInPoolMain
    ||
    idTinNamedP == ifcIDtINnAMED_tinNormalVeryVeryEarlyLateMainI
(
top_pTinMainI_
tinBaseS( ifcIDtYPEtIN_NORMAL ) ,
/*1*/tinNormalS::tinNormalS( tinBaseS& tinBaseSelfOrElderP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const countT ebpP , const countT idThreadP , tinBaseS* const pTinBaseDadP , const osTextT* const postThreadNameP , const flagsT flagsP , const countT idTinNamedP , byteT* const pbTlsP , const countT cbTlsP )/*1*/ :

// "tinBaseSelfOrElderP": USUALLY SO, BUT NOT ALWAYS (AN EXCEPTION TIN WILL BE, YOU GUESSED IT, AN EXCEPTION (S))

//CONJ: THE PRECEDING COMMENT IS OBSOLETE AND NO LONGER TRUE
// THIS DEFINITION MUST WORK WHEN tinBaseP REFERENCES BYTES THAT ARE ALL SET TO 0 ("tinNormalS. processGlobal4I.tinNormalVeryVeryEarlyLateMain( processGlobal4I.tinNormalVeryVeryEarlyLateMain , TAG( TAGiDnULL ) , flTINs_CONSTRUCTqUIETLY ) ;")

/**/
*/
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.12f0006.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

