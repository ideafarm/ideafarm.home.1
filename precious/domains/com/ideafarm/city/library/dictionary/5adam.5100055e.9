
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    if( ((tin123S&)tin0P).fingerprint && etherP ) ;

    }
        //}
        //    break ;
        //    loadSpeechF( tin0P , etherP , cArgP , ifcIDsPEECH_AGREEMENT ) ;
        //    hintF( tin0P , etherP , cArgP , T("the agreement will start soon") ) ;
        //    hintF( tin0P , etherP , cArgP , T("please honestly give me your agreement now") ) ;
        //{
        //case ifcIDsPEECH_FLOORdISCLOSURE :
    {
    switch( paramP.idSpeech )

    ARGgET( cArgP )
{
voidT speechEpilogF( tin0S& tin0P , etherC& etherP , const countT cArgP )

}
    return 0 ;
    if( idEventP && sadamStateP.ssc.idAdam ) ;

    if( idTypeCallP == ifcIDtYPEsTROKEcALLbACK_FLYOVER ) hintF( tin0P , etherP , pcNotesP[ 2 ] , T("animation period (actual time between individual frames, real time)") ) ;

    ARGgET( pcNotesP[ 2 ] )
{
boolT vtGraphSpeedCBF( tin0S& tin0P , etherC& etherP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , sadamStateOldS& sadamStateP )

}
    return 0 ;
    if( idEventP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
        {
        default :
        }
            break ;
            hintF( tin0P , etherP , pcNotesP[ 2 ] , T("vtTest, rendered onto the paper of an eyeOldC") , TUCK * 0x20 ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    //if( idTypeCallP != ifcIDtYPEsTROKEcALLbACK_ANIMATE ) { LOGrAWtID( T("vtTestCBF called for \"")+T(processGlobal4I.mapSadamCall(idTypeCallP))+T("\"") ) ; }

    ARGgET( pcNotesP[ 2 ] )
{
boolT vtTestCBF( tin0S& tin0P , etherC& etherP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , sadamStateOldS& sadamStateP )

}
    return 0 ;
    if( idEventP ) ;

    }
        }
            break ;
            if( F(paramP.flags) & flPARAM_EYEbUTTONSrENDERED ) paramP.eye.obeyToolActionF( tin0P , etherP , idTypeCallP , pcNotesP , sadamStateP ) ;
        {
        default :
        }
            break ;
            hintF( tin0P , etherP , pcNotesP[ 2 ] , T("left click to aim, right click to tilt") , TUCK * 0x20 ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )

    ARGgET( pcNotesP[ 2 ] )
{
boolT vtEyeCBF( tin0S& tin0P , etherC& etherP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , sadamStateOldS& sadamStateP )

}
    return 0 ;
    if( idEventP ) ;

    }
        }
            freshViewOfBranchesF( tin0P , etherP , pcNotesP[ 2 ] ) ;
        
            }
                etherP.delF( tin0P , psttView ) ;
                paramP.vtView.setF( tin0P , T("")+S2(1+incv02AM(paramP.idEventViewSelectLath),sc_NULL)+T(psttView) ) ; //U::CONJ: BUG: IF psttView IS NULL LEN THEN THIS WILL LOOP FOREVER
                }
                    }
                        etherP.strFuseF( tin0P , psttView , T("")+S2(0,scOld_POPfRAME)+S2(0,scOld_POPfRAME) ) ;
                        etherP.strFuseF( tin0P , psttView , *paramP.pptcView[cBelow+offr] ) ;
                        etherP.strFuseF( tin0P , psttView , T("")+S2(0,scOld_FRAMEdETACH)+S3(mColMin,scOld_mmMOVEtO,mRowMin)+S3(1.0,scOld_mmMOVEpEL,1.0)+S2(0,scOld_PUSHoVERRIDEcOLrOW)+S3(mColMax,scOld_mmMOVEtO,mRowMax)+S3(-1.0,scOld_mmMOVEpEL,-1.0)+S2(0,scOld_POPfRAMEdETACH)+S2(0,scOld_cOVERRIDEnEXTsTROKE)+S3(0.0,scOld_mmFRAMEpELtO,0.0)+S3(1,scOld_ccFRAMEfORsADAMfRAMES,1) ) ;
            
                        measureT mColMax = ( offr + 1 ) * 1.0 / (measureT)cCols ;
                        measureT mColMin =   offr       * 1.0 / (measureT)cCols ;
                    {
                    for( countT offr = 0 ; offr < cCols ; offr ++ )
                    countT cBelow = cCols * offu ;
            
                    mRowMaxLag = mRowMax ;
                    measureT mRowMax = offu == cRows - 1 ? 1.0 : mRowMin + ( offu % 2 ? mRowMale : mRowFemale ) ;
                    measureT mRowMin = mRowMaxLag ;
                {
                for( countT offu = 0 ; offu < cRows ; offu ++ )
                const measureT mRowMale   = mRowSet - mRowFemale ;
                const measureT mRowFemale = mRowSet / 8 ;
                const measureT mRowSet    = 2.0 / (measureT)cRows ;
                ZE( measureT , mRowMaxLag ) ;
                etherP.strMakeF( tin0P , LF , psttView , 0 , TOCK ) ; ___( psttView ) ; //U::EXACTLY THE LENGTH NEEDED
                ZE( strokeS* , psttView ) ;
            {
        
            // mRowMin, mRowMax, mColMin, mColMax ALL SPECIFY THE SEPARATING PEL
            // CODE IS WRITTEN TO WORK FOR ANY EVEN VALUE FOR cRows
            // THERE ARE cRows ROWS: FEMALE MALE FEMALE MALE FEMALE MALE (FROM BOTTOM TO TOP)
            // THERE ARE 3 COLUMNS
            // FRAMING IS DONE SO THAT THERE IS 1 SEPARATOR PEL BETWEEN EACH ROW AND BETWEEN EACH COL
            // MALE ROWS ARE 7 TIMES THE HEIGHT OF FEMALE ROWS
            // DESIRED FORMATTING: MAXIMUM USAGE OF THE STROKING FRAME FOR paramP.vtView
            // ASSUMPTION: THERE IS EXACTLY 1 FEMALE ROW BETWEEN ANY OO MALE ROWS
            // CONCEPTS AND APPROACH TO FORMATTING
        
            if( cRows != 1 && cRows % 2 ) { BLAMMO ; } //EVENTUALLY 0-N WIVE LEVELS WILL BE SUPPORTED. 1 WIFE LEVEL IS NOW REQUIRED, TO KEEP CODE AND USER INTERFACE SIMPLE
        
            }
                }
                    paramP.pptcView[ off ] = new( 0 , tin0P , pbn , sizeof( tcButtonC ) ) tcButtonC( tin0P , T("pptcView.")+TF1(1+off) , buViewCBF , (countT)pcArg , flTCfEATURE_FRAME , 0 , 0 , 1 , rgbFrame ) ;
                    //flagsT flFeatureTab = !scRelCol && scRelRow == 1 ? flTCfEATURE_TABpARTICIPANT : flTCfEATURE_null ;
                    byteT* pbn = (byteT*)((tin123S&)tin0P).pag1->pPoolAdamTemp->newF( tin0P , LF , sizeof( vTextC ) ) ; ___( pbn ) ;
                    countT rgbFrame = !scRelCol && ( !scRelRow || scRelRow == 1 ) ? ifcRGB_R4|ifcRGB_G4 : ifcRGB_BROWN ;
        
                    pcArg[ 2 ] = scRelCol ;
                    pcArg[ 1 ] = scRelRow ;
                    pcArg[ 0 ] = pcNotesP[ 2 ] ;
        
                    sCountT scRelCol = off % cCols - paramP.cLeft ;
                    sCountT scRelRow = off / cCols - paramP.cDown ;
                {
                if( pcArg )
                etherP.newF( tin0P , LF , pcArg , 3 ) ; ___( pcArg ) ;
                ZE( countT* , pcArg ) ;
            {
            for( countT off = 0 ; off < paramP.cvtView ; off ++ )
            etherP.memSetF( tin0P , (byteT*)paramP.pptcView , paramP.cvtView * sizeof( countT ) ) ;
            etherP.newF( tin0P , LF , *(countT**)&paramP.pptcView , paramP.cvtView ) ; ___( paramP.pptcView ) ;
            paramP.cvtView = cRows * cCols ;
            const countT cRows = paramP.cDown + 1 + paramP.cUp ;
            const countT cCols = paramP.cLeft + 1 + paramP.cRight ;
        
            THREADmODE2rESTORE
            etherP.delF( tin0P , *(countT**)&paramP.pptcView ) ;
            }
                delete paramP.pptcView[ off ] ;
                etherP.delF( tin0P , pcArg ) ;
                countT* pcArg = (countT*)paramP.pptcView[ off ]->cArgF() ;
            {
            for( countT off = 0 ; off < paramP.cvtView ; off ++ )
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        {
        if( (*vb.ppsttSpec)->idAdam == 1 )
        vBodyS& vb = *(vBodyS*)&(countT&)sadamStateP.prs->swVolBody ; //THIS REFERENCE IS VOLATILE DUE TO SNAP/RESTORE DURING RENDERING
    {
    if( idTypeCallP == ifcIDtYPEsTROKEcALLbACK_VOLATILEtEXTcHANGED )

    ARGgET( pcNotesP[ 2 ] )
{
boolT vtViewCBF( tin0S& tin0P , etherC& etherP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , sadamStateOldS& sadamStateP )

}
    if( ((tin123S&)tin0P).fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            }
                break ;
            {
            case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
            }
                if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;
    
                const countT& idAction = pcNotesP[ 3 ] ;
                const countT& idTool   = pcNotesP[ 2 ] ;
            {
            case ifcIDtYPEsTROKEcALLbACK_MOUSE :
            }
                break ;
                //U::hintF( tin0P , etherP , pcArg[ 0 ] , T("relative branch ")+TF1(scRelRow)+T(" ")+TF1(scRelCol) ) ;
            {
            case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
        {
        switch( idTypeCallP )
        sCountT scRelCol = pcArg[ 2 ] ;
        sCountT scRelRow = pcArg[ 1 ] ;
        ARGgET( pcArg[ 0 ] )
    {
    if( pcArg )
    countT* pcArg = (countT*)cArgP ;
{
voidT buViewCBF( tin0S& tin0P , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( ((tin123S&)tin0P).fingerprint && etherP && cArgP && idTypeCallP && idEventP && pcNotesP && flTcStateNewP && flTcStateOldP && sadamStateP.ssc.idAdam ) ;

    }
        }
            break ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
        }
            break ;
            //win.baton.ungrabF( tin0P ) ;
            hintF( tin0P , etherP , cArgP , paramP.vtHintClockBanner , 0 ) ;
            //win.baton.grabF( tin0P , TAG( TAGiDnULL ) ) ;
            //windowOldC& win = *thirdC::pWinRootIF() ;
        {
        case ifcIDtYPEsTROKEcALLbACK_FLYOVER :
    {
    switch( idTypeCallP )
    ARGgET( cArgP )
{
voidT buClockLaunchCBF( tin0S& tin0P , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP , const sadamStateOldS& sadamStateP )

}
    if( idCycleP && etherP ) ;

    paramP.vtToolStateCapsLock.setF( tin0P , T("")+S3((measureT)tSay.csF(tin0P),scOld_mmFRAMEcELLS,(measureT)1.0)+S2(bOn?ifcRGB_G4:ifcRGB_R4,scOld_cPUSHcOLOR)+tSay+S2(0,scOld_POPcOLOR)+S2(0,scOld_POPfRAME) ) ;

    TN( tSay , bOn ? "ON" : "OFF" ) ;

    const boolT bOn = !!( F(paramP.win.rowBack.ro.pfToolState_f[ifcIDtYPEtOOL_LOCKcAPS-ifcIDtYPEtOOL_begin-1]) & flTOOL_ON ) ;

    ARGgET( cArgP )
{
voidT vtToolStateCapsLockCBF( tin0S& tin0P , etherC& etherP , const countT idCycleP , const countT cArgP )

#include postADAMhEADER

/*1*//*callbacks (cont'd)*//*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

