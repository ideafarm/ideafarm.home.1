
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etherC::loafIF( tin0P ) ;
    etThread.traceF( tin0P , T("ok") ) ;

    }
        }
            etThread.delF( tin0P , psttzSuffix ) ;
            strokeS*& psttzSuffix = *(strokeS**)&(countT&)swSuffixUse ;
            psttzlName = (strokeS*)swSuffixUse.leverF( tin0P , idf ) ;
    
            _IO_
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swSuffixUse.cFlavorsF( tin0P ) ;

        switchC&      swSuffixUse     = !offPass ? swSuffix4     : swSuffix6     ;
    {
    for( countT offPass = 0 ; offPass <= 1 ; offPass ++ )
    // DELETE strokeS STRING switchC VALUES

    etThread.traceF( tin0P , T("****************************************************************************************************************************************************************************************************************************************************************") ) ;
    }
        }
            }
                }
                    while( ~hWalk ) ;
                    }
                        thirdC::c_systemIF( tin0P , tCommand ) ;
                        etThread.traceF( tin0P , tCommand+T("    |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||") ) ;

                        ;

                            +T(" validate=no")+tCRLF
                            +T(pstta)
                            +T("\" address=")
                            T(psttzlName)

                        TN( tCommand , !offPass ? "netsh interface ipv4 add dnsservers name=\"" : "netsh interface ipv6 add dnsservers name=\"" ) ; tCommand +=

                        etThread.traceF( tin0P , tb8+T(pstta) ) ;
                        strokeS* pstta = (strokeS*)swsAddressesUse.downF( tin0P , hWalk ) ;
                    {
                    do
                    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                    thirdC::c_systemIF( tin0P , tCommand ) ;
                    etThread.traceF( tin0P , tCommand+T("    -----------------------------------------------------------------------------------------------") ) ;

                    ;
                        +T(" validate=no")+tCRLF
                        )
                                    : tRegisterBoth
                                    ? tRegisterPrimary
                                : !etThread.strCompareF( tin0P , psttzSuffix , tPrimaryOnly )
                                ? tRegisterNone
                            !etThread.strCompareF( tin0P , psttzSuffix , tNone )
                        (
                        +
                        +T("\" source=static address=none ")
                        +T(psttzlName)
                        +T(" set dnsservers name=\"")
                        T(!offPass?"ipv4":"ipv6")

                    TN( tCommand , "netsh interface " ) ; tCommand +=
                {
                else
                }
                    thirdC::c_systemIF( tin0P , tCommand ) ;
                    etThread.traceF( tin0P , tCommand+T("    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++") ) ;

                    ;
                        +T("\" source=dhcp validate=no")
                        +T(psttzlName)
                        +T(" set dnsservers name=\"")
                        T(!offPass?"ipv4":"ipv6")

                    TN( tCommand , "netsh interface " ) ; tCommand +=
                {
                if( idType == 1 )
            {
            if( swsAddressesUse )

            etThread.traceF( tin0P , T("*************************************    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzSuffix)+tb4+T(psttzlName) ) ;
            strokeS* psttzSuffix = (strokeS*)(countT&)swSuffixUse ;
            countT idType = swTypeUse ;
            psttzlName = (strokeS*)swTypeUse.leverF( tin0P , idf ) ;
    
            _IO_
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swTypeUse.cFlavorsF( tin0P ) ;

        switchStackC& swsAddressesUse = !offPass ? swsAddresses4 : swsAddresses6 ;
        switchC&      swSuffixUse     = !offPass ? swSuffix4     : swSuffix6     ;
        switchC&      swTypeUse       = !offPass ? swType4       : swType6       ;

        etThread.traceF( tin0P , T(!offPass?"====================================================== IPV4 ==========================================================":"====================================================== IPV6 ==========================================================") ) ;
    {
    for( countT offPass = 0 ; offPass <= 1 ; offPass ++ )
    etThread.traceF( tin0P , T("****************************************************************************************************************************************************************************************************************************************************************") ) ;
    // RESTORE PRIOR DNS SETTINGS FOR ALL INTERFACES THAT HAD DNS ADDRESSES

    }
        }
            }
                thirdC::c_systemIF( tin0P , tCommand ) ;

                ;

                    +T(" validate=no")+tCRLF
                    )
                                : tRegisterBoth
                                ? tRegisterPrimary
                            : !etThread.strCompareF( tin0P , psttzSuffix , tPrimaryOnly )
                            ? tRegisterNone
                        !etThread.strCompareF( tin0P , psttzSuffix , tNone )
                    (
                    +
                    +T(!offPass?"127.0.0.1 ":"::1 ")
                    +T("\" source=static address=")
                    T(psttzlName)

                TN( tCommand , !offPass ? "netsh interface ipv4 set dnsservers name=\"" : "netsh interface ipv6 set dnsservers name=\"" ) ; tCommand +=

                // netsh interface ipv4 set dnsservers name="foo"  source=static address=1.2.3.4 register=none validate=no

                while( ~hWalk ) ;
                }
                    etThread.traceF( tin0P , tb8+T(pstta) ) ;
                    strokeS* pstta = (strokeS*)swsAddressesUse.downF( tin0P , hWalk ) ;
                {
                do
                handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( swsAddressesUse )

            etThread.traceF( tin0P , T("*************************************    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzSuffix)+tb4+T(psttzlName) ) ;
            strokeS* psttzSuffix = (strokeS*)(countT&)swSuffixUse ;
            countT idType = swTypeUse ;
            psttzlName = (strokeS*)swTypeUse.leverF( tin0P , idf ) ;
    
            _IO_
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swTypeUse.cFlavorsF( tin0P ) ;

        switchStackC& swsAddressesUse = !offPass ? swsAddresses4 : swsAddresses6 ;
        switchC&      swSuffixUse     = !offPass ? swSuffix4     : swSuffix6     ;
        switchC&      swTypeUse       = !offPass ? swType4       : swType6       ;
        etThread.traceF( tin0P , T(!offPass?"====================================================== IPV4 ==========================================================":"====================================================== IPV6 ==========================================================") ) ;
    {
    for( countT offPass = 0 ; offPass <= 1 ; offPass ++ )
    etThread.traceF( tin0P , T("****************************************************************************************************************************************************************************************************************************************************************") ) ;
    // SET DNS TO LOOPBACK FOR ALL INTERFACES THAT HAVE DNS ADDRESSES

    }
        }
            }
                }
                    }
                        }
                            swSuffixUse = (countT)pstts ;
                            etThread.strTrimF( tin0P , pstts ) ; ___( pstts ) ;
                            etThread.strSubstringF( tin0P , pstts , idf , sttq , tCRLF , psttBig ) ; ___( pstts ) ;
                            ZE( strokeS* , pstts ) ;
                        {

                        etThread.delF( tin0P , pstt1Addresses ) ;
                        }
                            swsAddressesUse << psttLower ;
                            etThread.strConvertToLowerCaseF( tin0P , psttLower , psttc1 ) ; ___( psttLower ) ;
                            ZE( strokeS* , psttLower ) ;
                        {
                        FORsTRINGSiN1( pstt1Addresses )
                        etThread.strWordsF( tin0P , pstt1Addresses , tAddresses , sttq , T(" \r\n") ) ; ___( pstt1Addresses ) ;
                        ZE( strokeS* , pstt1Addresses ) ;
                    {
                    if( etThread.strCompareF( tin0P , tNone , tAddresses ) )

                    etThread.delF( tin0P , pstts ) ;
                    TN( tAddresses , pstts ) ;
                    etThread.strTrimF( tin0P , pstts ) ; ___( pstts ) ;
                    etThread.strSubstringF( tin0P , pstts , idf , sttq , t4 , psttBig ) ; ___( pstts ) ;
                    ZE( strokeS* , pstts ) ;
                    swTypeUse = idType1Dhcp2Static ;
                {
                if( idType1Dhcp2Static )

                else if( !etThread.strCompareF( tin0P , tMatch , t3 ) ) idType1Dhcp2Static = 2 ;
                else if( !etThread.strCompareF( tin0P , tMatch , t2 ) ) idType1Dhcp2Static = 1 ;
                }
                    psttzlName = tName ;
                    //etThread.traceF( tin0P , tName ) ;
                    etThread.delF( tin0P , pstts ) ;
                    tName = T(pstts) ;
                    etThread.strTrimF( tin0P , pstts ) ; ___( pstts ) ;
                    etThread.strSubstringF( tin0P , pstts , idf , sttq , tq , psttBig ) ; ___( pstts ) ;
                    ZE( strokeS* , pstts ) ;
                {
                if( !etThread.strCompareF( tin0P , tMatch , t1 ) )
                ZE( countT , idType1Dhcp2Static ) ;

                }
                    break ;
                    etThread.delF( tin0P , psttm ) ;
                    //etThread.traceF( tin0P , tMatch ) ;
                    tMatch = T(psttm) ;
                    stMatch >> psttm ;
                    ZE( strokeS* , psttm ) ;
                {
                while( stMatch )
                TN( tMatch , "" ) ;

                //etThread.traceF( tin0P , T("[idf]  :    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                //etThread.traceF( tin0P , T("[idHit]:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                countT idHit = etThread.strIdF( tin0P , &stMatch , flSTRmATCH_REPORTmATCH , idf , sttq , psttre , psttBig , 0 , 1 ) ;
                stackC stMatch( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
            {
            while( idf )
            TN( tName , "" ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;

            //etThread.traceF( tin0P , tListRaw , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

            strokeS* psttBig = tListRaw ;
            strokeS* psttre = tre ;

            etThread.delF( tin0P , posti ) ;
            TN( tListRaw , posti ) ;
            etThread.boxGetF( tin0P , posti , costi , T("///c/doodle.ttt") ) ; ___( posti ) ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;

            thirdC::c_systemIF( tin0P , !offPass ? "netsh interface ipv4 show dnsservers > c:\\doodle.ttt" :  "netsh interface ipv6 show dnsservers > c:\\doodle.ttt" ) ;

            switchStackC& swsAddressesUse = !offPass ? swsAddresses4 : swsAddresses6 ;
            switchC&      swSuffixUse     = !offPass ? swSuffix4     : swSuffix6     ;
            switchC&      swTypeUse       = !offPass ? swType4       : swType6       ;
        {
        for( countT offPass = 0 ; offPass <= 1 ; offPass ++ )

        ;

            +S2(sa_SSSaNDeND,sc_ccSSS)
                +S2(sa_SSSrEPORTmATCHeND,sc_ccSSS)
                   +S2(sa_SSSoReND,sc_ccSSS)
                       +S2(sa_SSSaNDeND,sc_ccSSS)
                           +t4
                       +S2(sa_SSSaND,sc_ccSSS)
                       +S2(sa_SSSaNDeND,sc_ccSSS)
                           +t3
                       +S2(sa_SSSaND,sc_ccSSS)
                       +S2(sa_SSSaNDeND,sc_ccSSS)
                           +t2
                       +S2(sa_SSSaND,sc_ccSSS)
                       +S2(sa_SSSaNDeND,sc_ccSSS)
                           +t1
                       +S2(sa_SSSaND,sc_ccSSS)
                   +S2(sa_SSSoR,sc_ccSSS)
                +S2(sa_SSSrEPORTmATCH,sc_ccSSS)                  // 123456789abcde
            +S2(sa_SSSaND,sc_ccSSS)

        TN( tre , "" ) ; tre += tn

        TN( t4 , "Register with which suffix:" ) ;
        TN( t3 , "Statically Configured DNS Servers:" ) ;
        TN( t2 , "DNS servers configured through DHCP:" ) ;
        TN( t1 , "Configuration for interface \"" ) ;
        TN( tNone , "None" ) ;
        TN( tq , "\"" ) ;
        TN( tn , "" ) ;
    {
    switchStackC   swsAddresses6( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    switchStackC   swsAddresses4( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    switchC        swSuffix6(     tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName ) ;
    switchC        swSuffix4(     tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName ) ;
    switchC        swType6(       tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName ) ;
    switchC        swType4(       tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName ) ;
    ZE( strokeS* , psttzlName ) ;

    TN( tRegisterBoth    , "register=both"    ) ;
    TN( tRegisterPrimary , "register=primary" ) ;
    TN( tRegisterNone    , "register=none"    ) ;

    TN( tCommandClearLoopback , "" ) ;
    TN( tCommandSetLoopback , "" ) ;

    TN( tNameLoopback , "Loopback Pseudo-Interface 1" ) ;
    TN( tPrimaryOnly  , "Primary only" ) ;
    TN( tNone         , "None"         ) ;
    TN( tb8           , "        "     ) ;
    TN( tb4           , "    "         ) ;
    TN( tCRLF , "\r\n" ) ;
{
if( pTaskP )
TASK( tmWorkF )

//  
//      Register with which suffix:           None
//                                            fec0:0:0:ffff::3%1
//                                            fec0:0:0:ffff::2%1
//      Statically Configured DNS Servers:    fec0:0:0:ffff::1%1
//  Configuration for interface "Loopback Pseudo-Interface 1"
//  
//      Register with which suffix:           Primary only
//                                            fec0:0:0:ffff::3%1
//                                            fec0:0:0:ffff::2%1
//      DNS servers configured through DHCP:  fec0:0:0:ffff::1%1
//  Configuration for interface "Bluetooth Network Connection"
//  
//      Register with which suffix:           None
//      DNS servers configured through DHCP:  2600:380:452e:b7e7::bc
//  Configuration for interface "Wi-Fi"
//  
//      Register with which suffix:           Primary only
//                                            fec0:0:0:ffff::3%1
//                                            fec0:0:0:ffff::2%1
//      DNS servers configured through DHCP:  fec0:0:0:ffff::1%1
//  Configuration for interface "Local Area Connection* 11"
//  
//      Register with which suffix:           Primary only
//                                            fec0:0:0:ffff::3%1
//                                            fec0:0:0:ffff::2%1
//      DNS servers configured through DHCP:  fec0:0:0:ffff::1%1
//  Configuration for interface "Local Area Connection* 8"
//  
//      Register with which suffix:           Primary only
//                                            fec0:0:0:ffff::3%1
//                                            fec0:0:0:ffff::2%1
//      Statically Configured DNS Servers:    fec0:0:0:ffff::1%1
//  Configuration for interface "virtualbox"
//  
//  OUTPUT OF "netsh interface ipv6 show dnsservers"

//  
//      Register with which suffix:           None
//      Statically Configured DNS Servers:    None
//  Configuration for interface "Loopback Pseudo-Interface 1"
//  
//      Register with which suffix:           Primary only
//      DNS servers configured through DHCP:  None
//  Configuration for interface "Bluetooth Network Connection"
//  
//      Register with which suffix:           Primary only
//                                            50.216.215.53
//      DNS servers configured through DHCP:  50.216.215.54
//  Configuration for interface "Wi-Fi"
//  
//      Register with which suffix:           Primary only
//      DNS servers configured through DHCP:  None
//  Configuration for interface "Local Area Connection* 11"
//  
//      Register with which suffix:           Primary only
//      DNS servers configured through DHCP:  None
//  Configuration for interface "Local Area Connection* 8"
//  
//      Register with which suffix:           Primary only
//      Statically Configured DNS Servers:    None
//  Configuration for interface "virtualbox"
//  
//  OUTPUT OF "netsh interface ipv4 show dnsservers"

/*1*/WAKEhIDE( "doodle.switch.to.private.local.dns.and.then.restore" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
