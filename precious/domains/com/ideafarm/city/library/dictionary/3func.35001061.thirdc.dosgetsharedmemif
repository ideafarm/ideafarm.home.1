
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    osTraceWrongNodeIF( tin0P , (byteT*)handleP.cNoteF() , "dosGetSharedMemIF: cNote" ) ;

    #endif

        THREADmODE1rESTORE
        if( !( F(flagsP) & flOPENsHAREDmEMORY_DOnOTsERIALIZE ) && F(processGlobal2I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal2I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal4I.grabMemorySpace.ungrabF( tin0P ) ;

        }
            }
                }
                    }
                        //}
                        //    CONoUTrAW( os ) ;
                        //    OStEXTAK( os , "\"\r\n" ) ;
                        //    OStEXTA(  os , ostoOsName ) ;
                        //    OStEXTAK( os , "\r\ndosGetSharedMemIF / old: \"" ) ;
                        //    OStEXT( os , TUCK << 1 ) ;
                        //{
                        //if( thirdC::c_strstrIF( ostoOsName , ".batonC." ) )

                        handleP.osF( ifcIDtYPEhANDLE_SHAREDmEMORY , (countT)osh , 0 , (countT)pv ) ;
            
                        }
                            if( offr == CsHAREDmEMiNFO ) { BLAMMO ; }
                            }
                                }
                                    break ;
                                    processGlobal2I._thirdC_pSharedMemInfo[ offr ].pv  = pv ;
                                    processGlobal2I._thirdC_pSharedMemInfo[ offr ].osh = (countT)osh ;
                                    thirdC::c_strncpyIF( tin0P , processGlobal2I._thirdC_pSharedMemInfo[ offr ].postName , ostoOsName , sizeof processGlobal2I._thirdC_pSharedMemInfo[ offr ].postName ) ;
                                {
                                if( !*processGlobal2I._thirdC_pSharedMemInfo[ offr ].postName )
                            {
                            for( offr = 0 ; offr < CsHAREDmEMiNFO ; offr ++ )
                            ZE( countT , offr ) ;
                        {
                        //DUPLICATED CODE: 1020068 1020061 1020132
        
                        //}
                        //    etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                        //    //CONoUTrAW(  ostoSay ) ;
                        //    //OStEXTAK( ostoSay , "\r\n" ) ;
                        //    OStEXTA(  ostoSay , ostoOsName ) ;
                        //    OStEXTAK( ostoSay , " old: " ) ;
                        //    OStEXTC(  ostoSay , pv , ' ' ) ;
                        //    OStEXT(   ostoSay , TUCK << 2 ) ;
                        //{
                        //if( thirdC::c_strstrIF( tin0P , ostoOsName , "napSlab" ) )
                        //CAN WRITE TO LOG SINCE NO EXCEPTION HANDLER WILL BE REGISTERED

                        //if( ((tin1S&)tin0P).pc Utility[ 0 ] )
                    {
                    else
                    }
                        osh = 0 ;
                        BOSpOOP
                        BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                    {
                    if( POOP )
    
                    //__( IsBadReadPtr( pv , 1 ) ) ;
                    //U:: THE NEXT LINE, WHEN NOT COMMENTED OUT, WAS NOT REPORTED BY LINT

                    //}
                    //    //etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                    //    LOGrAW(   ostoSay ) ;
                    //    OStEXTAK( ostoSay , " + (file mapping) / dosGetSharedMemIF 2\r\n" ) ;
                    //    OStEXTC(  ostoSay , save , '0' ) ;
                    //    OStEXT(   ostoSay , TUCK >> 2 ) ;
                    //{
                    //if( ((tin1S&)tin0P).pc Utility[ 0 ] )

                    voidT* pv = (voidT*)((tin1S&)tin0P).brcRaw ;
                    countT save = ((tin1S&)tin0P).brcRaw ;
                {
                else
                }
                    LOGrAW3( "DosGetSharedMem: MapViewOfFileExNuma returned " , ((tin1S&)tin0P).brcRaw , "\r\n" ) ;
                    CONoUTrAW3( "DosGetSharedMem: MapViewOfFileExNuma returned " , ((tin1S&)tin0P).brcRaw , "\r\n" ) ;
                    BOSdOnOTtEST( WHATgbo , GetLastError() )

                    osh = 0 ;
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                {
                if( POOP )
                BOSpOOP
                BOS( WHATgbo , BOSoK , MapViewOfFileExNuma( osh , osFlagsMap , 0 , 0 , 0 , 0 , thirdC::osOffNumaNodeValidChosenIF( processGlobal2I.idNumaNode ) ) )
    
                //}
                //    LOGrAW(    ostoSay ) ;
                //    CONoUTrAW( ostoSay ) ;
                //    
                //    OStEXTAK( ostoSay , "\r\n" ) ;
                //    OStEXTC(  ostoSay , ((tin1S&)tin0P).brcRaw , 0 ) ;
                //    OStEXTAK( ostoSay , "\" dosGetSharedMemIF OpenFileMapping [osh]: " ) ;
                //    OStEXTA(  ostoSay , postP ) ;
                //    OStEXTAK( ostoSay , " \"" ) ;
                //    OStEXTC(  ostoSay , ((tin1S&)tin0P).pag1->idAdam , 0 ) ;
                //    OStEXT(   ostoSay , TUCK << 2 ) ;
                //{
                //if( ((tin1S&)tin0P).pc Utility[ 0 ] )

                HANDLE osh = (HANDLE)((tin1S&)tin0P).brcRaw ;

                //}
                //    etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                //
                //    OStEXTA(  ostoSay , ostoOsName ) ;
                //    OStEXTAK( ostoSay , "dosGetSharedMemIF / opened napSlab aok [osName]:    " ) ;
                //    OStEXT(   ostoSay , TUCK << 1 ) ;
                //{
                //if( c_strstrIF( tin0P , ostoOsName , "napSlab" ) )
                //COMMENTED OUT BECAUSE WILL CLUTTER LOG FILE BECAUSE AN EXCEPTION HANDLER IS NOT YET REGISTERED
            {
            else
            }
                __1

                //}
                //    etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                //
                //    OStEXTA(  ostoSay , ostoOsName ) ;
                //    OStEXTAK( ostoSay , "    " ) ;
                //    OStEXTC(  ostoSay , rcSave , 0 ) ;
                //    OStEXTAK( ostoSay , "dosGetSharedMemIF / could not open napSlab [rc]:    " ) ;
                //    OStEXT(   ostoSay , TUCK << 1 ) ;
                //{
                //if( c_strstrIF( tin0P , ostoOsName , "napSlab" ) )
                //COMMENTED OUT BECAUSE WILL CLUTTER LOG FILE BECAUSE AN EXCEPTION HANDLER IS NOT YET REGISTERED

                POOPRqUIET

                countT rcSave = *((tin1S&)tin0P).pPoop ;
            {
            if( POOP )

            THREADmODE1rESTORE
            BOSpOOP
            THREADmODE1oN( flTHREADmODE1_QUIETiMPOTENCE )
            BOS( WHATgbo , BOSoK , OpenFileMapping( osFlagsMap , 0 , ostoOsName ) )

            //LOGrAW( "\r\n" ) ; //U:: TO FIND A BUG
            //LOGrAW( ostoOsName ) ; //U:: TO FIND A BUG
            //LOGrAW( "calling OpenFileMapping [postOsName]:    " ) ; //U:: TO FIND A BUG

            SECURITYaTTRIBUTE_saUNRESTRICTED( 0 ) ;
        {
        if( !POOP && !handleP )

        }
            }
                }
                    break ;
                    }
                        }
                            //}
                            //    //etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                            //    LOGrAW(   ostoSay ) ;
                            //    OStEXTAK( ostoSay , " + (file mapping) / dosGetSharedMemIF 1\r\n" ) ;
                            //    OStEXTC(  ostoSay , save , '0' ) ;
                            //    OStEXT(   ostoSay , TUCK >> 2 ) ;
                            //{
                            //if( ((tin1S&)tin0P).pc Utility[ 0 ] )

                            handleP.osF( ifcIDtYPEhANDLE_SHAREDmEMORY , (countT)osh , 0 , ((tin1S&)tin0P).brcRaw ) ;
                            countT save = ((tin1S&)tin0P).brcRaw ;
                        {
                        else
                        }
                            osh = 0 ;
                            BOSpOOP
                            BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                        {
                        if( POOP )
                        BOSpOOP
                        BOS( WHATgbo , BOSoK , MapViewOfFileExNuma( osh , osFlagsMap , 0 , 0 , 0 , 0 , thirdC::osOffNumaNodeValidChosenIF( processGlobal2I.idNumaNode ) ) )
                    {
                    else
                    }
                        osh = 0 ;
                        BOSpOOP
                        BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                    {
                    if( POOP )
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , DuplicateHandle( oshMe , (HANDLE)processGlobal2I._thirdC_pSharedMemInfo[ offr ].osh , oshMe , &osh , 0 , 1 , DUPLICATE_SAME_ACCESS ) )
                    HANDLE oshMe = (HANDLE)((tin1S&)tin0P).brcRaw ;
                    BOSdOnOTtEST( WHATgbo , GetCurrentProcess() )
                    ZE( HANDLE , osh ) ;
                    __( !processGlobal2I._thirdC_pSharedMemInfo[ offr ].pv ) ;
                    __( !processGlobal2I._thirdC_pSharedMemInfo[ offr ].osh ) ;
                {
                if( !c_strcmpIF( tin0P , processGlobal2I._thirdC_pSharedMemInfo[ offr ].postName , ostoOsName ) )
            {
            for( countT offr = 0 ; offr < CsHAREDmEMiNFO ; offr ++ )
        {

        if( !( F(flagsP) & flOPENsHAREDmEMORY_DOnOTsERIALIZE ) && F(processGlobal2I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal2I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal4I.grabMemorySpace.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        THREADmODE1oN( flTHREADmODE1_QUIETiMPOTENCE )       // SUPPRESS CALLS WITHIN gruntF() TO traceF() TO AVOID NONMONOTONIC GRABBING

        ;
            : FILE_MAP_ALL_ACCESS
            ? FILE_MAP_READ
        const flagsT osFlagsMap = F(flagsP) & flOPENsHAREDmEMORY_READoNLY

        c_zReplaceIF( tin0P , (osTextT*)(const osTextT*)ostoOsName , '/' , '.' ) ;
        OStEXTA(  ostoOsName  , postP ) ;
        OStEXTAK( ostoOsName  , "." ) ;
        else                                                  { OStEXTCF( ostoOsName , idMemorySpaceP ? idMemorySpaceP : ((tin1S&)tin0P).pag1->idMemorySpace , '0' ) ; }
        if( F(flagsP) & flOPENsHAREDmEMORY_ALLmEMORYsPACES )  { OStEXTAK( ostoOsName  , "_" ) ; }
        OStEXTAK( ostoOsName  , "." ) ;
        else                                                  { OStEXTCF( ostoOsName , processGlobal1I.idAdamRoot == ifcIDaDAM_TOOLnAPwORDvIEWER && ((tin1S&)tin0P).pag1->_thirdC_.idHomeOverride ? ((tin1S&)tin0P).pag1->_thirdC_.idHomeOverride : processGlobal2I.idHome , '0' ) ; }
        if( F(flagsP) & flOPENsHAREDmEMORY_ALLhOMES         ) { OStEXTAK( ostoOsName  , "_" ) ; }
        OStEXTAK( ostoOsName  , "." ) ;
        else                                                  { OStEXTA(  ostoOsName , thirdC::postUserNameIF() ) ; }
        if( F(flagsP) & flOPENsHAREDmEMORY_ALLuSERS         ) { OStEXTAK( ostoOsName  , "_" ) ; }
        OStEXTA(  ostoOsName  , postPrefix ) ;
        OStEXT(   ostoOsName , COSTnAPKINnAMEmAX + 1 )
        //CODEsYNC: DUPLICATE CODE 1020061 1020068

        ;
            :  "Local\\ideafarm.domains.com.ideafarm.1."
            ? "Global\\ideafarm.domains.com.ideafarm.1."

        osTextT* postPrefix = F(flagsP) & flOPENsHAREDmEMORY_ALLsESSIONS

    #elif defined( __NT__ )

        if( !POOP ) handleP.osF( ifcIDtYPEhANDLE_SHAREDmEMORY , handleP.hInvalid + 1 , 0 , (countT)pv ) ;
        if( POOP ) pv = 0 ;
        BOSpOOP
        BOSI( WHATgbo , BOSfAIL , DosGetNamedSharedMem( &pv , ostoName , PAG_EXECUTE | PAG_READ | PAG_WRITE ) )
        OStEXTA( ostoName  , postP ) ;
        OStEXTAK( ostoName  , "\\sharemem\\" ) ;
        OStEXT( ostoName , COSToSfILEnAMEmAX + 11 )
        ZE( voidT* , pv ) ;

    #ifdef __OS2__
    _IO_

    }
        if( POOP ) return ;
        __( idMemorySpaceP && !( F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tin0P ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tin0P ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        FV(flOPENsHAREDmEMORY,flagsP) ;
        __( idMemorySpaceP == ifcIDmEMORYsPACE_GLASS2 && processGlobal1I.idAdamRoot != ifcIDaDAM_2GLASS2 && processGlobal1I.idAdamRoot != ifcIDaDAM_PISS && processGlobal1I.idAdamRoot != ifcIDaDAM_1DRIVER ) ;        // PISS SO etherSoilF CAN CREATE SETTINGS FILES FOR THE glass2 MEMORY SPACE
        __( idMemorySpaceP == ifcIDmEMORYsPACE_GLASS1 && processGlobal1I.idAdamRoot != ifcIDaDAM_GLASS1  && processGlobal1I.idAdamRoot != ifcIDaDAM_PISS && processGlobal1I.idAdamRoot != ifcIDaDAM_1DRIVER ) ;        // PISS SO etherSoilF CAN CREATE SETTINGS FILES FOR THE glass1 MEMORY SPACE
        __( COSToSfILEnAMEmAX < thirdC::c_strlenIF( tin0P , postP ) ) ;
        __( !!thirdC::c_strchrIF( tin0P , postP , '\\' ) ) ;
        //__( !!thirdC::c_strchrIF( tin0P , postP , '/' ) ) ;
        __( !*postP ) ;
        if( POOP ) return ;
        __( ~handleP ) ;
        __Z( postP ) ;
        #endif
            { ZE( boolT , foo ) ; __( !foo && sizeof(countT) != sizeof(HANDLE) ) ;  }
        #if defined( __NT__ )
        if( POOP ) return ;
    {
    IFbEcAREFUL    
{
/*1*/voidT thirdC::dosGetSharedMemIF( tin0S& tin0P , handleC& handleP , const osTextT* const postP , const countT idMemorySpaceP , const flagsT flagsP )/*1*/

/**/
*/
 postP
 handleP
 pvP
arguments
the name must be less than 240 bytes
the name must not contain slash ('/') or backslash ('\\')
the memory must already be allocated and named
opens an existing allocation of shared memory
\<A HREF=\"5.1020068.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosGetSharedMemIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

