
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

etThread.delF( tin0P , pbi2 ) ;
etThread.delF( tin0P , pbi1 ) ;


}
    etThread.traceF( tin0P , T("---- [offWoth,off,diff,cbRemaining]:    ")+TF2(offWoth,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pbc1-pbi1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tb4+TF2(offWoth-(pbc1-pbi1),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pbe1-pbc1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    }
        }
            pbc1 += sizeof( count01T ) ;
            etThread.traceF( tin0P , T("++++ [signature]:    ")+TF2(*(count02T*)pbc1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN) ) ;

                etThread.traceF( tin0P , T("the woth difference is within this signature") ) ;
            if( offWoth > offNow && offWoth - offNow < sizeof( count01T ) )
        {
        default :
        }
            break ;

            pEE2 = (endEntryS*)pbc2 ; pbc2 += sizeof( endEntryS ) ;
            pEE1 = (endEntryS*)pbc1 ; pbc1 += sizeof( endEntryS ) ;
            static endEntryS* pEE2 ;
            static endEntryS* pEE1 ;

                etThread.traceF( tin0P , T("the woth difference is within this endEntryS") ) ;
            if( offWoth > offNow && offWoth - offNow < sizeof( endEntryS ) )
        {
        case 0x06054b50 :
        }
            break ;

            pbc2 += pFE2->cbComment ;
            pbc1 += pFE1->cbComment ;
            //FILE COMMENT

            }
                }
                    }
                        etThread.traceF( tin0P , T("    2 [timeCreated]:    ")+TTF(((countT*)&info2.timeCreated)[0],((countT*)&info2.timeCreated)[1]) ) ;
                        etThread.traceF( tin0P , T("    1 [timeCreated]:    ")+TTF(((countT*)&info1.timeCreated)[0],((countT*)&info1.timeCreated)[1]) ) ;

                        etThread.traceF( tin0P , T("    2 [timeAccessed]:    ")+TTF(((countT*)&info2.timeAccessed)[0],((countT*)&info2.timeAccessed)[1]) ) ;
                        etThread.traceF( tin0P , T("    1 [timeAccessed]:    ")+TTF(((countT*)&info1.timeAccessed)[0],((countT*)&info1.timeAccessed)[1]) ) ;

                        etThread.traceF( tin0P , T("    2 [timeModified]:    ")+TTF(((countT*)&info2.timeModified)[0],((countT*)&info2.timeModified)[1]) ) ;
                        etThread.traceF( tin0P , T("    1 [timeModified]:    ")+TTF(((countT*)&info1.timeModified)[0],((countT*)&info1.timeModified)[1]) ) ;
                    {
                    if( info1.tag == 0x0001 && info1.cbMeta == 0x18 )

                    ntfsMetaS& info2 = *(ntfsMetaS*)pbExtra2 ;
                    ntfsMetaS& info1 = *(ntfsMetaS*)pbExtra1 ;
                {
                if( idHeader1 == 0x000a )

                }
                    default     : { etThread.traceF( tin0P , T("unknown") ) ; break ; }
                    case 0x4690 : { etThread.traceF( tin0P , T("poszip 4690 reserved") ) ; break ; }
                    case 0x0066 : { etThread.traceF( tin0P , T("reserved for ibm s/390") ) ; break ; }
                    case 0x0065 : { etThread.traceF( tin0P , T("ibm s/390 attributes") ) ; break ; }
                    case 0x0023 : { etThread.traceF( tin0P , T("smartcrypt policy key data") ) ; break ; }
                    case 0x0022 : { etThread.traceF( tin0P , T("smartcrypt key provider") ) ; break ; }
                    case 0x0021 : { etThread.traceF( tin0P , T("policy decryption key") ) ; break ; }
                    case 0x0020 : { etThread.traceF( tin0P , T("reserved for timestamp") ) ; break ; }
                    case 0x0019 : { etThread.traceF( tin0P , T("pkcs#7 encryption recipient cert list") ) ; break ; }
                    case 0x0018 : { etThread.traceF( tin0P , T("record management controls") ) ; break ; }
                    case 0x0017 : { etThread.traceF( tin0P , T("strong encryption header") ) ; break ; }
                    case 0x0016 : { etThread.traceF( tin0P , T("X.509 for central dir") ) ; break ; }
                    case 0x0015 : { etThread.traceF( tin0P , T("X.509 for individual file") ) ; break ; }
                    case 0x0014 : { etThread.traceF( tin0P , T("pkcs#7 store for X.509 certificates") ) ; break ; }
                    case 0x000f : { etThread.traceF( tin0P , T("patch") ) ; break ; }
                    case 0x000e : { etThread.traceF( tin0P , T("reseerved file stream and fork") ) ; break ; }
                    case 0x000d : { etThread.traceF( tin0P , T("unix") ) ; break ; }
                    case 0x000c : { etThread.traceF( tin0P , T("openvms") ) ; break ; }
                    case 0x000a : { etThread.traceF( tin0P , T("ntfs") ) ; break ; }
                    case 0x0009 : { etThread.traceF( tin0P , T("os2") ) ; break ; }
                    case 0x0008 : { etThread.traceF( tin0P , T("reserved for extended language pfs") ) ; break ; }
                    case 0x0007 : { etThread.traceF( tin0P , T("av") ) ; break ; }
                    case 0x0001 : { etThread.traceF( tin0P , T("zip64") ) ; break ; }
                {
                switch( idHeader1 )

                static const byteT* pbExtra2 = pbc2 ; pbc2 += cbData2 ;
                static const byteT* pbExtra1 = pbc1 ; pbc1 += cbData1 ;

                count01T& cbData2   = *(count01T*)pbc2 ; pbc2 += sizeof( count01T ) ; 
                count01T& cbData1   = *(count01T*)pbc1 ; pbc1 += sizeof( count01T ) ; 
                count01T& idHeader2 = *(count01T*)pbc2 ; pbc2 += sizeof( count01T ) ;
                count01T& idHeader1 = *(count01T*)pbc1 ; pbc1 += sizeof( count01T ) ;
            {
            while( pbc1 < pbee1 )

            const byteT* pbee2 = pbc2 + pFE2->cbExtraField ;
            const byteT* pbee1 = pbc1 + pFE1->cbExtraField ;
            //EXTRA FIELD

            etThread.traceF( tin0P , T("index [cbFileName,fileName]:    ")+TF2(pFE2->cbFileName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postfnBuf) ) ; pbc2 += pFE2->cbFileName ;
            postfnBuf[ pFE2->cbFileName ] = 0 ;
            thirdC::c_memcpyIF( tin0P , postfnBuf , pbc2 , pFE2->cbFileName ) ;

            etThread.traceF( tin0P , T("index [cbFileName,fileName]:    ")+TF2(pFE1->cbFileName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postfnBuf) ) ; pbc1 += pFE1->cbFileName ;
            postfnBuf[ pFE1->cbFileName ] = 0 ;
            thirdC::c_memcpyIF( tin0P , postfnBuf , pbc1 , pFE1->cbFileName ) ;

            pFE2 = (fileEntryS*)pbc2 ; pbc2 += sizeof( fileEntryS ) ;
            pFE1 = (fileEntryS*)pbc1 ; pbc1 += sizeof( fileEntryS ) ;
            static fileEntryS* pFE2 ;
            static fileEntryS* pFE1 ;

                etThread.traceF( tin0P , T("the woth difference is within this fileEntryS") ) ;
            if( offWoth > offNow && offWoth - offNow < sizeof( fileEntryS ) )
        {
        case 0x02014b50 :
        }
            break ;

            pbc2 += pLFH2->cbCompressed ;
            pbc2 += pLFH2->cbExtraField ;
            
            pbc1 += pLFH1->cbCompressed ;
            pbc1 += pLFH1->cbExtraField ;
            
            etThread.traceF( tin0P , T("data 2 [fileName]:    ")+T(postfnBuf) ) ; pbc2 += pLFH2->cbFileName ;
            postfnBuf[ pLFH2->cbFileName ] = 0 ;
            thirdC::c_memcpyIF( tin0P , postfnBuf , pbc2 , pLFH2->cbFileName ) ;

            etThread.traceF( tin0P , T("data 1 [fileName]:    ")+T(postfnBuf) ) ; pbc1 += pLFH1->cbFileName ;
            postfnBuf[ pLFH1->cbFileName ] = 0 ;
            thirdC::c_memcpyIF( tin0P , postfnBuf , pbc1 , pLFH1->cbFileName ) ;

            pLFH2 = (localFileHeaderS*)pbc2 ; pbc2 += sizeof( localFileHeaderS ) ;
            pLFH1 = (localFileHeaderS*)pbc1 ; pbc1 += sizeof( localFileHeaderS ) ;
            static localFileHeaderS* pLFH2 ;
            static localFileHeaderS* pLFH1 ;

                etThread.traceF( tin0P , T("the woth difference is within this localFileHeaderS") ) ;
            if( offWoth > offNow && offWoth - offNow < sizeof( localFileHeaderS ) )
        {
        case 0x04034b50 :
    {
    switch( *(count02T*)pbc1 )
    etThread.traceF( tin0P , T("++++ [offNow,offWoth,diff,cbRemaining]:    ")+TF2(offNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offWoth,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offWoth-(pbc1-pbi1),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pbe1-pbc1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    countT offNow = pbc1-pbi1 ;

    const byteT* pbSave2 = pbc2 ;
    const byteT* pbSave1 = pbc1 ;
{
while( pbc1 < pbe1 )
osTextT postfnBuf[ TUCK << 1 ] ;

//if( bDiff ) { BLAMMO ; }
static boolT bDiff = etThread.memCompareF( tin0P , pbi1 , pbi2 , cbi1 ) ;

//for( countT offo = offWoth ; offo < cbi1 ; offo ++ ) *(byteT*)&pbi1[ offo ] = 0xee ;

}
    }
        break ;
        etThread.traceF( tin0P , T("woth diff at [offi]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        pbHit = pbi2 + offi ;
        offWoth = offi ;
    {
    if( pbi2[ offi ] - pbi1[ offi ] )
{
for( countT offi = 0 ; offi < cbi1 ; offi ++ )
ZE( const byteT* , pbHit ) ;
ZE( countT , offWoth ) ;

//if( cbDiff ) { BLAMMO ; }
static countT cbDiff = cbi2 - cbi1 ;

const byteT* pbe2 = pbi2 + cbi2 ;
static const byteT* pbc2 = pbi2 ;
etThread.boxGetShadowF( tin0P , pbi2 , cbi2 , tZip2 ) ; ___( pbi2 ) ;
ZE( countT , cbi2 ) ;
ZE( byteT* , pbi2 ) ;

const byteT* pbe1 = pbi1 + cbi1 ;
static const byteT* pbc1 = pbi1 ;
etThread.boxGetShadowF( tin0P , pbi1 , cbi1 , tZip1 ) ; ___( pbi1 ) ;
ZE( countT , cbi1 ) ;
ZE( byteT* , pbi1 ) ;

TN( tb4 , "    " ) ;
TN( tZip2 , "///e/2.zip" ) ;
TN( tZip1 , "///e/1.zip" ) ;

TODO

;
}
    count01T cbComment ;
    count02T offDiskEntries ;
    count02T cbEntries ;
    count01T cEntries ;
    count01T cEntriesThisDisk ;
    count01T idDiskStart ;
    count01T idDiskThis ;
    count02T signature ;
{
struct endEntryS

;
}
    count04T timeCreated ;
    count04T timeAccessed ;
    count04T timeModified ;
    count01T cbMeta ;
    count01T tag ;
    count02T reserved1 ;
{
struct ntfsMetaS


;
}
    count02T offLocalHeader ;
    count02T externalAttributes ;
    count01T internalAttributes ;
    count01T diskNumberStart ;
    count01T cbComment ;
    count01T cbExtraField ;
    count01T cbFileName ;
    count02T cbUncompressed ;
    count02T cbCompressed ;
    count02T crc32 ;
    count01T lastModFileDate ;
    count01T lastModFileTime ;
    count01T compressionMethod ;
    count01T flags ;
    count01T versionNeeded ;
    count01T versionMadeBy ;
    count02T signature ;
{
struct fileEntryS

;
}
    count01T cbExtraField ;
    count01T cbFileName ;
    count02T cbUncompressed ;
    count02T cbCompressed ;
    count02T crc32 ;
    count01T lastModFileDate ;
    count01T lastModFileTime ;
    count01T compressionMethod ;
    count01T flags ;
    count01T versionNeeded ;
    count02T signature ;
{
struct localFileHeaderS




/*1*/WAKEsHOWtEXT( "doodle dump zip file" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
