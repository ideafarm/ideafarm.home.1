
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

sgnDone_tmWorkF.waitF( tin0P ) ;
ether.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etherC::loafIF( tin0P ) ;
    etRock.traceF( tin0P , T("ok") ) ;
    
    }
        ++ s ; ether.osSleepF( tin0P , TOCK ) ;
    
        pcap_freealldevs( pInfo ) ; pInfo = 0 ;
    
        }
            pcNic = pcNic->next ;
    
            }
                }
                    pcap_free_datalinks( pInfo2 ) ;
    
                    }
                        }
                            }
                                }
                                    }
                                        ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;

                                        }
                                            }
                                                etThread.boxPutF( tin0P , T("mail.smtp2go.com/dd9/smtp/factories@ideafarm.com/")+tTo , tSubject+tBody ) ;

                                                TN( tTo      , "factoryreports@ideafarm.com" ) ;
                                                TN( tb4      , "    " ) ;
                                                TN( tBody    , "IDEAnETgEIGERcOUNTER has noticed that many unanswered ICMPv6 host solicitations are arriving.\r\n\r\n" ) ;
                                                TN( tSubject , "Subject: Flood attack detected.\r\n" ) ;
                                            {
                                            if( !( idNotifyLath ++ ) )
                                                            
                                            etRock.traceF( tin0P , T("attck detected [c136NewResponse,c135NewQuery]:    ")+TF3(c136NewResponse,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0xc)+TF3(c135NewQuery,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0xc) ) ;
                                        {
                                        else
                                        }
                                            }
                                                etThread.boxPutF( tin0P , T("mail.smtp2go.com/dd9/smtp/factories@ideafarm.com/")+tTo , tSubject+tBody ) ;

                                                TN( tTo      , "factoryreports@ideafarm.com" ) ;
                                                TN( tb4      , "    " ) ;
                                                TN( tBody    , "IDEAnETgEIGERcOUNTER has noticed that almost all ICMPv6 host solicitations are being answered\r\nso the attack appears to have ended.\r\n\r\n" ) ;
                                                TN( tSubject , "Subject: End of flood attack detected.\r\n" ) ;

                                                idNotifyLath = 0 ;
                                            {
                                            if( idNotifyLath )
                                        {
                                        if( c135NewQuery <= 0x10 || c135NewQuery >> 1 <= c136NewResponse )

                                        if( scDone > 0 ) etRock.traceF( tin0P , T("[scDone]:    ")+TF2((countT)scDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        sCountT scDone = pcap_dispatch( poshNic , CpACKETSiNbATCH , pcapCBF , (unsigned char*)"foo" ) ;
                                        //cNewInterruptions = 0 ;

                                        }
                                             c136NewResponse = c135NewQuery = 0 ;
                                             timeS2 = timeN2 ;
                                             timeS1 = timeN1 ;
                                        {
                                        if( timeE2 || timeE1 > TICK >> 4 )

                                        etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeS1 , timeS2 ) ;
                                        sCountT timeE2 = timeN2 ; 
                                        countT  timeE1 = timeN1 ; 

                                        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                                        ZE( sCountT , timeN2 ) ;
                                        ZE( countT  , timeN1 ) ;
                                    {
                                    while( !ether )
                                    ZE( countT , idNotifyLath ) ;
                                    sleepC s( tin0P , TAG( TAGiDnULL )  ) ;

                                    etThread.osTimeNowF( tin0P , timeS1 , timeS2 ) ;
                                    ZE( sCountT , timeS2 ) ;
                                    ZE( countT  , timeS1 ) ;
                                {
                                )
                                    !pcap_setfilter( poshNic , &byteCodes )
                                    &&
                                    !pcap_compile( poshNic , &byteCodes , "icmp6[icmp6type] = icmp6-neighborsolicit or icmp6[icmp6type] = icmp6-neighboradvert" , 1 , 0 )
                                    //!pcap_compile( poshNic , &byteCodes , "icmp6" , 1 , 0 )
                                    //G:!pcap_compile( poshNic , &byteCodes , "tcp or icmp6" , 0 , 0 )
                                (
                                if
                                bpf_program byteCodes ;
    
                                pcapCBF_p_tFINoN      = &tFINoN      ;
                                pcapCBF_p_tFINoFF     = &tFINoFF     ;
                                pcapCBF_p_tSYNoN      = &tSYNoN      ;
                                pcapCBF_p_tSYNoFF     = &tSYNoFF     ;
                                pcapCBF_p_tRSToN      = &tRSToN      ;
                                pcapCBF_p_tRSToFF     = &tRSToFF     ;
                                pcapCBF_p_tPSHoN      = &tPSHoN      ;
                                pcapCBF_p_tPSHoFF     = &tPSHoFF     ;
                                pcapCBF_p_tACKoN      = &tACKoN      ;
                                pcapCBF_p_tACKoFF     = &tACKoFF     ;
                                pcapCBF_p_tURGoN      = &tURGoN      ;
                                pcapCBF_p_tURGoFF     = &tURGoFF     ;
                                pcapCBF_p_tECEoN      = &tECEoN      ;
                                pcapCBF_p_tECEoFF     = &tECEoFF     ;
                                pcapCBF_p_tCWRoN      = &tCWRoN      ;
                                pcapCBF_p_tCWRoFF     = &tCWRoFF     ;
                                pcapCBF_p_tbDashesUDP = &tbDashesUDP ;
                                pcapCBF_p_tCloseParen = &tCloseParen ;
                                pcapCBF_p_tOpenParen  = &tOpenParen  ;
                                pcapCBF_p_tb64        = &tb64        ;
                                pcapCBF_p_tb32        = &tb32        ;
                                pcapCBF_p_tb4         = &tb4         ;
                                pcapCBF_p_tb          = &tb          ;
                                pcapCBF_p_tn          = &tn          ;
                                pcapCBF_idLinkType    = idLinkType   ;
                                pcapCBF_pEtRock       = &etRock      ;
                                pcapCBF_pEtThread     = &etThread    ;
                                pcapCBF_pTin0         = &tin0P       ;
                                etRock.traceF( tin0P , T("receiving header/data images") ) ;
                            {
                            if( !rc )
    
                            rc = pcap_set_datalink( poshNic , idLinkType ) ;
                        {
                        if( idLinkType != - 1 )
    
                        }
                            }
                                break ;
                                idLinkType = idMaybe ;
                            {
                            if( idMaybe == osIDlINKtYPE_NULL /*LOOPBACK*/ || idMaybe == osIDlINKtYPE_ETHERNET )
                            etRock.traceF( tin0P , T("link layer header type:    ")+TF2(idMaybe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            countT idMaybe = pInfo2[ offa ] ;
                        {
                        for( countT offa = 0 ; offa < rc ; offa ++ )
                        countT idLinkType = - 1 ;
                    {
                    if( rc )
    
                    rc = pcap_list_datalinks( poshNic , &pInfo2 ) ;
                    ZE( int* , pInfo2 ) ;
                {
                if( !rc )
                rc |= pcap_activate(    poshNic                 ) ;
                rc |= pcap_setnonblock( poshNic , 1 , postError ) ;
                rc  = pcap_set_timeout( poshNic , 1000          ) ;
                char postError[ PCAP_ERRBUF_SIZE ] ;
    
                etRock.traceF( tin0P , T(poshNic?"aok":"nope") ) ;
                pcap_t* poshNic = pcap_create( pcNic->name , postError ) ;
                etRock.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------") ) ;
            {
            if( etThread.strIdF( tin0P , tWantCurly , tName ) || !etThread.strCompareF( tin0P , tName , tWantExactName ) )
            etRock.traceF( tin0P , T("description    :    ")+T(pcNic->description) ) ;
            etRock.traceF( tin0P , T("wantName       :    ")+tWantExactName ) ;
            etRock.traceF( tin0P , T("name           :    ")+tName ) ;
            etRock.traceF( tin0P , T("idNic          :    ")+TF2(++idNic,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            TN( tName , pcNic->name ) ;
        {
        if( !rc ) while( pcNic )
        ZE( countT , idNic ) ;
        pcNic = pInfo ;
        pcap_if_t* pcNic ;
    
        int rc = pcap_findalldevs( &pInfo , postError ) ;
        pcap_if_t* pInfo ;
    {
    while( !ether )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    pcapCBF_p_idPacket = &idPacket ;
    ZE( countT , idPacket ) ;

    pstNnRequested = &stNnRequested ;
    stackC stNnRequested( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ;
    nnIdeaNetSubnet = socketC::nicNameIF( tin0P , etThread , T("2602:ff03::") ) ;
    
    char postError[ PCAP_ERRBUF_SIZE ] ;
    
    }
        pc1 = pc1->Next ;
    
        }
            pc2 = pc2->Next ;
    
            }
                etRock.traceF( tin0P , T("    [nnMe]        :    ")+T(nnMe)+(bWanted?tb4+T("wanted"):tn) ) ;
    
                if( bWanted && !nnMeOnWanted )  nnMeOnWanted = nnMe ;       //ONLY SUPPORTS A SINGLE ADDRESS ON THE WANTED ADAPTER
    
                nicNameC nnMe( nnv ) ;
                countT nnv = SWAB4( *(countT*)pbv ) ;
                byteT* pbv = (byteT*)pc2->Address.lpSockaddr->sa_data + 2 ;        //U:: THE "+ 2" IS NEEDED TO GET TO THE IPV4 VALUE, BUT I DO NOT KNOW WHY (CONJ: THE DEF OF THE STRUCTURE HAS CHANGED AND I AM USING AN OBSOLETE VERSION)
            {
            if( pc2->Address.lpSockaddr->sa_family == AF_INET )
        {
        while( pc2 )
        IP_ADAPTER_UNICAST_ADDRESS_LH* pc2 = pc1->FirstUnicastAddress ;
    
        if( cunt <= TUCK && !unicodeToAnsiF( postt , sizeof postt , (byteT*)punt , cunt ) ) etRock.traceF( tin0P , tSayDescription+T(postt) ) ;
        cunt = unicodeLengthF( punt ) ;
        punt = (unTextT*)pc1->Description ;
    
        etRock.traceF( tin0P , tSayName+T(pc1->AdapterName) ) ;
    
        }
            }
                tWantCurly = tCurly ;
                bWanted = 1 ;
            {
            if( !etThread.strCompareF( tin0P , tWantFriendly , T(postt) ) )
            etRock.traceF( tin0P , tSayFriendlyName+tFriendly ) ;
            TN( tFriendly , postt ) ;
        {
        if( cunt < sizeof postt && !unicodeToAnsiF( postt , sizeof postt , (byteT*)punt , cunt ) )
        ZE( boolT , bWanted ) ;
        countT   cunt = unicodeLengthF( punt ) ;
        unTextT* punt = (unTextT*)pc1->FriendlyName ;
    
        osTextT postt[ TUCK << 1 + 1 ] ;
    
        etRock.traceF( tin0P , T("[index,type]:    ")+TF2(luidIndex,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+tb4+TF3(luidType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ;
        //etRock.traceF( tin0P , T("[index,type]:    ")+TF2(luidIndex,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(luidType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
        countT   luidType  = pc1->Luid.Info.IfType       ;
        countT   luidIndex = pc1->Luid.Info.NetLuidIndex ;
    
        TN( tCurly , pc1->AdapterName ) ;
    {
    while( pc1 )
    static IP_ADAPTER_ADDRESSES* pc1 = pInfo ;
    pnnMeOnWanted = &nnMeOnWanted ;
    nicNameC nnMeOnWanted ;
    
    ULONG cAddresses = GetAdaptersAddresses( AF_INET , 0 , 0 ,  pInfo , &cba ) ;
    unsigned long cba = sizeof pInfo ; 
    static IP_ADAPTER_ADDRESSES pInfo[ 0x10 ] ;
    
    etRock.traceF( tin0P , T(postv) ) ;
    const osTextT* postv = pcap_lib_version() ;
    
      TN( tSayDescription  , "    [description] :    "     ) ;
      TN( tSayName         , "    [name]        :    "     ) ;
      TN( tSayFriendlyName , "    [friendlyName]:    "     ) ;
      TN( tWantCurly       , ""                            ) ;
    
      TN( tWantFriendly    , "ideanet"                     ) ;
    //TN( tWantFriendly    , "outer"                       ) ;
    //TN( tWantFriendly    , "Loopback Pseudo-Interface 1" ) ;
    
      TN( tWantExactName   , ""                            ) ;
    //TN( tWantExactName   , "\\Nic\\NPF_Loopback"      ) ;
    
    TN( tFINoN  , "FIN" ) ;
    TN( tFINoFF , "---" ) ;
    TN( tSYNoN  , "SYN" ) ;
    TN( tSYNoFF , "---" ) ;
    TN( tRSToN  , "RST" ) ;
    TN( tRSToFF , "---" ) ;
    TN( tPSHoN  , "PSH" ) ;
    TN( tPSHoFF , "---" ) ;
    TN( tACKoN  , "ACK" ) ;
    TN( tACKoFF , "---" ) ;
    TN( tURGoN  , "URG" ) ;
    TN( tURGoFF , "---" ) ;
    TN( tECEoN  , "ECE" ) ;
    TN( tECEoFF , "---" ) ;
    TN( tCWRoN  , "CWR" ) ;
    TN( tCWRoFF , "---" ) ;
    
    TN( tbDashesUDP , "-------------------------------------------------------" ) ;
    TN( tCloseParen , ")" ) ;
    TN( tOpenParen , "(" ) ;
    TN( tb64 , "                                                                      " ) ;
    TN( tb32 , "                                   " ) ;
    TN( tb4 , "    " ) ;
    TN( tb  , " "    ) ;
    TN( tn  , ""    ) ;
    
    //if( cProtocol != TUCK ) { BLAMMOiD( 0xff00ff00 ) ; }
    etRock.traceF( tin0P , T("[cProtocol]:    ")+TF2(cProtocol,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    const countT cProtocol = sizeof ppostProtocol / sizeof ppostProtocol[ 0 ] ;
    
    etherC& etRock = etherC::etRockIF( tin0P ) ;

    ether.osSleepF( tin0P , TIMEnAPdURINGsERVICEsTARTUP ) ;

    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIEST ) ;
    thirdC::dosPriorityProcessIF(      tin0P , ifcTHREADpRIORITY_LAZIEST ) ;
{
if( pTaskP )
TASK( tmWorkF )

DONE( tmInterruptLoopF )
}
    }
        ++ cNewInterruptionsP ;
        pcap_breakloop( poshNicP ) ;                    //DONE AFTER THE NAP SO AS TO NOT INTERFERE WITH THE INITIAL MOMENTS OF THE WO'TH CALL TO pcap_dispatch, JUST TO BE SAFE
        ++ cNewInterruptionsP ;
        ++ s ; ether.osSleepF( tin0P , TOCK << 3 ) ;    //A:ASSUME: LONG ENOUGH TO ALLOW WOTH CALL TO pcap_dispatch TO GET STARTED BEFORE pcap_breakloop SETS ITS FLAG
    {
    while( !ether )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    countT& cNewInterruptionsP = *(countT*)pTaskP->c2 ;
    pcap_t* poshNicP           =  (pcap_t*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmInterruptLoopF )

}
    }
        }
            }
                }
                    break ;
                    etRock.traceF( tin0P , T("[idPacket,source(idp),dest(idp),protocol,data]                                :    ")+TF3(++idPacket,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tIndent1+tb4+tSource+tb4+tDestination+tIndent2+tb4+tProtocol+tb4+tData , flTRACE_null ) ;
                {
                case 58 : // ICMPv6
                }
                    break ;
                    etRock.traceF( tin0P , T("[idPacket,source(idp),dest(idp),protocol,data]                                :    ")+TF3(++idPacket,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tIndent1+tb4+tSource+tb4+tDestination+tIndent2+tb4+tProtocol+tb4+tbDashesUDP+tb4+tData , flTRACE_NOpREFIX ) ;
                {
                case 17 :
                }
                    break ;
                    etRock.traceF( tin0P , T("[idPacket,source(idp),dest(idp),protocol,flags,idSerial,idSerialExpected,data]:    ")+TF3(++idPacket,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tIndent1+tb4+tSource+tb4+tDestination+tIndent2+tb4+tProtocol+tb4+tFlags+tb4+tIdSerial+tb4+tIdSerialExpected+tb4+tData , flTRACE_NOpREFIX ) ;
                {
                case 6 :
            {
            switch( protocol )

            ;
                    : tn
                    ? tb32
                : bToMe
                ? tb64
            TN( tIndent2 , "" ) ; tIndent2 = bFromMe

            ;
                    : tb64
                    ? tb32
                : bToMe
                ? tn
            TN( tIndent1 , "" ) ; tIndent1 = pcapCBF_idLinkType == osIDlINKtYPE_NULL || bFromMe

            boolT bToMe   = nnMeOnWanted == nnDest   ;
            boolT bFromMe = nnMeOnWanted == nnSource ;

            TN( tIdSerialExpected , "        " ) ; if( bACK ) tIdSerialExpected = TF3(idSerialExpected,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,8) ;
            TN( tIdSerial         , "" ) ; tIdSerial = TF3(idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,8) ;

            TN( tProtocol    , ppostProtocol[ protocol ] ) ; while( tProtocol.csF( tin0P ) < 0x18 ) tProtocol += tb ;
            TN( tDestination , ""                        ) ; tDestination = T(nnDest  ) ; while( tDestination.csF( tin0P ) < 0x18 ) tDestination += tb ; tDestination += tOpenParen+TF4(idpDestination,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,5,0xa)+tCloseParen ;
            TN( tSource      , ""                        ) ; tSource      = T(nnSource) ; while( tSource     .csF( tin0P ) < 0x18 ) tSource      += tb ; tSource      += tOpenParen+TF4(idpSource     ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,5,0xa)+tCloseParen ;
        {
        if( bReport )

        }
            }
                tData = T("[type,code,bRouter,bSolicited,bOverride,nnTarget,c136Response,c135Query,c136NewResponse,c135NewQuery]:    ")+TF4(pIcmpv6->type,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+tb4+TF4(pIcmpv6->code,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(bRouter?"    ROUTER":"          ")+T(bSolicited?"    SOLICITED":"             ")+T(bOverride?"    OVERRIDE    ":"                ")+T(nnTarget)+tb4+TF3(c136Response,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0xc)+TF3(c135Query,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0xc)+TF3(c136NewResponse,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0xc)+TF3(c135NewQuery,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0xc) ;

                }
                    }
                        break ;
                        }
                            pstNnRequested->ungrabF( tin0P ) ;
                            if( ids ) pstNnRequested->extractF( 0 , tin0P ) ;
                            pstNnRequested->sinkF( tin0P , ids , nnSource , flSTACKsINK_QUERY ) ;
                            pstNnRequested->grabF( tin0P , TAG( TAGiDnULL ) ) ;
                            ZE( countT , ids ) ;

                            bReport = 1 ;
                            c136Response ++ ; c136NewResponse ++ ;
                        {
                        if( nnIdeaNetSubnet == nnSubnet36Target )
                        nicNameC nnSubnet36Target = nnTarget( 0x24 ) ;

                        bOverride  = icmpv6Type136.bOverride  ;
                        bSolicited = icmpv6Type136.bSolicited ;
                        bRouter    = icmpv6Type136.bRouter    ;

                        nnTarget = *(nicNameC*)icmpv6Type136.pcTarget ;
                        icmpv6Type136.swabF() ;
                        icmpv6Type136S icmpv6Type136 = *(icmpv6Type136S*)pIcmpv6 ;
                    {
                    case 136 :                                              // HOST ADVERTISEMENT
                    }
                        break ;
                        }
#endif
                            }
                                }
                                    etRock.traceF( tin0P , T("could not add nicName [rc,nicName]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnTarget) ) ;
                                    POOPRqUIET
                                    countT rc = POOP ;
                                {
                                else
                                if( !POOP ) etRock.traceF( tin0P , T("added nicName aok [nicName]:    ")+T(nnTarget) ) ;
                                ((tin1S&)tin0P).pEtScratch->osNicAddressAddF( tin0P , hInterface , nnTarget , 30 * 60 , 0 , 0x30 ) ;
                                SCOOPS
                                _IO_
                            {
                            IFsCRATCHoK

                            etThread.osNicOpenF( tin0P , hInterface , T("ideanet") ) ;
                            handleC hInterface( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_NETWORKiNTERFACE ) ;
#if defined( NEVERdEFINED )
                            //U::DO THIS ONLY IF ON A LIST OF APPROVED NN VALUES

                            pstNnRequested->sinkF( tin0P , countTC() , nnTarget , flSTACKsINK_UNIQUE ) ;

                            bReport = 1 ;
                            c135Query ++ ; c135NewQuery ++ ;
                        {
                        if( nnIdeaNetSubnet == nnSubnet36Target )
                        nicNameC nnSubnet36Target = nnTarget( 0x24 ) ;

                        nnTarget = *(nicNameC*)icmpv6Type135.pcTarget ;
                        icmpv6Type135.swabF() ;
                        icmpv6Type135S icmpv6Type135 = *(icmpv6Type135S*)pIcmpv6 ;
                    {
                    case 135 :                                              // HOST SOLICITATION
                {
                switch( pIcmpv6->type )
                ZE( boolT , bOverride  ) ;
                ZE( boolT , bSolicited ) ;
                ZE( boolT , bRouter    ) ;
                nicNameC nnTarget ;
            {
            /*else*/ if( pIcmpv6 )
            //}
            //    etThread.delF( tin0P , psttData ) ;
            //    tData = T(psttData) ;
            //
            //    }
            //        pbd ++ ;
            //        }
            //            etThread.strFuseF( tin0P , psttData , T(post2) ) ;
            //            osTextT post2[] = { *pbd , 0 } ;
            //        {
            //        if( *pbd >= 0x20 && *pbd < 0x7e )
            //    {
            //    while( psttData[ 2 ].idAdam && pbd < pbDataEnd )
            //    const byteT* pbd = pbData ;
            //
            //    etThread.strMakeF( tin0P , LF , psttData , 0 , cbData > TUCK ? TUCK : cbData ) ; ___( psttData ) ;
            //    ZE( strokeS* , psttData ) ;
            //
            //    countT cbData = pbDataEnd - pbData ;                                            //I IGNORE cbDataGross, RELYING INSTEAD ON THE IP HEADER
            //    const byteT* pbData    = (byteT*)( (countT*)pUdp + sizeof( udpHeadRawS ) ) ;
            //
            //    idpDestination = udp.u.swabbed.idpDestination ;
            //    idpSource      = udp.u.swabbed.idpSource      ;
            //
            //    udp.swabF() ;
            //    udpHeadRawS udp = *pUdp ;
            //{
            //else if( pUdp )
            //}
            //    bReport = 1 ;
            //    etThread.delF( tin0P , psttData ) ;
            //    tData = T(psttData) ;
            //
            //    }
            //        pbd ++ ;
            //        }
            //            etThread.strFuseF( tin0P , psttData , T(post2) ) ;
            //            osTextT post2[] = { *pbd , 0 } ;
            //        {
            //        if( *pbd >= 0x20 && *pbd < 0x7e )
            //    {
            //    while( psttData[ 2 ].idAdam && pbd < pbDataEnd )
            //    const byteT* pbd = pbData ;
            //
            //    etThread.strMakeF( tin0P , LF , psttData , 0 , cbData > TUCK ? TUCK : cbData ) ; ___( psttData ) ;
            //    ZE( strokeS* , psttData ) ;
            //
            //    countT cbData = pbDataEnd - pbData ;
            //    const byteT* pbData    = (byteT*)( (countT*)pTcp + tcp.u.swabbed.hCounts ) ;
            //
            //    idpDestination = tcp.u.swabbed.idpDestination ;
            //    idpSource      = tcp.u.swabbed.idpSource      ;
            //
            //    }
            //        idSerialExpected = tcp.u.swabbed.idSerialExpected ;
            //        bACK = 1 ;
            //    {
            //    if( tcp.u.swabbed.bACK )
            //    idSerial = tcp.u.swabbed.idSerial ;
            //
            //    tFlags += tb + ( tcp.u.swabbed.bFIN ? tFINoN : tFINoFF ) ;
            //    tFlags += tb + ( tcp.u.swabbed.bSYN ? tSYNoN : tSYNoFF ) ;
            //    tFlags += tb + ( tcp.u.swabbed.bRST ? tRSToN : tRSToFF ) ;
            //    tFlags += tb + ( tcp.u.swabbed.bPSH ? tPSHoN : tPSHoFF ) ;
            //    tFlags += tb + ( tcp.u.swabbed.bACK ? tACKoN : tACKoFF ) ;
            //    tFlags += tb + ( tcp.u.swabbed.bURG ? tURGoN : tURGoFF ) ;
            //    tFlags += tb + ( tcp.u.swabbed.bECE ? tECEoN : tECEoFF ) ;
            //    tFlags +=        tcp.u.swabbed.bCWR ? tCWRoN : tCWRoFF   ;
            //
            //    tcp.swabF() ;
            //    tcpHeadRawS tcp = *pTcp ;
            //{
            //if( pTcp )

            }
                }
                    }
                        }
                            break ;
                            bQuit = 1 ;
                        {
                        default :
                        }
                            break ;
                                                                // THIS IS A SECURITY ATTACK SURFACE ; AN ATTACKER CAN HIDE FROM ME BY INSERTING AN IPv6 EXTENSION HEADER TO CAUSE ME TO IGNORE THE PACKET ; SO I AM GOING TO TRACE THIS PACKET
                            pbNextHead  = 0 ;                   // I GIVE UP; AS OF THIS WRITING, ALL OF THE VALUES FOR protocol OTHER THAN 6 (TCP) ARRIVE HERE, BECAUSE I DON'T NEED TO SNIFF THEM AND IT IS SAFER TO IGNORE THEM THAN RISK INCORRECTLY PARSING THEM
                        {
                        case 139 :
                        case  50 :
                        case  44 :
                        //}
                        //    break ;
                        //    pbNextHead += ( pbNextHead[ 1 ] + 1 ) * ( 2 * sizeof( countT) ) ;
                        //    protocol    =   pbNextHead[ 0 ] ;
                        //{
                        case 140 :
                        case 135 :
                        //}
                        //    break ;
                        //    pbNextHead += ( pbNextHead[ 1 ] + 2 ) * sizeof( countT) ;       // NOT SURE; SEE RFC
                        //    protocol    =   pbNextHead[ 0 ] ;
                        //{
                        case 51 :
                        //}
                        //    break ;
                        //    pbNextHead +=   pbNextHead[ 1 ] + 1 ;
                        //    protocol    =   pbNextHead[ 0 ] ;
                        //{
                        case 60 :
                        case 43 :
                        case 0  :

                        }
                            break ;
                            pIcmpv6 = (icmpv6HeadRawS*)pbNextHead ;
                        {
                        case 58 :
                        }
                            break ;
                            pUdp = (udpHeadRawS*)pbNextHead ;
                        {
                        case 17 /*UDP*/ :
                        }
                            break ;
                            pTcp = (tcpHeadRawS*)pbNextHead ;
                        {
                        case 6 /*TCP*/ :
                    {
                    switch( protocol )

                    //      
                    //      0    *   IPv6 Hop-by-Hop Option                  [RFC8200]
                    //      43   *   Routing Header for IPv6                 [RFC8200][RFC5095]
                    //      44   *   Fragment Header for IPv6                [RFC8200]
                    //      50   *   Encapsulating Security Payload          [RFC4303]
                    //      51   *   Authentication Header                   [RFC4302]
                    //      60   *   Destination Options for IPv6            [RFC8200]
                    //      135  *   Mobility Header                         [RFC6275]
                    //      139  *   Host Identity Protocol                  [RFC7401]
                    //      140  *   Shim6 Protocol                          [RFC5533]
                    //      253  -   Use for experimentation and testing     [RFC3692][RFC4727]
                    //      254  -   Use for experimentation and testing     [RFC3692][RFC4727]
                    //      
                    //      ipv6 extension header types
                    //      
                    //      https://www.iana.org/assignments/ipv6-parameters/ipv6-parameters.xhtml
                    //      
                {
                while( !pTcp && !pUdp && !pIcmpv6 && !bQuit && pbNextHead )
                ZE( boolT , bQuit ) ;
                byteT* pbNextHead = (byteT*)pIpv6HeadRaw + sizeof head ;

                pbDataEnd = (byteT*)pIpv6HeadRaw + sizeof head + head.u.swabbed.cbGramNet ;

                protocol = head.u.swabbed.idNextHeader ;
                nnDest   = nicNameC( head.u.swabbed.pcDestination[ 0 ] , head.u.swabbed.pcDestination[ 1 ] , head.u.swabbed.pcDestination[ 2 ] , head.u.swabbed.pcDestination[ 3 ] ) ;
                nnSource = nicNameC( head.u.swabbed.pcSource[      0 ] , head.u.swabbed.pcSource[      1 ] , head.u.swabbed.pcSource[      2 ] , head.u.swabbed.pcSource[      3 ] ) ;

                head.swabF() ;
                ipv6HeadRawS head = *pIpv6HeadRaw ;
                bIPv6 = 1 ;
            {
            //else if( pIpv6HeadRaw )
            //}
            //    }
            //        case 17 : { pUdp    = (udpHeadRawS*)(    (countT*)pIpv4HeadRaw + head.u.swabbed.hCounts ) ; break ; }
            //        case  6 : { pTcp    = (tcpHeadRawS*)(    (countT*)pIpv4HeadRaw + head.u.swabbed.hCounts ) ; break ; }
            //    {
            //    switch( protocol )
            //
            //    pbDataEnd = (byteT*)pIpv4HeadRaw + head.u.swabbed.hCounts * sizeof( countT ) + head.u.swabbed.cbGramNet ;
            //
            //    protocol = head.u.swabbed.protocol ;
            //    nnDest   = nicNameC( head.u.swabbed.ipv4Destination ) ;
            //    nnSource = nicNameC( head.u.swabbed.ipv4Source      ) ;
            //
            //    head.swabF() ;
            //    ipv4HeadRawS head = *pIpv4HeadRaw ;
            //{
            //if( pIpv4HeadRaw )
            ZE( const byteT*    , pbDataEnd ) ;
            ZE( icmpv6HeadRawS* , pIcmpv6   ) ;
            ZE( udpHeadRawS*    , pUdp      ) ;
            ZE( tcpHeadRawS*    , pTcp      ) ;
        {
        ZE( boolT  , bReport ) ;
        ZE( boolT  , bIPv6 ) ;
        ZE( countT , protocol ) ;
        ZE( boolT  , bACK ) ;
        ZE( countT , idSerialExpected ) ;
        ZE( countT , idSerial         ) ;
        ZE( countT , idpDestination   ) ;
        ZE( countT , idpSource        ) ;
        nicNameC nnDest   ;
        nicNameC nnSource ;
        TN( tData  , "" ) ;
        TN( tFlags , "" ) ;
    {
    if( pIpv6HeadRaw )

    }
        }
            case 0x86dd : { pIpv6HeadRaw = (const ipv6HeadRawS*)pbc ; break ; }
            //case 0x0800 : { pIpv4HeadRaw = (const ipv4HeadRawS*)pbc ; break ; }
        {
        switch( idType )

        count01T     idType           = *(count01T*)pbc ; pbc += 2 ; idType = SWAB2( idType ) ;
        const byteT* pbMACSource      =             pbc ; pbc += 6 ;
        const byteT* pbMACDestination =             pbc ; pbc += 6 ;
    {
    else if( pcapCBF_idLinkType == osIDlINKtYPE_ETHERNET )
    }
        }
            case 0x1e : { pIpv6HeadRaw = (ipv6HeadRawS*)( pbc + sizeof( loopHeadS ) /*- 2*/ ) ; break ; }         //U::"- 2" TO MAKE IT WORK (MYSTERY)
            case 0x1c :
            case 0x18 :

            //case 0x2 : { pIpv4HeadRaw = (ipv4HeadRawS*)( pbc + sizeof( loopHeadS ) ) ; break ; }
        {
        switch( pLoopHead->protocol )

        const loopHeadS* pLoopHead = (const loopHeadS*)pbc ;
    {
    if( pcapCBF_idLinkType == osIDlINKtYPE_NULL )
    ZE( const ipv6HeadRawS* , pIpv6HeadRaw ) ;
    //ZE( const ipv4HeadRawS* , pIpv4HeadRaw ) ;

    pbc = (byteT*)pInfo3DataP ;
    byteT* pbc ;

    textC&  tFINoN          = *pcapCBF_p_tFINoN      ;
    textC&  tFINoFF         = *pcapCBF_p_tFINoFF     ;
    textC&  tSYNoN          = *pcapCBF_p_tSYNoN      ;
    textC&  tSYNoFF         = *pcapCBF_p_tSYNoFF     ;
    textC&  tRSToN          = *pcapCBF_p_tRSToN      ;
    textC&  tRSToFF         = *pcapCBF_p_tRSToFF     ;
    textC&  tPSHoN          = *pcapCBF_p_tPSHoN      ;
    textC&  tPSHoFF         = *pcapCBF_p_tPSHoFF     ;
    textC&  tACKoN          = *pcapCBF_p_tACKoN      ;
    textC&  tACKoFF         = *pcapCBF_p_tACKoFF     ;
    textC&  tURGoN          = *pcapCBF_p_tURGoN      ;
    textC&  tURGoFF         = *pcapCBF_p_tURGoFF     ;
    textC&  tECEoN          = *pcapCBF_p_tECEoN      ;
    textC&  tECEoFF         = *pcapCBF_p_tECEoFF     ;
    textC&  tCWRoN          = *pcapCBF_p_tCWRoN      ;
    textC&  tCWRoFF         = *pcapCBF_p_tCWRoFF     ;
    textC&  tbDashesUDP     = *pcapCBF_p_tbDashesUDP ;
    textC&  tCloseParen     = *pcapCBF_p_tCloseParen ;
    textC&  tOpenParen      = *pcapCBF_p_tOpenParen  ;
    textC&  tb64            = *pcapCBF_p_tb64        ;
    textC&  tb32            = *pcapCBF_p_tb32        ;
    textC&  tb4             = *pcapCBF_p_tb4         ;
    textC&  tb              = *pcapCBF_p_tb          ;
    textC&  tn              = *pcapCBF_p_tn          ;

    countT&   idPacket      = *pcapCBF_p_idPacket    ;
    nicNameC& nnMeOnWanted  = *pnnMeOnWanted         ;
    etherC&   etRock        = *pcapCBF_pEtRock       ;
    etherC&   etThread      = *pcapCBF_pEtThread     ;
    tin0S&    tin0P         = *pcapCBF_pTin0         ;
{
void __cdecl pcapCBF( u_char* postUserNotUsedP , const pcap_pkthdr* pInfo3HeaderNotUsedP , const u_char* pInfo3DataP )

stackC*   pstNnRequested ;
nicNameC  nnIdeaNetSubnet ;

countT    c136NewResponse ;
countT    c135NewQuery    ;
countT    c136Response    ;
countT    c135Query       ;

textC*    pcapCBF_p_tFINoN      ;
textC*    pcapCBF_p_tFINoFF     ;
textC*    pcapCBF_p_tSYNoN      ;
textC*    pcapCBF_p_tSYNoFF     ;
textC*    pcapCBF_p_tRSToN      ;
textC*    pcapCBF_p_tRSToFF     ;
textC*    pcapCBF_p_tPSHoN      ;
textC*    pcapCBF_p_tPSHoFF     ;
textC*    pcapCBF_p_tACKoN      ;
textC*    pcapCBF_p_tACKoFF     ;
textC*    pcapCBF_p_tURGoN      ;
textC*    pcapCBF_p_tURGoFF     ;
textC*    pcapCBF_p_tECEoN      ;
textC*    pcapCBF_p_tECEoFF     ;
textC*    pcapCBF_p_tCWRoN      ;
textC*    pcapCBF_p_tCWRoFF     ;
textC*    pcapCBF_p_tbDashesUDP ;
textC*    pcapCBF_p_tCloseParen ;
textC*    pcapCBF_p_tOpenParen  ;
textC*    pcapCBF_p_tb64        ;
textC*    pcapCBF_p_tb32        ;
textC*    pcapCBF_p_tb4         ;
textC*    pcapCBF_p_tb          ;
textC*    pcapCBF_p_tn          ;
countT*   pcapCBF_p_idPacket    ;
nicNameC* pnnMeOnWanted         ;
etherC*   pcapCBF_pEtRock       ;
etherC*   pcapCBF_pEtThread     ;
tin0S*    pcapCBF_pTin0         ;
countT    pcapCBF_idLinkType    ;

#define osIDlINKtYPE_ETHERNET 1
#define osIDlINKtYPE_NULL     0

;
}
    "Reserved"                              ,       //    255
    "Use for experimentation and testing"   ,       //    254
    "Use for experimentation and testing"   ,       //    253
    "Unassigned"                            ,       //    252
    "Unassigned"                            ,       //    251
    "Unassigned"                            ,       //    250
    "Unassigned"                            ,       //    249
    "Unassigned"                            ,       //    248
    "Unassigned"                            ,       //    247
    "Unassigned"                            ,       //    246
    "Unassigned"                            ,       //    245
    "Unassigned"                            ,       //    244
    "Unassigned"                            ,       //    243
    "Unassigned"                            ,       //    242
    "Unassigned"                            ,       //    241
    "Unassigned"                            ,       //    240
    "Unassigned"                            ,       //    239
    "Unassigned"                            ,       //    238
    "Unassigned"                            ,       //    237
    "Unassigned"                            ,       //    236
    "Unassigned"                            ,       //    235
    "Unassigned"                            ,       //    234
    "Unassigned"                            ,       //    233
    "Unassigned"                            ,       //    232
    "Unassigned"                            ,       //    231
    "Unassigned"                            ,       //    230
    "Unassigned"                            ,       //    229
    "Unassigned"                            ,       //    228
    "Unassigned"                            ,       //    227
    "Unassigned"                            ,       //    226
    "Unassigned"                            ,       //    225
    "Unassigned"                            ,       //    224
    "Unassigned"                            ,       //    223
    "Unassigned"                            ,       //    222
    "Unassigned"                            ,       //    221
    "Unassigned"                            ,       //    220
    "Unassigned"                            ,       //    219
    "Unassigned"                            ,       //    218
    "Unassigned"                            ,       //    217
    "Unassigned"                            ,       //    216
    "Unassigned"                            ,       //    215
    "Unassigned"                            ,       //    214
    "Unassigned"                            ,       //    213
    "Unassigned"                            ,       //    212
    "Unassigned"                            ,       //    211
    "Unassigned"                            ,       //    210
    "Unassigned"                            ,       //    209
    "Unassigned"                            ,       //    208
    "Unassigned"                            ,       //    207
    "Unassigned"                            ,       //    206
    "Unassigned"                            ,       //    205
    "Unassigned"                            ,       //    204
    "Unassigned"                            ,       //    203
    "Unassigned"                            ,       //    202
    "Unassigned"                            ,       //    201
    "Unassigned"                            ,       //    200
    "Unassigned"                            ,       //    199
    "Unassigned"                            ,       //    198
    "Unassigned"                            ,       //    197
    "Unassigned"                            ,       //    196
    "Unassigned"                            ,       //    195
    "Unassigned"                            ,       //    194
    "Unassigned"                            ,       //    193
    "Unassigned"                            ,       //    192
    "Unassigned"                            ,       //    191
    "Unassigned"                            ,       //    190
    "Unassigned"                            ,       //    189
    "Unassigned"                            ,       //    188
    "Unassigned"                            ,       //    187
    "Unassigned"                            ,       //    186
    "Unassigned"                            ,       //    185
    "Unassigned"                            ,       //    184
    "Unassigned"                            ,       //    183
    "Unassigned"                            ,       //    182
    "Unassigned"                            ,       //    181
    "Unassigned"                            ,       //    180
    "Unassigned"                            ,       //    179
    "Unassigned"                            ,       //    178
    "Unassigned"                            ,       //    177
    "Unassigned"                            ,       //    176
    "Unassigned"                            ,       //    175
    "Unassigned"                            ,       //    174
    "Unassigned"                            ,       //    173
    "Unassigned"                            ,       //    172
    "Unassigned"                            ,       //    171
    "Unassigned"                            ,       //    170
    "Unassigned"                            ,       //    169
    "Unassigned"                            ,       //    168
    "Unassigned"                            ,       //    167
    "Unassigned"                            ,       //    166
    "Unassigned"                            ,       //    165
    "Unassigned"                            ,       //    164
    "Unassigned"                            ,       //    163
    "Unassigned"                            ,       //    162
    "Unassigned"                            ,       //    161
    "Unassigned"                            ,       //    160
    "Unassigned"                            ,       //    159
    "Unassigned"                            ,       //    158
    "Unassigned"                            ,       //    157
    "Unassigned"                            ,       //    156
    "Unassigned"                            ,       //    155
    "Unassigned"                            ,       //    154
    "Unassigned"                            ,       //    153
    "Unassigned"                            ,       //    152
    "Unassigned"                            ,       //    151
    "Unassigned"                            ,       //    150
    "Unassigned"                            ,       //    149
    "Unassigned"                            ,       //    148
    "BIT-EMU"                               ,       //    147
    "Homa"                                  ,       //    146
    "NSH"                                   ,       //    145
    "AGGFRAG"                               ,       //    144
    "Ethernet"                              ,       //    143
    "ROHC"                                  ,       //    142
    "WESP"                                  ,       //    141
    "Shim6"                                 ,       //    140
    "HIP"                                   ,       //    139
    "manet"                                 ,       //    138
    "MPLS-in-IP"                            ,       //    137
    "UDPLite"                               ,       //    136
    "Mobility Header"                       ,       //    135
    "RSVP-E2E-IGNORE"                       ,       //    134
    "FC"                                    ,       //    133
    "SCTP"                                  ,       //    132
    "PIPE"                                  ,       //    131
    "SPS"                                   ,       //    130
    "IPLT"                                  ,       //    129
    "SSCOPMCE"                              ,       //    128
    "CRUDP"                                 ,       //    127
    "CRTP"                                  ,       //    126
    "FIRE"                                  ,       //    125
    "ISIS over IPv4"                        ,       //    124
    "PTP"                                   ,       //    123
    "SM (deprecated)"                       ,       //    122
    "SMP"                                   ,       //    121
    "UTI"                                   ,       //    120
    "SRP"                                   ,       //    119
    "STP"                                   ,       //    118
    "IATP"                                  ,       //    117
    "DDX"                                   ,       //    116
    "L2TP"                                  ,       //    115
    "any 0-hop protocol"                    ,       //    114
    "PGM"                                   ,       //    113
    "VRRP"                                  ,       //    112
    "IPX-in-IP"                             ,       //    111
    "Compaq-Peer"                           ,       //    110
    "SNP"                                   ,       //    109
    "IPComp"                                ,       //    108
    "A/N"                                   ,       //    107
    "QNX"                                   ,       //    106
    "SCPS"                                  ,       //    105
    "ARIS"                                  ,       //    104
    "PIM"                                   ,       //    103
    "PNNI"                                  ,       //    102
    "IFMP"                                  ,       //    101
    "GMTP"                                  ,       //    100
    "any private encryption scheme"         ,       //     99
    "ENCAP"                                 ,       //     98
    "ETHERIP"                               ,       //     97
    "SCC-SP"                                ,       //     96
    "MICP (deprecated)"                     ,       //     95
    "IPIP"                                  ,       //     94
    "AX.25"                                 ,       //     93
    "MTP"                                   ,       //     92
    "LARP"                                  ,       //     91
    "Sprite-RPC"                            ,       //     90
    "OSPFIGP"                               ,       //     89
    "EIGRP"                                 ,       //     88
    "TCF"                                   ,       //     87
    "DGP"                                   ,       //     86
    "NSFNET-IGP"                            ,       //     85
    "IPTM"                                  ,       //     84
    "VINES"                                 ,       //     83
    "SECURE-VMTP"                           ,       //     82
    "VMTP"                                  ,       //     81
    "ISO-IP"                                ,       //     80
    "WB-EXPAK"                              ,       //     79
    "WB-MON"                                ,       //     78
    "SUN-ND"                                ,       //     77
    "BR-SAT-MON"                            ,       //     76
    "PVP"                                   ,       //     75
    "WSN"                                   ,       //     74
    "CPHB"                                  ,       //     73
    "CPNX"                                  ,       //     72
    "IPCV"                                  ,       //     71
    "VISA"                                  ,       //     70
    "SAT-MON"                               ,       //     69
    "any distributed file system"           ,       //     68
    "IPPC"                                  ,       //     67
    "RVD"                                   ,       //     66
    "KRYPTOLAN"                             ,       //     65
    "SAT-EXPAK"                             ,       //     64
    "any local network"                     ,       //     63
    "CFTP"                                  ,       //     62
    "any host internal protocol"            ,       //     61
    "IPv6-Opts"                             ,       //     60
    "IPv6-NoNxt"                            ,       //     59
    "IPv6-ICMP"                             ,       //     58
    "SKIP"                                  ,       //     57
    "TLSP"                                  ,       //     56
    "Min-IPv4"                              ,       //     55
    "NARP"                                  ,       //     54
    "SWIPE (deprecated)"                    ,       //     53
    "I-NLSP"                                ,       //     52
    "AH"                                    ,       //     51
    "ESP"                                   ,       //     50
    "BNA"                                   ,       //     49
    "DSR"                                   ,       //     48
    "GRE"                                   ,       //     47
    "RSVP"                                  ,       //     46
    "IDRP"                                  ,       //     45
    "IPv6-Frag"                             ,       //     44
    "IPv6-Route"                            ,       //     43
    "SDRP"                                  ,       //     42
    "IPv6"                                  ,       //     41
    "IL"                                    ,       //     40
    "TP++"                                  ,       //     39
    "IDPR-CMTP"                             ,       //     38
    "DDP"                                   ,       //     37
    "XTP"                                   ,       //     36
    "IDPR"                                  ,       //     35
    "3PC"                                   ,       //     34
    "DCCP"                                  ,       //     33
    "MERIT-INP"                             ,       //     32
    "MFE-NSP"                               ,       //     31
    "NETBLT"                                ,       //     30
    "ISO-TP4"                               ,       //     29
    "IRTP"                                  ,       //     28
    "RDP"                                   ,       //     27
    "LEAF-2"                                ,       //     26
    "LEAF-1"                                ,       //     25
    "TRUNK-2"                               ,       //     24
    "TRUNK-1"                               ,       //     23
    "XNS-IDP"                               ,       //     22
    "PRM"                                   ,       //     21
    "HMP"                                   ,       //     20
    "DCN-MEAS"                              ,       //     19
    "MUX"                                   ,       //     18
    "UDP"                                   ,       //     17
    "CHAOS"                                 ,       //     16
    "XNET"                                  ,       //     15
    "EMCON"                                 ,       //     14
    "ARGUS (deprecated)"                    ,       //     13
    "PUP"                                   ,       //     12
    "NVP-II"                                ,       //     11
    "BBN-RCC-MON"                           ,       //     10
    "IGP"                                   ,       //      9
    "EGP"                                   ,       //      8
    "CBT"                                   ,       //      7
    "TCP"                                   ,       //      6
    "ST"                                    ,       //      5
    "IPv4"                                  ,       //      4
    "GGP"                                   ,       //      3
    "IGMP"                                  ,       //      2
    "ICMP"                                  ,       //      1
    "HOPOPT"                                ,       //      0
{
osTextT* ppostProtocol[] =

//    
//    255,Reserved,,,[Internet_Assigned_Numbers_Authority]
//    254,,Use for experimentation and testing,Y,[RFC3692]
//    253,,Use for experimentation and testing,Y,[RFC3692]
//    148-252,,Unassigned,,[Internet_Assigned_Numbers_Authority]
//    147,BIT-EMU,Bit-stream Emulation,Y,[RFC9801]
//    146,Homa,Homa,N,[HomaModule][John_Ousterhout]
//    145,NSH,Network Service Header,N,[RFC9491]
//    144,AGGFRAG,AGGFRAG encapsulation payload for ESP,,[RFC9347]
//    143,Ethernet,Ethernet,,[RFC8986]
//    142,ROHC,Robust Header Compression,,[RFC5858]
//    141,WESP,Wrapped Encapsulating Security Payload,,[RFC5840]
//    140,Shim6,Shim6 Protocol,Y,[RFC5533]
//    139,HIP,Host Identity Protocol,Y,[RFC7401]
//    138,manet,MANET Protocols,,[RFC5498]
//    137,MPLS-in-IP,,,[RFC4023]
//    136,UDPLite,,,[RFC3828]
//    135,Mobility Header,,Y,[RFC6275]
//    134,RSVP-E2E-IGNORE,,,[RFC3175]
//    133,FC,Fibre Channel,,[Murali_Rajagopal][RFC6172]
//    132,SCTP,Stream Control Transmission Protocol,,[Randall_R_Stewart]
//    131,PIPE,Private IP Encapsulation within IP,,[Bernhard_Petri]
//    130,SPS,Secure Packet Shield,,[Bill_McIntosh]
//    129,IPLT,,,[[Hollbach]]
//    128,SSCOPMCE,,,[Kurt_Waber]
//    127,CRUDP,Combat Radio User Datagram,,[Robert_Sautter]
//    126,CRTP,Combat Radio Transport Protocol,,[Robert_Sautter]
//    125,FIRE,,,[Criag_Partridge]
//    124,ISIS over IPv4,,,[Tony_Przygienda]
//    123,PTP,Performance Transparency Protocol,,[Michael_Welzl]
//    122,SM (deprecated),Simple Multicast Protocol,,[Jon_Crowcroft][draft-perlman-simple-multicast-03]
//    121,SMP,Simple Message Protocol,,[Leif_Ekblad]
//    120,UTI,UTI,,[Peter_Lothberg]
//    119,SRP,SpectraLink Radio Protocol,,[Mark_Hamilton]
//    118,STP,Schedule Transfer Protocol,,[Jean_Michel_Pittet]
//    117,IATP,Interactive Agent Transfer Protocol,,[John_Murphy]
//    116,DDX,D-II Data Exchange (DDX),,[John_Worley]
//    115,L2TP,Layer Two Tunneling Protocol,,[RFC3931][Bernard_Aboba]
//    114,,any 0-hop protocol,,[Internet_Assigned_Numbers_Authority]
//    113,PGM,PGM Reliable Transport Protocol,,[Tony_Speakman]
//    112,VRRP,Virtual Router Redundancy Protocol,,[RFC9568]
//    111,IPX-in-IP,IPX in IP,,[CJ_Lee]
//    110,Compaq-Peer,Compaq Peer Protocol,,[Victor_Volpe]
//    109,SNP,Sitara Networks Protocol,,[Manickam_R_Sridhar]
//    108,IPComp,IP Payload Compression Protocol,,[RFC2393]
//    107,A/N,Active Networks,,[Bob_Braden]
//    106,QNX,QNX,,[Michael_Hunter]
//    105,SCPS,SCPS,,[Robert_Durst]
//    104,ARIS,ARIS,,[Nancy_Feldman]
//    103,PIM,Protocol Independent Multicast,,[RFC7761][Dino_Farinacci]
//    102,PNNI,PNNI over IP,,[Ross_Callon]
//    101,IFMP,Ipsilon Flow Management Protocol,,"[Bob_Hinden][November 1995, 1997.]"
//    100,GMTP,GMTP,,[[RXB5]]
//    99,,any private encryption scheme,,[Internet_Assigned_Numbers_Authority]
//    98,ENCAP,Encapsulation Header,,[RFC1241][Robert_Woodburn]
//    97,ETHERIP,Ethernet-within-IP Encapsulation,,[RFC3378]
//    96,SCC-SP,Semaphore Communications Sec. Pro.,,[Howard_Hart]
//    95,MICP (deprecated),Mobile Internetworking Control Pro.,,[John_Ioannidis]
//    94,IPIP,IP-within-IP Encapsulation Protocol,,[John_Ioannidis]
//    93,AX.25,AX.25 Frames,,[Brian_Kantor]
//    92,MTP,Multicast Transport Protocol,,[Susie_Armstrong]
//    91,LARP,Locus Address Resolution Protocol,,[Brian Horn]
//    University of California at Berkeley, June 1986.][Bruce Willins]"
//    Technical Report, UCB/Computer Science Dept., 86/302,
//    90,Sprite-RPC,Sprite RPC Protocol,,"[Welch, B., ""The Sprite Remote Procedure Call System"",
//    89,OSPFIGP,OSPFIGP,,[RFC1583][RFC2328][RFC5340][John_Moy]
//    88,EIGRP,EIGRP,,[RFC7868]
//    87,TCF,TCF,,[Guillermo_A_Loyola]
//    November 16, 1987.][Mike_Little]"
//    Specification, Draft Version"", Contract no. CS901145,
//    86,DGP,Dissimilar Gateway Protocol,,"[M/A-COM Government Systems, ""Dissimilar Gateway Protocol
//    85,NSFNET-IGP,NSFNET-IGP,,[Hans_Werner_Braun]
//    84,IPTM,Internet Protocol Traffic Manager,,[Jim_Stevens][1]
//    83,VINES,VINES,,[Brian Horn]
//    82,SECURE-VMTP,SECURE-VMTP,,[Dave_Cheriton]
//    81,VMTP,VMTP,,[Dave_Cheriton]
//    80,ISO-IP,ISO Internet Protocol,,[Marshall_T_Rose]
//    79,WB-EXPAK,WIDEBAND EXPAK,,[Steven_Blumenthal]
//    78,WB-MON,WIDEBAND Monitoring,,[Steven_Blumenthal]
//    77,SUN-ND,SUN ND PROTOCOL-Temporary,,[William_Melohn]
//    76,BR-SAT-MON,Backroom SATNET Monitoring,,[Steven_Blumenthal]
//    75,PVP,Packet Video Protocol,,[Steve_Casner]
//    74,WSN,Wang Span Network,,[Victor Dafoulas]
//    73,CPHB,Computer Protocol Heart Beat,,[David Mittnacht]
//    72,CPNX,Computer Protocol Network Executive,,[David Mittnacht]
//    71,IPCV,Internet Packet Core Utility,,[Steven_Blumenthal]
//    70,VISA,VISA Protocol,,[Gene_Tsudik]
//    69,SAT-MON,SATNET Monitoring,,[Steven_Blumenthal]
//    68,,any distributed file system,,[Internet_Assigned_Numbers_Authority]
//    67,IPPC,Internet Pluribus Packet Core,,[Steven_Blumenthal]
//    66,RVD,MIT Remote Virtual Disk Protocol,,[Michael_Greenwald]
//    65,KRYPTOLAN,Kryptolan,,[Paul Liu]
//    64,SAT-EXPAK,SATNET and Backroom EXPAK,,[Steven_Blumenthal]
//    63,,any local network,,[Internet_Assigned_Numbers_Authority]
//    Newman, January 1982.][Harry_Forsdick]"
//    62,CFTP,CFTP,,"[Forsdick, H., ""CFTP"", Network Message, Bolt Beranek and
//    61,,any host internal protocol,,[Internet_Assigned_Numbers_Authority]
//    60,IPv6-Opts,Destination Options for IPv6,Y,[RFC8200]
//    59,IPv6-NoNxt,No Next Header for IPv6,,[RFC8200]
//    58,IPv6-ICMP,ICMP for IPv6,,[RFC8200]
//    57,SKIP,SKIP,,[Tom_Markson]
//    using Kryptonet key management",,[Christer_Oberg]
//    56,TLSP,"Transport Layer Security Protocol        
//    55,Min-IPv4,Minimal IPv4 Encapsulation,,[RFC2004][Charlie_Perkins]
//    54,NARP,NBMA Address Resolution Protocol,,[RFC1735]
//    53,SWIPE (deprecated),IP with Encryption,,[John_Ioannidis]
//    52,I-NLSP,Integrated Net Layer Security  TUBA,,[K_Robert_Glenn]
//    51,AH,Authentication Header,Y,[RFC4302]
//    50,ESP,Encap Security Payload,Y,[RFC4303]
//    49,BNA,BNA,,[Gary Salamon]
//    48,DSR,Dynamic Source Routing Protocol,,[RFC4728]
//    47,GRE,Generic Routing Encapsulation,,[RFC2784][Tony_Li]
//    46,RSVP,Reservation Protocol,,[RFC2205][RFC3209][Bob_Braden]
//    45,IDRP,Inter-Domain Routing Protocol,,[Sue_Hares]
//    44,IPv6-Frag,Fragment Header for IPv6,Y,[Steve_Deering]
//    43,IPv6-Route,Routing Header for IPv6,Y,[Steve_Deering]
//    42,SDRP,Source Demand Routing Protocol,,[Deborah_Estrin]
//    41,IPv6,IPv6 encapsulation,,[RFC2473]
//    40,IL,IL Transport Protocol,,[Dave_Presotto]
//    39,TP++,TP++ Transport Protocol,,[Dirk_Fromhein]
//    38,IDPR-CMTP,IDPR Control Message Transport Proto,,[Martha_Steenstrup]
//    37,DDP,Datagram Delivery Protocol,,[Wesley_Craig]
//    36,XTP,XTP,,[Greg_Chesson]
//    35,IDPR,Inter-Domain Policy Routing Protocol,,[Martha_Steenstrup]
//    34,3PC,Third Party Connect Protocol,,[Stuart_A_Friedberg]
//    33,DCCP,Datagram Congestion Control Protocol,,[RFC4340]
//    32,MERIT-INP,MERIT Internodal Protocol,,[Hans_Werner_Braun]
//    Livermore, California, June 1977.][Barry_Howard]"
//    Computer Network"", UCRL-52317, Lawrence Livermore Labs,
//    31,MFE-NSP,MFE Network Services Protocol,,"[Shuttleworth, B., ""A Documentary of MFENet, a National
//    30,NETBLT,Bulk Data Transfer Protocol,,[RFC969][David_Clark]
//    29,ISO-TP4,ISO Transport Protocol Class 4,,[RFC905][Robert_Cole]
//    28,IRTP,Internet Reliable Transaction,,[RFC938][Trudy_Miller]
//    27,RDP,Reliable Data Protocol,,[RFC908][Bob_Hinden]
//    26,LEAF-2,Leaf-2,,[Barry_Boehm]
//    25,LEAF-1,Leaf-1,,[Barry_Boehm]
//    24,TRUNK-2,Trunk-2,,[Barry_Boehm]
//    23,TRUNK-1,Trunk-1,,[Barry_Boehm]
//    Xerox Corporation, Stamford, CT., October 1980.][[XEROX]]"
//    Layer and Physical Layer Specification"", X3T51/80-50,
//    And: XEROX, ""The Ethernet, A Local Area Network: Data Link
//    Specifications"", Digital, Intel and Xerox, November 1982.
//    Area Network: Data Link Layer and Physical Layer
//    Corporation, September 1980.  And: ""The Ethernet, A Local
//    Equipment Corporation, Intel Corporation, Xerox
//    Ethernet - A Local Area Network"", Version 1.0, Digital
//    Equipment Corporation, Maynard, MA.  Also as: ""The
//    Physical Layer Specification"", AA-K759B-TK, Digital
//    22,XNS-IDP,XEROX NS IDP,,"[""The Ethernet, A Local Area Network: Data Link Layer and
//    21,PRM,Packet Radio Measurement,,[Zaw_Sing_Su]
//    20,HMP,Host Monitoring,,[RFC869][Bob_Hinden]
//    19,DCN-MEAS,DCN Measurement Subsystems,,[David_Mills]
//    USC/Information Sciences Institute, May 1979.][Jon_Postel]"
//    18,MUX,Multiplexing,,"[Cohen, D. and J. Postel, ""Multiplexing Protocol"", IEN 90,
//    17,UDP,User Datagram,,[RFC768][Jon_Postel]
//    16,CHAOS,Chaos,,[J_Noel_Chiappa]
//    IEN 158, October 1980.][Jack_Haverty]"
//    15,XNET,Cross Net Debugger,,"[Haverty, J., ""XNET Formats for Internet Protocol Version 4"",
//    14,EMCON,EMCON,,[Bich_Nguyen]
//    13,ARGUS (deprecated),ARGUS,,[Robert_W_Scheifler]
//    Communication, Volume COM-28, Number 4, April 1980.][[XEROX]]"
//    CSL-79-10, July 1979; also in IEEE Transactions on
//    Internetwork Architecture"", XEROX Palo Alto Research Center,
//    12,PUP,PUP,,"[Boggs, D., J. Shoch, E. Taft, and R. Metcalfe, ""PUP: An
//    11,NVP-II,Network Voice Protocol,,[RFC741][Steve_Casner]
//    10,BBN-RCC-MON,BBN RCC Monitoring,,[Steve_Chipman]
//    (used by Cisco for their IGRP)",,[Internet_Assigned_Numbers_Authority]
//    9,IGP,"any private interior gateway             
//    8,EGP,Exterior Gateway Protocol,,[RFC888][David_Mills]
//    7,CBT,CBT,,[Tony_Ballardie]
//    6,TCP,Transmission Control,,[RFC9293]
//    5,ST,Stream,,[RFC1190][RFC1819]
//    4,IPv4,IPv4 encapsulation,,[RFC2003]
//    3,GGP,Gateway-to-Gateway,,[RFC823]
//    2,IGMP,Internet Group Management,,[RFC1112]
//    1,ICMP,Internet Control Message,,[RFC792]
//    0,HOPOPT,IPv6 Hop-by-Hop Option,Y,[RFC8200]
//    
//    Decimal,Keyword,Protocol,IPv6 Extension Header,Reference
//    
//    https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
//    ASSIGNED INTERNET PROTOCOL NUMBERS
//    

;
}
    }
        }
                                         pbRaw[ offMax - offs ] = save ;
                         pbRaw[ offs ] = pbRaw[ offMax - offs ]        ;
            byteT save = pbRaw[ offs ]                                 ;
        {
        for( countT offs = 0 ; offs < offStop ; offs ++ )
        byteT* pbRaw = (byteT*)pcTarget ;
        countT offStop = 1 + offMax >> 1 ;                  //        1   1   2   2   3   3   4   4
        countT offMax  = sizeof pcTarget - 1 ;              //        0   1   2   3   4   5   6   7
    {                                                       // CASES
    inline voidT swabF( voidT )                             // FOR EVEN NUMBER OF BYTES, EFFICIENT ; FOR ODD NUMBER OF BYTES, SWITCHES THE MIDDLE BYTE WITH ITSELF
    
    countT   pcTarget[ 4 ] ;
    count02T reserved      : 0x1d ;
    count02T bOverride     :    1 ;
    count02T bSolicited    :    1 ;
    count02T bRouter       :    1 ;
{
struct icmpv6Type136S : public icmpv6HeadRawS

;
}
    }
        }
                                         pbRaw[ offMax - offs ] = save ;
                         pbRaw[ offs ] = pbRaw[ offMax - offs ]        ;
            byteT save = pbRaw[ offs ]                                 ;
        {
        for( countT offs = 0 ; offs < offStop ; offs ++ )
        byteT* pbRaw = (byteT*)pcTarget ;
        countT offStop = 1 + offMax >> 1 ;                  //        1   1   2   2   3   3   4   4
        countT offMax  = sizeof pcTarget - 1 ;              //        0   1   2   3   4   5   6   7
    {                                                       // CASES
    inline voidT swabF( voidT )                             // FOR EVEN NUMBER OF BYTES, EFFICIENT ; FOR ODD NUMBER OF BYTES, SWITCHES THE MIDDLE BYTE WITH ITSELF
    
    countT   pcTarget[ 4 ] ;
    count02T reserved      ;
{
struct icmpv6Type135S : public icmpv6HeadRawS

;
}
    count01T checksum ;
    byteT    code     ;
    byteT    type     ;
{
struct icmpv6HeadRawS

//      
//            |                                                               |
//            +                         Message Body                          +
//            |                                                               |
//            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//            |     Type      |     Code      |          Checksum             |
//            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//             0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
//             0                   1                   2                   3
//      
//      ICMPv6 HEADER FORMAT    (RFC 4443)
//      

;
}
    }
        }
                                                 u.bytes.pbRaw[ offMax - offs ] = save ;
                         u.bytes.pbRaw[ offs ] = u.bytes.pbRaw[ offMax - offs ]        ;
            byteT save = u.bytes.pbRaw[ offs ]                                         ;
        {
        for( countT offs = 0 ; offs < offStop ; offs ++ )
        countT offStop = 1 + offMax >> 1 ;                  //        1   1   2   2   3   3   4   4
        countT offMax  = sizeof u.bytes.pbRaw - 1 ;         //        0   1   2   3   4   5   6   7
    {                                                       // CASES
    inline voidT swabF( voidT )                             // FOR EVEN NUMBER OF BYTES, EFFICIENT ; FOR ODD NUMBER OF BYTES, SWITCHES THE MIDDLE BYTE WITH ITSELF

    } u ;

        swabbed ;
        }

            count01T    idpSource            ;
            count01T    idpDestination       ;

            count01T    cbGross              ;
            count01T    checksum             ;

        {
        struct

        raw ;
        }

            count01T    checksum             ;
            count01T    cbGross              ;

            count01T    idpDestination       ;
            count01T    idpSource            ;

        {
        struct

        bytes ;
        }
            byteT pbRaw[ 0x4 * sizeof( count01T ) ] ;
        {
        struct
    {
    union
{
struct udpHeadRawS


//      
//      Format
//      ------
//      
//                                          
//                        0      7 8     15 16    23 24    31  
//                       +--------+--------+--------+--------+ 
//                       |     Source      |   Destination   | 
//                       |      Port       |      Port       | 
//                       +--------+--------+--------+--------+ 
//                       |                 |                 | 
//                       |     Length      |    Checksum     | 
//                       +--------+--------+--------+--------+ 
//                       |                                     
//                       |          data octets ...            
//                       +---------------- ...                 
//      
//                            User Datagram Header Format
//      
//      RFC 768
//      


;
}
    }
        }
                                                 u.bytes.pbRaw[ offMax - offs ] = save ;
                         u.bytes.pbRaw[ offs ] = u.bytes.pbRaw[ offMax - offs ]        ;
            byteT save = u.bytes.pbRaw[ offs ]                                         ;
        {
        for( countT offs = 0 ; offs < offStop ; offs ++ )
        countT offStop = 1 + offMax >> 1 ;                  //        1   1   2   2   3   3   4   4
        countT offMax  = sizeof u.bytes.pbRaw - 1 ;         //        0   1   2   3   4   5   6   7
    {                                                       // CASES
    inline voidT swabF( voidT )                             // FOR EVEN NUMBER OF BYTES, EFFICIENT ; FOR ODD NUMBER OF BYTES, SWITCHES THE MIDDLE BYTE WITH ITSELF

    } u ;

        swabbed ;
        }


            count01T    idpSource            ;
            count01T    idpDestination       ;

            countT      idSerial             ;

            countT      idSerialExpected     ;

            byteT       hCounts          : 4 ;
            byteT       reserved         : 4 ;
            byteT       bCWR             : 1 ;
            byteT       bECE             : 1 ;
            byteT       bURG             : 1 ;
            byteT       bACK             : 1 ;
            byteT       bPSH             : 1 ;
            byteT       bRST             : 1 ;
            byteT       bSYN             : 1 ;
            byteT       bFIN             : 1 ;
            count01T    cbWindow             ;

            count01T    checksum             ;
            count01T    offUrgent            ;

        {
        struct

        raw ;
        }

            count01T    offUrgent            ;
            count01T    checksum             ;

            count01T    cbWindow             ;
            byteT       bCWR             : 1 ;
            byteT       bECE             : 1 ;
            byteT       bURG             : 1 ;
            byteT       bACK             : 1 ;
            byteT       bPSH             : 1 ;
            byteT       bRST             : 1 ;
            byteT       bSYN             : 1 ;
            byteT       bFIN             : 1 ;
            byteT       hCounts          : 4 ;
            byteT       reserved         : 4 ;

            countT      idSerialExpected     ;

            countT      idSerial             ;

            count01T    idpDestination       ;
            count01T    idpSource            ;

        {
        struct

        bytes ;
        }
            byteT pbRaw[ 0x5 * sizeof( countT ) ] ;
        {
        struct
    {
    union
{
struct tcpHeadRawS

//  
//  
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     :                                                               |
//     :                             Data                              :
//     |                                                               :
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |                           [Options]                           |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |           Checksum            |         Urgent Pointer        |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |       |       |R|E|G|K|H|T|N|N|                               |
//     | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |
//     |  Data |       |C|E|U|A|P|R|S|F|                               |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |                    Acknowledgment Number                      |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |                        Sequence Number                        |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |          Source Port          |       Destination Port        |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
//      0                   1                   2                   3
//  
//  Figure 1: TCP Header Format
//  
//  RFC 9293
//  

;
}
    }
        }
                                                 u.bytes.pbRaw[ offMax - offs ] = save ;
                         u.bytes.pbRaw[ offs ] = u.bytes.pbRaw[ offMax - offs ]        ;
            byteT save = u.bytes.pbRaw[ offs ]                                         ;
        {
        for( countT offs = 0 ; offs < offStop ; offs ++ )
        countT offStop = 1 + offMax >> 1 ;                  //        1   1   2   2   3   3   4   4
        countT offMax  = sizeof u.bytes.pbRaw - 1 ;         //        0   1   2   3   4   5   6   7
    {                                                       // CASES
    inline voidT swabF( voidT )                             // FOR EVEN NUMBER OF BYTES, EFFICIENT ; FOR ODD NUMBER OF BYTES, SWITCHES THE MIDDLE BYTE WITH ITSELF

    } u ;

        swabbed ;
        }

            countT      version      : 0x04 ;
            countT      pad1         : 0x04 ;
            countT      pad2         : 0x18 ;

            count01T    cbGramNet                ;
            byteT       idNextHeader          ;
            byteT       hopLimit              ;

            countT      pcSource[ 4 ]         ;

            countT      pcDestination[ 4 ]    ;

        {
        struct

        raw ;
        }

            countT      pcDestination[ 4 ]    ;

            countT      pcSource[ 4 ]         ;

            byteT       hopLimit              ;
            byteT       idNextHeader          ;
            count01T    cbGramNet                ;

            countT      pad2         : 0x18 ;
            countT      version      : 0x04 ;
            countT      pad1         : 0x04 ;

        {
        struct

        //counts ;
        //}
        //    countT pcRaw[ 0xa ] ;
        //{
        //struct
        
        bytes ;
        }
            byteT pbRaw[ 0xa * sizeof( countT ) ] ;
        {
        struct
        
        //nibs ;
        //}
        //    byteT  nibf : 4 ;
        //    byteT  nibe : 4 ;
        //    byteT  nibd : 4 ;
        //    byteT  nibc : 4 ;
        //    byteT  nibb : 4 ;
        //    byteT  niba : 4 ;
        //    byteT  nib9 : 4 ;
        //    byteT  nib8 : 4 ;
        //    byteT  nib7 : 4 ;
        //    byteT  nib6 : 4 ;
        //    byteT  nib5 : 4 ;
        //    byteT  nib4 : 4 ;
        //    byteT  nib3 : 4 ;
        //    byteT  nib2 : 4 ;
        //    byteT  nib1 : 4 ;
        //    byteT  nib0 : 4 ;
        //{
        //struct
    {
    union
{
struct ipv6HeadRawS

//    
//       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//       |                                                               |
//       +                                                               +
//       |                                                               |
//       +                      Destination Address                      +
//       |                                                               |
//       +                                                               +
//       |                                                               |
//       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//       |                                                               |
//       +                                                               +
//       |                                                               |
//       +                         Source Address                        +
//       |                                                               |
//       +                                                               +
//       |                                                               |
//       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//       |         Payload Length        |  Next Header  |   Hop Limit   |
//       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//       |Version| Traffic Class |           Flow Label                  |
//       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//    
//        RFC 8200
//    

;
}
    }
        }
                                                 u.bytes.pbRaw[ offMax - offs ] = save ;
                         u.bytes.pbRaw[ offs ] = u.bytes.pbRaw[ offMax - offs ]        ;
            byteT save = u.bytes.pbRaw[ offs ]                                         ;
        {
        for( countT offs = 0 ; offs < offStop ; offs ++ )
        countT offStop = 1 + offMax >> 1 ;                  //        1   1   2   2   3   3   4   4
        countT offMax  = sizeof u.bytes.pbRaw - 1 ;         //        0   1   2   3   4   5   6   7
    {                                                       // CASES
    inline voidT swabF( voidT )                             // FOR EVEN NUMBER OF BYTES, EFFICIENT ; FOR ODD NUMBER OF BYTES, SWITCHES THE MIDDLE BYTE WITH ITSELF

    } u ;

        swabbed ;
        }

            byteT       version : 4       ;
            byteT       hCounts : 4       ;
            byteT       service           ;
            count01T    cbGramNet            ;

            count01T    identification    ;
            count01T    pad1              ;

            byteT       ttl               ;
            byteT       protocol          ;
            count01T    hChecksum         ;

            countT      ipv4Source        ;

            countT      ipv4Destination   ;

        {
        struct

        raw ;
        }

            countT      ipv4Destination   ;

            countT      ipv4Source        ;

            count01T    hChecksum         ;
            byteT       protocol          ;
            byteT       ttl               ;

            count01T    pad1              ;
            count01T    identification    ;

            count01T    cbGramNet            ;
            byteT       service           ;
            byteT       version : 4       ;
            byteT       hCounts : 4       ;

        {
        struct

        bytes ;
        }
            byteT pbRaw[ 5 * sizeof( countT ) ] ;
        {
        struct
    {
    union
{
struct ipv4HeadRawS

//
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   |                    Options                    |    Padding    |
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   |                    Destination Address                        |
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   |                       Source Address                          |
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   |  Time to Live |    Protocol   |         Header Checksum       |
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   |         Identification        |Flags|      Fragment Offset    |
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   |Version|  IHL  |Type of Service|          Total Length         |
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
//    0                   1                   2                   3
//
//                    Example Internet Datagram Header
//
//    RFC 6274
//

;
}
    countT      protocol ;
{
struct loopHeadS

//      
//          23 - payload is an IPX packet.
//          7 - payload is an OSI packet;
//          30 - payload is an IPv6 packet;         0x1e
//          28 - payload is an IPv6 packet;         0x1c
//          24 - payload is an IPv6 packet;         0x18
//          2 - payload is an IPv4 packet;
//      
//      The protocol type field is in the host byte order of the machine on which the capture was done. The values for that field are:
//      
//      Description
//      
//      .                           .
//      .                           .
//      .                           .
//      |           Payload         |
//      +---------------------------+
//      |         (4 Octets)        |
//      |       Protocol type       |
//      +---------------------------+
//      
//      https://www.tcpdump.org/linktypes/LINKTYPE_NULL.html
//      

#define CpACKETSiNbATCH ( TUCK << 2 )

#include <iphlpapi.h>

// LIKE 8e0_ BUT SPECIALIZED TO DETECT FLOOD ATTACKS ON ROUTES TO web1
//OBSOLETES: 8e0_
//OBSOLETED BY: 8e2_

/*1*/WAKEhIDE( "ifcIDaDAM_IDEAnETgEIGERcOUNTER" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
