
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

VERYsMARTpOINTERfUNCTIONdEFS( listing   , listingC , 0   , 01 , sizeof( listingC ) , 1 , 8  )







    }
        return (byteT*)P(pv) ;
        }
            }
                if( pCBF ) (*pCBF)( tinBaseP , (byteT*)this , ifcIDeVENTvsp_WrEFcT , cRefWriteOld , cRefF() , cArg ) ;
                count01T cRefWriteOld = incv01AM( cRefWrite ) ;
                count01T& cRefWrite = *(count01T*)&( (byteT*)&((count02T*)P(pv))[ - 2 ] )[ 2 ] ;
                flags |= flVSP_NONCONSTANTrEFdISPENSED ;
            {
            if( !( F(flags) & flVSP_NONCONSTANTrEFdISPENSED ) )
            /*if( !thirdC::bCanAccessMemoryIF( (byteT*)P(pv) , 1 ) ) { BLAMMO ; }*/
            if( !( F(((tinFullS&)tinBaseP).flagsThreadMode4) & flTHREADmODE4_ALLOWwRITEABLEpOINTERgET ) ) { BLAMMO ; }
            TINSL
        {
        if( P(pv) )
    {
    blobVSP::operator byteT*( voidT )

    }
        return (const byteT*)P(pv) ;
        }
            /*if( !thirdC::bCanAccessMemoryIF( (byteT*)P(pv) , 1 ) ) { BLAMMO ; }*/
            /*TINSL*/
        {
        /*if( P(pv) )*/
    {
    blobVSP::operator const byteT*( voidT ) const    /*20240822@1620: ADDED THIS OPERATOR W/O ANALYSIS*/

    }
        }
            }
                if( pCBF ) (*pCBF)( thirdC::third_tinBaseS_ref_IF() , (byteT*)this , ifcIDeVENTvsp_WrEFdT , cRefWriteOld , cRefF() , cArg ) ;
                count01T  cRefWriteOld = decv01AM( cRefWrite ) ;
                count01T& cRefWrite = *(count01T*)&( (byteT*)&((count02T*)P(pv))[ - 2 ] )[ 2 ] ;
                flags &= ~F(flVSP_NONCONSTANTrEFdISPENSED) ;
            {
            if( F(flags) & flVSP_NONCONSTANTrEFdISPENSED )
            /*if( !thirdC::bCanAccessMemoryIF( (byteT*)P(pv) , 1 ) ) { BLAMMO ; }*/
        {
        if( P(pv) )
    {
    voidT blobVSP::gaspDispensedF( voidT )

    NEWdELcLASSb( blobVSP )

    blobVSP& blobVSP::operator =( const blobSP&   spP ) { if( F(flags) & flVSP_LOCKED && (const byteT*)spP  ) { BLAMMO ; } gaspDispensedF() ; gaspF() ; pv = (byteT*)PyES( spP.pv  ) ;                                       cryF() ; return *this ; }
    blobVSP& blobVSP::operator =( const blobVSP& vspP ) { if( F(flags) & flVSP_LOCKED && (const byteT*)vspP ) { BLAMMO ; } gaspDispensedF() ; gaspF() ; pv = (byteT*)PyES( vspP.pv ) ; pCBF = vspP.pCBF ; cArg = vspP.cArg ; cryF() ; return *this ; }
    blobVSP& blobVSP::operator =( byteT* pvP               ) { if( F(flags) & flVSP_LOCKED && pvP                 ) { BLAMMO ; } gaspDispensedF() ; gaspF() ; pv = (byteT*)PyES( pvP     ) ;                                       cryF() ; return *this ; }

    { cryF() ; }
    flags( flagsP )
    cArg( cArgP ) ,
    pCBF( pCBFP ) ,
    blobSP( (byteT*)PyES( pvP ) ) ,
    blobVSP::blobVSP( byteT* pvP , vspCBFT pCBFP , countT cArgP , flagsT flagsP ) :

    { cryF() ; }
    flags( F(flagsP) ? flagsP : vspP.flags & ~( F(flVSP_NONCONSTANTrEFdISPENSED) ) )
    cArg(  pCBFP || cArgP ? cArgP : vspP.cArg ) ,
    pCBF( pCBFP ? pCBFP : vspP.pCBF ) ,
    blobSP( (byteT*)PyES( vspP.pv ) ) ,
    blobVSP::blobVSP( const blobVSP& vspP , vspCBFT pCBFP , countT cArgP , flagsT flagsP ) :

    { cryF() ; }
    flags( flagsP )
    cArg( cArgP ) ,
    pCBF( pCBFP ) ,
    blobSP( (byteT*)PyES( spP.pv  ) ) ,
    blobVSP::blobVSP( const blobSP& spP , vspCBFT pCBFP , countT cArgP , flagsT flagsP ) :

    blobVSP::~blobVSP( voidT ) { gaspDispensedF() ; gaspF() ; }

    SMARTpOINTERfUNCTIONdEFS( blob , byteT , - 2 , 02 , 1 )

//#define VERYsMARTpOINTERfUNCTIONdEFS(blob,byteT,- 2,02,1,2,01)

//U::VERYsMARTpOINTERfUNCTIONdEFS( blob      , byteT    , - 2 , 02 , 1                  , 2 , 01 )




VERYsMARTpOINTERfUNCTIONdEFS( countStrz , countT   , - 2 , 02 , sizeof( countT   ) , 2 , 01 )
VERYsMARTpOINTERfUNCTIONdEFS( count     , countT   , - 1 , 02 , sizeof( countT   ) , 2 , 01 )

// SMARTpOINTERfUNCTIONdEFS SHOULD ALSO GO HERE (NOT NEEDED FOR SP THAT CORRESPONDS TO EACH OF THE ABOVE VSP)

// THIS FILE IS NONCONFORMANT:  EACH OF THE ABOVE WOULD NORMALLY BE IN A SEPARATE FILE

/*1*//*VERYsMARTpOINTERfUNCTIONdEFS, SMARTpOINTERfUNCTIONdEFS*//*1*/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

