
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    ++ s ; ether.osSleepF( tin0P , TOCK ) ;

    pcap_freealldevs( pInfo ) ; pInfo = 0 ;

    }
        pCursor = pCursor->next ;

        }
            }
                pcap_free_datalinks( pInfo2 ) ;

                }
                    }
                        }
                            }
                                }
                                    etThread.traceF( tin0P , T("[idPacket,dest,source]:    ")+TF3(++idPacket,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+T(nnDest)+tb4+T(nnSource) ) ;
                                    nicNameC nnSource( SWAB4( ipSource ) ) ;
                                    nicNameC nnDest(   SWAB4( ipDest   ) ) ;

                                    //etThread.traceF( tin0P , T("[dest,source]:    ")+TF2(ipDest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ipSource,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    countT ipSource = *(countT*)pbc ; pbc += 4 ;
                                    countT ipDest   = *(countT*)pbc ; pbc += 4 ;
                                    pbc += 3 * sizeof( countT ) ;
                                {
                                if( rc == 1 && idType == 8 )

                                //else          etThread.traceF( tin0P , T("oops") ) ;
                                //if( rc == 1 ) etThread.traceF( tin0P , T("[type]:    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                count01T idType         = *(count01T*)pbc ; pbc += 2 ;
                                byteT* pbMACSource      =             pbc ; pbc += 6 ;
                                byteT* pbMACDestination =             pbc ; pbc += 6 ;

                                byteT* pbc = (byteT*)pInfo3Data ;

                                rc = pcap_next_ex( pHandle , &pInfo3Header , &pInfo3Data ) ;
                                ZE( const u_char* , pInfo3Data   ) ;
                                ZE( pcap_pkthdr*  , pInfo3Header ) ;
                            {
                            while( !ether )
                            etThread.traceF( tin0P , T("receiving header/data images") ) ;
                        {
                        if( !rc )

                        rc = pcap_set_datalink( pHandle , 1 ) ;
                    {
                    if( bOk )

                    }

                        if( pInfo2[ offa ] == 1 )  bOk = 1 ;
                        etThread.traceF( tin0P , T("link layer header type:    ")+TF2(pInfo2[offa],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    for( countT offa = 0 ; offa < rc ; offa ++ )
                    ZE( boolT , bOk ) ;
                {
                if( rc )

                rc = pcap_list_datalinks( pHandle , &pInfo2 ) ;

                ZE( int* , pInfo2 ) ;
            {
            if( !rc )
            rc = pcap_activate( pHandle ) ;

            etThread.traceF( tin0P , T(pHandle?"aok":"nope") ) ;
            pcap_t* pHandle = pcap_create( pCursor->name , postError ) ;

            etThread.traceF( tin0P , T("name:           ")+T(pCursor->name) ) ;
        {
        if( !etThread.strCompareF( tin0P , T(pCursor->description) , tWant ) )
        etThread.traceF( tin0P , T("wanted     :    ")+tWant                   ) ;
        etThread.traceF( tin0P , T("description:    ")+T(pCursor->description) ) ;
        etThread.traceF( tin0P , T("idDevice:       ")+TF2(++idDevice,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( pCursor )
    ZE( countT , idDevice ) ;
    pcap_if_t* pCursor = pInfo ;

    rc = pcap_findalldevs( &pInfo , postError ) ;
static    int rc ;
    pcap_if_t* pInfo ;

    //thirdC::c_systemIF( tin0P , "cls" ) ;
{
while( !ether )
sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
ZE( countT , idPacket ) ;

char postError[ PCAP_ERRBUF_SIZE ] ;

etThread.traceF( tin0P , T(postv) ) ;
const osTextT* postv = pcap_lib_version() ;

TN( tWant , "ASIX USB to Gigabit Ethernet Family Adapter" ) ;
TN( tb4 , "    " ) ;

TODO

// TO COMPILE ME, YOU MUST ENABLE THE npcap LINE IN osLinkF         WARNING:  THIS ****MUST NOT**** BE DONE IN PRODUCTION

#include <D:\npcap-sdk-1.15\include.smudged\pcap\pcap.h>

/*1*/WAKEhIDE( "doodle.simple.npcap.packet.sniffer" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
