
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etThread.strokeF( tin0P , T("ok\r\n") ) ;
    writeTimeNowTableF( tin0P , etThread ) ;
    writeValidFlagsTableF( tin0P , etThread , swValidFlags , idGroupFlags ) ;

    etThread.delF( tin0P , postx ) ;

    etThread.boxPutF( tin0P , tFileOut2d , postSplitAt , costx - cost1 ) ;
    etThread.boxPutF( tin0P , tFileOut2c , postSplitAt , costx - cost1 ) ;
    etThread.boxPutF( tin0P , tFileOut2b , postSplitAt , costx - cost1 ) ;
    etThread.boxPutF( tin0P , tFileOut2a , postSplitAt , costx - cost1 ) ;
    //etThread.boxPutF( tin0P , tFileOut2  , postSplitAt , costx - cost1 ) ;

    etThread.boxPutF( tin0P , tFileOut1d , postx , cost1 ) ;
    etThread.boxPutF( tin0P , tFileOut1c , postx , cost1 ) ;
    etThread.boxPutF( tin0P , tFileOut1b , postx , cost1 ) ;
    etThread.boxPutF( tin0P , tFileOut1a , postx , cost1 ) ;
    //etThread.boxPutF( tin0P , tFileOut1  , postx , cost1 ) ;

    countT cost1 = postSplitAt - postx ;

    postSplitAt += 5 ;
    if( !postSplitAt ) { BLAMMO ; }
    osTextT* postSplitAt = thirdC::c_strstrIF( tin0P , postx + costx / 2 , "END\r\n//SOURCE:" ) ; // SPLIT THE IMAGE INTO OO IMAGES TO AVOID CAUSING COMPILER (wpp386) TO CRAP AND DIE

    TN( tFileOut2d , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.adam.hide.third.2.h" ) ;
    TN( tFileOut2c , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.adam.show.third.2.h" ) ;
    TN( tFileOut2b , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.base.hide.third.2.h" ) ;
    TN( tFileOut2a , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.base.show.third.2.h" ) ;

    TN( tFileOut1d , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.adam.hide.third.1.h" ) ;
    TN( tFileOut1c , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.adam.show.third.1.h" ) ;
    TN( tFileOut1b , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.base.hide.third.1.h" ) ;
    TN( tFileOut1a , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.base.show.third.1.h" ) ;

    // ALL FI FILES IN EACH OF THE OO SETS MUST REMAIN IDENTICAL ; ANY MANUAL MODIFICATIONS TO ipdos.h MUST BE PROPOGATED TO THESE FO FILES BY COPYING AND SPLITTING ipdos.h
    // THESE FILES ARE IDENTICAL COPIES OF tFileOut.  IT IS A KLUDGE THAT IS DONE SO THAT PRECOMPILED HEADERS CAN BE FULLY EXPLOITED TO SPEED UP BUILDS

    //TN( tFileOut2 , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.2.h" ) ;
    //TN( tFileOut1 , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.1.h" ) ;

    etThread.boxPutF( tin0P , tFileOutAll , postx , costx ) ;
    TN( tFileOutAll , "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.h" ) ;

    // 
    // SUMMARY: THE FILE ipdos.h ONLY EXISTS FOR USE WITH THE hc.bat BATCH FILE TO PROPOGATE HEADER CHANGES DURING CRAFTWORK, I.E. BETWEEN "DOaLL" BUILDS
    // 
    // DURING STEP 7, THE FILE ipdos.h WILL BE OVERWRITTEN BY ADAM ifcIDaDAM_HEADER.  (THE MANUAL EDITS ARE NO LONGER NEEDED.)
    //
    // 7. Elves IS BUILT AND RUN (e.bat)
    // 6. THE ephemeral\domains DIRECTORY IS DELETED
    // 5. THE "#define DOaLL" LINE IN ADAM 621 IS ENABLED
    // 4. OTHER CODE IS EDITED TO USE THAT NEW SYMBOLIC CONSTANT
    // 3. THE hc.bat BATCH FILE IS RUN, TO PROPOGATE THE ipdos.h IMAGE TO THE FILES THAT ARE ACTUALLY INCLUDED BY THE SOURCE CODE
    // 2. A COPY OF THE #define LINE IS PASTED AT THE TOP (ANYWHERE, BUT THE TOP IS EASIEST) OF FILE ipdos.h
    // 1. THE CODE CRAFTSMAN CREATES A NEW DICTIONARY FILE CONTAINING THE #define LINE
    // 
    // EXAMPLE SCENARIO:  DURING CODE CRAFTWORK, A NEW SYMBOLIC CONSTANT IS NEEDED
    // 
    // FILE ipdos.h EXISTS FOR THE CONVENIENCE OF HUMAN EDITORS
    // THE SOURCE CODE DOES NOT REFER TO, OR INCLUDE, ipdos.h
    // 
    // USAGE NOTES

    etThread.delF( tin0P , pstto ) ;
    countT costx = etThread.strMakeF( tin0P , LF , postx , pstto ) ; ___( postx ) ;
    ZE( osTextT* , postx ) ;

    __( idLath > 0xdfffffff ) ;
    etThread.strokeF( tin0P , TF2(idf,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
    }
        etThread.delF( tin0P , psttw ) ;
        }
            }
                break ;
                __1
                __( idsTag ) ;
            {
            default :
            //}
            //    break ;
            //    etThread.strFuseF( tin0P , pstto , T("0x")+TF3(idLath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            //    etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
            //    bNewGroup = 0 ;
            //    __Z( bIn3block ) ;
            //{
            //case  :
            //}
            //    break ;
            //    etThread.strFuseF( tin0P , pstto , T("0x")+TF3(idLath+1,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
            //    etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
            //    bNewGroup = 0 ;
            //    __Z( bIn3block ) ;
            //{
            //case  :
            //}
            //    break ;
            //    etThread.strFuseF( tin0P , pstto , T("0x")+TF3(++idbLast,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,2) ) ; ___( pstto ) ;
            //    etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
            //    bNewGroup = 0 ;
            //    __Z( bIn3block ) ;
            //{
            //case  :
            }
                break ;
                groupLath = idbLath ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(idbLath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ idbLath ;
                }
                    groupWoth = ++idbLath ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 0x11 :
            }
                break ;
                groupLath = idaLath ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(idaLath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ idaLath ;
                }
                    groupWoth = ++idaLath ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 0x10 :
            }
                break ;
                etThread.delF( tin0P , psttLathWord ) ;
                }
                    etThread.strFuseF( tin0P , pstto , tLeft+T("_max     0x")+TF3(idr01Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                    TN( tLeft , "\r\n#define " ) ; tLeft += T(psttLathWord) ;
                {
                if( psttLathWord && psttLathWord->idAdam )

                idr01Lath += 0x10 - 1 ; //THIS RESERVES THE REMAINING f VALUES
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(++idr01Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;

                etThread.strWordF( tin0P , psttLathWord , psttw , sttq , S1C(' ') , - 2 ) ; ___( psttLathWord ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttLathWord ) ;

                __NZ( bIn3block ) ;
            {
            case 0xf :
            }
                break ;
                groupLath = id9Lath ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(id9Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ id9Lath ;
                }
                    groupWoth = ++id9Lath ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 0xe :
            }
                break ;
                groupLath = id8Lath ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(id8Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ id8Lath ;
                }
                    groupWoth = ++id8Lath ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 0xd :
            }
                break ;
                groupLath = id7Lath ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(id7Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ id7Lath ;
                }
                    groupWoth = ++id7Lath ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 0xc :
            }
                break ;
                groupLath = id5Lath ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(id6Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ id6Lath ;
                }
                    groupWoth = ++id6Lath ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 0xb :
            }
                break ;
                groupLath = id5Lath ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(id5Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ id5Lath ;
                }
                    groupWoth = ++id5Lath ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 0xa :
            }
                break ;
                groupLath = id4Lath ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(id4Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ id4Lath ;
                }
                    groupWoth = ++id4Lath ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 9 :
            }
                break ;
                groupLath = id3Lath ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(id3Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ id3Lath ;
                }
                    groupWoth = ++id3Lath ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 8 :
            }
                break ;
                groupLath = id2Lath ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(id2Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ id2Lath ;
                }
                    groupWoth = ++id2Lath ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 7 :
            }
                break ;
                groupLath = id1Lath ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(id1Lath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ id1Lath ;
                }
                    groupWoth = ++id1Lath ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 6 :
            }
                break ;
                groupLath = idwmLast ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(idwmLast,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ idwmLast ;
                }
                    groupWoth = ++idwmLast ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 5 :
            }
                break ;
                groupLath = fiLast ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(fiLast,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ fiLast ;
                }
                    groupWoth = ++fiLast ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                __Z( bIn3block ) ;
            {
            case 4 :
            }
                break ;
                flNext <<= 1 ;
                (countT&)swValidFlags |= vv ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(vv,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;

                //LOGrAW3( "[vv]          :    " , vv                             , "\r\n" ) ; //U:: TO FIND A BUG
                //LOGrAW3( "[markFlags]   :    " , markFlags                      , "\r\n" ) ; //U:: TO FIND A BUG
                //LOGrAW3( "[flNext]      :    " , flNext                         , "\r\n" ) ; //U:: TO FIND A BUG
                //LOGrAW3( "[cFlavors]    :    " , swValidFlags.cFlavorsF( tin0P ) , "\r\n" ) ; //U:: TO FIND A BUG
                //LOGrAW3( "[idGroupFlags]:    " , idGroupFlags                   , "\r\n" ) ; //U:: TO FIND A BUG

                flagsT vv = flNext | markFlags ;
                __( !( F(flNext) ) ) ;

                }
                    flNext = 1 << offbFlags ;

                    markFlags = idGroupFlags | 0xe << offbIdType ;

                    if( !idGroupFlags ) idGroupFlags ++ ;
                    idGroupFlags &= 0xff ;
                    //20141121@1005: DISABLED THIS BECAUSE NOW HAVE MORE THAN A TUCK OF FLAGS GROUPS: __( idGroupFlags > 0xff ) ; //THIS CAN BE REMOVED IF HAVE MORE THAN ff GROUPS.  THEN THE idGroup VALUES WILL NOT BE UNIQUE. THEY WILL STILL SERVE TO HELP DETECT CODING ERRORS
                    idGroupFlags ++ ;

                    b_fl = 1 ;

                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )

                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;

                __Z( bIn3block ) ;

                //}
                //    etThread.delF( tin0P , posto ) ;
                //    etThread.boxPutF( tin0P , T("///d/tmp/goo.ttt") , posto , costo ) ;
                //    costo = etThread.strMakeF( tin0P , LF , posto , psttw ) ; ___( posto ) ;
                //
                //    etThread.delF( tin0P , posto ) ;
                //    etThread.boxPutF( tin0P , T("///d/tmp/foo.ttt") , posto , costo ) ;
                //    countT costo = etThread.strMakeF( tin0P , LF , posto , pstto ) ; ___( posto ) ;
                //    ZE( osTextT* , posto ) ;
                //{
                //if( !bIn3block ) //U:: TO FIND A BUG
            {
            case 3 :
            }
                break ;
                groupLath = idLath ;
                etThread.strFuseF( tin0P , pstto , T("0x")+TF3(idLath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
                else ++ idLath ;
                }
                    groupWoth = ++idLath ;
                    prefixF( tin0P , etThread , psttGroup , psttw ) ; ___( psttGroup ) ;
                    bNewGroup = 0 ;
                {
                if( bNewGroup )
                }
                    __Z( bIn3block ) ;
                    etThread.strokeF( tin0P , T("ERROR: NOT DELIMITED BY \"/*3*/\": \"\r\n")+T(psttw)+T("\r\n\"\r\n") ) ;
                {
                if( !bIn3block )
            {
            case 2 :
            }
                break ;
                }
                        etThread.delF( tin0P , psttGroup ) ;
                        b_fl = 0 ;
                        bNewGroup = 0 ;
                {
                else
                if( bIn3block ) bNewGroup = 1 ;

                }
                    etThread.strFuseF( tin0P , pstto , tLeft+T("_min     0x")+TF3(groupWoth,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tLeft+T("_max     0x")+TF3(groupLath,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ;
                    TN( tLeft , "\r\n#define " ) ; tLeft += T(psttGroup) ;
                {
                else if( !bIn3block && psttGroup && psttGroup->idAdam )
                if( b_fl ) { etThread.strFuseF( tin0P , pstto , T("\r\n#define ")+T(psttGroup)+T("_null    0x")+TF3(markFlags,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( pstto ) ; }
                bIn3block = !bIn3block ;
                etThread.strFuseF( tin0P , pstto , t3 ) ; ___( pstto ) ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
            {
            case 1 :
            }
                break ;
                etThread.strFuseF( tin0P , pstto , psttw ) ; ___( pstto ) ;
            {
            case 0 :
        {
        switch( idsTag )

        etThread.strSubstringF( tin0P , psttw , idf , sttq , stTag , idsTag , tIn ) ; ___( psttw ) ;
        idsTag = 0 ;
        ZE( strokeS* , psttw ) ;
        if( !( idf % TUCK ) ) etThread.strokeF( tin0P , TF2(idf,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r") ) ;
    {
    while( !ether && !etThread && idf )
    switchC swValidFlags( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idGroupFlags ) ;
    ZE( boolT , b_fl ) ;
    ZE( strokeS* , psttGroup ) ;
    etThread.strokeF( tin0P , T("editing (cursor position)\r\n") ) ;
    ZE( countT , groupLath ) ;
    ZE( countT , groupWoth ) ;
    ZE( flagsT , markFlags ) ;
    ZE( boolT , bNewGroup ) ;
    ZE( countT , idGroupFlags ) ;
    ZE( boolT , bIn3block ) ;
    ZE( countT , flNext ) ;
    ZE( countT , idbLast ) ;
    countT idwmLast = 0x000003ff ; //ASSUME: WM_USER == 0x400 FOR ALL OPERATING SYSTEMS SUPPORTED
    countT fiLast   = 0xcccc0000 ; // THE HIGH ORDER "cccc" INDICATES FINGERPRINT
    //OLD: countT fiLast   = 0xc1a732b8 ; // THE HIGH ORDER "c" INDICATES FINGERPRINT; THE REMAINING NIBBLES ARE INTENDED TO BE UNLIKELY TO OCCUR IN DATA
    countT idbLath   = 0xdddd4000 ; // ifcIDmODEaCCOUNT
    countT idaLath   = 0xdddd5000 ; // LISTnAMEsYSaDAM
    countT idr01Lath = 0xdddd6000 ; // ID'S FOR RESERVED BLOCKS (TAGS OF FORM /*idr.01*/
    countT id9Lath   = 0xdddd7000 ; // LISTnAMEsYS
    countT id8Lath   = 0xdddd8000 ; // ID'S FOR ifcIDtYPEsOULiTEM ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
    countT id7Lath   = 0xdddd9000 ; // ID'S FOR ifcIDtYPEdISPLAY ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
    countT id6Lath   = 0xdddda000 ; // ID'S FOR ifcIDtYPEtREEwALKcb ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
    countT id5Lath   = 0xddddb000 ; // ID'S FOR ifcIDcMDsPOUSE_PILLnAME ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
    countT id4Lath   = 0xddddc000 ; // ID'S FOR ifcOLDiDtYPEwRAP ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
    countT id3Lath   = 0xddddd000 ; // ID'S FOR ifcIDpROTOCOL ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
    countT id2Lath   = 0xdddde000 ; // ID'S FOR strokeC IDaDAM ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE
    countT id1Lath   = 0xddddf000 ; // ID'S FOR strokeC CASTE ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE

    //0xdddd0000: TWEAK idLath INITIAL VALUE TO VERIFY PERSISTENT STORES (E.G. KT FILES) AREN'T BROKEN
    countT idLath   = 0xdddd0000 ; // ID'S ARE KEPT SIMPLE SO THAT THEY CAN BE EASILY RECOGNIZED BY THE HUMAN EYE

    //sttq = ze ;
    idf = 1 ;

    ) , tIn.csF( tin0P ) + csTags ) ; ___( pstto ) ;

        "\r\n"

    #endif

        "#define SIZEOF_windowOldC       0x")+TF2(sizeof( windowOldC       ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_switchStackC     0x")+TF2(sizeof( switchStackC     ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_switchC          0x")+TF2(sizeof( switchC          ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_stackC           0x")+TF2(sizeof( stackC           ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_soulC            0x")+TF2(sizeof( soulC            ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_sexC             0x")+TF2(sizeof( sexC             ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_rootWordC        0x")+TF2(sizeof( rootWordC        ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_renderStateOldS  0x")+TF2(sizeof( renderStateOldS  ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_pulpOldC         0x")+TF2(sizeof( pulpOldC         ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_poolC            0x")+TF2(sizeof( poolC            ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_napkinC          0x")+TF2(sizeof( napkinC          ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_lexC             0x")+TF2(sizeof( lexC             ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_handleC          0x")+TF2(sizeof( handleC          ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_grabMemorySpaceC 0x")+TF2(sizeof( grabMemorySpaceC ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_fileC            0x")+TF2(sizeof( fileC            ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_etherC           0x")+TF2(sizeof( etherC           ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_bookC            0x")+TF2(sizeof( bookC            ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_batonC           0x")+TF2(sizeof( batonC           ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"
        "#define SIZEOF_baseSoilXxxxC    0x")+TF2(sizeof( baseSoilXxxxC    ),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T("\r\n"

    #else

        "#define SIZEOF_windowOldC       ( sizeof( windowOldC          ) )\r\n"
        "#define SIZEOF_switchStackC     ( sizeof( switchStackC        ) )\r\n"
        "#define SIZEOF_switchC          ( sizeof( switchC             ) )\r\n"
        "#define SIZEOF_stackC           ( sizeof( stackC              ) )\r\n"
        "#define SIZEOF_soulC            ( sizeof( soulC               ) )\r\n"
        "#define SIZEOF_sexC             ( sizeof( sexC                ) )\r\n"
        "#define SIZEOF_rootWordC        ( sizeof( rootWordC           ) )\r\n"
        "#define SIZEOF_renderStateOldS  ( sizeof( renderStateOldS     ) )\r\n"
        "#define SIZEOF_pulpOldC         ( sizeof( pulpOldC            ) )\r\n"
        "#define SIZEOF_poolC            ( sizeof( poolC               ) )\r\n"
        "#define SIZEOF_napkinC          ( sizeof( napkinC             ) )\r\n"
        "#define SIZEOF_lexC             ( sizeof( lexC                ) )\r\n"
        "#define SIZEOF_handleC          ( sizeof( handleC             ) )\r\n"
        "#define SIZEOF_grabMemorySpaceC ( sizeof( grabMemorySpaceC    ) )\r\n"
        "#define SIZEOF_fileC            ( sizeof( fileC               ) )\r\n"
        "#define SIZEOF_etherC           ( sizeof( etherC              ) )\r\n"
        "#define SIZEOF_bookC            ( sizeof( bookC               ) )\r\n"
        "#define SIZEOF_batonC           ( 0x1b4                         )\r\n"
        "#define SIZEOF_baseSoilXxxxC    ( sizeof( baseSoilXxxxC       ) )\r\n"

    #if !defined( NEVERdEFINED )
    //U::DEBUG USE OF OOTH SET OF DEFS (REVERSING SENSE OF NEXT LINE)
    //20180127@1709: sizeof( batonC ) IS HARDCODED SO CAN BE USED WITHIN CLASS DEF OF napkinC
    //SO WE NORMALLY USE THE OOTH SNIP
    //BUT USING THE WOTH SNIP WILL RESULT IN LOTS OF IRRITATING WARNING CHATTER FROM THE COMPILER
    //USING THE WOTH SNIP IS NEEDED WHENEVER THE SIZE OF ANY OF THE LISTED CLASSES CHANGES

        "\r\n"
        "#pragma disable_message ( 549 , 656 , 657 , 665 , 666 , 726 ) ;\r\n"
        "\r\n"
        "// SIZEOF_[class] CONSTANTS ARE DEFINED HERE TO AVOID HAVING A USELESS COMPILER ERROR\r\n"
        "\r\n"
        "// For build environment info, see file \"\\ideafarm.work\\backed.up.never\\txt\\readme.first.ipdos.build.environment.txt\"\r\n"
        "\r\n"
        "// IPDOS (tm) <> IdeaFarm " "(tm) Piggyback Distributed Operating System\r\n"
        "\r\n"

    etThread.strMakeF( tin0P , LF , pstto , T(
    ZE( strokeS* , pstto ) ;

    // Warning! W726: col(1) no reference to formal parameter 'tin0P'

    }
        offbIdType = idMax ;
        offbFlags = idMin - 1 ;
        __( cGaps ) ;
        maskExtentF( tin0P , etThread , idMin , idMax , cGaps , FL_maskFlags ) ;
        ZE( countT , cGaps ) ;
        ZE( countT , idMax ) ;
        ZE( countT , idMin ) ;
    {
    ZE( countT , offbIdType ) ;
    ZE( countT , offbFlags ) ;
    //U: USE THIS INFO TO CALCULATE THE FLAGS VALUES USING CODE THAT DOES NOT ASSUME 02 BITS PER flagsT OBJECT

    }
        }
            }
                }
                    break ;
                    __1
                    __( idsTag ) ;
                {
                default :
                //case    : { csTags += sw_cTag *   0x0 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                //case    : { csTags += sw_cTag *   0x0 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                //case    : { csTags -= sw_cTag *   0x3 ; break ; } // TAG REMOVED; 2 DIGITS; "0x"
                case 0x11 : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case 0x10 : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case 0xf  : { csTags += sw_cTag *   0x0 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case 0xe  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case 0xd  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case 0xc  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case 0xb  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case 0xa  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case   9  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case   8  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case   7  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case   6  : { csTags += sw_cTag *   0x3 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case   5  : { csTags += sw_cTag *   0x2 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case   4  : { csTags += sw_cTag *   0x4 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case   3  : { csTags += sw_cTag *   0x4 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case   2  : { csTags += sw_cTag *   0x4 ; break ; } // TAG REMOVED; 8 DIGITS; "0x"
                case   1  : { csTags += sw_cTag * 0x100 ; break ; } // NO EDITS, BUT ALLOCATE 0x100 BYTES FOR GENERATED DEFINITION LINES FOR EACH GROUP
            {
            switch( idsTag )
            idsTag = sw_cTag.leverF( tin0P , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = sw_cTag.cFlavorsF( tin0P ) ;
    {
    ZE( countT , csTags ) ;

    //etThread.strokeF( tin0P , TF2(idf,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ) ;
    }
        else                                                              break ;
        if( etThread.strIdF( tin0P , idf , sttq , stTag , idsTag , tIn ) ) ( (countT&)sw_cTag ) ++ ;
        idsTag = 0 ;
        /*if( idf && !( idf % TUCK ) )*/ etThread.strokeF( tin0P , TF2(idf,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r") ) ;
    {
    while( !ether && !etThread && idf )
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    countT idf = 1 ;
    etThread.strokeF( tin0P , T("counting tags (cursor position)\r\n") ) ;

    switchC sw_cTag( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idsTag ) ;
    ZE( countT , idsTag ) ;

    //U:stTag << psttOldC( tin0P , etThread , T("/*idLath*/") ) ; //
    //U:stTag << psttOldC( tin0P , etThread , T("/*idNext*/") ) ; //
    psttv = psttOldC( tin0P , etThread , T("/*idb*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 11
    psttv = psttOldC( tin0P , etThread , T("/*ida*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 01
    psttv = psttOldC( tin0P , etThread , T("/*idr.01*/" ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // f
    psttv = psttOldC( tin0P , etThread , T("/*id9*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // e
    psttv = psttOldC( tin0P , etThread , T("/*id8*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // d
    psttv = psttOldC( tin0P , etThread , T("/*id7*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // c
    psttv = psttOldC( tin0P , etThread , T("/*id6*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // b
    psttv = psttOldC( tin0P , etThread , T("/*id5*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // a
    psttv = psttOldC( tin0P , etThread , T("/*id4*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 9
    psttv = psttOldC( tin0P , etThread , T("/*id3*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 8
    psttv = psttOldC( tin0P , etThread , T("/*id2*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 7
    psttv = psttOldC( tin0P , etThread , T("/*id1*/"    ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 6
    psttv = psttOldC( tin0P , etThread , T("/*idwm*/"   ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 5
    psttv = psttOldC( tin0P , etThread , T("/*fi*/"     ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 4
    psttv = psttOldC( tin0P , etThread , T("/*fl*/"     ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 3
    psttv = psttOldC( tin0P , etThread , T("/*id*/"     ) ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; ; // 2
    psttv = psttOldC( tin0P , etThread , t3               ) ; ___( psttv ) ; stTag << psttv ; psttv = 0 ; // 1
    ZE( strokeS* , psttv ) ;
    //FOR BEST SPEED, IT IS VERY IMPORTANT THAT THE MOST FREQUENT TAGS BE LISTED WOTH
    //THESE LINES CORRESPOND TO THE HARDCODED CASE VALUES

    TN( t3 , "/*" "3*/" ) ;

    stackC stTag( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;

    }
        etThread.delF( tin0P , posti ) ;
        tIn = T(posti) ;
        etThread.boxGetShadowF( tin0P , posti , countTC() , tFileIn ) ; ___( posti ) ;
        ZE( osTextT* , posti ) ;
    {
    TN( tIn , "" ) ;

    TN( tFileIn  , "///ideafarm/ephemeral/city/workshop/tmp/ipdos.h.draft2" ) ;

    CONoUTrAW( "HEADER FILE\r\n" ) ;

    */
    /*
{
if( pTaskP )
TASK( tmWorkF )

}
    etThread.delF( tin0P , psttw ) ;
    }
        }
            if( idw < cWords - 1 ) { etThread.strFuseF( tin0P , psttP , tUnder ) ; ___( psttP ) ; }
            etThread.delF( tin0P , psttn ) ;
            etThread.strFuseF( tin0P , psttP , psttn ) ; ___( psttP ) ;
            etThread.strWordF( tin0P , psttn , psttw , sttq , sttUnder , idw ) ; ___( psttn ) ;
            ZE( strokeS* , psttn ) ;
            //sttq = ze ;
        {
        for( countT idw = 1 ; idw < cWords ; idw ++ )
        strokeS sttUnder('_') ;
        etThread.strFuseF( tin0P , psttP , T("") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ psttw->idAdam ) ; ___( psttP ) ;
        sCountT cWords = etThread.strCLinesF( tin0P , psttw , tUnder ) ;
        TN( tUnder , "_" ) ;
    {
    if( psttw )
    etThread.strWordF( tin0P , psttw , psttFromP , sttq , S1C(' ') , 2 ) ; ___( psttw ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    ZE( strokeS* , psttw ) ;

    //IT IS BAD CODE STYLE TO USE UNDERSCORES WITHIN PREFIXES, BUT I WILL HANDLE IT IF NECESSARY
    //psttP IS SET TO "PREFIX1_PREFIX2_..._PREFIXN"
    //ASSUME: psttFromP IS OF THE FORM "#define PREFIX1_PREFIX2_..._PREFIXN_SUFFIX"
{
voidT prefixF( tin0S& tin0P , etherC& etThread , strokeS*& psttP , const strokeS* const psttFromP )

}
    cGapsP = cZe - cBitsOut ;
    countT cBitsOut = cBitsAll - cBitsIn ;
    countT cBitsIn = idMaxP - idMinP + 1 ;
    countT cBitsAll = sizeof( flagsT ) * SB ;

    }
        idc ++ ;
        mski <<= 1 ;

        else                          cZe ++ ;
        if(            maskP & mski ) idMaxP = idc ;
        if( !idMinP && maskP & mski ) idMinP = idc ;
    {
    while( mski )
    ZE( countT , cZe ) ;
    countT idc = 1 ;
    countT mski = 1 ;

    }
        if( etThread ) return ;
        __( cGapsP ) ;
        __( idMaxP ) ;
        __( idMinP ) ;
        if( etThread ) return ;
    {
    IFbEcAREFUL
{
voidT maskExtentF( tin0S& tin0P , etherC& etThread , countT& idMinP , countT& idMaxP , countT& cGapsP , const flagsT maskP )

}
    etThread.delF( tin0P , postx ) ;
    etThread.boxPutF( tin0P , T("///ideafarm/ephemeral/city/workshop/snip/1snip.1900000b.genValidFlags.h") , postx , costx ) ;
    etThread.delF( tin0P , pstto ) ;
    countT costx = etThread.strMakeF( tin0P , LF , postx , pstto ) ; ___( postx ) ;
    ZE( osTextT* , postx ) ;

    }
        etThread.strFuseF( tin0P , pstto , T("0x")+TF3(vv,flFORMAT_UNSIGNED|flFORMAT_FOREIGN,8)+(idf<cFlavors?T(" ,\r\n"):T("\r\n")) ) ;
        //LOGrAW7( "write [idf,leverP,vv]    :    " , idf , "    " , leverP , "    " , vv , "\r\n" ) ; //U:: TO FIND A BUG
        flagsT vv = swP ;
        leverP = swP.leverF( tin0P , idf ) ;
    {
    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
    etThread.strMakeF( tin0P , LF , pstto , tLine , cFlavors * tLine.csF( tin0P ) ) ; ___( pstto ) ;
    TN( tLine , "0x00000000 ,\r\n" ) ;
    ZE( strokeS* , pstto ) ;

    //LOGrAW3( "write [cFlavors]    :    " , cFlavors , "\r\n" ) ; //U:: TO FIND A BUG

    countT cFlavors = swP.cFlavorsF( tin0P ) ;
{
voidT writeValidFlagsTableF( tin0S& tin0P , etherC& etThread , switchC& swP , countT& leverP )

}
    etThread.boxPutF( tin0P , T("///ideafarm/ephemeral/city/workshop/snip/1snip.1900000c.genTimeNow.h") , (osTextT*)tt , tt.csF( tin0P ) ) ;
    TN( tt , "" ) ; tt = T("0x")+TF3(timeN1,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(" ,\r\n0x")+TF3(timeN2,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T("\r\n") ;

    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT  , timeN1 ) ;
{
voidT writeTimeNowTableF( tin0S& tin0P , etherC& etThread )

// "///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.h"
// "\ideafarm.home.1\precious\domains\com\ideafarm\city\library\snip\ipdos.h"

//  THE REASON FOR THIS IS THAT I MUST BE ABLE TO RUN CORRECTLY USING THE "OLD" VALUES IN EFFECT WHEN I WAS COMPILED
// IT IS ILLEGAL TO REFER TO ANY SYMBOLS WHOSE VALUES I CALCULATE

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_HEADER" )/*1*/
/**/
*/
generates snip.0050025.genMake.h snip file by inserting generated values
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

