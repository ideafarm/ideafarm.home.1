
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    delF( tinP , postArgs2 ) ;
    delF( tinP , postArgs1 ) ;

    __Z( bDone ) ;

    }
        }
            }
                tinP.pEtScratch->traceF( tinP , T("could not unzip using bundled infozip unzip.exe ; i give up" ) ) ;

                delF( tinP , postDir ) ;
                tinP.pEtScratch->traceF( tinP , T("called infozip unzip.exe [postArgs]:    ")+T(postArgs1) ) ;
                tinP.pEtScratch->traceF( tinP , T("[postDir]:    ")+T(postDir) ) ;
                dosGetCurrentDirF( tinP , postDir ) ; ___( postDir ) ;
                ZE( osTextT* , postDir ) ;
            {
            if( !bDone )

            else bDone = 1 ;
            }
                tinP.pEtScratch->traceF( tinP , T("bundled infozip unzip.exe failed [value,idDeathType]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            else if( value || idDeathType )
            }
                tinP.pEtScratch->traceF( tinP , T("could not hire bundled infozip unzip.exe [POOP]:    ")+TF2(idPoop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT idPoop = POOP ;
            {
            if( POOP )

            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            ((thirdC&)*tinP.pEtScratch).dosExecPgmF( tinP , countTC() , countTC() , value , idDeathType , postLongExe , postArgs2 ) ;
            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            SCOOPS
        {
        IFsCRATCH

        c_strcatIF( tinP , postLongExe , "\\precious\\domains\\com\\ideafarm\\city\\workshop\\infozip\\unzip.exe\\unzip.exe" ) ;
        c_strcpyIF( tinP , postLongExe , home.postHome ) ;
        osTextT postLongExe[ TUCK ] ;
        homeS& home = homeS::homeIF() ;

        idDeathType = value = 0 ;
    {
    if( !bDone && ( !idZipperP || idZipperP == ifcIDzIPPER_INFOZIP ) )

    }
        }
            }
                }
                    tinP.pEtScratch->traceF( tinP , T("could not unzip using pkzipc.exe" ) ) ;

                    delF( tinP , postDir ) ;
                    tinP.pEtScratch->traceF( tinP , T("called pkzipc.exe [postArgs]:    ")+T(postArgs1) ) ;
                    tinP.pEtScratch->traceF( tinP , T("[postDir]:    ")+T(postDir) ) ;
                    dosGetCurrentDirF( tinP , postDir ) ; ___( postDir ) ;
                    ZE( osTextT* , postDir ) ;

                    pEtherContainsMe->traceF( tinP , T("!exception: kid process failed [value,rc,name]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc) ) ;
                    TN( tb4 , "    " ) ;
                    const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                {
                else
                if( !POOP ) bPKZipHired = bDone = 1 ;

                }
                    __1
                    __( value ) ;
                {
                if( value != ifcEXITcODE_EXITpROCESSaOK )

                tinP.pEtScratch->osProcessWaitF( tinP , value , countTC() , osTid , osPid ) ;
                ZE( countT , value ) ;

                SCOOPS
                _IO_
            {
            IFsCRATCH
        {
        else
        if( !osPid ) pEtherContainsMe->traceF( tinP , T("!exception: could not launch ifcIDaDAM_HIREwITHOUTdEBUGGING") ) ;

        }
            c4Result = pEtherContainsMe->ifcHireF( tinP , T("ifcIDaDAM_HEALaRCHIVES") , ifcIDaDAM_HIREwITHOUTdEBUGGING , tArgs , flHIRE_DISPLAYaUTO , 0 , 0 , 1 , nicNameC() ) ;
            TN( tArgs , "" ) ; tArgs = T("!ignore [comment can go here] !maxValue 0 !hireLater pkzipc.exe ")+T(postArgs1) ;
            _IO_
        {
        countT& osPid = c4Result.c2 ;
        countT& osTid = c4Result.c1 ;
        count4S c4Result ;
    {
    if( bHireNoMonitor )

    }
        }
            else bPKZipHired = bDone = 1 ;
            }
                tinP.pEtScratch->traceF( tinP , T("pczipc.exe failed [value,idDeathType]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                bPKZipHired = 1 ;
            {
            else if( value || idDeathType )
            }
                if( bHireNoMonitor ) tinP.pEtScratch->traceF( tinP , T("i will try hiring pkzipc.exe indirectly") ) ;
                tinP.pEtScratch->traceF( tinP , T("could not hire pczipc.exe directly [POOP]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc) ) ;
                POOPRqUIET
                const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                bHireNoMonitor = rc == ifcIDiMPOTENCEbASEeRRORcODE_NOTsUPPORTED ;
                countT rc = POOP ;
            {
            if( POOP )

            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            ((thirdC&)*tinP.pEtScratch).dosExecPgmF( tinP , countTC() , countTC() , value , idDeathType , "pkzipc.exe" , postArgs1 ) ;
            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            SCOOPS
        {
        IFsCRATCH
    {
    if( !idZipperP || idZipperP == ifcIDzIPPER_PKZIPC )
    ZE( boolT  , bHireNoMonitor ) ;
    ZE( boolT  , bPKZipHired    ) ;
    ZE( countT , idDeathType    ) ;
    ZE( countT , value          ) ;
    ZE( boolT  , bDone          ) ;

    pEtherContainsMe->traceF( tinP , T("[postArgs2]:    ")+T(postArgs2) ) ;
    pEtherContainsMe->traceF( tinP , T("[postArgs1]:    ")+T(postArgs1) ) ;

    }
        pEtherContainsMe->strMakeF( tinP , LF , postArgs2 , tArgs2 ) ; ___( postArgs2 ) ;
        pEtherContainsMe->strMakeF( tinP , LF , postArgs1 , tArgs1 ) ; ___( postArgs1 ) ;

        tArgs2 += T(postSpecsInfoZipP)+tb+T(postFromP)+tb+T(postWildListP) ;
        tArgs1 += T(postSpecsPKZipP  )+tb+T(postFromP)+tb+T(postWildListP) ;
        if( tArgs2.csF( tinP ) ) tArgs2 += tb ;
        if( tArgs1.csF( tinP ) ) tArgs1 += tb ;

        }
            tArgs2 += T(" -x "      )   +T(postWildListExcludeP)+tba ;
            tArgs1 += T(" -exclude ")+tq+T(postWildListExcludeP)+tq  ;
        {
        if( postWildListExcludeP )

        }
            tArgs2 += T(" -i "      )   +T(postWildListIncludeP)+tba ;
            tArgs1 += T(" -include ")+tq+T(postWildListIncludeP)+tq  ;
        {
        if( postWildListIncludeP )

        TN( tArgs2 , F(flagsP) & flUNZIP_QUERY ? "-v" : ""         ) ;  // "-v" PRODUCES A VERBOSE LISTING, WHICH MOST CLOSELY CORRESPONDS TO PKZIP'S LISTING ; THE LISTS DIFFER SLIGHTLY, SO PARSING CODE MUST HANDLE BOTH VARIANTS
        TN( tArgs1 , F(flagsP) & flUNZIP_QUERY ? ""   : "-extract" ) ;  // MORE DETAIL, INCLUDING EXACT UNCOMPRESSED SIZE, CAN BE REPORTED BY PKZIPC THAN BY INFOZIP ; TO OBTAIN THIS, SPECIFY "-view=details" WITHIN postSpecsPKZipP
        TN( tq , "\""  ) ;
        TN( tb , " "   ) ;
        TN( tba , " @" ) ;
    {
    ZE( osTextT* , postArgs2 ) ;
    ZE( osTextT* , postArgs1 ) ;

    if( postSpecsInfoZipP    ) costAll += thirdC::c_strlenIF( tinP , postSpecsInfoZipP    ) ;
    if( postSpecsPKZipP      ) costAll += thirdC::c_strlenIF( tinP , postSpecsPKZipP      ) ;   // REALLY ONLY NEED THE MAXIMUM LENGTH SINCE ONLY WO SPEC IS USED AT A TIME; DONE THIS WAY FOR SIMPLICITY (SPECS ARE SHORT)
    if( postWildListExcludeP ) costAll += thirdC::c_strlenIF( tinP , postWildListExcludeP ) ;
    if( postWildListIncludeP ) costAll += thirdC::c_strlenIF( tinP , postWildListIncludeP ) ;
    countT                     costAll  = thirdC::c_strlenIF( tinP , postFromP ) + thirdC::c_strlenIF( tinP , postWildListP ) + TUCK ;

    pEtherContainsMe->traceF( tinP , T("[postSpecsInfoZipP   ]:    ")+T(postSpecsInfoZipP)    ) ;
    pEtherContainsMe->traceF( tinP , T("[postSpecsPKZipP     ]:    ")+T(postSpecsPKZipP)      ) ;
    pEtherContainsMe->traceF( tinP , T("[postWildListExcludeP]:    ")+T(postWildListExcludeP) ) ;
    pEtherContainsMe->traceF( tinP , T("[postWildListIncludeP]:    ")+T(postWildListIncludeP) ) ;
    pEtherContainsMe->traceF( tinP , T("[postWildListP       ]:    ")+T(postWildListP)        ) ;
    pEtherContainsMe->traceF( tinP , T("[postFromP           ]:    ")+T(postFromP)            ) ;

    _IO_

    }
        if( POOP ) return ;
        //FV( flUNZIP , flagsP ) ;
        __Z( pEtherContainsMe  ) ;
        __Z( postWildListP     ) ;
        __Z( postFromP         ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT thirdC::diskUnzipF( tinS& tinP , const osTextT* const postFromP , const flagsT flagsP , const osTextT* const postWildListP , const osTextT* const postWildListIncludeP , const osTextT* const postWildListExcludeP , const osTextT* const postSpecsPKZipP , const osTextT* const postSpecsInfoZipP , const countT idZipperP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
