
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        ) ;

            +T("</SPAN>\r\n")
            +T(     psttKVReportP)
            )

                "<P>\r\n"
                "Not done.\r\n"
            
            T(

        meP.pushSnipF( tin0P , stBodyP ,
    {
    else
    }
        ) ;

            +T("</SPAN>\r\n")
            +T(     psttKVReportP)
            )

                "<P>\r\n"
                "Not done.  Another account is owned by the proposed email address.\r\n"
            
            T(

        meP.pushSnipF( tin0P , stBodyP ,
    {
    else if( bAlreadyExists )
    }
        ) ;

            +T("</SPAN>\r\n")
            +T(     psttKVReportP)
            )

                "<P>\r\n"
                "Done.\r\n"
            
            T(

        meP.pushSnipF( tin0P , stBodyP ,
    {
    if( bDone )

    }
        if( POOP ) POOPR

        }
            }
                }
                    }
                        }
                            }
                                }
                                    etThread.delF( tin0P , posti ) ;
                                    }
                                        bDone = 1 ;
                                        }
                                            while( ~hFind1 ) ;
                                            }
                                                DEL( pInfo1 ) ;
                                                }
                                                    while( ~hFind2 ) ;
                                                    }
                                                        DEL( pInfo2 ) ;
                                                        }
                                                            etThread.delF( tin0P , posti ) ;
                                                            }
                                                                ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , pInfo2->psttIfoName , tNew , tNew.csF( tin0P ) ) ;
                                                                etThread.delF( tin0P , psttw ) ;
                                                                TN( tNew , "" ) ; tNew = T(psttw) ;
                                                                etThread.strReplaceF( tin0P , psttw , T(posti) , tEmailLoggedIn , tEmailTicket , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttw ) ;
                                                                ZE( strokeS* , psttw ) ;
                                                            {
                                                            else if( posti && *posti )
                                                            if( POOP ) { POOPR ; }
                                                            ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , pInfo2->psttIfoName , 1 ) ; ___( posti ) ;
                                                            ZE( countT , costi ) ;
                                                            ZE( osTextT* , posti ) ;
                                                        {
                                                        if( pInfo2 && !( F(pInfo2->flags) & flFILEaTTR1_DIRECTORY ) )
                                                        ((tin1S&)tin0P).pEtScratch->diskFindFileOrDirF( tin0P , pInfo2 , hFind2 , tDirSubaccount , &pat ) ; ___( pInfo2 ) ;
                                                        ZE( infoFileS* , pInfo2 ) ;
                                                    {
                                                    do
                                                    handleC hFind2( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                                    patternC pat( tin0P , etThread , T("txt.*") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                                                    TN( tDirSubaccount , "" ) ; tDirSubaccount = T(pInfo1->psttIfoName) ;
                                                {
                                                if( pInfo1 && F(pInfo1->flags) & flFILEaTTR1_DIRECTORY && !( F(pInfo1->flags) & flFILEaTTR1_DOTdIRECTORY ) )
                                                ((tin1S&)tin0P).pEtScratch->diskFindFileOrDirF( tin0P , pInfo1 , hFind1 , tDirSubaccounts ) ; ___( pInfo1 ) ;
                                                ZE( infoFileS* , pInfo1 ) ;
                                            {
                                            do
                                            handleC hFind1( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                            TN( tDirSubaccounts , "" ) ; tDirSubaccounts += tDirAccount+T("/subaccounts/") ;
                                        {
                                        etThread.boxPutF( tin0P , tFile , tEmailTicket , tEmailTicket.csF( tin0P ) ) ;
                                    {
                                    else if( posti && !etThread.strCompareF( tin0P , T(posti) , tEmailLoggedIn ) )
                                    if( POOP ) { POOPR ; }
                                    ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , tFile , 1 ) ; ___( posti ) ;
                                    ZE( countT , costi ) ;
                                    ZE( osTextT* , posti ) ;
                                    TN( tFile , "" ) ; tFile = tDirAccount+tShortFileOwner ;
            
                                    TN( tDirAccount , "" ) ; tDirAccount = tIpdosAccounts+TF4(idAccountLoggedIn,flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_NObIGITvALUES,0,36)+T("/") ;
                                {
                                if( !bAlreadyExists )

                                }
                                    }
                                        if( !bAlreadyExists ) { etThread.diskFindFileOrDirF( tin0P , psttDirAccount , hFind , tIpdosAccounts ) ; ___( psttDirAccount ) ; }
                                        etThread.delF( tin0P , psttDirAccount ) ;
                        
                                        }
                                            etThread.delF( tin0P , posti ) ;
                                            else if( posti && costi && !etThread.strCompareF( tin0P , tEmailTicket , T(posti) ) ) bAlreadyExists = 1 ;
                                            if( POOP ) { POOPR ; }
                                            ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , T(psttDirAccount)+tShortFileOwner ) ; ___( posti ) ;
                                            ZE( countT , costi ) ;
                                            ZE( osTextT* , posti ) ;
                                        {
                                        else
                                        if( !bDir || bDots ) etThread.delF( tin0P , psttDirAccount ) ;
                        
                                        }
                                            etThread.delF( tin0P , psttw ) ;
                                            ;
                                                !etThread.strCompareF( tin0P , psttw , T(".") )
                                                !etThread.strCompareF( tin0P , psttw , T("..") ) ||
                                            bDots = 
                        
                                            etThread.strWordF( tin0P , psttw , psttDirAccount , sttq , S1C('/') , - 1 - bDir ) ; ___( psttw ) ;
                                            ZE( strokeS* , psttw ) ;
                                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        
                                            bDir = psttDirAccount && psttDirAccount[ CSpREFIX - 1 + psttDirAccount->idAdam ].idAdam == '/' ;
                                        {
                                        ZE( boolT , bDir ) ;
                                        ZE( boolT , bDots ) ;
                                    {
                                    while( !etThread && psttDirAccount && !bAlreadyExists )
                        
                                    etThread.diskFindFileOrDirF( tin0P , psttDirAccount , hFind , tIpdosAccounts ) ; ___( psttDirAccount ) ;
                                    ZE( strokeS* , psttDirAccount ) ;
                                    handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                {
                                TN( tShortFileOwner , "txt.email.owner.txt" ) ;
                                TN( tIpdosAccounts , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/accounts/" ) ;
                                //SEARCH FOR AN EXISTING ACCOUNT OWNED BY tEmailTicket; THIS NEEDS TO BE DONE WITHOUT BLOWING MEMORY WITH A LARGE LIST

                                }
                                    etThread.delF( tin0P , psttEmailTicket ) ;
                                    tEmailTicket = T(psttEmailTicket) ;
                                    sIn >> psttEmailTicket ; ___( psttEmailTicket ) ;
                                    ZE( strokeS* , psttEmailTicket ) ;
                                {
                            {
                            if( idAccountTicket && idAccountTicket == idAccountLoggedIn )
                            sIn >> idAccountTicket ;
                            ZE( countT , idAccountTicket ) ;
                        {
                        if( idType == ifcIDtYPEtICKET_REPLACEaCCOUNToWNEReMAIL )
                        sIn >> idType ;
                        ZE( countT , idType ) ;
                    {
                    if( idFormat == 1 )
                    sIn >> idFormat ;
                    ZE( countT , idFormat ) ;
                {
                if( finger == FINGERnEG_TICKET )
                sIn >> finger ;
                ZE( countT , finger ) ;

                ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , sIn , tFileNew ) ;
                soulC sIn( tin0P , TAG( TAGiDnULL ) ) ;
            {
            else
            if( POOP ) { POOPR ; }
            ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tFileNew , tDirOld+tShort ) ;
            TN( tFileNew , "" ) ; tFileNew = tDirNew+tShort ;
            TN( tShort  , "soul.ticket." ) ; tShort += T(zsttIdTicket)+T(".soul") ;

            if( POOP ) { POOPR ; }
            ((tin1S&)tin0P).pEtScratch->diskMakeDirIfNeededF( tin0P , tDirNew ) ;
            TN( tDirNew , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets.used/" ) ;
            TN( tDirOld , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/tickets/" ) ;

            if( zsttIdTicket ) { etThread.strTrimF( tin0P , zsttIdTicket , 0 , T(TbLACKnEWlINE) ) ; ___( zsttIdTicket ) ; }
            strokeS*& zsttIdTicket = *(strokeS**)&(countT&)swKVP ;
            psttLeverKVP = tKey ;
        {
        if( swKVP.idSlotOfLeverF( tin0P , (countT)(strokeS*)tKey ) )
        TN( tKey , "idticket" ) ;
        SCOOPS
    {
    IFsCRATCH
    TN( tEmailTicket , "" ) ;
    ZE( boolT , bAlreadyExists ) ;
    ZE( boolT , bDone ) ;

    }
        etThread.delF( tin0P , psttEmailLoggedIn ) ;
        tEmailLoggedIn = T(psttEmailLoggedIn) ;
        idAccountLoggedIn = session.getIdAccountF( tin0P ) ;
        session.getEmailF( tin0P , psttEmailLoggedIn ) ; ___( psttEmailLoggedIn ) ;
        sessionC& session = sessionsP( tin0P , nnPeerP ) ;
        ZE( strokeS* , psttEmailLoggedIn ) ;
    {
    ZE( countT , idAccountLoggedIn ) ;
    TN( tEmailLoggedIn , "" ) ;
{
/*1*/voidT obeyEmailLinkReplaceOwnerEmailCBF( tin0S& tin0P , etherC& etThread , const boolT& bQuitP , httpServerC& meP , countT& cArgP , httpReplyS& replyP , stackC& stBodyP , const strokeS* const psttKVReportP , switchC& swKVP , strokeS*& psttLeverKVP , sessionsC& sessionsP , nicNameC& nnPeerP , const strokeS* const psttNameP , const strokeS* const psttQueryKVP , const strokeS* const psttPeerAgentP , const osTextT* const postBodyP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

