
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#undef POSTnAPKINdRIVEReXISTSpREFIX

}
    return bOk ;

    #endif

        }
            }
                break ;

                while( bRetry ) ;
                }
                    }
                        bOk = 1 ;
                        if( !_brcRaw ) { BLAMMO ; }
                        BOSnOtIN( CloseHandle( (HANDLE)_brcRaw ) )
                    {
                    else
                    }
                        }
                            bRetry = 1 ;
                            POPUP( "Please add more paging file capacity now and then click OK." ) ;
                        {
                        if( _brcRaw  == ERROR_NOT_ENOUGH_MEMORY || _brcRaw  == ERROR_COMMITMENT_LIMIT )
                        BOSnOtIN( GetLastError() )
                    {
                    if( !_brcRaw )
                    BOSnOtIN( CreateFileMappingNuma( (HANDLE)-1 , 0 , PAGE_READONLY | SEC_COMMIT , 0 , 0x10 * TOCK , ostoOsName , thirdC::osOffNumaNodeValidChosenIF( processGlobal2I.idNumaNode ) ) )

                    //INCREASE THE COMMITMENT SIZE IF FIELD PROBLEMS OCCUR DURING INSTALLATION
                    //COMMITMENT TAKES TIME, AND THIS CAN CAUSE THE SERVICE INSTALLER TO TIME OUT
                    //THIS WAS OBSOLETED BY THE poolC REWRITE; IT IS RETAINED TO ENFORCE A MUCH LOWER MINIMUM

                    bRetry = 0 ;
                {
                do
                ZE( boolT , bRetry ) ;

                OStEXTC( ostoOsName , processGlobal2I.idHome , 0 ) ;
                OStEXTAK( ostoOsName , "ideafarm.testWaterI.0." ) ; //A: ASSUME: FOR EACH HOST, ONLY 1 INSTANCE OF THIS FUNCTION IS EXECUTING AT A TIME (IF NOT THEN I WILL COMPLAIN SPURIOUSLY ABOUT LOW MEMORY)
                OStEXT( ostoOsName , COSTnAPKINnAMEmAX + 1 )
            {
            case ifcIDtYPEtESTwATER_ENOUGHmEMORY :
            }
                break ;

                bOk = 1 ;
                while( bRetry ) ;
                }
                    }
                        *pOshP = 0 ;
                        if( !_brcRaw ) { BLAMMO ; }
                        BOSnOtIN( CloseHandle( (voidT*)*pOshP ) )
                    {
                    if( !bDriver && *pOshP )

                    }
                        }
                            BOSnOvALUEnOtIN( OSsLEEPf( TUCK ) )
                            /*Beep ( 0x100 , TUCK ) ;*/
                            CONoUTrAW5( "waiting for idHome " , processGlobal2I.idHome , " to become available for " , processGlobal1I.idAdamRoot , "\r\n" ) ;
                        {
                        else
                        if( F(processGlobal2I._thirdC_flagsModeProcess2) & flMODEpROCESS2_IDhOSTsEARCH ) ++ *(countT*)&processGlobal2I.idHome ;

                        }
                            *pOshP = 0 ;
                            if( !_brcRaw ) { BLAMMO ; }
                            BOSnOtIN( CloseHandle( (voidT*)*pOshP ) )
                        {
                        if( *pOshP )
                        bRetry = 1 ;
                    {
                    else if( bDenied || ( bDriver && bOld ) ? 1 : 0 )
                    }
                        bRetry = 1 ;
                        POPUP( "Please allocate more disk space for use as virtual memory and then click OK.\r\n\r\nIn Windows 2000, you can do this now by mouse clicking into MyComputer/ControlPanel/System/Advanced/PerformanceOptions/VirtualMemory/Change" ) ;
                    {
                    if( bLowMem )

                    //conGF( "\r\n" ) ;
                    //conGF( bDriver ) ;
                    //conGF( " " ) ;
                    //conGF( bOld ) ;
                    //conGF( " " ) ;
                    //conGF( bDenied ) ;
                    //conGF( " " ) ;
                    //conGF( bLowMem ) ;
                    //conGF( "osTestWaterIF [bLowMem,bDenied,bOld,bDriver]: " ) ;

                    boolT bDriver = processGlobal1I.idAdamRoot == ifcIDaDAM_KERNEL1DRIVER || processGlobal1I.idAdamRoot == ifcIDaDAM_KERNEL2MONITOR ;
                    boolT bOld    = rc == ERROR_ALREADY_EXISTS ;
                    boolT bDenied = rc == ERROR_ACCESS_DENIED ;
                    boolT bLowMem = rc == ERROR_NOT_ENOUGH_MEMORY ;

                    countT rc = _brcRaw ;
                    BOSnOtIN( GetLastError() )

                    *pOshP = _brcRaw ; //U::UNSAFE (LEAKAGE): RETURN A handleC RATHER THAN A countT
                    BOSnOtIN( CreateFileMappingNuma( (HANDLE)-1 , 0 , PAGE_READONLY | SEC_COMMIT , 0 , 1 , ostoOsName , thirdC::osOffNumaNodeValidChosenIF( processGlobal2I.idNumaNode ) ) )

                    OStEXTC( ostoOsName , processGlobal2I.idHome , 0 ) ;
                    OStEXTAK( ostoOsName , POSTnAPKINdRIVEReXISTSpREFIX ) ;
                    OStEXT( ostoOsName , COSTnAPKINnAMEmAX + 1 )

                    bRetry = 0 ;
                {
                do
                ZE( boolT , bRetry ) ;

                if( !pOshP ) { BLAMMO ; }
            {
            case ifcIDtYPEtESTwATER_IDhOSTaDJUST :
            }
                break ;

                }
                    }
                        BOSnOtIN( CloseHandle( (voidT*)oshm ) )

                        if( _brcRaw == ERROR_ALREADY_EXISTS ) bOk = 1 ;
                        BOSnOtIN( GetLastError() )
                        countT oshm = _brcRaw ;
                    {
                    else
                    }
                        }
                            }
                                pEtRock->traceF( tinP , T("osTestWaterIF: traced pool tallies") ) ;
                                pEtRock->tracePoolTalliesF( tinP ) ;
                                pEtRock->traceF( tinP , T("osTestWaterIF: tracing pool tallies because CreateFileMappingNuma returned ERROR_NOT_ENOUGH_MEMORY") ) ;
                            {
                            if( pEtRock )
                            etherC* pEtRock = &etherC::etRockIF( tinP ) ;
                            bOk = 1 ;       //U:: THIS ERROR IS SILENTLY IGNORED PENDING FURTHER ANALYSIS, ON THE PRESUMPTION THAT IT IS TRANSIENT ; U:: CONSIDER INFORMING CALLER (E.G. BY EITHER SETTING bOk TO 2 OR USING A NEW PARAMETER TO SAY "I COULD NOT DETERMINE bOk")
                        {
                        else
                        if( rc != ERROR_NOT_ENOUGH_MEMORY ) { BLAMMOiD( rc ) ; }

                        countT rc = _brcRaw ? _brcRaw : - 1 ;
                        BOSnOtIN( GetLastError() )
                    {
                    if( !_brcRaw )
                    BOSnOtIN( CreateFileMappingNuma( (HANDLE)-1 , 0 , PAGE_READONLY | SEC_COMMIT , 0 , 1 , ostoOsName , thirdC::osOffNumaNodeValidChosenIF( processGlobal2I.idNumaNode ) ) )

                    OStEXTC( ostoOsName , processGlobal2I.idHome , 0 ) ;
                    OStEXTAK( ostoOsName , POSTnAPKINdRIVEReXISTSpREFIX ) ;
                    OStEXT( ostoOsName , COSTnAPKINnAMEmAX + 1 )
                {
                else
                if( bDriver || processGlobal2I.idHome & fliIDhOME_HOMELESS ) bOk = 1 ;

                boolT bDriver = processGlobal1I.idAdamRoot == ifcIDaDAM_KERNEL1DRIVER || processGlobal1I.idAdamRoot == ifcIDaDAM_KERNEL2MONITOR ;
            {
            case ifcIDtYPEtESTwATER_LOOKfORdRIVER :
        {
        switch( idTypeP )

    #if defined( __NT__ )

    ZE( countT , _brcRaw ) ;
    ZE( boolT , bOk ) ;
{
/*1*/boolT thirdC::osTestWaterIF( tinS& tinP , const countT idTypeP , countT* pOshP )/*1*/

#define POSTnAPKINdRIVEReXISTSpREFIX "..napkinC.ideafarm.domains.com.ideafarm.driverExists.0."

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

