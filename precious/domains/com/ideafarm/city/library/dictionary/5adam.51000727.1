
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    while( ~hFindDir && !ether && !POOP ) ;
    }
        DEL( pInfoDir ) ;
    
        }
            }
                //if( !stCurrentNameValueDataFileName ) break ; //U:: REMOVE IN PRODUCTION

                }
                    }


                        }
                            etThread.delF( tin0P , psttSourceShortRoot ) ;
                            etThread.delF( tin0P , psttTargetShortRoot ) ;
                            etThread.delF( tin0P , pstt1Doomed ) ;

                            }
                                etThread.diskFileOrDirDeleteF( tin0P , psttc1 ) ;
                                etThread.traceF( tin0P , T("                                           doomed: ")+T(psttc1) ) ;
                            {
                            FORsTRINGSiN1( pstt1Doomed )
                            etThread.diskFindFileOrDirOldF( tin0P , pstt1Doomed , tPathArchive+tYearSlash+T(psttSourceShortRoot)+tStar ) ; ___( pstt1Doomed ) ;
                            ZE( strokeS* , pstt1Doomed ) ;

                            etThread.traceF( tin0P , T("                                      doomed root: ")+tPathArchive+tYearSlash+T(psttSourceShortRoot) ) ;

                            etThread.diskMoveFileOrDirF( tin0P , tPathArchive+tYearSlash+tNewName , tPathArchive+tYearSlash+T(psttzDataThumb) ) ;

                            etThread.traceF( tin0P , T("                                         new name: ")+tPathArchive+tYearSlash+tNewName ) ;
                            etThread.traceF( tin0P , T("                                         old name: ")+tPathArchive+tYearSlash+T(psttzDataThumb) ) ;

                            TN( tNewName , psttTargetShortRoot ) ; tNewName += tMetaDotThumbDot0600xDotJpg ;

                            etThread.strSubstringF( tin0P , psttSourceShortRoot , idf4 , idHit4 , psttzDataThumb ) ; ___( psttSourceShortRoot ) ;
                            countT idf4 = 1 ;
                            ZE( strokeS* , psttSourceShortRoot ) ;

                            etThread.strSubstringF( tin0P , psttTargetShortRoot , idf3 , idHit3 , psttzDataFull ) ; ___( psttTargetShortRoot ) ;
                            countT idf3 = 1 ;
                            ZE( strokeS* , psttTargetShortRoot ) ;
                        {
                        if( idHit3 && idHit4 )
                        countT idHit4 = etThread.strIdF( tin0P , tDotDataDot , psttzDataThumb ) ;
                        countT idHit3 = etThread.strIdF( tin0P , tDotDataDot , psttzDataFull ) ;

                        etThread.traceF( tin0P , T("                     full: ")+T(psttzDataFull) ) ;
                        etThread.traceF( tin0P , T("                    thumb: ")+T(psttzDataThumb) ) ;
                    {
                    if( psttzDataThumb && psttzDataFull )

                    }
                        while( ~hWalk ) ;
                        }
                            }
                                }
                                    }
                                        break ;
                                        ( b600 ? psttzDataThumb : psttzDataFull ) = psttc1 ;
                                        etThread.traceF( tin0P , T("                dataname: ")+T(psttc1) ) ;
                                    {
                                    case 3 :
                                    }
                                        break ;
                                        b600 = !!etThread.strIdF( tin0P , tDot0600xDotJpg , psttc1 ) ;
                                        etThread.traceF( tin0P , T("        currentnamevalue: ")+T(psttc1) ) ;
                                    {
                                    case 2 :
                                {
                                switch( ++ ids )
                            {
                            FORsTRINGSiN1( pstt1Set )
                            ZE( boolT , b600 ) ;
                            ZE( countT , ids ) ;

                            strokeS* pstt1Set = (strokeS*)swsSets.downF( tin0P , hWalk ) ;
                            etThread.traceF( tin0P , T("    set") ) ;
                        {
                        do
                        handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( swsSets > 1 )
                    ZE( strokeS* , psttzDataThumb ) ;
                    ZE( strokeS* , psttzDataFull  ) ;
                    etThread.traceF( tin0P , T("sets [swsSets]:")+TF2(swsSets,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    psttzLever = (strokeS*)swsSets.leverF( tin0P , idf ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                countT cFlavors = swsSets.cFlavorsF( tin0P ) ;

                }
                    swsSets << pstt1Set ;
                    etThread.traceF( tin0P , T("lever: ")+T(psttzLever) ) ;
                    psttzLever = pstt1Set + CSpREFIX ;
                
                    stCurrentNameValueDataFileName >> pstt1Set ;
                    ZE( strokeS* , pstt1Set ) ;
                {
                while( stCurrentNameValueDataFileName )
                switchStackC swsSets( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLever , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                ZE( strokeS* , psttzLever ) ;

                while( ~hFindFile && !ether && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
    
                    }
                        }
                            }
                                etThread.delF( tin0P , psttShortest ) ;
                                stCurrentNameValueDataFileName.sinkF( tin0P , countTC() , pstt1Set , flSTACKsINK_null , 0 , 1 ) ;
                                etThread.strFuseSeparateF( tin0P , pstt1Set , tShort            ) ;
                                etThread.strFuseSeparateF( tin0P , pstt1Set , tCurrentNameValue ) ;
                                etThread.strFuseSeparateF( tin0P , pstt1Set , psttShortest      , 0 , 0 , 0 , 0 , 2 * CSpREFIX + tCurrentNameValue.csF( tin0P ) + tShort.csF( tin0P ) ) ; ___( pstt1Set ) ;
                                ZE( strokeS* , pstt1Set ) ;

                                etThread.strSubstringF( tin0P , psttShortest , idf2 , idHit2 , tCurrentNameValue ) ; ___( psttShortest ) ;
                                countT idf2 = 1 ;
                                ZE( strokeS* , psttShortest ) ;

                                if( !idHit2 ) { BLAMMO ; }
                                if( !idHit2 ) idHit2 = etThread.strIdF( tin0P , tDotJpg         , tCurrentNameValue ) ;
                                countT        idHit2 = etThread.strIdF( tin0P , tDot0600xDotJpg , tCurrentNameValue ) ;

    
                                }
                                    etThread.delF( tin0P , postCurrentNameValue ) ;
                                    tCurrentNameValue = T(postCurrentNameValue) ;
                                    etThread.boxGetShadowF( tin0P , postCurrentNameValue , costCurrentNameValue , tFileMetaNameLong ) ; ___( postCurrentNameValue ) ;
                                    ZE( countT   , costCurrentNameValue ) ;
                                    ZE( osTextT* , postCurrentNameValue ) ;
                                {
                                else
                                if( !etThread.diskFileExistsF( tin0P , tFileMetaNameLong ) ) etThread.traceF( tin0P , T("error / file does not exist: ")+tFileMetaNameLong ) ;
                                TN( tCurrentNameValue , "" ) ;
                                TN( tFileMetaNameLong , "" ) ; tFileMetaNameLong = tPathArchive+tYearSlash+tShortMetaName ;
    
                                etThread.delF( tin0P , psttShorter ) ;
                                TN( tLongMetaDotStar , "" ) ; tLongMetaDotStar = tPathArchive+tYearSlash+T(psttShorter)+tMetaDotStar ;
                                TN( tShortMetaName , "" ) ; tShortMetaName = T(psttShorter)+tMetaDotCurrentName ;
    
                                etThread.strSubstringF( tin0P , psttShorter , idf , idHit , tShort ) ; ___( psttShorter ) ;
                                countT idf = 1 ;
                                ZE( strokeS* , psttShorter ) ;
                            {
                            if( idHit )
                            countT idHit = etThread.strIdF( tin0P , tDotDataDot , tShort ) ;
    
                            }
                                etThread.delF( tin0P , psttShort ) ;
                                tShort = T(psttShort) ;
                                etThread.delF( tin0P , psttnu ) ;
                                etThread.strBisectF( tin0P , psttnu , psttShort , pInfoFile->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                                ZE( strokeS* , psttShort ) ;
                                ZE( strokeS* , psttnu ) ;
                            {
                            TN( tShort , "" ) ;
                        {
                        if( !bDir )
    
                        const boolT bDir = pInfoFile->psttIfoName[ CSpREFIX - 1 + pInfoFile->psttIfoName->idAdam ].idAdam == '/' ;
                        TN( tIfoName , pInfoFile->psttIfoName ) ;
                    {
                    else
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( !pInfoFile || !pInfoFile->psttIfoName )
    
                    etThread.diskFindFileOrDirOldF( tin0P , pInfoFile , hFindFile , tPathArchive+tYearSlash+t7DotStarDotDataDotJpg ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                handleC hFindFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                stackC stCurrentNameValueDataFileName( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
    
                etThread.traceF( tin0P , tYearSlash ) ;
            {
            if( bDir && etThread.strCompareF( tin0P , tDotSlash , tYearSlash ) && etThread.strCompareF( tin0P , tDotDotSlash , tYearSlash ) )
    
            }
                etThread.delF( tin0P , psttYearSlash ) ;
                tYearSlash = T(psttYearSlash) ;
                etThread.delF( tin0P , psttnu ) ;
                etThread.strBisectF( tin0P , psttnu , psttYearSlash , pInfoDir->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttYearSlash ) ;
                ZE( strokeS* , psttYearSlash ) ;
                ZE( strokeS* , psttnu ) ;
            {
            TN( tYearSlash , "" ) ;
    
            const boolT bDir = pInfoDir->psttIfoName[ CSpREFIX - 1 + pInfoDir->psttIfoName->idAdam ].idAdam == '/' ;
            TN( tIfoName , pInfoDir->psttIfoName ) ;
        {
        else
        }
            break ;
            DEL( pInfoDir ) ;
        {
        if( !pInfoDir || !pInfoDir->psttIfoName )
    
        etThread.diskFindFileOrDirOldF( tin0P , pInfoDir , hFindDir , tPathArchive+tStar ) ; ___( pInfoDir ) ;
        ZE( infoFileS* , pInfoDir ) ;
    {
    do
    handleC hFindDir( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    
    TN( tMetaDotThumbDot0600xDotJpg , "meta.thumb.0600x.jpg" ) ;
    TN( tDotJpg , ".jpg" ) ;
    TN( tDot0600xDotJpg , ".0600x.jpg" ) ;
    TN( tDot , "." ) ;
    TN( tDotDotSlash , "../" ) ;
    TN( tDotSlash , "./" ) ;
    TN( tb8 , "        " ) ;
    TN( tb , " " ) ;
    TN( tMetaDotStar , "meta.*" ) ;
    TN( tMetaDotCurrentName , "meta.currentname" ) ;
    TN( tDotDataDot , ".data." ) ;
    TN( tSlash , "/" ) ;
    TN( t7DotStarDotDataDotJpg , "!ideafarm.8.2.00000000.00000001.*.data.jpg" ) ;
    TN( tStar , "*" ) ;
    TN( tPathArchiveLinks , "///d/archive.links/" ) ;
    TN( tPathArchive      , "///d/archive/" ) ;
{

TODO

/*1*/WAKEsHOWtEXT( "was.scratch.2.archived.20180508@1202.tool.file.migrate.0600x.files.to.meta.thumbnails" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
