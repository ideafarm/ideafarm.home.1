
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

}
    }
        }
            }
                etThread.traceF( tinBaseP , T("cycle ended aok [time]:    ")+TT(time1AOK,time2AOK) ) ;
                etThread.osTimeNowF( tinBaseP , time1AOK , time2AOK ) ;
                time2AOK = time1AOK = 0 ;
            {
            else
            }
                time2AOK = time1AOK = 0 ;      // THIS WILL CAUSE THE NEXT ITERATION TO PROCEED AFTER ONLY NAPPING WO TICK
                etThread.traceF( tinBaseP , T("exception: this cycle was aborted") ) ;
                /*if( cYearsInParallel > 1 && 1 == decv02AM( cYearsInParallel ) )*/ cYearsInParallel = 1 ;  // REDUCE cYearsInParallel BUT NOT BELOW 1
                //20221229@1435: IF ABORT THEN ON NEXT ITERATION PROCESS YEARS SERIALLY
            {
            if( bAbort )

            }
                ++ s ; ether.osSleepF( tinBaseP , TOCK ) ;
            {
            while( stJob )

            }
                }
                    //etThread.osSuspendF( tinBaseP ) ;
                    //etThread.traceF( tinBaseP , T("ok.  hibernating") ) ;

                    }
                        }
                            THREADmODE2rESTORE
                            while( cExecutiveHealYear ) thirdC::dosSleepWinkIF( tinBaseP ) ;
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                            _IO_
                        {

                        }
                            while( !bAbort && ~hStYearToHeal ) ;
                            }
                                }
                                    }
                                        }
                                            break ;
                                            bAbort = 1 ;
                                            etThread.traceF( tinBaseP , T("exception: could not launch thread tmOldExecutiveHealYearF") ) ;
                                            dec02AM( cExecutiveHealYear ) ;
                                            POOPR
                                        {
                                        if( POOP )
                                        ((tinFullS&)tinBaseP).pEtScratch->osThreadF( TaRG3fLAGScBtLS( tmExecutiveHealYearF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cExecutiveHealYear , (countT)psttYear , (countT)&psttzArchive , (countT)&swsPathToArchivesByArchiveName , (countT)&bAbort , (countT)&stJob ) ;
                                        SCOOPS
                                        _IO_
                                    {
                                    IFsCRATCH
                                    inc02AM( cExecutiveHealYear ) ;

                                    etThread.strMakeF( tinBaseP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                                    ZE( strokeS* , psttYear ) ;

                                    etThread.traceF( tinBaseP , T("year to heal:    ")+T(psttzYear) ) ;
                                    strokeS* psttzYear = (strokeS*)stYearToHeal.upF( tinBaseP , hStYearToHeal ) ;       //PROCESSES YEARS BEGINNING WITH MOST RECENT  (A:ASSUME: CURRENT YEARS ARE IN MOST NEED OF HEALING SINCE FILES ARE ADDED AND MODIFIED)
                                {
                                if( !bAbort )

                                }
                                    THREADmODE2rESTORE
                                    while( cYearsInParallel == cExecutiveHealYear ) thirdC::dosSleepWinkIF( tinBaseP ) ;
                                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                                    _IO_
                                {
                                _IO_
                            {
                            do
                            handleC hStYearToHeal( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            _IO_
                        {
                        if( !bAbort && stYearToHeal )
                        ZE( countT , cExecutiveHealYear ) ;

                        }
                            }
                                }
                                    }
                                        }
                                            break ;
                                            bAbort = 1 ;
                                            etThread.delF( tinBaseP , psttYear ) ;
                                            etThread.traceF( tinBaseP , T("exception: duplicate year [psttYear]:    ")+T(psttYear) ) ;                        
                                        {
                                        if( !idSlot ) //SHOULD BE IMPOSSIBLE
                                        stYearToHeal.sinkF( tinBaseP , idSlot , psttYear , flSTACKsINK_UNIQUE ) ;
                                        ZE( countT , idSlot ) ;
                                        etThread.strMakeF( tinBaseP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                                        ZE( strokeS* , psttYear ) ;
                                        _IO_
                                    {
                                    if( tally > 1 )
                                    countT tally = swTallyByYear ;
                                    psttzYear = (strokeS*)swTallyByYear.leverF( tinBaseP , idf ) ;
                                    _IO_
                                {
                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                countT cFlavors = swTallyByYear.cFlavorsF( tinBaseP ) ;
                                _IO_
                            {
                            if( !bAbort )

                            while( ~hSwsPathToArchives ) ;
                            }
                                etThread.delF( tinBaseP , pstt1PathToYear ) ;
                                }
                                    //etThread.traceF( tinBaseP , T("[tYear,tally]:    ")+tYear+tb4+TF2((countT)swTallyByYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    swTallyByYear ++ ;
                                    psttzYear = tYear ;

                                    }
                                        etThread.delF( tinBaseP , psttYear ) ;
                                        tYear = T(psttYear) ;
                                        etThread.strWordF( tinBaseP , psttYear , psttc1 , sttq , sttSlash , - 2 ) ; ___( psttYear ) ;
                                        ZE( strokeS* , psttYear ) ;
                                    {
                                    TN( tYear , "" ) ;
                                    _IO_
                                {
                                FORsTRINGSiN1( pstt1PathToYear )
                                etThread.strConvertToLowerCaseF( tinBaseP , pstt1PathToYear ) ;
                                }
                                    }
                                        break ;
                                        bAbort = 1 ;
                                        etThread.delF( tinBaseP , pstt1PathToYear ) ;
                                        etThread.traceF( tinBaseP , T("exception: diskFindFileOrDirF failed [tPathToArchive]:    ")+tPathToArchive ) ;
                                        POOPR
                                    {
                                    if( POOP )
                                    ((tinFullS&)tinBaseP).pEtScratch->diskFindFileOrDirF( tinBaseP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                                    SCOOPS
                                    _IO_
                                {
                                IFsCRATCH
                                patternC pat( tinBaseP , etThread , tYearPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                                ZE( strokeS* , pstt1PathToYear ) ;

                                //etThread.traceF( tinBaseP , T("new code [tPathToArchive]:    ")+tPathToArchive ) ;
                                TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchive)+tSlash ;
                                strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveName.downF( tinBaseP , hSwsPathToArchives ) ;
                                _IO_
                            {
                            do
                            handleC hSwsPathToArchives( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            strokeS sttSlash( '/' ) ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

                            switchC swTallyByYear( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzYear ) ;
                            ZE( strokeS* , psttzYear ) ;
                            _IO_
                        {
                        stackC stYearToHeal( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

                        // FOR EACH YEAR FOLDER (ALL YEARS FOR THIS ARCHIVE NAME (EXAMPLE: ALL YEAR PATHS FOR EVERY YEAR FOR "wo.ideafarm"), LAUNCH A FILE RECORD COLLECTION THREAD
                        _IO_
                    {
                    if( cArchivesWithThisName > 1 )
                    etThread.traceF( tinBaseP , T("[cArchivesWithThisName,archive]:    ")+TF2(cArchivesWithThisName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzArchive) ) ;
                    swsPathToArchivesByArchiveName.ungrabF( tinBaseP ) ;
                    countT cArchivesWithThisName = swsPathToArchivesByArchiveName ;
                    psttzArchive = (strokeS*)swsPathToArchivesByArchiveName.leverF( tinBaseP , idf ) ;
                    swsPathToArchivesByArchiveName.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                    _IO_
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )    // FOR EACH ARCHIVE NAME (EXAMPLE: "wo.ideafarm")
                swsPathToArchivesByArchiveName.ungrabF( tinBaseP ) ;
                countT cFlavors = swsPathToArchivesByArchiveName.cFlavorsF( tinBaseP ) ;
                swsPathToArchivesByArchiveName.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                TN( tYearPattern , "?" "?" "?" "?" "/" ) ;                                                              //20221118@1747: "????/" PROUCES A SPURIOUS COMPILER ERROR INVOLVING TRIGRAPH
                //TN( tYearPattern , "1999/" ) ;
                //TN( tYearPattern , "1234/" ) ;
                _IO_
            {
            if( !bAbort )

            //stJob << (byteT*)0 ; pbDebug = (byteT*)&stJob[ - 1 ] ; etThread.traceF( tinBaseP , TF2((countT)pbDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; new( 0 , tinBaseP , pbDebug , sizeof( jobS ) ) jobS( tinBaseP , etThread , IDtYPEjOB_NULL , T("4-to") , T("4-from") ) ;
            //stJob << (byteT*)0 ; pbDebug = (byteT*)&stJob[ - 1 ] ; etThread.traceF( tinBaseP , TF2((countT)pbDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; new( 0 , tinBaseP , pbDebug , sizeof( jobS ) ) jobS( tinBaseP , etThread , IDtYPEjOB_NULL , T("3-to") , T("3-from") ) ;
            //stJob << (byteT*)0 ; pbDebug = (byteT*)&stJob[ - 1 ] ; etThread.traceF( tinBaseP , TF2((countT)pbDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; new( 0 , tinBaseP , pbDebug , sizeof( jobS ) ) jobS( tinBaseP , etThread , IDtYPEjOB_NULL , T("2-to") , T("2-from") ) ;
            //stJob << (byteT*)0 ; pbDebug = (byteT*)&stJob[ - 1 ] ; etThread.traceF( tinBaseP , TF2((countT)pbDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; new( 0 , tinBaseP , pbDebug , sizeof( jobS ) ) jobS( tinBaseP , etThread , IDtYPEjOB_NULL , T("1-to") , T("1-from") ) ;
            //ZE( byteT* , pbDebug ) ;
            //TO TEST

            swsPathToArchivesByArchiveName.lockIfF( tinBaseP ) ;
            }
                }
                    etThread.delF( tinBaseP , pstt1Archives ) ;
                    }
                        }
                            }
                                swsPathToArchivesByArchiveName.sinkF( tinBaseP , countTC() , psttPathArchives ) ;                           // EXAMPLE: "///c/ipdos.arhives/"

                                psttzArchive = tArchive ;

                                etThread.traceF( tinBaseP , T("    [tPathArchives,tArchive]:    ")+T(psttPathArchives)+tb4+tArchive ) ;

                                }
                                    etThread.delF( tinBaseP , psttShorter ) ;
                                    tArchive = T(psttShorter) ;
                                    etThread.strSubstringF( tinBaseP , psttShorter , idf , idl , tArchiveSlash ) ; ___( psttShorter ) ;
                                    ZE( strokeS* , psttShorter ) ;
                                {
                                if( idl )
                                countT idl = tArchiveSlash.csF( tinBaseP ) ? tArchiveSlash.csF( tinBaseP ) - 1 : 0 ;
                                countT idf = 1 ;
                                TN( tArchive , "" ) ;                                                                                   // EXAMPLE: "wo.ideafarm"

                                }
                                    etThread.delF( tinBaseP , psttArchiveSlash ) ;
                                    tArchiveSlash = T(psttArchiveSlash) ;
                                    etThread.strBisectF( tinBaseP , psttPathArchives , psttArchiveSlash , psttc1 , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathArchives ) ; ___( psttArchiveSlash ) ;
                                    ZE( strokeS* , psttArchiveSlash ) ;
                                {
                                TN( tArchiveSlash , "" ) ;                                                                              // EXAMPLE: "wo.ideafarm/"
                                ZE( strokeS* , psttPathArchives ) ;                                                                     // EXAMPLE: "///c/ipdos.arhives/"

                                etThread.traceF( tinBaseP , T("processing archive ")+T(psttc1) ) ;                                          // EXAMPLE: "///c/ipdos.arhives/wo.ideafarm/"
                                _IO_
                            {
                            FORsTRINGSiN1( pstt1Archives )
                            _IO_
                        {
                        if( !bAbort )

                        }
                            }
                                bAbort = 1 ;
                                etThread.traceF( tinBaseP , T("exception:  diskFindFileOrDirF [tLikeArchives]:    ")+tLikeArchives ) ;
                                POOPR
                            {
                            if( POOP )
                            RETRYsCR( 8 , diskFindFileOrDirF( tinBaseP , pstt1Archives , tLikeArchives ) ) ___( pstt1Archives ) ;
                            SCOOPS
                            _IO_
                        {
                        IFsCRATCH
                        _IO_
                    {
                    ZE( strokeS* , pstt1Archives ) ;
                    _IO_
                {
                TN( tLikeArchives , "///?/ipdos.archives/" ) ;
                _IO_
            {
            switchStackC swsPathToArchivesByArchiveName( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzArchive , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
            ZE( strokeS* , psttzArchive ) ;
            ZE( boolT , bAbort ) ;
            // LOAD swsPathToArchivesByArchiveName WITH VALUES LIKE "///c/ipdos.arhives/" SWITCHED ON VALUES LIKE "wo.ideafarm"
            _IO_
        {
        if( !ether )

        }
            }
                if( !bWaitWoDay ) etThread.traceF( tinBaseP , T("napped  for a tick") ) ;
                ++ s ; ether.osSleepF( tinBaseP , TICK >> 0 ) ;
                cNaps ++ ;
                if( !cNaps ) etThread.traceF( tinBaseP , T(bWaitWoDay?"napping for a day":"napping for a tick") ) ;
                _IO_
            {
            else
            }
                break ;
                if( bWaitWoDay ) etThread.traceF( tinBaseP , T("napped  for a day") ) ;
            {
            )
                (  bWaitWoDay && time2E )            // A DAY'S NAP IS     REQUIRED AND I'VE NAPPED FOR A DAY
                ||
                ( !bWaitWoDay && cNaps  )            // A DAY'S NAP IS NOT REQUIRED AND I'VE NAPPED WO TIME
            (
            if

            etThread.osTimeSubtractF( tinBaseP , time1E , time2E , time1AOK , time2AOK ) ;
            etThread.osTimeNowF( tinBaseP , time1E , time2E ) ;
            ZE( sCountT , time2E ) ;
            ZE( countT  , time1E ) ;

            boolT bWaitWoDay = !!time2AOK ;
            _IO_
        {
        while( !ether )
        ZE( countT , cNaps ) ;
        _IO_
    {
    while( !ether && !POOP )
    ZE( sCountT , time2AOK ) ;
    ZE( countT  , time1AOK ) ;

    etThread.traceF( tinBaseP , T("napping for a half tick so you can plug in devices to heal") ) ;
    ++ s ; ether.osSleepF( tinBaseP , TICK >> 1 ) ;
    etThread.traceF( tinBaseP , T("napping for a half tick so you can plug in devices to heal") ) ;
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

    etThread.osThreadF( TaRG3fLAGScBtLS( tmDoJobF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&stJob ) ;
    stackC stJob( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_BLOB | flSTACKc_ALLOWzE , sizeof( jobS ) ) ;

    TN( tSlash , "/" ) ;
    TN( tb4    , "    " ) ;
    _IO_
{
TODO

DONE( tmExecutiveHealYearF )
}
    dec02AM( cExecutiveHealYearP ) ;
    }
        }
            etThread.traceF( tinBaseP , T("done for archive [bAbort,archive]:    ")+TF2(bAbortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzArchiveP) ) ;

            }
                }
                    }
                        if( POOP ) POOPR
                        ((tinFullS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tLong , 1 ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/status.")+tArchive+tDot+tYear+T(".lath.file.completed.ttt") ;

                    etThread.boxPutF( tinBaseP , tLong , tBody , tBody.csF( tinBaseP ) ) ;
                    TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/status.")+tArchive+tDot+tYear+T(".completed.ttt") ;

                    TN( tBody , "" ) ; tBody = TT(time1N,time2N) + T("\r\nIPDOS (tm) Archive Healer\r\nDelete this file to cause Healer to not wait to heal this year.\r\n") ;
                    etThread.osTimeNowF( tinBaseP , time1N , time2N ) ;
                    ZE( sCountT , time2N ) ;
                    ZE( countT  , time1N ) ;
                {
                if( !bAbortP )

                etThread.delF( tinBaseP , *(byteT**)&ppsttzPathToYear ) ;
                }
                    while( ~hWalk && !bAbortP ) ;
                    }

                        }
                            //++ s ; ether.osSleepF( tinBaseP , TOCK ) ;
                            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

                            }
                                while( ~hStkMeta ) ;
                                }
                                    DELzOMBIE( pfmOuter ) ;

                                    }
                                        DELzOMBIE( pd ) ;
                                        imageCompareS* pd = picOuter + offd ;
                                    {
                                    for( countT offd = 0 ; offd < cResultStructsNeeded ; offd ++ )

                                    fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + cResultStructsNeeded ) ;
                                    imageCompareS* picOuter  = (imageCompareS*)&stMeta.downF( tinBaseP , hStkMeta ) ;
                                {
                                do
                                handleC hStkMeta( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( stMeta )
                            //etThread.traceF( tinBaseP , T("deleting metadata [cPlates]:    ")+TF2(stMeta,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            }
                                etThread.boxPutF( tinBaseP , tLong , tShort , tShort.csF( tinBaseP ) ) ;
                                TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/status.")+tArchive+tDot+tYear+T(".lath.file.completed.ttt") ;
                            {
                            if( !bAbortP )

                            //etThread.traceF( tinBaseP , T("healed  [tShort]:    ")+tShort ) ;
                            while( !ether && bCompareFail ) ;
                            }
                                }
                                    }
                                        break ;
                                        bAbortP = 1 ;
                                        etThread.traceF( tinBaseP , T("exception: compare failed 8 times [tShort]:    ")+tShort ) ;
                                    {
                                    if( ++ cCompareFail == 8 )
                                {
                                if( bCompareFail )

                                //etThread.traceF( tinBaseP , T("processed  [tShort,bCompareFail]:    ")+tShort+tb4+TF2(bCompareFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // ****                                                                                                                                  *******************************************************************
                                // ****  END:    COMPARE ALL COPIES OF THIS SHORT FILE NAME.  THIS IS RETRIED UNTIL ALL COMPARISONS COMPLETE WITHOUT AN EXCEPTION EVENT  *******************************************************************
                                // ****                                                                                                                                  *******************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************

                                }
                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                *************************************************************************************************************************************************************************************
                                    // ****  END:    HEAL  *************************************************************************************************************************************************************************************
                                    // ****                *************************************************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************

                                    }
                                        }
                                            }
                                                etThread.delF( tinBaseP , psttFrom ) ;
                                                etThread.delF( tinBaseP , psttTo   ) ;

                                                stJobP.ungrabF( tinBaseP ) ;
                                                stJobP << (byteT*)0 ; new( 0 , tinBaseP , (byteT*)&stJobP[ - 1 ] , sizeof( jobS ) ) jobS( tinBaseP , etThread , IDtYPEjOB_COPY , psttTo , psttFrom ) ;
                                                stJobP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                                                //etThread.traceF( tinBaseP , T("new      [psttTo,psttFrom]:    ")+TF2((countT)psttTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)psttFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                                //etThread.traceF( tinBaseP , T("copying [idFrom,new,old,idFrom]:    ")+TF2(idFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttTo)+tb4+T(psttFrom) ) ;

                                                etThread.strMakeF( tinBaseP , LF , psttFrom , (strokeS*)stFrom[ idFrom ] ) ; ___( psttFrom ) ;
                                                ZE( strokeS* , psttFrom ) ;

                                                countT idFrom = 1 + ( cDone ++ % cFrom ) ;

                                                stTo >> psttTo ;
                                                ZE( strokeS* , psttTo ) ;
                                            {
                                            while( stTo )
                                            ZE( countT , cDone ) ;
                                            countT cFrom = stFrom ;

                                            while( ~hStPathToYear ) ;
                                            }
                                                }
                                                    if( !idSlot ) etThread.delF( tinBaseP , psttLong ) ;
                                                    stTo.sinkF( tinBaseP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ;
                                                    ZE( countT , idSlot ) ;
                                                    //etThread.traceF( tinBaseP , T("sinking to stTo 2 [long]:    ")+T(psttLong) ) ;
                                                {
                                                else
                                                if( stFrom( psttLong ) ) etThread.delF( tinBaseP , psttLong ) ;

                                                etThread.strMakeF( tinBaseP , LF , psttLong , T(psttPathToYear)+tShort ) ; ___( psttLong ) ;
                                                ZE( strokeS* , psttLong ) ;

                                                strokeS* psttPathToYear = (strokeS*)stPathToYear.downF( tinBaseP , hStPathToYear ) ;
                                            {
                                            do
                                            handleC hStPathToYear( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                            while( ~hStUnique ) ;
                                            }
                                                }
                                                    while( ~hStkInner ) ;
                                                    }
                                                        }
                                                            if( !idSlot ) etThread.delF( tinBaseP , psttLong ) ;
                                                            }
                                                                stTo.sinkF( tinBaseP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                                //etThread.traceF( tinBaseP , T("sunk into stTo [cPlatesBefore,long]:    ")+TF2(stTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                            {
                                                            else
                                                            }
                                                                stFrom.sinkF( tinBaseP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                                //etThread.traceF( tinBaseP , T("sunk into stFrom [cPlatesBefore,long]:    ")+TF2(stFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                            {
                                                            if( bYoungestNotAlone && bWinner )
                                                            ZE( countT , idSlot ) ;

                                                            etThread.strMakeF( tinBaseP , LF , psttLong , T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ) ; ___( psttLong ) ;
                                                            ZE( strokeS* , psttLong ) ;
                                                        {
                                                        if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) )

                                                        }
                                                            }
                                                                break ;
                                                                bMatchImage = 0 ;
                                                            {
                                                            if( picUnique[ offc ] - picInner[ offc ] )
                                                        {
                                                        for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ )
                                                        boolT bMatchImage = 1 ;

                                                        //picInner->traceF( tinBaseP , T("inner :    ") ) ;
                                                        fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                                        imageCompareS* picInner  = (imageCompareS*)&stMeta.downF( tinBaseP , hStkInner ) ;
                                                    {
                                                    do
                                                    handleC hStkInner( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                {

                                                //pfmUnique->traceF( tinBaseP , stPathToYear , T(bYoungestNotAlone?"reporting tallies (youngestNotAlone):    ":"reporting tallies            (other):    ") ) ;

                                                //etThread.traceF( tinBaseP , T("[bYoungestNotAlone,bWinner,cVotes,cVotesMax]:    ")+TF2(bYoungestNotAlone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bWinner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pfmUnique->cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cVotesMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                boolT bWinner           = pfmUnique->cVotes         == cVotesMaxYoungestNotAlone      ;
                                                boolT bYoungestNotAlone = pfmUnique->timeModRounded == timeModRoundedYoungestNotAlone ;

                                                //for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ ) picUnique[ offc ].traceF( tinBaseP , T("reporting tallies:    ") ) ;

                                                //picUnique->traceF( tinBaseP , T("unique:    ") ) ;
                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hStUnique ) ;
                                            {
                                            do
                                            handleC hStUnique( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            stackC stTo(     tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                                            stackC stFrom(   tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                                        {
                                        else
                                        }
                                            etThread.delF( tinBaseP , psttu ) ;
                                            while( !bAbortP && ~hStkInner ) ;
                                            }
                                                etThread.delF( tinBaseP , psttLongFrom ) ;
                                                etThread.delF( tinBaseP , psttLongTo   ) ;

                                                stJobP.ungrabF( tinBaseP ) ;
                                                stJobP << (byteT*)0 ; new( 0 , tinBaseP , (byteT*)&stJobP[ - 1 ] , sizeof( jobS ) ) jobS( tinBaseP , etThread , IDtYPEjOB_MOVEuNIQUE , psttLongTo , psttLongFrom , psttu ) ;
                                                stJobP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                                                etThread.strReplaceF( tinBaseP , psttLongTo , psttLongFrom , tPathArchives , !bLonely ? tPathRejects : tPathLonely ) ; ___( psttLongTo ) ;
                                                ZE( strokeS* , psttLongTo ) ;
                                                //P:PERSONALITY: LONELY FILES (ONLY 1 COPY) ARE MOVED OUT OF ARCHIVE INTO A "LONELY" DIRECTORY

                                                etThread.strMakeF( tinBaseP , LF , psttLongFrom , T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ) ; ___( psttLongFrom ) ;
                                                ZE( strokeS* , psttLongFrom ) ;

                                                fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                                imageCompareS* picInner  = (imageCompareS*)&stMeta.downF( tinBaseP , hStkInner ) ;
                                            {
                                            do
                                            handleC hStkInner( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                            etThread.strUniqueF( tinBaseP , psttu ) ; ___( psttu ) ;
                                            ZE( strokeS* , psttu ) ;

                                            etThread.traceF( tinBaseP , T("no, or too many (more than 1), winners (authoritative copies) so i will move all copies [bLonely,file]:    ")+TF2(bLonely,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
                                            boolT bLonely = cCopies <= 1 ;
                                        {
                                        if( !cWinners || cWinners > 1 )

                                        }
                                            while( ~hSt ) ;
                                            }
                                                cWinners ++ ;
                                                )
                                                    pfmUnique->cVotes == cVotesMaxYoungestNotAlone
                                                    &&
                                                    timeModRoundedYoungestNotAlone == pfmUnique->timeModRounded
                                                (
                                                if

                                                //picUnique->traceF( tinBaseP , T("unique:    ") ) ;
                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                                            {
                                            do
                                            handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        if( cVotesMaxYoungestNotAlone )        // IF ALL ARE ALONE THEN THERE WILL BE NO WINNER
                                        ZE( countT , cWinners ) ;

                                        // RULE; TO WIN, A SLOT MUST HAVE A "YOUNGEST NOT ALONE" AGE AND BE "NOT ALONE" AND HAVE THE MAXIMUM VOTES FOR SLOTS YOUNGEST AND NOT ALONE
                                        //P:PERSONALITY: RULES FOR "WINNING": A stRecUnique SLOT "WINNING" MEANS THAT THE SLOT IS DEEMED TO BE AN AUTHORITATIVE IMAGE FOR THE FILE

                                        }
                                            while( ~hSt ) ;
                                            }
                                                }
                                                    if( pfmUnique->cVotes > 1 && cVotesMaxYoungestNotAlone < pfmUnique->cVotes ) cVotesMaxYoungestNotAlone = pfmUnique->cVotes ;
                                                {
                                                if( timeModRoundedYoungestNotAlone == pfmUnique->timeModRounded )

                                                }
                                                    if(                          cVotesMaxYoungest         < pfmUnique->cVotes ) cVotesMaxYoungest         = pfmUnique->cVotes ;
                                                {
                                                if( timeModRoundedYoungest == pfmUnique->timeModRounded )

                                                //picUnique->traceF( tinBaseP , T("unique:    ") ) ;
                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                                            {
                                            do
                                            handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        if( timeModRoundedYoungestNotAlone )        // IF ALL ARE ALONE THEN THERE WILL BE NO WINNER
                                        ZE( countT , cVotesMaxYoungestNotAlone ) ;
                                        ZE( countT , cVotesMaxYoungest ) ;

                                        }
                                            while( ~hSt ) ;
                                            }
                                                if( pfmUnique->cVotes > 1 && timeModRoundedYoungestNotAlone < pfmUnique->timeModRounded ) timeModRoundedYoungestNotAlone = pfmUnique->timeModRounded ;

                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                                            {
                                            do
                                            handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        ZE( countT , timeModRoundedYoungestNotAlone ) ;
                                        // SET timeModRoundedYoungestNotAlone

                                        }
                                            while( ~hSt ) ;
                                            }
                                                while( ~hStkOuter ) ;
                                                }
                                                    if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) ) pfmUnique->cVotes ++ ;

                                                    }
                                                        }
                                                            break ;
                                                            bMatchImage = 0 ;
                                                        {
                                                        if( picUnique[ offc ] - picInner[ offc ] )
                                                    {
                                                    for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ )
                                                    boolT bMatchImage = 1 ;

                                                    //}
                                                    //    pfmInner->traceF( tinBaseP , stPathToYear , T("inner : ") ) ;
                                                    //    picInner->traceF( tinBaseP , T("inner :    ") ) ;
                                                    //{
                                                    //if( bChatter )
                                                    fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                                    imageCompareS* picInner  = (imageCompareS*)&stMeta.downF( tinBaseP , hStkOuter ) ;
                                                {
                                                do
                                                handleC hStkOuter( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                                if( timeModRoundedYoungest < pfmUnique->timeModRounded ) timeModRoundedYoungest = pfmUnique->timeModRounded ;

                                                //}
                                                //    pfmUnique->traceF( tinBaseP , stPathToYear , T("unique: ") ) ;
                                                //    picUnique->traceF( tinBaseP , T("unique:    ") ) ;
                                                //{
                                                //if( bChatter )
                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                                            {
                                            do
                                            handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        ZE( countT , timeModRoundedYoungest ) ;
                                        // TALLY cVotes AND SET timeModRoundedYoungest

                                        }
                                            bChatter = 1 ;
                                            etThread.traceF( tinBaseP , T("lengths or times or images differ [tShort]:    ")+tShort ) ;
                                        {
                                        if( stRecUnique > 1 )
                                        ZE( boolT , bChatter ) ;
                                    {
                                    else                            // EVEN IF THERE IS ONLY WO PLATE, THERE IS STILL WORK TO DO BECAUSE THE FILE MIGHT NEED TO BE COPIED TO DESTINATIONS THAT DON'T HAVE IT
                                    }
                                        break ;
                                        bAbortP = 1 ;
                                        etThread.traceF( tinBaseP , T("exception: stRecUnique is empty") ) ;
                                    {
                                    if( !stRecUnique ) //SHOULD  BE IMPOSSIBLE

                                    while( ~hStkOuter ) ;
                                    do stRecUnique.sinkF( tinBaseP , countTC() , (byteT*)&stMeta.downF( tinBaseP , hStkOuter ) , flSTACKsINK_UNIQUE , subtractFileMetaF ) ;
                                    stackC stRecUnique( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , stPathToYear * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ;
                                    handleC hStkOuter( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                *************************************************************************************************************************************************************************************
                                    // ****  BEGIN:  HEAL  *************************************************************************************************************************************************************************************
                                    // ****                *************************************************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************
                                {
                                if( !bCompareFail && !ether && cCopies )
                                //etThread.traceF( tinBaseP , T("[cFound,file]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postzShort) ) ;

                                // PHASE 4: COPY TO ALL ARCHIVE CONTAINERS THAT DO NOT HAVE A COPY OF THIS FILE NAME
                                // PHASE 3: OVERWRITE ALL COPIES THAT DO NOT MATCH THIS UNIQUE META
                                // PHASE 2: IS THIS UNIQUE META VERIFIED (cVotes > 1)?
                                // PHASE 1: IDENTIFY THE UNIQUE META WITH THE LATEST FILE DATE
                                // HEALING ACTION HAS PHASES
                                // COMPARE AND FILE META FOR THIS FILE ARE SET AND READY FOR ANALYSIS AND HEALING ACTION
                                // THESE COMMENTS ARE OBSOLETED BY ACTUAL CODE WHICH CONTRADICTS THEM

                                while( !ether && ~hStkOuter ) ;
                                }
                                    if( bCompareFail ) break ;

                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                                      ***************************************************************************************************************************************************************
                                    // ****  END:    FOR EACH COPY OF THIS FILE  ***************************************************************************************************************************************************************
                                    // ****                                      ***************************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************

                                    etThread.delF( tinBaseP ,            pcBitsShiftLeftHeInMine ) ;
                                    etThread.delF( tinBaseP ,            pcBitsShiftLeftMeInHis  ) ;
                                    etThread.delF( tinBaseP , *(byteT**)&ppIdResultHeInMine      ) ;
                                    etThread.delF( tinBaseP , *(byteT**)&ppIdResultMeInHis       ) ;
                                    etThread.delF( tinBaseP ,            pcbwInner               ) ;
                                    etThread.delF( tinBaseP , *(byteT**)&ppbwInner               ) ;

                                    }
                                        }
                                            etThread.delF( tinBaseP , *(byteT**)&pfwsInner ) ;

                                            etThread.delF( tinBaseP , pEqual ) ;
                                            }
                                                }
                                                    //etThread.traceF( tinBaseP , T(pEqual[offo]?"        set other and myself to BITSrESULT_EQUAL because images match [offo]:    ":"        set other and myself to BITSrESULT_NOTeQUAL because images differ [offo]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                                    }
                                                        //etThread.traceF( tinBaseP , T("after  [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                                        *ppIdResultMeInHis[  offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftMeInHis[  offo ] ;
                                                        *ppIdResultHeInMine[ offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftHeInMine[ offo ] ;
                                                        //etThread.traceF( tinBaseP , T("before [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                                    {
                                                    else
                                                    }
                                                        *ppIdResultMeInHis[  offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftMeInHis[  offo ] ;
                                                        *ppIdResultHeInMine[ offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftHeInMine[ offo ] ;
                                                    {
                                                    if( pEqual[ offo ] )
                                                {
                                                for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ )
                                            {
                                            if( !bCompareFail )

                                            THREADmODE2rESTORE
                                            }
                                                //etThread.delF( tinBaseP , *(byteT**)&pfwsOuter ) ;
                                                //etThread.traceF( tinBaseP , T("del [pfwsOuter]:    ")+TF3((countT)pfwsOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;

                                                }
                                                    }
                                                        bCompareFail = 1 ;
                                                        etThread.traceF( tinBaseP , T("exception: could not dt pfwsOuter [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    DEL( pfwsOuter ) ;
                                                    SCOOPS
                                                {

                                                }
                                                    bAbortP = 1 ;
                                                    etThread.traceF( tinBaseP , T("exception [cbUsed,cbDone]:    ")+TT(pcbUsed[0],pcbUsed[1])+tb4+TT(pcbDone[0],pcbDone[1])+tb4+tLongOuter ) ;
                                                    countT* pcbDone = (countT*)&cbDone ;
                                                    countT* pcbUsed = (countT*)&pfmOuter->cbUsed ;
                                                {
                                                if( !bCompareFail && !ether && cbDone != pfmOuter->cbUsed ) //SHOULD BE IMPOSSIBLE

                                                }
                                                    cbDone += cbwOuter ;

                                                    if( bCompareFail ) break ;

                                                    }
                                                        }
                                                            pcbwInner[ offi ] = 0 ;  // TELLS  TO GET ANOTHER WINDOW
                                                            ppbwInner[ offi ] = 0 ;

                                                            }
                                                                }
                                                                    thirdC::dosSleepWinkIF( tinBaseP ) ;
                                                                    etThread.traceF( tinBaseP , T("exception while trying to access memory for a mapped file.  will retry [idWindow,idTry]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                                {
                                                                else
                                                                }
                                                                    break;
                                                                    }
                                                                        //etThread.traceF( tinBaseP , T("images match between unique and inner [idWindow,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                                    {
                                                                    else
                                                                    }
                                                                        //etThread.delF( tinBaseP , psttGen ) ;
                                                                        //etThread.traceF( tinBaseP , T("wrote inner [gen]:    ")+T(psttGen) ) ;
                                                                        //etThread.boxPutGenerationF( tinBaseP , psttGen , tLikeInner+TF3(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) , TUCK , ppbwInner[ offi ] , cbwOuter ) ; ___( psttGen ) ;

                                                                        //etThread.delF( tinBaseP , psttGen ) ;
                                                                        //etThread.traceF( tinBaseP , T("wrote outer [gen]:    ")+T(psttGen) ) ;
                                                                        //etThread.boxPutGenerationF( tinBaseP , psttGen , tLikeOuter , TUCK , pbwOuter , cbwOuter ) ; ___( psttGen ) ;
                                                                        //ZE( strokeS* , psttGen ) ;

                                                                        pEqual[ offi ] = 0 ;
                                                                        etThread.traceF( tinBaseP , T("difference detected between unique and inner [idWindow,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                                    {
                                                                    if( etThread.memCompareF( tinBaseP , pbwOuter , ppbwInner[ offi ] , cbwOuter ) )
                                                                    //etThread.traceF( tinBaseP , T("attempting to compare images [idWindow,idTry,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                                {
                                                                if( !_restart )

                                                                idTry ++ ;
                                                                _restart.flags |= flRESTARTc_QUIET ;
                                                                RESTART
                                                            {
                                                            while( !ether )
                                                            ZE( countT , idTry ) ;
                                                        {
                                                        else
                                                        }
                                                            break ;
                                                            bDone = 1 ;
                                                            //etThread.traceF( tinBaseP , T("done inspecting images [idWindow]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        {
                                                        if( !pbwOuter || !cbwOuter )

                                                        }
                                                            break ;  // REDO THIS SHORT NAME FROM THE BEGINNING
                                                            bCompareFail = 1 ;
                                                            etThread.traceF( tinBaseP , T("byte by byte comparison failed [tLongOuter]:    ")+tLongOuter ) ;
                                                        {
                                                        )
                                                              cbwOuter !=   pcbwInner[ offi ]
                                                            ||
                                                            !!cbwOuter != !!pcbwInner[ offi ]
                                                            ||
                                                            !!pbwOuter != !!ppbwInner[ offi ]
                                                        (
                                                        if

                                                        //etThread.traceF( tinBaseP , T("fed this [(countT)ppbwInner[offi],ppbwInner[offi]]:    ")+TF3((countT)ppbwInner[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+T(ppbwInner[offi]) ) ;

                                                        }
                                                            }
                                                                break ;  // REDO THIS SHORT NAME FROM THE BEGINNING
                                                                bCompareFail = 1 ;
                                                                etThread.traceF( tinBaseP , T("exception:  pfwsInner[ offi ].getF [tLongOuter]:    ")+tLongOuter ) ;
                                                                POOPR
                                                            {
                                                            if( POOP )
                                                            RETRY( 8 , ( ppbwInner[ offi ] = 0 , pcbwInner[ offi ] = 0 , pfwsInner[ offi ].getF( tinBaseP , ppbwInner[ offi ] , pcbwInner[ offi ] ) ) ) ;
                                                            SCOOPS
                                                        {
                                                        IFsCRATCH
                                                    {
                                                    for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )

                                                    }
                                                        }
                                                            break ;  // REDO THIS SHORT NAME FROM THE BEGINNING
                                                            bCompareFail = 1 ;
                                                            etThread.traceF( tinBaseP , T("exception:  pfwsOuter->getF [tLongOuter]:    ")+tLongOuter ) ;
                                                            POOPR
                                                        {
                                                        if( POOP )
                                                        RETRY( 8 , ( pbwOuter = 0 , cbwOuter = 0 , pfwsOuter->getF( tinBaseP , pbwOuter , cbwOuter ) ) )
                                                        SCOOPS
                                                    {
                                                    IFsCRATCH
                                                    ZE( countT , cbwOuter ) ;
                                                    ZE( byteT* , pbwOuter ) ;

                                                    TN( tLikeInner , "///ideafarm/tmp/debug.inner." ) ; tLikeInner += TF3(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot ;
                                                    TN( tLikeOuter , "///ideafarm/tmp/debug.outer." ) ; tLikeOuter += TF3(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;

                                                    idWindow ++ ;
                                                {
                                                while( !bCompareFail && !ether && !bDone )
                                                ZE( countT , idWindow ) ;
                                                ZE( boolT , bDone ) ;
                                                ZE( count04T , cbDone ) ;

                                                //etThread.traceF( tinBaseP , T("inspecting images [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;

                                                }
                                                    }
                                                        bCompareFail = 1 ;
                                                        etThread.traceF( tinBaseP , T("exception: could not ct pfwsOuter [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    new( 0 , tinBaseP , (byteT*)pfwsOuter , sizeof( fileWindowsC ) ) fileWindowsC( tinBaseP , *((tinFullS&)tinBaseP).pEtScratch , tLongOuter ) ;
                                                    SCOOPS
                                                {

                                                //etThread.traceF( tinBaseP , T("new [pfwsOuter]:    ")+TF3((countT)pfwsOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                                                etThread.newF( tinBaseP , LF , *(byteT**)&pfwsOuter , sizeof( fileWindowsC ) ) ; ___( pfwsOuter ) ;
                                                ZE( fileWindowsC* , pfwsOuter ) ;
                                            {
                                            IFsCRATCH

                                            for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ ) pEqual[ offo ] = 1 ;
                                            etThread.newF( tinBaseP , LF , pEqual , cInnerImagesToInspect ) ; ___( pEqual ) ;
                                            ZE( boolT* , pEqual ) ;
                                            TN( tDot , "." ) ;
                                        {
                                        if( !bCompareFail )

                                        }
                                            }
                                                etThread.delF( tinBaseP , psttLongInner ) ;

                                                }
                                                    }
                                                        break ;
                                                        bCompareFail = 1 ;
                                                        etThread.traceF( tinBaseP , T("exception: could not ct a fileWindowsC instance") ) ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    new( 0 , tinBaseP , (byteT*)( pfwsInner + offi ) , sizeof( fileWindowsC ) ) fileWindowsC( tinBaseP , *((tinFullS&)tinBaseP).pEtScratch , psttLongInner ) ;
                                                    SCOOPS
                                                {
                                                IFsCRATCH

                                                stLongInner >> psttLongInner ;
                                                ZE( strokeS* , psttLongInner ) ;
                                            {
                                            for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )
                                        {
                                        if( pfwsInner )
                                        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                                        etThread.newF( tinBaseP , LF , *(byteT**)&pfwsInner , cInnerImagesToInspect * sizeof( fileWindowsC ) ) ; ___( pfwsInner ) ;
                                        ZE( fileWindowsC* , pfwsInner ) ;

                                        }
                                            break ;
                                            bAbortP = 1 ;                                
                                            etThread.traceF( tinBaseP , T("exception [cInnerImagesToInspect,stLongInner]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+TF2(stLongInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        {
                                        if( stLongInner != cInnerImagesToInspect ) //SHOULD BE IMPOSSIBLE
                                    {
                                    if( !ether && !bAbortP && cInnerImagesToInspect )

                                    }
                                        }
                                            while( !ether && !bAbortP && ~hStkInner ) ;
                                            }
                                                }
                                                    }
                                                        break ;

                                                        }
                                                            }
                                                                bAbortP = 1 ;                                                    
                                                                etThread.traceF( tinBaseP , T("exception: iSlotLongInnr is null") ) ;
                                                                etThread.delF( tinBaseP , psttLongInner ) ;
                                                            {
                                                            if( !idSlotLongInner ) //SHOULD BE IMPOSSIBLE
                                                            stLongInner.sinkF( tinBaseP , idSlotLongInner , psttLongInner , flSTACKsINK_UNIQUE ) ;
                                                            ZE( countT , idSlotLongInner ) ;

                                                            etThread.strMakeF( tinBaseP , LF , psttLongInner , tLongInner ) ; ___( psttLongInner ) ;
                                                            ZE( strokeS* , psttLongInner ) ;

                                                            offResult ++ ;

                                                            pcBitsShiftLeftHeInMine[ offResult ] = cBitsShiftLeftHeInMine ;
                                                            pcBitsShiftLeftMeInHis[  offResult ] = cBitsShiftLeftMeInHis  ;
                                                            ppIdResultHeInMine[      offResult ] = &bitsResultHeInMine    ;
                                                            ppIdResultMeInHis[       offResult ] = &bitsResultMeInHis     ;
                                                        {
                                                        if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                                    {
                                                    case 3 :
                                                    }
                                                        break ;

                                                        }
                                                            cInnerImagesToInspect ++ ;
                                                            //etThread.traceF( tinBaseP , T("incrementing") ) ;
                                                        {
                                                        if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )

                                                        //etThread.traceF( tinBaseP , T("        maybe incrementing cInnerImagesToInspect [bitsResultHeInMine,maskHeInMine,masked,cBitsShiftLeftHeInMine,inner]:    ")+TF2(bitsResultHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(maskHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((bitsResultHeInMine&maskHeInMine),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                                    {
                                                    case 2 :    // COUNT THE NUMBER OF INNER FILES FOR WHICH I MUST INSPECT THE IMAGE (I SET cInnerImagesToInspect HERE)
                                                    }
                                                        break ;

                                                        }
                                                            }
                                                                bitsResultHeInMine |= BITSrESULT_NOTeQUAL << cBitsShiftLeftHeInMine ;
                                                                bitsResultMeInHis  |= BITSrESULT_NOTeQUAL << cBitsShiftLeftMeInHis  ;
                                                                //etThread.traceF( tinBaseP , T("        set other and myself to BITSrESULT_NOTeQUAL because cbUsed differs") ) ;
                                                            {
                                                            if( pfmOuter->cbUsed != pfmInner->cbUsed )
                                                        {
                                                        else if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                                        }
                                                            //etThread.traceF( tinBaseP , T("        setted  myself to BITSrESULT_EQUAL [bitsResultMeInHis]:    ")+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                            bitsResultMeInHis |= BITSrESULT_EQUAL << cBitsShiftLeftMeInHis ;
                                                            //etThread.traceF( tinBaseP , T("        setting myself to BITSrESULT_EQUAL [&bitsResultMeInHis,bitsResultMeInHis,&cBitsShiftLeftMeInHis,cBitsShiftLeftMeInHis]:    ")+TF2(&bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(&cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        {
                                                        if( pfmInner == pfmOuter )
                                                    {
                                                    case 1 :    // SET bitsResult WITHOUT COMPARING FILE IMAGES
                                                {
                                                switch( idPass )

                                                //etThread.traceF( tinBaseP , T("    [idPass,tLongInner]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                                TN( tLongInner , "" ) ; tLongInner = T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ;

                                                countT maskHeInMine = BITSrESULT_ALLbITS << cBitsShiftLeftHeInMine ;
                                                countT maskMeInHis  = BITSrESULT_ALLbITS << cBitsShiftLeftMeInHis  ;

                                                countT cBitsShiftLeftHeInMine =           ( ( pfmInner->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;
                                                countT cBitsShiftLeftMeInHis  =           ( ( pfmOuter->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;

                                                countT& bitsResultHeInMine    = picOuter[ ( pfmInner->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;
                                                countT& bitsResultMeInHis     = picInner[ ( pfmOuter->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;

                                                //picInner->traceF( tinBaseP , T("inner :    ") ) ;
                                                //pfmInner->traceF( tinBaseP , stPathToYear , T("inner: ") ) ;
                                                fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;

                                                //etThread.traceF( tinBaseP , T("    [picInner]:    ")+TF2((countT)picInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                imageCompareS* picInner = (imageCompareS*)&stMeta.downF( tinBaseP , hStkInner ) ;
                                            {
                                            do
                                            handleC hStkInner( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        if( idPass != 3 || cInnerImagesToInspect )

                                        }
                                            etThread.memSetF( tinBaseP , (byteT*)pcBitsShiftLeftHeInMine , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                            etThread.memSetF( tinBaseP , (byteT*)pcBitsShiftLeftMeInHis  , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                            etThread.memSetF( tinBaseP , (byteT*)ppIdResultHeInMine      , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                            etThread.memSetF( tinBaseP , (byteT*)ppIdResultMeInHis       , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                            etThread.memSetF( tinBaseP , (byteT*)pcbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                            etThread.memSetF( tinBaseP , (byteT*)ppbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;

                                            etThread.newF( tinBaseP , LF ,             pcBitsShiftLeftHeInMine , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftHeInMine ) ;
                                            etThread.newF( tinBaseP , LF ,             pcBitsShiftLeftMeInHis  , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftMeInHis  ) ;
                                            etThread.newF( tinBaseP , LF , *(countT**)&ppIdResultHeInMine      , cInnerImagesToInspect ) ; ___( ppIdResultHeInMine      ) ;
                                            etThread.newF( tinBaseP , LF , *(countT**)&ppIdResultMeInHis       , cInnerImagesToInspect ) ; ___( ppIdResultMeInHis       ) ;
                                            etThread.newF( tinBaseP , LF ,             pcbwInner               , cInnerImagesToInspect ) ; ___( pcbwInner               ) ;
                                            etThread.newF( tinBaseP , LF , *(countT**)&ppbwInner               , cInnerImagesToInspect ) ; ___( ppbwInner               ) ;
                                        {
                                        if( idPass == 3 && cInnerImagesToInspect )
                                    {
                                    for( countT idPass = 1 ; !ether && idPass <= 3 ; idPass ++ )
                                    ZE( countT   , offResult               ) ;
                                    ZE( countT*  , pcBitsShiftLeftHeInMine ) ;
                                    ZE( countT*  , pcBitsShiftLeftMeInHis  ) ;
                                    ZE( countT** , ppIdResultHeInMine      ) ;
                                    ZE( countT** , ppIdResultMeInHis       ) ;
                                    ZE( countT*  , pcbwInner               ) ;
                                    ZE( byteT**  , ppbwInner               ) ;
                                    ZE( countT   , cInnerImagesToInspect   ) ;
                                    stackC stLongInner( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

                                    //pfmOuter->traceF( tinBaseP , stPathToYear , T("outer: ") ) ;
                                    //etThread.traceF( tinBaseP , T("[tLongOuter]:    ")+tLongOuter ) ;
                                    TN( tLongOuter , "" ) ; tLongOuter = T((strokeS*)stPathToYear[pfmOuter->idSlotPathToYear])+tShort ;

                                    //picOuter->traceF( tinBaseP , T("outer :    ") ) ;
                                    fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + cResultStructsNeeded ) ;
                                    imageCompareS* picOuter  = (imageCompareS*)&stMeta.downF( tinBaseP , hStkOuter ) ;

                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                                      ***************************************************************************************************************************************************************
                                    // ****  BEGIN:  FOR EACH COPY OF THIS FILE  ***************************************************************************************************************************************************************
                                    // ****                                      ***************************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************
                                {
                                do
                                handleC hStkOuter( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                // SET ALL COMPARE META ELEMENTS FOR EACH FILE'S IMAGE COMPARE META ARRAY

                                //etThread.traceF( tinBaseP , T("processing [tShort             ]:    ")+tShort ) ;

                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // ****                                                                                                                                  *******************************************************************
                                // ****  BEGIN:  COMPARE ALL COPIES OF THIS SHORT FILE NAME.  THIS IS RETRIED UNTIL ALL COMPARISONS COMPLETE WITHOUT AN EXCEPTION EVENT  *******************************************************************
                                // ****                                                                                                                                  *******************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                            {
                            do
                            ZE( countT , cCompareFail ) ;
                            ZE( boolT  , bCompareFail ) ;

                            countT cCopies = stMeta ;

                            }
                                DEL( pInfoFile ) ;
                                }
                                    new( 0 , tinBaseP , (byteT*)pCursor , sizeof( fileMetaS ) ) fileMetaS( tinBaseP , bAbortP , offh + 1 , time1Mod , time2Mod , cbUsed ) ;

                                    pCursor += cResultStructsNeeded ;
                                    for( countT offs = 0 ; offs < cResultStructsNeeded ; offs ++ ) new( 0 , tinBaseP , (byteT*)( pCursor + offs ) , sizeof( imageCompareS ) ) imageCompareS ;
                                    imageCompareS* pCursor = (imageCompareS*)&(stMeta)[ 1 ] ;

                                    stMeta << (byteT*)0 ;

                                    count04T cbUsed = pInfoFile->cbUsedHigh << sizeof( count02T ) * SB | pInfoFile->cbUsed ;

                                    sCountT time2Mod = pInfoFile->timeWritten2 ;
                                    countT  time1Mod = pInfoFile->timeWritten1 ;
                                {
                                if( pInfoFile )

                                }
                                    }
                                        }
                                            break ;
                                            DEL( pInfoFile ) ;
                                            bAbortP = 1 ;
                                            etThread.traceF( tinBaseP , T("exception:  diskFileQueryF") ) ;
                                            POOPR
                                        {
                                        if( POOP )
                                        RETRYsCR( 8 , diskFileQueryF( tinBaseP , pInfoFile , fi ) ) ; ___( pInfoFile ) ;
                                    {
                                    else
                                    if( POOP ) POOPRqUIET
                                    fileC fi( tinBaseP , (strokeS*)tLong , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 ) ;
                                    SCOOPS
                                {
                                IFsCRATCH
                                ZE( infoFileS* , pInfoFile ) ;

                                //etThread.traceF( tinBaseP , T("    [tLong]:    ")+tLong ) ;
                                TN( tLong , "" ) ; tLong = T(ppsttzPathToYear[offh])+tShort ;
                            {
                            for( countT offh = 0 ; offh < cPathsToYear ; offh ++ )

                            stackC stMeta( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB | flSTACKc_ALLOWzE , cResultStructsNeeded * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ;

                            //etThread.traceF( tinBaseP , T("healing [tShort]:    ")+tShort ) ;
                        {
                        else
                        if( bSkipThisFile ) ; // etThread.traceF( tinBaseP , T("skipping [tShortSkipBeyond,tShort]:    ")+tShortSkipBeyond+tb4+tShort ) ;

                        boolT bSkipThisFile = tShortSkipBeyond.csF( tinBaseP ) && 0 >= etThread.strCompareF( tinBaseP , tShort , tShortSkipBeyond ) ;

                        }
                            break ;
                            bAbortP = 1 ;
                            etThread.traceF( tinBaseP , T("exception: short file name is null length") ) ;
                        {
                        if( !tShort.csF( tinBaseP ) )     //SHOULD BE IMPOSSIBLE

                        }
                            }
                                break ;
                                bAbortP = 1 ;
                                etThread.traceF( tinBaseP , T("exception: could not obtain a pageC instance containing a short file name 2") ) ;
                            {
                            else
                            if( ~page ) tShort = T((const byteT*)page) ;
                            pageC page = jotShortFileNames[ idj ] ;
                        {
                        TN( tShort , "" ) ;

                        countT idj = stIdJot.upF( tinBaseP , hWalk ) ;

                        }
                            etThread.traceF( tinBaseP , T("healing [year,cShortNames,idName,perTuck]:    ")+tYear+tb4+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb+tPerTuck ) ;
                            countT perTuck = ( idName << 8 ) / cShortNames ;
++ idName ;
                        {
                        //if( !( ++ idName % ( TUCK >> 4 ) ) )

                        }
                            break ;
                            bAbortP = 1 ;
                        {
                        if( ether )
                    {
                    do
                    handleC hWalk( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    TN( tb            , " "                        ) ;
                    TN( tPerTuck      , "%"                        ) ;
                    TN( tPathLonely   , "/ipdos.archives.lonely/"  ) ;
                    TN( tPathRejects  , "/ipdos.archives.rejects/" ) ;
                    TN( tPathArchives , "/ipdos.archives/"         ) ;
                    ZE( countT , idName ) ;
                    const countT cShortNames = stIdJot ;
                {
                if( !bAbortP && stIdJot )
                etThread.traceF( tinBaseP , T("processing each short file name in stIdJot") ) ;

                }
                    etThread.delF( tinBaseP , *(byteT**)&pphff            ) ;
                    etThread.delF( tinBaseP , *(byteT**)&ppif             ) ;

                    }
                        }
                            etThread.traceF( tinBaseP , T("final count [year,cShortNames]:    ")+tYear+tb4+TF2(stIdJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            jotPresortedShortsF( tinBaseP , etThread , bAbortP , jotShortFileNames , stIdJot , stPresort , 0 ) ;
                        {
                        if( !bAbortP )

                        if( ether ) bAbortP = 1 ;

                        while( !bAbortP && !POOP && cPathsDone < cPathsToYear ) ;
                        }
                            }
                                //etThread.traceF( tinBaseP , T("accumulating [cShortNames]:    ")+TF2(stIdJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                jotPresortedShortsF( tinBaseP , etThread , bAbortP , jotShortFileNames , stIdJot , stPresort , CsHORTpRESORT ) ;
                            {
                            if( !bAbortP && stPresort >= ( CsHORTpRESORT << 1 ) )
                            //TESTING: if( stPresort > CsHORTpRESORT ) jotPresortedShortsF( tinBaseP , etThread , bAbortP , jotShortFileNames , stIdJot , stPresort , 0 ) ;

                            }
                                }
                                    DEL( ppif[ offh ] ) ;
                                    }
                                        }
                                            etThread.traceF( tinBaseP , T("folder ignored [tFolder]:    ")+tFolder ) ;
                                            }
                                                etThread.delF( tinBaseP , psttFolder ) ;
                                                etThread.delF( tinBaseP , psttnu ) ;
                                                tFolder  = T(psttFolder) ;
                                                etThread.strBisectF( tinBaseP , psttnu , psttFolder , ppif[ offh ]->psttIfoName , T("/") , - 2 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttFolder ) ;
                                                ZE( strokeS* , psttFolder ) ;
                                                ZE( strokeS* , psttnu ) ;
                                            {
                                            TN( tFolder , "" ) ;
                                        {
                                        else
                                        }
                                            }
                                                }
                                                    etThread.traceF( tinBaseP , T("listing [year,idName]:    ")+tYear+tb4+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( !( ++ idName % ( TUCK << 0 ) ) )

                                                //etThread.traceF( tinBaseP , T("presorted [tShort]:    ")+tShort ) ;
                                            {
                                            else
                                            if( !ids ) etThread.delF( tinBaseP , psttShort ) ;
                                            stPresort.sinkF( tinBaseP , ids , psttShort , flSTACKsINK_UNIQUE ) ;
                                            ZE( countT , ids ) ;
                                            etThread.strMakeF( tinBaseP , LF , psttShort , tShort ) ; ___( psttShort ) ;
                                            ZE( strokeS* , psttShort ) ;
                                        {
                                        if( tShort.csF( tinBaseP ) )        // IF NOT A DIRECTORY
                                                                                   
                                        }
                                            etThread.delF( tinBaseP , psttShort ) ;
                                            etThread.delF( tinBaseP , psttnu ) ;
                                            tShort  = T(psttShort) ;
                                            etThread.strBisectF( tinBaseP , psttnu , psttShort , ppif[ offh ]->psttIfoName , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttShort ) ;
                                            ZE( strokeS* , psttShort ) ;
                                            ZE( strokeS* , psttnu ) ;
                                        {
                                        TN( tShort , "" ) ;
                                    {
                                    else
                                    }
                                        continue ;
                                        cPathsDone ++ ;
                                        DEL( pphff[ offh ] ) ;
                                        DEL( ppif[ offh ] ) ;
                                    {
                                    if( bAbortP || !ppif[ offh ] || !ppif[ offh ]->psttIfoName )

                                    }
                                        }
                                            bAbortP = 1 ;
                                            etThread.traceF( tinBaseP , T("exception:  diskFindFileOrDirF") ) ;
                                            POOPR
                                        {
                                        if( POOP )
                                        RETRYsCR( 8 , diskFindFileOrDirF( tinBaseP , ppif[ offh ] , *pphff[ offh ] , ppsttzPathToYear[ offh ] ) ) ___( ppif[ offh ] ) ;
                                        SCOOPS
                                    {
                                    IFsCRATCH
                                {
                                if( pphff[ offh ] )
                            {
                            for( countT offh = 0 ; !bAbortP && offh < cPathsToYear ; offh ++ )
                            // PRESORT WO FILE FROM EACH PATH
                        {
                        do
                        ZE( countT , cPathsDone ) ;

                        //for( countT offh = 0 ; offh < cPathsToYear ; offh ++ ) etThread.traceF( tinBaseP , T("cache [cPaths,off,pstt]:    ")+TF2(cPathsToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(ppsttzPathToYear[offh]) ) ;

                        for( countT offh = 0 ; offh < cPathsToYear ; offh ++ ) pphff[ offh ] = new( 0 , tinBaseP , LF ) handleC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                        for( countT offh = 0 ; offh < cPathsToYear ; offh ++ ) ppsttzPathToYear[ offh ] = (strokeS*)stPathToYear[ 1 + offh ] ;
                    {
                    else
                    if( !ppsttzPathToYear || !pphff || !ppif || ether ) bAbortP = 1 ;

                    etThread.memSetF( tinBaseP , (byteT*)ppif , cPathsToYear * sizeof( infoFileS* ) ) ;
                    etThread.newF( tinBaseP , LF , *(byteT**)&ppif , cPathsToYear * sizeof( infoFileS* ) ) ; ___( ppif ) ;
                    ZE( infoFileS** , ppif ) ;

                    etThread.memSetF( tinBaseP , (byteT*)pphff , cPathsToYear * sizeof( handleC* ) ) ;
                    etThread.newF( tinBaseP , LF , *(byteT**)&pphff , cPathsToYear * sizeof( handleC* ) ) ; ___( pphff ) ;
                    ZE( handleC** , pphff ) ;

                    etThread.newF( tinBaseP , LF , *(byteT**)&ppsttzPathToYear , cPathsToYear * sizeof( strokeS* ) ) ; ___( ppsttzPathToYear ) ;

                    stackC stPresort( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKiGNOREtABS | flSTACKc_SINKrEVERSE , ifcSTACKtYPE_PTR_strokeS ) ;
                    ZE( countT , idName ) ;
                {
                if( !bAbortP )
                ZE( strokeS** , ppsttzPathToYear ) ;                // OPTIMIZATION TO AVOID MANY CALLS TO stackC::operator []

                if( ether ) bAbortP = 1 ;
                        
                stackC stIdJot( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKiGNOREtABS | flSTACKc_SINKrEVERSE ) ;
                jotC jotShortFileNames( tinBaseP , "short.file.names" , flJOTc_WRITE | flJOTc_PRIVATE | flJOTc_DELETE | flJOTc_PURGEoNcT , 1 ) ;                    //A:ASSUME: INPUT IS SORTED ENOUGH THAT A NEWLY ENCOUNTERED SHORT NAME WILL NEVER SINK BEYOND THE NAMES RETAINED BY THE cKeepInactive PARAMETER HERE
            {
            if( cPathsToYear > 1 )

            }
                if( idPass == 1 ) stPathToYear.lockIfF( tinBaseP ) ;

                if( bAbortP ) break ;

                while( !bAbortP && ~hSwsPathToArchives ) ;
                }
                    etThread.delF( tinBaseP , pstt1PathToYear ) ;
                    }
                        }
                            etThread.traceF( tinBaseP , T("stPathToYear [cPlates,ids,psttc1]:    ")+TF2(stPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idSlotPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttc1) ) ;
                            countT idSlotPathToYear = stPathToYear( psttc1 ) ;
                        {
                        else
                        }
                            }
                                break ;
                                bAbortP = 1 ;
                                etThread.traceF( tinBaseP , T("exception: idSlotPathToYear is null") ) ;
                                etThread.delF( tinBaseP , psttPathToYear ) ;
                            {
                            if( !idSlotPathToYear ) //SHOULD BE IMPOSSIBLE
                            //etThread.traceF( tinBaseP , T("maybe sunk into stPathToYear [now,psttPathToYear]:    ")+TF2(stPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttPathToYear) ) ;
                            stPathToYear.sinkF( tinBaseP , idSlotPathToYear , psttPathToYear , flSTACKsINK_UNIQUE ) ;
                            ZE( countT , idSlotPathToYear ) ;

                            etThread.strMakeF( tinBaseP , LF , psttPathToYear , psttc1 ) ; ___( psttPathToYear ) ;
                            ZE( strokeS* , psttPathToYear ) ;
                        {
                        if( idPass == 1 )
                    {
                    FORsTRINGSiN1( pstt1PathToYear )

                    //etThread.traceF( tinBaseP , T("[pstt1PathToYear]:    ")+T(pstt1PathToYear) ) ;
                    etThread.strConvertToLowerCaseF( tinBaseP , pstt1PathToYear ) ;

                    }
                        }
                            break ;
                            bAbortP = 1 ;
                            etThread.traceF( tinBaseP , T("exception:  diskFindFileOrDirF [tPathToArchive]:    ")+tPathToArchive ) ;
                            POOPR
                        {
                        if( POOP )
                        RETRYsCR( 8 , diskFindFileOrDirF( tinBaseP , pstt1PathToYear , tPathToArchive , &pat ) ) ___( pstt1PathToYear ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    patternC pat( tinBaseP , etThread , tYearSlash , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                    ZE( strokeS* , pstt1PathToYear ) ;

                    //if( idPass == 1 ) etThread.traceF( tinBaseP , T("flavor [tPathToArchive]:    ")+tPathToArchive ) ;
                    TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchiveP)+tSlash ;
                    strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveNameP.downF( tinBaseP , hSwsPathToArchives ) ;
                {
                do
                handleC hSwsPathToArchives( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                }
                    cResultStructsNeeded = 1 + cPathsToYear / cResultsPerStruct ;
                    cPathsToYear = stPathToYear ;
                {
                if( idPass == 2 )
            {
            for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
            stackC stPathToYear( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
            ZE( countT   , cResultStructsNeeded ) ;
            ZE( countT   , cPathsToYear         ) ;

            }
                ++ s ; ether.osSleepF( tinBaseP , TOCK ) ;
                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

                }
                    }
                        etThread.delF( tinBaseP , posti ) ;
                        }
                            etThread.traceF( tinBaseP , T("i will skip files recently healed [tShortSkipBeyond]:    ")+tShortSkipBeyond ) ;
                            tShortSkipBeyond = T(posti) ;
                        {
                        else if( posti && costi && *posti )
                             if( POOP                     ) POOPRqUIET
                        ((tinFullS&)tinBaseP).pEtScratch->boxGetF( tinBaseP , posti , costi , tLong , 1 ) ; ___( posti ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/status.")+tArchive+tDot+tYear+T(".lath.file.completed.ttt") ;
                {
                if( !bAbortP )
            {
            TN( tShortSkipBeyond , "" ) ;
        {
        else
        if( !bDoThisYear ) etThread.traceF( tinBaseP , T("skipping this year because it was recently healed AOK") ) ;

        }
            etThread.delF( tinBaseP , posti ) ;
            }
                }
                    if( time2E < 8 ) bDoThisYear = 0 ;
                    etThread.osTimeSubtractF( tinBaseP , time1E , time2E , time1AOK , time2AOK ) ;

                    }
                        etThread.delF( tinBaseP , pstt1w ) ;
                        }
                            if( cDone == 2 ) break ;
                            *( cDone ++ ? &time2AOK : (sCountT*)&time1AOK ) = etThread.strDigitsToSCountF( tinBaseP , psttc1 ) ;
                            etThread.traceF( tinBaseP , T("time word:    ")+T(psttc1) ) ;
                        {
                        FORsTRINGSiN1( pstt1w )
                        ZE( countT  , cDone ) ;
                        etThread.strWordsF( tinBaseP , pstt1w , tTimeAOK , sttq , tDot ) ; ___( pstt1w ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        ZE( strokeS* , pstt1w ) ;

                        etThread.traceF( tinBaseP , T("[year,timeAOK]:    ")+tYear+tb4+tTimeAOK ) ;
                        TN( tTimeAOK , posti ) ;
                        *postc = 0 ;
                    {
                    ZE( sCountT , time2AOK ) ;
                    ZE( countT  , time1AOK ) ;

                    etThread.osTimeNowF( tinBaseP , time1E , time2E ) ;
                    ZE( sCountT , time2E ) ;
                    ZE( countT  , time1E ) ;
                {
                if( postc )
                osTextT* postc = thirdC::c_strstrIF( tinBaseP , posti , "\r\n" ) ;
            {
            else
            if( POOP ) POOPRqUIET
            ((tinFullS&)tinBaseP).pEtScratch->boxGetShadowF( tinBaseP , posti , costi , tLong , 1 ) ; ___( posti ) ;
            TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/status.")+tArchive+tDot+tYear+T(".completed.ttt") ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;

            SCOOPS
        {
        IFsCRATCH
        boolT bDoThisYear = 1 ;

        etThread.traceF( tinBaseP , T("[year]:    ")+tYear ) ;
        TN( tYearSlash , "" ) ; tYearSlash = tYear+T("/") ;
        etThread.delF( tinBaseP , psttYearP ) ;
        TN( tYear , "" ) ; tYear = T(psttYearP) ;

        TN( tArchive , psttzArchiveP ) ;

        TN( tDot    , "." ) ;
        TN( tcr     , "\r\n" ) ;
        TN( tSlash  , "/" ) ;
        TN( tb4     , "    " ) ;
    {
    if( !POOP )

    __Z( psttzArchiveP->idAdam ) ;
    __Z( psttYearP->idAdam ) ;

    stackC&       stJobP                          =       *(stackC*)pTaskP->c6 ;
    boolT&        bAbortP                         =        *(boolT*)pTaskP->c5 ;
    switchStackC& swsPathToArchivesByArchiveNameP = *(switchStackC*)pTaskP->c4 ;
    strokeS*&     psttzArchiveP                   =     *(strokeS**)pTaskP->c3 ;
    strokeS*      psttYearP                       =       (strokeS*)pTaskP->c2 ;
    countT&       cExecutiveHealYearP             =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmExecutiveHealYearF )

DONE( tmDoJobF )
}
    }
        //etThread.traceF( tinBaseP , T("napped for a tock") ) ;
        ++ s ; ether.osSleepF( tinBaseP , TOCK ) ;
        //etThread.traceF( tinBaseP , T("napping for a tock") ) ;

        }
            }
                }
                    break ;
                    etThread.traceF( tinBaseP , T("exception: unexpected job idType:    ")+TF2(woJob.idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                default :
                }
                    break ;

                    }
                        }
                            }
                                if( !bOk ) etThread.traceF( tinBaseP , T("diskCopyFileF failed too many times.  will not retry [to,from]:    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                                }
                                    }
                                        thirdC::dosSleepWinkIF( tinBaseP , 2 ) ;
                                        etThread.traceF( tinBaseP , T("diskCopyFileF failed.  will retry [cRetries,to,from]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                                        POOPR
                                    {
                                    else
                                    }
                                        break ;
                                        bOk = 1 ;
                                    {
                                    if( !POOP )
                                    ((tinFullS&)tinBaseP).pEtScratch->diskCopyFileF( tinBaseP , woJob.psttTo , woJob.psttFrom , 1 ) ;
                                {
                                while( cTries && cTries -- )
                                ZE( boolT , bOk ) ;

                                cTries = 8 ;

                                etThread.traceF( tinBaseP , T("copying [to,from]:    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                            {
                            else
                            else if( bExists ) etThread.traceF( tinBaseP , T("bizarre!  there is still a file in the way, so not copying [to,from]:    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                                 if( !bOk    ) etThread.traceF( tinBaseP , T("after rejecting a file out of the way, not copying because could not obtain bExists (probable drive failure) [to,from]:    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;

                            }
                                }
                                    thirdC::dosSleepWinkIF( tinBaseP , 2 ) ;
                                    etThread.traceF( tinBaseP , T("diskFileExistsF failed.  will retry [cRetries,to,from]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                                    POOPR
                                {
                                else
                                }
                                    break ;
                                    bOk = 1 ;
                                {
                                if( !POOP )
                                bExists = ((tinFullS&)tinBaseP).pEtScratch->diskFileExistsF( tinBaseP , woJob.psttTo ) ;
                            {
                            while( cTries && cTries -- )
                            bOk = bExists = 0 ;
                            countT cTries = 8 ;

                            }
                                etThread.delF( tinBaseP , psttLongInRejects ) ;
                                etThread.delF( tinBaseP , psttRejected ) ;

                                }
                                    else etThread.traceF( tinBaseP , T("rejected  file from archive because would have been overwritten [reject,from]:    ")+T(psttRejected)+T("    ")+T(woJob.psttTo) ) ;
                                    }
                                        etThread.traceF( tinBaseP , T("exception:  diskMoveFileOrDirUniqueF 2 [reject,from]:    ")+T(psttRejected)+T("    ")+T(woJob.psttTo) ) ;
                                        POOPR
                                    {
                                    if( POOP )
                                    RETRY( 8 , ( psttRejected = 0 , ((tinFullS&)tinBaseP).pEtScratch->diskMoveFileOrDirUniqueF( tinBaseP , psttRejected , woJob.psttTo , psttLongInRejects ) ) ) ; ___( psttRejected ) ;
                                    SCOOPS
                                {
                                IFsCRATCH
                                ZE( strokeS* , psttRejected ) ;

                                etThread.strReplaceF( tinBaseP , psttLongInRejects , woJob.psttTo , tPathArchives , tPathRejects ) ; ___( psttLongInRejects ) ;
                                ZE( strokeS* , psttLongInRejects ) ;
                            {
                            if( bExists )
                        {
                        else
                        if( !bOk ) etThread.traceF( tinBaseP , T("not copying because could not obtain bExists (probable drive failure) [to,from]:    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;

                        }
                            }
                                thirdC::dosSleepWinkIF( tinBaseP , 2 ) ;
                                etThread.traceF( tinBaseP , T("diskFileExistsF failed.  will retry [cRetries,to,from]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                                POOPR
                            {
                            else
                            }
                                break ;
                                bOk = 1 ;
                            {
                            if( !POOP )
                            bExists = ((tinFullS&)tinBaseP).pEtScratch->diskFileExistsF( tinBaseP , woJob.psttTo ) ;
                        {
                        while( cTries && cTries -- )
                        ZE( boolT , bOk ) ;
                        ZE( boolT , bExists ) ;

                        countT cTries = 8 ;

                        SCOOPS
                    {
                    IFsCRATCH
                {
                case IDtYPEjOB_COPY :
                }
                    break ;

                    etThread.delF( tinBaseP , psttUnique ) ;
                    etThread.traceF( tinBaseP , T("moved [to,from]:    ")+T(psttUnique)+T("    ")+T(woJob.psttFrom) ) ;
                    }
                        }
                            etThread.traceF( tinBaseP , T("exception:  diskMoveFileOrDirUniqueF 1 [to,from]:    ")+T(psttUnique)+T("    ")+T(woJob.psttFrom) ) ;
                            POOPR
                        {
                        if( POOP )
                        RETRY( 8 , ( psttUnique = 0 , ((tinFullS&)tinBaseP).pEtScratch->diskMoveFileOrDirUniqueF( tinBaseP , psttUnique , woJob.psttFrom , woJob.psttTo , 0 , woJob.psttUnique , 1 ) ) ) ; ___( psttUnique ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    ZE( strokeS* , psttUnique ) ;
                {
                case IDtYPEjOB_MOVEuNIQUE :
                }
                    break ;
                {
                case IDtYPEjOB_NULL :
            {
            switch( woJob.idType )

            woJob.traceF( tinBaseP ) ;
            woJob.etherF( tinBaseP , etThread ) ;
            stJobP >> pb_woJob ;
            byteT* pb_woJob = (byteT*)&woJob ;
            jobS woJob( tinBaseP , etThread ) ;
        {
        while( stJobP )
    {
    while( !ether && !POOP )
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

    TN( tPathRejects  , "/ipdos.archives.rejects/" ) ;
    TN( tPathArchives , "/ipdos.archives/" ) ;
    //CS:CODEsYNC: 2 2

    stackC& stJobP  = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmDoJobF )

}
    }
        while( ~hSt ) ;
        }
            if( bAbortP || !( -- cDo ) ) break ;

            }
                }
                    etherP.traceF( tinBaseP , T("exception: duplicate short [short]:    ")+tShort ) ;       //SHOULD  BE IMPOSSIBLE
                {
                if( !ids2 && !bAbortP )
                stIdJotP.sinkF( tinBaseP , ids2 , idJot , flSTACKsINK_UNIQUE , subtractJottedOsTextF , (countT)&bAbortP ) ;
                ZE( countT , ids2 ) ;

                //etherP.traceF( tinBaseP , T("jotted short [idJot,short]:    ")+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tShort ) ;
                countT idJot = jotShortFileNamesP.writeF( tinBaseP , tShort , tShort.csF( tinBaseP ) + 1 ) ;
            {
            else
            if( ids1 ) etherP.traceF( tinBaseP , T("jotPresortedShortsF / already in stIdJot [ids,short]:    ")+TF2(ids1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tShort ) ;
            stIdJotP.sinkF( tinBaseP , ids1 , (countT)(osTextT*)tShort , flSTACKsINK_QUERY , subtractOsTextMinusJottedOsTextF , (countT)&bAbortP ) ;
            ZE( countT , ids1 ) ;

            //etherP.traceF( tinBaseP , T("querying stIdJot [short]:    ")+tShort ) ;
            stPresortP.extractF( 0 , tinBaseP ) ;
            etherP.delF( tinBaseP , psttShort ) ;
            TN( tShort , psttShort ) ;
            strokeS*& psttShort = *(strokeS**)&stPresortP.upF( tinBaseP , hSt ) ;
        {
        do
        handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        etherP.traceF( tinBaseP , T("jotPresortedShortsF / [cDo]:    ")+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        countT cDo = stPresortP - cKeepP ;
    {
    if( stPresortP > cKeepP )
{
voidT jotPresortedShortsF( tinBaseS& tinBaseP , etherC& etherP , boolT& bAbortP , jotC& jotShortFileNamesP , stackC& stIdJotP , stackC& stPresortP , countT cKeepP )

}
    return sgn ;

    }
        sgn = bAbortP ? 0 : thirdC::c_strcmpIF( tinBaseP , post1 , post2 ) ; ;
        //ether.traceF( tinBaseP , T("subtract [post1,post2]:    ")+T(post1Copy)+T("    ")+T(post2) ) ;

        }
            bAbortP = 1 ;
            ether.traceF( tinBaseP , T("subtractOsTextMinusJottedOsTextF / could not obtain text [idJot]:    ")+TF2(c2P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        if( !post2 )

        }
            bAbortP = 1 ;
            ether.traceF( tinBaseP , T("subtractOsTextMinusJottedOsTextF / null osTextT* pointer") ) ;
        {
        if( !post1 )

        const osTextT* post2 = page2 ;
        pageC page2 = jotC::readIF( tinBaseP , c2P ) ;

        osTextT* post1 = (osTextT*)c1P ;

        boolT&  bAbortP = *(boolT*)c3P ;
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther && c3P )
    ZE( sCountT , sgn ) ;

    }
    {
    IFbEcAREFUL
{
/*1*/countT subtractOsTextMinusJottedOsTextF( tinBaseS& tinBaseP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    return sgn ;

    }
        ether.delF( tinBaseP , post1Copy ) ;

        sgn = bAbortP ? 0 : thirdC::c_strcmpIF( tinBaseP , post1Copy , post2 ) ; ;
        //ether.traceF( tinBaseP , T("subtract [post1,post2]:    ")+T(post1Copy)+T("    ")+T(post2) ) ;

        }
            bAbortP = 1 ;
            ether.traceF( tinBaseP , T("subtractJottedOsTextF / could not obtain text for 2 (cursor) [idJot]:    ")+TF2(c2P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        if( !post2 )

        }
            bAbortP = 1 ;
            ether.traceF( tinBaseP , T("subtractJottedOsTextF / could not obtain text for 1 (new) [idJot]:    ")+TF2(c1P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        if( !post1Copy )

        const osTextT* post2 = page2 ;
        pageC page2 = jotC::readIF( tinBaseP , c2P ) ;

        }
            thirdC::c_memcpyIF( tinBaseP , post1Copy , post1 , cost1 ) ;    
            ether.newF( tinBaseP , LF , post1Copy , cost1 ) ; ___( post1Copy ) ;
            countT         cost1 = page1 ;
            const osTextT* post1 = page1 ;
            pageC page1 = jotC::readIF( tinBaseP , c1P ) ;
        {
        ZE( osTextT* , post1Copy ) ;

        boolT&  bAbortP = *(boolT*)c3P ;
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther && c3P )
    ZE( sCountT , sgn ) ;

    }
    {
    IFbEcAREFUL
{
/*1*/countT subtractJottedOsTextF( tinBaseS& tinBaseP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    return *pfr1 - *pfr2 ;

    fileMetaS* pfr2 = (fileMetaS*)c2P ;
    fileMetaS* pfr1 = (fileMetaS*)c1P ;
{
/*1*/countT subtractFileMetaF( tinBaseS& tinBaseP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    pEther->traceF( tinBaseP , T("jobS [idType,psttTo,psttFrom,psttUnique]:    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttTo)+T("    ")+T(psttFrom)+T("    ")+T(psttUnique) ) ;
{
voidT jobS::traceF( tinBaseS& tinBaseP )

}
    if( psttUniqueP ) { pEther->strMakeF( tinBaseP , LF , psttUnique , psttUniqueP ) ; ___( psttUnique ) ; }
    if( psttFromP   ) { pEther->strMakeF( tinBaseP , LF , psttFrom   , psttFromP   ) ; ___( psttFrom   ) ; }
    if( psttToP     ) { pEther->strMakeF( tinBaseP , LF , psttTo     , psttToP     ) ; ___( psttTo     ) ; }
{
psttUnique( 0 )
psttFrom( 0 ) ,
psttTo( 0 ) ,
idType( idTypeP ) ,
pEther( &etherP ) ,
jobS::jobS( tinBaseS& tinBaseP , etherC& etherP , countT idTypeP , const strokeS* const psttToP , const strokeS* const psttFromP , const strokeS* const psttUniqueP ) :

}
    pEther->delF( tinBaseP , psttFrom   ) ;
    pEther->delF( tinBaseP , psttTo     ) ;
    pEther->delF( tinBaseP , psttUnique ) ;
    TINSL
{
jobS::~jobS( voidT )

NEWdELcLASS( 3 , jobS ) ;

}
    ((tinFullS&)tinBaseP).pEther->traceF( tinBaseP , T(psttP)+T(" [bitsResult]:    ")+TF4(bitsResult,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
{
voidT imageCompareS::traceF( tinBaseS& tinBaseP , const strokeS* const psttP )

}
    //traceF( tinBaseP , T("ct      :    ") ) ;
    TINSL
{
bitsResult( BITSrESULT_UNKNOWN )
imageCompareS::imageCompareS( voidT ) :

NEWdELcLASS( 2 , imageCompareS ) ;

}
    return ((tinFullS&)tinBaseP).pEther->memCompareF( tinBaseP , (byteT*)this , (byteT*)&frP , sizeof( countT ) + sizeof( count04T ) ) ;    //CS:CODEsYNC 1 1
    TINSL
{
sCountT fileMetaS::operator -( const fileMetaS& frP ) const

}
    ((tinFullS&)tinBaseP).pEther->traceF( tinBaseP , T(psttP)+T(" [timeModRounded,timeMod,cbUsed,cVotes,idSlotPathToYear,path]:    ")+TF3(timeModRounded,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T("    ")+TT(time1Mod,time2Mod)+T("    ")+TT(((countT*)&cbUsed)[0],((countT*)&cbUsed)[1])+T("    ")+TF2(cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idSlotPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((strokeS*)stPathToYearP[idSlotPathToYear]) ) ;
{
voidT fileMetaS::traceF( tinBaseS& tinBaseP , stackC& stPathToYearP , const strokeS* const psttP )

}
    timeModRounded = *(countT*)( (byteT*)pc2 + 3 ) + bRoundUp ;
    countT pc2[ 2 ] = { time1Mod , time2Mod } ;

    boolT bRoundUp = !!( ( time1Mod & 0xffffff ) > 0x800000 ) ;

    }
        bAbortP = 1 ;
        ((tinFullS&)tinBaseP).pEther->traceF( tinBaseP , T("fileMetaS::fileMetaS / exception: idSlotPathToYear is null") ) ;
    {
    if( !idSlotPathToYear )
{
idSlotPathToYear( idSlotPathToYearP )
cVotes( 0 ) ,
time2Mod( time2ModP ) ,
time1Mod( time1ModP ) ,
cbUsed( cbUsedP ) ,
timeModRounded( 0 ) ,
fileMetaS::fileMetaS( tinBaseS& tinBaseP , boolT& bAbortP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) :

NEWdELcLASS( 1 , fileMetaS ) ;

osTextT* postDebugLever ;

countT cYearsInParallel = CyEARSiNpARALLEL ;
const countT cResultsPerStruct = sizeof( countT ) * SB / 2 ;     // 2 BITS ARE USED TO STORE A RESULT, SO 4 RESULTS FIT INTO A BYTE AND 01 RESULTS FIT INTO A count02T ; MY CODE SHOULD BE WRITTEN WITHOUT ASSUMING countT IS count02T

;
}
    inline voidT etherF( tinBaseS& tinBaseP , etherC& etherP ) { pEther = &etherP ; }

    voidT traceF( tinBaseS& tinBaseP ) ;
    jobS( tinBaseS& tinBaseP , etherC& etherP , countT idTypeP = 0 , const strokeS* const psttToP = 0 , const strokeS* const psttFromP = 0 , const strokeS* const psttUniqueP = 0 ) ;
    ~jobS( voidT ) ;
    NEWdELcLASSpROTOS
   

    strokeS* psttUnique ;
    strokeS* psttFrom ;
    strokeS* psttTo ;
    countT   idType ;
    etherC*  pEther ;
{
struct jobS

;
}
    voidT traceF( tinBaseS& tinBaseP , const strokeS* const psttP = 0 ) ;
    inline sCountT operator -( imageCompareS& picP ) { return bitsResult - picP.bitsResult ; }
    imageCompareS( voidT ) ;
    NEWdELcLASSpROTOS

    countT bitsResult ;
{
struct imageCompareS

;
}
    sCountT operator -( const fileMetaS& frP ) const ;
    voidT traceF( tinBaseS& tinBaseP , stackC& stPathToYearP , const strokeS* const psttP = 0 ) ;
    fileMetaS( tinBaseS& tinBaseP , boolT& bAbortP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) ;
    NEWdELcLASSpROTOS

    countT   idSlotPathToYear ;
    countT   cVotes ;
    sCountT  time2Mod ;
    countT   time1Mod ;
    count04T cbUsed ;
    countT   timeModRounded ;   //CS:CODEsYNC 1 1
{
struct fileMetaS

#define IDtYPEjOB_COPY       0x3
#define IDtYPEjOB_MOVEuNIQUE 0x2
#define IDtYPEjOB_NULL       0x1

#define CsHORTpRESORT ( TUCK << 1 )
//PROD: TUCK << 4
//THE GOAL IS TO NEVER PULL AN "OUT OF ORDER" SHORT NAME FROM stPresort
//LARGER VALUE RESULTS IN ABILITY TO EFFICIENTLY HANDLE LARGER DISCREPANCY IN THE NAME LISTS FOR THE VOLUMES

#define CyEARSiNpARALLEL  0x1
//20221229@1440: FOR ALPHA SITE TESTING, PROCESS YEARS SERIALLY (MILESTONE GOAL: ROCK SOLID FOR WO YEAR AT A TIME)

#define BITSrESULT_ALLbITS        3
#define BITSrESULT_EQUAL          2
#define BITSrESULT_NOTeQUAL       1
#define BITSrESULT_UNKNOWN        0

//OBSOLETES 7e6
//OBSOLETED BY 

/*1*/WAKEdEBUGsHOWtEXT( "ifcIDaDAM_HEALaRCHIVES" )/*1*/
/**/
*/
redesign executive for each year
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
