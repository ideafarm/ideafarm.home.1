
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK << 4 ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        while( !ether && ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                }
                    etThread.traceF( tin0P , (!F(flagsFail)?T("aok"):T("flagsFail:")+TF2(flagsFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)) ) ;

                    }
                        }
                            flagsFail |= flFAIL_COULDnOTmOVEfILE ;
                            POOPR
                        {
                        if( POOP )
                        ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tWhere+tShort , tIfoName ) ;

                        SCOOPS
                    {
                    IFsCRATCHoK

                    ;
                            : tFolderDone
                            ? tFolderToRetry
                        : F(flagsFail)
                        ? tFolderAbandoned
                    TN( tWhere , "" ) ; tWhere = bFailPermanent

                    etThread.traceF( tin0P , T("moving the file") ) ;

                    etThread.traceF( tin0P , T("cleaning up 3") ) ;

                    }
                        etThread.traceF( tin0P , T("unknown error") ) ;
                        flagsFail |= flFAIL_UNKNOWNeRROR ;
                        POOPR
                    {
                    if( POOP )
                    etThread.traceF( tin0P , T("cleaning up 2") ) ;

                    }
                        etThread.delF( tin0P , psttValueLive             ) ;
                        etThread.delF( tin0P , psttValueAmountDiscount   ) ;
                        etThread.delF( tin0P , psttValueIdSubscription   ) ;
                        etThread.delF( tin0P , psttValueMode             ) ;
                        etThread.delF( tin0P , psttValueName             ) ;
                        etThread.delF( tin0P , psttValueEmail            ) ;
                        etThread.delF( tin0P , psttValuePostalCode       ) ;
                        etThread.delF( tin0P , psttValueCountry          ) ;
                        etThread.delF( tin0P , psttValueHawker           ) ;
                        etThread.delF( tin0P , psttValueAge              ) ;
                        etThread.delF( tin0P , psttValueAmountTotal      ) ;
                        etThread.delF( tin0P , psttValueAmountSubtotal   ) ;
                        etThread.delF( tin0P , psttValueApiVersion       ) ;
                        etThread.delF( tin0P , psttValueStripeNoticeType ) ;
                        etThread.delF( tin0P , psttVersion               ) ;
                        etThread.delF( tin0P , psttEvent             ) ;
                        }
                            }
                                }
                                    etThread.traceF( tin0P , T("debug / 0") ) ;
                                    etThread.boxPutF( tin0P , T("mail.smtp2go.com/dd9/smtp/factories@ideafarm.com/factoryreports@ideafarm.com/")+T(psttValueEmail)+T("") , tThankYou ) ;
                                    etThread.traceF( tin0P , T("debug / 1") ) ;

                                    }
                                        ) ;

                                            "Be sure to use the same email address so that we can detect duplicate charges and reverse them.\r\n\r\n"
                                            "If you entered your [matrix] username incorrectly, you can submit a new, corrected order.\r\n"
                                            "\r\nWe have been notified and will contact you via email during business hours.\r\n"

                                        tThankYou += T(

                                        }
                                            ) ;

                                                "    [students and faculty]:    ")+tValueError3+T("\r\n"

                                            tThankYou += T(
                                        {
                                        if( bFail3 )

                                        }
                                            ) ;

                                                "    [courtship workshops]:     ")+tValueError2+T("\r\n"

                                            tThankYou += T(
                                        {
                                        if( bFail2 )

                                        }
                                            ) ;

                                                "    [visitors]:                ")+tValueError1+T("\r\n"

                                            tThankYou += T(
                                        {
                                        if( bFail1 )

                                        ) ;

                                            "Your payment has been received but this automated system could not generate some of your invite(s):\r\n\r\n"

                                        tThankYou += T(
                                    {
                                    if( bFail1 || bFail2 || bFail3 )

                                    ) ;
                                        +tInvitationsSubmitted +T("\r\n"
                                        "You have been invited to join the following spaces and rooms at The IdeaFarm (tm) College of Imagination Science:\r\n\r\n")
                                        "    [backup codes]:  ")+T("        (You will receive these during your first login, but hopefully will never need them.)\r\n\r\n"
                                        "    [secret phrase]: ")+T("        (You will make this up during your first login and enter it each time you log in.)\r\n"
                                        "Your account will also be secured by the following credentials:\r\n\r\n"
                                        "    [password]:      ")+tNewPassword+T("        (Be sure to change this right away!)\r\n\r\n"
                                        "    [username]:      ")+tNewUserName+T("\r\n"
                                        "Here are your credentials.  You can use them immediately to log in:\r\n\r\n"
                                        "For instructions, see http://admissions.ideafarm.com .\r\n\r\n"
                                        "    [hawker]:        ")+T(psttValueHawker)+T("\r\n\r\n"
                                        "    [age (parsed)]:  ")+TF4(age,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n"
                                        "    [age (raw)]:     ")+T(psttValueAge)+T("\r\n"
                                        "    [email]:         ")+T(psttValueEmail)+T("\r\n"
                                        +T("Payment received for:\r\n\r\n"
                                        "Subject: Notification from IDEAFARM.COM\r\n\r\nThank you for ")+tForWhat

                                    TN( tThankYou , "" ) ; tThankYou = T(

                                    else           tForWhat = T("paying your entry fee for self-monitored chat.\r\n\r\n") ;
                                    if( bStudent ) tForWhat = T("registering as a student on IDEAFARM.COM.\r\n\r\n") ;
                                    TN( tForWhat , "" ) ;
                                    etThread.traceF( tin0P , T("debug / 2") ) ;

                                    }
                                        }
                                            }
                                                }
                                                    etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                    POOPRqUIET
                                                {
                                                if( POOP )
                                            
                                                etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
                                            
                                                }
                                                    DEL( pSwPathValue ) ;
                                            
                                                    }
                                                        }
                                                            etThread.delF( tin0P , pstpsttValue ) ;
                                            
                                                            }
                                                                }
                                                                    etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                    *pptValue[ offe ] = T(pstpsttValue) ;
                                                                {
                                                                if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                            {
                                                            for( countT offe = 0 ; offe < cPaths ; offe ++ )
                                            
                                                            if( cPaths - cValues ) { BLAMMO ; }
                                                            countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                            countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
                                            
                                                            etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(pstpsttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                            etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                            
                                                            strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                            psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                                            
                                                            _IO_
                                                        {
                                                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                        countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                    {
                                                    if( !POOP )
                                            
                                                    ;
                                                    }
                                                        &tPathDeviceId     ,
                                                        &tPathAccessToken  ,
                                                    {
                                                    textC* pptPath[] =
                                            
                                                    TN( tPathDeviceId    , "\"device_id\"/"    ) ;
                                                    TN( tPathAccessToken , "\"access_token\"/" ) ;
                                            
                                                    ;
                                                    }
                                                        &tValueDeviceId      ,
                                                        &tValueAccessToken ,
                                                    {
                                                    textC* pptValue[] =
                                            
                                                    __Z( pSwPathValue ) ;
                                                    etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                    ZE( switchC* , pSwPathValue ) ;
                                                    ZE( strokeS* , psttPath     ) ;
                                                {
                                            
                                                etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                etThread.traceF( tin0P , T("json response:") ) ;
                                            
                                                }
                                                    }
                                                        else if( costj ) break ;
                                                             if( cNest ) costj ++ ;
                                            
                                                        else if( postj[ costj ] == '}' ) cNest -- ;
                                                             if( postj[ costj ] == '{' ) cNest ++ ;
                                            
                                                        if( !cbIn ) break ;
                                                        countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                    {
                                                    for(;;)
                                                    ZE( countT , cNest ) ;
                                                {
                                                ZE( countT , costj ) ;
                                                thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                                                osTextT postj[ TUCK << 1 ] ;
                                            
                                                sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                etThread.traceF( tin0P , T("request:") ) ;
                                            
                                                TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/logout HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(0,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;
                                            
                                                //sockc.connectF( tin0P , 80 , nnServer ) ;
                                                //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                            
                                                sockc.connectF( tin0P , 443 , nnServer ) ;
                                                socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                            
                                                countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                countT timeAllowedConnected = TICK >> 2 ;
                                            
                                                nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                nicNameC nnServer ;
                                            
                                                SCOOPS
                                                _IO_
                                            {
                                            IFsCRATCHoK                                                           // LOGOUT

                                            if( !tInvitationsSubmitted.csF( tin0P ) ) tInvitationsSubmitted = T("    none\r\n") ;
                                            etThread.traceF( tin0P , T("debug / 3") ) ;

                                            }            
                                                }
                                                    }
                                                        tInvitationsSubmitted += tb4+tNameSpaceAcademic+tcrlf ;
                                                        TN( tNameSpaceAcademic , "Students and Faculty Only (ICIS)" ) ;
                                                    {
                                                    if( !bFail3 )

                                                    }
                                                        bFail3 = 1 ;
                                                        etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                        POOPRqUIET
                                                    {
                                                    if( POOP )
                                                
                                                    }
                                                        if( !tValueErrorCode3.csF( tin0P ) ) bFail3 = 0 ;
                                                        DEL( pSwPathValue ) ;
                                                        }
                                                            }
                                                                etThread.delF( tin0P , pstpsttValue ) ;

                                                                }
                                                                    }
                                                                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                        *pptValue[ offe ] = T(pstpsttValue) ;
                                                                    {
                                                                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                                {
                                                                for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                                if( cPaths - cValues ) { BLAMMO ; }
                                                                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                                strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                                _IO_
                                                            {
                                                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                        {
                                                        if( !POOP )

                                                        //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                                        ;
                                                        }
                                                            &tPathError     ,
                                                            &tPathErrorCode ,
                                                        {
                                                        textC* pptPath[] =

                                                        TN( tPathError     , "\"error\"/"   ) ;
                                                        TN( tPathErrorCode , "\"errcode\"/" ) ;

                                                        ;
                                                        }
                                                            &tValueError3     ,
                                                            &tValueErrorCode3 ,
                                                        {
                                                        textC* pptValue[] =

                                                        __Z( pSwPathValue ) ;
                                                        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                        ZE( switchC* , pSwPathValue ) ;
                                                        ZE( strokeS* , psttPath     ) ;
                                                    {

                                                    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("json response:") ) ;

                                                    }
                                                        }
                                                            else if( costj ) break ;
                                                                 if( cNest ) costj ++ ;
                                                
                                                            else if( postj[ costj ] == '}' ) cNest -- ;
                                                                 if( postj[ costj ] == '{' ) cNest ++ ;
                                                
                                                            if( !cbIn ) break ;
                                                            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                        {
                                                        for(;;)
                                                        ZE( countT , cNest ) ;
                                                    {
                                                    ZE( countT , costj ) ;
                                                    thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                                                    osTextT postj[ TUCK << 1 ] ;
                                                
                                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("request:") ) ;

                                                    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!CxQXuURdflEEIURQXO:ideafarm.com/invite HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(tBodyInvite.csF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBodyInvite ;
                                                
                                                    sockc.connectF( tin0P , 443 , nnServer ) ;
                                                    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                                
                                                    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT timeAllowedConnected = TICK >> 2 ;
                                                
                                                    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                    nicNameC nnServer ;
                                                
                                                    SCOOPS
                                                {
                                                IFsCRATCHoK
                                                _IO_
                                            {
                                            else if( !bFail0 )
                                            if( age < 16 || !bStudent ) bFail3 = 0 ;
                                            TN( tNameSpaceAcademic , "Students and Faculty Only (ICIS)" ) ;    // INVITE TO SPACE
                                            etThread.traceF( tin0P , T("debug / 4") ) ;
                                            
                                            }            
                                                }
                                                    }
                                                        tInvitationsSubmitted += tb4+tNameSpaceCourtship+tcrlf ;
                                                        TN( tNameSpaceCourtship , "Bait N' Switch Courtship Workshops (ICIS)" ) ;
                                                    {
                                                    if( !bFail2 )

                                                    }
                                                        bFail2 = 1 ;
                                                        etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                        POOPRqUIET
                                                    {
                                                    if( POOP )
                                                
                                                    }
                                                        if( !tValueErrorCode2.csF( tin0P ) ) bFail2 = 0 ;
                                                        DEL( pSwPathValue ) ;
                                                        }
                                                            }
                                                                etThread.delF( tin0P , pstpsttValue ) ;

                                                                }
                                                                    }
                                                                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                        *pptValue[ offe ] = T(pstpsttValue) ;
                                                                    {
                                                                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                                {
                                                                for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                                if( cPaths - cValues ) { BLAMMO ; }
                                                                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                                strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                                _IO_
                                                            {
                                                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                        {
                                                        if( !POOP )

                                                        //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                                        ;
                                                        }
                                                            &tPathError     ,
                                                            &tPathErrorCode ,
                                                        {
                                                        textC* pptPath[] =

                                                        TN( tPathError     , "\"error\"/"   ) ;
                                                        TN( tPathErrorCode , "\"errcode\"/" ) ;

                                                        ;
                                                        }
                                                            &tValueError2     ,
                                                            &tValueErrorCode2 ,
                                                        {
                                                        textC* pptValue[] =

                                                        __Z( pSwPathValue ) ;
                                                        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                        ZE( switchC* , pSwPathValue ) ;
                                                        ZE( strokeS* , psttPath     ) ;
                                                    {

                                                    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("json response:") ) ;

                                                    }
                                                        }
                                                            else if( costj ) break ;
                                                                 if( cNest ) costj ++ ;
                                                
                                                            else if( postj[ costj ] == '}' ) cNest -- ;
                                                                 if( postj[ costj ] == '{' ) cNest ++ ;
                                                
                                                            if( !cbIn ) break ;
                                                            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                        {
                                                        for(;;)
                                                        ZE( countT , cNest ) ;
                                                    {
                                                    ZE( countT , costj ) ;
                                                    thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                                                    osTextT postj[ TUCK << 1 ] ;
                                                
                                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("request:") ) ;
                                                
                                                    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!esnkyOGEyeJQlIZGPM:ideafarm.com/invite HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(tBodyInvite.csF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBodyInvite ;
                                                
                                                    sockc.connectF( tin0P , 443 , nnServer ) ;
                                                    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                                
                                                    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT timeAllowedConnected = TICK >> 2 ;
                                                
                                                    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                    nicNameC nnServer ;
                                                
                                                    SCOOPS
                                                {
                                                IFsCRATCHoK
                                                _IO_
                                            {
                                            else if( !bFail0 )
                                            if( age < 13 || age > 29 ) bFail2 = 0 ;
                                            etThread.traceF( tin0P , T("debug / 5") ) ;
                                            
                                            }
                                                }
                                                    }
                                                        tInvitationsSubmitted += tb4+tNameSpaceVisitors+tcrlf ;
                                                        TN( tNameSpaceVisitors , "Visitors (ICIS: The IdeaFarm (tm) College of Imagination Science)" ) ;
                                                    {
                                                    if( !bFail1 )

                                                    }
                                                        bFail1 = 1 ;
                                                        etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                        POOPRqUIET
                                                    {
                                                    if( POOP )
                                                
                                                    }
                                                        if( !tValueErrorCode1.csF( tin0P ) ) bFail1 = 0 ;
                                                        DEL( pSwPathValue ) ;
                                                        }
                                                            }
                                                                etThread.delF( tin0P , pstpsttValue ) ;

                                                                }
                                                                    }
                                                                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                        *pptValue[ offe ] = T(pstpsttValue) ;
                                                                    {
                                                                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                                {
                                                                for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                                if( cPaths - cValues ) { BLAMMO ; }
                                                                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                                strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                                _IO_
                                                            {
                                                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                        {
                                                        if( !POOP )

                                                        //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                                        ;
                                                        }
                                                            &tPathError     ,
                                                            &tPathErrorCode ,
                                                        {
                                                        textC* pptPath[] =

                                                        TN( tPathError     , "\"error\"/"   ) ;
                                                        TN( tPathErrorCode , "\"errcode\"/" ) ;

                                                        ;
                                                        }
                                                            &tValueError1     ,
                                                            &tValueErrorCode1 ,
                                                        {
                                                        textC* pptValue[] =

                                                        __Z( pSwPathValue ) ;
                                                        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                        ZE( switchC* , pSwPathValue ) ;
                                                        ZE( strokeS* , psttPath     ) ;
                                                    {

                                                    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("json response:") ) ;

                                                    }
                                                        }
                                                            else if( costj ) break ;
                                                                 if( cNest ) costj ++ ;
                                                
                                                            else if( postj[ costj ] == '}' ) cNest -- ;
                                                                 if( postj[ costj ] == '{' ) cNest ++ ;
                                                
                                                            if( !cbIn ) break ;
                                                            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                        {
                                                        for(;;)
                                                        ZE( countT , cNest ) ;
                                                    {
                                                    ZE( countT , costj ) ;
                                                    thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                                                    osTextT postj[ TUCK << 1 ] ;
                                                
                                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("request:") ) ;
                                                
                                                    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!tvsMKCZYUrmUfxhZIq:ideafarm.com/invite HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(tBodyInvite.csF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBodyInvite ;
                                                
                                                    sockc.connectF( tin0P , 443 , nnServer ) ;
                                                    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                                
                                                    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT timeAllowedConnected = TICK >> 2 ;
                                                
                                                    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                    nicNameC nnServer ;
                                                
                                                    SCOOPS
                                                {
                                                IFsCRATCHoK                                                       // INVITE TO SPACE
                                                _IO_
                                            {
                                            else if( !bFail0 )
                                            if( age < 13 ) bFail1 = 0 ;
                                            etThread.traceF( tin0P , T("debug / 6") ) ;

                                            }
                                                if( tValueAccessToken.csF( tin0P ) ) bFail0 = 0 ;

                                                }
                                                    etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                    POOPRqUIET
                                                {
                                                if( POOP )
                                            
                                                etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
                                            
                                                }
                                                    DEL( pSwPathValue ) ;
                                                    
                                                    }
                                                        }
                                                            etThread.delF( tin0P , pstpsttValue ) ;
                                                    
                                                            }
                                                                }
                                                                    etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                    *pptValue[ offe ] = T(pstpsttValue) ;
                                                                {
                                                                if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                            {
                                                            for( countT offe = 0 ; offe < cPaths ; offe ++ )
                                                    
                                                            if( cPaths - cValues ) { BLAMMO ; }
                                                            countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                            countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
                                                    
                                                            etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(pstpsttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                            etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    
                                                            strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                            psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                                                    
                                                            _IO_
                                                        {
                                                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                        countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                    {
                                                    if( !POOP )
                                                    
                                                    ;
                                                    }
                                                        &tPathDeviceId     ,
                                                        &tPathAccessToken  ,
                                                    {
                                                    textC* pptPath[] =
                                                    
                                                    TN( tPathDeviceId    , "\"device_id\"/"    ) ;
                                                    TN( tPathAccessToken , "\"access_token\"/" ) ;
                                                    
                                                    ;
                                                    }
                                                        &tValueDeviceId      ,
                                                        &tValueAccessToken ,
                                                    {
                                                    textC* pptValue[] =
                                                    
                                                    __Z( pSwPathValue ) ;
                                                    etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                    ZE( switchC* , pSwPathValue ) ;
                                                    ZE( strokeS* , psttPath     ) ;
                                                    _IO_
                                                {
                                            
                                                etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                etThread.traceF( tin0P , T("json response:") ) ;
                                            
                                                }
                                                    }
                                                        else if( costj ) break ;
                                                             if( cNest ) costj ++ ;
                                            
                                                        else if( postj[ costj ] == '}' ) cNest -- ;
                                                             if( postj[ costj ] == '{' ) cNest ++ ;
                                            
                                                        if( !cbIn ) break ;
                                                        countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                    {
                                                    for(;;)
                                                    ZE( countT , cNest ) ;
                                                {
                                                ZE( countT , costj ) ;
                                                thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                                                osTextT postj[ TUCK << 1 ] ;
                                            
                                                sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                etThread.traceF( tin0P , T("request:") ) ;
                                            
                                                TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/login HTTP/1.1\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;
                                            
                                                countT costBody = tBody.csF( tin0P ) ;
                                            
                                                //sockc.connectF( tin0P , 80 , nnServer ) ;
                                                //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                            
                                                sockc.connectF( tin0P , 443 , nnServer ) ;
                                                socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                            
                                                countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                countT timeAllowedConnected = TICK >> 2 ;
                                            
                                                nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                nicNameC nnServer ;
                                            
                                                ) ;
                                                
                                                    "}\r\n"
                                                    "    \"password\": \"")+tApiPassword+T("\"\r\n"
                                                    "    },\r\n"
                                                    "        \"user\": \"a.1\"\r\n"
                                                    "        \"type\": \"m.id.user\",\r\n"
                                                    "    {\r\n"
                                                    "    \"identifier\":\r\n"
                                                    "    \"type\": \"m.login.password\",\r\n"
                                                    "{\r\n"
                                                
                                                TN( tBody , "" ) ; tBody = T(
                                                
                                                }
                                                    etThread.delF( tin0P , psttApiPassword ) ;
                                                    tApiPassword = T(psttApiPassword) ;
                                                    etThread.traceF( tin0P , T("[password]:    ")+T(psttApiPassword) ) ;
                                                    if( psttApiPassword && psttApiPassword->idAdam ) tApiPassword = T(psttApiPassword) ;

                                                      ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.ideafarm.com.a.1"          ) ) ; ___( psttApiPassword ) ;
                                                    //ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.ideafarm.com.administrator") ) ; ___( psttApiPassword ) ;
                                                    //ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.communick.com.ideafarm"    ) ) ; ___( psttApiPassword ) ;
                                                {
                                                TN( tApiPassword , "" ) ;

                                                SCOOPS
                                                _IO_
                                            {
                                            IFsCRATCHoK                                                           // LOGIN

                                            TN( tValueDeviceId    , ""                     ) ;
                                            TN( tValueAccessToken , ""                     ) ;
                                            TN( tServer              , "ideafarm.com"         ) ;
                                          //TN( tServer              , "matrix.communick.com" ) ;
                                            etThread.traceF( tin0P , T("debug / 7") ) ;

                                            }
                                                etThread.traceF( tin0P , T("debug / 7.1") ) ;
                                                }
                                                    etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                    POOPRqUIET
                                                {
                                                if( POOP )
                                                etThread.traceF( tin0P , T("debug / 7.2") ) ;

                                                etThread.traceF( tin0P , T("[nonce]:    ")+tValueNonce ) ;
                                                TN( tb4 , "    " ) ;

                                                }                               //U::VERIFY THAT REGISTRATION SUCCEEDED
                                                    else bRegistered = 1 ;      //I ASSUME THAT REGISTRATION SUCCEEDED ;
                                                    }
                                                        continue ;
                                                        etThread.traceF( tin0P , T("!exception / this username is already registered ; will try the next value") ) ;
                                                    {
                                                    if( !etThread.strCompareF( tin0P , tValueErrorCode , T("M_USER_IN_USE") ) )

                                                    DEL( pSwPathValue ) ;

                                                    }
                                                        }
                                                            etThread.delF( tin0P , psttValue ) ;

                                                            }
                                                                }
                                                                    etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                    *pptValue[ offe ] = T(psttValue) ;
                                                                {
                                                                if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                            {
                                                            for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                            if( cPaths - cValues ) { BLAMMO ; }
                                                            countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                            countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                            etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                            etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

                                                            strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                            psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                            _IO_
                                                        {
                                                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                        countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                        _IO_
                                                    {
                                                    if( !POOP )

                                                    //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                                    ;
                                                    }
                                                        &tPathNonce     ,
                                                        &tPathError     ,
                                                        &tPathErrorCode ,
                                                    {
                                                    textC* pptPath[] =

                                                    TN( tPathNonce     , "\"nonce\"/"   ) ;
                                                    TN( tPathError     , "\"error\"/"   ) ;
                                                    TN( tPathErrorCode , "\"errcode\"/" ) ;

                                                    ;
                                                    }
                                                        &tValueNonce     ,
                                                        &tValueError     ,
                                                        &tValueErrorCode ,
                                                    {
                                                    textC* pptValue[] =

                                                    TN( tValueError     , "" ) ;
                                                    TN( tValueErrorCode , "" ) ;

                                                    __Z( pSwPathValue ) ;
                                                    etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                    ZE( switchC* , pSwPathValue ) ;
                                                    ZE( strokeS* , psttPath     ) ;
                                                    _IO_
                                                {
                                                TN( tValueNonce     , "" ) ;
                                                etThread.traceF( tin0P , T("debug / 7.3") ) ;

                                                etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                etThread.traceF( tin0P , T("json response:") ) ;

                                                }
                                                    etThread.traceF( tin0P , T(posth) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("[headers]:") ) ;
                                                    posth[ costh ] = 0 ;
                                                    }
                                                        }
                                                            break ;

                                                            postj[ costj ] = save ;
                                                                           postj[ costj ] = 0 ;
                                                            osTextT save = postj[ costj ] ;
                                                        {
                                                        else if( costj )
                                                             if( cNest ) costj ++ ;

                                                        else if( postj[ costj ] == '}' ) cNest -- ;
                                                             if( postj[ costj ] == '{' ) cNest ++ ;

                                                        if( !costj && !cNest ) posth[ costh ++ ] = postj[ costj ] ;

                                                        if( !cbIn ) break ;
                                                        countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                    {
                                                    for(;;)
                                                    ZE( countT , cNest ) ;

                                                    ZE( countT , costh ) ;
                                                    osTextT posth[ TUCK << 0 ] ;
                                                    _IO_
                                                {
                                                ZE( countT , costj ) ;
                                                osTextT postj[ TUCK << 1 ] ;
                                                etThread.traceF( tin0P , T("debug / 7.4") ) ;

                                                sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                etThread.traceF( tin0P , T("request:") ) ;
                                                etThread.traceF( tin0P , T("debug / 7.5") ) ;

                                                TN( tSay , "" ) ; tSay = T("POST /_synapse/admin/v1/register HTTP/1.1")/*+T("\r\nAuthorization: Bearer ")+tValueSharedSecret*/+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;

                                                countT costBody = tBody.csF( tin0P ) ;

                                                etThread.traceF( tin0P , T("debug / 7.6") ) ;
                                                sockc.connectF( tin0P , 443 , nnServer ) ;
                                                socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                                etThread.traceF( tin0P , T("debug / 7.7") ) ;

                                                countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                countT timeAllowedConnected = TICK >> 2 ;

                                                nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                nicNameC nnServer ;

                                                etThread.traceF( tin0P , T("debug / 7.8") ) ;
                                                ) ;

                                                    "}\r\n"
                                                    "    \"mac\": \"")+tMac                 +T("\"\r\n"
                                                    "    \"password\": \"")+tNewPassword           +T("\",\r\n"
                                                    "    \"username\": \"")+tNewUserNameShort      +T("\",\r\n"
                                                    "    \"nonce\": \"")+tValueNonce        +T("\",\r\n"
                                                    "{\r\n"

                                                TN( tBody , "" ) ; tBody = T(

                                                etThread.traceF( tin0P , T("[mac]:    ")+tMac ) ;
                                                }
                                                    etThread.delF( tin0P , psttMac ) ;
                                                    tMac = T(psttMac) ;
                                                    etThread.openSslHmacF( tin0P , psttMac , tValueSharedSecret , tValueSharedSecret.csF( tin0P ) , postRaw , costRaw ) ; ___( psttMac ) ;
                                                    ZE( strokeS* , psttMac ) ;

                                                    countT costRaw = postc - postRaw ;

                                                    thirdC::c_strcpyIF( tin0P , postc , posti ) ; postc += costi     ;
                                                    costi = tNote.csF( tin0P ) ;
                                                    posti = tNote ;

                                                    thirdC::c_strcpyIF( tin0P , postc , posti ) ; postc += costi + 1 ;
                                                    costi = tNewPassword.csF( tin0P ) ;
                                                    posti = tNewPassword ;

                                                    thirdC::c_strcpyIF( tin0P , postc , posti ) ; postc += costi + 1 ;
                                                    costi = tNewUserNameShort.csF( tin0P ) ;
                                                    posti = tNewUserNameShort ;

                                                    thirdC::c_strcpyIF( tin0P , postc , posti ) ; postc += costi + 1 ;
                                                    countT   costi = tValueNonce.csF( tin0P ) ;
                                                    osTextT* posti = tValueNonce ;

                                                    osTextT* postc = postRaw ;
                                                    thirdC::c_memsetIF( tin0P , postRaw , sizeof postRaw , 0 ) ;
                                                    osTextT postRaw[ TUCK ] ;
                                                    etThread.traceF( tin0P , T("debug / 7.g") ) ;
                                                    _IO_
                                                {
                                                TN( tMac , "" ) ;

                                                TN( tNote , "notadmin"  ) ;
                                                etThread.traceF( tin0P , T("debug / 7.h") ) ;

                                                _IO_
                                            {
                                            etThread.traceF( tin0P , T("debug / 8") ) ;

                                            }
                                                }
                                                    etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                    POOPRqUIET
                                                {
                                                if( POOP )

                                                etThread.traceF( tin0P , T("[nonce]:    ")+tValueNonce ) ;

                                                }
                                                    DEL( pSwPathValue ) ;

                                                    }
                                                        }
                                                            etThread.delF( tin0P , psttValue ) ;

                                                            }
                                                                }
                                                                    etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                    *pptValue[ offe ] = T(psttValue) ;
                                                                {
                                                                if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                            {
                                                            for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                            if( cPaths - cValues ) { BLAMMO ; }
                                                            countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                            countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                            etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                            etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

                                                            strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                            psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                            _IO_
                                                        {
                                                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                        countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                        _IO_
                                                    {
                                                    if( !POOP )

                                                    //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                                    ;
                                                    }
                                                        &tPathNonce     ,
                                                        &tPathError     ,
                                                        &tPathErrorCode ,
                                                    {
                                                    textC* pptPath[] =

                                                    TN( tPathNonce     , "\"nonce\"/"   ) ;
                                                    TN( tPathError     , "\"error\"/"   ) ;
                                                    TN( tPathErrorCode , "\"errcode\"/" ) ;

                                                    ;
                                                    }
                                                        &tValueNonce     ,
                                                        &tValueError     ,
                                                        &tValueErrorCode ,
                                                    {
                                                    textC* pptValue[] =

                                                    TN( tValueError     , "" ) ;
                                                    TN( tValueErrorCode , "" ) ;

                                                    __Z( pSwPathValue ) ;
                                                    etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                    ZE( switchC* , pSwPathValue ) ;
                                                    ZE( strokeS* , psttPath     ) ;
                                                    _IO_
                                                {

                                                etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                etThread.traceF( tin0P , T("json response:") ) ;

                                                }
                                                    }
                                                        else if( costj ) break ;
                                                             if( cNest ) costj ++ ;

                                                        else if( postj[ costj ] == '}' ) cNest -- ;
                                                             if( postj[ costj ] == '{' ) cNest ++ ;

                                                        if( !cbIn ) break ;
                                                        countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                    {
                                                    for(;;)
                                                    ZE( countT , cNest ) ;
                                                    _IO_
                                                {
                                                ZE( countT , costj ) ;
                                                osTextT postj[ TUCK << 1 ] ;

                                                sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                etThread.traceF( tin0P , T("request:") ) ;

                                                TN( tSay , "" ) ; tSay = T("GET /_synapse/admin/v1/register HTTP/1.1")+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;

                                                countT costBody = tBody.csF( tin0P ) ;

                                                sockc.connectF( tin0P , 443 , nnServer ) ;
                                                socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

                                                countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                countT timeAllowedConnected = TICK >> 2 ;

                                                nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                nicNameC nnServer ;

                                                TN( tBody , "" ) ;

                                                SCOOPS
                                                _IO_
                                            {
                                            IFsCRATCHoK
                                            TN( tValueNonce , "" ) ;
                                            _IO_
                                        {
                                        else
                                        }
                                            flagsFail |= flFAIL_COULDnOTgETsHAREDsECRET ;
                                            etThread.traceF( tin0P , T("could not retrieve shared secret") ) ;
                                        {
                                        if( !tValueSharedSecret.csF( tin0P ) )

                                        TN( tServer , "ideafarm.com" ) ;

                                        }
                                            etThread.traceF( tin0P , T("[sharedSecret]:    ")+tValueSharedSecret ) ;
                                            etThread.delF( tin0P , psttSharedSecret ) ;
                                            if( psttSharedSecret && psttSharedSecret->idAdam ) tValueSharedSecret = T(psttSharedSecret) ;

                                            ZE( strokeS* , psttSharedSecret ) ; etThread.querySettingF( tin0P , psttSharedSecret , T("!ipdos.password.matrix.ideafarm.com.shared.secret")  ) ; ___( psttSharedSecret ) ;
                                        {
                                        TN( tValueSharedSecret , "" ) ;

                                        tNewPassword = TF4((countT)ruPassword,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FILLzE,0,0x3e) ;
                                        countT idNewPassword = ruPassword ;
                                        _IO_
                                    {
                                    if( tNewUserName.csF( tin0P ) )

                                    }
                                        }
                                            tBodyInvite = T("{\"user_id\": \"")+tNewUserName+T("\"}\r\n") ;
                                            tNewUserName      = /*T("@")+*/tNewUserNameShort/*+T(":ideafarm.com")*/ ;       // GIVE ONLY THE SHORT USERNAME BECAUSE NONFEDERATED SO (1) LONG NAME ISN'T NEEDED AND (2) LONG NAME WILL PRODUCE AN ERROR MESSAGE THAT WILL CONFUSE EVEN THOUGH IT WILL THEN WORK
                                            tNewUserNameShort =  T("test.")+TF4(idNewUser,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e) ;
                                            countT idNewUser = 1 + incv02AM( idNewUserLath ) ;

                                            if( bZe ) idNewUserLath = 0 ;
                                            countT& idNewUserLath = *(countT*)pbi ;
                                        {
                                        if( pbi && cbi == sizeof( countT ) )
                                        fwsLath.getF( tin0P , pbi , cbi , sizeof( countT ) ) ;
                                        ZE( countT , cbi ) ;
                                        ZE( byteT* , pbi ) ;
                                        fileWindowsC fwsLath( tin0P , etThread , tName , flFILEwINDOW_WRITE ) ;

                                        boolT bZe = !etThread.diskFileExistsF( tin0P , tName ) ;
                                        TN( tName , "///ideafarm/ephemeral/ipdos/idNewTestUserLath" ) ;
                                        _IO_
                                    {
                                    else                                                            // DISPENSE CREDENTIALS (TEST)
                                    }
                                        }
                                            tBodyInvite = T("{\"user_id\": \"")+tNewUserName+T("\"}\r\n") ;
                                            tNewUserName      = /*T("@")+*/tNewUserNameShort/*+T(":ideafarm.com")*/ ;       // GIVE ONLY THE SHORT USERNAME BECAUSE NONFEDERATED SO (1) LONG NAME ISN'T NEEDED AND (2) LONG NAME WILL PRODUCE AN ERROR MESSAGE THAT WILL CONFUSE EVEN THOUGH IT WILL THEN WORK
                                            tNewUserNameShort =  T("a.")+TF4(idNewUser,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x24) ;       // [0-9,a-z]
                                            countT idNewUser = 1 + incv02AM( idNewUserLath ) ;

                                            if( bZe ) idNewUserLath = 0 ;
                                            countT& idNewUserLath = *(countT*)pbi ;
                                        {
                                        if( pbi && cbi == sizeof( countT ) )
                                        fwsLath.getF( tin0P , pbi , cbi , sizeof( countT ) ) ;
                                        ZE( countT , cbi ) ;
                                        ZE( byteT* , pbi ) ;
                                        fileWindowsC fwsLath( tin0P , etThread , tName , flFILEwINDOW_WRITE ) ;

                                        boolT bZe = !etThread.diskFileExistsF( tin0P , tName ) ;
                                        TN( tName , "///ideafarm/ephemeral/ipdos/idNewLiveUserLath" ) ;
                                        _IO_
                                    {
                                    if( !etThread.strCompareF( tin0P , psttValueLive , tTrue ) )   // DISPENSE CREDENTIALS (LIVE)
                                    TN( tBodyInvite , "" ) ;

                                    tNewPassword          = tn ;
                                    tNewUserName          = tn ;
                                    tNewUserNameShort     = tn ;
                                    tValueError3          = tn ;
                                    tValueErrorCode3      = tn ;
                                    tValueError2          = tn ;
                                    tValueErrorCode2      = tn ;
                                    tValueError1          = tn ;
                                    tValueErrorCode1      = tn ;
                                    tInvitationsSubmitted = tn ;
                                    bFail3 = 1 ;
                                    bFail2 = 1 ;
                                    bFail1 = 1 ;
                                    bFail0 = 1 ;
                                    _IO_
                                {
                                while( !ether && !POOP && !bRegistered )     //WILL continue UNTIL SUCCESSFULLY REGISTER A NEW USERNAME ; THIS CAUSES idNewUser TO INCREMENT UNTIL IT IS A VALUE THAT HAS NOT BEEN REGISTERED
                                ZE( boolT , bRegistered ) ;
                                TN( tNewPassword         , "" ) ;
                                TN( tNewUserName         , "" ) ;
                                TN( tNewUserNameShort    , "" ) ;
                                TN( tValueError3         , "" ) ;
                                TN( tValueErrorCode3     , "" ) ;
                                TN( tValueError2         , "" ) ;
                                TN( tValueErrorCode2     , "" ) ;
                                TN( tValueError1         , "" ) ;
                                TN( tValueErrorCode1     , "" ) ;
                                boolT bFail3 = 1 ;
                                boolT bFail2 = 1 ;
                                boolT bFail1 = 1 ;
                                boolT bFail0 = 1 ;
                                TN( tInvitationsSubmitted , "" ) ;
                            {
                            if( !flagsFail )

                            if( !bStudent && !bVisitor ) flagsFail |= flFAIL_UNKNOWNpRODUCT ;

                            ;
                                !etThread.strCompareF( tin0P , psttValueIdProduct , T("prod_RIY6Y4t2Kv3kdr") )      // TEST
                                ||
                                !etThread.strCompareF( tin0P , psttValueIdProduct , T("prod_RJ1RvgWrjbn5VU") )      // LIVE
                            const boolT bVisitor =

                            ;
                                !etThread.strCompareF( tin0P , psttValueIdProduct , T("prod_RGh9084BI1TiHP") )      // TEST
                                ||
                                !etThread.strCompareF( tin0P , psttValueIdProduct , T("prod_RJ1XOIUO9htwyX") )      // LIVE
                            const boolT bStudent =

                            _IO_
                        {
                        if( !flagsFail )

                        //THIS IS NOT AVAILABLE IN THE EVENT THAT I AM PROCESSING: if( age < 13                                                                             ) flagsFail |= flFAIL_UNEXPECTEDaGEtOOyOUNG      ;
                        if( etThread.strCompareF( tin0P , psttValueStripeNoticeType , tCorrectStripeNoticeType ) ) flagsFail |= flFAIL_UNEXPECTEDsTRIPEnOTICEtYPE ;
                        if( etThread.strCompareF( tin0P , psttValueApiVersion       , tCorrectApiVersion       ) ) flagsFail |= flFAIL_UNEXPECTEDaPIvERSION       ;
                        if( etThread.strCompareF( tin0P , psttVersion               , tCorrectVersion          ) ) flagsFail |= flFAIL_UNEXPECTEDvERSION          ;
                        if( etThread.strCompareF( tin0P , psttEvent                 , tCorrectEvent            ) ) flagsFail |= flFAIL_UNEXPECTEDeVENT            ;

                        const sCountT age = etThread.strDigitsToSCountF( tin0P , psttValueAge , 0xa , 1 ) ;
                        TN( tCorrectVersion , "1" ) ;
                        TN( tCorrectEvent    , "stripe.notice" ) ;

                        ZE( strokeS* , psttValueAmountDiscount   ) ; sIn >> psttValueAmountDiscount   ; ___( psttValueAmountDiscount   ) ; etThread.traceF( tin0P , T("[ValueAmountDiscount   ]:    ")+T(psttValueAmountDiscount   ) ) ;
                        ZE( strokeS* , psttValueIdSubscription   ) ; sIn >> psttValueIdSubscription   ; ___( psttValueIdSubscription   ) ; etThread.traceF( tin0P , T("[ValueIdSubscription   ]:    ")+T(psttValueIdSubscription   ) ) ;
                        ZE( strokeS* , psttValueMode             ) ; sIn >> psttValueMode             ; ___( psttValueMode             ) ; etThread.traceF( tin0P , T("[ValueMode             ]:    ")+T(psttValueMode             ) ) ;
                        ZE( strokeS* , psttValueName             ) ; sIn >> psttValueName             ; ___( psttValueName             ) ; etThread.traceF( tin0P , T("[ValueName             ]:    ")+T(psttValueName             ) ) ;
                        ZE( strokeS* , psttValueEmail            ) ; sIn >> psttValueEmail            ; ___( psttValueEmail            ) ; etThread.traceF( tin0P , T("[ValueEmail            ]:    ")+T(psttValueEmail            ) ) ;
                        ZE( strokeS* , psttValuePostalCode       ) ; sIn >> psttValuePostalCode       ; ___( psttValuePostalCode       ) ; etThread.traceF( tin0P , T("[ValuePostalCode       ]:    ")+T(psttValuePostalCode       ) ) ;
                        ZE( strokeS* , psttValueCountry          ) ; sIn >> psttValueCountry          ; ___( psttValueCountry          ) ; etThread.traceF( tin0P , T("[ValueCountry          ]:    ")+T(psttValueCountry          ) ) ;
                        ZE( strokeS* , psttValueHawker           ) ; sIn >> psttValueHawker           ; ___( psttValueHawker           ) ; etThread.traceF( tin0P , T("[ValueHawker           ]:    ")+T(psttValueHawker           ) ) ;
                        ZE( strokeS* , psttValueAge              ) ; sIn >> psttValueAge              ; ___( psttValueAge              ) ; etThread.traceF( tin0P , T("[ValueAge              ]:    ")+T(psttValueAge              ) ) ;
                        ZE( strokeS* , psttValueAmountTotal      ) ; sIn >> psttValueAmountTotal      ; ___( psttValueAmountTotal      ) ; etThread.traceF( tin0P , T("[ValueAmountTotal      ]:    ")+T(psttValueAmountTotal      ) ) ;
                        ZE( strokeS* , psttValueAmountSubtotal   ) ; sIn >> psttValueAmountSubtotal   ; ___( psttValueAmountSubtotal   ) ; etThread.traceF( tin0P , T("[ValueAmountSubtotal   ]:    ")+T(psttValueAmountSubtotal   ) ) ;
                        ZE( strokeS* , psttValueApiVersion       ) ; sIn >> psttValueApiVersion       ; ___( psttValueApiVersion       ) ; etThread.traceF( tin0P , T("[ValueApiVersion       ]:    ")+T(psttValueApiVersion       ) ) ;
                        ZE( strokeS* , psttValueIdProduct        ) ; sIn >> psttValueIdProduct        ; ___( psttValueIdProduct        ) ; etThread.traceF( tin0P , T("[ValueIdProduct        ]:    ")+T(psttValueIdProduct        ) ) ;
                        ZE( strokeS* , psttValueStripeNoticeType ) ; sIn >> psttValueStripeNoticeType ; ___( psttValueStripeNoticeType ) ; etThread.traceF( tin0P , T("[ValueStripeNoticeType ]:    ")+T(psttValueStripeNoticeType ) ) ;
                        ZE( strokeS* , psttValueLive             ) ; sIn >> psttValueLive             ; ___( psttValueLive             ) ; etThread.traceF( tin0P , T("[ValueLive             ]:    ")+T(psttValueLive             ) ) ;
                        ZE( strokeS* , psttVersion               ) ; sIn >> psttVersion               ; ___( psttVersion               ) ; etThread.traceF( tin0P , T("[Version               ]:    ")+T(psttVersion               ) ) ;
                        ZE( strokeS* , psttEvent                 ) ; sIn >> psttEvent                 ; ___( psttEvent                 ) ; etThread.traceF( tin0P , T("[Event                 ]:    ")+T(psttEvent                 ) ) ;

                        _IO_
                    {
                    if( !( F(flagsFail) & flFAIL_COULDnOTgETsHADOW ) )
                    ZE( boolT , bFailPermanent ) ;

                    }
                        }
                            etThread.traceF( tin0P , TT(timeN1,timeN2)+T(" | could not get shadow of ")+T((strokeS*)tIfoName)+T(": ") ) ;
                            flagsFail |= flFAIL_COULDnOTgETsHADOW ;
                            POOPR ;
                        {
                        if( POOP )
                        ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , sIn , tIfoName ) ;
                        SCOOPS
                    {
                    IFsCRATCHoK
                    soulC sIn( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
                    IFsCRATCHoK{}

                    ZE( flagsT , flagsFail ) ;
                    etThread.traceF( tin0P , TT(timeN1,timeN2)+T(" | receiving ")+T((strokeS*)tIfoName)+T(": ") ) ;

                    etThread.traceF( tin0P , tShort ) ;

                    }
                        etThread.delF( tin0P , psttShort ) ;
                        tShort = T(psttShort) ;
                        etThread.delF( tin0P , psttnu ) ;
                        etThread.strBisectF( tin0P , psttnu , psttShort , tIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShort , "" ) ;

                    TN( tIfoName , pInfo->psttIfoName ) ;
                    _IO_
                {
                if( !bDir )

                const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
                _IO_
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirF( tin0P , pInfo , hFind , tFolderIncoming ) ;
            ZE( infoFileS* , pInfo ) ;
            _IO_
        {
        do
        handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

        }
            while( !ether && ~hFind && !POOP ) ;
            }
                DEL( pInfo ) ;
                }
                    }
                        etThread.traceF( tin0P , tShort ) ;
                        etThread.diskMoveFileOrDirF( tin0P , tFolderIncoming+tShort , pInfo->psttIfoName ) ;

                        }
                            etThread.delF( tin0P , psttShort ) ;
                            tShort = T(psttShort) ;
                            etThread.delF( tin0P , psttnu ) ;
                            etThread.strBisectF( tin0P , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShort , "" ) ;
                    {
                    if( !bDir )

                    const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
                {
                else
                }
                    break ;
                    DEL( pInfo ) ;
                {
                if( !pInfo || !pInfo->psttIfoName )

                etThread.diskFindFileOrDirF( tin0P , pInfo , hFind , tFolderToRetry ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            do
            handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

            timeL2 = timeN2 ;
            timeL1 = timeN1 ;
            _IO_
        {
        if( timeE2 || timeE1 > TICK )

        etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeL1 , timeL2 ) ;
        sCountT timeE2 = timeN2 ;
        countT  timeE1 = timeN1 ;

        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;
        _IO_
    {
    while( !ether && !etThread )
    ZE( countT  , idUniquifier ) ;
    ZE( sCountT , timeL2 ) ;
    ZE( countT  , timeL1 ) ;
    TN( tSlash , "/" ) ;

    ranUniC ruPassword( tin0P , (measure04T)MAXcOUNTT + 1 , processGlobal1S::_processGlobal1I_IF().trueRandom ) ;

    etThread.diskMakeDirIfNeededF( tin0P , tFolderAbandoned ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFolderToRetry   ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFolderDone      ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFolderIncoming  ) ;

    TN( tn                       , ""                              ) ;
    TN( tb4                      , "    "                          ) ;
    TN( tcrlf                    , "\r\n"                          ) ;
    TN( tCorrectStripeNoticeType , "customer.subscription.created" ) ;
    TN( tCorrectApiVersion       , "2023-10-16"                    ) ;
    TN( tFalse                   , "false"                         ) ;
    TN( tTrue                    , "true"                          ) ;
    TN( tFolderAbandoned         , ""                              ) ; tFolderAbandoned = T("///ideafarm/ephemeral/ipdos/orders.3.abandoned/") ;
    TN( tFolderToRetry           , ""                              ) ; tFolderToRetry   = T("///ideafarm/ephemeral/ipdos/orders.2.to.retry/" ) ;
    TN( tFolderDone              , ""                              ) ; tFolderDone      = T("///ideafarm/ephemeral/ipdos/orders.4.done/"     ) ;
    TN( tFolderIncoming          , ""                              ) ; tFolderIncoming  = T("///ideafarm/ephemeral/ipdos/orders.1.incoming/" ) ;
    _IO_
{
if( pTaskP )
TASK( tmWorkF )

#define flFAIL_UNKNOWNpRODUCT                   0xe01000ff
#define flFAIL_COULDnOTzAPrAW                   0xe00800ff
#define flFAIL_COULDnOTgEThMAC                  0xe00400ff
#define flFAIL_COULDnOTpUTrAW                   0xe00200ff
#define flFAIL_COULDnOTgETsHAREDsECRET          0xe00100ff
#define flFAIL_UNEXPECTEDaGEtOOyOUNG            0xe00080ff
#define flFAIL_UNEXPECTEDsTRIPEnOTICEtYPE       0xe00040ff
#define flFAIL_UNEXPECTEDaPIvERSION             0xe00020ff
#define flFAIL_UNEXPECTEDvERSION                0xe00010ff
#define flFAIL_UNEXPECTEDeVENT                  0xe00008ff
#define flFAIL_COULDnOTmOVEfILE                 0xe00004ff
#define flFAIL_COULDnOTgETsHADOW                0xe00002ff
#define flFAIL_UNKNOWNeRROR                     0xe00001ff

//OBSOLETES 877_

/*1*/WAKEhIDE( "ifcIDaDAM_EATiNCOMINGoRDERSoLD" )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

