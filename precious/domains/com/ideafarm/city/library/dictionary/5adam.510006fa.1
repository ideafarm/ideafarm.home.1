
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//



REST

etThread.loafIF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("ok") ) ;

}
    while( ~hFind && !ether && !POOP ) ;
    }
        DEL( pInfo ) ;
        }
            }
                etThread.delF( tinBaseP , posti ) ;
                }
                    }
                        etThread.fileWriteF( tinBaseP , fo , postBar , sizeof postBar - 1 ) ;
                        etThread.fileWriteF( tinBaseP , fo , posti , costi ) ;
                        swOuterTally ++ ;

                        if( !swOuterTally.idSlotOfLeverF( tinBaseP , (countT)psttLever ) ) etThread.fileWriteF( tinBaseP , fo , postBar , sizeof postBar - 1 ) ;

                        etThread.fileSetPtrF( tinBaseP , fo , flSETfILEpTR_END , c2z ) ;
                        count2S c2z ;

                        fileC fo( tinBaseP , (strokeS*)( tPrefix+T(psttLever)+tSuffix ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeO ) ;

                        //etThread.traceF( tinBaseP , psttLever ) ;
                        psttLever = (strokeS*)swInnerUnique.leverF( tinBaseP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )                                                                    // FOR EACH EMAIL ADDRESS THAT OCCURS WITHIN THIS ITEM
                    countT cFlavors = swInnerUnique.cFlavorsF( tinBaseP ) ;

                    }
                        etThread.delF( tinBaseP , pstt1Lines ) ;
                        }
                            }
                                etThread.delF( tinBaseP , pstt1Words ) ;
                                }
                                    if( save > 0x30 ) psttc2->idAdam = save ;
                                    swInnerUnique ++ ;                                                                                  // TALLY THE EMAIL ADDRESS
                                    psttLever = psttc2 ;

                                    etThread.strCleanF( tinBaseP , psttc2 , S1C('.') , ifcIDtYPEsTROKEcLEAN_CnAMESoRaT ) ;

                                    if( save > 0x30 ) psttc2->idAdam = 0x30 ;
                                    countT save = psttc2->idAdam ;
                                {
                                FORsTRINGSiN2( pstt1Words )                                                                             // FOR EACH EMAIL ADDRESS
                                etThread.strWordsF( tinBaseP , pstt1Words , psttc1 , sttq , tPattern , flSTRwORDS_DELIMITERsTRING|flSTRwORDS_DELIMITERS|flSTRwORDS_ONLYdELIMITERS ) ; ___( pstt1Words ) ;
                                ZE( strokeS* , pstt1Words ) ;

                                //etThread.traceF( tinBaseP , psttc1 ) ;
                            {
                            )
                                || 1 == etThread.strIdF( tinBaseP , tLook4 , psttc1 )
                                || 1 == etThread.strIdF( tinBaseP , tLook3 , psttc1 )
                                || 1 == etThread.strIdF( tinBaseP , tLook2 , psttc1 )
                                   1 == etThread.strIdF( tinBaseP , tLook1 , psttc1 )
                            (
                            if

                            etThread.strConvertToLowerCaseF( tinBaseP , psttc1 ) ;
                        {
                        FORsTRINGSiN1( pstt1Lines )
                        etThread.strWordsF( tinBaseP , pstt1Lines, tHead , sttq , tcrlf , flSTRwORDS_DELIMITERsTRING ) ; ___( pstt1Lines ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        ZE( strokeS* , pstt1Lines ) ;

                        }
                            *poste = save ;
                            tHead = T(posti) ;
                                   *poste = 0 ;
                            save = *poste ;
                        {
                        else
                        if( !poste ) tHead = T(posti) ;
                        ZE( osTextT , save ) ;
                        TN( tHead , "" ) ;

                        osTextT* poste = thirdC::c_strstrIF( tinBaseP , posti , "\r\n\r\n" ) ;
                    {
                    switchC swInnerUnique( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttLever ) ;

                    etThread.fileWriteF( tinBaseP , fo , postBar , sizeof postBar - 1 ) ;
                    etThread.fileWriteF( tinBaseP , fo , posti , costi ) ;
                {
                if( posti && costi )
            
                etThread.boxGetShadowF( tinBaseP , posti , costi , pInfo->psttIfoName ) ; ___( posti ) ;
                ZE( countT   , costi ) ;
                ZE( osTextT* , posti ) ;

                etThread.traceF( tinBaseP , tShort ) ;
            {

            }
                etThread.delF( tinBaseP , psttShort ) ;
                etThread.delF( tinBaseP , psttPath ) ;
                tShort = T(psttShort) ;
                ___( psttShort ) ;
                ___( psttPath ) ;
                etThread.strBisectF( tinBaseP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttPath ) ;
            {
            TN( tShort , "" ) ;
        {
        if( pInfo && pInfo->psttIfoName && pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam != '/' )
        etThread.diskFindFileOrDirOldF( tinBaseP , pInfo , hFind , tLike ) ; ___( pInfo ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    TN( tLook4 , "bcc" ":" ) ;
    TN( tLook3 , "cc" ":" ) ;
    TN( tLook2 , "to:" ) ;
    TN( tLook1 , "from:" ) ;
    TN( tcrlf , "\r\n" ) ;
    TN( tSlash , "/" ) ;
    TN( tLike , "///d/tmp/gmail.download/3.renamed/*") ;
    //TN( tLike , "///d/tmp/gmail.download/3.renamed/20071214@035705.000051bd.eml") ;

    switchC swOuterTally( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttLever ) ;
    ZE( strokeS* , psttLever ) ;

    etThread.fileWriteF( tinBaseP , fo , postBar , sizeof postBar - 1 ) ;

    fileC fo( tinBaseP , (strokeS*)( tPrefix+T("all")+tSuffix ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
    TN( tSuffix , ".txt" ) ;
    TN( tPrefix , "///d/tmp/gmail.download/4.dialogs/20990024@0001.email.dialog." ) ;
{

;

    +S2(sa_SSSaNDeND,sc_ccSSS)

        +S2(sa_SSSoReND,sc_ccSSS)
        +T(TdISALLOW)
        +S3(sa_SSSoR,sc_ccSSS,sp_SSSfLAGnOT)
        +S3(0,sc_ccSSSrEPEAT,-1)
        +T("@")
        +S2(sa_SSSoReND,sc_ccSSS)
        +T(TdISALLOW)
        +S3(sa_SSSoR,sc_ccSSS,sp_SSSfLAGnOT)
        +S3(0,sc_ccSSSrEPEAT,-1)

    +S2(sa_SSSaND,sc_ccSSS)
    T("")

TN( tPattern , "" ) ; tPattern =

TODO

#define TdISALLOW TbLACK "@<>,:;\"\'"

osTextT postBar[] = "\r\n_______________________________________________________________________________________________________________________________\r\n@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@_@\r\n\r\n" ;

/*1*/WAKEsHOWtEXT( "tool.email.concatenate.conversations" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

