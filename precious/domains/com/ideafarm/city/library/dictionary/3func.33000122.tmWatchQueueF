
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

DONE( tmWatchQueueF )
}
    }
        }
            if( bWoth ) bWoth = 0 ;

            }
                while( !ether && ~hFindFile && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        if( !bDir ) queueP << pInfoFile->psttIfoName ;
                        const boolT bDir = pInfoFile->psttIfoName[ CSpREFIX - 1 + pInfoFile->psttIfoName->idAdam ].idAdam == '/' ;
                    {
                    else
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( !pInfoFile || !pInfoFile->psttIfoName )

                    etThread.diskFindFileOrDirF( tin0P , pInfoFile , hFindFile , queueP.psttLongIn , &patUse ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                handleC hFindFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {

            //ether.traceF( tin0P , T(bWoth?"starting to watch":"file name change detected") ) ;
            _IO_
        {
        if( bWoth || etThread.etherC::diskWaitDirF( tin0P , hWait , queueP.bQuit , queueP.psttLongIn , TOCK << 0 , flWAITdIR_FILEnAME ) )
        _IO_
    {
    while( !queueP.bQuit )
    handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    boolT bWoth = 1 ;

    }
        while( !ether && ~hFindFile && !POOP ) ;
        }
            DEL( pInfoFile ) ;
            }
                }
                    ether.delF( tin0P , pstts ) ;
                    }
                        if( POOP ) { POOPRqUIET }
                        ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , T(queueP.psttLongIn)+T(pstts) , pInfoFile->psttIfoName , 1 ) ;
                        SCOOPS
                        _IO_
                    {
                    IFsCRATCHoK

                    ether.delF( tin0P , psttnu ) ;
                    ether.strBisectF( tin0P , psttnu , pstts , pInfoFile->psttIfoName , queueP.psttSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( pstts ) ;  ___( psttnu ) ;
                    ZE( strokeS* , pstts  ) ;
                    ZE( strokeS* , psttnu ) ;
                {
                if( !bDir )
                const boolT bDir = pInfoFile->psttIfoName[ CSpREFIX - 1 + pInfoFile->psttIfoName->idAdam ].idAdam == '/' ;
            {
            else
            }
                break ;
                DEL( pInfoFile ) ;
            {
            if( !pInfoFile || !pInfoFile->psttIfoName )

            etThread.diskFindFileOrDirF( tin0P , pInfoFile , hFindFile , queueP.psttLongArchive , &patUse ) ; ___( pInfoFile ) ;
            ZE( infoFileS* , pInfoFile ) ;
        {
        do
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        handleC hFindFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    {
    // POUR THE ARCHIVE INTO THE INPUT FOLDER, SKIPPING FILES THAT CANNOT BE MOVED

    const patternC& patUse = pPatP ? *pPatP : pat ;
    patternC pat( tin0P , etThread , T("*") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

    const patternC* pPatP  = queueP ;
    queueC&         queueP = *(queueC*)pTaskP->c1 ;

    _IO_
{
if( pTaskP && pTaskP->c1 )
/*1*/TASK( tmWatchQueueF )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

