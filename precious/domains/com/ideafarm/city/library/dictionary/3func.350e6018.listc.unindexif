
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//



    }
        tinP.ta.retained.u.listWalk.walk.pPoolRecord = 0 ;

        }
            DEL( pPuseIndex ) ;
            PUSE( tinP , *(byteT**)&pczV ) ;
            puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
        {

        }
            { puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ; PUSE( tinP , *(byteT**)&pczIKV ) ; }

            }
                }
                    pczIKV[ ccDoomed ] = 0 ;
                    ccDoomed -- ;
                {
                while( ccDoomed > 1 && F(flLISTwALKrETURNcODE_LISTINGdELETED) & listC::deleteIF( tinP , pczIKV , flLISTdELETE_IFeMPTY ) )
                countT ccDoomed = ccIKV ;

                thirdC::c_memcpyIF( tinP , (byteT*)( pczIKV + ccIK ) , (byteT*)pczV  , sizeof( countT ) * ( ccV      + 1 ) ) ;
                thirdC::c_memcpyIF( tinP , (byteT*)  pczIKV          , (byteT*)pczIK , sizeof( countT ) *   ccIK           ) ;
            {
            if( !bFail )

            }
                __Z( pczIKV ) ;
                PUSE.newF( tinP , LF , *(byteT**)&pczIKV , sizeof( countT ) * ( ccIKV + 1 ) ) ; ___( pczIKV ) ;
                puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
            {
            countT ccIKV = ccIK + ccV ;
            countT ccV   = thirdC::c_strlenIF( tinP , pczV  ) ;
            countT ccIK  = thirdC::c_strlenIF( tinP , pczIK ) ;
            ZE( countT* , pczIKV ) ;
        {
        if( !bFail )

        }
            DELlIST( fieldEditParamOutC , pOut ) ;
            puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
        {

        }
            }
                listC::fieldIF( tinP , pOut , hIKV , pczField , _1_deleteC() + _1_ok_equal_C( recordP ) , LF ) ;
                countT pczField[] = { LISTnAME_RECORD , 0 } ;
            {
            if( !bFail )

            if( bOpenIK ) hIKP.closeIfF() ;
            if( bFail && bSmelly ) { __1 }
            if( !hIKV ) bFail = 1 ;
            listC::openIF( tinP , hIKV , hIKP , pczV , flLISToPEN_IFeXISTS ) ;
            handleC hIKV( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
        {
        if( !bFail )
        ZE( fieldEditParamOutC* , pOut ) ;

        }
            if( bFail && bSmelly ) { __1 }
            if( !hIKP ) bFail = 1 ;
            listC::openIF( tinP , hIKP , pczIK , flLISToPEN_IFeXISTS ) ;
            THREADmODE3rESTORE
            listC::dictionaryReplaceOsTextIF( tinP , pczIK ) ;
            THREADmODE3oN( flTHREADmODE3_ALLOWdICTIONARYwHILEgRABBING )
        {
        if( bOpenIK )
        countT pczIK[] = { LISTnAME_ROOT , LISTnAME_SYSTEM , LISTnAME_FIELDvALUEiNDEX , (countT)postMasterPool , idKeyInIndex , 0 } ;
        ZE( boolT , bFail ) ;

        }
            THREADmODE3rESTORE
            }
                }
                    DELzOMBIE( pvspPostKey ) ;
                    idKeyInIndex = dictionaryQueryFromTextIF( tinP , *pvspPostKey ) ;
                {
                if( !bLiteralKey )

                }
                    ___( pPuseIndex ) ;
                    puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
                {

                ;
                    : new( 0 , tinP , LF ) puseC( tinP , idStateSpace == ifcIDsTATEsPACE_SINGLEaDAM( tinP ) || idStateSpace == ifcIDsTATEsPACE_SCRATCH ? ifcIDpOOL_ADAMtEMP : ifcIDpOOL_HOMEtEMP )
                    ? new( 0 , tinP , LF ) puseC( puseIndexP )
                pPuseIndex = !bOpenIK
                puseat.doNotRestoreTinWhenDieF() ;
                puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;

                }
                    *pvspPostKey = dictionaryQueryFromIdIF( tinP , idKeyP ) ;
                    pvspPostKey = new( 0 , tinP , pbvsp , sizeof pbvsp ) blobVSP ;
                {
                if( !bLiteralKey )
                ZE( blobVSP* , pvspPostKey ) ;
                byteT pbvsp[ sizeof( blobVSP ) ] ;
                boolT bLiteralKey = LISTnAME_min <= idKeyP && idKeyP << LISTnAME_max ;
            {
            THREADmODE3oN( flTHREADmODE3_ALLOWdICTIONARYwHILEgRABBING )
        {
        if( !bOpenIK || thirdC::c_strcmpIF( tinP , postMasterPool , "adam.temp" ) )
        countT idKeyInIndex = idKeyP ;
        ZE( puseC* , pPuseIndex ) ;
        puseC puseMaster( tinP , *tinP.pPoolUse ) ;

        const countT idStateSpace = PUSE.idStateSpaceF() ;
        ;
            : PUSE.postNameF( tinP )
            ? 0
        const osTextT* postMasterPool = !bOpenIK

        boolT bSmelly = !( F(flagsP) & flUNiNDEXf_IFiNDEXED ) ;
        boolT bOpenIK = !hIKP ;

        }
            etherC::strStretchIF( tinP , pczV , 0 , valueP , cNetP ) ; ___( pczV ) ;
            puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
        {
        ZE(  countT* , pczV ) ;

        tinP.ta.retained.u.listWalk.walk.pPoolRecord = &PUSE ;

        }
            if( POOP ) return ;
            FV( flUNiNDEXf , flagsP ) ;
            if( bCareful != - 1 ) { __( bCareful ) ; }
            countT bCareful = (- 1) ;
            if( POOP ) return ;
            __( !!tinP.ta.retained.u.listWalk.walk.pPoolRecord ) ;
            __Z( idKeyP ) ;
            if( POOP ) return ;
        {
        IFbEcAREFUL
    {
    voidT listC::unIndexIF( tinS& tinP , puseC& puseIndexP , handleC& hIKP , const countT idKeyP , const countT valueP , const countT cNetP , const listingC& recordP , const listingC& datumP , const flagsT flagsP )

//#define FD_UNiNDEXif(countT,- 1)

// /*1*/FD_UNiNDEXif( countT , - 1 )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

