
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("ok") ) ;

}
    }
        ContinueDebugEvent( event.dwProcessId , event.dwThreadId , DBG_EXCEPTION_NOT_HANDLED ) ;

        }
            }
                }
                    break ;

                    if( event.u.LoadDll.hFile && event.u.LoadDll.hFile != INVALID_HANDLE_VALUE ) CloseHandle( event.u.LoadDll.hFile ) ; event.u.LoadDll.hFile = 0 ;
                {
                case LOAD_DLL_DEBUG_EVENT :
                }
                    break ;

                    //if( event.u.CreateThread.hThread && event.u.CreateThread.hThread != INVALID_HANDLE_VALUE ) CloseHandle( event.u.CreateThread.hThread ) ; event.u.CreateThread.hThread = 0 ;
                    //IT IS AN ERROR TO CLOSE THIS HANDLE ; THE BASE O.S. WILL CLOSE IT WITHIN ContinueDebugEvent for EXIT_THREAD
                {
                case CREATE_THREAD_DEBUG_EVENT :
                }
                    break ;

                    //if( event.u.CreateProcessInfo.hThread  && event.u.CreateProcessInfo.hThread  != INVALID_HANDLE_VALUE ) CloseHandle( event.u.CreateProcessInfo.hThread  ) ; event.u.CreateProcessInfo.hThread  = 0 ;
                    //if( event.u.CreateProcessInfo.hProcess && event.u.CreateProcessInfo.hProcess != INVALID_HANDLE_VALUE ) CloseHandle( event.u.CreateProcessInfo.hProcess ) ; event.u.CreateProcessInfo.hProcess = 0 ;
                    //IT IS AN ERROR TO CLOSE THESE HANDLES ; THE BASE O.S. WILL CLOSE THEM WITHIN ContinueDebugEvent for EXIT_PROCESS

                    if( event.u.CreateProcessInfo.hFile    && event.u.CreateProcessInfo.hFile    != INVALID_HANDLE_VALUE ) CloseHandle( event.u.CreateProcessInfo.hFile    ) ; event.u.CreateProcessInfo.hFile    = 0 ;
                {
                case CREATE_PROCESS_DEBUG_EVENT :
                case EXIT_THREAD_DEBUG_EVENT    : {             break ; }
                case EXIT_PROCESS_DEBUG_EVENT   : { bDone = 1 ; break ; }
            {
            switch( event.dwDebugEventCode )
        {
        if( WaitForDebugEvent( &event , INFINITE ) )
    {
    if( bOk ) while( !bDone )
    ZE( boolT , bDone ) ;
    memset( (char*)&event , 0 , sizeof event ) ;
    DEBUG_EVENT event ;

    CloseHandle( result.hThread  ) ; result.hThread  = 0 ;
    CloseHandle( result.hProcess ) ; result.hProcess = 0 ;

    boolT bOk = CreateProcess( 0 , "null" , 0 , 0 , 0 , DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS , 0 , 0 , &specs , &result ) ;

    specs.dwFillAttribute = BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED ;
    specs.dwYCountChars = 0x300 ;
    specs.dwXCountChars = 0x400 ;
    specs.dwY = specs.dwX = 0 ;
    specs.wShowWindow = /*SW_SHOWMAXIMIZED*/ SW_SHOWMINNOACTIVE ;
    specs.dwFlags = STARTF_USESHOWWINDOW | STARTF_USEPOSITION | STARTF_USECOUNTCHARS | STARTF_USEFILLATTRIBUTE ;
    specs.cb                  = sizeof specs                        ;  
    memset( &specs , 0 , sizeof specs ) ;
    STARTUPINFO specs ;

    memset( &result , 0 , sizeof result ) ;
    PROCESS_INFORMATION result ;
{
while( !ether )

TODO

// I EXEMPLIFY CORRECT CODING OF A SIMPLEST POSSIBLE WIN32 DEBUGGER THAT CORRECTLY CLOSES HANDLES SO THAT THERE IS NO HANDLE LEAKAGE

/*1*/WAKEsHOWtEXT( "example.simplest.win32.debugger.api" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
