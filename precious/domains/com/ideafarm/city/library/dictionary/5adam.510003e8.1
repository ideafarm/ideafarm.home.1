
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tin0P , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    }
        etThread.delF( tin0P , pbd ) ;
        byteT* pbd = (byteT*)cpbd ;
        stStringsOfBytesToDelete >> cpbd ;
        ZE( countT , cpbd ) ;
    {
    while( stStringsOfBytesToDelete )

    }
        DEL( ptbld ) ;
        tableC* ptbld = (tableC*)cptbld ;
        stTablesToDelete >> cptbld ;
        ZE( countT , cptbld ) ;
    {
    while( stTablesToDelete )

    }
        DEL( pstd ) ;
        stackC* pstd = (stackC*)cpstd ;
        stStacksToDelete >> cpstd ;
        ZE( countT , cpstd ) ;
    {
    while( stStacksToDelete )

    }
        bLever.ungrabF( tin0P ) ;
        swsHistory.ungrabF( tin0P ) ;
        }
            }
                etThread.delF( tin0P , pc4r ) ;
                swsHistory >> pc4r ;
                ZE( count4S* , pc4r ) ;
            {
            while( swsHistory )

            lever = swsHistory.leverF( tin0P , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )
        const countT cLevers = swsHistory.cFlavorsF( tin0P ) ;
        swsHistory.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        bLever.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {

    }
        bLever.ungrabF( tin0P ) ;
        }
            etThread.delF( tin0P , pc5s ) ;
            count5S* pc5s = (count5S*)(countT)swState ;
            lever = swState.leverF( tin0P , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )
        const countT cLevers = swState.cFlavorsF( tin0P ) ;
        bLever.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {

    snapshotF( tin0P , etThread , tState , tKey , tHistory , bLever , lever , swState , swKey , swsHistory ) ;

    while( etThread.os_cAllKidThreadsI_IF( tin0P ) > cctAtStart ) etThread.osSleepF( tin0P , TUCK * 0x40 ) ;

    }
        else                    { ZE( countT , tnu ) ; etThread.osThreadF( tin0P , tnu , tmServeF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)pso , (countT)&lever , (countT)&bLever , (countT)&swKey , (countT)&swState , (countT)&swsHistory , (countT)&decoder ) ; }
        if( ether || etThread ) { DEL( pso ) ; }
        socket.acceptF( tin0P , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        ZE( socketC* , pso ) ;
    {
    while( !ether && !etThread )
    ZE( countT , cIn ) ;
    etThread.etherCryF( tin0P ) ;

    sqMatrixOldC decoder = coder.inverseF( tin0P ) ;
    }
        }
            }
                coder( idr , idc ) = xx ;
                while( -- cMult ) xx *= ff ;
                countT cMult = idc ;
                measureT xx = idr ;
                measureT ff = idr ;
            {
            for( idc = 1 ; idc <= cSize ; idc ++ )
        {    
        for( idr = 1 ; idr <= cSize ; idr ++ )
        ZE( countT , idc ) ;
        ZE( countT , idr ) ;
    {                
    sqMatrixOldC coder( tin0P , etThread , cSize ) ;
    const countT cSize = 4 ;

    }
        }
            etThread.osThreadF( tin0P , tnu , tmSnapshotF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)pstp , (countT)&lever , (countT)&bLever , (countT)&swState , (countT)&swKey , (countT)&swsHistory ) ;
            ZE( countT , tnu ) ;

            *pstp << (countT)&tHistory ;
            *pstp << (countT)&tKey ;
            *pstp << (countT)&tState ;
        {
        if( pstp )
        stackC* pstp = new( 0 , tin0P , LF ) stackC( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;
    {

    loadDataF( tin0P , etThread , stStringsOfBytesToDelete , stTablesToDelete , stStacksToDelete , tState , tKey , tHistory , bLever , lever , swState , swKey , swsHistory ) ;
    TN( tHistory , "///ideafarm/ephemeral/city/data/base/ae30104.history" ) ;
    TN( tKey     , "///ideafarm/ephemeral/city/data/base/ae30104.key"     ) ;
    TN( tState   , "///ideafarm/ephemeral/city/data/base/ae30104.state"   ) ;

    stackC stStacksToDelete( tin0P , etThread , TAG( TAGiDnULL ) ) ;
    stackC stTablesToDelete( tin0P , etThread , TAG( TAGiDnULL ) ) ;
    stackC stStringsOfBytesToDelete( tin0P , etThread , TAG( TAGiDnULL ) ) ;

    switchStackC swsHistory( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever , flSTACKc_null , ifcSTACKtYPE_PTR_count4S ) ;
    switchC      swState( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever ) ;
    switchC      swKey( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever ) ;
    batonC       bLever( tin0P , TAG( TAGiDnULL ) ) ;
    ZE( countT , lever ) ;

    socket.listenF( tin0P ) ;
    countT idPort = socket.bindF( tin0P , ifcPORToLD1pASSCODE ) ;
    socketC socket( tin0P , etThread , TAG( TAGiDnULL ) ) ;

    etThread.strokeF( tin0P , TPS(""    ,0x17,S1C('-'))+T("  ")+TPS("caste"  ,8,S1C('-'))+T("  ")+TPS("id"     ,8,S1C('-'))+T("  ")+TPS("id"     ,8,S1C('-'))+T("  ")+TPS("id"      ,8,S1C('-'))+T("  ")+TPS("",8,S1C('-'))+T("\r\n\r\n") ) ;
    etThread.strokeF( tin0P , TPS("time",0x17,S1C('-'))+T("  ")+TPS("citizen",8,S1C('-'))+T("  ")+TPS("citizen",8,S1C('-'))+T("  ")+TPS("session",8,S1C('-'))+T("  ")+TPS("computer",8,S1C('-'))+T("  ")+TPS("passcode",8,S1C('-'))+T("\r\n") ) ;

    etThread.strokeF( tin0P , T("IdeaFarm " "(tm) City PassCode Authority\r\ni maintain the passcode list and approve/deny id/psw pairs\r\n\r\n") ) ;

    { ZE( boolT , bnu ) ; __( !bnu && sizeof( measureT ) != sizeof( countT ) ) ; }

    const countT cctAtStart = etThread.os_cAllKidThreadsI_IF( tin0P ) ;
{
else
}
    etThread.strokeF( tin0P , T("Another ae30104 appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tin0P , TAG( TAGiDnULL ) , T("ae30104") ) ;

TODO

}
    bLeverP.ungrabF( tin0P ) ;

    }
        swsHistoryP.ungrabF( tin0P ) ;

        }
            swsHistoryP << &tbl._CT1_0aF( idr , 2 ) ;
            leverP =  tbl._CT1_04F( idr , 1 ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tin0P ) ;

        tbl.readF( tin0P , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttHistoryP ) ;
        tableC tbl( tin0P , etThread ) ;

        swsHistoryP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {
    if( etThread.diskFileExistsF( tin0P , psttHistoryP ) )

    }
        }
            swStateP = (countT)&tbl._CT1_0bF( idr , 2 ) ;
            leverP   =          tbl._CT1_04F( idr , 1 ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tin0P ) ;

        tbl.readF( tin0P , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttStateP ) ;
        tableC tbl( tin0P , etThread ) ;
    {
    if( etThread.diskFileExistsF( tin0P , psttStateP ) )

    }
        }
            swKeyP =  tbl._CT1_04F( idr , 2 ) ;
            leverP =  tbl._CT1_04F( idr , 1 ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tin0P ) ;

        tbl.readF( tin0P , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttKeyP ) ;
        tableC tbl( tin0P , etThread ) ;
    {
    if( etThread.diskFileExistsF( tin0P , psttKeyP ) )

    bLeverP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
{
voidT loadDataF( tin0S& tin0P , etherC& etThread , stackC& stStringsOfBytesToDeleteP , stackC& stTablesToDeleteP , stackC& stStacksToDeleteP , const strokeS* const psttStateP , const strokeS* const psttKeyP , const strokeS* const psttHistoryP , batonC& bLeverP , countT& leverP , switchC& swStateP , switchC& swKeyP , switchStackC& swsHistoryP )

DONE( tmSnapshotF )
}
    }
        etThread.osSleepF( tin0P , TOCK ) ;
        if( !( idTry % 0x40 ) && !ether ) snapshotF( tin0P , etThread , tState , tKey , tHistory , bLever , lever , swState , swKey , swsHistory ) ;

        idTry ++ ;
    {
    while( !ether && !etThread )
    ZE( countT , idTry ) ;

    DEL( pstkSKH ) ;
    textC&        tHistory   = *(textC*)( *pstkSKH )[ 3 ] ;
    textC&        tKey       = *(textC*)( *pstkSKH )[ 2 ] ;
    textC&        tState     = *(textC*)( *pstkSKH )[ 1 ] ;

    switchStackC& swsHistory = *(switchStackC*)pTaskP->c6 ;
    switchC&      swKey      = *(switchC*)     pTaskP->c5 ;
    switchC&      swState    = *(switchC*)     pTaskP->c4 ;
    batonC&       bLever     = *(batonC*)      pTaskP->c3 ;
    countT&       lever      = *(countT*)      pTaskP->c2 ;
    stackC*       pstkSKH    =  (stackC*)      pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmSnapshotF )

}
    bLeverP.ungrabF( tin0P ) ;

    }
        tbl.writeF( tin0P , psttHistoryP ) ;

        swsHistoryP.ungrabF( tin0P ) ;

        }
            while( handle ) ;
            }
                }
                    tbl.newObjectF( tin0P , *pc4r ) ;
                    tbl.newObjectF( tin0P , leverP ) ;
                    tbl.newEventF( tin0P ) ;
                {
                if( pc4r )
                __Z( pc4r ) ;
                count4S* pc4r = (count4S*)swsHistoryP.downF( tin0P , handle ) ;
            {
            do
            handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

            leverP = swsHistoryP.leverF( tin0P , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )

        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tableC tbl( tin0P , etThread ) ;

        const countT cLevers = swsHistoryP.cFlavorsF( tin0P ) ;

        swsHistoryP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {

    }
        tbl.writeF( tin0P , psttKeyP ) ;

        }
            tbl.newObjectF( tin0P , key ) ;
            tbl.newObjectF( tin0P , leverP ) ;
            tbl.newEventF( tin0P ) ;
            countT key = swKeyP ;
            leverP = swKeyP.leverF( tin0P , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )

        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tableC tbl( tin0P , etThread ) ;

        const countT cLevers = swKeyP.cFlavorsF( tin0P ) ;
    {

    }
        tbl.writeF( tin0P , psttStateP ) ;

        }
            }
                tbl.newObjectF( tin0P , *pc5s ) ;
                tbl.newObjectF( tin0P , leverP ) ;
                tbl.newEventF( tin0P ) ;
            {
            if( pc5s )
            count5S* pc5s = (count5S*)(countT)swStateP ;
            leverP = swStateP.leverF( tin0P , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )

        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tableC tbl( tin0P , etThread ) ;

        const countT cLevers = swStateP.cFlavorsF( tin0P ) ;
    {

    bLeverP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
{
voidT snapshotF( tin0S& tin0P , etherC& etThread , const strokeS* const psttStateP , const strokeS* const psttKeyP , const strokeS* const psttHistoryP , batonC& bLeverP , countT& leverP , switchC& swStateP , switchC& swKeyP , switchStackC& swsHistoryP )

DONE( tmServeF )

}
    }
        DEL( pso ) ;
        pso->writeF( tin0P , (byteT*)&bOk , sizeof bOk ) ;

        bLever.ungrabF( tin0P ) ;

        }
            }
                }
                    }
                        else      etThread.strokeF( tin0P , T("  rejected\r\n") ) ;
                        if( bOk ) etThread.strokeF( tin0P , T("  ok\r\n") ) ;
                        etThread.strokeF( tin0P , TT(time1,time2)+T("  ")+TF3(query.c2,0,8)+T("  ")+TF3(query.c1,0,8)+T("  ")+TF3(ids,0,8)+T("  ")+TF3(query.c5,0,8) ) ;

                        swsHistory << pc4r ;
                        pc4r->c4 = bOk ;
                        pc4r->c3 = query.c5 ;
                        pc4r->c2 = time2 ;
                        pc4r->c1 = time1 ;
                        etThread.osTimeNowF( tin0P , time1 , time2 ) ;
                        ZE( sCountT , time2 ) ;
                        ZE( countT , time1 ) ;
                    {
                    if( pc4r )
                    __Z( pc4r ) ;
                    etThread.newF( tin0P , LF , pc4r ) ; ___( pc4r ) ;
                    ZE( count4S* , pc4r ) ;
                {

                }
                    }
                        }
                            etThread.delF( tin0P , postb ) ;
                            etThread.delF( tin0P , psttEmail ) ;
                            if( psttEmail ) etThread.boxPutF( tin0P , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+T(psttEmail) , postb , costb ) ;
                            etThread.ifcExternalEmailFromIdCitizenF( tin0P , psttEmail , query.c1 ) ;
                            ZE( strokeS* , psttEmail ) ;

                            etThread.delF( tin0P , psttb ) ;
                            countT costb = etThread.strMakeF( tin0P , LF , postb , psttb ) ; ___( postb ) ;
                            ZE( osTextT* , postb ) ;

                            ) ) ; ___( psttb ) ;

                                ".\r\n"
                                "    http://www.ideafarm.com\r\n"
                                "\r\n"
                                "If you suspect foul play, see the IdeaFarm " "(tm) City knowledge tree at\r\n"
                                "\r\n"
                                "supplies the incorrect passcode or session#.\r\n"
                                "id is locked.  That happens whenever someone attempts to login but\r\n"
                                "An email message like this will be sent to you each time your citizen\r\n"
                                "\r\n"
                                "Remember your passcode and your last session#, and keep them secret!\r\n"
                                "WARNING: This event might indicate that someone is impersonating you.\r\n"
                                "\r\n"
                                "    key: ")+TF1((countT)swKey)+T("\r\n"
                                "\r\n"
                                "key when prompted during login:\r\n"
                                "You citizen id has been locked.  To unlock it, specify the following\r\n"
                                "\r\n"
                                "Subject: IdeaFarm " "(tm) City: CIA lock\r\n"

                            etThread.strMakeF( tin0P , LF , psttb , T(

                            ZE( strokeS* , psttb ) ;
                        {

                        //ids = 0 ;
                        swKey = (countT)ranUni ;
                        ranUniC ranUni( tin0P , MAXcOUNTT , 0x32847 ) ; // AN UNGUESSABLE SEED IS SPECIFIED SO THAT THE SEQUENCE WILL HOPEFULLY NOT BE RECOGNIZABLE; (-1 WOULD PRODUCE A WELL KNOWN SEQUENCE)
                        swState = 0 ;
                        etThread.delF( tin0P , pc5s ) ;
                    {
                    if( !bOk )

                    }
                        }
                            bOk = query.c3 == correct ;

                            }
                                etThread.memCopyF( tin0P , (byteT*)&correct , (byteT*)&cpc , sizeof correct ) ;
                                measureT cpc = (measureT)aa * (measureT)ids + (measureT)bb * ids2 + (measureT)cc * ids3 + (measureT)dd * ids4 ;
                                measureT ids4 = ids3 * (measureT)ids ;
                                measureT ids3 = ids2 * (measureT)ids ;
                                measureT ids2 = (measureT)ids  * (measureT)ids ;
                            {
                            ZE( countT , correct ) ;

                                   ids = pc5s->c1 ;
                            sCountT dd = pc5s->c5 ;
                            sCountT cc = pc5s->c4 ;
                            sCountT bb = pc5s->c3 ;
                            sCountT aa = pc5s->c2 ;

                            }
                                countT cFoo = 2 ;
                            {
                            if( pc5s->c1 > 0xfd )
                            //U:
                        {
                        default :
                        }
                            bOk = 1 ;

                            pc5s->c5 = aabbccdd( 4 ) >= 0 ? aabbccdd( 4 ) + 0.5 : aabbccdd( 4 ) - 0.5 ;
                            pc5s->c4 = aabbccdd( 3 ) >= 0 ? aabbccdd( 3 ) + 0.5 : aabbccdd( 3 ) - 0.5 ;
                            pc5s->c3 = aabbccdd( 2 ) >= 0 ? aabbccdd( 2 ) + 0.5 : aabbccdd( 2 ) - 0.5 ;
                            pc5s->c2 = aabbccdd( 1 ) >= 0 ? aabbccdd( 1 ) + 0.5 : aabbccdd( 1 ) - 0.5 ;

                            vectorOldC aabbccdd = decoder * v14 ;
                            v14( 4 ) = *(measureT*)&pc5s->c5 ;
                            v14( 3 ) = *(measureT*)&pc5s->c4 ;
                            v14( 2 ) = *(measureT*)&pc5s->c3 ;
                            v14( 1 ) = *(measureT*)&pc5s->c2 ;
                            vectorOldC v14( tin0P , etThread , cSize ) ;

                            const countT cSize = 4 ;
                            pc5s->c5 = query.c3 ;
                        {
                        case 4 :
                        case 3 : { pc5s->c4 = query.c3 ; bOk = 1 ; break ; }
                        case 2 : { pc5s->c3 = query.c3 ; bOk = 1 ; break ; }
                        case 1 : { pc5s->c2 = query.c3 ; bOk = 1 ; break ; }
                    {
                    switch( pc5s->c1 )
                    // THEN THESE POSITIONS ARE USED TO STORE THE INFERRED COEFFICIENTS (THE INFERRED TOP SECRET PASSCODE)
                    // INITIALLY, c2-c5 WILL BE USED TO STORE THE CALCULATED PASSCODES RECEIVED

                    pc5s->c1 ++ ;
                    count5S* pc5s = (count5S*)(countT)swState ;
                {
                ZE( countT , ids ) ;
            {
            if( swState )

            }
                swState = (countT)pc5s ;
                etThread.memSetF( tin0P , (byteT*)pc5s , sizeof( count5S ) ) ;
                etThread.newF( tin0P , LF , pc5s ) ; ___( pc5s ) ;
                ZE( count5S* , pc5s ) ;
            {
            if( !swState )

            swKey = 0 ;
        {
        else
        if( swKey && swKey != query.c4 ) ;
        #endif
        else
        if( lever == 2 ) bOk = 1 ; // idCitizen == 2 IS A SHARED NONSECURED CITIZEN ID
        #if defined( NEVERdEFINED )
        ZE( boolT , bOk ) ;

        __( query.c2 - 1 ) ; //U: SUPPORT NONHUMAN CITIZENS ONCE LEVER CAN BE A NULL TERMINATED STRING OF countT OBJECTS
        lever = query.c1 ;
        bLever.grabF( tin0P , TAG( TAGiDnULL ) ) ;

        pso->readF( tin0P , (byteT*)&query , sizeof query ) ;
        count5S query ;

        pso->etherF( tin0P , etThread ) ;
        sqMatrixOldC&    decoder    = *(sqMatrixOldC*)   pTaskP->c7 ;
        switchStackC& swsHistory = *(switchStackC*)pTaskP->c6 ;
        switchC&      swState    = *(switchC*)     pTaskP->c5 ;
        switchC&      swKey      = *(switchC*)     pTaskP->c4 ;
        batonC&       bLever     = *(batonC*)      pTaskP->c3 ;
        countT&       lever      = *(countT*)      pTaskP->c2 ;
        socketC*      pso        = (socketC*)      pTaskP->c1 ;
    {
    if( !etThread )

    __( !pTaskP->c7 ) ;
    __( !pTaskP->c6 ) ;
    __( !pTaskP->c5 ) ;
    __( !pTaskP->c4 ) ;
    __( !pTaskP->c3 ) ;
    __( !pTaskP->c2 ) ;
    __( !pTaskP->c1 ) ;
{
if( !etThread )
__Z( pTaskP ) ;
TASK( tmServeF )

/*1*/WAKEhIDE( "city.passcode.authority" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

