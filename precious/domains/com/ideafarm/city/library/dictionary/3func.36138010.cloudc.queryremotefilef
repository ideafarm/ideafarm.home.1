
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            if( POOP ) POOPR ;
            //etScratch.boxPutF( tin0P , T("///d/tmp/x/query.reply.")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(".ttt") , postHear , costHear ) ;
            //countT idIn = ++ idInLath ;
            //static countT idInLath ;

            }
                ether.strMakeFromOsTextF( tin0P , psttHashP , postc2 ) ; ___( psttHashP ) ;
                *poste = 0 ;
                while( *poste && *poste != '\r' && *poste != '\n' ) poste ++ ;
                osTextT* poste = postc2 ;

                while( *postc2 == ' ' ) postc2 ++ ;
                postc2 += sizeof postTagHash - 1 ;
            {
            if( postc2 )

            }
                cbHiP = 0 ; //U::SUPPORT LARGE FILES
                cbLoP = ether.strDigitsToSCountF( tin0P , T(postc1) , 0xa , 1 ) ;

                *poste = 0 ;
                while( *poste && *poste != '\r' && *poste != '\n' ) poste ++ ;
                osTextT* poste = postc1 ;

                while( *postc1 == ' ' ) postc1 ++ ;
                postc1 += sizeof postTagLength - 1 ;
            {
            if( postc1 )

            osTextT* postc2 = thirdC::c_strstrIF( tin0P , postHear , postTagHash ) ;
            osTextT* postc1 = thirdC::c_strstrIF( tin0P , postHear , postTagLength ) ;

            osTextT postTagHash[] = "\nEtag:" ;
            osTextT postTagLength[] = "\nContent-Length:" ;
        {
        if( bOk )

        }
            }
                }
                    POOPR
                {
                if( POOP )

                }
                    }
                        etPrime.osSleepF( tin0P , TOCK ) ;
                        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                        ether.traceF( tin0P , T("will retry after napping for a tock") ) ;

                        POOPR ;
                    {
                    else
                    }
                        break ;
                        bOk = 1 ;
                    {
                    if( !POOP )

                    __( !ether.strIdF( tin0P , tReplyCode200_OK , tHear ) ) ;

                    }
                        break ;
                        etherC::etRockIF( tin0P ).traceF( tin0P , T("authorization refused") ) ;
                    {
                    if( POOP )
                    __NZ( 1 == ether.strIdF( tin0P , tReplyCode401_Unauthorized , tHear ) ) ;
                {
                if( !POOP )

                ether.traceF( tin0P , T(postHear) ) ;
                TN( tHear , postHear ) ;

                costHear = ss.readF( tin0P , postHear , sizeof postHear , flSOCKETcrEAD_STILLhUNGRYiSoK ) ;
                thirdC::c_memsetIF(  tin0P , postHear , sizeof postHear ) ;

                ss.writeF( tin0P , (osTextT*)tSay , (countT)tSay.csF( tin0P ) ) ;
                ss.connectF( tin0P , 443 , socketC::nicNameIF( tin0P , etScratch , tHost ) ) ;
                socketC ss( tin0P , etScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL ) ;

                //}
                //    __1 ;
                //    bWoth = 0 ;
                //{
                //if( bWoth ) //U:: TO FIND A BUG

                SCOOPS
            {
        {
        while( cTries -- && !etPrime && !POOP )
        countT cTries = TUCK >> 5 ;
        //boolT bWoth = 1 ; //U::TO FIND A BUG
        etherC& etScratch = *((tin1S&)tin0P).pEtScratch ;
        etherC& etPrime   = etherC::etPrimeIF( tin0P ) ;
        ZE( boolT , bOk ) ;
        ZE( countT , costHear ) ;
        char postHear[ TOCK ] ; 
    {
    IFsCRATCHoK

    //ether.traceF( tin0P , T("the HEAD utterance has been appended to the log") ) ;
    //LOGrAW( tSay ) ;

    }
        ether.delF( tin0P , psttShortUrlEncoded ) ;
        }
            bHandle.ungrabF( tin0P ) ;
            tSay = T("HEAD ")+tUrlCloudAgent+T("/")+T(psttCloudContainerP)+T("/")+T(psttShortUrlEncoded)+T(" HTTP/1.1\r\nHost: ")+tHost+T("\r\nX-Auth-Token: ")+cloudInfo.tRackspaceAccessToken+T("\r\n\r\n") ;
            cloudInfoS& cloudInfo = *(cloudInfoS*)hCloud.osF( ifcIDtYPEhANDLE_CLOUD ) ;
            bHandle.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        {

        //  
        // X-Auth-Token: f064c46a782c444cb4ba4b6434288f7c
        // Host: storage.clouddrive.com
        // HEAD /v1/MossoCloudFS_0672d7fa-9f85-4a81-a3ab-adb66a880123/archive/shortEncodedName HTTP/1.1
        // 
        // EXAMPLE

        ether.strToUrlF( tin0P , psttShortUrlEncoded , psttShortP ) ; ___( psttShortUrlEncoded ) ;
        ZE( strokeS* , psttShortUrlEncoded ) ;
    {
    TN( tSay , "" ) ;

    _IO_

    }
        if( POOP ) return ;
        __Z( psttShortP ) ;
        __Z( psttCloudContainerP ) ;
        __NZ( psttHashP ) ;
        __NZ( cbHiP ) ;
        __NZ( cbLoP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    SCOOP
{
/*1*/voidT cloudC::queryRemoteFileF( tin0S& tin0P , countT& cbLoP , countT& cbHiP , strokeS*& psttHashP , const strokeS* const psttCloudContainerP , const strokeS* const psttShortP )/*1*/

/**/
*/
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

