
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("ok") ) ;

while( ~hFindDir && !ether && !POOP ) ;
}
    }
        DEL( pInfoDir ) ;
        }
            }
                while( ~hFindFile && !ether && !POOP ) ;
                }
                    }
                        DEL( pInfoFile ) ;
                        }
                            }
                                etThread.fileWriteF( tinBaseP , foRpt , tSay , tSay.csF( tinBaseP ) ) ;

                                TN( tSay , "" ) ; tSay = TP((strokeS*)tShortFile,0x80)+tName+tcr ;

                                }
                                    etThread.delF( tinBaseP , postName ) ;
                                    tName = T(postName) ;
                                    etThread.boxGetShadowF( tinBaseP , postName , costName , tFileMetaNameLong ) ; ___( postName ) ;
                                    ZE( countT   , costName ) ;
                                    ZE( osTextT* , postName ) ;
                                {
                                else
                                if( !etThread.diskFileExistsF( tinBaseP , tFileMetaNameLong ) ) etThread.traceF( tinBaseP , T("error / file does not exist: ")+tFileMetaNameLong ) ;
                                TN( tName , "" ) ;

                                TN( tFileMetaNameLong , "" ) ; tFileMetaNameLong = tArchiveSlash+tShortDir+tShortMetaName ;

                                etThread.delF( tinBaseP , psttShortRoot ) ;
                                TN( tShortMetaName , "" ) ; tShortMetaName = T(psttShortRoot)+tMetaDotCurrentName ;

                                etThread.strSubstringF( tinBaseP , psttShortRoot , idf , idHit , tShortFile ) ; ___( psttShortRoot ) ;
                                countT idf = 1 ;
                                ZE( strokeS* , psttShortRoot ) ;
                            {
                            if( idHit )
                            countT idHit = etThread.strIdF( tinBaseP , tDotDataDot , tShortFile ) ;
                        {
                        else
                        }
                            }
                                etThread.traceF( tinBaseP , T("error / unexpected dir: ")+tArchiveSlash+tShortDir+tShortFile ) ;
                            {
                            if( etThread.strCompareF( tinBaseP , tShortFile , tDotSlash ) && etThread.strCompareF( tinBaseP , tShortFile , tDotDotSlash ) )
                        {
                        if( bDir )
                
                        }
                            etThread.delF( tinBaseP , psttShortFile ) ;
                            tShortFile = T(psttShortFile) ;
                            etThread.delF( tinBaseP , psttnu ) ;
                            etThread.strBisectF( tinBaseP , psttnu , psttShortFile , pInfoFile->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShortFile ) ;
                            ZE( strokeS* , psttShortFile ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShortFile , "" ) ;
                
                        const boolT bDir = pInfoFile->psttIfoName[ CSpREFIX - 1 + pInfoFile->psttIfoName->idAdam ].idAdam == '/' ;
                        TN( tIfoName , pInfoFile->psttIfoName ) ;
                    {
                    else
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( !pInfoFile || !pInfoFile->psttIfoName )
                
                    etThread.diskFindFileOrDirOldF( tinBaseP , pInfoFile , hFindFile , tArchiveSlash+tShortDir+tStar ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                handleC hFindFile( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                etThread.delF( tinBaseP , psttYear ) ;
                fileC foRpt( tinBaseP , (strokeS*)( T("///ideafarm/tmp/rpt.d.archive/")+T(psttYear)+T(".ttt") ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

                etThread.strSubstringF( tinBaseP , psttYear , idf , idl , tShortDir ) ; ___( psttYear ) ;
                countT idl = tShortDir.csF( tinBaseP ) - 1 ;
                countT idf = 1 ;
                ZE( strokeS* , psttYear ) ;

                etThread.traceF( tinBaseP , T("processing dir: ")+tArchiveSlash+tShortDir ) ;
            {
            if( tShortDir.csF( tinBaseP ) > 1 && etThread.strCompareF( tinBaseP , tShortDir , tDotSlash ) && etThread.strCompareF( tinBaseP , tShortDir , tDotDotSlash ) )
        {
        if( bDir )

        }
            etThread.delF( tinBaseP , psttShortDir ) ;
            tShortDir = T(psttShortDir) ;
            etThread.delF( tinBaseP , psttnu ) ;
            etThread.strBisectF( tinBaseP , psttnu , psttShortDir , pInfoDir->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShortDir ) ;
            ZE( strokeS* , psttShortDir ) ;
            ZE( strokeS* , psttnu ) ;
        {
        TN( tShortDir , "" ) ;

        const boolT bDir = pInfoDir->psttIfoName[ CSpREFIX - 1 + pInfoDir->psttIfoName->idAdam ].idAdam == '/' ;
        TN( tIfoName , pInfoDir->psttIfoName ) ;
    {
    else
    }
        break ;
        DEL( pInfoDir ) ;
    {
    if( !pInfoDir || !pInfoDir->psttIfoName )

    etThread.diskFindFileOrDirOldF( tinBaseP , pInfoDir , hFindDir , tArchiveSlash+tStar ) ;
    ZE( infoFileS* , pInfoDir ) ;
{
do
handleC hFindDir( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
TN( tMetaDotCurrentName , "meta.currentname" ) ;
TN( tDotDataDot , ".data." ) ;
TN( tDotDotSlash , "../" ) ;
TN( tDotSlash , "./" ) ;
TN( tStar , "*" ) ;
TN( tSlash , "/" ) ;
TN( tb8 , "        " ) ;
TN( tcr , "\r\n" ) ;
TN( tArchiveSlash , "///d/archive/" ) ;
ZE( countT , cFiles ) ;

//WISH: WO LINE PER FILE IN FORMAT [base file name] [currentname]

TODO

/*1*/WAKEsHOWtEXT( "tool.list.archive.file.names" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
