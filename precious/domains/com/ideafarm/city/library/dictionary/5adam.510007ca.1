
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinBaseP ) ;

etThread.traceF( tinBaseP , T("ok") ) ;

}
    break ; //REMOVE FOR BURN-IN TESTING

    cReceivedFileWindows = 0 ;
    etThread.traceF( tinBaseP , T("received [cReceivedFileWindows]:    ")+TF2(cReceivedFileWindows,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    etThread.traceF( tinBaseP , T("process [mTocks]:    ")+TT(timeE1,timeE2)+tb4+TF2(mTocksE,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tinBaseP , T("throw   [mTocks]:    ")+TT(timeT1,timeT2)+tb4+TF2(mTocksT,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tinBaseP , T("[mGBits]:            ")+TF2(mGBits,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tinBaseP , T("[cGram]:            ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    measureT mGBits = (measureT)( cb04Thrown << 3 ) / ( TICK << 2 ) ;

    measureT mTocksE = (measureT)timeE1 / TOCK ;
    measureT mTocksT = (measureT)timeT1 / TOCK ;

    etThread.osTimeSubtractF( tinBaseP , timeE1 , timeE2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO PROCESS
    etThread.osTimeNowF( tinBaseP , timeE1 , timeE2 ) ;
    ZE( sCountT , timeE2 ) ;
    ZE( countT  , timeE1 ) ;

    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

    etThread.osTimeSubtractF( tinBaseP , timeT1 , timeT2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO THROW
    etThread.osTimeNowF( tinBaseP , timeT1 , timeT2 ) ;
    ZE( sCountT , timeT2 ) ;
    ZE( countT  , timeT1 ) ;

    }
        }
            }
                }
                    cbDone += cbNow ;
                    pbc    += cbNow ;

                    cb04Thrown += cbGram ;
                    cThrown ++ ;

                    sThrow.writeF( tinBaseP , idPortEndpointCatcher , nicNameC() , pbGram , cbGram ) ;
                    //if( !( idGram % TUCK ) ) etThread.traceF( tinBaseP , T("sending [idGram,cbNow,cbGram]:    ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT cbGram = sizeof( udpFileGramHeadFileWindowS ) + cbNow ;
                    //CONoUTrAW( "!" ) ;
                    etThread.memCopyF( tinBaseP , pbPayload , pbc , cbNow ) ;
                    head.secret = secretToUse ;
                    head.len    = cbNow  ;
                    head.off    = cbDone ;
                    head.cbThisGram = sizeof head + cbNow ;
                    //etThread.traceF( tinBaseP , T("throwing window [secretToUse]:    ")+TF2(secretToUse,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    //CONoUTrAW( "+" ) ;

                    idGram ++ ;

                    cbDo -= cbNow ;

                    ;
                        : CBuDPfILEpAYLOAD
                        ? cbDo
                    countT cbNow = cbDo < CBuDPfILEpAYLOAD

                    //etThread.traceF( tinBaseP , T("waited  for a secret") ) ;
                    }
                        Sleep( 100 ) ;
                    {
                    while( !secretToUse )
                    //etThread.traceF( tinBaseP , T("waiting for a secret") ) ;
                {
                while( cbDo )
                countT cbDo = cbw ;
                byteT* pbc = pbw ;

                //etThread.boxPutF( tinBaseP , tFileIn+T(".window.")+tIdWindow , pbw , cbw ) ;
                //etThread.traceF( tinBaseP , T("[tIdWindow,cb]:    ")+tIdWindow+tb4+TF2(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                TN( tIdWindow , "" ) ; tIdWindow = TF3(++idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;
            {
            else
            if( !pbw || !cbw ) break ;

            fwsIn.getF( tinBaseP , pbw , cbw ) ;
            ZE( countT , cbw ) ;
            ZE( byteT* , pbw ) ;
        {
        while( !ether )
        ZE( count04T , cbDone ) ;
        ZE( countT , idWindow ) ;

        head.idMeta     = 0 ;
        head.idMetaType = ifcIDuDPfILEmETAtYPE_CONTENT ;
        head.idFileHi     = 0 ;
        head.idFileLo     = 1 ;
        head.idCmd      = ifcIDcMDuDPfILEgRAM_PUTfILEwINDOW ;

        udpFileGramHeadFileWindowS& head = *(udpFileGramHeadFileWindowS*)pbGram ;
        byteT*               pbPayload = pbGram + sizeof( udpFileGramHeadFileWindowS ) ;
        byteT                pbGram[ sizeof( udpFileGramHeadFileWindowS ) + CBuDPfILEpAYLOAD ] ;

        fileWindowsC fwsIn( tinBaseP , etThread , tFileIn ) ;

        sThrow.bindF( tinBaseP ) ;
        socketC sThrow( tinBaseP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
    {
    ZE( countT , idGram ) ;

    etThread.osTimeNowF( tinBaseP , timeA1 , timeA2 ) ;
    ZE( sCountT , timeA2 ) ;
    ZE( countT  , timeA1 ) ;
{
while( !ether )
TN( tFileIn     , "///d/tmp/foo.ttt" ) ;
ZE( count04T , cb04Thrown ) ;
ZE( countT , cThrown ) ;

//++ s ; ether.osSleepF( tinBaseP , TICK << 4 ) ;         //U:: TO FIND A BUG
++ s ; ether.osSleepF( tinBaseP , TOCK << 2 ) ;         // LET WORKER THREADS GET SET UP

etThread.traceF( tinBaseP , T("waited  for woth secret") ) ;
}
    ++ s ; ether.osSleepF( tinBaseP , TOCK >> 2 ) ;
{
while( !secretToUse && !ether )
etThread.traceF( tinBaseP , T("waiting for woth secret") ) ;

CONoUTrAW( "\r\n" ) ;

}
    etThread.osThreadF( TaRG1( tmUdpFileGetSecretF  ) , (countT)&secretToUse , (countT)&psoEndpointThrower , (countT)&grab_psoEndpointThrower , idPortEndpointCatcher , pcNnMe[ 0 ] , pcNnMe[ 1 ] , pcNnMe[ 2 ] , pcNnMe[ 3 ] ) ;
    const count02T* pcNnMe = nnMe ;
    nicNameC nnMe ;
{

TN( tb4 , "    " ) ;

}
    ++ s ; ether.osSleepF( tinBaseP , TOCK >> 2 ) ;
{
while( ( !idPortEndpointCatcher || !psoEndpointThrower ) && !ether )
sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

etThread.osThreadF( TaRG1( tmUdpFilesEndpointThrowerF ) , (countT)&psoEndpointThrower   , (countT)&grab_psoEndpointThrower   , (countT)&secretToUse          ) ;
etThread.osThreadF( TaRG1( tmUdpFilesEndpointCatcherF ) , (countT)&psoEndpointCatcherNU , (countT)&grab_psoEndpointCatcherNU , (countT)&cReceivedFileWindows ) ;
grabC grab_psoEndpointThrower(   tinBaseP , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS ) ;
grabC grab_psoEndpointCatcherNU( tinBaseP , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS ) ;
ZE( socketC* , psoEndpointCatcherNU ) ;
ZE( socketC* , psoEndpointThrower ) ;
ZE( countT , secretToUse ) ;

ZE( countT , cReceivedFileWindows ) ;

TODO

DONE( tmUdpFilesEndpointThrowerF )
}
    etThread.ifcUdpFilesEndpointF( tinBaseP , ether , idPortEndpointThrowerNU , TICK >> 0 , psoEndpointP , grab_psoEndpointP , pSecretToUseP ) ;
    ZE( countT , idPortEndpointThrowerNU ) ;

    countT*   pSecretToUseP     =    (countT*)pTaskP->c3 ;
    grabC&    grab_psoEndpointP =    *(grabC*)pTaskP->c2 ;
    socketC*& psoEndpointP      = *(socketC**)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmUdpFilesEndpointThrowerF )

DONE( tmUdpFilesEndpointCatcherF )
}
    etThread.ifcUdpFilesEndpointF( tinBaseP , ether , idPortEndpointCatcher , TICK >> 0 , psoEndpointP , grab_psoEndpointP , 0 , &cReceivedFileWindowsP ) ;

    countT&   cReceivedFileWindowsP =   *(countT*)pTaskP->c3 ;
    grabC&    grab_psoEndpointP     =    *(grabC*)pTaskP->c2 ;
    socketC*& psoEndpointP          = *(socketC**)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmUdpFilesEndpointCatcherF )



countT   idPortEndpointCatcher ;    // THIS MUST BE PUBLISHED BY CATCHER SO THAT IT CAN BE KNOWN TO THROWER


//BASELINE: 510007c9

/*1*/WAKEsHOWtEXT( "example.dut.3func.36002200.etherC.ifcUdpFilesEndpointF.now.serialized" )/*1*/
/**/
*/
 this code works and suggests that code like this can keep up with incoming datagrams on a 1 gbit per second wire
 instead, secrets are honored for unlimited requests within an epoch (e.g. a tock or tock << 2)
 i eliminate the concept of ttl for each secret per requester
 baseline: 5adam.510007c2.1
i use hash to map ip address to secret in order to bound the size of the state needed for deluge of spoofed requests for secret
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
