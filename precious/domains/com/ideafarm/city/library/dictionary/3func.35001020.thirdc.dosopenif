
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //LOGrAW( TF2(processGlobal1I.idAdamRoot,flFORMAT_NObIGITvALUES)+T(": dosOpenIF/")+T(postP)+T("/-\r\n") ) ;
    }
        }
            BOSpOOP
            BOS( WHATgbo , BOSoK , DeleteFile( ostoNameTag ) )
            hTag.closeIfF() ;
        {
        if( ~hTag && !handleP )

        }
            }
                }
                    ((tin1S&)tin0P).pag1->_thirdC_.pSwFileOpen->ungrabF( tin0P ) ;

                    THREADmODE3rESTORE

                    }
                        //pThird->delF( tin0P , pbz ) ;
                        DEL( pInfo ) ;
                    {
                    else
                    if( !POOP ) *((tin1S&)tin0P).pag1->_thirdC_.pSwFileOpen = (countT)pInfo ;

                    //U::__( !!*((tin1S&)tin0P).pag1->_thirdC_.pSwFileOpen ) ;
                    }
                        __NZ( pInfoLag ) ;
                        fileOpenS* pInfoLag = (fileOpenS*)(countT)*((tin1S&)tin0P).pag1->_thirdC_.pSwFileOpen ;
                    {
                    if( !!*((tin1S&)tin0P).pag1->_thirdC_.pSwFileOpen )
                    //U::

                    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )     // THIS IS NEEDED BECAUSE pSwFileOpen WILL ALLOCATE FROM POOL, WHICH WOULD CAUSE NONMONOTONIC GRAB

                    ((tin1S&)tin0P).pag1->_thirdC_.cLever_pSwFileOpen = handleP.osF( ifcIDtYPEhANDLE_FILE ) ;
                    ((tin1S&)tin0P).pag1->_thirdC_.pSwFileOpen->grabF( tin0P , TAG( TAGiDnULL ) ) ;
    
                    __( !pInfo->hTag != !ostoNameTag.costF() ) ;

                    fileOpenS* pInfo = new( 0 , tin0P , pbz , sizeof( fileOpenS ) ) fileOpenS( tin0P , *pThird , postP , ostoNameTag.costF() ? (const osTextT*)ostoNameTag : 0 , idAccessP , idShareP , flagsDetailsP , idHowP , flagsAttribute1P , flagsAttribute2P , cbP , hTag ) ;
                    puseC puseat( tin0P , ifcIDpOOL_ADAMtEMP ) ;

                    }
                        handleP.osF( ifcIDtYPEhANDLE_FILE , osh , 0 , flFILEhANDLEnOTE_OPENrEGISTERED ) ;
                        handleP.resetF() ;
                        countT osh = handleP.osF( ifcIDtYPEhANDLE_FILE ) ;
                    {
                {
                if( pbz )
                pThird->newF( tin0P , LF , pbz , sizeof( fileOpenS ) ) ; ___( pbz ) ;  //U::LEAKS ; 20190129@1340: pbz IS (SOMETIMES? ALWAYS?) WRITTEN TO pSwFileOpen SO MIGHT OR MIGHT NOT BE A LEAK
                ZE( byteT* , pbz ) ;
            {
            if( ((tin1S&)tin0P).pPoolUse && pThird && !POOP && !( F(flagsDetailsP) & flOPENdETAILS_DOnOTrEGISTER ) && ~hTag )
    
            //}
            //    //U: LOG THIS ostoEntry
            //    OStEXTAK( ostoEntry  , "\"" ) ;
            //    OStEXTA( ostoEntry  , postP ) ;
            //    OStEXTAK( ostoEntry  , " \"" ) ;
            //    OStEXTC( ostoEntry  , idErrorOs , 0 ) ;
            //    OStEXTAK( ostoEntry  , "thirdC::dosOpenIF: DosOpen failed with idErrorOs = " ) ;
            //    OStEXT( ostoEntry , 0x80 )
            //{
            //if( idErrorOs )

            c2AppNote.c1 = idResultP ;
            HANDLEaPPnOTEScOUNTcLASS& c2AppNote = handleP ;
    
            __Z( handleP ) ;

            BOSpOOP
            }
                ((tin1S&)tin0P).brcQuery = idErrorOs ;
                ((tin1S&)tin0P).bosFail = 1 ;
            {
            if( idErrorOs )

            #endif
                }
                    case ERROR_SHARING_VIOLATION : { idResultP = ifcOPENrESULT_ERRORsHARINGvIOLATION ; break ; }
                {
                switch( ((tin1S&)tin0P).brcLath )
            #if defined( __NT__ )

            //}
            //    LOGrAW( ostoSay ) ;
            //
            //    OStEXTAK( ostoSay , "\"\r\n" ) ;
            //    OStEXTA(  ostoSay , postP ) ;
            //    OStEXTAK( ostoSay , " \"" ) ;
            //    OStEXTC(  ostoSay , idShareP , 0 ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , idAccessP , 0 ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , bNoQuitEarly , 0 ) ;
            //    OStEXTAK( ostoSay , " " ) ;
            //    OStEXTC(  ostoSay , ((tin1S&)tin0P).brcLath , 0 ) ;
            //    OStEXTAK( ostoSay , "dosOpenIF [brcLath,bNoQuitEarly,idAccessP,idShareP,postP]: " ) ;
            //    OStEXT(   ostoSay , TUCK << 1 ) ;
            //{
            //if( ((tin1S&)tin0P).bosFail && ((tin1S&)tin0P).pPoop->flagsF() & flPOOP_SMELLY )
            //THIS DOES NOT WORK

            #endif
                else          idResultP = 0 ;
                if( ~handleP ) idResultP = openResultIfFromOsIF( tin0P , idResultP ) ;
            #ifdef __OS2__
            //LOG1020022( !handleP ) ;
    
            }
                while( !POOP && !handleP && ( bNoQuitEarly || ( cTriesP && -- cTriesP ) ) ) ; // thirdC::thPrimeIF( tin0P ) IS NOT CHECKED HERE BECAUSE IT WOULD HANG IF I AM CALLED DURING TERMINATION, AFTER thPrimeIF HAS BEEN DESTROYED
                }
                    }
                        ++ s ; dosSleepIF( tin0P , TOCK ) ;

                        LOGrAW(   ostoSay ) ;
                        OStEXTAK( ostoSay , "\"\r\n" ) ;
                        OStEXTA(  ostoSay , postP ) ;
                        OStEXTAK( ostoSay , ": \"" ) ;
                        OStEXTC(  ostoSay , ++ cFail , 0 ) ;
                        OStEXTAK( ostoSay , "DosOpenIF/cannot open [postP] " ) ;
                        OStEXT(   ostoSay , TUCK << 1 ) ;
                    {
                    if( !handleP && ( !cTriesP || cTriesP > 1 ) ) // thirdC::thPrimeIF( tin0P ) IS NOT CHECKED HERE BECAUSE IT WOULD HANG IF I AM CALLED DURING TERMINATION, AFTER thPrimeIF HAS BEEN DESTROYED (THIS IS ALSO WHY I DO NOT LOG ANYTHING HERE)
        
                    if( pThird && F(pThird->flagsMode) & flTHIRDmODE_TESTaUTO ) break ;
        
                    #endif

                        //}
                        //    CONoUTrAW( "\"\r\n" ) ;
                        //    CONoUTrAW( postP ) ;
                        //    CONoUTrAW3( "[idErrorOs]: " , idErrorOs , "\r\nfile: \"" ) ;
                        //{
                        //if( idErrorOs )
                        //OBSOLETED BY chatterF CALL WITHIN POOPR
        
                        if( idErrorOs ) handleP.closeIfF() ;
        
                        }
                            case ifcOPENhOW_nCeR : { if( !idErrorOs ) idResultP = ifcOPENrESULT_CREATED   ; else if( idErrorOs == ERROR_ALREADY_EXISTS ) { idErrorOs = 0 ; idResultP = ifcOPENrESULT_TRUNCATED ; } break ; }
                            case ifcOPENhOW_nCeO : { if( !idErrorOs ) idResultP = ifcOPENrESULT_CREATED   ; else if( idErrorOs == ERROR_ALREADY_EXISTS ) { idErrorOs = 0 ; idResultP = ifcOPENrESULT_EXISTED   ; } break ; }
                            case ifcOPENhOW_nCeF : { if( !idErrorOs ) idResultP = ifcOPENrESULT_CREATED   ;                                                                                          break ; }
                            case ifcOPENhOW_nFeR : { if( !idErrorOs ) idResultP = ifcOPENrESULT_TRUNCATED ;                                                                                          break ; }
                            case ifcOPENhOW_nFeO : { if( !idErrorOs ) idResultP = ifcOPENrESULT_EXISTED   ;                                                                                          break ; }
                        {
                        switch( idHowP )

                        }
                            handleP.osF( ifcIDtYPEhANDLE_FILE , osh ) ;
                            idErrorOs = ((tin1S&)tin0P).brcRaw ;
                            BOSdOnOTtEST( WHATgbo , GetLastError() )
                            countT osh = ((tin1S&)tin0P).brcRaw ;
                            BOS( WHATgbo , BOShANDLE , CreateFile( postP , flagsAccess , flagsShare , &sa , how , flagsDetails , 0 ) )
                            BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                            SECURITYaTTRIBUTE_saUNRESTRICTED( 1 ) ; //U:: SET bInherit IN OBEDIENCE TO A PARAMETRIC FLAG
                        {
        
                    #elif defined( __NT__ )
        
                        if( rc ) handleP.closeIfF() ;
        
                        handleP.osF( ifcIDtYPEhANDLE_FILE , (countT)osh ) ;
                        rc = ((tin1S&)tin0P).brcRaw ;
                        BOS( WHATsfw , BOSfAIL , DosOpen( postP , &osh , (ULONG*)&idResultP , cbP , flagsAttribute1 , flagsAttribute2 , how , flagsAccess | flagsShare | flagsDetails , 0 ) )
                        ZE( HFILE , osh ) ;
        
                    #ifdef __OS2__
                {
                do
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                ZE( countT , cFail ) ;
            {
            ZE( countT , idErrorOs ) ;
    
            }
                }
                    }
                        }
                            thirdC::dosOpenIF( tin0P , pEtherP , hTag , countTC() , ostoNameTag , ifcOPENaCCESS_W , 0 , flOPENdETAILS_WRITEnOW | flOPENdETAILS_FAIL  , ifcOPENhOW_nCeF ) ;

                            ostoNameTag.truncateF( TUCK ) ;
                            OStEXTC(  ostoNameTag , ((tin1S&)tin0P).glass.idStep , 0 ) ;
                            OStEXTAK( ostoNameTag , "." ) ;
                            OStEXTC(  ostoNameTag , ((tin1S&)tin0P).glass.idThread , 0 ) ;
                            OStEXTAK( ostoNameTag , "." ) ;
                            OStEXTC(  ostoNameTag , processGlobal1I.idAdamRoot , 0 ) ;
                            OStEXTAK( ostoNameTag , "." ) ;
                        {
                        else
                        }
                            LOGrAW( ostoSay ) ;

                            OStEXTAK( ostoSay , "\r\n" ) ;
                            OStEXTA(  ostoSay , postP ) ;
                            OStEXTAK( ostoSay , "    " ) ;
                            OStEXTC(  ostoSay , ostoNameTag.costF() - TUCK , 0 ) ;
                            OStEXTA(  ostoSay , "error: cannot create validation file because root file name is too long [costExcess,postP]:  " ) ;
                            OStEXT(   ostoSay , TUCK << 2 ) ;
                        {
                        if( ostoNameTag.costF() > TUCK )    // OTHER CODE CAN ASSUME THAT THE FULL postTag IS IN THE NAME, BUT MAY NOT ASSUME THAT THE SUFFIX IS COMPLETE
                        OStEXTA(  ostoNameTag , postTag ) ;
                        OStEXTA(  ostoNameTag , postP ) ;
                    {
                    if( ( idAccessP == ifcOPENaCCESS_WR || idAccessP == ifcOPENaCCESS_W ) && !thirdC::c_strstrIF( tin0P , postP , postTag ) )
                {
                if( pThird && !POOP )

                dosFileDeleteIfCorruptIF( tin0P , postP ) ;
            {
            if( !( F(flagsDetailsP) & flOPENdETAILS_DOnOTvALIDATE ) )
        {
        handleC hTag( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
        OStEXT( ostoNameTag , TUCK << 1 )

        const flagsT flagsAttribute1 = fileAttrOsFromIf1IF( tin0P , flagsAttribute1P , flagsAttribute2P ) ;
        const countT how             = openHowOsFromIfIF( tin0P , idHowP ) ;
        const flagsT flagsDetails    = openDetailsOsFromIfIF( tin0P , flagsDetailsP ) ;
        const flagsT flagsShare      = openShareOsFromIfIF( tin0P , idShareP ) ;
        const flagsT flagsAccess     = openAccessOsFromIfIF( tin0P , idAccessP ) ;

        }
            }
                if( POOP ) POOPR

                //IF I GET TO HERE BECAUSE I EXHAUSTED cTries THEN THE FOLLOWING CODE WILL FAIL IF THE DIRECTORY DOES NOT EXIST
                }
                    }
                        thirdC::dosSleepWinkIF( tin0P , 2 ) ;
                        ((tin1S&)tin0P).pEtScratch->traceF( tin0P , T("my call to diskMakeDirIfNeededF failed    [cRetries,cFail,file]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(++cFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tFile ) ;
                        POOPR
                    {
                    else
                    }
                        break ;
                        if( cFail ) ((tin1S&)tin0P).pEtScratch->traceF( tin0P , T("my call to diskMakeDirIfNeededF succeeded [cRetries,cFail,file]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tFile ) ;
                    {
                    if( !POOP )

                    ((tin1S&)tin0P).pEtScratch->diskMakeDirIfNeededF( tin0P , tFile ) ;
                {
                while( bNoQuitEarly || ( cTries && -- cTries ) )
                ZE( countT , cFail ) ;
                SCOOPS
            {
            IFsCRATCHoK

            countT cTries = cTriesP ;
            TN( tFile , ifFileNameC( tin0P , *pThird , postP ) ) ;
        {
        if( !( F(flagsDetailsP) & flOPENdETAILS_DOnOTmAKEdIRiFnEEDED ) && !( F(((tin1S&)tin0P).flagsThreadMode2) & flTHREADmODE2_DISALLOWpUSE ) && pThird && pThird->pEtherContainsMe && ((tin1S&)tin0P).pPoolUse )
        thirdC* pThird = ((tin1S&)tin0P).pEther ? &(thirdC&)*((tin1S&)tin0P).pEther : 0 ;

        boolT bNoQuitEarly = !cTriesP ;
    {
    _IO_

    }
        if( POOP ) return ;
        if( costaLong > MAX_PATH ) { __( costaLong - 1 ) } ;
        if( POOP ) return ;
        #endif
            __( cbP ) ;
            __( sizeof( countT ) != sizeof( HANDLE ) || fnu ) ;
        #elif defined( __NT__ )
            __( sizeof( countT ) != sizeof( ULONG ) || fnu ) ;
            __( sizeof( countT ) != sizeof( HFILE ) || fnu ) ;
        #ifdef __OS2__
        ZE( boolT , fnu ) ;
        __NZ( !( F(flagsDetailsP) & flOPENdETAILS_DOnOTvALIDATE ) && F(flagsDetailsP) & flOPENdETAILS_DOnOTrEGISTER ) ; // VALIDATION REQUIRES REGISTRATION SO THAT THE TAG FILE CAN BE DELETED WHEN THE HANDLE IS CLOSED
        FV( flOPENdETAILS , flagsDetailsP ) ;
        __Z( postP ) ;
        __( idResultP ) ;
        __( ~handleP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    

    const countT         costTag = thirdC::c_strlenIF( tin0P , postTag ) ;
    const osTextT* const postTag = ".!writing" ;
    const countT         costaLong = !postP ? 0 : 1 + thirdC::c_strlenIF( tin0P , postP ) ;
    //LOGrAW( TF2(processGlobal1I.idAdamRoot,flFORMAT_NObIGITvALUES)+T(": dosOpenIF/")+T(postP)+T("/+\r\n") ) ;
{
/*1*/voidT thirdC::dosOpenIF( tin0S& tin0P , etherC* pEtherP , handleC& handleP , countT& idResultP , const osTextT* const postP , const countT idAccessP , const countT idShareP , const flagsT flagsDetailsP , const countT idHowP , const flagsT flagsAttribute1P , const flagsT flagsAttribute2P , const countT cbP , countT cTriesP )/*1*/

#endif

            ((tin1S&)tin0P).pEther->traceF( tin0P , textC(tin0P,TAG( TAGiDnULL ),flTEXTc_null,"1020022: could not open \"") + textC(tin0P,TAG( TAGiDnULL ),flTEXTc_null,postP) + textC(tin0P,TAG( TAGiDnULL ),flTEXTc_null,"\".") ) ;
        if( bFailP && !( pThird && F(pThird->flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) && ((tin1S&)tin0P).pEther )                            \
                                                                                                                                      \
    #define LOG1020022(bFailP)                                                                                                        \

#if defined( NEVERdEFINED )

/**/
*/
  if not 0 then will try cTriesP times
  if 0 then will retry forever
 cTriesP
  os/2: the number of bytes to allocate when creating a new file
  windows: must be 0
 cbP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010010.flFILEaTTR2!||
 flagsAttribute2P
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010010.flFILEaTTR1!||
 flagsAttribute1P
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010014.ifcOPENhOW!||
 idHowP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010011.flOPENdETAILS!||
 flagsDetailsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010016.ifcOPENsHARE!||
 idShareP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010015.ifcOPENaCCESS!||
 idAccessP
 postP
  os/2: idResultP will be set to a value that indicates what action was taken
   idResultP will contain ifcOPENrESULT_EXISTED or 0 when i return
  windows: idResultP is always set to 0 (no longer true)
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010013.ifcOPENrESULT!||
 idResultP
 handleP
arguments
i assume that i am the only thread that is opening a file of the specified name
\<A HREF=\"5.1020022.1.0.html\"\>definition\</A\>
    
\<A HREF=\"6.$dosOpenIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

