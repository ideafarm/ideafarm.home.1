
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

sgnDone_tmWorkF.waitF( tin0P ) ;                                                         //20241219@0949: STACK OVERFLOW WITH TICK << 0 AFTER BLAMMO ON SAME THREAD
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK << 1 ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

d ++ ;
m ++ ;
y ++ ;

//etThread.osTimeToOldTimeF( tin0P , ms , ss , mm , hh , d , m , y , dow , timeN1 , timeN2 , flOStIMEtOoLDtIME_OLDtIMEiSutc ) ;
  etThread.osTimeToOldTimeF( tin0P , ms , ss , mm , hh , d , m , y , dow , timeN1 , timeN2 , flOStIMEtOoLDtIME_null         ) ;
static ZE(  countT , dow ) ;
static ZE( sCountT , y   ) ;
static ZE(  countT , m   ) ;
static ZE(  countT , d   ) ;
static ZE(  countT , hh  ) ;
static ZE(  countT , mm  ) ;
static ZE(  countT , ss  ) ;
static ZE(  countT , ms  ) ;

//etThread.delF( tin0P , psttNow ) ;
//etThread.traceF( tin0P , T("the time now is (text   ):    ")+T(psttNow) ) ;
//etThread.strFromTimeF( tin0P , psttNow , timeN1 , timeN2 , 0 , 0 , S1C('.') , 0 , ifcIDfORMATtIME_TEXT    , flFORMAT_null ) ; ___( psttNow ) ;

etThread.delF( tin0P , psttNow ) ;
etThread.traceF( tin0P , T("the time now is:    ")+T(psttNow) ) ;
etThread.strFromTimeF( tin0P , psttNow , timeN1 , timeN2 , 0 , 0 , S1C('.') , 0 , ifcIDfORMATtIME_NUMERIC , flFORMAT_null ) ; ___( psttNow ) ;
ZE( strokeS* , psttNow ) ;

etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
ZE( sCountT , timeN2 ) ;
ZE(  countT , timeN1 ) ;

//U:: DEBUG THIS: thirdC::dosPriorityProcessIF( tin0P , ifcTHREADpRIORITY_LAZIEST ) ;     //20241220@2048: THIS ADAM CONSUMES PRACTICALLY ALL OF THE TOTAL CPU USED BY BUNDLE, AND ITS FUNCTION IS NATURALLY LOW PRIORITY AND SUITABLE FOR AS AVAILABLE IDLE PROCESSING

TODO

DONE( tmWorkF )
}
    //etherC::loafIF( tin0P ) ;
    //etThread.trace F( tin0P , T("ok") ) ;

    }
        }
            etThread.traceF( tin0P , T("!exception / socket is impotent") ) ;
            POOPRqUIET
        {
        if( POOP )
    
        //etThread.trace F( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
    
        }
            }
                DEL( pSwPathValue ) ;
                }
                    }
                        etThread.delF( tin0P , psttValue ) ;

                        //etThread.trace F( tin0P , T("********    ") + T(psttPath) + T("   :    ") + T(psttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

                        strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                        psttPath            = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                        _IO_
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                {
                if( !POOP )

                __Z( pSwPathValue ) ;
                etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                ZE( switchC* , pSwPathValue ) ;
                ZE( strokeS* , psttPath     ) ;
            {

            //etThread.trace F( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            //etThread.trace F( tin0P , T("json response:") ) ;
        
            }
                }
                    else if( costj ) break ;
                         if( cNest ) costj ++ ;
        
                    else if( postj[ costj ] == '}' ) cNest -- ;
                         if( postj[ costj ] == '{' ) cNest ++ ;
        
                    if( !cbIn ) break ;
                    countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                {
                for(;;)
                ZE( countT , cNest ) ;
            {
            ZE( countT , costj ) ;
            thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
            osTextT postj[ TUCK << 1 ] ;
        
            sockc.writeF( tin0P , (osTextT*)tSay ) ;
            //etThread.trace F( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            //etThread.trace F( tin0P , T("request:") ) ;
        
            TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/logout/all HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(0,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;
        {
        if( !POOP )
    
        //sockc.connectF( tin0P , 80 , nnServer ) ;
        //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
    
        sockc.connectF( tin0P , 443 , nnServer ) ;
        socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
    
        countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
        countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
        countT timeAllowedConnected = TICK >> 2 ;
    
        nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
        nicNameC nnServer ;
    
        SCOOPS
    {
    IFsCRATCHoK                                                           // LOGOUT

    }
        ++ s ; ether.osSleepF( tin0P , TICK >> 4 ) ;

        }
            }
                etThread.traceF( tin0P , T("!exception / socket is impotent") ) ;
                POOPRqUIET
            {
            if( POOP )
        
            }
                etThread.delF( tin0P , postj ) ;
                }
                    DEL( pSwPathValue ) ;
                    
                    }
                        }
                            etThread.delF( tin0P , psttd ) ;
                            strokeS*& psttd = (strokeS*&)(countT&)swMessage ;
                            psttzlPrefix = (strokeS*)swMessage.leverF( tin0P , idfm ) ;
                        {
                        for( countT idfm = 1 ; idfm <= cFlavorsMessage ; idfm ++ )
                        countT cFlavorsMessage = swMessage.cFlavorsF( tin0P ) ;

                        }
                            etThread.delF( tin0P , psttd ) ;
                            strokeS*& psttd = (strokeS*&)(countT&)swSender ;
                            psttzlPrefix = (strokeS*)swSender.leverF( tin0P , idfm ) ;
                        {
                        for( countT idfm = 1 ; idfm <= cFlavorsSender ; idfm ++ )
                        countT cFlavorsSender = swSender.cFlavorsF( tin0P ) ;

                        }
                            etThread.delF( tin0P , psttValue ) ;
                            }
                                }
                                    }
                                        etThread.boxPutF( tin0P , tSoilFilePathFrom+tShort , tEvals , tEvals.csF( tin0P ) ) ;

                                        etThread.delF( tin0P , psttu ) ;
                                        TN( tShort , "" ) ; tShort  =  tSoilFileShortPrefix+T(psttu)+T(".soil") ;

                                        etThread.strUniqueF( tin0P , psttu ) ; ___( psttu ) ;
                                        ZE( strokeS* , psttu ) ;

                                        etThread.delF( tin0P , psttSoil ) ;
                                        TN( tEvals , psttSoil ) ;

                                        etThread.strFuseF( tin0P , psttSoil , T(postFoot) ) ;
                                        }
                                            while( ~hWalk ) ;
                                            }
                                                etThread.strFuseF( tin0P , psttSoil , tbIndentDetail+T(psttm)+T("\r\n") ) ;
                                                strokeS* psttm = (strokeS*)stMessages.downF( tin0P , hWalk ) ;
                                            {
                                            do
                                            handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        if( stMessages )

                                        etThread.strMakeF( tin0P , LF , psttSoil , T(postHead) , cstta + TUCK ) ; ___( psttSoil ) ;
                                        ZE( strokeS* , psttSoil ) ;

                                        }
                                            while( ~hWalk ) ;
                                            }
                                                if( !POOP ) cstta += psttm->idAdam + 4 + tbIndentTopic.csF( tin0P ) ;        // CRLF CRLF
                                                __Z( psttm ) ;
                                                strokeS* psttm = (strokeS*)stMessages.downF( tin0P , hWalk ) ;
                                            {
                                            do
                                            handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        if( stMessages )
                                        countT cstta = thirdC::c_strlenIF( tin0P , postHead ) + thirdC::c_strlenIF( tin0P , postFoot ) ;

                                        stMessages << pstte ; pstte = 0 ;
                                        etThread.strMakeF( tin0P , LF , pstte , tEntry ) ; ___( pstte ) ;
                                        ZE( strokeS* , pstte ) ;

                                        etThread.traceF( tin0P , T("[post]:    ")+tEntry ) ;
                                        TN( tEntry , "" ) ; tEntry = tMessage+T("\r\n")+tbIndentTopic+tTime+tbOpen+tSender+tCloseColonCRLF ;

                                        tTime = tDayOfWeek+tCommaBlank+tMonth+tb+TF4(++mDay,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+tCommaBlank+TF4(++year,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T(" at ")+TF4(hour,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa)+tColon+TF4(minute,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ;

                                        }
                                            case 0xb : { tMonth = T("December"  ) ; break ; }
                                            case 0xa : { tMonth = T("November"  ) ; break ; }
                                            case 0x9 : { tMonth = T("October"   ) ; break ; }
                                            case 0x8 : { tMonth = T("September" ) ; break ; }
                                            case 0x7 : { tMonth = T("August"    ) ; break ; }
                                            case 0x6 : { tMonth = T("July"      ) ; break ; }
                                            case 0x5 : { tMonth = T("June"      ) ; break ; }
                                            case 0x4 : { tMonth = T("May"       ) ; break ; }
                                            case 0x3 : { tMonth = T("April"     ) ; break ; }
                                            case 0x2 : { tMonth = T("March"     ) ; break ; }
                                            case 0x1 : { tMonth = T("February"  ) ; break ; }
                                            case 0x0 : { tMonth = T("January"   ) ; break ; }
                                        {
                                        switch( month )
                                        TN( tMonth , "" ) ;

                                        }
                                            case 6 : { tDayOfWeek = T("Saturday" ) ; break ; }
                                            case 5 : { tDayOfWeek = T("Friday"   ) ; break ; }
                                            case 4 : { tDayOfWeek = T("Thursday" ) ; break ; }
                                            case 3 : { tDayOfWeek = T("Wednesday") ; break ; }
                                            case 2 : { tDayOfWeek = T("Tuesday"  ) ; break ; }
                                            case 1 : { tDayOfWeek = T("Monday"   ) ; break ; }
                                            case 0 : { tDayOfWeek = T("Sunday"   ) ; break ; }
                                        {
                                        switch( wDay )
                                        TN( tDayOfWeek , "" ) ;                                     //U:: USE etherC API FOR THIS

                                        thirdC::osOldTimeFromUnixTimeIF( tin0P , isDaylightSavingsTime , yDay , wDay , year , month , mDay , hour , minute , second , secondsIntoEpoch ) ;
                                        ZE( boolT  , isDaylightSavingsTime ) ;
                                        ZE( countT , yDay                  ) ;
                                        ZE( countT , wDay                  ) ;
                                        ZE( countT , year                  ) ;
                                        ZE( countT , month                 ) ;
                                        ZE( countT , mDay                  ) ;
                                        ZE( countT , hour                  ) ;
                                        ZE( countT , minute                ) ;
                                        ZE( countT , second                ) ;
                                    {
                                    if( secondsIntoEpoch != - 1 && tSender.csF( tin0P ) )
                                    TN( tTime , "" ) ;
                                    
                                    }
                                        if( !etThread.strCompareF( tin0P , psttzlPrefix , (strokeS*)swTime.leverF( tin0P , idft ) ) ) secondsIntoEpoch = swTime ;
                                    {
                                    for( countT idft = 1 ; idft <= cFlavorsTime ; idft ++ )
                                    countT cFlavorsTime = swTime.cFlavorsF( tin0P ) ;
                                    countT secondsIntoEpoch = - 1 ;

                                    TN( tMessage , (strokeS*&)(countT&)swMessage ) ;
                                    TN( tSender  , (strokeS*&)(countT&)swSender  ) ;
                                {
                                if( !etThread.strCompareF( tin0P , psttzlPrefix , tPrefix ) )

                                psttzlPrefix = (strokeS*)swMessage.leverF( tin0P , idfm ) ;
                            {
                            for( countT idfm = 1 ; idfm <= cFlavorsMessage ; idfm ++ )
                            countT cFlavorsMessage = swMessage.cFlavorsF( tin0P ) ;

                            }
                                }
                                    }
                                        }
                                            break ;

                                            etThread.strMakeF( tin0P , LF , psttMessage , (strokeS*)*pptValue[ offe ] ) ; ___( psttMessage ) ;
                                            etThread.delF( tin0P , psttMessage ) ;
                                            strokeS*& psttMessage = (strokeS*&)(countT&)swMessage ;
                                        {
                                        case 5 :
                                        }
                                            break ;

                                            etThread.strMakeF( tin0P , LF , psttSender , (strokeS*)*pptValue[ offe ] ) ; ___( psttSender ) ;
                                            etThread.delF( tin0P , psttSender ) ;
                                            strokeS*& psttSender = (strokeS*&)(countT&)swSender ;
                                        {
                                        case 4 :
                                        }
                                            break ;
                                            }
                                                etThread.delF( tin0P , psttSeconds ) ;
                                                swTime = (countT)etThread.strDigitsToSCountF( tin0P , psttSeconds , 0xa , 1 ) ;
                                                etThread.strSubstringF( tin0P , psttSeconds , idf , idl , tMs ) ; ___( psttSeconds ) ;
                                                countT idl = csttMs - 3 ;
                                                countT idf = 1 ;
                                                ZE( strokeS* , psttSeconds ) ;
                                            {
                                            if( csttMs > 3 )
                                            countT csttMs = tMs.csF( tin0P ) ;
                                            TN( tMs , "" ) ; tMs = *pptValue[ offe ] ;
                                        {
                                        case 3 :
                                    {
                                    switch( offe )
                                    psttzlPrefix = tPrefix ;

                                    //etThread.trace F( tin0P , T("[prefix]:    ")+tPrefix ) ;

                                    }
                                        etThread.delF( tin0P , psttSuffix ) ;
                                        etThread.delF( tin0P , psttPrefix ) ;
                                        tSuffix = T(psttSuffix) ;
                                        tPrefix  = T(psttPrefix) ;
                                        etThread.strBisectF( tin0P , psttPrefix , psttSuffix , psttPath , T("/") , 6 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPrefix ) ; ___( psttSuffix ) ;
                                        ZE( strokeS* , psttSuffix ) ;
                                        ZE( strokeS* , psttPrefix ) ;
                                    {
                                    TN( tSuffix , "" ) ;

                                    // "rooms"/"join"/"!mdggPdOnBbNwmpeHnH:ideafarm.com"/"timeline"/"events"/item.0000000a/"content"/"body"/

                                    //etThread.trace F( tin0P , T("********    ") + T(psttPath) + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                    *pptValue[ offe ] = T(psttValue) ;
                                {
                                )
                                    )
                                        etThread.strIdF(  tin0P , *pptPathZ[ offe ] , psttPath ) + pptPathZ[ offe ]->csF( tin0P ) - 1 == psttPath->idAdam
                                        &&
                                        etThread.strIdF(  tin0P , *pptPathA[ offe ] , psttPath ) == 1
                                    (
                                    ||
                                    )
                                        !etThread.strCompareF( tin0P , *pptPathA[ offe ] , psttPath )
                                        &&
                                        !pptPathZ[ offe ]->csF( tin0P )
                                    (
                                (
                                if
                            {
                            for( countT offe = 0 ; offe < cValues ; offe ++ )
                            TN( tPrefix  , "" ) ;
                    
                            if( cPathsZ - cValues ) { BLAMMO ; }
                            if( cPathsA - cValues ) { BLAMMO ; }
                            countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                            countT cPathsZ  = sizeof pptPathZ  / sizeof pptPathZ[  0 ] ;
                            countT cPathsA  = sizeof pptPathA  / sizeof pptPathA[  0 ] ;
                    
                            //etThread.trace F( tin0P , T("--------------------------        [value]:    ")+T(psttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                            //etThread.trace F( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                    
                            strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                            psttPath            = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                    
                            _IO_
                        {
                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                        countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;

                        switchC swMessage( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzlPrefix ) ;
                        switchC swSender(  tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzlPrefix ) ;
                        switchC swTime(    tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzlPrefix ) ;
                        ZE( strokeS* , psttzlPrefix ) ;
                    {
                    if( !POOP )
                    
                    ;
                    }
                        &tPathZRoomTopic  ,
                        &tPathZMessage    ,
                        &tPathZSender     ,
                        &tPathZTime       ,
                        &tPathZEnd        ,
                        &tPathZStart      ,
                        &tPathZNextBatch  ,
                    {
                    textC* pptPathZ[] =

                    ;
                    }
                        &tPathARoomTopic  ,
                        &tPathAMessage    ,
                        &tPathASender     ,
                        &tPathATime       ,
                        &tPathAEnd        ,
                        &tPathAStart      ,
                        &tPathANextBatch  ,
                    {
                    textC* pptPathA[] =

                    TN( tPathZRoomTopic , ""                                                                                                                     ) ;                
                    TN( tPathZMessage   , "/\"content\"/\"body\"/"                                                                                               ) ;
                    TN( tPathZSender    , "/\"sender\"/"                                                                                                         ) ;
                    TN( tPathZTime      , "/\"origin_server_ts\"/"                                                                                               ) ;
                    TN( tPathZEnd       , ""                                                                                                                     ) ;
                    TN( tPathZStart     , ""                                                                                                                     ) ;
                    TN( tPathZNextBatch , ""                                                                                                                     ) ;

                    TN( tPathARoomTopic , "\"rooms\"/\"join\"/\"!mdggPdOnBbNwmpeHnH:ideafarm.com\"/\"timeline\"/\"events\"/item.00000002/\"content\"/\"topic\"/" ) ;                
                    TN( tPathAMessage   , "\"rooms\"/\"join\"/\"!mdggPdOnBbNwmpeHnH:ideafarm.com\"/\"timeline\"/\"events\"/item."                                ) ;
                    TN( tPathASender    , "\"rooms\"/\"join\"/\"!mdggPdOnBbNwmpeHnH:ideafarm.com\"/\"timeline\"/\"events\"/item."                                ) ;
                    TN( tPathATime      , "\"rooms\"/\"join\"/\"!mdggPdOnBbNwmpeHnH:ideafarm.com\"/\"timeline\"/\"events\"/item."                                ) ;
                    TN( tPathAEnd       , "\"end\"/"                                                                                                             ) ;
                    TN( tPathAStart     , "\"start\"/"                                                                                                           ) ;
                    TN( tPathANextBatch , "\"next_batch\"/"                                                                                                      ) ;
                    
                    ;
                    }
                        &tValueRoomTopic ,
                        &tValueMessage   ,
                        &tValueSender    ,
                        &tValueTime      ,
                        &tValueEnd       ,
                        &tValueStart     ,
                        &tValueNextBatch ,
                    {
                    textC* pptValue[] =
                    
            
                    }
                        }
                            etThread.traceF( tin0P , T("!exception / could not parse response to sync request") ) ;
                            POOPR
                        {
                        else
                        if( !POOP ) ; // etThread.trace F( tin0P , T("response to sync request was parsed AOK") ) ;

                        __Z( pSwPathValue ) ;

                        ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
            
                        SCOOPS
                    {
                    IFsCRATCHoK
                    ZE( switchC* , pSwPathValue ) ;
                    ZE( strokeS* , psttPath     ) ;
                {

                etThread.delF( tin0P , psttg ) ;
                //etThread.trace F( tin0P , T("[json file]:    ")+T(psttg) ) ;
                etThread.boxPutGenerationF( tin0P , psttg , T("///ideafarm/tmp/")+TfORsTRING(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T("/json/json.sync") , TOCK , postj , costj , 0 , flOPENdETAILS_null , /*T(".json")*/0 ) ; ___( psttg ) ;
                ZE( strokeS* , psttg ) ;

                //etThread.trace F( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                //etThread.trace F( tin0P , T("json response [costj]:    ")+TF2(costj,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE) ) ;

                }
                    }
                        if( cNest ) costj ++ ;
            
                        }
                            }
                                break ;
                                costj ++ ;
                            {
                            if( 1 == cNest -- )
                        {
                        else if( postj[ costj ] == '}' )
                             if( postj[ costj ] == '{' ) cNest ++ ;
            
                        if( !cbIn ) break ;
                        countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                    {
                    for(;;)
                    ZE( countT , cNest ) ;
                {
                ZE( countT , costj ) ;

                sockc.writeF( tin0P , (osTextT*)tSay ) ;
                //etThread.trace F( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                //etThread.trace F( tin0P , T("request:") ) ;

                thirdC::c_memsetIF( tin0P , postj , costaj ) ;
                etThread.newF( tin0P , LF , postj , costaj ) ; ___( postj ) ;
                countT costaj = TICK ;
                ZE( osTextT* , postj ) ;
            
                TN( tSay , "" ) ; tSay = T("GET /_matrix/client/v3/sync")+tQuery+T(" HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer/*+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(tBody.csF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)*/+T("\r\n\r\n")/*+tBody*/ ;

                //etThread.trace F( tin0P , T("requesting sync (update)") ) ;
            {
            if( !POOP )

            ) ;

                ""
                "&since=")+tValueNextBatch+T(

            if( tValueNextBatch.csF( tin0P ) ) tQuery += T(
            TN( tQuery , "?timeout=4000" ) ;
        
            sockc.connectF( tin0P , 443 , nnServer ) ;
            socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
        
            countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
            countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
            countT timeAllowedConnected = TICK >> 2 ;
        
            nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
            nicNameC nnServer ;
        
            SCOOPS
        {
        IFsCRATCHoK

        }
            }
                }
                    }
                        }
                            etThread.traceF( tin0P , T("!exception / could not move the student evaluations soil file to publish it to [tShort]:    ")+tShort ) ;
                            POOPRqUIET
                        {
                        else
                        if( !POOP ) ; // etThread.traceF( tin0P , T("moved the student evaluations soil file to publish it to [tTo,tFrom]:    ")+tTo+tb4+tFrom ) ;
                        ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tTo , tFrom , 1 ) ;
                        SCOOPS
                    {
                    IFsCRATCHoK

                    TN( tFrom , "" ) ; tFrom = tSoilFilePathFrom + tShort ;
                    TN( tTo   , "" ) ; tTo   = tSoilFilePathTo   + tShort ;

                    etThread.delF( tin0P , psttShort ) ;
                    etThread.delF( tin0P , psttPath ) ;
                    TN( tShort , psttShort ) ;
                    etThread.strBisectF( tin0P , psttPath , psttShort , tYoungest , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                    ZE( strokeS* , psttShort ) ;
                    ZE( strokeS* , psttPath ) ;                                                                                     // PUBLISH THE YOUNGEST FILE BY MOVING IT INTO PISS'S MOUTH
                {
                else
                if( cLogsJammed ) etThread.traceF( tin0P , T("not publishing because PISS isn't ready [cLogsJammed]:    ")+TF2(cLogsJammed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                }
                    }
                        ++ cLogsJammed ;
                    {
                    FORsTRINGSiN2( pstt1f )
                    etThread.diskFindFileOrDirF( tin0P , pstt1f , tSoilFilePathCheck ) ; ___( pstt1f ) ;

                    etThread.delF( tin0P , pstt1f ) ;
                    }
                        ++ cLogsJammed ;
                    {
                    FORsTRINGSiN1( pstt1f )
                    etThread.diskFindFileOrDirF( tin0P , pstt1f , tSoilFilePathTo ) ; ___( pstt1f ) ;
                    ZE( strokeS* , pstt1f ) ;
                {                                                                                                                   // VERIFY THAT PISS IS READY TO RECEIVE A NEW SOIL FILE
                ZE( countT , cLogsJammed ) ;

                etThread.delF( tin0P , pstt1f ) ;
                }
                    if( etThread.strCompareF( tin0P , psttc1 , tYoungest ) ) etThread.diskFileOrDirDeleteF( tin0P , psttc1 ) ;
                {
                FORsTRINGSiN1( pstt1f )
                etThread.diskFindFileOrDirF( tin0P , pstt1f , tSoilFilePathFrom ) ; ___( pstt1f ) ;
                ZE( strokeS* , pstt1f ) ;
            {                                                                                                                       // ZAP OLDER FILES THAT SURVIVED DUE TO BEING PRESENTED OUT OF ORDER
            if( tYoungest.csF( tin0P ) )

            }
                etThread.delF( tin0P , pstt1f ) ;
                }
                    }
                        tYoungest = T(psttc1) ;
                        if( tYoungest.csF( tin0P ) ) etThread.diskFileOrDirDeleteF( tin0P , tYoungest ) ;
                    {
                    if( !tYoungest.csF( tin0P ) || 0 < etThread.strCompareF( tin0P , psttc1 , tYoungest ) )
                {
                FORsTRINGSiN1( pstt1f )
                etThread.diskFindFileOrDirF( tin0P , pstt1f , tSoilFilePathFrom ) ; ___( pstt1f ) ;
                ZE( strokeS* , pstt1f ) ;
            {                                                                                                                       // ZAP EACH FILE THAT IS OLDER THAN A FILE ALREADY SEEN ; THIS ONLY ZAPS ALL OF THE OLDER FILES IF THE BASE O.S. PRESENTS THE NAMES IN SORTED ORDER, WHICH IT DOES NOT GUARANTEE TO DO (NTFS)
            TN( tYoungest , "" ) ; // DELETE ALL BUT THE YOUNGEST bot.kt.student.evaluations.*

            timeU2 = timeN2 ;
            timeU1 = timeN1 ;
        {
        if( timeE2 || timeE1 > ( TICK << 2 ) )                                                                                      // LIMIT PUBLICATION SO THAT PISS (AND THE CPU) IS IDLE AND AVAILABLE FOR OTHER WORK

        etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeU1 , timeU2 ) ;
        sCountT timeE2 = timeN2 ;
        countT  timeE1 = timeN1 ;

        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;
    {
    while( !ether && !POOP )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    TN( tSoilFilePathCheck   , "" ) ; tSoilFilePathCheck = T("///ideafarm/IdeaFarm (tm)/")+tUser+T("/1.2. SOIL (tm) Text Files Being Eaten/" ) ;
    TN( tSoilFilePathTo      , "" ) ; tSoilFilePathTo    = T("///ideafarm/IdeaFarm (tm)/")+tUser+T("/1.1. Drop a Copy of SOIL (tm) Text Files Here/" ) ;
    TN( tSoilFilePathFrom    , "" ) ; tSoilFilePathFrom  = T("///ideafarm/tmp/")+TfORsTRING(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T("/soil/") ;
    TN( tSoilFileShortPrefix , "bot.kt.student.evaluations." ) ;
    ZE( sCountT , timeU2 ) ;
    ZE( countT  , timeU1 ) ;        //TIME THAT LATH PUBLICATION OCCURRED
    TN( tValueRoomTopic , "" ) ;
    TN( tValueMessage   , "" ) ;
    TN( tValueSender    , "" ) ;
    TN( tValueTime      , "" ) ;
    TN( tValueNextBatch , "" ) ;
    TN( tValueEnd       , "" ) ;
    TN( tValueStart     , "" ) ;
    TN( tUser , thirdC::postUserNameIF() ) ;

    ;

        "}\r\n"
        "    }\r\n"
        "\r\n"
        "        \\rStudent Evaluations of ICIS IdeaFarm (tm) College of Imagination Science\r\n"

    const osTextT* const postFoot =

    ;

        "\r\n"
        "    {body:\r\n"
        "\r\n"
        "    {namespace: web.root }\r\n"
        "\r\n"
        "    {folder: ///d/web.evaluations/ }\r\n"
        "\r\n"
        "    {flags: noZip beep}\r\n"
        "\r\n"
        "    {mode: about }\r\n"
        "\r\n"
        "    {file: index }\r\n"
        "\r\n"
        "    {domain: ideafarm.com }\r\n"
        "\r\n"
        "{ktr:\r\n"

    const osTextT* const postHead =

    stackC stMessages( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
   
    }
        }
            etThread.traceF( tin0P , T("!exception / socket is impotent") ) ;
            POOPRqUIET
        {
        if( POOP )
    
        //etThread.trace F( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
    
        }
            }
                DEL( pSwPathValue ) ;
                
                }
                    }
                        etThread.delF( tin0P , psttValue ) ;
                
                        }
                            }
                                //etThread.trace F( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                *pptValue[ offe ] = T(psttValue) ;
                            {
                            if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                        {
                        for( countT offe = 0 ; offe < cPaths ; offe ++ )
                
                        if( cPaths - cValues ) { BLAMMO ; }
                        countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                        countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
                
                        //etThread.trace F( tin0P , T("--------------------------        [value]:    ")+T(psttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                        //etThread.trace F( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                
                        strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                        psttPath            = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                
                        _IO_
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                {
                if( !POOP )
                
                ;
                }
                    &tPathDeviceId     ,
                    &tPathAccessToken  ,
                {
                textC* pptPath[] =
                
                TN( tPathDeviceId    , "\"device_id\"/"    ) ;
                TN( tPathAccessToken , "\"access_token\"/" ) ;
                
                ;
                }
                    &tValueDeviceId      ,
                    &tValueAccessToken ,
                {
                textC* pptValue[] =
                
                __Z( pSwPathValue ) ;
                etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                ZE( switchC* , pSwPathValue ) ;
                ZE( strokeS* , psttPath     ) ;
            {

            //etThread.trace F( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            //etThread.trace F( tin0P , T("json response:") ) ;
        
            }
                }
                    else if( costj ) break ;
                         if( cNest ) costj ++ ;
        
                    else if( postj[ costj ] == '}' ) cNest -- ;
                         if( postj[ costj ] == '{' ) cNest ++ ;
        
                    if( !cbIn ) break ;
                    countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                {
                for(;;)
                ZE( countT , cNest ) ;
            {
            ZE( countT , costj ) ;
            thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
            osTextT postj[ TUCK << 1 ] ;
        
            sockc.writeF( tin0P , (osTextT*)tSay ) ;
            //etThread.trace F( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            //etThread.trace F( tin0P , T("request:") ) ;
        {
        if( !POOP )
    
        TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/login HTTP/1.1\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;
    
        countT costBody = tBody.csF( tin0P ) ;
    
        //sockc.connectF( tin0P , 80 , nnServer ) ;
        //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
    
        sockc.connectF( tin0P , 443 , nnServer ) ;
        socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
    
        countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
        countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
        countT timeAllowedConnected = TICK >> 2 ;
    
        nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
        nicNameC nnServer ;
    
        ) ;
        
            "}\r\n"
            "    \"password\": \"")+tApiPassword+T("\"\r\n"
            "    },\r\n"
            "        \"user\": \"b.bot.1\"\r\n"
          //"        \"user\": \"administrator\"\r\n"
          //"        \"user\": \"a.1\"\r\n"
            "        \"type\": \"m.id.user\",\r\n"
            "    {\r\n"
            "    \"identifier\":\r\n"
            "    \"type\": \"m.login.password\",\r\n"
            "{\r\n"
        
        TN( tBody , "" ) ; tBody = T(
        
        }
            etThread.delF( tin0P , psttApiPassword ) ;
            tApiPassword = T(psttApiPassword) ;
            //etThread.trace F( tin0P , T("[password]:    ")+T(psttApiPassword) ) ;
            if( psttApiPassword && psttApiPassword->idAdam ) tApiPassword = T(psttApiPassword) ;

              ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.ideafarm.com.b.bot.1"      ) ) ; ___( psttApiPassword ) ;
            //ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.ideafarm.com.a.1"          ) ) ; ___( psttApiPassword ) ;
            //ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.ideafarm.com.administrator") ) ; ___( psttApiPassword ) ;
            //ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.communick.com.ideafarm"    ) ) ; ___( psttApiPassword ) ;
        {
        TN( tApiPassword , "" ) ;

        SCOOPS
    {
    IFsCRATCHoK                                                           // LOGIN
    TN( tbOpen            , " ("                   ) ;
    TN( tCloseColonCRLF   , "):\r\n"               ) ;
    TN( tbIndentDetail    , "          \\r"        ) ;
    TN( tbIndentTopic     , "         \\r"         ) ;
    TN( tColon            , ":"                    ) ;
    TN( tCommaBlank       , ", "                   ) ;
    TN( tb4               , "    "                 ) ;
    TN( tb                , " "                    ) ;
    TN( tValueDeviceId    , ""                     ) ;
    TN( tValueAccessToken , ""                     ) ;
    TN( tServer           , "ideafarm.com"         ) ;
  //TN( tServer           , "matrix.communick.com" ) ;
{
if( pTaskP )
TASK( tmWorkF )

// OBSOLETES: 5adam.5100087b.1

/*1*/WAKEhIDE( "ifcIDaDAM_ICISbOT" )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

