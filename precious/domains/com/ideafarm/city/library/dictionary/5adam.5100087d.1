
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

sgnDone_tmWorkF.waitF( tin0P ) ;                                                         //20241219@0949: STACK OVERFLOW WITH TICK << 0 AFTER BLAMMO ON SAME THREAD
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK << 1 ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

d ++ ;
m ++ ;
y ++ ;

//etThread.osTimeToOldTimeF( tin0P , ms , ss , mm , hh , d , m , y , dow , timeN1 , timeN2 , flOStIMEtOoLDtIME_OLDtIMEiSutc ) ;
  etThread.osTimeToOldTimeF( tin0P , ms , ss , mm , hh , d , m , y , dow , timeN1 , timeN2 , flOStIMEtOoLDtIME_null         ) ;
static ZE(  countT , dow ) ;
static ZE( sCountT , y   ) ;
static ZE(  countT , m   ) ;
static ZE(  countT , d   ) ;
static ZE(  countT , hh  ) ;
static ZE(  countT , mm  ) ;
static ZE(  countT , ss  ) ;
static ZE(  countT , ms  ) ;

//etThread.delF( tin0P , psttNow ) ;
//etThread.traceF( tin0P , T("the time now is (text   ):    ")+T(psttNow) ) ;
//etThread.strFromTimeF( tin0P , psttNow , timeN1 , timeN2 , 0 , 0 , S1C('.') , 0 , ifcIDfORMATtIME_TEXT    , flFORMAT_null ) ; ___( psttNow ) ;

etThread.delF( tin0P , psttNow ) ;
//etThread.traceF( tin0P , T("the time now is:    ")+T(psttNow) ) ;
etThread.strFromTimeF( tin0P , psttNow , timeN1 , timeN2 , 0 , 0 , S1C('.') , 0 , ifcIDfORMATtIME_NUMERIC , flFORMAT_null ) ; ___( psttNow ) ;
ZE( strokeS* , psttNow ) ;

etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
ZE( sCountT , timeN2 ) ;
ZE(  countT , timeN1 ) ;

etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIEST ) ;     //20241220@2048: THIS ADAM CONSUMES PRACTICALLY ALL OF THE TOTAL CPU USED BY BUNDLE, AND ITS FUNCTION IS NATURALLY LOW PRIORITY AND SUITABLE FOR AS AVAILABLE IDLE PROCESSING
thirdC::dosPriorityProcessIF(      tin0P , ifcTHREADpRIORITY_LAZIEST ) ;     //20241220@2048: THIS ADAM CONSUMES PRACTICALLY ALL OF THE TOTAL CPU USED BY BUNDLE, AND ITS FUNCTION IS NATURALLY LOW PRIORITY AND SUITABLE FOR AS AVAILABLE IDLE PROCESSING

TODO

DONE( tmWorkF )
}
    //etherC::loafIF( tin0P ) ;
    //etThread.traceF( tin0P , T("ok") ) ;

    }
        }
            }
                }
                    }
                        }
                            DEL( pSwPathValue ) ;
                            }
                                }
                                    etThread.delF( tin0P , psttValue ) ;

                                    //etThread.traceF( tin0P , T("********    ") + T(psttPath) + T("   :    ") + T(psttValue) ) ;

                                    strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                    psttPath            = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                    _IO_
                                {
                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                            {
                            else        
                            }
                                etThread.traceF( tin0P , T("!exception / could not parse json response") ) ;
                                POOPR
                            {
                            if( POOP )        

                            __Z( pSwPathValue ) ;
                            ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                            ZE( switchC* , pSwPathValue ) ;
                            ZE( strokeS* , psttPath     ) ;

                            //etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                            //etThread.traceF( tin0P , T("json response:") ) ;
                        {
                        else        
                        }
                            etThread.traceF( tin0P , T("!exception / could not read response") ) ;
                            POOPR
                        {
                        if( POOP )        
                    
                        }
                            }
                                else if( costj ) break ;
                                     if( cNest ) costj ++ ;
                    
                                else if( postj[ costj ] == '}' ) cNest -- ;
                                     if( postj[ costj ] == '{' ) cNest ++ ;
                    
                                if( !cbIn ) break ;
                                countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                            {
                            for(;;)
                            ZE( countT , cNest ) ;
                        {
                        ZE( countT , costj ) ;
                        thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                        osTextT postj[ TUCK << 1 ] ;
                    {
                    else        
                    }
                        etThread.traceF( tin0P , T("!exception / could not write request") ) ;
                        POOPR
                    {
                    if( POOP )        

                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                    //etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                    //etThread.traceF( tin0P , T("request:") ) ;
                
                    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/logout/all HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tIdeafarmDotCom+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(0,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;
                {
                else        
                }
                    etThread.traceF( tin0P , T("!exception / could not connect 3") ) ;
                    POOPR
                {
                if( POOP )        

                sockc.connectF( tin0P , 443 , nnServer ) ;
                socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
            {
            else        
            }
                etThread.traceF( tin0P , T("!exception / could not obtain nnServer 3") ) ;
                POOPR
            {
            if( POOP )        
        
            nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tIpv4IdeafarmCom ) ;
        
            SCOOPS
        {
        IFsCRATCHoK

        countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
        countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
        countT timeAllowedConnected = TICK >> 2 ;
        nicNameC nnServer ;
    {                                                                         // LOGOUT

    }
//      ++ s ; ether.osSleepF( tin0P , TICK << 1 ) ;
        //etThread.traceF( tin0P , T("napping") ) ;

        }
            }
                }            
                    }            
                        etThread.delF( tin0P , postj ) ;
                        }            
                            }            
                                DEL( pSwPathValue ) ;
                                }            
                                    }
                                        etThread.delF( tin0P , psttd ) ;
                                        strokeS*& psttd = (strokeS*&)(countT&)swMessage ;
                                        psttzlPrefix = (strokeS*)swMessage.leverF( tin0P , idfm ) ;
                                    {
                                    for( countT idfm = 1 ; idfm <= cFlavorsMessage ; idfm ++ )
                                    countT cFlavorsMessage = swMessage.cFlavorsF( tin0P ) ;

                                    }
                                        etThread.delF( tin0P , psttd ) ;
                                        strokeS*& psttd = (strokeS*&)(countT&)swSender ;
                                        psttzlPrefix = (strokeS*)swSender.leverF( tin0P , idfm ) ;
                                    {
                                    for( countT idfm = 1 ; idfm <= cFlavorsSender ; idfm ++ )
                                    countT cFlavorsSender = swSender.cFlavorsF( tin0P ) ;
                                    IFsCRATCHoK{} //U:: TO TRAP A BUG

                                    }
                                        etThread.delF( tin0P , psttValue ) ;
                                        }
                                            }
                                                }
                                                    etThread.boxPutF( tin0P , tSoilFilePathFrom+tShort , tEvals , tEvals.csF( tin0P ) ) ;

                                                    etThread.delF( tin0P , psttu ) ;
                                                    TN( tShort , "" ) ; tShort  =  tSoilFileShortPrefix+T(psttu)+T(".soil") ;

                                                    etThread.strUniqueF( tin0P , psttu ) ; ___( psttu ) ;
                                                    ZE( strokeS* , psttu ) ;

                                                    etThread.delF( tin0P , psttSoil ) ;
                                                    TN( tEvals , psttSoil ) ;

                                                    etThread.strFuseF( tin0P , psttSoil , T(postFoot) ) ;
                                                    }
                                                        while( ~hWalk ) ;
                                                        }
                                                            etThread.strFuseF( tin0P , psttSoil , tbIndentDetail+T(psttm)+T("\r\n") ) ;
                                                            strokeS* psttm = (strokeS*)stMessages.downF( tin0P , hWalk ) ;
                                                        {
                                                        do
                                                        handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                    {
                                                    if( stMessages )

                                                    etThread.strMakeF( tin0P , LF , psttSoil , T(postHead) , cstta + TUCK ) ; ___( psttSoil ) ;
                                                    ZE( strokeS* , psttSoil ) ;

                                                    }
                                                        while( ~hWalk ) ;
                                                        }
                                                            if( !POOP ) cstta += psttm->idAdam + 4 + tbIndentTopic.csF( tin0P ) ;        // CRLF CRLF
                                                            __Z( psttm ) ;
                                                            strokeS* psttm = (strokeS*)stMessages.downF( tin0P , hWalk ) ;
                                                        {
                                                        do
                                                        handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                    {
                                                    if( stMessages )
                                                    countT cstta = thirdC::c_strlenIF( tin0P , postHead ) + thirdC::c_strlenIF( tin0P , postFoot ) ;

                                                    /**/etThread.traceF( tin0P , T("pushed a message") ) ;
                                                    stMessages << pstte ; pstte = 0 ;
                                                    etThread.strMakeF( tin0P , LF , pstte , tEntry ) ; ___( pstte ) ;
                                                    ZE( strokeS* , pstte ) ;

                                                    //etThread.traceF( tin0P , T("[post]:    ")+tEntry ) ;
                                                    TN( tEntry , "" ) ; tEntry = tMessage+T("\r\n")+tbIndentTopic+tTime+tbOpen+tSender+tCloseColonCRLF ;

                                                    tTime = tDayOfWeek+tCommaBlank+tMonth+tb+TF4(++mDay,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+tCommaBlank+TF4(++year,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T(" at ")+TF4(hour,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa)+tColon+TF4(minute,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE|flFORMAT_FILLzE,2,0xa) ;

                                                    }
                                                        case 0xb : { tMonth = T("December"  ) ; break ; }
                                                        case 0xa : { tMonth = T("November"  ) ; break ; }
                                                        case 0x9 : { tMonth = T("October"   ) ; break ; }
                                                        case 0x8 : { tMonth = T("September" ) ; break ; }
                                                        case 0x7 : { tMonth = T("August"    ) ; break ; }
                                                        case 0x6 : { tMonth = T("July"      ) ; break ; }
                                                        case 0x5 : { tMonth = T("June"      ) ; break ; }
                                                        case 0x4 : { tMonth = T("May"       ) ; break ; }
                                                        case 0x3 : { tMonth = T("April"     ) ; break ; }
                                                        case 0x2 : { tMonth = T("March"     ) ; break ; }
                                                        case 0x1 : { tMonth = T("February"  ) ; break ; }
                                                        case 0x0 : { tMonth = T("January"   ) ; break ; }
                                                    {
                                                    switch( month )
                                                    TN( tMonth , "" ) ;

                                                    }
                                                        case 6 : { tDayOfWeek = T("Saturday" ) ; break ; }
                                                        case 5 : { tDayOfWeek = T("Friday"   ) ; break ; }
                                                        case 4 : { tDayOfWeek = T("Thursday" ) ; break ; }
                                                        case 3 : { tDayOfWeek = T("Wednesday") ; break ; }
                                                        case 2 : { tDayOfWeek = T("Tuesday"  ) ; break ; }
                                                        case 1 : { tDayOfWeek = T("Monday"   ) ; break ; }
                                                        case 0 : { tDayOfWeek = T("Sunday"   ) ; break ; }
                                                    {
                                                    switch( wDay )
                                                    TN( tDayOfWeek , "" ) ;                                     //U:: USE etherC API FOR THIS

                                                    thirdC::osOldTimeFromUnixTimeIF( tin0P , isDaylightSavingsTime , yDay , wDay , year , month , mDay , hour , minute , second , secondsIntoEpoch ) ;
                                                    ZE( boolT  , isDaylightSavingsTime ) ;
                                                    ZE( countT , yDay                  ) ;
                                                    ZE( countT , wDay                  ) ;
                                                    ZE( countT , year                  ) ;
                                                    ZE( countT , month                 ) ;
                                                    ZE( countT , mDay                  ) ;
                                                    ZE( countT , hour                  ) ;
                                                    ZE( countT , minute                ) ;
                                                    ZE( countT , second                ) ;
                                                {
                                                if( secondsIntoEpoch != - 1 && tSender.csF( tin0P ) )
                                                TN( tTime , "" ) ;
                                                
                                                }
                                                    if( !etThread.strCompareF( tin0P , psttzlPrefix , (strokeS*)swTime.leverF( tin0P , idft ) ) ) secondsIntoEpoch = swTime ;
                                                {
                                                for( countT idft = 1 ; idft <= cFlavorsTime ; idft ++ )
                                                countT cFlavorsTime = swTime.cFlavorsF( tin0P ) ;
                                                countT secondsIntoEpoch = - 1 ;

                                                TN( tMessage , (strokeS*&)(countT&)swMessage ) ;
                                                TN( tSender  , (strokeS*&)(countT&)swSender  ) ;
                                            {
                                            if( !etThread.strCompareF( tin0P , psttzlPrefix , tPrefix ) )

                                            psttzlPrefix = (strokeS*)swMessage.leverF( tin0P , idfm ) ;
                                        {
                                        for( countT idfm = 1 ; idfm <= cFlavorsMessage ; idfm ++ )
                                        countT cFlavorsMessage = swMessage.cFlavorsF( tin0P ) ;

                                        }
                                            }
                                                }
                                                    }
                                                        break ;

                                                        etThread.strMakeF( tin0P , LF , psttMessage , (strokeS*)*pptValue[ offe ] ) ; ___( psttMessage ) ;
                                                        etThread.delF( tin0P , psttMessage ) ;
                                                        strokeS*& psttMessage = (strokeS*&)(countT&)swMessage ;
                                                    {
                                                    case 5 :
                                                    }
                                                        break ;

                                                        etThread.strMakeF( tin0P , LF , psttSender , (strokeS*)*pptValue[ offe ] ) ; ___( psttSender ) ;
                                                        etThread.delF( tin0P , psttSender ) ;
                                                        strokeS*& psttSender = (strokeS*&)(countT&)swSender ;
                                                    {
                                                    case 4 :
                                                    }
                                                        break ;
                                                        }
                                                            etThread.delF( tin0P , psttSeconds ) ;
                                                            swTime = (countT)etThread.strDigitsToSCountF( tin0P , psttSeconds , 0xa , 1 ) ;
                                                            etThread.strSubstringF( tin0P , psttSeconds , idf , idl , tMs ) ; ___( psttSeconds ) ;
                                                            countT idl = csttMs - 3 ;
                                                            countT idf = 1 ;
                                                            ZE( strokeS* , psttSeconds ) ;
                                                        {
                                                        if( csttMs > 3 )
                                                        countT csttMs = tMs.csF( tin0P ) ;
                                                        TN( tMs , "" ) ; tMs = *pptValue[ offe ] ;
                                                    {
                                                    case 3 :
                                                {
                                                switch( offe )
                                                psttzlPrefix = tPrefix ;

                                                /**/etThread.traceF( tin0P , T("[prefix]:    ")+tPrefix ) ;

                                                }
                                                    etThread.delF( tin0P , psttSuffix ) ;
                                                    etThread.delF( tin0P , psttPrefix ) ;
                                                    tSuffix = T(psttSuffix) ;
                                                    tPrefix  = T(psttPrefix) ;
                                                    etThread.strBisectF( tin0P , psttPrefix , psttSuffix , psttPath , T("/") , 6 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPrefix ) ; ___( psttSuffix ) ;
                                                    ZE( strokeS* , psttSuffix ) ;
                                                    ZE( strokeS* , psttPrefix ) ;
                                                {
                                                TN( tSuffix , "" ) ;

                                                // "rooms"/"join"/"" postIDrOOMuSE ""/"timeline"/"events"/item.0000000a/"content"/"body"/

                                                //etThread.traceF( tin0P , T("********    ") + T(psttPath) + T("   :    ") +T(psttValue) ) ;
                                                *pptValue[ offe ] = T(psttValue) ;
                                            {
                                            )
                                                )
                                                    etThread.strIdF(  tin0P , *pptPathZ[ offe ] , psttPath ) + pptPathZ[ offe ]->csF( tin0P ) - 1 == psttPath->idAdam
                                                    &&
                                                    etThread.strIdF(  tin0P , *pptPathA[ offe ] , psttPath ) == 1
                                                (
                                                ||
                                                )
                                                    !etThread.strCompareF( tin0P , *pptPathA[ offe ] , psttPath )
                                                    &&
                                                    !pptPathZ[ offe ]->csF( tin0P )
                                                (
                                            (
                                            if
                                        {
                                        for( countT offe = 0 ; offe < cValues ; offe ++ )
                                        TN( tPrefix  , "" ) ;
                                
                                        if( cPathsZ - cValues ) { BLAMMO ; }
                                        if( cPathsA - cValues ) { BLAMMO ; }
                                        countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                        countT cPathsZ  = sizeof pptPathZ  / sizeof pptPathZ[  0 ] ;
                                        countT cPathsA  = sizeof pptPathA  / sizeof pptPathA[  0 ] ;
                                
                                        //etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                                        //etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;
                                
                                        strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                        psttPath            = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                                        IFsCRATCHoK{} //U:: TO TRAP A BUG
                                
                                        _IO_
                                    {
                                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                    countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;

                                    switchC swMessage( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzlPrefix ) ;
                                    switchC swSender(  tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzlPrefix ) ;
                                    switchC swTime(    tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzlPrefix ) ;
                                    ZE( strokeS* , psttzlPrefix ) ;
                                    
                                    ;
                                    }
                                        &tPathZRoomTopic  ,
                                        &tPathZMessage    ,
                                        &tPathZSender     ,
                                        &tPathZTime       ,
                                        &tPathZEnd        ,
                                        &tPathZStart      ,
                                        &tPathZNextBatch  ,
                                    {
                                    textC* pptPathZ[] =

                                    ;
                                    }
                                        &tPathARoomTopic  ,
                                        &tPathAMessage    ,
                                        &tPathASender     ,
                                        &tPathATime       ,
                                        &tPathAEnd        ,
                                        &tPathAStart      ,
                                        &tPathANextBatch  ,
                                    {
                                    textC* pptPathA[] =

                                    TN( tPathZRoomTopic , ""                                                                                                                     ) ;                
                                    TN( tPathZMessage   , "/\"content\"/\"body\"/"                                                                                               ) ;
                                    TN( tPathZSender    , "/\"sender\"/"                                                                                                         ) ;
                                    TN( tPathZTime      , "/\"origin_server_ts\"/"                                                                                               ) ;
                                    TN( tPathZEnd       , ""                                                                                                                     ) ;
                                    TN( tPathZStart     , ""                                                                                                                     ) ;
                                    TN( tPathZNextBatch , ""                                                                                                                     ) ;

                                    TN( tPathARoomTopic , "\"rooms\"/\"join\"/\"" postIDrOOMuSE "\"/\"timeline\"/\"events\"/item.00000002/\"content\"/\"topic\"/" ) ;                
                                    TN( tPathAMessage   , "\"rooms\"/\"join\"/\"" postIDrOOMuSE "\"/\"timeline\"/\"events\"/item."                                ) ;
                                    TN( tPathASender    , "\"rooms\"/\"join\"/\"" postIDrOOMuSE "\"/\"timeline\"/\"events\"/item."                                ) ;
                                    TN( tPathATime      , "\"rooms\"/\"join\"/\"" postIDrOOMuSE "\"/\"timeline\"/\"events\"/item."                                ) ;
                                    TN( tPathAEnd       , "\"end\"/"                                                                                                             ) ;
                                    TN( tPathAStart     , "\"start\"/"                                                                                                           ) ;
                                    TN( tPathANextBatch , "\"next_batch\"/"                                                                                                      ) ;
                                    
                                    ;
                                    }
                                        &tValueRoomTopic ,
                                        &tValueMessage   ,
                                        &tValueSender    ,
                                        &tValueTime      ,
                                        &tValueEnd       ,
                                        &tValueStart     ,
                                        &tValueNextBatch ,
                                    {
                                    textC* pptValue[] =
                                {
                                else        
                                }
                                    etThread.traceF( tin0P , T("!exception / could not parse json response") ) ;
                                    POOPR
                                {
                                if( POOP )        
            
                                __Z( pSwPathValue ) ;
                                ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                ZE( switchC* , pSwPathValue ) ;
                                ZE( strokeS* , psttPath     ) ;
                                IFsCRATCHoK{} //U:: TO TRAP A BUG

                                }
                                    etThread.delF( tin0P , psttg ) ;
                                    //etThread.traceF( tin0P , T("[json file]:    ")+T(psttg) ) ;
                                    etThread.boxPutGenerationF( tin0P , psttg , T("///ideafarm/tmp/")+TfORsTRING(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T("/json/json.sync") , TOCK , postj , costj , 0 , flOPENdETAILS_null , /*T(".json")*/0 ) ; ___( psttg ) ;
                                    ZE( strokeS* , psttg ) ;
                                {
                                if( postj && costj )

                                //etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                //etThread.traceF( tin0P , T("json response [costj]:    ")+TF2(costj,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE) ) ;
                            {
                            else        
                            }
                                etThread.traceF( tin0P , T("!exception / could not read response") ) ;
                                POOPR
                            {
                            if( POOP )        
            
                            }
                                }
                                    if( cNest ) costj ++ ;
                        
                                    }
                                        }
                                            break ;
                                            costj ++ ;
                                        {
                                        if( 1 == cNest -- )
                                    {
                                    else if( postj[ costj ] == '}' )
                                         if( postj[ costj ] == '{' ) cNest ++ ;
                        
                                    if( !cbIn ) break ;
                                    countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                {
                                for(;;)
                                ZE( countT , cNest ) ;
                            {
                            ZE( countT , costj ) ;
                        {
                        else        
                        }
                            etThread.traceF( tin0P , T("!exception / could not write request 2") ) ;
                            POOPR
                        {
                        if( POOP )        
            
                        sockc.writeF( tin0P , (osTextT*)tSay ) ;
                        IFsCRATCHoK{} //U:: TO TRAP A BUG
                        //etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                        //etThread.traceF( tin0P , T("request:") ) ;

                        thirdC::c_memsetIF( tin0P , postj , costaj ) ;
                        etThread.newF( tin0P , LF , postj , costaj ) ; ___( postj ) ;
                        countT costaj = TICK ;
                        ZE( osTextT* , postj ) ;
                    
                        /**/etThread.traceF( tin0P , T("requesting sync (update) [tSay]:    ")+tSay ) ;

                        TN( tSay , "" ) ; tSay = T("GET /_matrix/client/v3/sync")+tQuery+T(" HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tIdeafarmDotCom/*+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(tBody.csF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)*/+T("\r\n\r\n")/*+tBody*/ ;

                        ) ;

                            ""
                            "&since=")+tValueNextBatch+T(

                        if( tValueNextBatch.csF( tin0P ) ) tQuery += T(
                        TN( tQuery , "?timeout=4000" ) ;
                    {
                    else        
                    }
                        etThread.traceF( tin0P , T("!exception / could not connect 2") ) ;
                        POOPR
                    {
                    if( POOP )        
            
                    sockc.connectF( tin0P , 443 , nnServer ) ;
                    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                {
                else        
                }
                    etThread.traceF( tin0P , T("!exception / could not obtain nnServer 2") ) ;
                    POOPR
                {
                if( POOP )        
            
                nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tIpv4IdeafarmCom ) ;
            
                SCOOPS
            {
            IFsCRATCHoK

            countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
            countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
            countT timeAllowedConnected = TICK >> 2 ;
            nicNameC nnServer ;
        {

#endif
        }
            }
                }
                    }
                        }
                            etThread.traceF( tin0P , T("!exception / could not move the classroom soil file to publish it to [tShort]:    ")+tShort ) ;
                          //etThread.traceF( tin0P , T("!exception / could not move the student evaluations soil file to publish it to [tShort]:    ")+tShort ) ;
                            POOPR
                        {
                        if( POOP )        

                        ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tTo , tFrom , 1 ) ;
                        SCOOPS
                    {
                    IFsCRATCHoK

                    TN( tFrom , "" ) ; tFrom = tSoilFilePathFrom + tShort ;
                    TN( tTo   , "" ) ; tTo   = tSoilFilePathTo   + tShort ;

                    etThread.delF( tin0P , psttShort ) ;
                    etThread.delF( tin0P , psttPath ) ;
                    TN( tShort , psttShort ) ;
                    etThread.strBisectF( tin0P , psttPath , psttShort , tYoungest , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                    ZE( strokeS* , psttShort ) ;
                    ZE( strokeS* , psttPath ) ;                                                                                     // PUBLISH THE YOUNGEST FILE BY MOVING IT INTO PISS'S MOUTH
                {
                else
                if( cLogsJammed ) etThread.traceF( tin0P , T("not publishing because PISS isn't ready [cLogsJammed]:    ")+TF2(cLogsJammed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                }
                    }
                        ++ cLogsJammed ;
                    {
                    FORsTRINGSiN2( pstt1f )
                    etThread.diskFindFileOrDirF( tin0P , pstt1f , tSoilFilePathCheck ) ; ___( pstt1f ) ;

                    etThread.delF( tin0P , pstt1f ) ;
                    }
                        ++ cLogsJammed ;
                    {
                    FORsTRINGSiN1( pstt1f )
                    etThread.diskFindFileOrDirF( tin0P , pstt1f , tSoilFilePathTo ) ; ___( pstt1f ) ;
                    ZE( strokeS* , pstt1f ) ;
                {                                                                                                                   // VERIFY THAT PISS IS READY TO RECEIVE A NEW SOIL FILE
                ZE( countT , cLogsJammed ) ;

                etThread.delF( tin0P , pstt1f ) ;
                }
                    if( etThread.strCompareF( tin0P , psttc1 , tYoungest ) ) etThread.diskFileOrDirDeleteF( tin0P , psttc1 ) ;
                {
                FORsTRINGSiN1( pstt1f )
                etThread.diskFindFileOrDirF( tin0P , pstt1f , tSoilFilePathFrom ) ; ___( pstt1f ) ;
                ZE( strokeS* , pstt1f ) ;
            {                                                                                                                       // ZAP OLDER FILES THAT SURVIVED DUE TO BEING PRESENTED OUT OF ORDER
            if( tYoungest.csF( tin0P ) )

            }
                etThread.delF( tin0P , pstt1f ) ;
                }
                    }
                        tYoungest = T(psttc1) ;
                        if( tYoungest.csF( tin0P ) ) etThread.diskFileOrDirDeleteF( tin0P , tYoungest ) ;
                    {
                    if( !tYoungest.csF( tin0P ) || 0 < etThread.strCompareF( tin0P , psttc1 , tYoungest ) )
                {
                FORsTRINGSiN1( pstt1f )
                etThread.diskFindFileOrDirF( tin0P , pstt1f , tSoilFilePathFrom ) ; ___( pstt1f ) ;
                ZE( strokeS* , pstt1f ) ;
            {                                                                                                                       // ZAP EACH FILE THAT IS OLDER THAN A FILE ALREADY SEEN ; THIS ONLY ZAPS ALL OF THE OLDER FILES IF THE BASE O.S. PRESENTS THE NAMES IN SORTED ORDER, WHICH IT DOES NOT GUARANTEE TO DO (NTFS)
            TN( tYoungest , "" ) ; // DELETE ALL BUT THE YOUNGEST bot.kt.classroom.*
          //TN( tYoungest , "" ) ; // DELETE ALL BUT THE YOUNGEST bot.kt.student.evaluations.*

            timeU2 = timeN2 ;
            timeU1 = timeN1 ;
            //etThread.traceF( tin0P , T("publish the youngest evaluation soil file [timeE]:    ")+TT(timeE1,timeE2) ) ;
        {
        if( timeE2 || timeE1 > ( TICK << 2 ) )                                                                                      // LIMIT PUBLICATION SO THAT PISS (AND THE CPU) IS IDLE AND AVAILABLE FOR OTHER WORK
#if defined( NEVERdEFINED )

        etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeU1 , timeU2 ) ;
        sCountT timeE2 = timeN2 ;
        countT  timeE1 = timeN1 ;

        //etThread.traceF( tin0P , T("awakening [timeN]:    ")+TT(timeN1,timeN2) ) ;
        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;
    {
    while( !ether && !POOP )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    TN( tSoilFilePathCheck   , "" ) ; tSoilFilePathCheck = T("///ideafarm/IdeaFarm (tm)/")+tUser+T("/1.2. SOIL (tm) Text Files Being Eaten/" ) ;
    TN( tSoilFilePathTo      , "" ) ; tSoilFilePathTo    = T("///ideafarm/IdeaFarm (tm)/")+tUser+T("/1.1. Drop a Copy of SOIL (tm) Text Files Here/" ) ;
    TN( tSoilFilePathFrom    , "" ) ; tSoilFilePathFrom  = T("///ideafarm/tmp/")+TfORsTRING(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T("/soil/") ;
    TN( tSoilFileShortPrefix , "bot.kt.classroom." ) ;
  //TN( tSoilFileShortPrefix , "bot.kt.student.evaluations." ) ;
    ZE( sCountT , timeU2 ) ;
    ZE( countT  , timeU1 ) ;        //TIME THAT LATH PUBLICATION OCCURRED
    TN( tValueRoomTopic , "" ) ;
    TN( tValueMessage   , "" ) ;
    TN( tValueSender    , "" ) ;
    TN( tValueTime      , "" ) ;
    TN( tValueNextBatch , "" ) ;
    TN( tValueEnd       , "" ) ;
    TN( tValueStart     , "" ) ;
    TN( tUser , thirdC::postUserNameIF() ) ;

    ;

        "}\r\n"
        "    }\r\n"
        "\r\n"
        "        \\rClassroom, ICIS IdeaFarm (tm) College of Imagination Science\r\n"
      //"        \\rStudent Evaluations of ICIS IdeaFarm (tm) College of Imagination Science\r\n"

    const osTextT* const postFoot =

    ;

        "\r\n"
        "    {body:\r\n"
        "\r\n"
        "    {namespace: web.root }\r\n"
        "\r\n"
        "    {folder: ///d/web.classroom/ }\r\n"
      //"    {folder: ///d/web.evaluations/ }\r\n"
        "\r\n"
        "    {flags: noZip beep}\r\n"
        "\r\n"
        "    {mode: about }\r\n"
        "\r\n"
        "    {file: index }\r\n"
        "\r\n"
        "    {domain: ideafarm.com }\r\n"
        "\r\n"
        "{ktr:\r\n"

    const osTextT* const postHead =

    stackC stMessages( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
   
    }
        }
            }
                etThread.traceF( tin0P , T("!exception / socket is impotent") ) ;
                POOPRqUIET
            {
            if( POOP )
        
            //etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
        
            }
                }
                    }
                        }
                            DEL( pSwPathValue ) ;
                            }                            
                                }
                                    etThread.delF( tin0P , psttValue ) ;
                            
                                    }
                                        }
                                            //etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + T(psttValue) ) ;
                                            *pptValue[ offe ] = T(psttValue) ;
                                        {
                                        if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                    {
                                    for( countT offe = 0 ; offe < cPaths ; offe ++ )
                            
                                    if( cPaths - cValues ) { BLAMMO ; }
                                    countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                    countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
                            
                                    //etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                                    //etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;
                            
                                    strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                    psttPath            = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                            
                                    _IO_
                                {
                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                            
                                ;
                                }
                                    &tPathDeviceId     ,
                                    &tPathAccessToken  ,
                                {
                                textC* pptPath[] =
                                
                                TN( tPathDeviceId    , "\"device_id\"/"    ) ;
                                TN( tPathAccessToken , "\"access_token\"/" ) ;
                                
                                ;
                                }
                                    &tValueDeviceId      ,
                                    &tValueAccessToken ,
                                {
                                textC* pptValue[] =
                            {
                            else
                            }
                                etThread.traceF( tin0P , T("!exception / could not parse json response") ) ;
                                POOPR
                            {
                            if( POOP )        

                            __Z( pSwPathValue ) ;
                            ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                            ZE( switchC* , pSwPathValue ) ;
                            ZE( strokeS* , psttPath     ) ;

                            //etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                            //etThread.traceF( tin0P , T("json response:") ) ;
                        {
                        else
                        }
                            etThread.traceF( tin0P , T("!exception / could not read response") ) ;
                            POOPR
                        {
                        if( POOP )        

                        }
                            }
                                else if( costj ) break ;
                                     if( cNest ) costj ++ ;
                    
                                else if( postj[ costj ] == '}' ) cNest -- ;
                                     if( postj[ costj ] == '{' ) cNest ++ ;
                    
                                if( !cbIn ) break ;
                                countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                            {
                            for(;;)
                            ZE( countT , cNest ) ;
                        {
                        ZE( countT , costj ) ;
                        thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                        osTextT postj[ TUCK << 1 ] ;
                    {
                    else
                    }
                        etThread.traceF( tin0P , T("!exception / could not write request") ) ;
                        POOPR
                    {
                    if( POOP )        

                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                    //etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                    //etThread.traceF( tin0P , T("request:") ) ;
                {
                else
                }
                    etThread.traceF( tin0P , T("!exception / could not connect") ) ;
                    POOPR
                {
                if( POOP )        
        
                sockc.connectF( tin0P , 443 , nnServer ) ;
                socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
            {
            else        
            }
                etThread.traceF( tin0P , T("!exception / could not obtain nnServer") ) ;
                POOPR
            {
            if( POOP )        
        
            nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tIpv4IdeafarmCom ) ;

            SCOOPS
        {
        IFsCRATCHoK

        TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/login HTTP/1.1\r\nHost: ")+tIdeafarmDotCom+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;
        countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
        countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
        countT timeAllowedConnected = TICK >> 2 ;
        nicNameC nnServer ;
        countT costBody = tBody.csF( tin0P ) ;
    
        ) ;
        
            "}\r\n"
            "    \"password\": \"")+tApiPassword+T("\"\r\n"
            "    },\r\n"
          //"        \"user\": \"b.bot.1\"\r\n"
          //"        \"user\": \"administrator\"\r\n"
            "        \"user\": \"a.1\"\r\n"
            "        \"type\": \"m.id.user\",\r\n"
            "    {\r\n"
            "    \"identifier\":\r\n"
            "    \"type\": \"m.login.password\",\r\n"
            "{\r\n"
        
        TN( tBody , "" ) ; tBody = T(
        
        }
            etThread.delF( tin0P , psttApiPassword ) ;
            tApiPassword = T(psttApiPassword) ;
            //etThread.traceF( tin0P , T("[password]:    ")+T(psttApiPassword) ) ;
            if( psttApiPassword && psttApiPassword->idAdam ) tApiPassword = T(psttApiPassword) ;

            //ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.ideafarm.com.b.bot.1"      ) ) ; ___( psttApiPassword ) ;
              ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.ideafarm.com.a.1"          ) ) ; ___( psttApiPassword ) ;
            //ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.ideafarm.com.administrator") ) ; ___( psttApiPassword ) ;
            //ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.communick.com.ideafarm"    ) ) ; ___( psttApiPassword ) ;
        {
        TN( tApiPassword , "" ) ;
    {                                                                                                                      // LOGIN
    TN( tValueDeviceId    , ""                     ) ;
    TN( tValueAccessToken , ""                     ) ;

    }
        etThread.delF( tin0P , pstts ) ;
        tIpv4IdeafarmCom = T(pstts) ;
        //etRock.traceF( tin0P , T("[password]:    ")+T(pstts) ) ;
        if( pstts && pstts->idAdam ) tIpv4IdeafarmCom = T(pstts) ;

          ZE( strokeS* , pstts ) ; etThread.querySettingF( tin0P , pstts , T("!ipdos.ipv4.ideafarm.com"          ) ) ; ___( pstts ) ;
    {
    TN( tIpv4IdeafarmCom , "" ) ; // IPV4 OF "ideafarm.com", WHICH IS THE [MATRIX] HOMESERVER FOR IDEAFARM.COM (HOSTED AT HETZNER)
    TN( tIdeafarmDotCom , "ideafarm.com" ) ;

    TN( tbOpen            , " ("                   ) ;
    TN( tCloseColonCRLF   , "):\r\n"               ) ;
    TN( tbIndentDetail    , "          \\r"        ) ;
    TN( tbIndentTopic     , "         \\r"         ) ;
    TN( tColon            , ":"                    ) ;
    TN( tCommaBlank       , ", "                   ) ;
    TN( tb4               , "    "                 ) ;
    TN( tb                , " "                    ) ;

    ether.osSleepF( tin0P , TIMEnAPdURINGsERVICEsTARTUP ) ;
{
if( pTaskP )
TASK( tmWorkF )

#define postIDrOOMuSE postIDrOOMcLASSROOM

#define postIDrOOMcLASSROOM   "!xZFAfdZNvjiogHSLff:ideafarm.com"
#define postIDrOOMeVALUATIONS "!mdggPdOnBbNwmpeHnH:ideafarm.com"

// OBSOLETES: 5adam.5100087b.1

/*1*/WAKEhIDE( "ifcIDaDAM_ICISbOT" )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

