
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("ok") ) ;

etThread.traceF( tinBaseP , T("sorted  (final sort after multithreaded presort)") ) ;
sorta2.sortF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("sorting (final sort after multithreaded presort)") ) ;
sortaC sorta2( tinBaseP , etThread , bQuit , pbArray2 , cbArray2 , sizeof( countT ) , 0 , sizeof( countT ) , 1 , 0 , flSORTAc_null ) ;

}
    thirdC::dosSleepRWinkIF( tinBaseP ) ;
{
while( cPending )
sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

}
    etThread.osThreadF( TaRG1( tmWorkerF ) , (countT)&cPending , modulo , remainder ++ ) ;
    inc02AM( cPending ) ;
{
while( cDo -- )
ZE( countT , cPending ) ;
ZE( countT , remainder ) ;
countT cDo = modulo ;
countT modulo = cProcessors ;
const countT cProcessors = thirdC::osProcessorsIF( tinBaseP ) ;

}
    etThread.traceF( tinBaseP , T("sorted  (simple sort: modulo 1)") ) ;
    sorta1.sortF( tinBaseP ) ;
    etThread.traceF( tinBaseP , T("sorting (simple sort: modulo 1)") ) ;
    sortaC sorta1( tinBaseP , etThread , bQuit , pbArray1 , cbArray1 , sizeof( countT ) , 0 , sizeof( countT ) , 1 , 0 , flSORTAc_null ) ;
{
ZE( boolT , bQuit ) ;

etThread.traceF( tinBaseP , T("wrote   a tick of elements, each with wo ranUniC value") ) ;
}
    }
        case 1 : { pcArray2[ offca ] = pcArray1[ offca ] = 0x11111111  ; break ; }
        case 0 : { pcArray2[ offca ] = pcArray1[ offca ] = ruChallenge ; break ; }
    {
    switch( offca % 2 )
{
for( countT offca = 0 ; offca < ccArray1 ; offca ++ )
etThread.traceF( tinBaseP , T("writing a tick of elements, each with wo ranUniC value") ) ;

ranUniC ruChallenge( tinBaseP , (measure04T)MAXcOUNTT + 1 , cSeed ) ;
//etThread.traceF( tinBaseP , T("[cSeed]:    ")+TF2(cSeed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_NOpREFIX ) ;
cSeedLath = cSeed ;
countT cSeed = 0x78E86FC1 /*slab.trueRandom*/ ;

countT  cCounts2 = ccArray2 ;
countT  ccArray2 = sizeof pbArray2 / sizeof( countT ) ;
countT* pcArray2 = (countT*)pbArray2 ;

countT  cCounts1 = ccArray1 ;
countT  ccArray1 = sizeof pbArray1 / sizeof( countT ) ;
countT* pcArray1 = (countT*)pbArray1 ;

slabS& slab = slabS::slabIF() ;

TODO

DONE( tmWorkerF )
}
    dec02AM( cPendingP ) ;

    }
        etThread.traceF( tinBaseP , T("sorted  [remainderP]:    ")+TF2(remainderP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        sorta.sortF( tinBaseP ) ;
        etThread.traceF( tinBaseP , T("sorting [remainderP]:    ")+TF2(remainderP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        sortaC sorta( tinBaseP , etThread , bQuit , pbArray2 , cbArray2 , sizeof( countT ) , 0 , sizeof( countT ) , moduloP , remainderP , flSORTAc_null ) ;
    {
    ZE( boolT , bQuit ) ;

    countT  remainderP =           pTaskP->c3 ;
    countT  moduloP    =           pTaskP->c2 ;
    countT& cPendingP  = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )

boolT bChatter = 0 ;

countT cSeedLath ; // TO FIND A BUG

countT cbArray2 = sizeof pbArray2 ;
byteT  pbArray2[ TICK * sizeof( countT ) * 2 ] ;

countT cbArray1 = sizeof pbArray1 ;
byteT  pbArray1[ TICK * sizeof( countT ) * 2 ] ;

/*1*/WAKEsHOW( "example.dut.1snip.1500019d.sortaC.wo.tick.elements.multithread" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
