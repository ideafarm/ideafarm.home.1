
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etherC::loafIF( tinBaseP ) ;

}
    ++ s ; ether.osSleepF( tinBaseP , TOCK >> 2 ) ;

    }
        etThread.traceF( tinBaseP , T("launched [cLaunched,cAlive]:    ")+TF2(++cLaunched,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cAliveSnap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        etThread.osThreadF( TaRG1( tmWorkF ) , (countT)&cAlive ) ;
        inc02AM( cAlive ) ;
    {
    if( cAliveSnap < 0x10 )

    countT cAliveSnap = cAlive ;
{
while( !ether )
TN( tb4 , "    " ) ;
sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
ZE( countT , cAlive ) ;
ZE( countT , cLaunched ) ;

TODO

DONE( tmWorkF )
}
    dec02AM( cAliveP ) ;
    }
        etThread.delF( tinBaseP , pNicName ) ;
        }
            }
                }
                    }
                        }
                            etThread.traceF( tinBaseP , T("reply received") ) ;
                        {
                        else
                        }
                            etThread.traceF( tinBaseP , T("error: could not read reply") ) ;
                            POOPR
                        {
                        if( POOP )

                        etThread.delF( tinBaseP , postIn ) ;
                        }
                            //CONoUTrAW( postIn + offi - 1 ) ;
                            sGet.readF( tinBaseP , postIn + ( offi ++ ) , 1 ) ;
                        {
                        while( !POOP && offi < TOCK - 1 )
                        //CONoUTrAW( "\r\n" ) ;
                        ZE( countT , offi ) ;
                        etThread.traceF( tinBaseP , T("reading reply") ) ;

                        thirdC::c_memsetIF( tinBaseP , postIn , TOCK ) ;
                        etThread.newF( tinBaseP , LF , postIn , TOCK ) ; ___( postIn ) ;
                        ZE( osTextT* , postIn ) ;
                    {
                    else
                    }
                        etThread.traceF( tinBaseP , T("error: could not write request") ) ;
                        POOPR
                    {
                    if( POOP )

                    etThread.traceF( tinBaseP , T("wrote   request") ) ;
                    sGet.writeF( tinBaseP , (osTextT*)tRequest ) ;
                    etThread.traceF( tinBaseP , T("writing request") ) ;

                    etThread.osTimeNowF( tinBaseP , timeA1 , timeA2 ) ;
                    ZE( sCountT , timeA2 ) ;
                    ZE( countT  , timeA1 ) ;

                    //TN( tRequest , "" ) ; tRequest = T("GET / HTTP/1.1\r\nHost: ideafarm.com\r\n\r\n") ;
                    TN( tRequest , "" ) ; tRequest = T("GET / HTTP/1.1\r\nHost: ideafarm.com") ;                     // INTENTIONALLY INCOMPLETE

                    //etThread.traceF( tinBaseP , T("[idpMeBound,idpMe,nnMe]:    ")+TF2(idpMeBound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idpMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(nnMe) ) ;
                {
                else
                }
                    etThread.traceF( tinBaseP , T("error: could not get my connection endpoint name") ) ;
                    POOPR
                {
                if( POOP )

                sGet.myNameF( tinBaseP , idpMe , nnMe ) ;
                nicNameC nnMe ;
                ZE( countT , idpMe ) ;
            {
            else
            }
                etThread.traceF( tinBaseP , T("error: could not connect") ) ;
                POOPR
            {
            if( POOP )

            sGet.connectF( tinBaseP , 0x50 , pNicName[ 0 ] , 1 ) ;
            etThread.traceF( tinBaseP , T("connecting") ) ;
            socketC sGet( tinBaseP , *((tinNormalS&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) /*, 0 , flSOCKETc_null , 0 , countTC( SOCKETtIMEOUTdEFAULTlAN ) , countTC( SOCKETtIMEOUTdEFAULTlAN ) , countTC( SOCKETtIMEOUTdEFAULTlAN )*/ ) ;
        {
        else
        }
            etThread.traceF( tinBaseP , T("error: could not obtain nicName array") ) ;
            POOPR ;
        {
        if( POOP )

        __Z( cNicName ) ;
        __Z( pNicName ) ;
        socketC::nicNameIF( tinBaseP , *((tinNormalS&)tinBaseP).pEtScratch , pNicName , cNicName , T("factory6.ideafarm.com") ) ; ___( pNicName ) ;
        ZE( nicNameC* , pNicName ) ;
        ZE( countT , cNicName ) ;

        SCOOPS
    {
    IFsCRATCH

    countT& cAliveP = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmWorkF )

/*1*/WAKEsHOWtEXT( "gorilla.http.malicious.attacker.sends.intentionally.incomplete.http.requests" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

