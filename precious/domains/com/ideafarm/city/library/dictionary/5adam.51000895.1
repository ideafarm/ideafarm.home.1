
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        }
            //U::sgnDone_tmLoadSilent.waitF( tin0P ) ;

            TELL( "cleaning up" ) ;
            }
                *((tin1S&)tin0P).pEtScratch = 0 ; //U: WORKAROUND TO SEE WHETHER PREVENTS BLOCK IN bindF
                TELL( "destroying the catching socket" ) ;
                }
                    ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbq ) ;
                    }
                        }
                            if( bFireOs ) ((tin1S&)tin0P).pEtScratch->osFireF( tin0P ) ;

                            //CONoUTrAW( "done\r\n" ) ;
                            TELL( "query packet handled" ) ;
                            }
                                ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbr ) ;

                                /*while( cTries -- )*/ sockd.writeF( tin0P , idp , nnPeer , pbr , cbr ) ;
                                //KEEP THE REPLY SUPPRESSED UNTIL I FULLY UNDERSTAND HOW TO PREVENT ME FROM BEING USED MALICIOUSLY
                                //U::DISABLED TO PREVENT ME FROM BEING USED TO ATTACK SPOOFED REQUESTER

                                countT cTries = 8 ;
                                TELL( "writing a reply" ) ;

                                ((tin1S&)tin0P).pEtScratch->dnsReplyF( tin0P , pbr , cbr , pbq , stsReplies , 1 , idError ) ;
                                ZE( countT , cbr ) ;
                                ZE( byteT* , pbr ) ;
                                TELL( "composing a reply" ) ;
                                //CONoUTrAW( "emitting reply\r\n" ) ;
                            {
                            else
                            }
                                etRock.traceF( tin0P , T(nnPeer)+tSaySilentlyIgnoring+tb4+tDomainPeer ) ;
                                CONoUTrAW( "silent\r\n" ) ;
                            {
                            if( bSilent )

                            }
                                ((tin1S&)tin0P).pEtScratch->delF( tin0P , psttPeer ) ;
                                TELL( "cleaning up after handling the query datagram" ) ;

                                }
                                    }
                                        DEL( ps ) ;
                                        }
                                            TELL( "cleaning up after handling a single query" ) ;
                                            ((tin1S&)tin0P).pEtScratch->delF( tin0P , psttw ) ;
                                            }
                                                }
                                                    break ;
                                                    idError = ifcIDeRRORdNS_AOK ;                       //20250220@1114: REQUIRED BY RFC 1035 ACCORDING TO https://letsencrypt.org/docs/caa/
                                                    //idError = ifcIDeRRORdNS_QUERYnOTsUPPORTED ;
                                                    //((tin1S&)tin0P).pEtScratch->strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": nOTsUPPORTED: ")+T(psttw)+T("\r\n") ) ;
                                                    TELL( "ifcIDeRRORdNS_QUERYnOTsUPPORTED" ) ;
                                                    //CONoUTrAW3( "type " , idType , " [not supported]\r\n" ) ;
                                                    bSilent = 1 ;
                                                {
                                                default :
                                                //}
                                                //    break ;
                                                //    idError = ifcIDeRRORdNS_QUERYnOTsUPPORTED ;
                                                //    //((tin1S&)tin0P).pEtScratch->strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": OPTION: ")+T(psttw)+T("\r\n") ) ;
                                                //    TELL( "ifcIDtYPEdNSqUERY_OPTION" ) ;
                                                //    //CONoUTrAW( "OPTION\r\n" ) ;
                                                //{
                                                //case ifcIDtYPEdNSqUERY_OPTION :
                                                //}
                                                //    break ;
                                                //    if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tRoot ) ) rec_SOA_F( tin0P , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , psttw , tNs1 , tEmail ) ;
                                                //    //((tin1S&)tin0P).pEtScratch->strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": SOA: ")+T(psttw)+T("\r\n") ) ;
                                                //    TELL( "ifcIDtYPEdNSqUERY_SOA" ) ;
                                                //    //CONoUTrAW( "SOA\r\n" ) ;
                                                //{
                                                //case ifcIDtYPEdNSqUERY_SOA :
                                                //}
                                                //    break ;
                                                //
                                                //    }
                                                //        rec_NS_F( tin0P , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , psttw , tNs2 ) ;
                                                //        rec_NS_F( tin0P , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , psttw , tNs1 ) ;
                                                //    {
                                                //    if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tRoot ) )
                                                //    //((tin1S&)tin0P).pEtScratch->strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": NS: ")+T(psttw)+T("\r\n") ) ;
                                                //    TELL( "ifcIDtYPEdNSqUERY_NS" ) ;
                                                //    //CONoUTrAW( "NS\r\n" ) ;
                                                //{
                                                //case ifcIDtYPEdNSqUERY_NS :
                                                //}
                                                //    break ;
                                                //    }
                                                //        rec_A_F(  tin0P , stsReplies , ifcIDtYPEdNSrEPLY_NOTE   , tMail , nnRoot ) ;
                                                //        rec_MX_F( tin0P , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , psttw , tMail ) ;
                                                //    {
                                                //    if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tRoot ) )
                                                //    ((tin1S&)tin0P).pEtScratch->strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": MX: ")+T(psttw)+T("\r\n") ) ;
                                                //    TELL( "ifcIDtYPEdNSqUERY_MX" ) ;
                                                //    //CONoUTrAW( "MX\r\n" ) ;
                                                //{
                                                //case ifcIDtYPEdNSqUERY_MX :
                                                }
                                                    break ;

                                                    }
                                                        }
                                                            rec_A_F( tin0P , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , psttw , nnOut ) ;
                                                            etThread.traceF( tin0P , T("found a matching A record! [nnOut,domain,peer]:    ")+T(nnOut)+tb4+T(psttw)+tb4+tDomainPeer ) ;
                                                        {
                                                        else
                                                        }
                                                            etThread.traceF( tin0P , T("!exception / matching A record but unlisted and unexpected peer, so not responding [nnOut,domain,peer]:    ")+T(nnOut)+tb4+T(psttw)+tb4+tDomainPeer ) ;
                                                            bSilent = 1 ;
                                                        {
                                                        if( !bListedDomain )
                                                    {
                                                    if( !bSilent )

                                                    }
                                                        etThread.traceF( tin0P , T("no matching A record [domain,peer]:    ")+T(psttw)+tb4+tDomainPeer ) ;
                                                        bSilent = 1 ;
                                                    {
                                                    else

                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tAllowVersion  ) ) nnOut = nnAllow ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tRefuseVersion ) ) nnOut = nnRefuse ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tSingularity   ) ) nnOut = nnSingularity ; //MIGHT BE 0.  THIS MEANS THAT A SINGULARITY IS NOT REGISTERED
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tNs5           ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tNs            ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tMail          ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tFtp           ) ) nnOut = nnRoot ;
                                                    //else if( ((tin1S&)tin0P).pEtScratch->strIdF(       tin0P , tHostOk , psttw        ) ) { nnOut = nnRoot /*ANY NONZE VALUE WILL DO*/ ; } //U: ASSUME: I AM LIVING ON THE HOST THAT IS TO BE FIRED
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tFireOs        ) ) { nnOut = nnRoot ; bFireOs = 1 ; } //U: ASSUME: I AM LIVING ON THE HOST THAT IS TO BE FIRED
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tWww           ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tRoot          ) ) nnOut = nnRoot ;
                                                    //}
                                                    //    ((tin1S&)tin0P).pEtScratch->delF( tin0P , psttDigits ) ;
                                                    //    //((tin1S&)tin0P).pEtScratch->ifcSayF( tin0P , T("idComputer=")+TF1(idComputer)+T(" nnOut=")+T(nnOut)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                                                    //    swNicName.ungrabF( tin0P ) ;
                                                    //    nnOut = *(nicNameC*)&(countT&)swNicName ;
                                                    //    idComputer = ((tin1S&)tin0P).pEtScratch->strDigitsToSCountF( tin0P , psttDigits ) ;
                                                    //    swNicName.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                    //    ((tin1S&)tin0P).pEtScratch->strWordF( tin0P , psttDigits , psttw , sttq , S1C('.') ) ; ___( psttDigits ) ; ;
                                                    //    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                                    //    ZE( strokeS* , psttDigits ) ;
                                                    //{
                                                    //else if( ((tin1S&)tin0P).pEtScratch->strIdF( tin0P , tQueryHostSuffix , psttw ) )
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tIfc5        ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tIfc1        ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tPort3Space  ) ) nnOut = nnRelayPortCraft ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tPort2Space  ) ) nnOut = nnRelayPortTest ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tPort1Space  ) ) nnOut = nnRelayPort ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tNn3Space    ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tNn2Space    ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tNn1Space    ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tGorilla1    ) ) nnOut = nnGorilla1 ;
                                                    //
                                                    //P:PERSONALITY: I MUST KNOW ONLY UNGUESSABLE RANDOM SECRET DOMAIN NAMES SO THAT A PEER THAT DOES NOT KNOW WO OF THEM DOESN'T GET A REPLY
                                                    //

                                                    //U:: COMMENT OUT ALL OF THE CODE THAT IS ONLY NEEDED FOR THE FOLLOWING COMMENTED OUT LINES

                                                    else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tWebHook1    ) ) nnOut = nnWebHook1 ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                                         if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tWebHooks    ) ) nnOut = nnWebHook1 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...

                                                    //}
                                                    //    //((tin1S&)tin0P).pEtScratch->ifcSayF( tin0P , T("looked up teacher's nicNameC value: ")+T("idComputer=")+TF1(idComputer)+T(" nnOut=")+T(nnOut)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                                                    //    swNicName.ungrabF( tin0P ) ;
                                                    //    nnOut = *(nicNameC*)&(countT&)swNicName ;
                                                    //    idComputer = 0x4c3b8d9f  ; // SERIAL OF DRIVE ///c ON IFC12 (LAPTOP)
                                                    //    swNicName.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                    //{
                                                    //if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttw , tTeacher ) )

                                                    //CONoUTrAW( T("A: \"")+T(psttw)+T("\"\r\n") ) ;

                                                    nicNameC nnOut ;
                                                    //CONoUTrAW( TF1(idClient)+T(" ")+T(nnPeer)+T(" ")+T(psttPeer)+T(": A: \"")+T(psttw)+T("\"\r\n") ) ;
                                                    //((tin1S&)tin0P).pEtScratch->strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": A: \"")+T(psttw)+T("\"\r\n") ) ;
                                                    //((tin1S&)tin0P).pEtScratch->ifcSayF( tin0P , TF1(idClient)+T(" ")+T(nnPeer)+T(" ")+T(psttPeer)+T(": A: \"")+T(psttw)+T("\"\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                                                    TELL( "ifcIDtYPEdNSqUERY_A" ) ;
                                                    //CONoUTrAW( "A\r\n" ) ;
                                                {
                                                case ifcIDtYPEdNSqUERY_A :
                                                }
                                                    break ;
                                                {
                                                case ifcIDtYPEdNSqUERY_CAA :
                                            {
                                            else if( idClass == 1 ) switch( idType )
                                            if( bSilent ) ;//((tin1S&)tin0P).pEtScratch->ifcSayF( tin0P , T("---- SILENT REFUSAL: ")+T(nnPeer)+T(" ")+T(psttPeer)+T(": A: ")+T(psttw)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;

                                            *ps >> idClass ;
                                            ZE( countT , idClass ) ;

                                            *ps >> idType ;
                                            ZE( countT , idType ) ;

                                            }
                                                etThread.traceF( tin0P , T("[domainNet,peer]:      \"")+T(psttw)+T("\"    \"")+tDomainPeer+T("\"") ) ;

                                                etThread.strMakeF( tin0P , LF , psttw , tDomainNet ) ; ___( psttw ) ;
                                                TN( tDomainNet , "" ) ; tDomainNet = T(psttNet)+T(".hidden.ideafarm.com") ;

                                                etThread.delF( tin0P , psttw ) ;
                                                etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttw , 0 , 0 ) ;
                                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                countT idf = 1 ;
                                                ZE( strokeS* , psttNet ) ;
                                            {
                                            if( psttw )

                                            etThread.traceF( tin0P , T("[domainGross,peer]:    \"")+T(psttw)+T("\"    \"")+tDomainPeer+T("\"") ) ;
                                            if( psttw ) ((tin1S&)tin0P).pEtScratch->strConvertToLowerCaseF( tin0P , psttw ) ; ___( psttw ) ;
                                            *ps >> psttw ;
                                            ZE( strokeS* , psttw ) ;
                                            TELL( "preparing to respond to a single query" ) ;
                                        {
                                        if( ps )
                                        stsQueries >> ps ;
                                        ZE( soulC* , ps ) ;
                                        TELL( "handling a query" ) ;
                                    {
                                    while( stsQueries )
                                    TELL( "counting the remaining queries" ) ;
                                {
                                else
                                }
                                    bSilent = 1 ;
                                    POOPR ;
                                {
                                if( POOP )

                                }
                                    ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbNU ) ;
                                    ((tin1S&)tin0P).pEtScratch->dnsParseF( tin0P , pbNU , countTC() , stsQueries , stsRepliesNU , pbq , cbq ) ;
                                    ZE( byteT* , pbNU ) ;

                                    stsRepliesNU.purgeF( tin0P ) ;
                                    stsQueries.purgeF( tin0P ) ;
                                {
                                TELL( "parsing the queries" ) ;
                                //CONoUTrAW( "parsing the queries\r\n" ) ;

                                //((tin1S&)tin0P).pEtScratch->sockPsttHostF( tin0P , psttPeer , nnPeer ) ; ___( psttPeer ) ;
                                TELL( "transcribing the peer nicName" ) ;
                                ZE( strokeS* , psttPeer ) ;
                                //etThread.strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T("parsing request")+te ) ;

                                ++ idClient ;
                            {
                            //else
                            //}
                            //    CONoUTrAW( "request refused (nnNopeRefuse1)\r\n" ) ;
                            //    idError = ifcIDeRRORdNS_QUERYrEFUSED ;
                            //{
                            //if( nnPeer == nnNopeRefuse1 )

                            ZE( boolT , bFireOs ) ;

                            countT idError = ifcIDeRRORdNS_AOK ;
                        {
                        if( pbq && cbq )

                        //b_pnnSilent.ungrabF( tin0P ) ;
                        //}
                        //    }
                        //        break ;
                        //        bSilent = 1 ;
                        //    {
                        //    if( nnPeer == pnnSilent[ off ] )
                        //{
                        //for( countT off = 0 ; off < cnnSilent ; off ++ )
                        //b_pnnSilent.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        ZE( boolT , bSilent ) ;

                        TELL( "preparing to handle a query packet" ) ;
                        etRock.traceF( tin0P , tSayPrefix+T(nnPeer)+tb4+tDomainPeer ) ;
                    {

                    if( !bPeerListedOrStripe ) etRock.traceF( tin0P , tSayPrefix+T(nnPeer)+tSayUnknownDomain+tb4+tDomainPeer ) ;

                    const boolT bPeerListedOrStripe = bListedDomain || nnsStripe & nnPeer ;

                    }
                        ether.delF( tin0P , psttPeer ) ;
                        }
                            bListedDomain |= idHit2 && idHit2 == 1 + psttPeer->idAdam - tListedDomain2.csF( tin0P ) ;
                            countT idHit2  = etThread.strIdF( tin0P , tListedDomain2 , psttPeer , 1 ) ;

                            bListedDomain  = idHit1 && idHit1 == 1 + psttPeer->idAdam - tListedDomain1.csF( tin0P ) ;
                            countT idHit1  = etThread.strIdF( tin0P , tListedDomain1 , psttPeer , 1 ) ;

                            //etThread.traceF( tin0P , T("[tPeer]:    ")+T(psttPeer) ) ;
                            tDomainPeer = T(psttPeer) ;
                        {
                        else
                        if( !psttPeer ) ether.traceF( tin0P , T("!exception / reverse DNS lookup failed") ) ;
                        ether.sockPsttHostF( tin0P , psttPeer , nnPeer ) ; ___( psttPeer ) ;
                        ZE( strokeS* , psttPeer ) ;
                    {
                    ZE( boolT , bListedDomain ) ;
                    TN( tDomainPeer , "" ) ;

                    TELL( "waited for a query datagram" ) ;
                    sockd.readF( tin0P , pbq , cbq , idp , nnPeer ) ; ___( pbq ) ;
                    TELL( "waiting for a query datagram" ) ;
                    nicNameC nnPeer ;
                    ZE( countT , idp ) ;
                    ZE( countT , cbq ) ;
                    ZE( byteT* , pbq ) ;
                {
                while( !POOP && !ether && !etThread && !*((tin1S&)tin0P).pEtScratch )
                TN( tSaySilentlyIgnoring , "    !exception / silently ignoring    " ) ;
                TN( tSayUnknownDomain , "    !exception / unknown peer domain" ) ;
                TN( tSayPrefix  , "[nnPeer]:    " ) ;
                etherC& etRock = etherC::etRockIF( tin0P ) ;

                //nicNameC nnRoot2 = etThread.sockNicNameF( tin0P , T("69.0.244.16") ) ;

                //nicNameC nnAllow(  0x00ff00ff ) ;
                //nicNameC nnRefuse( 0xff00ff00 ) ;
                //if( etThread.diskIdF( tin0P , T("///c") ) != 0x2c1f032d ) nnRoot  = etThread.sockNicNameF( tin0P , T("69.0.243.16") ) ;
                //nicNameC nnRoot( NICnAMElOCAL ) ;    // 127.1.1.1 //U:
                //nicNameC nnRoot( 0x40ef0525 ) ;    // ifc5: 64.239.5.37
                //nicNameC nnRoot( 0xd8a2a931 ) ;    // ifc4: 216.162.169.49
                //nicNameC nnRoot( 0x0a010102 ) ;    // 10.1.1.2 //U:

                nicNameC nnWebHook1       = etThread.sockNicNameF( tin0P , tIpWebHook1 ) ;

                //nicNameC nnRelayPortCraft = nicNameC( ifcIDpORT_RELAYcRAFT ) ;
                //nicNameC nnRelayPortTest  = nicNameC( ifcIDpORT_RELAYtEST ) ;
                //nicNameC nnRelayPort      = nicNameC( ifcIDpORT_RELAY ) ;
                //nicNameC nnRoot           = nnThisHost ;
                //nicNameC nnThisHost       = socketC::nicNameIF( tin0P , etThread ) ;
                //nicNameC nnThisHost     = etThread.sockNicNameF( tin0P ) ;

                //TN( tPort3Space      , "port.3.space.ideafarm.com" ) ;
                //TN( tPort2Space      , "port.2.space.ideafarm.com" ) ;
                //TN( tPort1Space      , "port.1.space.ideafarm.com" ) ;
                //TN( tNn3Space        , "nicname.3.space.ideafarm.com" ) ;
                //TN( tNn2Space        , "nicname.2.space.ideafarm.com" ) ;
                //TN( tNn1Space        , "nicname.1.space.ideafarm.com" ) ;
                //TN( tAllowVersion    , "2.version.ipdos.ideafarm.com" ) ;
                //TN( tRefuseVersion   , "1.version.ipdos.ideafarm.com" ) ;
                //TN( tQueryHostSuffix ,        ".host.ideafarm.com" ) ;
                //TN( tTeacher         , "teacher.host.ideafarm.com" ) ;
                //TN( tIfc5            ,    "ifc5.host.ideafarm.com" ) ;
                //TN( tIfc1            ,    "ifc1.host.ideafarm.com" ) ;
                //TN( te     , "\r\n" ) ;
                TN( tb4    , "    " ) ;
                //TN( tb     , " " ) ;
                //TN( tBar   , "| " ) ;
                //TN( tLog   , "///d/ideafarm.log.port.53.dns" ) ;
                //TN( tNs5   ,    "ns5.ideafarm.com" ) ;
                //TN( tNs4   ,    "ns4.ideafarm.com" ) ;
                //TN( tNs3   ,    "ns3.ideafarm.com" ) ;
                //TN( tNs2   ,    "ns2.ideafarm.com" ) ;
                //TN( tNs1   ,    "ns1.ideafarm.com" ) ;
                //TN( tNs    ,     "ns.ideafarm.com" ) ;
                //TN( tSingularity , "singularity.ideafarm.com" ) ;
                //TN( tFtp   ,     "ftp.ideafarm.com" ) ;
                //TN( tHostOk , ".!hostxk.ideafarm.com" ) ;
                //TN( tFireOs ,  "!fire.ideafarm.com" ) ;
                //TN( tWww   ,     "www.ideafarm.com" ) ;
                //TN( tMail  ,    "mail.ideafarm.com" ) ;
                //TN( tTest  ,    "test.ideafarm.com" ) ;
                //TN( tGorilla1 , "go1.hidden.ideafarm.com" ) ;
                TN( tWebHook1 , "" ) ; tWebHook1 = tDomainLeafWebHook1Net+T(".hidden.ideafarm.com") ;
                TN( tWebHooks , "" ) ; tWebHooks = tDomainLeafWebHooksNet+T(".hidden.ideafarm.com") ;
                //TN( tEmail ,    ifcEMAIL_DNS ) ;
                //TN( tRoot  ,    "ideafarm.com" ) ;

                sockd.bindF( tin0P , ifcPORToLD2_DNS ) ;
                socketC sockd( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
                TELL( "preparing to catch query datagrams" ) ;
                stsReplies.purgeF( tin0P ) ;
                stsQueries.purgeF( tin0P ) ;
                *((tin1S&)tin0P).pEtScratch = 0 ;
            {
            while( !POOP && !ether && !etThread )
            stackC stsQueries(   tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            stackC stsReplies(   tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            stackC stsRepliesNU( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            ZE( countT , idClient ) ;

            //ether.loafIF( tin0P ) ; //U::DISABLE ME UNTIL I AM ENHANCED TO IGNORE OBVIOUS DDOS CLIENTS THAT PEG MY CPU

            //etThread.osThreadF( tin0P , countTC() , tmLoadSilentF , &sgnDone_tmLoadSilent , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&b_pnnSilent , (countT)&pnnSilent , (countT)&cnnSilent ) ;
            //signC sgnDone_tmLoadSilent( tin0P , TAG( TAGiDnULL ) ) ;

            const nicNameC nnNopeRefuse1 = etThread.sockNicNameF( tin0P , T("1.2.3.4") ) ; // example.reply.with.refusal
            ZE( countT    , cnnSilent ) ;
            ZE( nicNameC* , pnnSilent ) ;
            batonC b_pnnSilent( tin0P , TAG( TAGiDnULL ) ) ;
            //PSEUDODUPLICATE CODE: 1030168 2540104

            SCOOPS
        {
        IFsCRATCHoK

        //CONoUTrAW( "main/4\r\n" ) ; //U::
        count4S  c4p( (countT)&nnSingularity , (countT)&bParams , (countT)&idComputer , (countT)&swNicName ) ;
        switchC swNicName( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idComputer , 0 , sizeof( nicNameC ) ) ;
        ZE( countT , idComputer ) ;
        batonC bParams( tin0P , TAG( TAGiDnULL ) ) ;
        nicNameC nnSingularity ;

        TN( tListedDomain2 , (strokeS*)tDomainRootAllowed2 ) ;
        TN( tListedDomain1 , (strokeS*)tDomainRootAllowed1 ) ;

        //nicNameC nnReserved2     = etThread.sockNicNameF( tin0P , T("10.0.3.1") ) ;
        //nicNameC nnReserved1     = etThread.sockNicNameF( tin0P , T("64.176.222.148") ) ;

        //nicNameC nnLaptopSil1PhoneHotspot6 = etThread.sockNicNameF( tin0P , T("2600:387:15:5012::4") ) ;
        //nicNameC nnLaptopSil1PhoneHotspot4 = etThread.sockNicNameF( tin0P , T("72.159.157.28") ) ;
        //nicNameC nnLaptopSil1OfficeHotspot = etThread.sockNicNameF( tin0P , T("50.216.215.70") ) ;
        //nicNameC nnLaptopSil1OfficeWired   = etThread.sockNicNameF( tin0P , T("50.216.215.70") ) ;

        nicNamesAllowedStripeWebHookNotificationsC nnsStripe( tin0P , etThread , ether , TICK << 4 ) ;  //IT'S BEEN YEARS SINCE THESE HAVE CHANGED

        //CONoUTrAW( "main/5\r\n" ) ; //U::
        TELL( "preparing for work" ) ;
    {
    else
    }
        etThread.traceF( tin0P , T("a required setting is missing") ) ;
    {
    )
        !tDomainRootAllowed2.csF( tin0P )
        ||
        !tDomainRootAllowed1.csF( tin0P )
        ||
        !tIpWebHook1.csF( tin0P )
        ||
        !tDomainLeafWebHook1Net.csF( tin0P )
        ||
        !tDomainLeafWebHooksNet.csF( tin0P )
        ||
        !tIpWebHook1.csF( tin0P )
    (
    if

    etThread.traceF( tin0P , T("settings [tIpWebHook1,tDomainLeafWebHooksNet,tDomainLeafWebHook1Net,tDomainRootAllowed1,tDomainRootAllowed2]:    \"")+tIpWebHook1+T("\"    \"")+tDomainLeafWebHooksNet+T("\"    \"")+tDomainLeafWebHook1Net+T("\"    \"")+tDomainRootAllowed1+T("\"    \"")+tDomainRootAllowed2+T("\"") ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed2 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.2")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed2 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed1 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.1")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed1 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tIpWebHook1 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1")  ) ; ___( psttEat ) ;
    {
    TN( tIpWebHook1 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        }
            etThread.delF( tin0P , psttNet ) ;
            tDomainLeafWebHook1Net = T(psttNet) ;
            etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.wh1")  ) ; ___( psttEat ) ;
    {
    TN( tDomainLeafWebHook1Net , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        }
            etThread.delF( tin0P , psttNet ) ;
            tDomainLeafWebHooksNet = T(psttNet) ;
            etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.webhooks")  ) ; ___( psttEat ) ;
    {
    TN( tDomainLeafWebHooksNet , "" ) ;

    TN( tDash , "-" ) ;

    _IO_
{
if( pTaskP )
TASK( tmWorkF )

#endif

DONE( tmLoadSilentF )
}
    b_pnnSilent.ungrabF( tin0P ) ;
    cnnSilent = 0 ;
    etThread.delF( tin0P , pnnSilent ) ;
    b_pnnSilent.grabF( tin0P , TAG( TAGiDnULL ) ) ;

    }
        ether.osSleepF( tin0P , TOCK * 0x10 ) ;

        etThread.delF( tin0P , psttAll ) ;
        }
            etThread.delF( tin0P , pstt1Lines ) ;
            b_pnnSilent.ungrabF( tin0P ) ;
            }
                etThread.delF( tin0P , psttnn ) ;
                etThread.strokeF( tin0P , T("i will silently ignore: ")+T(pnnSilent[off-1])+T(" (\"")+T(psttnn)+T("\")\r\n") ) ;
                pnnSilent[ off ++ ] = etThread.strDigitsToNicNameF( tin0P , psttnn ) ;
                etThread.strWordF( tin0P , psttnn , psttc1 , sttq , S1C(';') ) ; ___( psttnn ) ;
                ZE( strokeS* , psttnn ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            {
            FORsTRINGSiN1( pstt1Lines )
            ZE( countT , off ) ;
            etThread.newF( tin0P , LF , pnnSilent , cnnSilent ) ; ___( pnnSilent ) ;
            cnnSilent = etThread.strWordsOldF( tin0P , pstt1Lines , psttAll , sttq , T("\r\n") ) ; ___( pstt1Lines ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1Lines ) ;

            cnnSilent = 0 ;
            etThread.delF( tin0P , pnnSilent ) ;

            b_pnnSilent.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        {
        if( psttAll )
        bFile.ungrabF( tin0P ) ;
        etThread.boxGetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF( tin0P , psttAll , T("///d/ideafarm.")+TF1(etherC::ifc_idHomeI_IF())+T(".setting.keyValue.nnSilent") ) ; ___( psttAll ) ;
        bFile.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        batonC bFile( tin0P , TAG( TAGiDnULL ) , T("setting.keyValue.nnSilent") ) ;
        ZE( strokeS* , psttAll ) ;
    {
    while( !etThread && !ether )

    countT&    cnnSilent   =    *(countT*)pTaskP->c3 ;
    nicNameC*& pnnSilent   = *(nicNameC**)pTaskP->c2 ;
    batonC&    b_pnnSilent =    *(batonC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmLoadSilentF )
//DUPLICATED CODE: 1030168 2540104

#if defined( NEVERdEFINED )

}
    }
        stsRepliesP << ps ;

        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // cSerial
        *ps << (countT)0 ; // cSerial
        *ps << psttEmailP ;
        *ps << psttNsP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_SOA ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_SOA_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttNsP , const strokeS* const psttEmailP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_NS ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_NS_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;
        *ps << (countT)0 ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_MX ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_MX_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_A ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_A_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )


//  
// U:: USE A "SHIELDS DOWN" MECHANISM SO THAT THIS CAN BE SUPPRESSED DURING ACME CERTIFICATE RENEWAL AND OTHERWISE ENABLED
// U: (FUTURE): I ALSO VALIDATE REQUESTS BY DOING A REVERSE DNS LOOKUP AND IGNORING REQUESTS IF THE DOMAIN IS UNEXPECTED
//  
//  THIS IS BOTH TO MITIGATE FLOOD ATTACKS AND TO CONCEAL THAT I AM A DNS NAME SERVER FROM PEERS WHO HAVE MY IP ADDRESS (E.G. FROM SCANNING THE IPv4 SPACE) BUT DO NOT KNOW (FROM A HIGHER LEVEL NAMESERVER) THAT I AM A NAMESERVER
// IF THE LEAF IS UNKNOWN TO ME, I SILENTLY IGNORE THE REQUEST
//  
//P:PERSONALITY: I KEEP IP ADDRESSES CONFIDENTIAL, PRIMARILY BY TREATING THE REQUESTED DOMAIN NAME LEAF AS A PASSWORD

// OBSOLETES 614_ (LIKE 614_ BUT USES WHITELIST NOT BLACKLIST)

/*1*/WAKEhIDE( "ifcIDaDAM_DNS" )/*1*/

/**/
*/
 i simply map names (many to 1 and 1 to many) into ip addresses and tell the client to not cache
i do not use the canonical name concept
 initially, this was a copy of 254 for which ifcChat was eliminated since ifcChat is obsoleted by relayOldC
 2010.12.23: brought back into service for development on laptop after not being used for many years
obsoletes 254
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

