
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        }
            //U::sgnDone_tmLoadSilent.waitF( tin0P ) ;

            TELL( "cleaning up" ) ;
            }
                *((tin1S&)tin0P).pEtScratch = 0 ; //U: WORKAROUND TO SEE WHETHER PREVENTS BLOCK IN bindF
                TELL( "destroying the catching socket" ) ;
                }
                    ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbq ) ;
                    }
                        }
                            if( bFireOs ) ((tin1S&)tin0P).pEtScratch->osFireF( tin0P ) ;

                            TELL( "query packet handled" ) ;
                            }
                                ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbr ) ;
                                sockd.writeF( tin0P , idp , nnPeer , pbr , cbr ) ;
                                TELL( "writing a reply" ) ;

                                ((tin1S&)tin0P).pEtScratch->dnsReplyF( tin0P , pbr , cbr , pbq , stsReplies , 1 , idError ) ;
                                ZE( countT , cbr ) ;
                                ZE( byteT* , pbr ) ;
                                //etThread.traceF( tin0P , T("replying [idError]:    ")+TF2(idError,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                TELL( "composing a reply" ) ;
                                //CONoUTrAW( "emitting reply\r\n" ) ;
                            {
                            else
                            if( bSilent && !bPeerListedOrStripe ) ;//etRock.traceF( tin0P , T(nnPeer)+tSaySilentlyIgnoring+tb4+tDomainPeer ) ;

                            }
                                ((tin1S&)tin0P).pEtScratch->delF( tin0P , psttPeer ) ;
                                TELL( "cleaning up after handling the query datagram" ) ;

                                }
                                    }
                                        DEL( ps ) ;
                                        }
                                            TELL( "cleaning up after handling a single query" ) ;
                                            }
                                                }
                                                    break ;
                                                    idError = ifcIDeRRORdNS_AOK ;                       //20250220@1114: REQUIRED BY RFC 1035 ACCORDING TO https://letsencrypt.org/docs/caa/
                                                    //idError = ifcIDeRRORdNS_QUERYnOTsUPPORTED ;
                                                    //((tin1S&)tin0P).pEtScratch->strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": nOTsUPPORTED: ")+tDomainNet+T("\r\n") ) ;
                                                    TELL( "ifcIDeRRORdNS_QUERYnOTsUPPORTED" ) ;
                                                    //CONoUTrAW3( "type " , idType , " [not supported]\r\n" ) ;
                                                    bSilent = 1 ;
                                                    //etThread.traceF( tin0P , T("!exception / setting bSilent because this is an unsupported request type [idType]:    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                default :
                                                //}
                                                //    break ;
                                                //    idError = ifcIDeRRORdNS_QUERYnOTsUPPORTED ;
                                                //    //((tin1S&)tin0P).pEtScratch->strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": OPTION: ")+tDomainNet+T("\r\n") ) ;
                                                //    TELL( "ifcIDtYPEdNSqUERY_OPTION" ) ;
                                                //    //CONoUTrAW( "OPTION\r\n" ) ;
                                                //{
                                                //case ifcIDtYPEdNSqUERY_OPTION :
                                                //}
                                                //    break ;
                                                //    if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tRoot ) ) rec_SOA_F( tin0P , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , tNs1 , tEmail ) ;
                                                //    //((tin1S&)tin0P).pEtScratch->strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": SOA: ")+tDomainNet+T("\r\n") ) ;
                                                //    TELL( "ifcIDtYPEdNSqUERY_SOA" ) ;
                                                //    //CONoUTrAW( "SOA\r\n" ) ;
                                                //{
                                                //case ifcIDtYPEdNSqUERY_SOA :
                                                //}
                                                //    break ;
                                                //
                                                //    }
                                                //        rec_NS_F( tin0P , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , tNs2 ) ;
                                                //        rec_NS_F( tin0P , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , tNs1 ) ;
                                                //    {
                                                //    if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tRoot ) )
                                                //    //((tin1S&)tin0P).pEtScratch->strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": NS: ")+tDomainNet+T("\r\n") ) ;
                                                //    TELL( "ifcIDtYPEdNSqUERY_NS" ) ;
                                                //    //CONoUTrAW( "NS\r\n" ) ;
                                                //{
                                                //case ifcIDtYPEdNSqUERY_NS :
                                                //}
                                                //    break ;
                                                //    }
                                                //        rec_A_F(  tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_NOTE   , tMail , nnRoot ) ;
                                                //        rec_MX_F( tin0P , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , tMail ) ;
                                                //    {
                                                //    if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tRoot ) )
                                                //    ((tin1S&)tin0P).pEtScratch->strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": MX: ")+tDomainNet+T("\r\n") ) ;
                                                //    TELL( "ifcIDtYPEdNSqUERY_MX" ) ;
                                                //    //CONoUTrAW( "MX\r\n" ) ;
                                                //{
                                                //case ifcIDtYPEdNSqUERY_MX :
                                                }
                                                    break ;

                                                    }
                                                        }
                                                            rec_A_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut ) ;
                                                            //etThread.traceF( tin0P , T("found a matching A record! [nnOut,domain,peer]:    ")+T(nnOut)+tb4+tDomainNet+tb4+tDomainPeer ) ;
                                                        {
                                                        else
                                                        }
                                                            //etThread.traceF( tin0P , T("!exception / matching A record, but setting bSilent because unlisted and unexpected peer [nnOut,domain,peer]:    ")+T(nnOut)+tb4+tDomainNet+tb4+tDomainPeer ) ;
                                                            bSilent = 1 ;
                                                        {
                                                        if( !bListedDomain )
                                                    {
                                                    if( !bSilent )

                                                    }
                                                        //etThread.traceF( tin0P , T("setting bSilent because no matching A record found [domain,peer]:    ")+tDomainNet+tb4+tDomainPeer ) ;
                                                        bSilent = 1 ;
                                                    {
                                                    else

                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tAllowVersion  ) ) nnOut = nnAllow ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tRefuseVersion ) ) nnOut = nnRefuse ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tSingularity   ) ) nnOut = nnSingularity ; //MIGHT BE 0.  THIS MEANS THAT A SINGULARITY IS NOT REGISTERED
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tNs5           ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tNs            ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tMail          ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tFtp           ) ) nnOut = nnRoot ;
                                                    //else if( ((tin1S&)tin0P).pEtScratch->strIdF(       tin0P , tHostOk , tDomainNet        ) ) { nnOut = nnRoot /*ANY NONZE VALUE WILL DO*/ ; } //U: ASSUME: I AM LIVING ON THE HOST THAT IS TO BE FIRED
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tFireOs        ) ) { nnOut = nnRoot ; bFireOs = 1 ; } //U: ASSUME: I AM LIVING ON THE HOST THAT IS TO BE FIRED
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWww           ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tRoot          ) ) nnOut = nnRoot ;
                                                    //}
                                                    //    ((tin1S&)tin0P).pEtScratch->delF( tin0P , psttDigits ) ;
                                                    //    //((tin1S&)tin0P).pEtScratch->ifcSayF( tin0P , T("idComputer=")+TF1(idComputer)+T(" nnOut=")+T(nnOut)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                                                    //    swNicName.ungrabF( tin0P ) ;
                                                    //    nnOut = *(nicNameC*)&(countT&)swNicName ;
                                                    //    idComputer = ((tin1S&)tin0P).pEtScratch->strDigitsToSCountF( tin0P , psttDigits ) ;
                                                    //    swNicName.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                    //    ((tin1S&)tin0P).pEtScratch->strWordF( tin0P , psttDigits , tDomainNet , sttq , S1C('.') ) ; ___( psttDigits ) ; ;
                                                    //    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                                    //    ZE( strokeS* , psttDigits ) ;
                                                    //{
                                                    //else if( ((tin1S&)tin0P).pEtScratch->strIdF( tin0P , tQueryHostSuffix , tDomainNet ) )
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tIfc5        ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tIfc1        ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tPort3Space  ) ) nnOut = nnRelayPortCraft ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tPort2Space  ) ) nnOut = nnRelayPortTest ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tPort1Space  ) ) nnOut = nnRelayPort ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tNn3Space    ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tNn2Space    ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tNn1Space    ) ) nnOut = nnRoot ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tGorilla1    ) ) nnOut = nnGorilla1 ;
                                                    //
                                                    //P:PERSONALITY: I MUST KNOW ONLY UNGUESSABLE RANDOM SECRET DOMAIN NAMES SO THAT A PEER THAT DOES NOT KNOW WO OF THEM DOESN'T GET A REPLY
                                                    //

                                                    //U:: COMMENT OUT ALL OF THE CODE THAT IS ONLY NEEDED FOR THE FOLLOWING COMMENTED OUT LINES

                                                    else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHook1    ) ) nnOut = nnWebHook1 ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                                         if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHooks    ) ) nnOut = nnWebHook1 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...

                                                    //}
                                                    //    //((tin1S&)tin0P).pEtScratch->ifcSayF( tin0P , T("looked up teacher's nicNameC value: ")+T("idComputer=")+TF1(idComputer)+T(" nnOut=")+T(nnOut)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                                                    //    swNicName.ungrabF( tin0P ) ;
                                                    //    nnOut = *(nicNameC*)&(countT&)swNicName ;
                                                    //    idComputer = 0x4c3b8d9f  ; // SERIAL OF DRIVE ///c ON IFC12 (LAPTOP)
                                                    //    swNicName.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                    //{
                                                    //if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tTeacher ) )

                                                    //CONoUTrAW( T("A: \"")+tDomainNet+T("\"\r\n") ) ;

                                                    nicNameC nnOut ;
                                                    //CONoUTrAW( TF1(idClient)+T(" ")+T(nnPeer)+T(" ")+T(psttPeer)+T(": A: \"")+tDomainNet+T("\"\r\n") ) ;
                                                    //((tin1S&)tin0P).pEtScratch->strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T(psttPeer)+T(": A: \"")+tDomainNet+T("\"\r\n") ) ;
                                                    //((tin1S&)tin0P).pEtScratch->ifcSayF( tin0P , TF1(idClient)+T(" ")+T(nnPeer)+T(" ")+T(psttPeer)+T(": A: \"")+tDomainNet+T("\"\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                                                    TELL( "ifcIDtYPEdNSqUERY_A" ) ;
                                                    //CONoUTrAW( "A\r\n" ) ;
                                                {
                                                case ifcIDtYPEdNSqUERY_A :
                                                }
                                                    break ;
                                                {
                                                case ifcIDtYPEdNSqUERY_CAA :
                                                case ifcIDtYPEdNSqUERY_AAAA :
                                            {
                                            else if( idClass == 1 ) switch( idType )
                                            if( bSilent ) ;//etThread.traceF( tin0P , T("bSilent is set for an unknown reason") ) ;

                                            *ps >> idClass ;
                                            ZE( countT , idClass ) ;

                                            *ps >> idType ;
                                            ZE( countT , idType ) ;

                                            etThread.delF( tin0P , psttw ) ;
                                            TN( tDomainNet , psttw ) ;
                                            }
                                                //etThread.traceF( tin0P , T("[domainNet,peer]:      \"")+T(psttw)+T("\"    \"")+tDomainPeer+T("\"") ) ;

                                                etThread.strMakeF( tin0P , LF , psttw , tDomainNet ) ; ___( psttw ) ;
                                                TN( tDomainNet , "" ) ; tDomainNet = T(psttNet)+T(".hidden.ideafarm.com") ;

                                                etThread.delF( tin0P , psttw ) ;
                                                etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttw , 0 , 0 ) ;
                                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                countT idf = 1 ;
                                                ZE( strokeS* , psttNet ) ;
                                            {
                                            if( psttw )

                                            //etThread.traceF( tin0P , T("[domainGross,peer]:    \"")+tDomainGross+T("\"    \"")+tDomainPeer+T("\"") ) ;
                                            TN( tDomainGross , psttw ) ;
                                            if( psttw ) ((tin1S&)tin0P).pEtScratch->strConvertToLowerCaseF( tin0P , psttw ) ; ___( psttw ) ;
                                            *ps >> psttw ;
                                            ZE( strokeS* , psttw ) ;
                                            TELL( "preparing to respond to a single query" ) ;
                                        {
                                        if( ps )
                                        stsQueries >> ps ;
                                        ZE( soulC* , ps ) ;
                                        TELL( "handling a query" ) ;
                                    {
                                    while( stsQueries )
                                    TELL( "counting the remaining queries" ) ;
                                {
                                else
                                }
                                    bSilent = 1 ;
                                    //etThread.traceF( tin0P , T("setting bSilent because dnsParseF failed") ) ;
                                    POOPR ;
                                {
                                if( POOP )

                                }
                                    ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbNU ) ;
                                    ((tin1S&)tin0P).pEtScratch->dnsParseF( tin0P , pbNU , countTC() , stsQueries , stsRepliesNU , pbq , cbq ) ;
                                    ZE( byteT* , pbNU ) ;

                                    stsRepliesNU.purgeF( tin0P ) ;
                                    stsQueries.purgeF( tin0P ) ;
                                {
                                TELL( "parsing the queries" ) ;
                                //CONoUTrAW( "parsing the queries\r\n" ) ;

                                //((tin1S&)tin0P).pEtScratch->sockPsttHostF( tin0P , psttPeer , nnPeer ) ; ___( psttPeer ) ;
                                TELL( "transcribing the peer nicName" ) ;
                                ZE( strokeS* , psttPeer ) ;
                                //etThread.strokeF( tin0P , TF1(idClient)+tb+T(nnPeer)+tBar+T("parsing request")+te ) ;

                                ++ idClient ;
                            {
                            //else
                            //}
                            //    CONoUTrAW( "request refused (nnNopeRefuse1)\r\n" ) ;
                            //    idError = ifcIDeRRORdNS_QUERYrEFUSED ;
                            //{
                            //if( nnPeer == nnNopeRefuse1 )

                            ZE( boolT , bFireOs ) ;

                            countT idError = ifcIDeRRORdNS_AOK ;
                        {
                        if( pbq && cbq )

                        //b_pnnSilent.ungrabF( tin0P ) ;
                        //}
                        //    }
                        //        break ;
                        //        bSilent = 1 ;
                        //    {
                        //    if( nnPeer == pnnSilent[ off ] )
                        //{
                        //for( countT off = 0 ; off < cnnSilent ; off ++ )
                        //b_pnnSilent.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        ZE( boolT , bSilent ) ;

                        TELL( "preparing to handle a query packet" ) ;
                        //etRock.traceF( tin0P , tSayPrefix+T(nnPeer)+tb4+tDomainPeer ) ;
                    {

                    if( !bPeerListedOrStripe ) /*;*/etRock.traceF( tin0P , tSayPrefix+T(nnPeer)+tSayUnknownDomain+tb4+tDomainPeer ) ;

                    const boolT bPeerListedOrStripe = bStripeWebHookNotifier || bListedDomain || nnsStripe & nnPeer ;

                    }
                        ether.delF( tin0P , psttPeer ) ;
                        }
                            bListedDomain |= idHit2 && idHit2 == 1 + psttPeer->idAdam - tListedDomain2.csF( tin0P ) ;
                            countT idHit2  = etThread.strIdF( tin0P , tListedDomain2 , psttPeer , 1 ) ;

                            bListedDomain  = idHit1 && idHit1 == 1 + psttPeer->idAdam - tListedDomain1.csF( tin0P ) ;
                            countT idHit1  = etThread.strIdF( tin0P , tListedDomain1 , psttPeer , 1 ) ;

                            //etThread.traceF( tin0P , T("[tPeer]:    ")+T(psttPeer) ) ;
                            tDomainPeer = T(psttPeer) ;
                        {
                        else
                        if( !psttPeer ) ether.traceF( tin0P , T("!exception / reverse DNS lookup failed") ) ;
                        ether.sockPsttHostF( tin0P , psttPeer , nnPeer ) ; ___( psttPeer ) ;
                        ZE( strokeS* , psttPeer ) ;
                    {
                    if( !bStripeWebHookNotifier )
                    ZE( boolT , bListedDomain ) ;
                    TN( tDomainPeer , "" ) ;

                    }
                        }
                            break ;
                            bStripeWebHookNotifier = 1 ;
                        {
                        if( nnPeer == *pnnAllowed[ offn ] )
                    {
                    for( countT offn = 0 ; offn < sizeof pnnAllowed / sizeof pnnAllowed[ 0 ] ; offn ++ )
                    ZE( boolT , bStripeWebHookNotifier ) ;

                    TELL( "waited for a query datagram" ) ;
                    sockd.readF( tin0P , pbq , cbq , idp , nnPeer ) ; ___( pbq ) ;
                    TELL( "waiting for a query datagram" ) ;
                    nicNameC nnPeer ;
                    ZE( countT , idp ) ;
                    ZE( countT , cbq ) ;
                    ZE( byteT* , pbq ) ;
                {
                while( !POOP && !ether && !etThread && !*((tin1S&)tin0P).pEtScratch )
                TN( tSaySilentlyIgnoring , "    !exception / silently ignoring    " ) ;
                TN( tSayUnknownDomain , "    !exception / unknown peer domain" ) ;
                TN( tSayPrefix  , "[nnPeer]:    " ) ;
                etherC& etRock = etherC::etRockIF( tin0P ) ;

                //nicNameC nnRoot2 = etThread.sockNicNameF( tin0P , T("69.0.244.16") ) ;

                //nicNameC nnAllow(  0x00ff00ff ) ;
                //nicNameC nnRefuse( 0xff00ff00 ) ;
                //if( etThread.diskIdF( tin0P , T("///c") ) != 0x2c1f032d ) nnRoot  = etThread.sockNicNameF( tin0P , T("69.0.243.16") ) ;
                //nicNameC nnRoot( NICnAMElOCAL ) ;    // 127.1.1.1 //U:
                //nicNameC nnRoot( 0x40ef0525 ) ;    // ifc5: 64.239.5.37
                //nicNameC nnRoot( 0xd8a2a931 ) ;    // ifc4: 216.162.169.49
                //nicNameC nnRoot( 0x0a010102 ) ;    // 10.1.1.2 //U:

                nicNameC nnWebHook1       = etThread.sockNicNameF( tin0P , tIpWebHook1 ) ;

                //nicNameC nnRelayPortCraft = nicNameC( ifcIDpORT_RELAYcRAFT ) ;
                //nicNameC nnRelayPortTest  = nicNameC( ifcIDpORT_RELAYtEST ) ;
                //nicNameC nnRelayPort      = nicNameC( ifcIDpORT_RELAY ) ;
                //nicNameC nnRoot           = nnThisHost ;
                //nicNameC nnThisHost       = socketC::nicNameIF( tin0P , etThread ) ;
                //nicNameC nnThisHost     = etThread.sockNicNameF( tin0P ) ;

                //TN( tPort3Space      , "port.3.space.ideafarm.com" ) ;
                //TN( tPort2Space      , "port.2.space.ideafarm.com" ) ;
                //TN( tPort1Space      , "port.1.space.ideafarm.com" ) ;
                //TN( tNn3Space        , "nicname.3.space.ideafarm.com" ) ;
                //TN( tNn2Space        , "nicname.2.space.ideafarm.com" ) ;
                //TN( tNn1Space        , "nicname.1.space.ideafarm.com" ) ;
                //TN( tAllowVersion    , "2.version.ipdos.ideafarm.com" ) ;
                //TN( tRefuseVersion   , "1.version.ipdos.ideafarm.com" ) ;
                //TN( tQueryHostSuffix ,        ".host.ideafarm.com" ) ;
                //TN( tTeacher         , "teacher.host.ideafarm.com" ) ;
                //TN( tIfc5            ,    "ifc5.host.ideafarm.com" ) ;
                //TN( tIfc1            ,    "ifc1.host.ideafarm.com" ) ;
                //TN( te     , "\r\n" ) ;
                TN( tb4    , "    " ) ;
                //TN( tb     , " " ) ;
                //TN( tBar   , "| " ) ;
                //TN( tLog   , "///d/ideafarm.log.port.53.dns" ) ;
                //TN( tNs5   ,    "ns5.ideafarm.com" ) ;
                //TN( tNs4   ,    "ns4.ideafarm.com" ) ;
                //TN( tNs3   ,    "ns3.ideafarm.com" ) ;
                //TN( tNs2   ,    "ns2.ideafarm.com" ) ;
                //TN( tNs1   ,    "ns1.ideafarm.com" ) ;
                //TN( tNs    ,     "ns.ideafarm.com" ) ;
                //TN( tSingularity , "singularity.ideafarm.com" ) ;
                //TN( tFtp   ,     "ftp.ideafarm.com" ) ;
                //TN( tHostOk , ".!hostxk.ideafarm.com" ) ;
                //TN( tFireOs ,  "!fire.ideafarm.com" ) ;
                //TN( tWww   ,     "www.ideafarm.com" ) ;
                //TN( tMail  ,    "mail.ideafarm.com" ) ;
                //TN( tTest  ,    "test.ideafarm.com" ) ;
                //TN( tGorilla1 , "go1.hidden.ideafarm.com" ) ;
                TN( tWebHook1 , "" ) ; tWebHook1 = tDomainLeafWebHook1Net+T(".hidden.ideafarm.com") ;
                TN( tWebHooks , "" ) ; tWebHooks = tDomainLeafWebHooksNet+T(".hidden.ideafarm.com") ;
                //TN( tEmail ,    ifcEMAIL_DNS ) ;
                //TN( tRoot  ,    "ideafarm.com" ) ;

                sockd.bindF( tin0P , ifcPORToLD2_DNS ) ;
                socketC sockd( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
                TELL( "preparing to catch query datagrams" ) ;
                stsReplies.purgeF( tin0P ) ;
                stsQueries.purgeF( tin0P ) ;
                *((tin1S&)tin0P).pEtScratch = 0 ;
            {
            while( !POOP && !ether && !etThread )
            stackC stsQueries(   tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            stackC stsReplies(   tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            stackC stsRepliesNU( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            ZE( countT , idClient ) ;

            //ether.loafIF( tin0P ) ; //U::DISABLE ME UNTIL I AM ENHANCED TO IGNORE OBVIOUS DDOS CLIENTS THAT PEG MY CPU

            //etThread.osThreadF( tin0P , countTC() , tmLoadSilentF , &sgnDone_tmLoadSilent , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&b_pnnSilent , (countT)&pnnSilent , (countT)&cnnSilent ) ;
            //signC sgnDone_tmLoadSilent( tin0P , TAG( TAGiDnULL ) ) ;

            const nicNameC nnNopeRefuse1 = etThread.sockNicNameF( tin0P , T("1.2.3.4") ) ; // example.reply.with.refusal
            ZE( countT    , cnnSilent ) ;
            ZE( nicNameC* , pnnSilent ) ;
            batonC b_pnnSilent( tin0P , TAG( TAGiDnULL ) ) ;
            //PSEUDODUPLICATE CODE: 1030168 2540104

            SCOOPS
        {
        IFsCRATCHoK

        //CONoUTrAW( "main/4\r\n" ) ; //U::
        count4S  c4p( (countT)&nnSingularity , (countT)&bParams , (countT)&idComputer , (countT)&swNicName ) ;
        switchC swNicName( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idComputer , 0 , sizeof( nicNameC ) ) ;
        ZE( countT , idComputer ) ;
        batonC bParams( tin0P , TAG( TAGiDnULL ) ) ;
        nicNameC nnSingularity ;

        TN( tListedDomain2 , (strokeS*)tDomainRootAllowed2 ) ;
        TN( tListedDomain1 , (strokeS*)tDomainRootAllowed1 ) ;

        } ;
            &nnAllowedStripe_22
            &nnAllowedStripe_21 ,
            &nnAllowedStripe_20 ,
            &nnAllowedStripe_1f ,
            &nnAllowedStripe_1e ,
            &nnAllowedStripe_1d ,
            &nnAllowedStripe_1c ,
            &nnAllowedStripe_1b ,
            &nnAllowedStripe_1a ,
            &nnAllowedStripe_19 ,
            &nnAllowedStripe_18 ,
            &nnAllowedStripe_17 ,
            &nnAllowedStripe_16 ,
            &nnAllowedStripe_15 ,
            &nnAllowedStripe_14 ,
            &nnAllowedStripe_13 ,
            &nnAllowedStripe_12 ,
            &nnAllowedStripe_11 ,
            &nnAllowedStripe_10 ,
            &nnAllowedStripe_0f ,
            &nnAllowedStripe_0e ,
            &nnAllowedStripe_0d ,
            &nnAllowedStripe_0c ,
            &nnAllowedStripe_0b ,
            &nnAllowedStripe_0a ,
            &nnAllowedStripe_09 ,
            &nnAllowedStripe_08 ,
            &nnAllowedStripe_07 ,
            &nnAllowedStripe_06 ,
            &nnAllowedStripe_05 ,
            &nnAllowedStripe_04 ,
            &nnAllowedStripe_03 ,
            &nnAllowedStripe_02 ,
            &nnAllowedStripe_01 ,
        {
        nicNameC* pnnAllowed[] =

        nicNameC nnAllowedStripe_22 = etThread.sockNicNameF( tin0P , T("44.242.180.165") ) ;
        nicNameC nnAllowedStripe_21 = etThread.sockNicNameF( tin0P , T("44.242.180.123") ) ;
        nicNameC nnAllowedStripe_20 = etThread.sockNicNameF( tin0P , T("44.242.179.63") ) ;
        nicNameC nnAllowedStripe_1f = etThread.sockNicNameF( tin0P , T("44.242.179.48") ) ;
        nicNameC nnAllowedStripe_1e = etThread.sockNicNameF( tin0P , T("44.242.179.102") ) ;
        nicNameC nnAllowedStripe_1d = etThread.sockNicNameF( tin0P , T("44.242.177.38") ) ;
        nicNameC nnAllowedStripe_1c = etThread.sockNicNameF( tin0P , T("35.80.48.209") ) ;
        nicNameC nnAllowedStripe_1b = etThread.sockNicNameF( tin0P , T("34.223.47.204") ) ;
        nicNameC nnAllowedStripe_1a = etThread.sockNicNameF( tin0P , T("34.223.46.51") ) ;
        nicNameC nnAllowedStripe_19 = etThread.sockNicNameF( tin0P , T("34.223.46.110") ) ;
        nicNameC nnAllowedStripe_18 = etThread.sockNicNameF( tin0P , T("34.223.112.29") ) ;
        nicNameC nnAllowedStripe_17 = etThread.sockNicNameF( tin0P , T("34.218.119.120") ) ;
        nicNameC nnAllowedStripe_16 = etThread.sockNicNameF( tin0P , T("34.216.226.194") ) ;
        nicNameC nnAllowedStripe_15 = etThread.sockNicNameF( tin0P , T("3.19.147.71") ) ;
        nicNameC nnAllowedStripe_14 = etThread.sockNicNameF( tin0P , T("3.19.147.64") ) ;
        nicNameC nnAllowedStripe_13 = etThread.sockNicNameF( tin0P , T("3.19.147.5") ) ;
        nicNameC nnAllowedStripe_12 = etThread.sockNicNameF( tin0P , T("3.19.147.31") ) ;
        nicNameC nnAllowedStripe_11 = etThread.sockNicNameF( tin0P , T("3.19.147.210") ) ;
        nicNameC nnAllowedStripe_10 = etThread.sockNicNameF( tin0P , T("3.19.147.166") ) ;
        nicNameC nnAllowedStripe_0f = etThread.sockNicNameF( tin0P , T("3.19.147.152") ) ;
        nicNameC nnAllowedStripe_0e = etThread.sockNicNameF( tin0P , T("3.18.132.41") ) ;
        nicNameC nnAllowedStripe_0d = etThread.sockNicNameF( tin0P , T("3.18.132.37") ) ;
        nicNameC nnAllowedStripe_0c = etThread.sockNicNameF( tin0P , T("3.18.132.35") ) ;
        nicNameC nnAllowedStripe_0b = etThread.sockNicNameF( tin0P , T("3.18.132.27") ) ;
        nicNameC nnAllowedStripe_0a = etThread.sockNicNameF( tin0P , T("3.142.4.130") ) ;
        nicNameC nnAllowedStripe_09 = etThread.sockNicNameF( tin0P , T("3.141.252.139") ) ;
        nicNameC nnAllowedStripe_08 = etThread.sockNicNameF( tin0P , T("3.140.136.146") ) ;
        nicNameC nnAllowedStripe_07 = etThread.sockNicNameF( tin0P , T("3.139.136.242") ) ;
        nicNameC nnAllowedStripe_06 = etThread.sockNicNameF( tin0P , T("3.139.136.145") ) ;
        nicNameC nnAllowedStripe_05 = etThread.sockNicNameF( tin0P , T("18.217.41.98") ) ;
        nicNameC nnAllowedStripe_04 = etThread.sockNicNameF( tin0P , T("18.217.41.68") ) ;
        nicNameC nnAllowedStripe_03 = etThread.sockNicNameF( tin0P , T("18.217.41.199") ) ;
        nicNameC nnAllowedStripe_02 = etThread.sockNicNameF( tin0P , T("18.188.9.89") ) ;
        nicNameC nnAllowedStripe_01 = etThread.sockNicNameF( tin0P , T("18.188.9.80") ) ;
        //20250225@1730: THESE VALUES WERE OBTAINED BY SETTING STRIPE TO USE AN EASILY RECOGNIZED INVALID URI LIKE piddle.hidden.ideafarm.com, TELLING STRIPE TO RESEND AN EVENT NOTICE, AND THEN OBSERVING ALL OF THE QUERIES THAT HIT THE HIDDEN DNS SERVER (ME)

        //nicNameC nnReserved2     = etThread.sockNicNameF( tin0P , T("10.0.3.1") ) ;
        //nicNameC nnReserved1     = etThread.sockNicNameF( tin0P , T("64.176.222.148") ) ;

        //nicNameC nnLaptopSil1PhoneHotspot6 = etThread.sockNicNameF( tin0P , T("2600:387:15:5012::4") ) ;
        //nicNameC nnLaptopSil1PhoneHotspot4 = etThread.sockNicNameF( tin0P , T("72.159.157.28") ) ;
        //nicNameC nnLaptopSil1OfficeHotspot = etThread.sockNicNameF( tin0P , T("50.216.215.70") ) ;
        //nicNameC nnLaptopSil1OfficeWired   = etThread.sockNicNameF( tin0P , T("50.216.215.70") ) ;

        nicNamesAllowedStripeWebHookNotificationsC nnsStripe( tin0P , etThread , ether , TICK << 4 ) ;  //IT'S BEEN YEARS SINCE THESE HAVE CHANGED

        //CONoUTrAW( "main/5\r\n" ) ; //U::
        TELL( "preparing for work" ) ;
    {
    else
    }
        etThread.traceF( tin0P , T("a required setting is missing") ) ;
    {
    )
        !tDomainRootAllowed2.csF( tin0P )
        ||
        !tDomainRootAllowed1.csF( tin0P )
        ||
        !tIpWebHook1.csF( tin0P )
        ||
        !tDomainLeafWebHook1Net.csF( tin0P )
        ||
        !tDomainLeafWebHooksNet.csF( tin0P )
        ||
        !tIpWebHook1.csF( tin0P )
    (
    if

    //etThread.traceF( tin0P , T("settings [tIpWebHook1,tDomainLeafWebHooksNet,tDomainLeafWebHook1Net,tDomainRootAllowed1,tDomainRootAllowed2]:    \"")+tIpWebHook1+T("\"    \"")+tDomainLeafWebHooksNet+T("\"    \"")+tDomainLeafWebHook1Net+T("\"    \"")+tDomainRootAllowed1+T("\"    \"")+tDomainRootAllowed2+T("\"") ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed2 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.2")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed2 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed1 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.1")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed1 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tIpWebHook1 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1")  ) ; ___( psttEat ) ;
    {
    TN( tIpWebHook1 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        }
            etThread.delF( tin0P , psttNet ) ;
            tDomainLeafWebHook1Net = T(psttNet) ;
            etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.wh1")  ) ; ___( psttEat ) ;
    {
    TN( tDomainLeafWebHook1Net , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        }
            etThread.delF( tin0P , psttNet ) ;
            tDomainLeafWebHooksNet = T(psttNet) ;
            etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.webhooks")  ) ; ___( psttEat ) ;
    {
    TN( tDomainLeafWebHooksNet , "" ) ;

    TN( tDash , "-" ) ;

    _IO_
{
if( pTaskP )
TASK( tmWorkF )

#endif

DONE( tmLoadSilentF )
}
    b_pnnSilent.ungrabF( tin0P ) ;
    cnnSilent = 0 ;
    etThread.delF( tin0P , pnnSilent ) ;
    b_pnnSilent.grabF( tin0P , TAG( TAGiDnULL ) ) ;

    }
        ether.osSleepF( tin0P , TOCK * 0x10 ) ;

        etThread.delF( tin0P , psttAll ) ;
        }
            etThread.delF( tin0P , pstt1Lines ) ;
            b_pnnSilent.ungrabF( tin0P ) ;
            }
                etThread.delF( tin0P , psttnn ) ;
                etThread.strokeF( tin0P , T("i will silently ignore: ")+T(pnnSilent[off-1])+T(" (\"")+T(psttnn)+T("\")\r\n") ) ;
                pnnSilent[ off ++ ] = etThread.strDigitsToNicNameF( tin0P , psttnn ) ;
                etThread.strWordF( tin0P , psttnn , psttc1 , sttq , S1C(';') ) ; ___( psttnn ) ;
                ZE( strokeS* , psttnn ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            {
            FORsTRINGSiN1( pstt1Lines )
            ZE( countT , off ) ;
            etThread.newF( tin0P , LF , pnnSilent , cnnSilent ) ; ___( pnnSilent ) ;
            cnnSilent = etThread.strWordsOldF( tin0P , pstt1Lines , psttAll , sttq , T("\r\n") ) ; ___( pstt1Lines ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1Lines ) ;

            cnnSilent = 0 ;
            etThread.delF( tin0P , pnnSilent ) ;

            b_pnnSilent.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        {
        if( psttAll )
        bFile.ungrabF( tin0P ) ;
        etThread.boxGetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF( tin0P , psttAll , T("///d/ideafarm.")+TF1(etherC::ifc_idHomeI_IF())+T(".setting.keyValue.nnSilent") ) ; ___( psttAll ) ;
        bFile.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        batonC bFile( tin0P , TAG( TAGiDnULL ) , T("setting.keyValue.nnSilent") ) ;
        ZE( strokeS* , psttAll ) ;
    {
    while( !etThread && !ether )

    countT&    cnnSilent   =    *(countT*)pTaskP->c3 ;
    nicNameC*& pnnSilent   = *(nicNameC**)pTaskP->c2 ;
    batonC&    b_pnnSilent =    *(batonC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmLoadSilentF )
//DUPLICATED CODE: 1030168 2540104

#if defined( NEVERdEFINED )

}
    }
        stsRepliesP << ps ;

        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // cSerial
        *ps << (countT)0 ; // cSerial
        *ps << psttEmailP ;
        *ps << psttNsP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_SOA ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_SOA_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttNsP , const strokeS* const psttEmailP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_NS ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_NS_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;
        *ps << (countT)0 ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_MX ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_MX_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_A ;
        *ps << psttP ;

        //etherP.traceF( tin0P , T("rec_A_F [nn,name]:    ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_A_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )


//  
// U:: USE A "SHIELDS DOWN" MECHANISM SO THAT THIS CAN BE SUPPRESSED DURING ACME CERTIFICATE RENEWAL AND OTHERWISE ENABLED
// U: (FUTURE): I ALSO VALIDATE REQUESTS BY DOING A REVERSE DNS LOOKUP AND IGNORING REQUESTS IF THE DOMAIN IS UNEXPECTED
//  
//  THIS IS BOTH TO MITIGATE FLOOD ATTACKS AND TO CONCEAL THAT I AM A DNS NAME SERVER FROM PEERS WHO HAVE MY IP ADDRESS (E.G. FROM SCANNING THE IPv4 SPACE) BUT DO NOT KNOW (FROM A HIGHER LEVEL NAMESERVER) THAT I AM A NAMESERVER
// IF THE LEAF IS UNKNOWN TO ME, I SILENTLY IGNORE THE REQUEST
//  
//P:PERSONALITY: I KEEP IP ADDRESSES CONFIDENTIAL, PRIMARILY BY TREATING THE REQUESTED DOMAIN NAME LEAF AS A PASSWORD

// OBSOLETES 614_ (LIKE 614_ BUT USES WHITELIST NOT BLACKLIST)

/*1*/WAKEhIDE( "ifcIDaDAM_DNS" )/*1*/

/**/
*/
 i simply map names (many to 1 and 1 to many) into ip addresses and tell the client to not cache
i do not use the canonical name concept
 initially, this was a copy of 254 for which ifcChat was eliminated since ifcChat is obsoleted by relayOldC
 2010.12.23: brought back into service for development on laptop after not being used for many years
obsoletes 254
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

