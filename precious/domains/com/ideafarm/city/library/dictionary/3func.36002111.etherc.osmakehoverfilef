
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //traceF( tin0P , T("-") ) ;
    //traceF( tin0P , T("osMakeHoverFileF /-") ) ;

    }
        //traceF( tin0P , T("0") ) ;

        delF( tin0P , pbm ) ;
        //traceF( tin0P , T("1") ) ;

        }
            }
                THREADmODE2rESTORE
                //traceF( tin0P , T("2") ) ;
                //traceF( tin0P , T("osMakeHoverFileF / wrote master file") ) ;
                boxPutF( tin0P , tMaster , pbm , cbm ) ;
                //traceF( tin0P , T("3") ) ;
                //traceF( tin0P , T("osMakeHoverFileF / writing master file") ) ;
                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
            {
            if( bModified )
            //traceF( tin0P , T("4") ) ;

            DEL( pInfo ) ;
            //traceF( tin0P , T("5") ) ;
            }
                }
                    THREADmODE2rESTORE
                    //traceF( tin0P , T("osMakeHoverFileF / wrote hover file") ) ;
                    //traceF( tin0P , T("6") ) ;
                    //traceF( tin0P , T("osMakeHoverFileF / put     hover file [name]:    ")+tName ) ;
                    }
                        boxPutF( tin0P , tFile , pbm , cbm ) ;
                    {
                    //20240813@2139: SUPPRESS THIS TEST: if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_DEBUG ) )  //U:: "if(...)" TO FIND A BUG (STUDY WHY SOMETIMES BUILDING HOVERFILE OF MASTER DLL TAKES SO LONG)
                    //traceF( tin0P , T("osMakeHoverFileF / putting hover file [name]:    ")+tName ) ;
                    TN( tFile , "" ) ; tFile = T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/")+tName ;
                    //traceF( tin0P , T("7") ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                    //traceF( tin0P , T("osMakeHoverFileF / writing hover file") ) ;

                    #endif
                    //U::

                    //traceF( tin0P , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall5 ;
                            *pbc = 'c' ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tin0P , pbc , cbm - ( pbc - pbm ) , pbSmall5 , sizeof pbSmall5 ) ;
                        //CONoUTrAW3( "\r        \r    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    //traceF( tin0P , T("") ) ;
                    //traceF( tin0P , T("osMakeHoverFileF / patching copy / 0") ) ;
                    
                    //traceF( tin0P , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall4 ;
                            *pbc = 'C' ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tin0P , pbc , cbm - ( pbc - pbm ) , pbSmall4 , sizeof pbSmall4 ) ;
                        //CONoUTrAW3( "\r        \r    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    //traceF( tin0P , T("") ) ;
                    //traceF( tin0P , T("osMakeHoverFileF / patching copy / 1") ) ;
                    
                    //traceF( tin0P , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall3 ;
                            *pbc = 0 ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tin0P , pbc , cbm - ( pbc - pbm ) , pbSmall3 , sizeof pbSmall3 ) ;
                        //CONoUTrAW3( "\r        \r    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    //traceF( tin0P , T("") ) ;
                    //traceF( tin0P , T("osMakeHoverFileF / patching copy / 2") ) ;
                    
                    //traceF( tin0P , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall2 ;
                            *pbc = 0 ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tin0P , pbc , cbm - ( pbc - pbm ) , pbSmall2 , sizeof pbSmall2 ) ;
                        //CONoUTrAW3( "\r        \r    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    //traceF( tin0P , T("") ) ;
                    //traceF( tin0P , T("osMakeHoverFileF / patching copy / 3") ) ;
                    
                    #if defined( NEVERdEFINED )
                    //U::
                    
                    //traceF( tin0P , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall8 ;
                            *pbc = (byteT)0 ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tin0P , pbc , cbm - ( pbc - pbm ) , pbSmall8 , sizeof pbSmall8 ) ;
                        //CONoUTrAW3( "\r        \r0    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    //traceF( tin0P , T("8") ) ;
                    //traceF( tin0P , T("osMakeHoverFileF / patching copy / 4") ) ;
                    
                    //traceF( tin0P , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall7 ;
                            *pbc = (byteT)0 ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tin0P , pbc , cbm - ( pbc - pbm ) , pbSmall7 , sizeof pbSmall7 ) ;
                        //CONoUTrAW3( "\r        \r1    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    //traceF( tin0P , T("9") ) ;
                    //traceF( tin0P , T("osMakeHoverFileF / patching copy / 5") ) ;
                    
                    //traceF( tin0P , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall6 ;
                            thirdC::c_memcpyIF( tin0P , pbc + 0xe , tName , tName.csF( tin0P ) ) ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tin0P , pbc , cbm - ( pbc - pbm ) , pbSmall6 , sizeof pbSmall6 ) ;
                        //CONoUTrAW3( "\r        \r2    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    pbc = pbm ;
                    //traceF( tin0P , T("a") ) ;
                    //traceF( tin0P , T("osMakeHoverFileF / patching copy / 6") ) ;
                    
                    //traceF( tin0P , T("\r\n") ) ;
                    }
                        }
                            pbc += sizeof pbSmall1 ;
                            thirdC::c_memsetIF( tin0P , pbc + 1 , sizeof pbSmall1 - 2 , FILLbYTE_HOVERfILEsMUDGE ) ;
                        {
                        if( pbc < pbe )
                        pbc = thirdC::c_memmemIF( tin0P , pbc , cbm - ( pbc - pbm ) , pbSmall1 , sizeof pbSmall1 ) ;
                        //CONoUTrAW3( "\r             \r3    " , pbe - pbc , "\r") ) ;
                    {
                    while( pbc < pbe )
                    //traceF( tin0P , T("\r\n") ) ;
                    byteT* pbc = pbm ;
                    //traceF( tin0P , T("b") ) ;
                    //traceF( tin0P , T("osMakeHoverFileF / patching copy / 7") ) ;
                    
                    byteT* const pbe = pbm + cbm ;
                    
                    *pbSmall8 = 'T' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall7 = 'T' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    pbSmall6[ 0x17 ] = '8' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall5 = 'd' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall4 = 'D' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall3 = *pbSmall2 = 'T' ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    *pbSmall1 = 0 ; //SO THAT MY OWN CODE DOES NOT GET SMUDGED
                    
                    byteT pbSmall8[] = ".he program encountered a problem at address %08lx and cannot continue" ;
                    byteT pbSmall7[] = ".he instruction at %08lx referenced memory at %08lx\x0aThe memory could not be %s" ;
                    byteT pbSmall6[] = "!postBaseName:ideafarm..1000001.ipdos-wm" ;
                    byteT pbSmall5[] = ".:\\ideafarm.work\\backed.up.never\\gen\\" ;
                    byteT pbSmall4[] = ".:\\ideafarm.work\\backed.up.never\\gen\\" ;
                    byteT pbSmall3[] = { 't' , 'h' , 'e' , ' ' , 'p' , 'r' , 'o' , 'g' , 'r' , 'a' , 'm' , ' ' , 'e' , 'n' , 'c' , 'o' , 'u' , 'n' , 't' , 'e' , 'r' , 'e' , 'd' , ' ' , 'a' , ' ' , 'p' , 'r' , 'o' , 'b' , 'l' , 'e' , 'm' , ' ' , 'a' , 't' , ' ' , 'a' , 'd' , 'd' , 'r' , 'e' , 's' , 's' , ' ' , '%' , '0' , '8' , 'l' , 'x' , ' ' , 'a' , 'n' , 'd' , ' ' , 'c' , 'a' , 'n' , 'n' , 'o' , 't' , ' ' , 'c' , 'o' , 'n' , 't' , 'i' , 'n' , 'u' , 'e' } ;
                    byteT pbSmall2[] = { 't' , 'h' , 'e' , ' ' , 'i' , 'n' , 's' , 't' , 'r' , 'u' , 'c' , 't' , 'i' , 'o' , 'n' , ' ' , 'a' , 't' , ' ' , '%' , '0' , '8' , 'l' , 'x' , ' ' , 'r' , 'e' , 'f' , 'e' , 'r' , 'e' , 'n' , 'c' , 'e' , 'd' , ' ' , 'm' , 'e' , 'm' , 'o' , 'r' , 'y' , ' ' , 'a' , 't' , ' ' , '%' , '0' , '8' , 'l' , 'x' } ;
                    //byteT pbSmall1[] = { 0 , 'M' , 'e' , 's' , 's' , 'a' , 'g' , 'e' , 'B' , 'o' , 'x' , 'E' , 'x' , 'A' , 0 , 'A' , 'p' , 'p' , 'l' , 'i' , 'c' , 'a' , 't' , 'i' , 'o' , 'n' , ' ' , 'E' , 'r' , 'r' , 'o' , 'r' , ':' , ' ' , 0 } ;
                    byteT pbSmall1[] = { 'x' , 'M' , 'e' , 's' , 's' , 'a' , 'g' , 'e' , 'B' , 'o' , 'x' , 'E' , 'x' , 'A' , 0 } ;
                    //traceF( tin0P , T("c") ) ;

                    //THIS REALLY ONLY NEEDS TO BE DONE FOR 0100002 0100003 (THE HOVER EXE FILES)
                    //SMUDGE "\x00MessageBoxExA\x00Application Error:\x00" TO PREVENT WATCOM'S CODE FROM EMITTING A POPUP WHEN AN EXCEPTION OCCURS
                    //IT ALSO PREDATES THE EXCEPTION HANDLING CODE WITHIN IPDOS (tm), WHICH MIGHT RENDER THE SMUDGING UNNECESSARY
                    //THIS SMUDGING OF MessageBoxExA DATES BACK TO THE MID 1990'S SO MIGHT NOT BE NEEDED ANY LONGER

                    if( pInfo->postImageName ) memCopyF( tin0P , pInfo->postImageName , tName , tName.csF( tin0P ) ) ; //U::WHY IS THIS 0 STARTING TODAY? 2002.12.26
                    tName = T("ideafarm.")+TF3(idCopy,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) + ( pInfo->bDll?T(".ipdos-wd") : T(".ipdos-we") ) ;
                    TN( tName , "" ) ;
                    //traceF( tin0P , T("osMakeHoverFileF / patching copy / 8") ) ;
                {
                if( idCopy )
                //traceF( tin0P , T("e") ) ;

                }
                    //traceF( tin0P , T("f") ) ;
                    delF( tin0P , pstt1w ) ;
                    //traceF( tin0P , T("g") ) ;
                    }
                        else if( !strCompareF( tin0P , psttc2 , tTag ) ) bNext = 1 ;
                        }
                            break ;
                            idCopy = strDigitsToSCountF( tin0P , psttc2 ) ;
                        {
                        if( bNext )
                    {
                    FORsTRINGSiN2( pstt1w )
                    //traceF( tin0P , T("h") ) ;
                    TN( tTag , "!idCopy" ) ;
                    ZE( boolT , bNext ) ;
                    strWordsOldF( tin0P , pstt1w , T(pInfo->postDescription) , sttq ) ; ___( pstt1w ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , pstt1w ) ;
                    __( !pInfo->postDescription ) ;
                    //traceF( tin0P , T("i") ) ;
                {
                ZE( countT , idCopy ) ;
                //traceF( tin0P , T("j") ) ;
                //traceF( tin0P , T("osMakeHoverFileF / setting idCopy") ) ;

                }
                    }
                        }
                            }
                                bModified = 1 ;
                                thirdC::c_itoaIF( postPatch , 1 + incv02AM( *(countT*)pbi ) , '0' ) ; //U:: VERIFY THAT WILL DO UNSIGNED I.E. WILL WORK WHEN HIGH ORDER BIT IS USED
                            {
                            if( pbi && cbi == sizeof( countT ) )
                            fwsLath.getF( tin0P , pbi , cbi , sizeof( countT ) ) ;
                            ZE( countT , cbi ) ;
                            ZE( byteT* , pbi ) ;
                            fileWindowsC fwsLath( tin0P , *this , tName , flFILEwINDOW_WRITE ) ;
                            TN( tName , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/idCopyLath" ) ;
                        {
                        if( !thirdC::c_memcmpIF( tin0P , postPatch , "00000000000000000000000000000000" , sizeof( countT ) * 2 ) ) //A:ASSUME: sizeof( countT ) IS NOT GREATER THAN 01 BYTES
                        //traceF( tin0P , T("r") ) ;

                        postPatch += sizeof postTag ;
                        //traceF( tin0P , T("s") ) ;
                    {
                    if( postPatch )
                    byteT* postPatch = thirdC::c_strstrIF( tin0P , pInfo->postDescription , postTag ) ;
                    //traceF( tin0P , T("t") ) ;

                    osTextT postTag[] = "!idCopy" ;
                    //traceF( tin0P , T("u") ) ;
                {
                //traceF( tin0P , T("v") ) ;
                //traceF( tin0P , T("osMakeHoverFileF / inspecting !idCopy value in description") ) ;

                }
                    while( !POOP && ~handle ) ;
                    }
                        }
                            delF( tin0P , psttw ) ;
                            }
                                }
                                    }
                                        //traceF( tin0P , T("w") ) ;
                                        delF( tin0P , postDll ) ;
                                        memCopyF( tin0P , postMas , postDll , costDll ) ;
                                        delF( tin0P , psttw2 ) ;
                                        countT costDll = strMakeF( tin0P , LF , postDll , psttw2 ) ; ___( postDll ) ;
                                        ZE( osTextT* , postDll ) ;
                                        strMakeF( tin0P , LF , psttw2 , T("ideafarm.")+TF3(idCopy,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(".ipdos-wd") ) ; ___( psttw2 ) ;
                                        ZE( strokeS* , psttw2 ) ;
                                        //traceF( tin0P , T("x") ) ;
                                    {
                                    if( idCopy )
                                    countT idCopy = ifcIdCopyF( tin0P , cName ) ; //U::20210825@1715: NOT TESTED ; ADDED THIS LINE AS PART OF REMOVING USE OF masterOldC IN THIS DEFINITION

                                    //traceF( tin0P , T("y") ) ;
                                {
                                if( cName )
                                cName = strDigitsToSCountF( tin0P , psttw , 0 , 1 ) ;
                                //traceF( tin0P , T("z") ) ;
                            {
                            if( strIsDigitsF( tin0P , psttw ) )
                            strSubstringF( tin0P , psttw , idf , idl , tMas ) ; ___( psttw ) ;
                            ZE( strokeS* , psttw ) ;
                            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                            countT idl = 0x11 ;
                            countT idf = 0xa ;
                            //traceF( tin0P , T("A") ) ;
                        {
                        if( 0x12 == strIdF( tin0P , 0 , flSTRmATCH_null , idf , sttq , teMas , tMas ) )
                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                        countT idf = 1 ;
                        //traceF( tin0P , T("B") ) ;

                        TN( tMas , postMas ) ;
                        osTextT* postMas = (osTextT*)pInfo->pSt_postDllUsed->downF( tin0P , handle ) ;
                        //traceF( tin0P , T("C") ) ;
                        //traceF( tin0P , T("osMakeHoverFileF / looping to get dll names") ) ;
                    {
                    do
                    handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    TN( teMas , ".ipdos-wm" ) ;
                    //traceF( tin0P , T("D") ) ;
                {
                if( pInfo->pSt_postDllUsed && *pInfo->pSt_postDllUsed )
                //traceF( tin0P , T("E") ) ;
            {
            if( pInfo )
            //traceF( tin0P , T("F") ) ;
            //traceF( tin0P , T("osMakeHoverFileF / got     image information") ) ;
            third.imageExeDllF( tin0P , pInfo , pbm ) ; ___( pInfo ) ;
            //traceF( tin0P , T("osMakeHoverFileF / getting image information") ) ;
            //traceF( tin0P , T("G") ) ;
            ZE( imageExeDllC* , pInfo ) ;
            ZE( boolT , bModified ) ;
        {
        if( !POOP )

        THREADmODE2rESTORE
        //traceF( tin0P , T("H") ) ;
        //traceF( tin0P , T("osMakeHoverFileF / read    master into memory [cbm]: ")+TF2(cbm,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        }
            boxGetShadowF( tin0P , pbm , cbm , tMaster , 1 ) ; ___( pbm ) ;
        {
        //traceF( tin0P , tMaster ) ;
        //traceF( tin0P , T("osMakeHoverFileF / reading master into memory [tMaster]:") ) ;
        //traceF( tin0P , T("I") ) ;
        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        ZE( countT , cbm ) ;
        ZE( byteT* , pbm ) ;

        TN( tMaster , "" ) ; tMaster = T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/master/ideafarm.")+TF3(cNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(".ipdos-wm") ;
        //traceF( tin0P , T("K") ) ;

        //traceF( tin0P , T("Q") ) ;
        //traceF( tin0P , T("R") ) ;
        //traceF( tin0P , T("S") ) ;
        ZE( countT , cName ) ;

        //traceF( tin0P , T("T") ) ;
        //traceF( tin0P , T("U") ) ;
        //traceF( tin0P , T("V") ) ;
    {

    //traceF( tin0P , T("osMakeHoverFileF /+") ) ;

    _IO_

    }
        //traceF( tin0P , T("W") ) ;
        if( POOP ) return ;
        __NZ( bRawNameP ) ; //U:NOT YET SUPPORTED
        __Z( cNameP ) ;
        if( POOP ) return ;
        //traceF( tin0P , T("X") ) ;
    {
    IFbEcAREFUL
    SCOOP
    //traceF( tin0P , T("+") ) ;
{
/*1*/voidT etherC::osMakeHoverFileF( tin0S& tin0P , const countT cNameP , const boolT bRawNameP )/*1*/

/**/
*/
 U: the wo'st type is named using the raw master name and its use list refers to raw master names
 the ze'st type is named using the idCopy value and its use list refers to idCopy names
U:for the specified master file, makes a hover file of wo of oo types
\<A HREF=\"5.103014a.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$osMakeHoverFileF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

