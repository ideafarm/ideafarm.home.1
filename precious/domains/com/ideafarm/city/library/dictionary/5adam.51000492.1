
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.loafIF( tinBaseP ) ;

sayF( tinBaseP , etThread , stw , T("after") ) ;

stw << souw ;
stw.purgeF( tinBaseP ) ;
stw >> souw ;
soulC souw( tinBaseP , TAG( TAGiDnULL ) ) ;

sayF( tinBaseP , etThread , stw , T("before") ) ;

stw << psttOldC( tinBaseP , etThread , T("d") ) ;
stw << psttOldC( tinBaseP , etThread , T("c") ) ;
stw << psttOldC( tinBaseP , etThread , T("b") ) ;
stw << psttOldC( tinBaseP , etThread , T("a") ) ;
stackC stw( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;

etThread.delF( tinBaseP , psttd ) ;
etThread.strMakeF( tinBaseP , LF , psttd , pstt4 ) ; ___( psttd ) ;
ZE( strokeS* , psttd ) ;

pstt4[ CSpREFIX ] = 'a' ;
SETpREFIX( pstt4 , 1 , 0 )
strokeS pstt4[ CSpREFIX + 1 ] ;

TODO

}
    }
        while( !etThread && ~hDown ) ;
        }
            if( psttw ) etThread.strokeF( tinBaseP , tL+T(psttw)+tR ) ;
            strokeS* psttw = (strokeS*)stP.downF( tinBaseP , hDown ) ;
        {
        do
        handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stP )
    TN( tR , "\"\r\n" ) ;
    TN( tL , "" ) ; tL = T(psttP)+T(": \"") ;
{
voidT sayF( tinBaseS& tinBaseP , etherC& etThread , stackC& stP , const strokeS* const psttP )

/*1*/WAKEhIDE( "example.simplest.func.115005a.stackC.operator_shiftLeft" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

