
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            if( pbP ) indexF( tinBaseP ) ; //20131224@1950: ADDED WITHOUT ANALYSIS

            aptData = pbData ;

            if( pbP ) thirdC::c_memcpyIF( tinBaseP , pbc , pbP , cbv ) ;
            *(countT*)pbc = cbv ; pbc += sizeof( countT ) ;
            *(countT*)pbc = 0   ; pbc += sizeof( countT ) ;

            byteT* pbc = pbData ;
        {
        if( pbData )
        CONoUTrAW3( "New " , pbData , "\r\n" ) ; //U::TO FIND A  LEAK
        PUSE.newF( tinBaseP , LF , pbData , cba ) ; ___( pbData ) ;
        ZE( byteT* , pbData ) ;
        countT cba = 2 * sizeof( countT ) + cbv ; // cRef cb value
        countT cbv = cbP ? cbP : 1 + thirdC::c_strlenIF( tinBaseP , pbP ) ;
    {
    if( pbP || cbP )
    //CS:CODEsYNC: 360ea004 360ea002

    aptData.resetF() ;
    __( pbData ) ;
    PUSE( tinBaseP , pbData ) ;
    CONoUTrAW3( "Del " , pbData , "\r\n" ) ; //U::TO FIND A  LEAK
    byteT* pbData = (byteT*)aptData ;
    //CS:CODEsYNC: 360ea001 360ea004

    unIndexF( tinBaseP ) ; //20131224@1950: ADDED WITHOUT ANALYSIS
{
/*1*/voidT datum_blob_C::assignF( tinBaseS& tinBaseP , const byteT* const pbP , const countT cbP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

