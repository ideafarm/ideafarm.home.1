
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cCalled ;

    ((tin9S&)tin0P).pag5->frPaper.grab.ungrabF( tin0P ) ;

    etherP( tin0P , pstk_pSadam ) ;
    }
        }
            }
                }
                    cCalled ++ ;
                    bQuit = pSadam->doF( tin0P , etherP , idTypeP , idEvent , pcNotesP , phCloneP ) ; //bQuit RETURN VALUE IGNORED IN THIS REWRITE; CAN BE SUPPORTED IF EVER NEEDED
                {
                )
                    ( !pczIdIntercomP || ( pSadam->pStrike && features.fc.idIntercom && etherP.strIdF( tin0P , idf , features.fc.idIntercom , pczIdIntercomP ) ) )
                    &&
                    ( idTypeP == ifcIDtYPEsTROKEcALLbACK_DESTROY || pSadam->pStrike )
                    &&
                    )
                        )
                            )
                                &pSadam->pStrike->sc.pPaper->x1.pPulp->x1.back == pPaperBackP
                                ||
                                pSadam->pStrike->sc.pPaper == pPaperP
                            (
                            &&
                            pSadam->pStrike
                        (
                        ||
                        features.fc.pOwner == pOwnerP
                        ||
                        ( !pOwnerP && !pPaperP && !pPaperBackP )
                    (
                (
                if
                countT idf = 1 ;
            {
            if( !bQuit )

            featuresS& features = *(featuresS*)&(const featuresS&)*pSadam ;

            *pstk_pSadam >> *(countT*)&pSadam ;
            ZE( sadamC* , pSadam ) ;
        {
        while( *pstk_pSadam )
        ZE( boolT , bQuit ) ;
        const countT idEvent = 1 + incv02AM( ((tin9S&)tin0P).pag1->idEventSadamsLath ) ;
    {
    if( pstk_pSadam )
    sadamsC::pSadamsIF( tin0P )->getF( tin0P , pstk_pSadam , F(flagsP) & flCALLsADAMS_FIFO ? flGETsADAMsTATES_FIFO : flGETsADAMsTATES_null ) ;
    ZE( stackC* , pstk_pSadam ) ;

    ((tin9S&)tin0P).pag5->frPaper.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    ZE( boolT , cCalled ) ;

    _IO_

    }
        if( POOP ) return 0 ;
        __( pPaperP && pPaperBackP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/countT paperOldC::callSadamsIF( tin0S& tin0P , etherC& etherP , const countT idTypeP , const countT* const pcNotesP , const handleC* const phCloneP , const flagsT flagsP , const vTextC* const pOwnerP , const paperOldC* const pPaperP , const backOldC* const pPaperBackP , const countT* const pczIdIntercomP )/*1*/

/**/
*/
   only the sadams that have placed a listed idIntercom value into their scratchpad will be called
  if not 0 then must point to a null terminated list of application defined countT values
  can be 0
 pczIdIntercomP
 bFifoP
 pcNotesP
 idTypeP
 tin0P
arguments
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

