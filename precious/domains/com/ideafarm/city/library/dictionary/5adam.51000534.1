
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.cioSetGetF( tin0P ) ;
}
    //etThread.delF( tin0P , pcIn ) ;
    //}
    //    etThread.strokeF( tin0P , T("\r\n") ) ;
    //    }
    //        etThread.strokeF( tin0P , TF1(pcIn[off])+T(" ") ) ; //U::
    //    {
    //    for( countT off = 0 ; off < ccIn ; off ++ )
    //    etThread.strokeF( tin0P , T("d: ") ) ;
    //{
    //if( pcIn )
    //homeS::superRandomIF( tin0P , pcIn , ccIn , flHOMEsUPERrANDOM_DELETE ) ; ___( pcIn ) ;
    //countT ccIn = 4 ;
    //ZE( countT* , pcIn ) ;
    //FOR TESTING ONLY; MUST BE COMMENTED OUT IN PRODUCTION

    ++ s ; ether.osSleepF( tin0P , TOCK * 0x10 ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    }
        etThread( tin0P , psPayload ) ;
        }
            etThread.cioPutF( tin0P , ether , count8S( ifcOLDiDcHANNEL1_BYfUNCTION , ifcOLDiDcHANNELfUNCTION_SUPERrANDOMnUMBERS ) , *psPayload ) ;
            psPayload->shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_countTptr , pcru , sizeof pcru / sizeof pcru[ 0 ] ) ;

            //etThread.strokeF( tin0P , T("\r\n") ) ;
            //for( off = 0 ; off < sizeof pcru / sizeof pcru[ 0 ] ; off ++ ) etThread.strokeF( tin0P , TF1(pcru[off])+T(" ") ) ;
            //etThread.strokeF( tin0P , T("generated: ") ) ;
    
            for( countT off = 0 ; off < sizeof pcru / sizeof pcru[ 0 ] ; off ++ ) pcru[ off ] = ru ;
        {
        if( psPayload )
        etThread( tin0P , psPayload , TAG( TAGiDnULL ) ) ;
        ZE( soulC* , psPayload ) ;
    {
    if( home.idRank && home.idRank <= ClAYERS /*&& cOn*/ )
{
while( !ether )
etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIEST ) ;
homeS& home = homeS::homeIF() ;
ranUniC ru( MAXcOUNTT ) ;
etThread.cioSetGetF( tin0P , cioGetF ) ;
etThread.cioSetArgF( tin0P , cArg ) ;
countT cArg = (countT)&c8a ;
count8S c8a( (countT)pcsru , sizeof pcsru / sizeof pcsru[ 0 ] , (countT)&idLayerLath , (countT)(strokeS*)tFile ) ;
ZE( countT , idLayerLath ) ;
TN( tFile , "///ideafarm/ephemeral/super.random.numbers/set" ) ;

//U::ENABLE IN PRODUCTION: etThread.ifcHireF( tin0P , T("ifcIDaDAM_SUPERrANDOMnUMBERS") , ifcIDaDAM_SECRETsERVICE , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
//U::WILL CAUSE D35 TO FAIL DUE TO POOLoLD LEAKAGE:

//U::WILL CAUSE 635 TO FAIL DUE TO POOLoLD LEAKAGE: etThread.ifcHireF( tin0P , T("ifcIDaDAM_SUPERrANDOMnUMBERS") , ifcIDaDAM_SECRETsERVICE , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

TODO

countT pcsru[ CCsUPERrANDOM ] ;
countT pcru[ CCsUPERrANDOM / ClAYERS ] ; //A: ASSUME: A CELL OF ME LIVES ON EACH OF THE LOWEST RANKED 01 HOMES; TOGETHER WE PRODUCE 00001 RU VALUES PER CYCLE

}
    if( bQuitP && idptOriginP ) ;

    }
        }
            }
                }
                    else if( cOn ) -- cOn ;
                         if( bOn ) ++ cOn ;
                    *psPayloadP >> bOn ;
                    ZE( countT , bOn ) ;
                {
                if( idFormat == 1 )
                *psPayloadP >> idFormat ;
                ZE( countT , idFormat ) ;
            {
            else if( pczChannelP[ 1 ] == ifcOLDiDcHANNELfUNCTION_SUPERrANDOMnUMBERScTRL )
            }
                etherP.delF( tin0P , pcru ) ;

                }
                    }
                        }
                            home.grabSuperRandom.ungrabF( tin0P ) ;
        
                            }
                                //etherP.strokeF( tin0P , T("\r\n") ) ;
                                }
                                    if( offo == ccSuperRandom ) offo = 0 ;
                                    home.pcSuperRandom[ offo ++ ] = pcsruP[ offi ++ ] ;
                                    //etherP.strokeF( tin0P , TF1(pcsruP[offi])+T(" ") ) ;
                                {
                                while( cToFill -- )
                                home.cNextSuperRandom += cToFill ;
                                //etherP.strokeF( tin0P , T("refilled: ") ) ;
            
                                if( cToFill > ccsruP ) cToFill = ccsruP ;
            
                                countT offo = ( home.offNextSuperRandom + home.cNextSuperRandom ) % ccSuperRandom ;
                                ZE( countT , offi ) ;
                            {
                            if( cToFill )
                            countT cToFill = ccSuperRandom - home.cNextSuperRandom ;
            
                            home.grabSuperRandom.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                            const countT ccSuperRandom = sizeof home.pcSuperRandom / sizeof home.pcSuperRandom[ 0 ] ;
                            homeS& home = homeS::homeIF() ;
                        {
                        else
                        }
                            etherP.delF( tin0P , psttn ) ;
                            //etherP.strokeF( tin0P , T("set ")+TF1(++idSetLath)+T(" written to ")+T(psttn)+T("\r\n") ) ;
                            etherP.boxPutGenerationF( tin0P , psttn , psttFileP , 0x20 * TUCK , (byteT*)pcsruP , ccsruP * sizeof( countT ) ) ; ___( psttn ) ;
                            ZE( strokeS* , psttn ) ;
                        {
                        if( !idMin || idMax - idMin < 0xf )

                        etherP.boxMenuIdRangeF( tin0P , idMin , idMax , T(psttFileP)+T(".*") , 0x20 * TUCK , S1C('/') ) ;
                        ZE( countT , idMax ) ;
                        ZE( countT , idMin ) ;
                    {
                    if( !( idLayerLathP % ClAYERS ) )

                    for( countT offi = 0 ; offi < ccru ; offi ++ ) pcsruP[ offi * ClAYERS + offLayer ] = pcru[ offi ] ;
                    //etherP.strokeF( tin0P , T("received layer ")+TF1(1+offLayer)+T("\r\n") ) ;
                    const countT offLayer = ( idLayerLathP ++ ) % ClAYERS ;
                {
                if( ccru * ClAYERS == ccsruP )

                psPayloadP->shiftRightF( tin0P , pcru , ccru ) ;
                ZE( countT  , ccru ) ;
                ZE( countT* , pcru ) ;

                const strokeS* psttFileP    =  (const strokeS*)c8aP.c4 ;
                countT&        idLayerLathP =        *(countT*)c8aP.c3 ;
                countT         ccsruP       =                  c8aP.c2 ;
                countT*        pcsruP       =         (countT*)c8aP.c1 ;
                count8S&       c8aP         =       *(count8S*)cArgP ;
            {
            if( pczChannelP[ 1 ] == ifcOLDiDcHANNELfUNCTION_SUPERrANDOMnUMBERS )
        {
        if( pczChannelP && pczChannelP[ 0 ] == ifcOLDiDcHANNEL1_BYfUNCTION )
    {
    if( idPayloadTypeP == ifcOLDiDtYPEgIFT_APPLICATION )

    //etherP.strokeF( tin0P , T(pczChannelP)+T("\r\n") ) ;
{
voidT cioGetF( tin0S& tin0P , etherC& etherP , const boolT& bQuitP , const countT idPayloadTypeP , soulC*& psPayloadP , countT*& pczChannelP , countT& cArgP , const portTimeC& idptOriginP )

countT idSetLath ;
countT cOn ;

#define ClAYERS 0x10

/*1*/WAKEhIDE( "ifcIDaDAM_SUPERrANDOMnUMBERS.super.random.number.server" )/*1*/
/**/
*/
when there are many cells of me, the merged stream of random numbers is superrandom
clients can read that channel to obtain random numbers
i write ranUniC values to a channel
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

