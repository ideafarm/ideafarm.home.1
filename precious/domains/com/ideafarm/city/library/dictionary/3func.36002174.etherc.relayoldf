
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        DEL( psPayload ) ;
        stRelayOutP >> *(countT*)&psPayload ;
        ZE( soulC* , psPayload ) ;
    {
    while( stRelayOutP )

    }
        if( POOP ) POOPR

        }
            }
                }
                    sgnDone_tmRelayOldBlowTeatF.waitF( tin0P ) ;
                    }
                        if( psNull ) stRelayOutP << *(countT*)&psNull ;
                        __Z( psNull ) ;
                        soulC* psNull = new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) ) ;
                    {
                    bQuitWoConnect = 1 ;

                    }
                        DEL( psWrap ) ;

                        }
                            b_pCioGetFP.ungrabF( tin0P ) ;
                            }
                                }
                                    DEL( psGift ) ; //CALLBACK WILL NORMALLY ZE THIS AND BE RESPONSIBLE FOR DELETION
                                    }
                                        if( POOP ) POOPR
                                        (*pCioGetFP)( tin0P , *((tin1S&)tin0P).pEtScratch , bQuitP , ifcOLDiDtYPEgIFT_REPLYrELAYiDpORTtIMEcaLLhOMES , psGift , pczChannelCopy , pcArgP ? *pcArgP : ze , idptNU ) ;
                                        ZE( countT* , pczChannelCopy ) ;
                                    {
                                    if( pCioGetFP )
            
                                    psGift->shiftLeftF( tin0P , 0 , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                                    const byteT* pbsGift = psWrap->pbFieldF( tin0P , idtsGift , flsGift , cbsGift , ifcOLDiDfIELDwRAP_PORTtIMEaLLhOMES ) ;
                                    ZE( countT , cbsGift ) ;
                                    ZE( flagsT , flsGift ) ;
                                    ZE( countT , idtsGift ) ;
                                {
                                if( psGift )
                                soulC* psGift = new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) ) ;
                            {
                            if( pCioGetFP )
                            b_pCioGetFP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        {
                        else if( idType == ifcOLDiDtYPEwRAP_REPLYrELAYiDpORTtIMEcaLLhOMES )
                        }
                            b_pCioGetFP.ungrabF( tin0P ) ;
                            }
                                }
                                    DEL( psGift ) ; //CALLBACK WILL NORMALLY ZE THIS AND BE RESPONSIBLE FOR DELETION
                                    }
                                        if( POOP ) POOPR
                                        (*pCioGetFP)( tin0P , *((tin1S&)tin0P).pEtScratch , bQuitP , ifcOLDiDtYPEgIFT_REPLYrELAYiDpORTtIMEc , psGift , pczChannelCopy , pcArgP ? *pcArgP : ze , idptNU ) ;
                                        ZE( countT* , pczChannelCopy ) ;
                                    {
                                    if( pCioGetFP )
            
                                    psGift->shiftLeftF( tin0P , 0 , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                                    const byteT* pbsGift = psWrap->pbFieldF( tin0P , idtsGift , flsGift , cbsGift , ifcOLDiDfIELDwRAP_PORTtIME ) ;
                                    ZE( countT , cbsGift ) ;
                                    ZE( flagsT , flsGift ) ;
                                    ZE( countT , idtsGift ) ;
                                {
                                if( psGift )
                                soulC* psGift = new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) ) ;
                            {
                            if( pCioGetFP )
                            b_pCioGetFP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        {
                        else if( idType == ifcOLDiDtYPEwRAP_REPLYrELAYiDpORTtIMEc )
                        }
                            b_pCioGetFP.ungrabF( tin0P ) ;
                            }
                                }
                                    DEL( psGift ) ; //CALLBACK WILL NORMALLY ZE THIS AND BE RESPONSIBLE FOR DELETION
                                    }
                                        if( POOP ) POOPR
                                        (*pCioGetFP)( tin0P , *((tin1S&)tin0P).pEtScratch , bQuitP , ifcOLDiDtYPEgIFT_REPLYrELAYrANK , psGift , pczChannelCopy , pcArgP ? *pcArgP : ze , idptNU ) ;
                                        ZE( countT* , pczChannelCopy ) ;
                                    {
                                    if( pCioGetFP )
            
                                    psGift->shiftLeftF( tin0P , 0 , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                                    const byteT* pbsGift = psWrap->pbFieldF( tin0P , idtsGift , flsGift , cbsGift , ifcOLDiDfIELDwRAP_RELAYrANK ) ;
                                    ZE( countT , cbsGift ) ;
                                    ZE( flagsT , flsGift ) ;
                                    ZE( countT , idtsGift ) ;
                                {
                                if( psGift )
                                soulC* psGift = new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) ) ;
                            {
                            if( pCioGetFP )
                            b_pCioGetFP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        {
                        else if( idType == ifcOLDiDtYPEwRAP_REPLYrELAYrANK )
                        //U::CONJ: THE NEXT SNIPPETS ARE PSEUDOIDENTICAL; COMBINE THEM
                        }
                            delF( tin0P , pczChannelCopy ) ; //CALLBACK MIGHT ZE THIS OUT AND BE RESPONSIBLE FOR DELETION
                            }
                                b_pCioGetFP.ungrabF( tin0P ) ;
                                }
                                    }
                                        DEL( psGift ) ; //CALLBACK WILL NORMALLY ZE THIS AND BE RESPONSIBLE FOR DELETION
                                        }
                                            if( POOP ) POOPR
                                            (*pCioGetFP)( tin0P , *((tin1S&)tin0P).pEtScratch , bQuitP , ifcOLDiDtYPEgIFT_APPLICATION , psGift , pczChannelCopy , pcArgP ? *pcArgP : ze , idptOrigin ) ;
                                        {
                                        if( pCioGetFP )
                
                                        psGift->shiftLeftF( tin0P , 0 , pbsGift , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                                    {
                                    if( psGift )
                                    soulC* psGift = new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) ) ;
                                {
                                if( pCioGetFP )
                                b_pCioGetFP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                
                                const byteT* pbsGift = psWrap->pbFieldF( tin0P , idtsGift , flsGift , cbsGift , ifcOLDiDfIELDwRAP_GIFT ) ;
                                ZE( countT , cbsGift ) ;
                                ZE( flagsT , flsGift ) ;
                                ZE( countT , idtsGift ) ;
                            {
                            else
                            }
                                b_pCioGetFP.ungrabF( tin0P ) ;
                                }
                                    if( POOP ) POOPR
                                    (*pCioGetFP)( tin0P , *((tin1S&)tin0P).pEtScratch , bQuitP , ifcOLDiDtYPEgIFT_MEDIATE , psWrap , pczChannelCopy , pcArgP ? *pcArgP : ze , idptOrigin ) ; //CALLBACK WILL NORMALLY psWrap AND BE RESPONSIBLE FOR DELETION
                                {
                                if( pCioGetFP )
                                b_pCioGetFP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
            
                                flags |= flCIOpUT_IGNOREmEDIATORlIST ;
                            {
                            if( bMediate )
            
                            boolT bMediate = !( F(flags) & flCIOpUT_IGNOREmEDIATORlIST ) && psToM ;
            
                            portTimeC idptOrigin = portTimeC::fieldF( tin0P , *psWrap , ifcOLDiDfIELDwRAP_IDPToRIGIN ) ;
            
                            flagsT& flags = psWrap->cFieldF( tin0P , ifcOLDiDfIELDwRAP_FLAGS ) ;

                            //if( psToM ) { CONoUTrAW( "got wrap with sToM values from tit\r\n" ) ; }

                            }
                                if( psToM && !*psToM ) DEL( psToM ) ;
                                }
                                    if( psToM ) psToM->shiftLeftF( tin0P , 0 , pbsToM , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                                    psToM = new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) ) ; ___( psToM ) ;
                                {
                                if( pbsToM )
                                const byteT* pbsToM = psWrap->pbFieldF( tin0P , idtToM , flToM , cbToM , ifcOLDiDfIELDwRAP_TOmEDIATOR ) ;
                                ZE( countT , cbToM ) ;
                                ZE( flagsT , flToM ) ;
                                ZE( countT , idtToM ) ;
                            {
                            ZE( soulC* , psToM ) ;

                            //if( psTo ) { CONoUTrAW( "got wrap with sTo values from tit\r\n" ) ; }
            
                            }
                                if( psTo && !*psTo ) DEL( psTo ) ;
                                }
                                    if( psTo ) psTo->shiftLeftF( tin0P , 0 , pbsTo , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                                    psTo = new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) ) ; ___( psTo ) ;
                                {
                                if( pbsTo )
                                const byteT* pbsTo = psWrap->pbFieldF( tin0P , idtTo , flTo , cbTo , ifcOLDiDfIELDwRAP_TO ) ;
                                ZE( countT , cbTo ) ;
                                ZE( flagsT , flTo ) ;
                                ZE( countT , idtTo ) ;
                            {
                            ZE( soulC* , psTo ) ;

                            memCopyF( tin0P , (byteT*)pczChannelCopy , (byteT*)pczChannel , cca * sizeof( countT ) ) ;
                            newF( tin0P , LF , pczChannelCopy , cca ) ; ___( pczChannelCopy ) ;
                            ZE( countT* , pczChannelCopy ) ;
                            countT cca = 1 + strBodyLengthF( tin0P , pczChannel ) ;
                            const countT* pczChannel = (countT*)psWrap->pbFieldF( tin0P , idtC , flC , cbC , ifcOLDiDfIELDwRAP_CHANNEL ) ;
                            ZE( countT , cbC ) ;
                            ZE( flagsT , flC ) ;
                            ZE( countT , idtC ) ;
                        {
                        else if( idType == ifcOLDiDtYPEwRAP_GIFT )
                        }
                            break ;
                            DEL( psWrap ) ;
                        {
                        if( idType == ifcOLDiDtYPEwRAP_QUIT    )
                        ZE( countT , ze ) ;
                        portTimeC idptNU ;
                
                        countT idType = psWrap->cFieldF( tin0P , ifcOLDiDfIELDwRAP_IDtYPE ) ;
                
                        __( psWrap->cFieldF( tin0P , ifcOLDiDfIELDwRAP_IDvERSION ) - 1 ) ;
                        __( psWrap->cFieldF( tin0P , ifcOLDiDfIELDwRAP_IDpROTOCOL ) - ifcIDpROTOCOL_RELAYwRAP ) ;
                        }
                            delF( tin0P , psttTM ) ;
                            __( strCompareF( tin0P , psttTM , T("IdeaFarm " "(tm)") ) ) ;

                            strReplaceF( tin0P , psttTM , 0 , ifcIDtYPEsTRrEPLACE_MAKEiMPORT , psttTM[ 2 ].idAdam ) ; ___( psttTM ) ;
                            strDecodeF( tin0P , psttTM , pbfTM ) ; ___( psttTM ) ;
                            ZE( strokeS* , psttTM ) ;
                
                            const byteT* pbfTM = psWrap->pbFieldF( tin0P , idtTM , flTM , cbTM , ifcOLDiDfIELDwRAP_TRADEmARK ) ;
                            ZE( countT , cbTM ) ;
                            ZE( flagsT , flTM ) ;
                            ZE( countT , idtTM ) ;
                        {
                
                        }
                            }
                                break ;
                                DEL( psWrap ) ;
                                traceF( tin0P , T("relayOldF: could not read wrap") ) ;
                                bFail = 1 ;
                                POOPRqUIET
                            {
                            if( POOP )
                            sock.readF( tin0P , *psWrap ) ;
                            SCOOPS
                        {
                        IFsCRATCHoK
            
                        soulC* psWrap = new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) ) ;
                    {
                    while( !bQuitP && !POOP )
                
                    osThreadF( tin0P , countTC() , tmRelayOldBlowTeatF , &sgnDone_tmRelayOldBlowTeatF , 0 , flTHREADlAUNCH_null , 0 , 0 , (countT)&sock , (countT)&bQuitWoConnect , (countT)&stRelayOutP ) ;
                    signC sgnDone_tmRelayOldBlowTeatF( tin0P , TAG( TAGiDnULL ) ) ;
                    ZE( boolT , bQuitWoConnect ) ;
                {
                if( !bFail )

                }
                    }
                        traceF( tin0P , T("relayOldF: could not connect to teat") ) ;
                        bFail = 1 ;
                        POOPRqUIET
                    {
                    if( POOP )
                    sock.connectF( tin0P , home.idpTeat , (nicNameC&)home.idpTeat ) ;
                    SCOOPS
                {
                IFsCRATCHoK
                socketC sock( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
                ZE( boolT , bFail ) ;
            {
            IFsCRATCHoK
        {
        if( !bQuitP )

        idpTeatLag = home.idpTeat ;
        }
            }
                ++ s ; osSleepF( tin0P , TUCK * 0x40 ) ;
                //LOGrAW3( "waiting for home.idpTeat value " , (countT)home.idpTeat , " to change\r\n" ) ;
                //CONoUTrAW3( "waiting for home.idpTeat value " , (countT)home.idpTeat , " to change\r\n" ) ;
            {
            while( ( !home.idpTeat || ( home.idpTeat == idpTeatLag && cTries -- ) ) && !bQuitP )
            countT cTries = 0x40 ;
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        {
    {
    while( !bQuitP )
    portC idpTeatLag ;
    homeS& home = homeS::homeIF() ;

    _IO_

    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::relayOldF( tin0S& tin0P , const boolT& bQuitP , stackC& stRelayOutP , countT*& pcArgP , cioGetFT& pCioGetFP , batonC& b_pCioGetFP )/*1*/

/**/
*/
 b_pCioGetFP
  it is illegal to change the value without grabbing b_pCioGetFP
  calling process can change or reset this value asynchronously
  if not 0 then will be called for each incoming soulC payload
  can be 0
 pCioGetFP
  passed to the callback function without being inspected
 cArgP
  each soulC item will be launched into relay
  the contents of these soulC objects must conform to the relay protocol
  caller can asynchronously push pointers to soulC objects onto stRelayOutP
 stRelayOutP
 bQuitP
 tin0P
arguments
   if pass then write the envelope to the application (BBBB)
   test against the filters registered by the application client
  for each outer envelope pushed onto a stackC (by the inner system)
 tmRelayOldServerOuterIncomingF
  read outer envelopes, popping each into the inner system (AAAA)                          ========AOK (triplets)
  launches tmRelayOldServerOuterIncomingF
 tmRelayOldServerOuterF
  for each local application client, launch tmRelayOldServerOuterF
  binds, and puts that idPort value into homeS so local clients can connect to it
 tmRelayOldAcceptorF
  launches tmRelayOldAcceptorF
  does inner stuff
 relayOldC::relayOldC
  for each envelope pushed onto a stackC: write it to the local inner relay server (AAAA)  ========AOK (triplets)
 tmRelayOldWriteWrapFromAppF
  for each incoming envelope: call callback  (BBBB)
  launches tmRelayOldWriteWrapFromAppF
  connects to the local inner relay server
 relayOldF
relay system pseudocode
if this occurs, impotence will not occur
i will return early if i must detach from relay
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

