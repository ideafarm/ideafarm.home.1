
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bCloaked ;
    //if( ((tinNormalS&)tinP).pEther && ((tinNormalS&)tinP).pc Utility[ 0 ] ) ((tinNormalS&)tinP).pEther->traceF( tinP , T("dosFindFileOrDirPrivateF ----") ) ;

    }
        }
            }
                }
                    pInfoFileP->flags |= flFILEaTTR1_DOTdIRECTORY ;
                    )
                        )
                            )
                                pInfoFileP->postOsName[ costn - 4 ] == '\\'
                                pInfoFileP->postOsName[ costn - 3 ] == '.' &&
                            (
                            pInfoFileP->postOsName[ costn - 3 ] == '\\' ||
                        (
                        pInfoFileP->postOsName[ costn - 2 ] == '.' &&
                        pInfoFileP->postOsName[ costn - 1 ] == '\\' &&
                    (
                    if                                                                                 // ENDS WITH EITHER "/./" OR "/../"
                    countT costn = c_strlenIF( tinP , pInfoFileP->postOsName ) ;

                    thirdC::c_strncpyIF( tinP , pInfoFileP->postOsName , ostot , pInfoFileP->costaOsName ) ;
                    OStEXTAK( ostot , "\\" )
                    OStEXTA( ostot , pInfoFileP->postOsName )
                    OStEXT( ostot , 0x200 )
                    _IO_
                {
                if( F(pInfoFileP->flags) & flFILEaTTR1_DIRECTORY )
                #include "\ideafarm.home.1\ephemeral\domains\com\ideafarm\city\workshop\snip\1snip.19000001.getFileInfo.h"
                _IO_
            {
            if( !*this && fFound )

            }
                delF( tinP , postLike ) ;                           //U::20210107@1055: slotsC FAILED TO DELETE THIS
                //((tinNormalS&)tinP).pc Utility[ 1 ] = (countT)postLike ;
                _IO_
            {

            }
                }
                    }
                        c_strncpyIF( tinP , pInfoFileP->postOsNameAlt , ostota , pInfoFileP->costaOsNameAlt ) ;
                        newF( tinP , LF , pInfoFileP->postOsNameAlt , pInfoFileP->costaOsNameAlt ) ; ___( pInfoFileP->postOsNameAlt ) ; // 1 osTextT IS ALLOCATED FOR THE '\\' THAT WILL BE APPENDED IF THE OBJECT IS A DIRECTORY
                        pInfoFileP->costaOsNameAlt = ostota.costF() + 2 ;
                    {
                    if( *info.symACHnAMEaLT )

                    c_strncpyIF( tinP , pInfoFileP->postOsName , ostot , pInfoFileP->costaOsName ) ;
                    newF( tinP , LF , pInfoFileP->postOsName , pInfoFileP->costaOsName ) ; ___( pInfoFileP->postOsName ) ; // 1 osTextT IS ALLOCATED FOR THE '\\' THAT WILL BE APPENDED IF THE OBJECT IS A DIRECTORY
                    pInfoFileP->costaOsName = ostot.costF() + 2 ;

                    if( info.symACHnAMEaLT ) OStEXTA( ostota , info.symACHnAMEaLT )
                    OStEXTAL( ostota , postLike , costPrefix )
                    OStEXT( ostota , TUCK << 1 )

                    if( info.symACHnAME ) OStEXTA( ostot , info.symACHnAME )
                    OStEXTAL( ostot , postLike , costPrefix )
                    OStEXT( ostot , TUCK << 1 )

                    countT costPrefix = postEnd - postLike + 1 ;
                    postEnd = c_strrchrIF( tinP , postLike , '\\' ) ;
                    ZE( osTextT* , postEnd ) ;
                {
                if( pInfoFileP )
                __Z( pInfoFileP ) ;
                pInfoFileP = new( 0 , tinP , LF ) infoFileS( tinP ) ; ___( pInfoFileP ) ;
                _IO_
            {
            if( !POOP && fFound )

            }
                }
                    #endif

                        }
                            }
                                }
                                    break ;
                                    handleP.closeIfF() ;
                                    fFound = 0 ;
                                    ((tinNormalS&)tinP).bosFail = 0 ;
                                    BOSpOOP
                                {
                                default :
                                }
                                    break ;
                                    handleP.closeIfF() ;
                                    fFound = 0 ;
                                    ((tinNormalS&)tinP).bosFail = 0 ;
                                {
                                case ERROR_NO_MORE_FILES  :
                                case ERROR_PATH_NOT_FOUND :
                                case ERROR_FILE_NOT_FOUND :
                                }
                                    break ;
                                    handleP.closeIfF() ;
                                    fFound = 0 ;
                                    ((tinNormalS&)tinP).bosFail = 0 ;
                                    etherC::etTextIF( tinP ).traceF( tinP , T("thirdC::dosFindFileOrDirPrivateF / ERROR_LOGON_FAILURE [postLike]: ")+T(postLike) ) ;
                                    BOSpOOP
                                {
                                case ERROR_LOGON_FAILURE :
                                }
                                    break ;
                                    handleP.closeIfF() ;
                                    fFound = 0 ;
                                    ((tinNormalS&)tinP).bosFail = 0 ;
                                    etherC::etTextIF( tinP ).traceF( tinP , T("thirdC::dosFindFileOrDirPrivateF / ERROR_SHARING_VIOLATION [postLike]: ")+T(postLike) ) ;
                                    BOSpOOP
                                {
                                case ERROR_SHARING_VIOLATION :
                            {
                            switch( ((tinNormalS&)tinP).brcLath )
                            _IO_
                        {
                        if( ((tinNormalS&)tinP).bosFail )

                        }
                            __( ifcIDiMPOTENCEbASEeRRORcODE_NOTrEADY ) ;
                            etherC::etTextIF( tinP ).traceF( tinP , T("thirdC::dosFindFileOrDirPrivateF / i gave up retrying on ERROR_NOT_READY [postLike]: ")+T(postLike) ) ;
                        {
                        if( bRetry )
                        while( bRetry && -- cDo ) ;
                        }
                            }
                                fFound = !((tinNormalS&)tinP).bosFail ;
                                else if( bRetry ) bRetry = 0 ;
                                }
                                    continue ;
                                    bRetry = 1 ;
                                    //Sleep( 2000 ) ;
                                    _IO_
                                {
                                if( ((tinNormalS&)tinP).brcLath == ERROR_NOT_READY )
                                BOS( WHATsfr , BOSoK , FindNextFile( (HANDLE)pFH->hFind.osF( ifcIDtYPEhANDLE_FILEfINDbASE ) , &info ) )
                            {
                            else
                            }
                                }
                                    handleP.osF( ifcIDtYPEhANDLE_FILEfIND , (countT)pFH ) ;
                                    fFound = 1 ;
                                    INCoShANDLES
                                {
                                else
                                if( !pFH->hFind ) { DEL( pFH ) ; }
                                pFH->hFind.osF( ifcIDtYPEhANDLE_FILEfINDbASE , (countT)((tinNormalS&)tinP).brcRaw ) ;
                                else if( bRetry ) bRetry = 0 ;
                                }
                                    continue ;
                                    bRetry = 1 ;
                                    //Sleep( 2000 ) ;
                                    _IO_
                                {
                                if( ((tinNormalS&)tinP).brcLath == ERROR_NOT_READY )
                                BOS( WHATsfr , BOShANDLE , FindFirstFile( postLikeP , &info ) )
                            {
                            if( bWoth )
                            _IO_
                        {
                        do                                                 //SILENTLY RETRY 8 TIMES IF ERROR_NOT_READY
                        countT cDo = 1 ;            //20230802@1823: 8 --> 1 ELIMINATE RETRY (PERSONALITY: LET CALLER DEAL WITH THIS SO THAT CALLER CAN DETECT FAILURE QUICKLY AND HANDLE IT
                        ZE( boolT , bRetry ) ;

                        //CS:CODEsYNCH: DUPLICATE CODE 3600101d 35001186

                        BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                        ULONG cc = 1 ;

                    #elif defined( __NT__ )

                        //U: CONJ: NEED TO CLOSE THE HANDLE IF ANOTHER FILE WAS NOT FOUND

                        fFound = cc == 1 && !((tinNormalS&)tinP).brcLath ;
                        }
                            BOSpOOP
                        {
                        )
                            /*((tinNormalS&)tinP).brcLath != ERROR _NOT_READY*/
                            ((tinNormalS&)tinP).brcLath != ERROR_PATH_NOT_FOUND          /*&&*/ /*CONJECTURE: THIS WILL NEVER OCCUR*/
                            ((tinNormalS&)tinP).brcLath != ERROR_FILE_NOT_FOUND          && /*CONJECTURE: THIS WILL NEVER OCCUR*/
                            ((tinNormalS&)tinP).brcLath != ERROR_NOT_DOS_DISK            && /*DON''T KNOW IF THIS OCCURS*/
                            ((tinNormalS&)tinP).brcLath != ERROR_FILENAME_E~CED_RANGE    && /*LONG NAME THAT IS NOT SUPPORTED ON THIS DISK*/
                            ((tinNormalS&)tinP).brcLath != ERROR_NO_MORE_FILES           && /*NO MORE MATCHES*/
                            ((tinNormalS&)tinP).bosFail                                  && /*CAUSE:*/
                        if( 

                        }
                            BOSI( WHATsfr , BOSfAIL , DosFindNext( handleP.osF( ifcIDtYPEhANDLE_FILEfIND ) , &info , sizeof info , &cc ) )
                        {
                        else
                        }
                            handleP.osF( ifcIDtYPEhANDLE_FILEfIND , (countT)osh ) ;
                            BOSI( WHATsfr , BOSfAIL , DosFindFirst( postLike , &osh , FILE_ARCHIVED | FILE_DIRECTORY | FILE_SYSTEM | FILE_HIDDEN | FILE_READONLY , &info , sizeof info , &cc, FIL_STANDARD ) )
                            ZE( HDIR , osh ) ;

                            else                                                                                                 handleP.osF( ifcIDtYPEhANDLE_fileFind , (countT)HDIR_CREATE ;
                            if( !c_st((tinNormalS&)tinP).brcRawhrIF( tinP , postLike , '?' ) && !c_st((tinNormalS&)tinP).brcRawhrIF( tinP , postLike , '*' ) ) handleP.osF( ifcIDtYPEhANDLE_FILEfIND , (countT)HDIR_SYSTEM ) ;
                        {
                        if( bWoth )
                        ULONG cc = 1 ;
                                                                                                             =
                    #ifdef __OS2__
                    _IO_
                {
                if( !POOP )
                _IO_
            {
            else
            }
                }
                    }
                        c_strcpyIF( tinP , info.symACHnAME , ostoCloaked ) ;
                        OStEXTA( ostoCloaked , posti ) ;
                        fFound = 1 ;
                        _IO_
                    {
                    if( posti )                                                                         //U:: IF THIS IS TRUE THEN REMOVE THE CODE USED HERE TO CONCATENATE
                    //OStEXTAL( ostoCloaked , postLikeP , costPrefix ) ;                                //20200602@1150: COMMENTED OUT BECAUSE CONJ: info.symACHnAME SHOULD CONTAIN ONLY THE SHORT NAME
                    OStEXT( ostoCloaked , 0x200 )

                    countT costPrefix = postEnd - postLikeP + 1 ;
                    postEnd = c_strrchrIF( tinP , postLikeP , '\\' ) ;
                    ZE( osTextT* , postEnd ) ;

                    posti[ costi ] = 0 ;
                    countT rc = thirdC::s_readIF( tinP , posti , costi , pFH->hSockCloak ) ;
                    osTextT* posti = processGlobal4I.heap.newF( tinP , LF , costi + 1 ) ;
                    _IO_
                {
                else
                if( !costi || costi > TUCK << 2 ) handleP.closeIfF() ;

                countT rc = thirdC::s_readIF( tinP , (byteT*)&costi , sizeof costi , pFH->hSockCloak ) ;
                ZE( countT , costi ) ;
                _IO_
            {
            if( bCloaked )

            c_memsetIF( tinP , (byteT*)&info , sizeof info ) ;
            #endif
                WIN32_FIND_DATA info ;
            #elif defined( __NT__ )
                FILEFINDBUF3 info ;
            #ifdef __OS2__
            ZE( boolT , fFound ) ;

            }
                }
                    thirdC::s_writeIF( tinP , pFH->hSockCloak , postLikeP , costLike ) ;
                    thirdC::s_writeIF( tinP , pFH->hSockCloak , (byteT*)&costLike , sizeof costLike ) ;
                    countT costLike = thirdC::c_strlenIF( tinP , postLikeP ) ;

                    thirdC::s_writeIF( tinP , pFH->hSockCloak , (byteT*)&idFormat , sizeof idFormat ) ;
                    countT idFormat = 1 ;

                    thirdC::s_writeIF( tinP , pFH->hSockCloak , (byteT*)&finger , sizeof finger ) ;
                    countT finger = FINGERnEG_CLOAKsIMPLEcONNECTION ;

                    thirdC::s_writeIF( tinP , pFH->hSockCloak , (byteT*)&idTypeConnection , sizeof idTypeConnection ) ;
                    countT idTypeConnection = ifcIDtYPEcLOAKcONNECTION_SIMPLE ;

                    thirdC::s_connectIF( tinP , countTC() , pFH->hSockCloak , homeS::homeIF().portCloak ) ;

                    thirdC::s_socketIF( tinP , pFH->hSockCloak , ifcSOCKETtYPE_STREAM ) ;
                    _IO_
                {
                if( bCloaked )

                }
                    pFH = new( 0 , tinP , pba , cba ) diskFindHandleS( tinP ) ;
                    _IO_
                {
                if( pba )
                byteT* pba = processGlobal4I.heap.newF( tinP , LF , cba ) ;
                countT cba = sizeof( diskFindHandleS ) ;
                _IO_
            {
            else
            if( ~handleP ) pFH = (diskFindHandleS*)handleP.osF( ifcIDtYPEhANDLE_FILEfIND ) ;
            boolT bWoth = !handleP ;
            ZE( diskFindHandleS* , pFH ) ;
            //CS:CODEsYNC: DUPLICATE CODE 3600101d 35001186
            _IO_
        {
        if( !POOP )

        }
            //}
            //    }
            //        //pEtherContainsMe->traceF( tinP , T(postLikeP) ) ;
            //        //pEtherContainsMe->traceF( tinP , T("dosFindFileOrDirPrivateF / setting bCloaked [postLikeP] (next line):") ) ;
            //    {
            //    if( pEtherContainsMe )
            //    if( !bNetBios ) bCloaked = 1 ;
            //    POOPR
            //{
            //if( POOP )

            // TO UNBREAK CLOAKING, THE FOLLOWING CODE, AND OTHER CODE LIKE IT, SHOULD BE REWRITTEN TO DETECT CLOAKING IN A WAY THAT DOES NOT GIVE A FALSE POSITIVE
            // COMMENTING OUT THE FOLLOWING CODE WILL ENABLE NORMAL IMPOTENCE BEHAVIOR BUT WILL ALSO BREAK CLOAKING
            // THE OO'TH DEFECT IS THAT CODE SUCH AS THE FOLLOWING (WHICH IS COMMENTED OUT) TESTS POOP, AND IF NONZE, INFERS THAT THE FAILURE WAS CAUSED BY CLOAKING
            // THE WO'TH DEFECT IS THAT NO THOUGHT WAS GIVENN TO SUPPORTING CLOAKING FOR NETWORKED DIRECTORIES
            //U:: 20221204@0820: SUPPORT FOR CLOAKING, AS CURRENTLY IMPLEMENTED, SUFFERS FROM OO FATAL DESIGN DEFECTS

            //THREADmODE2rESTORE
            thirdC::dosFindFileOrDirSimpleIF( tinP , postf , sizeof postf , hFind , postLikeP , flDOSfINDfILEoRdIR_DOnOTtESTwATER ) ;
            //THREADmODE2oN( flTHREADmODE2_QUIETiMPOTENCE ) ;

            handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            postf[ 0 ] = 0 ;
            osTextT postf[ TUCK << 1 ] ;

            //SCOOP
            //poopC poop ;
            _IO_
        {
        //CS:CODEsYNC: PSEUDODUPLICATE CODE 3600101d 35001186

        __Z( cMax ) ;
        countT cMax = dosQuerySysInfoMaxPathLengthIF( tinP ) ;
        }
            __( !(( ostDisk >= 'a' && ostDisk <= 'z' )||( ostDisk >= 'A' && ostDisk <= 'Z' )) ) ;
            if( !POOP ) ostDisk = *postLike ;
            ZE( osTextT , ostDisk ) ;
            _IO_
        {
        if( !bNetBios )

        const boolT bNetBios = postLike[ 0 ] == '\\' && postLike[ 1 ] == '\\' ;

        if( postLike ) postLike[ costCopy ] = 0 ;
        c_memcpyIF( tinP , postLike , postLikeP , costCopy ) ;
        //((tinNormalS&)tinP).pc Utility[ 0 ] = (countT)postLike ;                           //U::20210107@1055: slotsC FAILED TO DELETE THIS
        newF( tinP , LF , postLike , costCopy + 1 ) ; ___( postLike ) ;
        countT costCopy = costLikeP - ( postLikeP[ costLikeP - 1 ] == '\\' ) ;
        const countT costLikeP = postLikeP ? c_strlenIF( tinP , postLikeP ) : 0 ;
        ZE( osTextT* , postLike ) ;                                                 // REMOVED TRAILING '\\' FOR DIRECTORY NAME
        _IO_
    {
    ZE( boolT , bCloaked ) ;

    _IO_

    }
        if( POOP ) return 0 ;
        #endif
            __( sizeof( countT ) != sizeof( HANDLE ) || fnu ) ;
        #elif defined( __NT__ )
        __( sizeof( countT ) != sizeof( HDIR ) || fnu ) ;
        #ifdef __OS2__
        ZE( boolT , fnu ) ;
        __NZ( pInfoFileP ) ;
        __( !postLikeP[ 3 ] ) ;
        if( POOP ) return 0 ;
        __( !postLikeP[ 2 ] ) ;
        if( POOP ) return 0 ;
        }
            __( postLikeP[ 1 ] - ':' ) ;
        {
        if( postLikeP[ 1 ] != '\\' )            //20190826@0902: ACCOMMODATE NETBIOS FILE NAMES OF THE FORM "\\netbiosname\disk\path\short"
        if( POOP ) return 0 ;
        __( !postLikeP[ 0 ] ) ;
        if( POOP ) return 0 ;
        __Z( postLikeP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL    
    SCOOP


    //}
    //    countT foo = 2 ;
    //{
    //if( postLikeP[ 0 ] == '\\' && postLikeP[ 1 ] == '\\' )



//}
//    countT foo = 2 ;
//{
//if( ((tinNormalS&)tinP).pc Utility[ 0 ] && c_strstrIF( tinP , postLikeP , "\\exedll\\1" ) )
//U:: TO FIND A BUG


    //if( ((tinNormalS&)tinP).pEther && ((tinNormalS&)tinP).pc Utility[ 0 ] ) ((tinNormalS&)tinP).pEther->traceF( tinP , T("dosFindFileOrDirPrivateF ++++") ) ;
{
/*1*/boolT thirdC::dosFindFileOrDirPrivateF( tinNormalS& tinP , infoFileS*& pInfoFileP , handleC& handleP , const osTextT* const postLikeP )/*1*/

#endif
    #define symACHnAMEaLT      cAlternateFileName
    #define symACHnAME         cFileName
#elif defined( __NT__ )
    #define symACHnAMEaLT      replaceThisWithName
    #define symACHnAME         achName
#ifdef __OS2__

// CONJ: O.S. WILL SUPPORT SEARCHES FOR ROOT DIRECTORIES
//U: ENHANCE TO ALLOW "?:\\" TO RESULT IN FINDING A ROOT DIRECTORY

/**/

*/
    for Windows: "\\myDir\\myFile.foo*"
   examples
  can contain wildcard strokes ('*' and '?')
   the result is a dir iff F(pInfoFileP->flags) & flFILEaTTR1_DIRECTORY
   i cannot be told to just find files, or to just find directories
   my search will find both files and directories
  a terminating '\' character is ignored if present
  must point to a fully qualified file name, in native operating system form
  can contain the wildcard strokes '*' and '?'
  exception: cannot be a root directory, e.g. "?:\"
  can be a directory name (terminating '\' stroke is present)
  can be a file name (no terminating '\' stroke)
  must not be 0
 postLikeP
  call this function repeatedly until handleP is set, by it, to 0
  must be 0 on first call
 handleP
 pInfoFileP
arguments
 failure to do this causes a resource leak
 applications -must- call this function repeatedly until handleP is ze
 as long as handleP is nonze, more matching files exist
this function -must- be called repeatedly until handleP is ze
this function finds a single file whose name matches postLikeP
\<A HREF=\"5.102001e.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosFindFileOrDirPrivateF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

