
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmcHttpServerWorkerF )

}
    dec02AM( cWorkerP ) ;

    }
        }
            }
                }
                    DELzOMBIE( pDoomed ) ;
                    dec02AM( jobP.cSession ) ;
                    taskDrivenServerJobS* pDoomed = &jobP ;

                    //etThread.traceF( tinBaseP , T("DONE [cSession]:    ")+TF2(jobP.cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    /*etThread.delF( tinBaseP , psttPeerP ) ;*/

                    //etThread.traceF( tinBaseP , T("decremented cSession"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                    jobP.sw_cSessionWithPeer.ungrabF( tinBaseP ) ;
                    -- jobP.sw_cSessionWithPeer ;
                    jobP.lever_nnPeer = jobP.nnPeer ;
                    jobP.sw_cSessionWithPeer.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                    jobP.sessions.unregisterConnectionF( tinBaseP , jobP.nnPeer ) ;
                    //etThread.traceF( tinBaseP , T("decrementing cSession"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                    }
                        jobP.sw_pso.ungrabF( tinBaseP ) ;
                        }
                            else                                                 __1
                            if( (countT)&psoP == (countT)&(countT&)jobP.sw_pso ) jobP.sw_pso.freeF( tinBaseP ) ;
                            _IO_
                        {
                        }
                            jobP.lever_idSession = jobP.idSession ;
                            _IO_
                        {
                        }
                            DEL( psoP ) ;
                            _IO_
                        {
                        }
                            jobP.sw_pso.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                            _IO_
                        {

                        }
                            etThread.traceF( tinBaseP , T("called etherDoHttpJobF"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                            etThread.etherDoHttpJobF( tinBaseP , jobP , psoP , sessionP , idPortMeP , nnMeP ) ;
                            etThread.traceF( tinBaseP , T("calling etherDoHttpJobF"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                            _IO_
                        {
                        etThread.osTimeNowF( tinBaseP , jobP.timeDoJob1 , jobP.timeDoJob2 ) ;

                        _IO_
                    {

                    TELL( "TASK: entering application code" )

                    }
                        /* }                                                                      */
                        /*     if( POOP ) { POOPR }                                               */
                        /*     }                                                                  */
                        /*         TELL( "returned from querying dns for peer name string" ) ;    */
                        /*         ((tin9S&)tinBaseP).pEtScratch->sockPsttHostF( tinBaseP , psttPeerP , nnPeerP ) ; */
                        /*         TELL( "querying dns for peer name string" ) ;                  */
                        /*     {                                                                  */
                        /*     if( nnPeerP.pcId[ 0 ] )                                            */
                        /* {                                                                      */
                        /* ZE( strokeS* , psttPeerP ) ;                                           */
                        /* THIS IS TOO SLOW (2 TOCKS)                                             */

                        if( POOP ) { POOPR ; }
                        psoP->myNameF( tinBaseP , idPortMeP , nnMeP ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    nicNameC nnMeP ;
                    ZE( countT , idPortMeP ) ;

                    psoP->etherF( tinBaseP , *((tin9S&)tinBaseP).pEtScratch ) ;
                    //etThread.traceF( tinBaseP , T("TASKdRIVENsERVER [cSession]:    ")+TF2(jobP.cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    //etThread.traceF( tinBaseP , T("preparing to service psoP"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                {
                else
                if( etThread ) { BLAMMO ; }
                sessionC& sessionP = jobP.sessions.registerConnectionF( tinBaseP , jobP.nnPeer , /*psttPeerP*/T("notQueried") ) ;

                __Z( psoP ) ;
                //etThread.traceF( tinBaseP , T("U:: tmcHttpServerWorkerF / after ungrab") ) ;

                jobP.sw_pso.ungrabF( tinBaseP ) ;
                socketC*& psoP = (socketC*&)(countT&)jobP.sw_pso ;
                jobP.lever_idSession = jobP.idSession ;

                //((tin9S&)tinBaseP).pc Utility[ 0 ] = 0 ;
                //((tin9S&)tinBaseP).pc Utility[ 1 ] = 0 ;
                //((tin9S&)tinBaseP).pc Utility[ 2 ] = 0 ;
                //((tin9S&)tinBaseP).pc Utility[ 3 ] = 0 ;

                //etThread.traceF( tinBaseP , T("grabbed jobP.sw_pso"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                jobP.sw_pso.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                //etThread.traceF( tinBaseP , T("grabbing jobP.sw_pso"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                //((tin9S&)tinBaseP).pc Utility[ 3 ] = ((countT*)&jobCopy)[ 2 ] ;
                //((tin9S&)tinBaseP).pc Utility[ 2 ] = ((countT*)&jobP)[ 2 ] ;
                //((tin9S&)tinBaseP).pc Utility[ 0 ] = 0x12345678 ;
                //etThread.traceF( tinBaseP , T("U:: tmcHttpServerWorkerF / before grabbing") ) ;

                TELL( "TASKdRIVENsERVER: setting up" )
                TESTsCRATCH ;

                etThread.osTimeNowF( tinBaseP , jobP.timeJobPopped1 , jobP.timeJobPopped2 ) ;

                taskDrivenServerJobS& jobP = *(taskDrivenServerJobS*)_pbaJob ;
            {
            else
            }
                //etThread.traceF( tinBaseP , T("doing nothing since !pbJob"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
            {
            if( !pbJob )

            stJobP.ungrabF( tinBaseP ) ;
            //etThread.traceF( tinBaseP , T("ungrabbed stJobP after popping a job"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

            stJobP >> pbJob ;
            byteT* pbJob = _pbaJob ;
            byteT _pbaJob[ sizeof( taskDrivenServerJobS ) ] ;

            //etThread.traceF( tinBaseP , T("tmcHttpServerWorkerF popping a job [jobCopy[2]]:    ")+TF2(((countT*)&jobCopy)[2],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            //taskDrivenServerJobS jobCopy = *(taskDrivenServerJobS*)&(countT&)stJobP[ 1 ] ; //U:: TO FIND A BUG
        {
        else
        else if( bQuitP ) stJobP.ungrabF( tinBaseP ) ;
        }
            stJobP.ungrabF( tinBaseP ) ;
            //etThread.traceF( tinBaseP , T("immediately ungrabbed stJobP because it is empty"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
        {
        if( !stJobP )

        //etThread.traceF( tinBaseP , T("grabbed stJobP"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
        stJobP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        etThread.traceF( tinBaseP , T("waited for a push to stJobP"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
        stJobP.waitF( tinBaseP ) ;
        etThread.traceF( tinBaseP , T("waiting for a push to stJobP"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
    {
    while( !bQuitP )

    countT& cWorkerP = *(countT*)pTaskP->c3 ;
    stackC& stJobP   = *(stackC*)pTaskP->c2 ;
    countT& bQuitP   = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )

TELL( "preparing for work" ) ;
/*1*/TASK( tmcHttpServerWorkerF )/*1*/


/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

