
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmcHttpServerWorkerF )

}
    dec02AM( cWorkerP ) ;
    etThread.osThreadSwitchingDesireF( tin0P , idDesireOld ) ;

    }
        }
            }
                }
                    }
                        DELzOMBIE( pDoomed ) ;
                        dec02AM( jobP.cSession ) ;
                        taskDrivenServerJobS* pDoomed = &jobP ;

                        //etRock.traceF( tin0P , tSayClientPrefix+T("DONE [cSession]:    ")+TF2(jobP.cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        /*etThread.delF( tin0P , psttPeerP ) ;*/

                        //etRock.traceF( tin0P , tSayClientPrefix+T("decremented cSession") ) ;
                        jobP.sw_cSessionWithPeer.ungrabF( tin0P ) ;
                        -- jobP.sw_cSessionWithPeer ;
                        jobP.lever_nnPeer = jobP.nnPeer ;
                        jobP.sw_cSessionWithPeer.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        jobP.sessions.unregisterConnectionF( tin0P , jobP.nnPeer ) ;
                        //etRock.traceF( tin0P , tSayClientPrefix+T("decrementing cSession") ) ;

                        }
                            jobP.sw_pso.ungrabF( tin0P ) ;
                            }
                                else                                                 __1
                                if( (countT)&psoP == (countT)&(countT&)jobP.sw_pso ) jobP.sw_pso.freeF( tin0P ) ;
                                _IO_
                            {
                            }
                                jobP.lever_idSession = jobP.idSession ;
                                _IO_
                            {
                            }
                                DEL( psoP ) ;
                                _IO_
                            {
                            }
                                jobP.sw_pso.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                _IO_
                            {

                            }
                                etRock.traceF( tin0P , tSayClientPrefix+T("called  etherDoHttpJobF [idPortMe,nnMe]:    ")+TF2(idPortMeP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnMeP) ) ;
                                etThread.etherDoHttpJobF( tin0P , jobP , psoP , sessionP , idPortMeP , nnMeP , nnGorillaOuterOk1 ) ;
                                etRock.traceF( tin0P , tSayClientPrefix+T("calling etherDoHttpJobF [idPortMe,nnMe]:    ")+TF2(idPortMeP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnMeP) ) ;
                                TN( tb4 , "    " ) ;
                                _IO_
                            {
                            etThread.osTimeNowF( tin0P , jobP.timeDoJob1 , jobP.timeDoJob2 ) ;

                            _IO_
                        {

                        TELL( "TASK: entering application code" )

                        }
                            /* }                                                                      */
                            /*     if( POOP ) { POOPR }                                               */
                            /*     }                                                                  */
                            /*         TELL( "returned from querying dns for peer name string" ) ;    */
                            /*         ((tin1S&)tin0P).pEtScratch->sockPsttHostF( tin0P , psttPeerP , nnPeerP ) ; */
                            /*         TELL( "querying dns for peer name string" ) ;                  */
                            /*     {                                                                  */
                            /*     if( nnPeerP.pcId[ 0 ] )                                            */
                            /* {                                                                      */
                            /* ZE( strokeS* , psttPeerP ) ;                                           */
                            /* THIS IS TOO SLOW (2 TOCKS)                                             */

                            if( POOP ) { POOPR ; }
                            psoP->myNameF( tin0P , idPortMeP , nnMeP ) ;
                            SCOOPS
                        {
                        IFsCRATCHoK
                        nicNameC nnMeP ;
                        ZE( countT , idPortMeP ) ;

                        psoP->etherF( tin0P , *((tin1S&)tin0P).pEtScratch ) ;
                        //etRock.traceF( tin0P , tSayClientPrefix+T("TASKdRIVENsERVER [cSession]:    ")+TF2(jobP.cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //etRock.traceF( tin0P , tSayClientPrefix+T("preparing to service psoP") ) ;
                    {
                    else
                    if( etThread ) { BLAMMO ; }
                    sessionC& sessionP = jobP.sessions.registerConnectionF( tin0P , jobP.nnPeer , /*psttPeerP*/T("notQueried") ) ;

                    __Z( psoP ) ;
                    //etRock.traceF( tin0P , tSayClientPrefix+T("U:: tmcHttpServerWorkerF / after ungrab") ) ;

                    jobP.sw_pso.ungrabF( tin0P ) ;
                    socketC*& psoP = (socketC*&)(countT&)jobP.sw_pso ;
                    jobP.lever_idSession = jobP.idSession ;

                    //((tin1S&)tin0P).pc Utility[ 0 ] = 0 ;
                    //((tin1S&)tin0P).pc Utility[ 1 ] = 0 ;
                    //((tin1S&)tin0P).pc Utility[ 2 ] = 0 ;
                    //((tin1S&)tin0P).pc Utility[ 3 ] = 0 ;

                    //etRock.traceF( tin0P , tSayClientPrefix+T("grabbed jobP.sw_pso") ) ;
                    jobP.sw_pso.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                    //etRock.traceF( tin0P , tSayClientPrefix+T("grabbing jobP.sw_pso") ) ;

                    // //etRock.traceF( tin0P , tSayClientPrefix+T("before grabbing") ) ;

                    TELL( "TASKdRIVENsERVER: setting up" )
                    TESTsCRATCH ;

                    etThread.osTimeNowF( tin0P , jobP.timeJobPopped1 , jobP.timeJobPopped2 ) ;

                    etRock.traceF( tin0P , tSayClientPrefix+T("beginning to do a job") ) ;

                    //CONoUTrAW5( "\r\n||PULL||:  [idThread,pstt]:    " , ((tin1S&)tin0P).glass.idThread , "    " , jobP.psttSayClientPrefix , "" ) ;

                    TN( tSayClientPrefix , jobP.psttSayClientPrefix ) ;
                    taskDrivenServerJobS& jobP = *(taskDrivenServerJobS*)_pbaJob ;
                {
                else
                }
                    etRock.traceF( tin0P , T("doing nothing since !pbJob") ) ;
                {
                if( !pbJob )

                stJobP.ungrabF( tin0P ) ;
                etRock.traceF( tin0P , T("ungrabbing stJobP after popping a job") ) ;

                stJobP >> pbJob ;
                byteT* pbJob = _pbaJob ;
                byteT _pbaJob[ sizeof( taskDrivenServerJobS ) ] ;
            {
            else
            }
                break ;
                stJobP.ungrabF( tin0P ) ;
                //etRock.traceF( tin0P , T("ungrabbing stJobP because empty") ) ;
           {
            if( !stJobP || bQuitP )

            //etRock.traceF( tin0P , T("grabbed stJobP") ) ;
            stJobP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        {
        while( !bQuitP )

        //etRock.traceF( tin0P , T("waited for a push to stJobP") ) ;
        stJobP.waitF( tin0P ) ;
        //etRock.traceF( tin0P , T("waiting for a push to stJobP") ) ;
    {
    while( !bQuitP )

    nicNameC nnGorillaOuterOk1 = socketC::nicNameIF( tin0P , etThread , tNnGorillaOuter ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        }
            tNnGorillaOuter = T(psttEat) ;
            etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        else
        if( !psttEat ) etRock.traceF( tin0P , T("!exception / missing setting [key]:    ")+tSettingKey ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , tSettingKey  ) ; ___( psttEat ) ;
        TN( tSettingKey , "!ipdos.http.gorilla.go1" ) ;
    {
    TN( tNnGorillaOuter , "10.0.9.9" ) ;    // A LEGAL VALUE THAT IS A "DON'T CARE" AS IT WILL LIKELY NEVER BE USED
    //CS:CODEsYNC: 3600212d 33000104 3300005b

    etherC& etRock = etherC::etRockIF( tin0P ) ;

    const countT idDesireOld = etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_PUSHY ) ;

    countT& cWorkerP = *(countT*)pTaskP->c3 ;
    stackC& stJobP   = *(stackC*)pTaskP->c2 ;
    countT& bQuitP   = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )

TELL( "preparing for work" ) ;
/*1*/TASK( tmcHttpServerWorkerF )/*1*/


/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

