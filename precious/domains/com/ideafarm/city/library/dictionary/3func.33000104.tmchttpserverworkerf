
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmcHttpServerWorkerF )

}
    dec02AM( cWorkerP ) ;
    etThread.osThreadSwitchingDesireF( tin0P , idDesireOld ) ;

    }
        }
            }
                }
                    }
                        DELzOMBIE( pDoomed ) ;
                        dec02AM( jobP.cSession ) ;
                        taskDrivenServerJobS* pDoomed = &jobP ;

                        //etRock.traceF( tin0P , T("DONE [cSession]:    ")+TF2(jobP.cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        /*etThread.delF( tin0P , psttPeerP ) ;*/

                        //etRock.traceF( tin0P , T("decremented cSession")  , flTRACE_FORCEnOsILENCE /*, flTRACE_HOMEeCHOdEADMAN1 | flTRACE_ECHOoNLY */ ) ;
                        jobP.sw_cSessionWithPeer.ungrabF( tin0P ) ;
                        -- jobP.sw_cSessionWithPeer ;
                        jobP.lever_nnPeer = jobP.nnPeer ;
                        jobP.sw_cSessionWithPeer.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        jobP.sessions.unregisterConnectionF( tin0P , jobP.nnPeer ) ;
                        //etRock.traceF( tin0P , T("decrementing cSession")  , flTRACE_FORCEnOsILENCE /*, flTRACE_HOMEeCHOdEADMAN1 | flTRACE_ECHOoNLY */ ) ;

                        }
                            jobP.sw_pso.ungrabF( tin0P ) ;
                            }
                                else                                                 __1
                                if( (countT)&psoP == (countT)&(countT&)jobP.sw_pso ) jobP.sw_pso.freeF( tin0P ) ;
                                _IO_
                            {
                            }
                                jobP.lever_idSession = jobP.idSession ;
                                _IO_
                            {
                            }
                                DEL( psoP ) ;
                                _IO_
                            {
                            }
                                jobP.sw_pso.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                _IO_
                            {

                            }
                                //etRock.traceF( tin0P , T("called etherDoHttpJobF")  , flTRACE_FORCEnOsILENCE /*, flTRACE_HOMEeCHOdEADMAN1 | flTRACE_ECHOoNLY */ ) ;
                                etThread.etherDoHttpJobF( tin0P , jobP , psoP , sessionP , idPortMeP , nnMeP ) ;
                                //etRock.traceF( tin0P , T("calling etherDoHttpJobF")  , flTRACE_FORCEnOsILENCE /*, flTRACE_HOMEeCHOdEADMAN1 | flTRACE_ECHOoNLY */ ) ;
                                _IO_
                            {
                            etThread.osTimeNowF( tin0P , jobP.timeDoJob1 , jobP.timeDoJob2 ) ;

                            _IO_
                        {

                        TELL( "TASK: entering application code" )

                        }
                            /* }                                                                      */
                            /*     if( POOP ) { POOPR }                                               */
                            /*     }                                                                  */
                            /*         TELL( "returned from querying dns for peer name string" ) ;    */
                            /*         ((tin1S&)tin0P).pEtScratch->sockPsttHostF( tin0P , psttPeerP , nnPeerP ) ; */
                            /*         TELL( "querying dns for peer name string" ) ;                  */
                            /*     {                                                                  */
                            /*     if( nnPeerP.pcId[ 0 ] )                                            */
                            /* {                                                                      */
                            /* ZE( strokeS* , psttPeerP ) ;                                           */
                            /* THIS IS TOO SLOW (2 TOCKS)                                             */

                            if( POOP ) { POOPR ; }
                            psoP->myNameF( tin0P , idPortMeP , nnMeP ) ;
                            SCOOPS
                        {
                        IFsCRATCHoK
                        nicNameC nnMeP ;
                        ZE( countT , idPortMeP ) ;

                        psoP->etherF( tin0P , *((tin1S&)tin0P).pEtScratch ) ;
                        //etRock.traceF( tin0P , T("TASKdRIVENsERVER [cSession]:    ")+TF2(jobP.cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //etRock.traceF( tin0P , T("preparing to service psoP")  , flTRACE_FORCEnOsILENCE /*, flTRACE_HOMEeCHOdEADMAN1 | flTRACE_ECHOoNLY */ ) ;
                    {
                    else
                    if( etThread ) { BLAMMO ; }
                    sessionC& sessionP = jobP.sessions.registerConnectionF( tin0P , jobP.nnPeer , /*psttPeerP*/T("notQueried") ) ;

                    __Z( psoP ) ;
                    //etRock.traceF( tin0P , T("U:: tmcHttpServerWorkerF / after ungrab") ) ;

                    jobP.sw_pso.ungrabF( tin0P ) ;
                    socketC*& psoP = (socketC*&)(countT&)jobP.sw_pso ;
                    jobP.lever_idSession = jobP.idSession ;

                    //((tin1S&)tin0P).pc Utility[ 0 ] = 0 ;
                    //((tin1S&)tin0P).pc Utility[ 1 ] = 0 ;
                    //((tin1S&)tin0P).pc Utility[ 2 ] = 0 ;
                    //((tin1S&)tin0P).pc Utility[ 3 ] = 0 ;

                    //etRock.traceF( tin0P , T("grabbed jobP.sw_pso")  , flTRACE_FORCEnOsILENCE /*, flTRACE_HOMEeCHOdEADMAN1 | flTRACE_ECHOoNLY */ ) ;
                    jobP.sw_pso.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                    //etRock.traceF( tin0P , T("grabbing jobP.sw_pso")  , flTRACE_FORCEnOsILENCE /*, flTRACE_HOMEeCHOdEADMAN1 | flTRACE_ECHOoNLY */ ) ;

                    //((tin1S&)tin0P).pc Utility[ 3 ] = ((countT*)&jobCopy)[ 2 ] ;
                    //((tin1S&)tin0P).pc Utility[ 2 ] = ((countT*)&jobP)[ 2 ] ;
                    //((tin1S&)tin0P).pc Utility[ 0 ] = 0x12345678 ;
                    // /**/etRock.traceF( tin0P , T("before grabbing") , flTRACE_FORCEnOsILENCE ) ;

                    TELL( "TASKdRIVENsERVER: setting up" )
                    TESTsCRATCH ;

                    etThread.osTimeNowF( tin0P , jobP.timeJobPopped1 , jobP.timeJobPopped2 ) ;

                    taskDrivenServerJobS& jobP = *(taskDrivenServerJobS*)_pbaJob ;
                    //etRock.traceF( tin0P , T("beginning to do a job") , flTRACE_FORCEnOsILENCE ) ;
                {
                else
                }
                    /**/etRock.traceF( tin0P , T("doing nothing since !pbJob")  , flTRACE_FORCEnOsILENCE /*, flTRACE_HOMEeCHOdEADMAN1 | flTRACE_ECHOoNLY */ ) ;
                {
                if( !pbJob )

                stJobP.ungrabF( tin0P ) ;
                //etRock.traceF( tin0P , T("ungrabbing stJobP after popping a job")  , flTRACE_FORCEnOsILENCE /*, flTRACE_HOMEeCHOdEADMAN1 | flTRACE_ECHOoNLY */ ) ;

                stJobP >> pbJob ;
                byteT* pbJob = _pbaJob ;
                byteT _pbaJob[ sizeof( taskDrivenServerJobS ) ] ;

                //etRock.traceF( tin0P , T("tmcHttpServerWorkerF popping a job [jobCopy[2]]:    ")+TF2(((countT*)&jobCopy)[2],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                //taskDrivenServerJobS jobCopy = *(taskDrivenServerJobS*)&(countT&)stJobP[ 1 ] ; //U:: TO FIND A BUG
            {
            else
            }
                break ;
                stJobP.ungrabF( tin0P ) ;
            {
            if( !stJobP || bQuitP )

            //etRock.traceF( tin0P , T("grabbed stJobP")  , flTRACE_FORCEnOsILENCE /*, flTRACE_HOMEeCHOdEADMAN1 | flTRACE_ECHOoNLY */ ) ;
            stJobP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        {
        while( !bQuitP )

        //etRock.traceF( tin0P , T("waited for a push to stJobP")  , flTRACE_FORCEnOsILENCE /*, flTRACE_HOMEeCHOdEADMAN1 | flTRACE_ECHOoNLY */ ) ;
        stJobP.waitF( tin0P ) ;
        //etRock.traceF( tin0P , T("waiting for a push to stJobP")  , flTRACE_FORCEnOsILENCE /*, flTRACE_HOMEeCHOdEADMAN1 | flTRACE_ECHOoNLY */ ) ;
    {
    while( !bQuitP )

    etherC& etRock = etherC::etRockIF( tin0P ) ;

    const countT idDesireOld = etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_PUSHY ) ;

    countT& cWorkerP = *(countT*)pTaskP->c3 ;
    stackC& stJobP   = *(stackC*)pTaskP->c2 ;
    countT& bQuitP   = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )

TELL( "preparing for work" ) ;
/*1*/TASK( tmcHttpServerWorkerF )/*1*/


/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

