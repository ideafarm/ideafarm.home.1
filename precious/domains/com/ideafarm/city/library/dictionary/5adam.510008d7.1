
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
ether.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK >> 0 ) ;

        }
            nnSubnet48DecoyBgpLath = nnSubnet48DecoyBgp ;
            nnSubnet48DataLath     = nnSubnet48Data     ;
            nnSubnet48ControlLath  = nnSubnet48Control  ;

            }
                }
                    }
                        etRock.traceF( tin0P , T("!exception / could not write to router share ; ignoring [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLong ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    else
                    }
                        etRock.traceF( tin0P , T("i wrote aok to router share [tLong]:    ")+tLong ) ;
                        bOk = 1 ;
                    {
                    if( !POOP )
                    ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , tSay , tSay.csF( tin0P ) ) ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                ZE( boolT , bOk ) ;

                tSay += tImage5 ;

                etThread.traceF( tin0P , T("subnets to advertise   (end)" DASH79) ) ;

                }
                    while( ~hWalk ) ;
                    }
                        tSay += tImage3+T(nnWo)+tImage4BitsVia+tEpochPlate+tImage4DecoyBgp ;
                        etThread.traceF( tin0P , T("decoyBgp    [nnWo]:    ")+T(nnWo)+T("/48") ) ;
                        nicNameC& nnWo = (nicNameC&)stNnSubnetSayDecoyBgp.downF( tin0P , hWalk ) ;
                        tEpochPlate = TF2(epochPlate++,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
                    {
                    do
                    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    countT epochPlate = epoch + 1 - stNnSubnetSayDecoyBgp ;
                {
                if( stNnSubnetSayDecoyBgp )

                }
                    while( ~hWalk ) ;
                    }
                        tSay += tImage3+T(nnWo)+tImage4BitsVia+tEpochPlate+tImage4Data ;
                        etThread.traceF( tin0P , T("data        [nnWo]:    ")+T(nnWo)+T("/48") ) ;
                        nicNameC& nnWo = (nicNameC&)stNnSubnetSayData.downF( tin0P , hWalk ) ;
                        tEpochPlate = TF2(epochPlate++,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
                    {
                    do
                    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    countT epochPlate = epoch + 1 - stNnSubnetSayData ;
                {
                if( stNnSubnetSayData )

                }
                    while( ~hWalk ) ;
                    }
                        tSay += tImage3+T(nnWo)+tImage4BitsVia+tEpochPlate+tImage4Control ;
                        etThread.traceF( tin0P , T("control     [nnWo]:    ")+T(nnWo)+T("/48") ) ;
                        nicNameC& nnWo = (nicNameC&)stNnSubnetSayControl.downF( tin0P , hWalk ) ;
                        tEpochPlate = TF2(epochPlate++,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
                    {
                    do
                    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    countT epochPlate = epoch + 1 - stNnSubnetSayControl ;
                {
                if( stNnSubnetSayControl )
                etThread.traceF( tin0P , T("subnets to advertise (begin)" DASH79) ) ;
                TN( tEpochPlate , "" ) ;

                TN( tSay , "" ) ; tSay = tImage1+tBgpPassword+tImage2 ;
            {
            if( cChange )

            }
                stNnSubnetSayDecoyBgp.purgeF( tin0P , CePOCHSkEEP ) ;
                stNnSubnetSayDecoyBgp << nnSubnet48DecoyBgp ;
                cChange ++ ;
            {
            if( nnSubnet48DecoyBgpLath != nnSubnet48DecoyBgp )
            }
                stNnSubnetSayData.purgeF( tin0P , CePOCHSkEEP ) ;
                stNnSubnetSayData << nnSubnet48Data ;
                cChange ++ ;
            {
            if( nnSubnet48DataLath != nnSubnet48Data )
            }
                stNnSubnetSayControl.purgeF( tin0P , CePOCHSkEEP ) ;
                stNnSubnetSayControl << nnSubnet48Control ;
                cChange ++ ;
            {
            if( nnSubnet48ControlLath != nnSubnet48Control )
            ZE( countT , cChange ) ;

            etThread.traceF( tin0P , T("addNicAddressCBF [epoch,nnNowDecoyBgp,nnAdvertise]:    ")+TF2(epoch,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnNowDecoyBgp)+tb4+T(nnSubnet48DecoyBgp) , flTRACE_NOpREFIX ) ;
            etThread.traceF( tin0P , T("addNicAddressCBF [epoch,nnNowData,nnAdvertise]:        ")+TF2(epoch,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnNowData    )+tb4+T(nnSubnet48Data    ) , flTRACE_NOpREFIX ) ;
            etThread.traceF( tin0P , T("addNicAddressCBF [epoch,nnNowControl,nnAdvertise]:     ")+TF2(epoch,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnNowControl )+tb4+T(nnSubnet48Control ) , flTRACE_NOpREFIX ) ;

            nicNameC nnSubnet48DecoyBgp  = nnNowDecoyBgp(    0x30 ) ;
            nicNameC nnSubnet48Data      = nnNowData(        0x30 ) ;
            nicNameC nnSubnet48Control   = nnNowControl(     0x30 ) ;
            const nicNameC nnNowDecoyBgp = woSub.nnF( tin0P , epoch , fnu2 , ifcIDtYPErOUTE_DECOYbGPtABLE ) ;
            const nicNameC nnNowData     = woSub.nnF( tin0P , epoch                                       ) ;
            const nicNameC nnNowControl  = woSub.nnF( tin0P , epoch , fnu1 , ifcIDtYPErOUTE_CONTROL       ) ;
            ideaNetIpv6FieldsS fnu2 ;
            ideaNetIpv6FieldsS fnu1 ;

            epochLath = epoch ;
        {
        if( epochLath != epoch )
        countT epoch = timeN1 >> BITSsHIFTiDEAnETePOCH ;

        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;

        }
            etThread.traceF( tin0P , T("addNicAddressCBF [       nnMax] :          ")+tMax , flTRACE_NOpREFIX ) ;
            etThread.traceF( tin0P , T("addNicAddressCBF [       nnMin] :          ")+tMin , flTRACE_NOpREFIX ) ;
        {
        if( !epochLath )
    {
    while( !ether )

    etThread.osThreadF( TaRG2cBsTACK( tmEatGeigerEventsF , CBsTACKmIN << 1 ) , (countT)&stNnSubnetSayControl , (countT)&stNnSubnetSayData , (countT)&stNnSubnetSayDecoyBgp ) ;

    stackC               stNnSubnetSayDecoyBgp( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_nicNameC ) ;
    stackC               stNnSubnetSayData(     tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_nicNameC ) ;
    stackC               stNnSubnetSayControl(  tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_nicNameC ) ;
    nicNameC             nnSubnet48DecoyBgpLath ;
    nicNameC             nnSubnet48DataLath     ;
    nicNameC             nnSubnet48ControlLath  ;
    ideaNetSubscriptionC woSub( tin0P , etThread , 1 , 1 , T("foo") , T("goo@hoo") ) ;
    sleepC               s( tin0P , TAG( TAGiDnULL ) ) ;
    ZE( countT , epochLath ) ;
    TN( tLong , "////10.0.4.1/bird/bird.conf" ) ;
    TN( tMax , "2602:FF03:0FFF:FFFF:FFFF:FFFF:FFFF:FFFF" ) ;
    TN( tMin , "2602:FF03:0000::" ) ;
    TN( tDash , DASH127 ) ;
    TN( tFileSuffix , "/48\r\n" ) ;
    TN( tFilePrefix , "- " ) ;
    TN( tb4 , "    " ) ;

    TN( tArgsBirdConfigure , "" ) ; tArgsBirdConfigure = T("-batch -l root -pw ")+tRouterPassword+T(" 10.0.4.1 \"birdc configure\"") ;

    }
        etThread.delF( tin0P , psttv ) ;
        tBgpPassword = T(psttv) ;
        ZE( strokeS* , psttv ) ; etThread.querySettingF( tin0P , psttv , T("!ipdos.ideanet.bgp.password")  ) ; ___( psttv ) ;
    {
    TN( tBgpPassword , "" ) ;

    }
        etThread.delF( tin0P , psttv ) ;
        tRouterPassword = T(psttv) ;
        ZE( strokeS* , psttv ) ; etThread.querySettingF( tin0P , psttv , T("!ipdos.ideanet.router.password")  ) ; ___( psttv ) ;
    {
    TN( tRouterPassword , "" ) ;

    ) ;

        "}\n"
        "    scan time 5 ;\n"
        "{\n"
        "protocol device\n"
        "\n"
        "}\n"

    TN( tImage5 ,

    ) ;

        "    DECOYbGP\n"

    TN( tImage4DecoyBgp ,

    ) ;

        "    DATA\n"

    TN( tImage4Data ,

    ) ;

        "    CONTROL\n"

    TN( tImage4Control ,

    ) ;

        "/48 via " postROUTERiPV6oUTER " ;    #    EPOCH    "

    TN( tImage4BitsVia ,

    ) ;

        "    route "

    TN( tImage3 ,

    ) ;

        //"    route ::/0 blackhole { preference 0 ; } ;\n"
        //"    route 2602:ff03::/36 blackhole { preference = 0 ; } ;\n"
        "    ipv6 ;\n"
        "{\n"
        "protocol static\n"
        "\n"
        "}\n"
        "    } ;\n"
        "        export all  ;\n"
        "        import none ;\n"
        "    ipv6 {\n"
        "    graceful restart on ;\n"
        "    multihop 2 ;\n"
        "\" ;\n"

    TN( tImage2 ,

    ) ;

        "    password \""
        "    neighbor       2001:19f0:ffff::1                       as      64515 ;\n"
        "    source address " postROUTERiPV6oUTER "               ;\n"
        "    local          " postROUTERiPV6oUTER " as 4288000334 ;\n"
        "    description    \"ideanet\" ;\n"
        "protocol bgp vultr {\n"
        "\n"
        "protocol kernel { ipv6 { export all ; } ; }\n"
        "\n"
        "debug protocols all ;\n"
        "\n"
        "router id " postROUTERiPV4oUTER " ;\n"
        "\n"
        "log \"/tmp/bird.log\" all ;\n"
        "\n"

    TN( tImage1 ,

    etherC& etRock = etherC::etRockIF( tin0P ) ;
{
if( pTaskP )
TASK( tmWorkF )

DONE( tmEatGeigerEventsF )
}
    }
        if( bDelete1 ) etThread.delF( tin0P , *(byteT**)&pbi1 ) ;

        }
            if( bDelete2 ) etThread.delF( tin0P , *(byteT**)&pbi2 ) ;
            }
                head.traceF( tin0P , tSay ) ;

                if( bDecoyBgp )   tSay += T("    DECOYbGP") ;
                if( bData     )   tSay += T("    DATA"    ) ;
                if( bControl  )   tSay += T("    CONTROL" ) ;
                TN( tSay , "" ) ; tSay  = T(nnTarget      ) ;

                stNnSubnetSayDecoyBgpP.ungrabF( tin0P ) ;
                }
                    while( ~hWalk ) ;
                    }
                        }
                            break ;
                            cNewDecoyHits ++ ;
                            bDecoyBgp = 1 ;
                        {
                        if( nnWo == nnTarget )
                        nicNameC& nnWo = (nicNameC&)stNnSubnetSayDecoyBgpP.downF( tin0P , hWalk ) ;
                    {
                    do
                    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stNnSubnetSayDecoyBgpP )
                stNnSubnetSayDecoyBgpP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                ZE( boolT , bDecoyBgp ) ;

                stNnSubnetSayDataP.ungrabF( tin0P ) ;
                }
                    while( ~hWalk ) ;
                    }
                        }
                            break ;
                            bData = 1 ;
                        {
                        if( nnWo == nnTarget )
                        nicNameC& nnWo = (nicNameC&)stNnSubnetSayDataP.downF( tin0P , hWalk ) ;
                    {
                    do
                    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stNnSubnetSayDataP )
                stNnSubnetSayDataP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                ZE( boolT , bData ) ;

                stNnSubnetSayControlP.ungrabF( tin0P ) ;
                }
                    while( ~hWalk ) ;
                    }
                        }
                            break ;
                            bControl = 1 ;
                        {
                        if( nnWo == nnTarget )
                        nicNameC& nnWo = (nicNameC&)stNnSubnetSayControlP.downF( tin0P , hWalk ) ;
                    {
                    do
                    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stNnSubnetSayControlP )
                stNnSubnetSayControlP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                ZE( boolT , bControl ) ;

                nicNameC  nnSubnetTarget = nnTarget( 48 ) ;
                nicNameC& nnTarget       = *(nicNameC*)pbi2 ;
            {
            if( cbi2 == sizeof( nicNameC ) )
            boolT bDelete2 = bksGeiger.readF( tin0P , pbi2 , cbi2 , hRead ) ;
            countT cbi2 = sizeof( nicNameC ) ;
            ZE( const byteT* , pbi2 ) ;

            }
                cNewDecoyHits = 0 ;

                }
                    etThread.traceF( tin0P , T("detected attack that is using bgp table [cNewDecoyHits]:    ")+TF2(cNewDecoyHits,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( cNewDecoyHits > TUCK )

                epochLath  = epoch ;
            {
            if( epochLath != epoch )

            countT epoch = head.timeEvent1 >> BITSsHIFTiDEAnETePOCH ;
        {
        if( head.cbBodyEvent == sizeof( nicNameC ) )
        geigerEventHeadS& head = *(geigerEventHeadS*)pbi1 ;

        }
            continue ;
            ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
            hRead = hReadSave ;
        {
        if( !pbi1 || cbi1 != cbi1Save )

        boolT bDelete1 = bksGeiger.readF( tin0P , pbi1 , cbi1 , hRead ) ;
        ZE( const byteT* , pbi1 ) ;

        handleC hReadSave = hRead ;
        countT cbi1Save = cbi1 ;
        countT cbi1 = sizeof( geigerEventHeadS ) ;
    {
    while( !ether )
    ZE( countT , cNewDecoyHits ) ;
    ZE( countT , epochLath ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    handleC hRead( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
    TN( tn  , ""     ) ;
    TN( tb4 , "    " ) ;

    booksC bksGeiger( tin0P , TAG( TAGiDnULL ) , "geiger" ) ;

    stackC& stNnSubnetSayDecoyBgpP = *(stackC*)pTaskP->c3 ;
    stackC& stNnSubnetSayDataP     = *(stackC*)pTaskP->c2 ;
    stackC& stNnSubnetSayControlP  = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmEatGeigerEventsF )

#define postROUTERiPV6oUTER "2001:19f0:ac00:4406:5400:05ff:fee9:27e6"
#define postROUTERiPV4oUTER "149.28.204.105"

#define CePOCHSkEEP ( 0x8 )

// WITH EPOCH == TICK, USED 0x3
// WITH EPOCH == 85_9 FOREIGN SECONDS, USED 0x8 AOK
// MUST KEEP EACH ROUTE FOR ENOUGH TIME TO NOT TRIGGER ROUTE FLAPPING DETECTION ; FUTURE CODE CAN USE THESE ROUTES AS ALTERNATIVES DURING AN ATTACK

/*1*/WAKEhIDE( "ifcIDaDAM_IDEAnETcONTROLrOUTER" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
