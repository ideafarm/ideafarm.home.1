
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.strokeF( tin0P , T("\f") ) ;

}
    ++ s ; ether.osSleepF( tin0P , TOCK * 4 ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    etThread.strokeF( tin0P , ( ++ idCycle ) % 2 ? tSay : tSayErase ) ;
{
while( !ether )
ZE( countT , idCycle ) ;

TN( tSayErase , "" ) ; tSayErase = tSay + T("\f") ;

;
    //S2(0,scOld_POPfRAME)
        //S2(0,scOld_POPfRAME)
            S2(0,scOld_POPfRAME)
                S2(0,scOld_POPfRAME)+
                    S2(0,scOld_WRAPoFF)+
                    S2(' ',sc_NULL)+T("g")+
                    S2(' ',sc_NULL)+T("d")+button2+
                    S2(' ',sc_NULL)+button1+
                    T("a")+
                    S2(0,scOld_WRAPoN)+
                S3(17.0,scOld_mmFRAMEcELLS,8.0)+
                S3(1.0,scOld_mmPADfORsADAMfRAMES,2.0)+
            S3(2,scOld_ccFRAMEfORsADAMfRAMES,2)+
        //S3(1.0,scOld_mmFRAMEtO,1.0)+                     //WRAPPING REFERENCE FRAME
    //S3(0.66667,scOld_mmFRAMEtO,0.66667)+
    //S2(0,scOld_POPfRAMEdETACH)+
    //S3(0.33333,scOld_mmMOVEtO,0.33333)+
    //S2(0,scOld_FRAMEdETACH)+
    T("")+
tSay = 
TN( tSay , "" ) ;

win.baton.ungrabF( tin0P ) ;
win.cAnimateArg = (countT)&c4a ;
win.pAnimateCBF = animateCBF ;
win.baton.grabF( tin0P , TAG( TAGiDnULL ) ) ;
windowOldC& win = *thirdC::pWinRootIF() ;

count4S c4a( (countT)&button1Inner , (countT)&button2Inner , (countT)&button1 , (countT)&button2 ) ;

tcButtonC button2(      tin0P , tcStateCBF      , 0 , flFeatures      , 0 , T("e")+S2(' ',sc_NULL)+button2Inner+S2(' ',sc_NULL)+T("f") , 1 ) ;
tcButtonC button1(      tin0P , tcStateCBF      , 0 , flFeatures      , 0 , T("b")+S2(' ',sc_NULL)+button1Inner+S2(' ',sc_NULL)+T("c") , 1 ) ;
tcButtonC button2Inner( tin0P , tcStateInnerCBF , 0 , flFeaturesInner , 0 , T("grape")                       , 1 ) ;
tcButtonC button1Inner( tin0P , tcStateInnerCBF , 0 , flFeaturesInner , 0 , T("apple")                       , 1 ) ;
flagsT flFeatures      = flFeaturesCore ;
flagsT flFeaturesInner = flFeaturesCore /*& ~( F(flTCfEATURE_DRAGGABLE) )*/ ;
flagsT flFeaturesCore  = flTCfEATURE_DRAGGABLE | flTCfEATURE_FLYOVER | flTCfEATURE_FLYOVERhIGHLIGHT | flTCfEATURE_MOUSE | flTCfEATURE_HOTkEY | flTCfEATURE_FRAME ;

TODO

}
    if( etherP && wP.bDoomed ) ;
    }
        button2.setF(      tin0P , T("")+S3(2.0,scOld_mmPADfORsADAMfRAMES,2.0)+S3(9.0,scOld_mmFRAMEcELLS,1.0)+TP("",8)+S2(0,scOld_cPUSHrIPPLES)+T(pb2)+S2(0,scOld_POPrIPPLES)+S2(0,scOld_POPfRAME) ) ;
        button1.setF(      tin0P , T("")+S3(2.0,scOld_mmPADfORsADAMfRAMES,2.0)+S3(9.0,scOld_mmFRAMEcELLS,1.0)+TP("",8)+S2(0,scOld_cPUSHrIPPLES)+T(pb2)+S2(0,scOld_POPrIPPLES)+S2(0,scOld_POPfRAME) ) ;
        button2Inner.setF( tin0P , T("")+S3(2.0,scOld_mmPADfORsADAMfRAMES,2.0)+S3(6.0,scOld_mmFRAMEcELLS,1.0)+TP("",5)+S2(0,scOld_cPUSHrIPPLES)+T(pb2)+S2(0,scOld_POPrIPPLES)+S2(0,scOld_POPfRAME) ) ;
        button1Inner.setF( tin0P , T("")+S3(2.0,scOld_mmPADfORsADAMfRAMES,2.0)+S3(6.0,scOld_mmFRAMEcELLS,1.0)+TP("",5)+S2(0,scOld_cPUSHrIPPLES)+T(pb2)+S2(0,scOld_POPrIPPLES)+S2(0,scOld_POPfRAME) ) ;
        tcButtonC& button2      = *(tcButtonC*)c4a.c4 ;
        tcButtonC& button1      = *(tcButtonC*)c4a.c3 ;
        tcButtonC& button2Inner = *(tcButtonC*)c4a.c2 ;
        tcButtonC& button1Inner = *(tcButtonC*)c4a.c1 ;
        count4S& c4a = *(count4S*)cArgP ;

        byteT pb2[] = { (byteT)( idIn % 2 ? 'H' : 'I' ) , 0 } ;

        countT idIn = idCycleP / PERIOD ;
    {
    if( !( idCycleP % PERIOD ) )
{
voidT animateCBF( tin0S& tin0P , etherC& etherP , paperBackC& backP , const countT idCycleP , const countT cArgP )

#define PERIOD 0x1

}
    if( ((tin1S&)tin0P).fingerprint && etherP && cArgP && idTypeCallP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;

    }
        }
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
    {
    switch( idTypeCallP )
{
voidT tcStateCBF( tin0S& tin0P , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

}
    if( ((tin1S&)tin0P).fingerprint && etherP && cArgP && idTypeCallP && pcNotesP && flTcStateNewP && flTcStateOldP ) ;

    }
        }
            FIREmYSELF ;
            //LOGrAW( T("fired by ")+T(processGlobal4I.mapSadamCall(idTypeCallP))+T("\r\n") ) ;
        {
        case ifcIDtYPEsTROKEcALLbACK_HOTkEY :
        }
            if( idTool != ifcIDtYPEtOOL_MOUSEbUTTONlEFT || idAction != ifcIDtYPEaCTION_DOWN ) break ;

            const countT& idAction = pcNotesP[ 3 ] ;
            const countT& idTool   = pcNotesP[ 2 ] ;
        {
        case ifcIDtYPEsTROKEcALLbACK_MOUSE :
    {
    switch( idTypeCallP )
{
voidT tcStateInnerCBF( tin0S& tin0P , etherC& etherP , const countT cArgP , const countT idTypeCallP , const countT idEventP , const countT* const pcNotesP , const flagsT flTcStateNewP , const flagsT flTcStateOldP )

/*1*/WAKEsHOW( "example.other.snip.00300d3.tcButtonC.nested.wrapped.adjacent" )/*1*/
/**/
*/
this example tests nesting, wrapping, and exact positioning so that, e.g., sadam frames are adjacent
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

