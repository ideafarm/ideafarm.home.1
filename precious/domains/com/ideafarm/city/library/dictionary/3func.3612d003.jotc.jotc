
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //etherC::etRockIF( tinP ).traceF( tinP , T("jotC + [this,tag,name]: ")+TF2((countT)this,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(tagHighNibble,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+T(postNameP) ) ;

    tinP.pEther->delF( tinP , pcpIdBookSizePairs ) ;
    }
        idMaxWritten += cJots ;
        }
            pcc += 2 ;
            cJots += cbUsed / sizeof( handle0111C ) ;

            idBookLath = idBook ;
            __( cbUsed % sizeof( handle0111C ) ) ;
            __( idBook - 1 - idBookLath ) ;
            countT cbUsed = pcc[ 1 ] ;
            countT idBook = pcc[ 0 ] ;
        {
        while( cBooks -- )
        countT* pcc = pcpIdBookSizePairs + 1 ;
        countT cBooks = *pcpIdBookSizePairs ;
        ZE( countT , idBookLath ) ;
        ZE( countT , cJots ) ;
    {
    if( pcpIdBookSizePairs )

    bksIndex.cbEachBookF( tinP , pcpIdBookSizePairs ) ;
    ZE( countT* , pcpIdBookSizePairs ) ;

    idMaxWritten = idLathRead = tagHighNibble ; // SEE jotC::writeF FOR THE SPECIFICATION OF THE BIT LAYOUT OF AN idJot VALUE

    }
        tagHighNibble = ( offr << sizeof( countT ) * SB - 4 ) | BM_HIGH ;

        }
            BLAMMO ;
        {
        if( offr == CsLOTSjOTrEGISTRY )
        }
            }
                break ;
                idSlotJot = 1 + offr ;
                tinP.ppJot[ offr ] = this ;
            {
            if( !tinP.ppJot[ offr ] )
        {
        for( ; offr < CsLOTSjOTrEGISTRY ; offr ++ )
        ZE( countT , offr ) ;
    {
    if( !( F(flagsP) & flJOTc_DOnOTrEGISTER ) )

    //if( tinP.pEther ) tinP.pEther->traceF( tinP , T("jotC [postNameP]:    ")+T(postNameP) ) ;

    }
        }
            }
                //if( tinP.pEther ) tinP.pEther->traceF( tinP , T("jotC / existed       [postNameP]:    ")+T(postNameP) ) ;
                *(flagsT*)&flagsCt |= flJOTc_FILEeXISTED ;
            {
            else
            }
                //if( tinP.pEther ) tinP.pEther->traceF( tinP , T("jotC / newly created [postNameP]:    ")+T(postNameP) ) ;
            {
            if( !bDataExisted )

            if( bDataExisted != bIndexExisted ) { BLAMMO ; }

            boolT bIndexExisted = !!( F( bkNowIndex.flagsCtF() ) & flBOOKc_FILEeXISTED ) ;
            boolT bDataExisted  = !!( F( bkNowData.flagsCtF()  ) & flBOOKc_FILEeXISTED ) ;

            bookC& bkNowIndex = bksIndex.bookNowF() ;
            bookC& bkNowData  = bksData.bookNowF() ;
        {
        //if( pcpIdBookData && pcpIdBookIndex && pcpIdBookData[ 0 ] == 1 && pcpIdBookIndex[ 0 ] == 1 && pcpIdBookData[ 1 ] == 1 && pcpIdBookIndex[ 1 ] == 1 ) // IF THE CURRENT IDbOOK IS 1 FOR BOTH DATA AND INDEX
        //const countT* pcpIdBookIndex = bksIndex.pcpIdBookF() ;
        //const countT* pcpIdBookData  = bksData.pcpIdBookF() ;
        //20231111@1307: UNCONDITIONALLY SET b*Existed ; I DON'T REMEMBER WHY I MADE THIS CONDITIONAL BUT MAKING IT CONDITIONAL FAILS TO SET flJOTc_FILEeXISTED FOR EXISTING JOT FILESETS WHEN EITHER DATA OR INDEX HAS MULTIPLE BOOKS
    {

    _IO_

    }
        if( POOP ) return ;
        FV( flJOTc , flagsP ) ;
        __Z( postNameP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
flagsCt( flagsP )
idMaxWritten( 0 ) ,
idLathRead( 0 ) ,
cIndexEntriesPerIndexBook( bksIndex.cbBodyBookF() / sizeof( handle0111C ) ) ,
) ,
    cKeepInactiveP , 0 , 0 , 0 , idMemorySpaceP
    ,
        : sizeof( handle0111C ) * ( cIndexEntriesBookP ? cIndexEntriesBookP : CBjOTbOOKdEFAULT / sizeof( handle0111C ) )
        ? 0
    !( F(flagsP) & flJOTc_WRITE )
    ,
    )
            : flBOOKSc_null
            ? flBOOKSc_NOsHORTfILENAMEpREFIX
        F(flagsP) & flJOTc_NOsHORTfILENAMEpREFIX
    (
    |
    )
            : flBOOKSc_null
            ? flBOOKSc_PURGEoNdT
        F(flagsP) & flJOTc_DELETE
    (
    |
    )
            : flBOOKSc_null
            ? flBOOKSc_PURGEoNcT
        F(flagsP) & flJOTc_PURGEoNcT
    (
    |
    )
            : flBOOKSc_null
            ? flBOOKSc_WRITER
        F(flagsP) & flJOTc_WRITE
    (
    ,
        : ifcIDsTATEsPACE_MULTIPLEaDAMS
        ? ifcIDsTATEsPACE_SCRATCH
    F(flagsP) & flJOTc_PRIVATE
    ,
            : T("") )+T(postNameP)+T(".jotC.index")
            ? TF2(tinP.osPid,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".")+TF2(tinP.monitor.idThread,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".")
        F(flagsP) & flJOTc_PRIVATE
    (
    ,
    tinP , TAG( TAGiDnULL )
(
bksIndex
) ,
    cKeepInactiveP , 0 , 0 , 0 , idMemorySpaceP
    ,
            : CBjOTbOOKdEFAULT
            ? cbDataBookP
        : cbDataBookP
        ? 0
    !( F(flagsP) & flJOTc_WRITE )
    ,
    )
            : flBOOKSc_null
            ? flBOOKSc_NOsHORTfILENAMEpREFIX
        F(flagsP) & flJOTc_NOsHORTfILENAMEpREFIX
    (
    |
    )
            : flBOOKSc_null
            ? flBOOKSc_PURGEoNdT
        F(flagsP) & flJOTc_DELETE
    (
    |
    )
            : flBOOKSc_null
            ? flBOOKSc_PURGEoNcT
        F(flagsP) & flJOTc_PURGEoNcT
    (
    |
    )
            : flBOOKSc_null
            ? flBOOKSc_WRITER
        F(flagsP) & flJOTc_WRITE
    (
    ,
        : ifcIDsTATEsPACE_MULTIPLEaDAMS
        ? ifcIDsTATEsPACE_SCRATCH
    F(flagsP) & flJOTc_PRIVATE
    ,
    )
            : T("") )+T(postNameP)+T(".jotC.data"
            ? TF2(tinP.osPid,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".")+TF2(tinP.monitor.idThread,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".")
        F(flagsP) & flJOTc_PRIVATE
    (
    ,
    tinP , TAG( TAGiDnULL )
(
bksData
_idThreadCt( tinP.monitor.idThread ) ,
tagHighNibble( 0 ) ,
idSlotJot( 0 ) ,
grabC( tinP , TAG( TAGiDnULL ) , flagsGrabP | flGRABc_NOTjEALOUS , idGrabLayerP ) ,     // flGRABc_NOTjEALOUS IS ADDED BECAUSE USING ME WILL USUALLY OR ALWAYS RESULT IN booksC BEING GRABBED
/*1*/jotC::jotC( tinS& tinP , const osTextT* const postNameP , const flagsT flagsP , const countT cKeepInactiveP , const countT cbDataBookP , const countT cIndexEntriesBookP , countT idGrabLayerP , flagsT flagsGrabP , countT idMemorySpaceP ) :/*1*/

// IF flJOTc_DOnOTrEGISTER THEN I WILL NOT SET ANY BITS IN NM_HIGH FOR idJot VALUES

// IF IT IS EVER NECESSARY TO SUPPORT EARLY/LATE, EDIT THIS DEF TO AVOID USING textC (THE T MACRO) IF EARLY/LATE
// I CANNOT BE USED EARLY/LATE BECAUSE I USE textC TO CONSTRUCT A UNIQUE NAME

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

