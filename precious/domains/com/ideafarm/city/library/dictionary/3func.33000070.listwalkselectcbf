
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return flLISTwALKcALLbACKrETURNcODE_DOnOTwALKmE ;

    UNGRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )
    }
        }
            // POPtINaRGS
            // flagsT flagsRC = listC::walkIF( tinP , hRecord ) ;
            // ((tinNormalS&)tinP).ta.pushed.u.listWalk.util.pcP[ 1 ] = flLISTwALKcHATTER_null ;
            // ((tinNormalS&)tinP).ta.pushed.u.listWalk.util.pcP[ 0 ] = record.nameF() ;
            // ((tinNormalS&)tinP).ta.pushed.u.listWalk.walk.flagsWalkP = flLISTwALK_null ;
            // ((tinNormalS&)tinP).ta.pushed.u.listWalk.walk.pListWalkCBFP = listWalkChatterCBF ;
            // PUSHtINaRGS
            // CONoUTrAW( "================== CHATTERING RECORD ==============================\r\n" ) ;
            // 
            // record.openF( tinP , hRecord ) ;
            // handleC hRecord( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            // 
            // grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
        
            }
                DELlIST( fieldEditParamOutC , pOut ) ;
                listC::fieldIF( tinP , pOut , hTo , pczField , _fe_pushC( record ) + _fe_modePushSinkC() + _fe_modeUniqueC() , LF ) ;
                countT pczField[] = { LISTnAMEsYS_RECORD , 0 } ;                                                                                                                                                 \
                ZE( fieldEditParamOutC* , pOut ) ;
            
                listC::openIF( tinP , hTo , pczTo ) ;
                handleC hTo( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                countT pczTo[] = { LISTnAMEsYS_ROOT , LISTnAMEsYS_ROOTsYSTEM4 , LISTnAMEsYS_TEMPORARY , LISTnAMEsYS_SELECTED , ((tinNormalS&)tinP).ta.pushed.u.listWalk.util.pcP[ 0 ] , 0 } ;
            
                puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
            {
            //SINK UNIQUE A listingVSP for record INTO A TEMPORARY LIST
        
            __( !listingC::bIsListingIF( tinP , &record ) ) ;
            listC& record = *(listC*)(const listingC*)spRecord ;
        
            listingVSP spRecord = entry ;
            listing_listingVSP_C& entry = *(listing_listingVSP_C*)pListing ;
        {
        else
        }
            // POPtINaRGS
            // flagsT flagsRC = listOfSetC::walkIF( tinP , hRecord ) ;
            // ((tinNormalS&)tinP).ta.pushed.u.listWalk.util.pcP[ 1 ] = flLISTwALKcHATTER_null ;
            // ((tinNormalS&)tinP).ta.pushed.u.listWalk.util.pcP[ 0 ] = record.nameF() ;
            // ((tinNormalS&)tinP).ta.pushed.u.listWalk.walk.flagsWalkP = flLISTwALK_null ;
            // ((tinNormalS&)tinP).ta.pushed.u.listWalk.walk.pListWalkCBFP = listWalkChatterCBF ;
            // PUSHtINaRGS
            // CONoUTrAW( "================== CHATTERING RECORD ==============================\r\n" ) ;
            // 
            // record.openF( tinP , hRecord ) ;
            // handleC hRecord( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
            // 
            // grabitC grabitx( tinP , TAG( TAGiDnULL ) ) ;
        
            }
                DELlIST( fieldEditParamOutC , pOut ) ;
                listOfSetC::fieldIF( tinP , pOut , hTo , pczField , _fe_pushC( record ) + _fe_modePushSinkC() + _fe_modeUniqueC() , LF ) ;
                countT pczField[] = { LISTnAMEsYS_RECORD , 0 } ;                                                                                                                                                 \
                ZE( fieldEditParamOutC* , pOut ) ;
            
                listOfSetC::openIF( tinP , hTo , pczTo ) ;
                handleC hTo( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;
                countT pczTo[] = { LISTnAMEsYS_ROOT , LISTnAMEsYS_ROOTsYSTEM4 , LISTnAMEsYS_TEMPORARY , LISTnAMEsYS_SELECTED , ((tinNormalS&)tinP).ta.pushed.u.listWalk.util.pcP[ 0 ] , 0 } ;
            
                puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
            {
            //SINK UNIQUE A listingVSP for record INTO A TEMPORARY LIST
        
            __( !listingOfSetC::bIsListingIF( tinP , &record ) ) ;
            listOfSetC& record = *(listOfSetC*)(const listingC*)spRecord ;
        
            listingVSP spRecord = entry ;
            listingOfSet_listingVSP_C& entry = *(listingOfSet_listingVSP_C*)pListing ;
        {
        if( bOfSet )
    {
    if( pListing && !( pListing->flagsF() & fliLISTINGc_MIXINlIST ) && pListing->idTypeDatumF() == ifcIDtYPEmIXINdATUM_listingVSP )

    listingC* pListing = ((tinNormalS&)tinP).ta.pushed.u.listWalk.cbf.pListingP ;
    GRABtINaRGS( ifcIDtYPEtINaRGiNuSE_LIST )

    const boolT  bOfSet = F(flagsPoolFormat) & flPOOLfORMAT_SETS ;
    const flagsT flagsPoolFormat = !((tinNormalS&)tinP).pPoolUse ? 0 : PUSE.flagsPoolFormatF() ;
{
/*1*/flagsT _export listWalkSelectCBF( tinNormalS& tinP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

