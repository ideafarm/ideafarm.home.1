
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    delF( tinP , postArgs2 ) ;
    delF( tinP , postArgs1 ) ;

    __Z( bDone ) ;

    }
        }
            }
                tinP.pEtScratch->traceF( tinP , T("could not   zip using bundled infozip   zip.exe ; i give up" ) ) ;

                delF( tinP , postDir ) ;
                tinP.pEtScratch->traceF( tinP , T("called infozip   zip.exe [postArgs]:    ")+T(postArgs1) ) ;
                tinP.pEtScratch->traceF( tinP , T("[postDir]:    ")+T(postDir) ) ;
                dosGetCurrentDirF( tinP , postDir ) ; ___( postDir ) ;
                ZE( osTextT* , postDir ) ;
            {
            if( !bDone )

            else bDone = 1 ;
            }
                tinP.pEtScratch->traceF( tinP , T("bundled infozip   zip.exe failed [value,idDeathType]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            else if( value || idDeathType )
            }
                tinP.pEtScratch->traceF( tinP , T("could not hire bundled infozip   zip.exe [POOP]:    ")+TF2(idPoop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT idPoop = POOP ;
            {
            if( POOP )

            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            ((thirdC&)*tinP.pEtScratch).dosExecPgmF( tinP , countTC() , countTC() , value , idDeathType , postLongExe , postArgs2 ) ;
            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            SCOOPS
        {
        IFsCRATCH

        c_strcatIF( tinP , postLongExe , "\\precious\\domains\\com\\ideafarm\\city\\workshop\\infozip\\zip.exe\\zip.exe"     ) ;
        c_strcpyIF( tinP , postLongExe , home.postHome ) ;
        osTextT postLongExe[ TUCK ] ;
        homeS& home = homeS::homeIF() ;

        idDeathType = value = 0 ;
    {
    if( !bDone && ( !idZipperP || idZipperP == ifcIDzIPPER_INFOZIP ) )

    }
        //THREADmODE2rESTORE
        THREADmODE3rESTORE
        //THREADmODE4rESTORE
        }
            }
                }
                    }
                        tinP.pEtScratch->traceF( tinP , T("could not   zip using pkzipc.exe" ) ) ;

                        delF( tinP , postDir ) ;
                        tinP.pEtScratch->traceF( tinP , T("called pkzipc.exe [postArgs]:    ")+T(postArgs1) ) ;
                        tinP.pEtScratch->traceF( tinP , T("[postDir]:    ")+T(postDir) ) ;
                        dosGetCurrentDirF( tinP , postDir ) ; ___( postDir ) ;
                        ZE( osTextT* , postDir ) ;

                        pEtherContainsMe->traceF( tinP , T("!exception: kid process failed [value,rc,name]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc) ) ;
                        TN( tb4 , "    " ) ;
                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    else
                    if( !POOP ) bPKZipHired = bDone = 1 ;

                    }
                        __1
                        __( value ) ;
                    {
                    if( value != ifcEXITcODE_EXITpROCESSaOK )

                    tinP.pEtScratch->osProcessWaitF( tinP , value , countTC() , osTid , osPid ) ;
                    ZE( countT , value ) ;

                    SCOOPS
                    _IO_
                {
                IFsCRATCH

//                sgnReceived.giveF( tinP ) ;
                pEtherContainsMe->traceF( tinP , T("giving the \"received\" sign and waiting for kid process to end") ) ;

                }
                    }
                        //pEtherContainsMe->traceF( tinP , T("after querying report record (end)") ) ;
                        //listC::chatterIF( tinP ) ;
                        //pEtherContainsMe->traceF( tinP , T("after querying report record:") ) ;

                        }
                            }
                                }
                                    tinP.pEtScratch->traceF( tinP , T("[value]:    ")+TF2(*pc_value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    const countT*  pc_value     = vsp_value ;
                                    countVSP      vsp_value     = listC::countIF( tinP , myRecord , count2S( LISTnAME_PROCESSrEPORTfIELD30 ) ) ;
                                {
                            
                                }
                                    tinP.pEtScratch->traceF( tinP , T("[idPoop]:    ")+TF2(*pc_idPoop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    const countT*  pc_idPoop    = vsp_idPoop ;
                                    countVSP      vsp_idPoop    = listC::countIF( tinP , myRecord , count2S( LISTnAME_PROCESSrEPORTfIELD20 ) ) ;
                                {
                            
                                }
                                    tinP.pEtScratch->traceF( tinP , T("[bHiredAOK]:    ")+TF2(*pc_bHiredAOK,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    const countT*  pc_bHiredAOK = vsp_bHiredAOK ;
                                    countVSP      vsp_bHiredAOK = listC::countIF( tinP , myRecord , count2S( LISTnAME_PROCESSrEPORTfIELD10 ) ) ;
                                {

                                tinP.pEtScratch->traceF( tinP , T("record exists") ) ;
                            {
                            else
                            if( (const poopC&)myRecord ) tinP.pEtScratch->traceF( tinP , T("!exception / record does not exist [pcName]:    ")+T(pcNameRecord) ) ;
                        
                            recordC myRecord( tinP , pcNameRecord , flLISToPEN_IFeXISTS ) ;
                        {
                        countT pcNameRecord[] = { LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION , LISTnAME_GLOBALrECORD , LISTnAME_PROCESSrEPORT , tinP.pag1->idCell | BM_HIGH , idReport | BM_HIGH , ifcIDaDAM_HIREwITHOUTdEBUGGING | BM_HIGH , 0 } ;

                        PUSE.refresh_ppSlots_F( tinP ) ;
                        puseC puseHT( tinP , ifcIDpOOL_HOMEtEMP ) ;
                        _IO_
                    {
                {

                pEtherContainsMe->traceF( tinP , T("waited for the \"ready\" sign and am receiving the report") ) ;
                DELzOMBIE( pzSgnReady ) ;

pEtherContainsMe->osSleepF( tinP , TICK >> 4 ) ; //U::DEBUGGING (waitF RETURNS UNEXPECTEDLY IMMEDIATELY)

//                pzSgnReady->waitF( tinP ) ;

                pEtherContainsMe->traceF( tinP , T("waiting for the kid process to give the \"ready\" sign") ) ;

                }
                    }
                        ++ s ; tinP.pEtScratch->osSleepF( tinP , TOCK >> 4 ) ;
                        DELzOMBIE( pzSgnReady ) ;
                        POOPRqUIET

                        if( !POOP ) break ;
                        pzSgnReady = new( 0 , tinP , pbz_sgnReady , sizeof pbz_sgnReady ) signC( tinP , TAG( TAGiDnULL ) , tReady , flSIGNc_FAILiFnAPKINnOTeXIST ) ;
                    {
                    for(;;)

                    SCOOPS
                    _IO_
                {
                IFsCRATCH
                pEtherContainsMe->traceF( tinP , T("napping until the \"ready\" sign object has been ct by the kid process") ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                ZE( signC* , pzSgnReady ) ;
                byteT  pbz_sgnReady[ sizeof( signC ) ] ;
            {
            else
            if( !osPid ) pEtherContainsMe->traceF( tinP , T("!exception: could not launch ifcIDaDAM_HIREwITHOUTdEBUGGING") ) ;

            }
                c4Result = pEtherContainsMe->ifcHireF( tinP , T("ifcIDaDAM_HEALaRCHIVES") , ifcIDaDAM_HIREwITHOUTdEBUGGING , tArgs , flHIRE_DISPLAYaUTO , 0 , 0 , 1 , nicNameC() ) ;
                TN( tArgs , "" ) ; tArgs = T("!ignore [comment can go here] !maxValue 0 !reportToCell ")+TF2(tinP.pag1->idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" !idReport ")+TF2(idReport,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" !hireLater pkzipc.exe ")+T(postArgs1) ;

                idReport = 1 + incv02AM( idReportLath ) ;
                static countT idReportLath ;

                _IO_
            {
            countT& osPid = c4Result.c2 ;
            countT& osTid = c4Result.c1 ;
            count4S c4Result ;
            ZE( countT , idReport ) ;
        {
        //THREADmODE4oN( flTHREADmODE4_ALLOWwRITEABLEpOINTERgET )
        THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY       )
        //THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING   )

        signC sgnReceived( tinP , TAG( TAGiDnULL ) , tReceived ) ;          //THIS IS CT BEFORE HIRING KID TO ENSURE THAT KID CANNOT GIVE IT B4 I AM WAITING FOR IT

        TN( tReady    , "report.is.ready"    ) ;                            //U:: UNIQUIFY USING MY idCell AND REQUESTOR'S idCell AND idReport
        TN( tReceived , "report.is.received" ) ;                            //U:: UNIQUIFY USING MY idCell AND REQUESTOR'S idCell AND idReport
        TN( tDot      , "."                  ) ;
    {
#endif
    if( bHireNoMonitor )

    }
        }
            else bPKZipHired = bDone = 1 ;
            }
                tinP.pEtScratch->traceF( tinP , T("pczipc.exe failed [value,idDeathType]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                bPKZipHired = 1 ;
            {
            else if( value || idDeathType )
            }
                if( bHireNoMonitor ) tinP.pEtScratch->traceF( tinP , T("i will try hiring pkzipc.exe indirectly") ) ;
                tinP.pEtScratch->traceF( tinP , T("could not hire pczipc.exe directly [POOP]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc) ) ;
                POOPRqUIET
                const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                bHireNoMonitor = rc == ifcIDiMPOTENCEbASEeRRORcODE_NOTsUPPORTED ;
                countT rc = POOP ;
            {
            if( POOP )

            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            ((thirdC&)*tinP.pEtScratch).dosExecPgmF( tinP , countTC() , countTC() , value , idDeathType , "pkzipc.exe" , postArgs1 ) ;
            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            SCOOPS
        {
        IFsCRATCH
    {
    if( !idZipperP || idZipperP == ifcIDzIPPER_PKZIPC )
#if defined( NEVERdEFINED )
    ZE( boolT  , bHireNoMonitor ) ;
    ZE( boolT  , bPKZipHired    ) ;
    ZE( countT , idDeathType    ) ;
    ZE( countT , value          ) ;
    ZE( boolT  , bDone          ) ;

    pEtherContainsMe->traceF( tinP , T("[postArgs2]:    ")+T(postArgs2) ) ;
    pEtherContainsMe->traceF( tinP , T("[postArgs1]:    ")+T(postArgs1) ) ;

    }
        pEtherContainsMe->strMakeF( tinP , LF , postArgs2 , tArgs2 ) ; ___( postArgs2 ) ;
        pEtherContainsMe->strMakeF( tinP , LF , postArgs1 , tArgs1 ) ; ___( postArgs1 ) ;

        tArgs2 += T(postSpecsInfoZipP)+tb+T(postToP  )+tb+T(postWildListP) ;
        tArgs1 += T(postSpecsPKZipP  )+tb+T(postToP  )+tb+T(postWildListP) ;
        if( tArgs2.csF( tinP ) ) tArgs2 += tb ;
        if( tArgs1.csF( tinP ) ) tArgs1 += tb ;

        }
            tArgs2 += T(" -x "      )   +T(postWildListExcludeP)+tba ;
            tArgs1 += T(" -exclude ")+tq+T(postWildListExcludeP)+tq  ;
        {
        if( postWildListExcludeP )

        }
            tArgs2 += T(" -i "      )   +T(postWildListIncludeP)+tba ;
            tArgs1 += T(" -include ")+tq+T(postWildListIncludeP)+tq  ;
        {
        if( postWildListIncludeP )

        TN( tArgs2 , ""                                            ) ;
        TN( tArgs1 , "-add"                                        ) ;
        TN( tq , "\""  ) ;
        TN( tb , " "   ) ;
        TN( tba , " @" ) ;
    {
    ZE( osTextT* , postArgs2 ) ;
    ZE( osTextT* , postArgs1 ) ;

    if( postSpecsInfoZipP    ) costAll += thirdC::c_strlenIF( tinP , postSpecsInfoZipP    ) ;
    if( postSpecsPKZipP      ) costAll += thirdC::c_strlenIF( tinP , postSpecsPKZipP      ) ;   // REALLY ONLY NEED THE MAXIMUM LENGTH SINCE ONLY WO SPEC IS USED AT A TIME; DONE THIS WAY FOR SIMPLICITY (SPECS ARE SHORT)
    if( postWildListExcludeP ) costAll += thirdC::c_strlenIF( tinP , postWildListExcludeP ) ;
    if( postWildListIncludeP ) costAll += thirdC::c_strlenIF( tinP , postWildListIncludeP ) ;
    countT                     costAll  = thirdC::c_strlenIF( tinP , postToP   ) + thirdC::c_strlenIF( tinP , postWildListP ) + TUCK ;

    pEtherContainsMe->traceF( tinP , T("[postSpecsInfoZipP   ]:    ")+T(postSpecsInfoZipP)    ) ;
    pEtherContainsMe->traceF( tinP , T("[postSpecsPKZipP     ]:    ")+T(postSpecsPKZipP)      ) ;
    pEtherContainsMe->traceF( tinP , T("[postWildListExcludeP]:    ")+T(postWildListExcludeP) ) ;
    pEtherContainsMe->traceF( tinP , T("[postWildListIncludeP]:    ")+T(postWildListIncludeP) ) ;
    pEtherContainsMe->traceF( tinP , T("[postWildListP       ]:    ")+T(postWildListP)        ) ;
    pEtherContainsMe->traceF( tinP , T("[postToP             ]:    ")+T(postToP)              ) ;

    _IO_

    }
        if( POOP ) return ;

        __Z( pEtherContainsMe  ) ;
        __Z( postWildListP     ) ;
        __Z( postToP           ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT thirdC::diskZipF(   tinS& tinP , const osTextT* const postToP                         , const osTextT* const postWildListP , const osTextT* const postWildListIncludeP , const osTextT* const postWildListExcludeP , const osTextT* const postSpecsPKZipP , const osTextT* const postSpecsInfoZipP , const countT idZipperP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
