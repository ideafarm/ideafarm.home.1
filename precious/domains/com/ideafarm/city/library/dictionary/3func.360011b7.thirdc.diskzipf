
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    delF( tinP , postArgs2 ) ;
    delF( tinP , postArgs1 ) ;

    __Z( bDone ) ;

    }
        }
            }
                tinP.pEtScratch->traceF( tinP , T("could not   zip using bundled infozip   zip.exe ; i give up" ) ) ;

                delF( tinP , postDir ) ;
                tinP.pEtScratch->traceF( tinP , T("called infozip   zip.exe [postArgs]:    ")+T(postArgs1) ) ;
                tinP.pEtScratch->traceF( tinP , T("[postDir]:    ")+T(postDir) ) ;
                dosGetCurrentDirF( tinP , postDir ) ; ___( postDir ) ;
                ZE( osTextT* , postDir ) ;
            {
            if( !bDone )

            else bDone = 1 ;
            }
                tinP.pEtScratch->traceF( tinP , T("bundled infozip   zip.exe failed [value,idDeathType]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            else if( value || idDeathType )
            }
                tinP.pEtScratch->traceF( tinP , T("could not hire bundled infozip   zip.exe [POOP]:    ")+TF2(idPoop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT idPoop = POOP ;
            {
            if( POOP )

            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            ((thirdC&)*tinP.pEtScratch).dosExecPgmF( tinP , countTC() , countTC() , value , idDeathType , postLongExe , postArgs2 ) ;
            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            SCOOPS
        {
        IFsCRATCH

        c_strcatIF( tinP , postLongExe , "\\precious\\domains\\com\\ideafarm\\city\\workshop\\infozip\\zip.exe\\zip.exe"     ) ;
        c_strcpyIF( tinP , postLongExe , home.postHome ) ;
        osTextT postLongExe[ TUCK ] ;
        homeS& home = homeS::homeIF() ;

        idDeathType = value = 0 ;
    {
    if( !bDone && ( !idZipperP || idZipperP == ifcIDzIPPER_INFOZIP ) )

    }
        THREADmODE2rESTORE
        THREADmODE3rESTORE
        THREADmODE4rESTORE
        }
            }
                }
                    }
                        }
                            tinP.pEtScratch->traceF( tinP , T("[value]:    ")+TF2(*pc_value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            countT*   pc_value     = vsp_value ;
                            countVSP vsp_value     = listC::countIF( tinP , myRecord , count2S( LISTnAME_RETURNiNFO3 ) ) ;
                        {
                    
                        }
                            tinP.pEtScratch->traceF( tinP , T("[idPoop]:    ")+TF2(*pc_idPoop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            countT*   pc_idPoop    = vsp_idPoop ;
                            countVSP vsp_idPoop    = listC::countIF( tinP , myRecord , count2S( LISTnAME_RETURNiNFO2 ) ) ;
                        {
                    
                        }
                            tinP.pEtScratch->traceF( tinP , T("[bHiredAOK]:    ")+TF2(*pc_bHiredAOK,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            countT*   pc_bHiredAOK = vsp_bHiredAOK ;
                            countVSP vsp_bHiredAOK = listC::countIF( tinP , myRecord , count2S( LISTnAME_RETURNiNFO1 ) ) ;
                        {
                    
                        recordC myRecord( tinP , pcNameRecord ) ;
                        countT pcNameRecord[] = { LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION , LISTnAME_GLOBALrECORD , LISTnAME_PROCESSoUTCOME , ifcIDaDAM_HIREwITHOUTdEBUGGING | BM_HIGH , tinP.pag1->idCell | BM_HIGH , 0 } ;

                        listC::chatterIF( tinP , pcRoot ) ;
                        countT pcRoot[] = { LISTnAME_ROOT , 0 } ;
                    
                        puseC puseHT( tinP , ifcIDpOOL_HOMEtEMP ) ;
                        _IO_
                    {
                {

                }
                    }
                        tinP.pEtScratch->traceF( tinP , T("could not   zip using pkzipc.exe" ) ) ;

                        delF( tinP , postDir ) ;
                        tinP.pEtScratch->traceF( tinP , T("called pkzipc.exe [postArgs]:    ")+T(postArgs1) ) ;
                        tinP.pEtScratch->traceF( tinP , T("[postDir]:    ")+T(postDir) ) ;
                        dosGetCurrentDirF( tinP , postDir ) ; ___( postDir ) ;
                        ZE( osTextT* , postDir ) ;

                        pEtherContainsMe->traceF( tinP , T("!exception: kid process failed [value,rc,name]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc) ) ;
                        TN( tb4 , "    " ) ;
                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    else
                    if( !POOP ) bPKZipHired = bDone = 1 ;

                    }
                        __1
                        __( value ) ;
                    {
                    if( value != ifcEXITcODE_EXITpROCESSaOK )

                    tinP.pEtScratch->osProcessWaitF( tinP , value , countTC() , osTid , osPid ) ;
                    ZE( countT , value ) ;

                    SCOOPS
                    _IO_
                {
                IFsCRATCH
            {
            else
            if( !osPid ) pEtherContainsMe->traceF( tinP , T("!exception: could not launch ifcIDaDAM_HIREwITHOUTdEBUGGING") ) ;

            }
                c4Result = pEtherContainsMe->ifcHireF( tinP , T("ifcIDaDAM_HEALaRCHIVES") , ifcIDaDAM_HIREwITHOUTdEBUGGING , tArgs , flHIRE_DISPLAYaUTO , 0 , 0 , 1 , nicNameC() ) ;
                TN( tArgs , "" ) ; tArgs = T("!ignore [comment can go here] !outcome ")+TF2(tinP.pag1->idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" !maxValue 0 !hireLater pkzipc.exe ")+T(postArgs1) ;
                _IO_
            {
            countT& osPid = c4Result.c2 ;
            countT& osTid = c4Result.c1 ;
            count4S c4Result ;

            puseC puseHT( tinP , ifcIDpOOL_HOMEtEMP , flPUSEcmODE_HIDDEN ) ;    //THIS CAUSES HOMEtEMP TO BE CT'D SO THAT MY INSTANCE EXISTS BEFORE THE KID'S INSTANCE IS DESTROYED
        {
        THREADmODE4oN( flTHREADmODE4_ALLOWwRITEABLEpOINTERgET )
        THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY       )
        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING   )
    {
#endif
    if( bHireNoMonitor )

    }
        }
            else bPKZipHired = bDone = 1 ;
            }
                tinP.pEtScratch->traceF( tinP , T("pczipc.exe failed [value,idDeathType]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                bPKZipHired = 1 ;
            {
            else if( value || idDeathType )
            }
                if( bHireNoMonitor ) tinP.pEtScratch->traceF( tinP , T("i will try hiring pkzipc.exe indirectly") ) ;
                tinP.pEtScratch->traceF( tinP , T("could not hire pczipc.exe directly [POOP]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc) ) ;
                POOPRqUIET
                const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                bHireNoMonitor = rc == ifcIDiMPOTENCEbASEeRRORcODE_NOTsUPPORTED ;
                countT rc = POOP ;
            {
            if( POOP )

            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            ((thirdC&)*tinP.pEtScratch).dosExecPgmF( tinP , countTC() , countTC() , value , idDeathType , "pkzipc.exe" , postArgs1 ) ;
            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            SCOOPS
        {
        IFsCRATCH
    {
    if( !idZipperP || idZipperP == ifcIDzIPPER_PKZIPC )
#if defined( NEVERdEFINED )
    ZE( boolT  , bHireNoMonitor ) ;
    ZE( boolT  , bPKZipHired    ) ;
    ZE( countT , idDeathType    ) ;
    ZE( countT , value          ) ;
    ZE( boolT  , bDone          ) ;

    pEtherContainsMe->traceF( tinP , T("[postArgs2]:    ")+T(postArgs2) ) ;
    pEtherContainsMe->traceF( tinP , T("[postArgs1]:    ")+T(postArgs1) ) ;

    }
        pEtherContainsMe->strMakeF( tinP , LF , postArgs2 , tArgs2 ) ; ___( postArgs2 ) ;
        pEtherContainsMe->strMakeF( tinP , LF , postArgs1 , tArgs1 ) ; ___( postArgs1 ) ;

        tArgs2 += T(postSpecsInfoZipP)+tb+T(postToP  )+tb+T(postWildListP) ;
        tArgs1 += T(postSpecsPKZipP  )+tb+T(postToP  )+tb+T(postWildListP) ;
        if( tArgs2.csF( tinP ) ) tArgs2 += tb ;
        if( tArgs1.csF( tinP ) ) tArgs1 += tb ;

        }
            tArgs2 += T(" -x "      )   +T(postWildListExcludeP)+tba ;
            tArgs1 += T(" -exclude ")+tq+T(postWildListExcludeP)+tq  ;
        {
        if( postWildListExcludeP )

        }
            tArgs2 += T(" -i "      )   +T(postWildListIncludeP)+tba ;
            tArgs1 += T(" -include ")+tq+T(postWildListIncludeP)+tq  ;
        {
        if( postWildListIncludeP )

        TN( tArgs2 , ""                                            ) ;
        TN( tArgs1 , "-add"                                        ) ;
        TN( tq , "\""  ) ;
        TN( tb , " "   ) ;
        TN( tba , " @" ) ;
    {
    ZE( osTextT* , postArgs2 ) ;
    ZE( osTextT* , postArgs1 ) ;

    if( postSpecsInfoZipP    ) costAll += thirdC::c_strlenIF( tinP , postSpecsInfoZipP    ) ;
    if( postSpecsPKZipP      ) costAll += thirdC::c_strlenIF( tinP , postSpecsPKZipP      ) ;   // REALLY ONLY NEED THE MAXIMUM LENGTH SINCE ONLY WO SPEC IS USED AT A TIME; DONE THIS WAY FOR SIMPLICITY (SPECS ARE SHORT)
    if( postWildListExcludeP ) costAll += thirdC::c_strlenIF( tinP , postWildListExcludeP ) ;
    if( postWildListIncludeP ) costAll += thirdC::c_strlenIF( tinP , postWildListIncludeP ) ;
    countT                     costAll  = thirdC::c_strlenIF( tinP , postToP   ) + thirdC::c_strlenIF( tinP , postWildListP ) + TUCK ;

    pEtherContainsMe->traceF( tinP , T("[postSpecsInfoZipP   ]:    ")+T(postSpecsInfoZipP)    ) ;
    pEtherContainsMe->traceF( tinP , T("[postSpecsPKZipP     ]:    ")+T(postSpecsPKZipP)      ) ;
    pEtherContainsMe->traceF( tinP , T("[postWildListExcludeP]:    ")+T(postWildListExcludeP) ) ;
    pEtherContainsMe->traceF( tinP , T("[postWildListIncludeP]:    ")+T(postWildListIncludeP) ) ;
    pEtherContainsMe->traceF( tinP , T("[postWildListP       ]:    ")+T(postWildListP)        ) ;
    pEtherContainsMe->traceF( tinP , T("[postToP             ]:    ")+T(postToP)              ) ;

    _IO_

    }
        if( POOP ) return ;

        __Z( pEtherContainsMe  ) ;
        __Z( postWildListP     ) ;
        __Z( postToP           ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT thirdC::diskZipF(   tinS& tinP , const osTextT* const postToP                         , const osTextT* const postWildListP , const osTextT* const postWildListIncludeP , const osTextT* const postWildListExcludeP , const osTextT* const postSpecsPKZipP , const osTextT* const postSpecsInfoZipP , const countT idZipperP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
