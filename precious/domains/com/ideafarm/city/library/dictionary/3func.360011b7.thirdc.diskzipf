
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    delF( tinP , postArgs2 ) ;
    delF( tinP , postArgs1 ) ;

    __Z( bDone ) ;

    }
        }
            }
                tinP.pEtScratch->traceF( tinP , T("could not   zip using bundled infozip   zip.exe ; i give up" ) ) ;

                delF( tinP , postDir ) ;
                tinP.pEtScratch->traceF( tinP , T("called infozip   zip.exe [postArgs]:    ")+T(postArgs1) ) ;
                tinP.pEtScratch->traceF( tinP , T("[postDir]:    ")+T(postDir) ) ;
                dosGetCurrentDirF( tinP , postDir ) ; ___( postDir ) ;
                ZE( osTextT* , postDir ) ;
            {
            if( !bDone )

            else bDone = 1 ;
            }
                tinP.pEtScratch->traceF( tinP , T("bundled infozip   zip.exe failed [valueInfoZip,idDeathTypeInfoZip]:    ")+TF2(valueInfoZip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idDeathTypeInfoZip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            else if( valueInfoZip || idDeathTypeInfoZip )
            }
                tinP.pEtScratch->traceF( tinP , T("could not hire bundled infozip   zip.exe [POOP]:    ")+TF2(idPoop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT idPoop = POOP ;
            {
            if( POOP )

            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            ((thirdC&)*tinP.pEtScratch).dosExecPgmF( tinP , countTC() , countTC() , valueInfoZip , idDeathTypeInfoZip , postLongExe , postArgs2 ) ;
            pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
            SCOOPS
        {
        IFsCRATCH

        c_strcatIF( tinP , postLongExe , "\\precious\\domains\\com\\ideafarm\\city\\workshop\\infozip\\zip.exe\\zip.exe"     ) ;
        c_strcpyIF( tinP , postLongExe , home.postHome ) ;
        osTextT postLongExe[ TUCK ] ;
        homeS& home = homeS::homeIF() ;
    {
    )
        )
            )
                !bPKZipHiredAOK                     // IF PKZIP WAS HIRED AOK BUT IT DIDN'T GET THE JOB DONE THEN DON'T BOTHER TRYING INFOZIP
                &&
                !idZipperP
            (
            ||
            idZipperP == ifcIDzIPPER_INFOZIP
        (
        &&
        !bDone
    (
    if
    ZE( countT , idDeathTypeInfoZip ) ;
    ZE( countT , valueInfoZip       ) ;

    }
        //THREADmODE2rESTORE
        THREADmODE3rESTORE
        //THREADmODE4rESTORE
        }
            }
                }
                    }
                        tinP.pEtScratch->traceF( tinP , T("could not   zip using pkzipc.exe" ) ) ;

                        delF( tinP , postDir ) ;
                        tinP.pEtScratch->traceF( tinP , T("called pkzipc.exe [postArgs]:    ")+T(postArgs1) ) ;
                        tinP.pEtScratch->traceF( tinP , T("[postDir]:    ")+T(postDir) ) ;
                        dosGetCurrentDirF( tinP , postDir ) ; ___( postDir ) ;
                        ZE( osTextT* , postDir ) ;

                        pEtherContainsMe->traceF( tinP , T("!exception: kid process failed [valueWrapper,rc,name]:    ")+TF2(valueWrapper,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc) ) ;
                        TN( tb4 , "    " ) ;
                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    else
                    if( !POOP ) bPKZipHiredAOK = bDone = 1 ;

                    }
                        __1
                        __( valueWrapper ) ;
                    {
                    if( valueWrapper != ifcEXITcODE_EXITpROCESSaOK )

                    tinP.pEtScratch->osProcessWaitF( tinP , valueWrapper , idDeathTypeWrapper , osTid , osPid ) ;

                    SCOOPS
                    _IO_
                {
                IFsCRATCH

                sgnReceived.giveF( tinP ) ;
                pEtherContainsMe->traceF( tinP , T("giving the \"received\" sign and waiting for kid process to end") ) ;

                }
                    }
                        pEtherContainsMe->traceF( tinP , T("after deleting report record (end)") ) ;
                        listC::chatterIF( tinP ) ;
                        pEtherContainsMe->traceF( tinP , T("after deleting report record:") ) ;

                        listC::deleteIF( tinP , mn ) ;

                        pEtherContainsMe->traceF( tinP , T("after querying report record (end)") ) ;
                        listC::chatterIF( tinP ) ;
                        pEtherContainsMe->traceF( tinP , T("after querying report record:") ) ;

                        }
                            }
                                }
                                    tinP.pEtScratch->traceF( tinP , T("[idDeathTypePKZip]:    ")+TF2(idDeathTypePKZip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    if( pc_idDeathTypePKZip )            idDeathTypePKZip = *pc_idDeathTypePKZip ;
                                    const countT*                     pc_idDeathTypePKZip = vsp_idDeathTypePKZip ;
                                    countVSP                         vsp_idDeathTypePKZip = listC::countIF( tinP , memoResults , count2S( 4 | BM_HIGH ) , flagsUse ) ;
                                {
                            
                                }
                                    tinP.pEtScratch->traceF( tinP , T("[valuePKZip]:    ")+TF2(valuePKZip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    if( pc_valuePKZip )                  valuePKZip       = *pc_valuePKZip ;
                                    const countT*                     pc_valuePKZip       = vsp_valuePKZip ;
                                    countVSP                         vsp_valuePKZip       = listC::countIF( tinP , memoResults , count2S( 3 | BM_HIGH ) , flagsUse ) ;
                                {
                            
                                }
                                    tinP.pEtScratch->traceF( tinP , T("[idPoop]:    ")+TF2(idPoop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    countT idPoop = !pc_idPoop ? 0 : *pc_idPoop ;
                                    const countT*                     pc_idPoop           = vsp_idPoop ;
                                    countVSP                         vsp_idPoop           = listC::countIF( tinP , memoResults , count2S( 2 | BM_HIGH ) , flagsUse ) ;
                                {
                            
                                }
                                    tinP.pEtScratch->traceF( tinP , T("[bPKZipHiredAOK]:    ")+TF2(bPKZipHiredAOK,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    if( pc_bHiredAOK )               bPKZipHiredAOK       = !!*pc_bHiredAOK ;
                                    const countT*                      pc_bHiredAOK       =   vsp_bHiredAOK ;
                                    countVSP                          vsp_bHiredAOK       = listC::countIF( tinP , memoResults , count2S( 1 | BM_HIGH ) , flagsUse ) ;
                                {

                                tinP.pEtScratch->traceF( tinP , T("record exists") ) ;
                            {
                            else
                            if( (const poopC&)memoResults ) tinP.pEtScratch->traceF( tinP , T("!exception / record does not exist [memoName]:    ")+T((countT*)mn) ) ;
                        
                            recordC memoResults( tinP , mn , flagsUse ) ;

                        {
                        const flagsT flagsUse = flLISToPEN_IFeXISTS | flLISToPEN_REFRESHaNDrETRYfOREVER ;
                        memoNameC mn( tinP , 0 , - 1 , - 1 , - 1 , - 1 ) ;
                        countT pcNameRecord[] = { LISTnAME_ROOT , LISTnAME_APPLICATION , LISTnAME_MEMO , tinP.pag1->idCell | BM_HIGH , idReport | BM_HIGH , ifcIDaDAM_HIREwITHOUTdEBUGGING | BM_HIGH , 0 } ;
                        puseC puseHT( tinP , ifcIDpOOL_HOMEtEMP ) ;
                        _IO_
                    {
                {

                pEtherContainsMe->traceF( tinP , T("waited for the \"ready\" sign and am receiving the report") ) ;
                DELzOMBIE( pzSgnReady ) ;
                pzSgnReady->waitF( tinP ) ;
                pEtherContainsMe->traceF( tinP , T("waiting for the kid process to give the \"ready\" sign") ) ;

                }
                    }
                        ++ s ; tinP.pEtScratch->osSleepF( tinP , TOCK >> 4 ) ;
                        DELzOMBIE( pzSgnReady ) ;
                        POOPRqUIET

                        if( !POOP ) break ;
                        pzSgnReady = new( 0 , tinP , pbz_sgnReady , sizeof pbz_sgnReady ) signC( tinP , TAG( TAGiDnULL ) , tSgnReady , flSIGNc_FAILiFnAPKINnOTeXIST ) ;
                    {
                    for(;;)

                    SCOOPS
                    _IO_
                {
                IFsCRATCH
                pEtherContainsMe->traceF( tinP , T("napping until the \"ready\" sign object has been ct by the kid process") ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                ZE( signC* , pzSgnReady ) ;
                byteT  pbz_sgnReady[ sizeof( signC ) ] ;
            {
            else
            if( !osPid ) pEtherContainsMe->traceF( tinP , T("!exception: could not launch ifcIDaDAM_HIREwITHOUTdEBUGGING") ) ;

            }
                c4Result = pEtherContainsMe->ifcHireF( tinP , T("ifcIDaDAM_HEALaRCHIVES") , ifcIDaDAM_HIREwITHOUTdEBUGGING , tArgs , flHIRE_DISPLAYaUTO , 0 , 0 , 1 , nicNameC() ) ;
                TN( tArgs , "" ) ; tArgs = T("!ignore [comment can go here] !maxValue 0 !reportToCell ")+TF2(tinP.pag1->idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" !idReport ")+TF2(idReport,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" !hireLater pkzipc.exe ")+T(postArgs1) ;
                _IO_
            {
            countT& osPid = c4Result.c2 ;
            countT& osTid = c4Result.c1 ;
            count4S c4Result ;
        {
        //THREADmODE4oN( flTHREADmODE4_ALLOWwRITEABLEpOINTERgET )
        THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY       )
        //THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING   )

        signC sgnReceived( tinP , TAG( TAGiDnULL ) , tSgnReceived , flSIGNc_GIVER ) ;              //THIS IS CT BEFORE HIRING KID TO ENSURE THAT KID CANNOT GIVE IT B4 I AM WAITING FOR IT

        TN( tSgnReady    , "report.is.ready."    ) ; tSgnReady    += tUniquify ;
        TN( tSgnReceived , "report.is.received." ) ; tSgnReceived += tUniquify ;
        TN( tUniquify , ""                       ) ; tUniquify     = TF2(tinP.pag1->idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tDot+TF2(idReport,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
        TN( tDot      , "."                      ) ;

        }
                idReport = 1 + incv02AM( idReportLath ) ;
                static countT idReportLath ;
        {
        ZE( countT , idReport ) ;
    {
    if( bHireNoMonitor )
    ZE( countT , idDeathTypeWrapper ) ;
    ZE( countT , valueWrapper       ) ;

    }
        }
            }
                else bPKZipHiredAOK = bDone = 1 ;
                }
                    tinP.pEtScratch->traceF( tinP , T("pczipc.exe failed [valuePKZip,idDeathTypePKZip]:    ")+TF2(valuePKZip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idDeathTypePKZip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    bPKZipHiredAOK = 1 ;
                {
                else if( valuePKZip || idDeathTypePKZip )
                }
                    if( bHireNoMonitor ) tinP.pEtScratch->traceF( tinP , T("i will try hiring pkzipc.exe indirectly") ) ;
                    tinP.pEtScratch->traceF( tinP , T("could not hire pczipc.exe directly [POOP]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc) ) ;
                    POOPRqUIET
                    const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                    bHireNoMonitor = rc == ifcIDiMPOTENCEbASEeRRORcODE_NOTsUPPORTED ;
                    countT rc = POOP ;
                {
                if( POOP )

                pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
                ((thirdC&)*tinP.pEtScratch).dosExecPgmF( tinP , countTC() , countTC() , valuePKZip , idDeathTypePKZip , "pkzipc.exe" , postArgs1 ) ;
                pEtherContainsMe->strokeF( tinP , T("\r\n") ) ;
                SCOOPS
            {
            IFsCRATCH
        {
        else
        if( !bSandbox ) bHireNoMonitor = 1 ;                                        // DON'T BOTHER TRYING THIS IF NOT SANDBOX SINCE DIRECT HIRING OF pkzipc.exe WILL FAIL AS "NOT SUPPORTED" BECAUSE pkzipc.exe IS 04 BIT AND I AM BEING MONITORED (BY GLASS2) ; AN 04 BIT PROCESS CANNOT BE LAUNCHED BY AN 02 BIT PROCESS WHEN THE LATTER AND ITS KIDS ARE BEING MONITORED (USING THE MS WINDOWS DEBUGGING SUBSYSTEM)

        bSandbox = 0 ;                                                              // COMMENT OUT THIS LINE IN PRODUCTION OR IF DO NOT WANT TO TEST INDIRECT HIRING OF pkzipc.exe
        boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;            // bSandbox IS USED IN PRODUCTION TO SKIP A FUTILE ATTEMPT TO HIRE pkzipc.exe DIRECTLY (WHICH WILL FAIL)
    {
    if( !idZipperP || idZipperP == ifcIDzIPPER_PKZIPC )
    ZE( boolT  , bHireNoMonitor   ) ;
    ZE( boolT  , bPKZipHiredAOK   ) ;
    ZE( countT , idDeathTypePKZip ) ;
    ZE( countT , valuePKZip       ) ;
    ZE( boolT  , bDone            ) ;

    pEtherContainsMe->traceF( tinP , T("[postArgs2]:    ")+T(postArgs2) ) ;
    pEtherContainsMe->traceF( tinP , T("[postArgs1]:    ")+T(postArgs1) ) ;

    }
        pEtherContainsMe->strMakeF( tinP , LF , postArgs2 , tArgs2 ) ; ___( postArgs2 ) ;
        pEtherContainsMe->strMakeF( tinP , LF , postArgs1 , tArgs1 ) ; ___( postArgs1 ) ;

        tArgs2 += T(postSpecsInfoZipP)+tb+T(postToP  )+tb+T(postWildListP) ;
        tArgs1 += T(postSpecsPKZipP  )+tb+T(postToP  )+tb+T(postWildListP) ;
        if( tArgs2.csF( tinP ) ) tArgs2 += tb ;
        if( tArgs1.csF( tinP ) ) tArgs1 += tb ;

        }
            tArgs2 += T(" -x "      )   +T(postWildListExcludeP)+tba ;
            tArgs1 += T(" -exclude ")+tq+T(postWildListExcludeP)+tq  ;
        {
        if( postWildListExcludeP )

        }
            tArgs2 += T(" -i "      )   +T(postWildListIncludeP)+tba ;
            tArgs1 += T(" -include ")+tq+T(postWildListIncludeP)+tq  ;
        {
        if( postWildListIncludeP )

        TN( tArgs2 , ""                                            ) ;
        TN( tArgs1 , "-add"                                        ) ;
        TN( tq , "\""  ) ;
        TN( tb , " "   ) ;
        TN( tba , " @" ) ;
    {
    ZE( osTextT* , postArgs2 ) ;
    ZE( osTextT* , postArgs1 ) ;

    if( postSpecsInfoZipP    ) costAll += thirdC::c_strlenIF( tinP , postSpecsInfoZipP    ) ;
    if( postSpecsPKZipP      ) costAll += thirdC::c_strlenIF( tinP , postSpecsPKZipP      ) ;   // REALLY ONLY NEED THE MAXIMUM LENGTH SINCE ONLY WO SPEC IS USED AT A TIME; DONE THIS WAY FOR SIMPLICITY (SPECS ARE SHORT)
    if( postWildListExcludeP ) costAll += thirdC::c_strlenIF( tinP , postWildListExcludeP ) ;
    if( postWildListIncludeP ) costAll += thirdC::c_strlenIF( tinP , postWildListIncludeP ) ;
    countT                     costAll  = thirdC::c_strlenIF( tinP , postToP   ) + thirdC::c_strlenIF( tinP , postWildListP ) + TUCK ;

    pEtherContainsMe->traceF( tinP , T("[postSpecsInfoZipP   ]:    ")+T(postSpecsInfoZipP)    ) ;
    pEtherContainsMe->traceF( tinP , T("[postSpecsPKZipP     ]:    ")+T(postSpecsPKZipP)      ) ;
    pEtherContainsMe->traceF( tinP , T("[postWildListExcludeP]:    ")+T(postWildListExcludeP) ) ;
    pEtherContainsMe->traceF( tinP , T("[postWildListIncludeP]:    ")+T(postWildListIncludeP) ) ;
    pEtherContainsMe->traceF( tinP , T("[postWildListP       ]:    ")+T(postWildListP)        ) ;
    pEtherContainsMe->traceF( tinP , T("[postToP             ]:    ")+T(postToP)              ) ;

    _IO_

    }
        if( POOP ) return ;

        __Z( pEtherContainsMe  ) ;
        __Z( postWildListP     ) ;
        __Z( postToP           ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT thirdC::diskZipF(   tinS& tinP , const osTextT* const postToP                         , const osTextT* const postWildListP , const osTextT* const postWildListIncludeP , const osTextT* const postWildListExcludeP , const osTextT* const postSpecsPKZipP , const osTextT* const postSpecsInfoZipP , const countT idZipperP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
