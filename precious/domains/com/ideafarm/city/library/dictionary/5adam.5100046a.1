
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.osSleepF( tin0P , TOCK ) ;
etThread.strokeF( tin0P , T("ok\r\n") ) ;
etThread.strokeF( tin0P , T("just returned from destructor\r\n") ) ;
}
    etThread.osSleepF( tin0P , TOCK ) ;
    etThread.strokeF( tin0P , T("about to call destructor in 1 tock\r\n") ) ;
    etThread.loafIF( tin0P ) ;
    etThread.strokeF( tin0P , T("news has been constructed\r\n") ) ;
    newsC news( tin0P , etThread ) ;
{

TODO

}
    }
        ether.strokeF( tin0P , T("connected\r\n") ) ;
        }
            }
                }
                    etPrime.osSleepF( tin0P , TUCK * 0x40 ) ;
                    DEL( psosc ) ;
                    ether.strokeF( tin0P , T(".") ) ;
                    *((tin123S&)tin0P).zEtScratch = 0 ;
                {
                if( *((tin123S&)tin0P).zEtScratch )
                psosc->connectF( tin0P , ifcPORToLD2_NEWS , nnDns ) ;
            {
            else
            if( !psosc ) break ;
            psosc = new( 0 , tin0P , LF ) socketC( tin0P , *((tin123S&)tin0P).zEtScratch , TAG( TAGiDnULL ) ) ;
        {
        while( !psosc && !ether && !etPrime )
        etherC& etPrime = etherC::etPrimeIF( tin0P ) ;

        ether.strokeF( tin0P , T("connecting to dns\r\n") ) ;
    {
    if( !bDns )

    ether.strokeF( tin0P , T(*pnn)+(bDns?T(" dns"):T(" client"))+T("\r\n") ) ;
    boolT bDns = *pnn == nnDns ;
    
    __( *pnn != nnDns && *pnn != nnOther ) ;
    __( cnn - 1 ) ;
    socketC::nicNameIF( tin0P , ether , pnn , cnn ) ; ___( pnn ) ;
    ZE( countT    , cnn ) ;
    ZE( nicNameC* , pnn ) ;
    
    nicNameC nnOther = ether.sockNicNameF( tin0P , T("209.128.78.19") ) ;
    nicNameC nnDns   = ether.sockNicNameF( tin0P , T("209.128.78.20") ) ;

    ether.osThreadF( tin0P , countTC() , tm_NewsC_chatF  , &sgnDone_tm_NewsC_chatF  , flTHREADlAUNCH_null , 0 , 0 , (countT)&bFired , (countT)&bChatEnding  , (countT)this , (countT)&psoss ) ;

    }
        if( ether ) return ;
    {
    IFbEcAREFUL
{
psoss( 0 )
psosc( 0 ) ,
sgnDone_tm_NewsC_chatF( tin0P , TAG( TAGiDnULL ) ) ,
bChatEnding( 0 ) ,
bFired( 0 ) ,
ether( etherP ) ,
/*1*/newsC::newsC( tin0S& tin0P , etherC& etherP ) :/*1*/
/**/
*/
/*

}
    sgnDone_tm_NewsC_chatF.waitF( tin0P ) ;
    }
        ((tin123S&)tin0P).zEtScratch->osSleepF( tin0P , TUCK * 0x40 ) ;
        *((tin123S&)tin0P).zEtScratch = 0 ;
        socksk.connectF( tin0P , ifcPORToLD2_NEWS ) ;
        socketC socksk( tin0P , *((tin123S&)tin0P).zEtScratch , TAG( TAGiDnULL ) ) ;
    {
    while( !bChatEnding )
    *((tin123S&)tin0P).zEtScratch = 0 ;

    DEL( psoss ) ;
    if( psoss ) psoss->stopWaitingF( tin0P ) ;
    DEL( psosc ) ;
    bFired = 1 ;

    TINSL
{
/*1*/newsC::~newsC( voidT )/*1*/
/**/
*/
/*

DONE( tm_NewsC_chatF )
}
    }
        etThread.osSleepF( tin0P , TUCK * 0x40 ) ;
        etThread.strokeF( tin0P , T("waiting for ")+TF1(cSessions)+T(" sessions to end\r\n") ) ;
    {
    while( cSessions )

    }
        }
            }
                }
                    etThread.osThreadF( tin0P , countTC() , tm_newsC_sessionF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&psoss , (countT)&cSessions , (countT)&news , (countT)&bFired ) ;
                    psoss = pso ; pso = 0 ;
                    cSessions ++ ;
                {
                if( !etThread )
            {
            else
            if( bFired ) { DEL( pso ) ; bChatEnding = 1 ; }
            socks.acceptF( tin0P , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            ZE( socketC* , pso ) ;
        {
        while( !bFired && !etThread )

        socks.listenF( tin0P ) ;    
        socks.bindF( tin0P , ifcPORToLD2_NEWS ) ;
        socketC socks( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_DOnOTrEGISTERaCCEPTOR ) ;
    {
    while( !bFired )
    ZE( countT , cSessions ) ;

    socketC*& psoss       = *(socketC**)pTaskP->c4 ;
    newsC&    news        =    *(newsC*)pTaskP->c3 ;
    boolT&    bChatEnding =    *(boolT*)pTaskP->c2 ;
    boolT&    bFired      =    *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tm_NewsC_chatF )

DONE( tm_newsC_sessionF )
}
    cSessions -- ;
    DEL( pso ) ;
    *((tin123S&)tin0P).zEtScratch = 0 ;
    }
        }
            }
                }
                    break ;
                    __1
                    __( idCmd ) ;
                {
                default :
                }
                    break ;
                    pso->writeF( tin0P , sour ) ;
                    soulC sour( tin0P , TAG( TAGiDnULL ) , flSOUL_null , (countT)ifcIDcMDnEWS_PINGrEPLY ) ;
                    bBye = 1 ;
                {
                case ifcIDcMDnEWS_PING :
                }
                    break ;
                    pso->writeF( tin0P , sour ) ;
                    soulC sour( tin0P , TAG( TAGiDnULL ) , flSOUL_null , (countT)ifcIDcMDnEWS_BYErEPLY ) ;
                    bBye = 1 ;
                {
                case ifcIDcMDnEWS_BYE :
            {
            switch( idCmd )
        
            souq >> idCmd ;
            ZE( countT , idCmd ) ;
        {
        if( !*((tin123S&)tin0P).zEtScratch && !bFired )    
        pso->readF( tin0P , souq ) ;
        soulC souq( tin0P , TAG( TAGiDnULL ) ) ;
    {
    while( !etThread && !*((tin123S&)tin0P).zEtScratch && !bBye && !bFired )
    ZE( boolT , bBye ) ;

    pso->myNameF(   tin0P , countTC() , nicNameMe   ) ;
    pso->peerNameF( tin0P , countTC() , nicNamePeer ) ;
    nicNameC nicNameMe ;
    nicNameC nicNamePeer ;

    pso->etherF( tin0P , *((tin123S&)tin0P).zEtScratch ) ;

    boolT&    bFired    =    *(boolT*)pTaskP->c4 ;
    newsC&    news      =    *(newsC*)pTaskP->c3 ;
    countT&   cSessions =    *(boolT*)pTaskP->c2 ;
    socketC*& pso       = *(socketC**)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tm_newsC_sessionF )

;
}
    newsC( tin0S& tin0P , etherC& etherP ) ;
    ~newsC( voidT ) ;

    public :

    socketC*            psoss ;
    socketC*            psosc ;
    boolT               bFired ;
    boolT               bChatEnding ;
    signC               sgnDone_tm_NewsC_chatF ;
    etherC&             ether ;
{
/*1*/class __export newsC/*1*/
/**/
*/
/*

/*1*/WAKEhIDE( "doodle.newsC" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

