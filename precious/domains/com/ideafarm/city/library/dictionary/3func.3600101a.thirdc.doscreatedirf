
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bExisted ;

    }
        }
            delF( tin0P , postShorter ) ;

            }
                __( idImpotence ) ;   // BOSpOOP IS NOT USED BECAUSE THE traceF CALLS RESET ERROR INFO

                }
                    }
                        break ;
                        TELL( postP ) ;
                        //if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("dosCreateDirF / UNK FAIL: [postShorter,idImpotence]:    ")+T(postShorter)+T("    ")+TF2(idImpotence,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    default :
                    }
                        break ;

                        TELL( postP ) ;

                        BLAMMOiD( 0x11772299 ) ;
                        etRock.traceF( tin0P , T("dosCreateDirF: traced  pool tallies; now calling BLAMMO") ) ;
                        etRock.tracePoolTalliesF( tin0P ) ;
                        etRock.traceF( tin0P , T("dosCreateDirF: tracing pool tallies") ) ;
                        etherC& etRock = etherC::etRockIF( tin0P ) ;

                        if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("dosCreateDirF / ERROR_NOT_ENOUGH_MEMORY FAIL: [postShorter,brcQuery]:    ")+T(postShorter)+T("    ")+TF2(((tin1S&)tin0P).brcQuery,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U::
                    {
                    case ifcIDiMPOTENCEbASEeRRORcODE_NOTeNOUGHmEMORY :
                    }
                        break ;
                        if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("dosCreateDirF / ERROR_LOGON_FAILURE: [postShorter]:    ")+T(postShorter) ) ; //U::
                    {
                    case ifcIDiMPOTENCEbASEeRRORcODE_LOGONfAILURE :
                    }
                        break ;
                        //if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("dosCreateDirF / EXISTED: [postShorter]:    ")+T(postShorter) ) ; //U::
                        idImpotence = 0 ;
                        bExisted = 1 ;
                    {
                    case ifcIDiMPOTENCEbASEeRRORcODE_ALREADYeXISTS :
                    }
                        break ;

                        }
                            DEL( pInfoFile ) ;
                            bExisted = 1 ;
                            idImpotence = 0 ;
                        {
                        if( pInfoFile )
                        dosFindFileOrDirF( tin0P , pInfoFile , handle , postShorter ) ; ___( pInfoFile ) ;
                        handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                        ZE( infoFileS* , pInfoFile ) ;
                        //if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("dosCreateDirF / ACCESS DENIED: [postShorter]:    ")+T(postShorter) ) ;
                    {
                    case ifcIDiMPOTENCEbASEeRRORcODE_WRITEpROTECT :
                    case ifcIDiMPOTENCEbASEeRRORcODE_ACCESSdENIED :
                {
                switch( idImpotence )
            {
            if( idImpotence )

            countT idImpotence = IDiMPOTENCEuSE ;

            #endif
                }
                    BOS( WHATgbo , BOSoK , CreateDirectory( postShorter , &sa ) )
                    BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                    SECURITYaTTRIBUTE_saUNRESTRICTED( 0 ) ;
                {
            #elif defined( __NT__ )
                rc = ((tin1S&)tin0P).brcRaw ;
                BOS( WHATsfw , BOSfAIL , DosCreateDir( postShorter , 0 ) )
            #ifdef __OS2__

            //if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("dosCreateDirF: [postShorter]:    ")+T(postShorter) ) ; //U::

            postShorter[ costP - 1 ] = 0 ;
            c_memcpyIF( tin0P , postShorter , postP , costP - 1 ) ;
            newF( tin0P , LF , postShorter , costP ) ; ___( postShorter ) ;
            ZE( osTextT* , postShorter ) ;
        {
        else
        }
            DEL( pInfo ) ;
            }
                __1 ;
                __( postP[ 0 ] ) ;
            {
            if( !bExisted )
            bExisted = !!pInfo ;
            //THIS ERROR DETECTION CODE IS NOW HARMLESS BUT OBSOLETED BY THE 20121001 EDIT OF dosQueryFSInfoF

            dosQueryFSInfoF( tin0P , pInfo , ifFileNameC( tin0P , *this , postP ) ) ; ___( pInfo ) ;
            ZE( infoDisk1S* , pInfo ) ;
        {
        if( postP[ 1 ] == ':' && !postP[ 3 ] )
    {
    ZE( boolT , bExisted ) ;

    }
        }
            }
                BLAMMOiD( 0x73737373 ) ;
                TELL( "this is the call nest that does the bad deed (creating home folder on drive c)" ) ;
                _IO_
            {
            if( postLower == c_strstrIF( postLower , "c:\\ideafarm.home.1" ) )
            c_strlwrIF( tin0P , postLower ) ;
            c_strncpyIF( tin0P , postLower , postP , sizeof postLower ) ;
            osTextT postLower[ TUCK ] ;
        {
        else if( idComputer == IDcOMPUTER_IPDOSmASTERcRAFTWORK )                    //A:ASSUME: THE CRAFTWORK COMPUTER USES DRIVE D FOR ALL HOMES
        if( POOP ) POOPRqUIET
        countT idComputer = ((tin1S&)tin0P).pEtScratch->diskIdF( tin0P , T("///c") ) ;
        SCOOPS
    {
    IFsCRATCHoK
    //U::TO FIND A BUG (TO IDENTIFY THE CODE THAT CREATES AN IDEAFARM HOME FOLDER ON DRIVE C WHEN HOMES EXIST ON DRIVE D)
    //CS:CODEsYNC: 35001185 3600101a

 { BLAMMOiD( 0xc0c0c0c0 ) ; } //U:: REMOVE IN PRODUCTION ; TO FIND THE CODE THAT CREATES HOME ON DRIVE C
if( postP[ 1 ] == ':' && ( *postP == 'c' || *postP == 'C' ) )

    _IO_

    }
        if( POOP ) return 0 ;
        __( postP[ costP - 1 ] - '\\' ) ;
        //__( postP[ 1 ] - ':' ) ;
        if( POOP ) return 0 ;
        __( costP < cMin ) ;
        countT cMin = postP[ 1 ] == ':' ? 3 : 2 ;
        if( POOP ) return 0 ;
        __( costP < 2 ) ;
        __Z( postP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP

    const countT costP = postP ? c_strlenIF( tin0P , postP ) : 0 ;
{
/*1*/boolT thirdC::dosCreateDirF( tin0S& tin0P , const osTextT* const postP )/*1*/

/**/
*/
  "?:\\" (special case: i will verify that drive x exists
  example: "\\fooey\"
  enforces the ifc convention that requires each directory name to end with the delimiter character
 postP
arguments
  \<A HREF=\"5.8d00104.1.1.0.html\"\>8d00104:  WAKEsHOW( "example.simplest.func.102001b.thirdC.dosCreateDirF" )\</A\>
 simplest
examples
\<A HREF=\"5.102001b.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosCreateDirF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

