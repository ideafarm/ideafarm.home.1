
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    #endif

        if( POOP ) valueP = 0 ;
        }
            while( !*this && valueP == STILL_ACTIVE ) ;
            }
                BOSpOOP
                BOS( WHATgbo , BOSoK , GetExitCodeProcess( (HANDLE)hProcess.osF( ifcIDtYPEhANDLE_PROCESS ) , (DWORD*)&valueP ) )
                BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                ++ s ; dosSleepIF( tinBaseP , 16 * 256 ) ;
            {
            do
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        {

        }
            ((tinNormalS&)tinBaseP).pag4->_thirdC_grab_lOsPid.ungrabF( tinBaseP ) ;
            ((tinNormalS&)tinBaseP).pag1->_thirdC_.pSwProcessHandle->freeF( tinBaseP ) ;                                       //A:ASSUME: ONLY I AM WAITING FOR THIS PROCESS.  IT IS ILLEGAL FOR MULTIPLE THREADS TO WAIT FOR A SINGLE PROCESS TO END.
            hProcess.osF( ifcIDtYPEhANDLE_PROCESS , *((tinNormalS&)tinBaseP).pag1->_thirdC_.pSwProcessHandle ) ;
            ((tinNormalS&)tinBaseP).pag1->_thirdC_.lOsPid = osPidP ;
            if( !((tinNormalS&)tinBaseP).pag1->_thirdC_.pSwProcessHandle->idSlotOfLeverF( tinBaseP , osPidP ) ) { BLAMMO ; }     //THIS LINE WILL DETECT MULTIPLE THREADS WAITING FOR A SINGLE PROCESS TO END
            ((tinNormalS&)tinBaseP).pag4->_thirdC_grab_lOsPid.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

            ((tinNormalS&)tinBaseP).pag4->_thirdC_grab_lOsTid.ungrabF( tinBaseP ) ;
            ((tinNormalS&)tinBaseP).pag1->_thirdC_.pSwThreadHandle->freeF( tinBaseP ) ;                                       //A:ASSUME: ONLY I AM WAITING FOR THIS PROCESS.  IT IS ILLEGAL FOR MULTIPLE THREADS TO WAIT FOR A SINGLE PROCESS TO END.
            hThread.osF( ifcIDtYPEhANDLE_THREAD , *((tinNormalS&)tinBaseP).pag1->_thirdC_.pSwThreadHandle ) ;
            ((tinNormalS&)tinBaseP).pag1->_thirdC_.lOsTid = osTidP ;
            if( !((tinNormalS&)tinBaseP).pag1->_thirdC_.pSwThreadHandle->idSlotOfLeverF( tinBaseP , osTidP ) ) { BLAMMO ; }     //THIS LINE WILL DETECT MULTIPLE THREADS WAITING FOR A SINGLE PROCESS TO END
            ((tinNormalS&)tinBaseP).pag4->_thirdC_grab_lOsTid.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

            handleC hThread(  tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_THREAD  ) ;
        {
        handleC hProcess( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_PROCESS ) ;

        BOSnOvALUE( WHATgbo , SetLastError( 0 ) )

        //DOES NOT WORK FOR zip.exe ON 2000: osOpenProcessIF( tinBaseP , hProcess , osPidP ) ;              20240623@1626: CONJ: 04 BIT PROCESS

    #elif defined( __NT__ )

        valueP = info.codeResult ;
        else                                            __( info.codeTerminate ) ;
        else if( info.codeTerminate == TC_HARDERROR   ) idDeathTypeP = ifcPROCESSdEATH_HARDWAREfAILURE ;
        else if( info.codeTerminate == TC_EXCEPTION   ) idDeathTypeP = ifcPROCESSdEATH_SOFTWAREfAILURE ;
        else if( info.codeTerminate == TC_KILLPROCESS ) idDeathTypeP = ifcPROCESSdEATH_MURDERED        ;
             if( info.codeTerminate == TC_EXIT        ) idDeathTypeP = ifcPROCESSdEATH_NORMAL          ;
        if( !POOP ) osPidP = pid ;
        __( osPidP && pid - osPidP ) ;
        BOSpOOP
        BOS( WHATso , BOSfAIL , DosWaitChild( DCWA_PROCESS , DCWW_WAIT , &info , &pid , osPidP ) )
        ZE( ULONG , pid ) ;
        RESULTCODES  info ;

    #if defined( __OS2__ )
    _IO_

    }
        if( POOP ) return ;
        __Z( ((tinNormalS&)tinBaseP).pag1->_thirdC_.pSwProcessHandle->idSlotOfLeverF( tinBaseP , osPidP ) ) ;
        __Z( ((tinNormalS&)tinBaseP).pag1->_thirdC_.pSwThreadHandle->idSlotOfLeverF( tinBaseP , osTidP ) ) ;
        __( valueP ) ;
        __( idDeathTypeP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
    SCOOP
{
/*1*/voidT thirdC::dosWaitChildF( tinBaseS& tinBaseP , countT& valueP , countT& idDeathTypeP , countT& osTidP , countT& osPidP )/*1*/

/**/
*/
 pidP
 valueP
 idDeathTypeP
arguments
on windows, idDeathTypeP is not set
on windows, an extra delay is added due to polling
blocks until the specified process ends
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.1020079.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosWaitChildF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

