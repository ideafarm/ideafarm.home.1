
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    TELL( "server: destroying locals 0 (no action here)" )
    }
        TELL( "server: destroying locals 1 (nothing interesting)" )
        }
            TELL( "server: destroying locals 2 (sw_pso)" )
            }
                TELL( "server: destroying locals 3 (sw_cSessionWithPeer)" )
                }
                    }
                        DELzOMBIE( pDoomed ) ;
                        taskDrivenServerJobS* pDoomed = &jobP ;
                        taskDrivenServerJobS& jobP = *(taskDrivenServerJobS*)_pbaJob ;
                        stJob >> pbJob ;
                        byteT* pbJob = _pbaJob ;
                        byteT _pbaJob[ sizeof( taskDrivenServerJobS ) ] ;
                    {
                    while( stJob )

                    TELL( "server: destroying locals 4 (stJob)" )
                    }
                        TELL( "server: destroying locals 5 (after stJob)" )
                        }
                            TELL( "server: after maybe deleting sessionsC instance" )

                            }
                                DELzOMBIE( pzSessions ) ;
                                sessionsC* pzSessions = (sessionsC*)pbSessions ;
                                TELL( "server: definitely deleting sessionsC instance" )
                                _IO_
                            {
                            if( bDeleteSessions )
                            TELL( "server: maybe deleting sessionsC instance" )

                            }
                                }
                                    ++ s ; thirdC::dosSleepIF( tinBaseP , TUCK * 0x40 ) ;

                                    stJob.ungrabF( tinBaseP ) ;
                                    new( 0 , tinBaseP , (byteT*)&(countT&)stJob[ 1 ] , sizeof( taskDrivenServerJobS ) ) taskDrivenServerJobS() ;
                                    stJob << (byteT*)0 ;
                                    stJob.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                                    LOGrAW5( "ifcDrivenServerF / terminating [cWorker,cSession]:    " , cWorker , "    " , cSession , "\r\n" ) ;
                                {
                                while( cSession || cWorker )
                                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                            {
                            TELL( "server: final wait (forever) for all sessions to end" )

                            sw_pso.ungrabF( tinBaseP ) ;
                            }
                                }
                                    }
                                        if( POOP ) POOPR
                                        ((tinFullS&)tinBaseP).pEtScratch->sockCancelF( tinBaseP , hSoc ) ;
                                        SCOOPS
                                        //}
                                        //    thirdC::dosTellMonitorIF( tinBaseP , tellC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEtELLsYS_LOG , poste , sizeof poste ) , ifcIDbOOKStELL_SYS ) ;
                                        //    const osTextT poste[] = "ifcDrivenServerF: canceling a client session because i am quitting" ;
                                        //{
                                        const handleC& hSoc = pso->handleF( tinBaseP ) ;
                                        TELL( "server: canceling a client session" )
                                    {
                                    if( pso )
                                    socketC*& pso = (socketC*&)(countT&)sw_pso ;
                                    lever_idSession = sw_pso.leverF( tinBaseP , idf ) ;
                                {
                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                countT cFlavors = sw_pso.cFlavorsF( tinBaseP ) ;
                                _IO_
                            {
                            sw_pso.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                            }
                                }
                                    while( cSession && cTries -- ) { ++ s ; thirdC::dosSleepIF( tinBaseP , time1nap ) ; }
                                    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                                {
                                TELL( "server: will wait for a while to see cSession = 0" )

                                }
                                    time1nap = info2P.time1grace / cTries ;
                                    cTries >>= 1 ;
                                {
                                while( time1nap < TUCK * 0x40 && cTries > 1 )
                                countT time1nap = info2P.time1grace / cTries ;
                                countT cTries = 0x10 ;
                            {
                            else if( info2P.time1grace )
                            }
                                }
                                    while( cSession ) { ++ s ; thirdC::dosSleepIF( tinBaseP , TUCK * 0x40 ) ; }
                                    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                                {
                                TELL( "server: will wait forever until cSession is 0" )
                            {
                            if( info2P.time1grace == - 1 )

                            if( info2P.bState ) if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->ungrabF( tinBaseP ) ;

                            }
                                //A:  THREADmODE2rESTORE
                                //A:  DEL( pState ) ;
                                //A:  THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                                //A:  info1P.ppbdVarying = 0 ;
                                //A:  *info1P.ppbdVarying = 0 ; //U::BUG: MIGRATED FROM pbdVarying WITHOUT ADEQUATE STUDY; THIS FUNCTION COULD CONTAIN A BUG IN CODE HANDLING THIS MEMBER
                                //A:  if( info2P.stateEndF ) (*info2P.stateEndF)( tinBaseP , *this , *info1P.ppbdVarying , info2P.cbdVarying , info2P.cArg ) ;
                                //A:  if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                                //A: 20141130@1135: COMMENTED OUT AS PART OF ELIMINATION OF stateC
                            {
                            //if( pState )

                            }
                                info1P.sgnIdPortReplaced.giveF( tinBaseP ) ;
                                TELL( "server: cleaning up" )

                                }
                                    if( POOP ) POOPR

                                    }
                                        }
                                            etRock.traceF( tinBaseP , T("ifcDrivenServerF / could not dt listener socket") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                            POOPRqUIET
                                        {
                                        if( POOP )
                                        }
                                            DEL( psoListen ) ;
                                            _IO_
                                        {
                                        SCOOPS
                                    {
                                    IFsCRATCH
                                    TELL( "server: destroying listener socket" )
                                    info1P.idPort = 0 ;

                                    }
                                        }
                                            //THREADmODE5rESTORE
                                            }
                                                }
                                                    }
                                                        }
                                                            }
                                                                etRock.traceF( tinBaseP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                                etRock.traceF( tinBaseP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                                etRock.traceF( tinBaseP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                                etRock.traceF( tinBaseP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                                etRock.traceF( tinBaseP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                                etRock.traceF( tinBaseP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                                //CS:CODEsYNC: 360021f7 3600212d

                                                                etRock.traceF( tinBaseP , T("ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                            {
                                                            else
                                                            }
                                                                }
                                                                    //etRock.traceF( tinBaseP , T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                                    //etRock.traceF( tinBaseP , T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                                    //etRock.traceF( tinBaseP , T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                                    //etRock.traceF( tinBaseP , T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                                    //etRock.traceF( tinBaseP , T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                                    //etRock.traceF( tinBaseP , T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                                    //CS:CODEsYNC: 360021f7 3600212d

                                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / launched server thread") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                                {
                                                                else
                                                                }
                                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                                    //CS:CODEsYNC: 360021f7 3600212d

                                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / error: could not launch server thread") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                                    POOPR
                                                                {
                                                                if( POOP )

                                                                ZE( countT , tid ) ; ((tinFullS&)tinBaseP).pEtScratch->osThreadF( tinBaseP , tid , info1P.tmF , 0 , 0  , flTHREADlAUNCH_SHOWpONY , 0 , (countT)&info1P.bQuit , (countT)&stJob , (countT)pJob , (countT)&cWorker ) ;
                                                                inc02AM( cWorker ) ;
                                                                //etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / launching server thread for this client") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                                etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / launching server thread for this client") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                                TELL( "server: launching server thread for this client" )
                                                            {
                                                            if( pJob )

                                                            taskDrivenServerJobS* pJob = new( 0 , tinBaseP , LF ) taskDrivenServerJobS( idSessionLath , lever_idSession , sw_pso , cSession , info2P.cArg , lever_nnPeer , sw_cSessionWithPeer , sessions , nnPeer , timeAccepted1 , timeAccepted2 , timeJobCreated1 , timeJobCreated2 ) ; ___( pJob ) ;
                                                            /*if( bHeIsWatchDeadman1 )*/ //etRock.traceF( tinBaseP , T("ifcDrivenServerF / launching a job thread"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                        {
                                                        else
                                                        }
                                                            stJob.ungrabF( tinBaseP ) ;

                                                            //taskDrivenServerJobS& jobMe = *(taskDrivenServerJobS*)&(countT&)stJob[ 1 ] ; //U:: TO FIND A BUG

                                                            //taskDrivenServerJobS& fooDebug2 = *(taskDrivenServerJobS*)pbTop ;
                                                            //new( 0 , tinBaseP , pbTop , sizeof( taskDrivenServerJobS ) ) taskDrivenServerJobS( idSessionLath , pso , lever_idSession , sw_pso , cSession , info2P.cArg , lever_nnPeer , sw_cSessionWithPeer , sessions , nnPeer ) ;
                                                            //byteT* pbTop = (byteT*)&(countT&)stJob[ 1 ] ;

                                                            etRock.traceF( tinBaseP , T("ifcDrivenServerF pushed a job [cJobsHighWater,cPlates]:    ")+TF2(cJobsHighWater,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(stJob,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                            //taskDrivenServerJobS jobCopy = *(taskDrivenServerJobS*)&(countT&)stJob[ 1 ] ; //U:: TO FIND A BUG

                                                            }
                                                                etRock.traceF( tinBaseP , T("ifcDrivenServerF / backlog is rising [cJobsHighWater]:    ")+TF2(cJobsHighWater,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                                cJobsHighWater = cJobsNow ;
                                                            {
                                                            if( cJobsHighWater < cJobsNow )
                                                            countT cJobsNow = stJob ;

                                                            new( 0 , tinBaseP , (byteT*)&(countT&)stJob[ 1 ] , sizeof( taskDrivenServerJobS ) ) taskDrivenServerJobS( idSessionLath , lever_idSession , sw_pso , cSession , info2P.cArg , lever_nnPeer , sw_cSessionWithPeer , sessions , nnPeer , timeAccepted1 , timeAccepted2 , timeJobCreated1 , timeJobCreated2 ) ;
                                                            stJob << (byteT*)0 ;
                                                            stJob.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                                                            //taskDrivenServerJobS fooDebug1( idSessionLath , pso , lever_idSession , sw_pso , cSession , info2P.cArg , lever_nnPeer , sw_cSessionWithPeer , sessions , nnPeer ) ;
                                                            /*if( bHeIsWatchDeadman1 )*/ //etRock.traceF( tinBaseP , T("ifcDrivenServerF / pushing a job"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                        {
                                                        if( cWorkersSave )

                                                        osTimeNowF( tinBaseP , timeJobCreated1 , timeJobCreated2 ) ;
                                                        ZE( sCountT , timeJobCreated2 ) ;
                                                        ZE( countT  , timeJobCreated1 ) ;

                                                        inc02AM( cSession ) ;
                                                    {
                                                    if( !POOP )
                                                    //if( 0x401043a == processGlobal1I.idAdamRoot ) ifcSayIF( T("about to launch service thread: third is ")+T(third?"IMPOTENT":"potent") , flSAY_APPEND | flSAY_LOG ) ;

                                                    sw_cSessionWithPeer.ungrabF( tinBaseP ) ;
                                                    ++ sw_cSessionWithPeer ;
                                                    lever_nnPeer = nnPeer ;
                                                    if( sw_cSessionWithPeer.cFlavorsF( tinBaseP ) > TUCK ) sw_cSessionWithPeer.freeAllF( tinBaseP ) ;
                                                    sw_cSessionWithPeer.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                                                    sw_pso.ungrabF( tinBaseP ) ;
                                                    else          { BLAMMO ; }
                                                    if( !sw_pso ) sw_pso = (countT)pso ;
                                                    lever_idSession = ++ idSessionLath ;
                                                    sw_pso.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                                                    TELL( "server: preparing to serve the accepted socket" )
                                                    //etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / preparing to serve this client") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                    //etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / preparing to serve this client") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                    //etRock.traceF( tinBaseP , T("ifcDrivenServerF / counting this new session"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                    stRecentPeer.sinkF( tinBaseP , countTC() , nnPeer , flSTACKsINK_UNIQUE ) ;
                                                {
                                                else if( pso )
                                                }
                                                    }
                                                        DEL( pso ) ;
                                                        _IO_
                                                    {
                                                    TELL( "server: deleting the accepted socket without serving it" )

                                                    //etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / deleting accepted socket without serving it (bQuit | third | bSilent | POOP)") , flTRACE_null     , ifcIDtRACEdIVERT_7 ) ;
                                                    //etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / deleting accepted socket without serving it (bQuit | third | bSilent | POOP)") , flTRACE_null     , ifcIDtRACEdIVERT_6 ) ;
                                                    //etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / deleting accepted socket without serving it (bQuit | third | bSilent | POOP)") , flTRACE_null     , ifcIDtRACEdIVERT_5 ) ;
                                                    //etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / deleting accepted socket without serving it (bQuit | third | bSilent | POOP)") , flTRACE_null     , ifcIDtRACEdIVERT_4 ) ;
                                                    //etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / deleting accepted socket without serving it (bQuit | third | bSilent | POOP)") , flTRACE_null     , ifcIDtRACEdIVERT_3 ) ;
                                                    //etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / deleting accepted socket without serving it (bQuit | third | bSilent | POOP)") , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_2 ) ;
                                                    //CS:CODEsYNC: 360021f7 3600212d

                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / deleting accepted socket without serving it"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                {
                                                if( info1P.bQuit || third || bSilent || POOP )

                                                sw_cSessionWithPeer.ungrabF( tinBaseP ) ;

                                                //20240211@1057: COMMENTED OUT W/O ANALYSIS: bSilent = 0 ; //U::20220119@1157: TO FIND A BUG

                                                }
                                                    }
                                                        //stBadPeer.sinkF( tinBaseP , countTC() , nnPeer , flSTACKsINK_UNIQUE ) ;
                                                        //etRock.traceF( tinBaseP , T("ifcDrivenServerF / remembering bad peer [cBadPeer,nnPeer]:    ")+TF2((countT)stBadPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnPeer) ) ;
                                                        //U:: STUTTERING SHOULD NOT RESULT IN PERMANENT "BAD PEER" DESIGNATION ; THAT IS TOO SEVERE ; IMPOSE PERMANENT BANISHMENT ONLY FOR E.G. REPEAT OFFENDERS

                                                        bSilent |= 1 ; //TO PREVENT WO PEER FROM OPENING MANY SESSIONS TO DOS ATTACK
                                                        if( stRecentPeer( nnPeer ) ) etRock.traceF( tinBaseP , T("ifcDrivenServerF / too recently connected [nnPeer]:    ")+T(nnPeer) ) ;
                                                        //etRock.traceF( tinBaseP , T("ifcDrivenServerF / setting bSilent (too many sessions with this nnPeer)") ) ;
                                                    {
                                                    )
                                                        )
                                                            )
                                                                stRecentPeer( nnPeer )
                                                                ||
                                                                stBadPeer( nnPeer )
                                                                ||
                                                                cSession                             //20210717@1537: CHANGED FROM "0x10 < cSession" TO "cSession" SO EACH PEER IS ONLY ALLOWED WO SESSION AT A TIME
                                                            (
                                                            &&
                                                            !bHeIsWatchDeadman2
                                                            &&
                                                            !bHeIsWatchDeadman1
                                                        (
                                                        ||
                                                        bHeIsSpoofingMe
                                                    (
                                                    if

                                                    //if( !bHeIsWatchDeadman1 && !bHeIsWatchDeadman2 ) etRock.traceF( tinBaseP , T("ifcDrivenServerF / checking session count and recents and baddies with this nnPeer [cSessionMax,cSession,nnPeer]:    ")+TF2(info2P.cSessionMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnPeer) ) ;

                                                    countT cSession = sw_cSessionWithPeer ;
                                                {

#endif
                                                }
                                                    }
                                                        }
                                                            delF( tinBaseP , pnnBad ) ;

                                                            delF( tinBaseP , psttFile ) ;
                                                            //etRock.traceF( tinBaseP , T("snapshot [psttFile]:    ")+T(psttFile)  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                            THREADmODE2rESTORE ;
                                                            boxPutGenerationF( tinBaseP , psttFile , tSnapBadPeersFileLike , TOCK , (byteT*)pnnBad , sizeof( nicNameC ) * cDoSave ) ; ___( psttFile ) ;
                                                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING ) ;
                                                            ZE( strokeS* , psttFile ) ;

                                                            while( -- cDo && !stBadPeer.third && ~hDown ) ;
                                                            do *( pc ++ ) = *(nicNameC*)&stBadPeer.downF( tinBaseP , hDown ) ;
                                                            handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                                            nicNameC* pc = pnnBad ;
                                                            newF( tinBaseP , LF , pnnBad , cDo ) ; ___( pnnBad ) ;
                                                            ZE( nicNameC* , pnnBad ) ;

                                                            countT cDo = cDoSave ;
                                                        {
                                                        if( cDoSave )
                                                        const countT cDoSave = stBadPeer ;
                                                    {
                                                    if( timeN2 || timeN1 > TICK << 4 )
                                                    osTimeSubtractF( tinBaseP , timeN1 , timeN2 , timeSnapBad1 , timeSnapBad2 ) ;

                                                    osTimeNowF( tinBaseP , timeN1 , timeN2 ) ;
                                                    ZE( sCountT , timeN2 ) ;
                                                    ZE( countT  , timeN1 ) ;
                                                {
#if defined( NEVERdEFINED )
//DISABLED BECAUSE stBadPeer IS NOT USED YET

                                                }
                                                    }
                                                        stRecentPeer.purgeF( tinBaseP ) ;
                                                        //etRock.traceF( tinBaseP , T("purging stRecentPeer [cPlates]:    ")+TF2(stRecentPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                    {
                                                    if( timeN2 || timeN1 > TOCK || stRecentPeer > TUCK << 2 )
                                                    osTimeSubtractF( tinBaseP , timeN1 , timeN2 , timeLathPurgeRecentPeer1 , timeLathPurgeRecentPeer2 ) ;
                                                    osTimeNowF( tinBaseP , timeN1 , timeN2 ) ;
                                                    ZE( sCountT , timeN2 ) ;
                                                    ZE( countT  , timeN1 ) ;
                                                {

                                                lever_nnPeer = nnPeer ;
                                                sw_cSessionWithPeer.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                                                TELL( "server: detecting dos attack client" )
                                                //U::EXCLUDE ZOMBIE SESSIONS FROM THE COUNT, SO HTTP CLIENT CAN INITIATE AN ARBITRARILY LONG BURST OF SESSIONS TO GET E.G. ALL IMAGES FOR A PAGE

                                                ( bRefuse || bSilent ? cRefused : cAccepted ) ++ ;
                                                if( bRefuse ) { LOGrAW( "refusing a client\r\n" ) ; }
                                                //20240211@1057: COMMENTED OUT W/O ANALYSIS: bRefuse = 0 ; //U:: 20200907@1413 DISABLE ALL ATTACK DETECTION, WHICH WILL BE REWRITTEN AFTER STUDYING LOGS
                                                //20240211@1057: COMMENTED OUT W/O ANALYSIS: bSilent = 0 ; //U::20210914@1613: SERVE UNCONDITIONALLY TO USE AS DUT FOR NEW FIREWALL

#endif
                                                }
                                                    }
                                                        }
                                                            }
                                                                if( POOP ) { POOPR }
                                                                ((tinFullS&)tinBaseP).pEtScratch->diskMoveFileOrDirF( tinBaseP , tListBlock , tListAllowWoMore , 1 ) ;
                                                                SCOOPS
                                                            {
                                                            IFsCRATCH
                                                        {
                                                        if( !bSilent )

                                                        bSilent = diskFileExistsF( tinBaseP , tListBlock ) ;
                                                    {
                                                    else
                                                    }
                                                        }
                                                            if( POOP ) POOPR

                                                            ((tinFullS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tListBlock       , 1 ) ; if( POOP ) { POOPR }
                                                            ((tinFullS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tListAllowWoMore , 1 ) ; if( POOP ) { POOPR }
                                                            SCOOPS
                                                        {
                                                        IFsCRATCH
                                                    {
                                                    if( bHuman || bWhite )

                                                    boolT bWhite = diskFileExistsF( tinBaseP , tListWhite ) ;
                                                    boolT bHuman = diskFileExistsF( tinBaseP , tListHuman ) ;

                                                    tListWhite += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(nnPeer) ;
                                                    tListWhite += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(nnPeer) ;
                                                    tListWhite += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/white/")+T(nnPeer) ;
                                                    TlIST( tListWhite ) ;

                                                    tListBlock += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(nnPeer) ;
                                                    tListBlock += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(nnPeer) ;
                                                    tListBlock += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/block/")+T(nnPeer) ;
                                                    TlIST( tListBlock ) ;

                                                    tListAllowWoMore += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(nnPeer) ;
                                                    tListAllowWoMore += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(nnPeer) ;
                                                    tListAllowWoMore += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/allowWoMore/")+T(nnPeer) ;
                                                    TlIST( tListAllowWoMore ) ;

                                                    tListHuman += T("////factory6/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(nnPeer) ;
                                                    tListHuman += T("////factory4/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(nnPeer) ;
                                                    tListHuman += T("////factory2/d/ideafarm.home.101/ephemeral/domains/com/ideafarm/ipdos/attackers/human/")+T(nnPeer) ;
                                                    TlIST( tListHuman ) ;
                                                {
                                                if( !bSilent )
#if defined( NEVERdEFINED )
//U:: 20200907@1413 DISABLE ALL (OLD) ATTACK DETECTION, WHICH WILL BE REWRITTEN AFTER STUDYING LOGS

                                                //if( 0x401043a == processGlobal1I.idAdamRoot ) ifcSayIF( T("acceptF returned (2); bSilent: ")+TF1(bSilent) , flSAY_APPEND | flSAY_LOG ) ;
                                                }
                                                    b_pnnSilent.ungrabF( tinBaseP ) ;
                                                    }
                                                        }
                                                            break ;
                                                            LOGrAW3( "peer is on the silence list [nnPeer]: " , nnPeer , "\r\n" ) ;

                                                            etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                            etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                            etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                            etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                            etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                            etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                            //CS:CODEsYNC: 360021f7 3600212d

                                                            etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                            bSilent = 0 ; //U::20210914@1613: SERVE UNCONDITIONALLY TO USE AS DUT FOR NEW FIREWALL
                                                            bSilent = 1 ;
                                                        {
                                                        if( nnPeer == pnnSilent[ off ] )
                                                    {
                                                    for( countT off = 0 ; off < cnnSilent ; off ++ )
                                                    b_pnnSilent.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                                                {
                                                if( !bHeIsMe && !bSilent )
                                                boolT bSilent = bHeIsSpoofingMe || !bPeerAllowed ;

                                                //if( 0x401043a == processGlobal1I.idAdamRoot ) ifcSayIF( T("acceptF returned (1); nnPeer: ")+T(nnPeer)+T("; bRefuse: ")+TF1(bRefuse) , flSAY_APPEND | flSAY_LOG ) ;
                                                TELL( "server: a client has connected" )
                                                //etRock.traceF( tinBaseP , T(nnPeer)+T("    ifcDrivenServerF / a client has connected") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                //if( bHeIsWatchDeadman1 ) etRock.traceF( tinBaseP , T("ifcDrivenServerF / a client has connected") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                }
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_7 ) ;
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_6 ) ;
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_5 ) ;
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_4 ) ;
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_3 ) ;
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_2 ) ;
                                                    //CS:CODEsYNC: 360021f7 3600212d

                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                {
                                                if( bHeIsSpoofingMe )

                                                else                           etRock.traceF( tinBaseP , T("ifcDrivenServerF / accepted from a host other than me [idAccept,nnPeer]:    "                                                    )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnPeer)                                                                                                                                                                                                        , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                else if(  bLoopback          ) etRock.traceF( tinBaseP , T("ifcDrivenServerF / accepted from loopback [idAccept]:    "                                                                       )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                                                                                                                                                                                                                      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                else if(  bHeIsMe            ) etRock.traceF( tinBaseP , T("ifcDrivenServerF / accepted from me host [idAccept]:    "                                                                        )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                                                                                                                                                                                                                      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                else if(  bHeIsWatchDeadman2 ) etRock.traceF( tinBaseP , T("ifcDrivenServerF / accepted from watch deadman2 [idAccept]:    "                                                                 )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                                                                                                                                                                                                                      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                else if(  bHeIsWatchDeadman1 ) etRock.traceF( tinBaseP , T("ifcDrivenServerF / accepted from watch deadman1 [idAccept]:    "                                                                 )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                                                                                                                                                                                                                      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                     if(  bHeIsSpoofingMe    ) etRock.traceF( tinBaseP , T("ifcDrivenServerF / accepted i am being spoofed [idAccept,idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                bHeIsSpoofingMe = 0 ; //U::20210914@1613: SERVE UNCONDITIONALLY TO USE AS DUT FOR NEW FIREWALL

                                                boolT bHeIsSpoofingMe = bHeIsMe && !bHeIsWatchDeadman1 && !bHeIsWatchDeadman2 ;

                                                boolT bHeIsWatchDeadman2 = bHeIsMe && idpPeer == idPortWatchHttpDeadman2Snap ;
                                                boolT bHeIsWatchDeadman1 = bHeIsMe && idpPeer == idPortWatchHttpDeadman1Snap ;

                                                }
                                                    }
                                                        break ;
                                                        bHeIsMe = 1 ;
                                                    {
                                                    if( pNicNameMe[ offMe ] == nnPeer )
                                                {
                                                for( countT offMe = 0 ; offMe < cNicNameMe ; offMe ++ )
                                                ZE( boolT , bHeIsMe ) ;

                                                boolT bLoopback = nnPeer.isLoopbackOldDoNotUseF() ;

                                                bPeerAllowed = !info2P.pnnAllowedStripe ? 1 : *info2P.pnnAllowedStripe & nnPeer ;

                                                }
                                                    if( POOP ) POOPR

                                                    }
                                                        break ;

                                                        etRock.traceF( tinBaseP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                        etRock.traceF( tinBaseP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                        etRock.traceF( tinBaseP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                        etRock.traceF( tinBaseP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                        etRock.traceF( tinBaseP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                        etRock.traceF( tinBaseP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                        //CS:CODEsYNC: 360021f7 3600212d

                                                        etRock.traceF( tinBaseP , T("ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                        }
                                                            POOPRqUIET

                                                            }
                                                                POOPRqUIET
                                                                DEL( psoListen ) ;                  // THIS IS THE OFFENDING LINE IN WHICH OpenSSL NEVER RETURNS
                                                                _IO_
                                                            {                                       // DONE SEPARATELY SO CALL NEST WILL SHOW WHICH IS HUNG IF HANG IS EVER OBSERVED AGAIN
        
                                                            }
                                                                POOPRqUIET
                                                                DEL( pso ) ;                        // THIS IS THE OFFENDING LINE IN WHICH OpenSSL NEVER RETURNS (HAPPENS SOMETIMES BUT NOT ALWAYS HERE)
                                                                _IO_
                                                            {                                       // DONE SEPARATELY SO CALL NEST WILL SHOW WHICH IS HUNG IF HANG IS EVER OBSERVED AGAIN

                                                            _IO_
                                                        {

                                                        etRock.traceF( tinBaseP , T("ifcDrivenServerF / accept failed") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                        POOPRqUIET
                                                    {
                                                    if( idSubTypeSave )
                                                    idPortWatchHttpDeadman2Snap = home.idPortWatchHttpDeadman2 ;
                                                    idPortWatchHttpDeadman1Snap = home.idPortWatchHttpDeadman1 ;

                                                    //CONoUTrAW( "." ) ; //U:: TO FIND A BUG
                                                    osTimeNowF( tinBaseP , timeAccepted1 , timeAccepted2 ) ;
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / called  acceptF [idSubType]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                    const countT idSubTypeSave = POOP ;
                                                    psoListen->acceptF( tinBaseP , pso , idpPeer , nnPeer , bRefuse ) ; ___( pso ) ; //IF ALL SESSIONS END WHILE BLOCKED HERE, WILL STILL REFUSE WO SESSION; THIS CAN BE FIXED BY FRESHING bRefuse AT END OF EACH SESSION THREAD IN DONEtMsERVER
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / calling acceptF") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                    SCOOPS
                                                {
                                                IFsCRATCH
                                                ZE( boolT , bPeerAllowed ) ;
                                                ZE( socketC* , pso ) ;
                                                idAccept ++ ;
                                                //etRock.traceF( tinBaseP , T("ifcDrivenServerF / waiting for a client to connect") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                //etRock.traceF( tinBaseP , T("ifcDrivenServerF / waiting for a client to connect") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                TELL( "server: waiting for a client to connect" )
                                                ZE( countT , idPortWatchHttpDeadman2Snap ) ;
                                                ZE( countT , idPortWatchHttpDeadman1Snap ) ;
                                                ZE( sCountT , timeAccepted2 ) ;
                                                ZE( countT  , timeAccepted1 ) ;
                                                nicNameC nnPeer ;
                                                ZE( countT , idpPeer ) ;

                                                }
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                    //CS:CODEsYNC: 360021f7 3600212d

                                                    etRock.traceF( tinBaseP , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                    LOGrAW( tSay ) ;
                                                    TN( tSay , "" ) ; tSay = TT(timeN1,timeN2)+T("| ifcDrivenServerF/too many sessions, so will refuse the next connection attempt\r\n") ;
                                                    osTimeNowF( tinBaseP , timeN1 , timeN2 ) ;
                                                    ZE( sCountT , timeN2 ) ;
                                                    ZE( countT  , timeN1 ) ;
                                                {
                                                if( bRefuse )
                                                bRefuse = 0 ; //U:: 20200907@1413 DISABLE ALL ATTACK DETECTION, WHICH WILL BE REWRITTEN AFTER STUDYING LOGS
                                                boolT bRefuse = info2P.cSessionMax <= cSession ;
                                                //etRock.traceF( tinBaseP , T("ifcDrivenServerF / inspecting [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                TELL( "server: beginning loop" )
                                            {
                                            while( !info1P.bQuit && !POOP )
                                            ZE( countT , cRefused ) ;
                                            ZE( countT , cAccepted ) ;
                                            //THREADmODE5oN( flTHREADmODE5_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY )
                                        {
                                        if( psoListen )

                                        //LOGrAW3( "listener socket has been bound to port [idPort]: " , info1P.idPort , "\r\n" ) ;
                                        }
                                            }
                                                etRock.traceF( tinBaseP , T("ifcDrivenServerF / could not configure (name, bind, listen) listener socket [idPort]:    ")+TF2(info1P.idPort,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                }
                                                    POOPRqUIET
                                                    DEL( psoListen ) ;
                                                    POOPRqUIET
                                                    _IO_
                                                {
                                            {
                                            else
                                            }
                                                etRock.traceF( tinBaseP , T("ifcDrivenServerF / listener socket has been bound [idPort]:    ")+TF2(info1P.idPort,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                            {
                                            if( !POOP )

                                            }   
                                                info1P.sgnIdPortReplaced.giveF( tinBaseP ) ;
                                                psoListen->listenF( tinBaseP ) ;
                                                info1P.idPort = psoListen->bindF( tinBaseP , info2P.idPortHint ) ;
                                            {
                                            if( !info1P.bQuit )

                                            if( info2P.psttName ) psoListen->nameF( tinBaseP , info2P.psttName ) ;
                                            SCOOPS
                                        {
                                        IFsCRATCH
                                    {
                                    if( psoListen )

                                    delF( tinBaseP , psttPemPrivateKey   ) ;
                                    delF( tinBaseP , psttPemCertificates ) ;
                                    }
                                        }
                                            etRock.traceF( tinBaseP , T("ifcDrivenServerF / could not ct listener socket")  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                            }
                                                POOPRqUIET
                                                DEL( psoListen ) ;
                                                POOPRqUIET
                                                _IO_
                                            {
                                        {
                                        if( POOP )
                                        psoListen = new( 0 , tinBaseP , LF ) socketC( tinBaseP , *((tinFullS&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , info2P.flagsSocket , 0 , &info1P.time1idleTimeoutRead , &info1P.time1idleTimeoutWrite , 0 , psttPemCertificates , psttPemPrivateKey ) ; ___( psoListen ) ;
                                        SCOOPS
                                    {
                                    IFsCRATCH
                                    ZE( socketC* , psoListen ) ;

                                    }
                                        strMakeF( tinBaseP , LF , psttPemPrivateKey   , T("///c/certbot/live/factory1.ideafarm.com/privkey.pem")   ) ; ___( psttPemPrivateKey   ) ;
                                        strMakeF( tinBaseP , LF , psttPemCertificates , T("///c/certbot/live/factory1.ideafarm.com/fullchain.pem") ) ; ___( psttPemCertificates ) ;
                                        // ACCESS WILL BE DENIED IF NOT RUN ELEVATED
                                    {
                                    if( F(info2P.flagsSocket) & flSOCKETc_CRYPTfOREIGNsSL )
                                    ZE( strokeS* , psttPemPrivateKey   ) ;
                                    ZE( strokeS* , psttPemCertificates ) ;

                                    TELL( "server: constructing listener socket" )
                                    SCOOPS
                                {
                                while( !info1P.bQuit )

                                ZE( countT , idAccept ) ;
                                threadC th( tinBaseP , *this , TAG( TAGiDnULL ) , tmLoadSilentF , cArg_tmLoadSilent , flTHREADlAUNCH_SHOWpONY ) ;
                                TELL( "server: launching thread tmLoadSilentF" )

                                countT cArg_tmLoadSilent = (countT)pc8tp ;
                                pc8tp->c3 = (countT)&cnnSilent ;
                                pc8tp->c2 = (countT)&pnnSilent ;
                                pc8tp->c1 = (countT)&b_pnnSilent ;
                            {
                            if( pc8tp )
                            newF( tinBaseP , LF , pc8tp ) ; ___( pc8tp ) ;
                            ZE( count8S* , pc8tp ) ;

                            ZE( countT    , cnnSilent ) ;
                            ZE( nicNameC* , pnnSilent ) ;
                            batonC b_pnnSilent( tinBaseP , TAG( TAGiDnULL ) ) ;
                            TELL( "server: continuing to set up" )
                            //DUPLICATE CODE: 1030168 2540104

                            }
                                //A:  }
                                //A:      if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->ungrabF( tinBaseP ) ;
                                //A:      if( info2P.stateBeginF ) (*info2P.stateBeginF)( tinBaseP , *this , *info1P.ppbdVarying , info2P.cbdVarying , info2P.cArg ) ;
                                //A:      info1P.ppbdVarying = (byteT**)&pState->pbdVarying ; //COMPILERbUG: WATCOM BARFS WITHOUT THE CAST
                                //A:      if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                                //A:  {
                                //A:  if( pState )
                                //A:  pState = new( 0 , tinBaseP , LF ) stateC( tinBaseP , *this , info1P.bHandedOff , 0 , info2P.cbdVarying , translateStateDrivenServerF , info2P.cArg , info2P.psttSuffix ) ; ___( pState ) ;
                                //A:  ((tinFullS&)tinBaseP).pag1->pTranslateStateCallerCBF = info2P.translateStateF ;
                                //A:  TELL( "server: constructing state" )
                                //A: 20141130@1135: COMMENTED OUT AS PART OF ELIMINATION OF stateC
                            {
                            if( info2P.bState )
                            //A: ZE( stateC* , pState ) ;
                            ZE( countT , idSessionLath ) ;
                        {
                        if( !POOP )
                        TN( tSnapBadPeersFileLike , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/" ) ; tSnapBadPeersFileLike += TF2(processGlobal1I.idAdamRoot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("/bad.peers") ;
                        TN( tb4 , "    " ) ;

                        homeS& home = homeS::homeIF() ;

                        __Z( cNicNameMe ) ;
                        }
                            }
                                etRock.traceF( tinBaseP , T("ifcDrivenServerF / i could not obtain my nicNameC's")  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                POOPRqUIET
                            {
                            if( POOP )
                            __Z( cNicNameMe ) ;
                            __Z( pNicNameMe ) ;
                            socketC::nicNameIF( tinBaseP , *((tinFullS&)tinBaseP).pEtScratch , pNicNameMe , cNicNameMe , 0/*T(postCRAFTWORKfACTORY".ideafarm.com")*/ ) ; ___( pNicNameMe ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        ZE( nicNameC* , pNicNameMe ) ;
                        ZE( countT , cNicNameMe ) ;

                        }
                            }
                                osThreadF( tinBaseP , tid , info1P.tmF , 0 , 0  , flTHREADlAUNCH_SHOWpONY , 0 , (countT)&info1P.bQuit , (countT)&stJob , (countT)&cWorker ) ;
                                ZE( countT , tid ) ;
                                inc02AM( cWorker ) ;
                            {
                            while( cDo -- )
                            etRock.traceF( tinBaseP , T("ifcDrivenServerF / launching workers [cWorkers]:    ")+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                            if( cDo > 0x10 ) cDo = 0x10 ; //U::20240205@1335: WORKAROUND TO AVOID MEMORY EXHAUSTION WHEN EXIST 02 PROCESSORS ; STUDY WHY "SHOWPONY" IS NEEDED (WHAT DOES IT DO?:); STUDY: USING MINIMAL THREAD STACK HERE SO CAN LAUNCH MORE

                            if( cDo == - 1 ) cDo = thirdC::osProcessorsIF( tinBaseP ) ; //U:: DISTINCT BEHAVIOR FOR -1 -2 -3 ...

                            countT cDo = cWorkersSave ;
                        {
                        if( cWorkersSave )

                        const countT cWorkersSave = info2P.cWorkers ;

                        _IO_
                    {

                    ZE( countT , cJobsHighWater ) ;
                    stackC stJob( tinBaseP , third , TAG( TAGiDnULL ) , /*flSTACKc_FIFO |*/ flSTACKc_BLOB | flSTACKc_ALLOWzE | flSTACKc_GIVEsIGNnEWpLATE , sizeof( taskDrivenServerJobS ) , ifcIDgRABlAYER_7BASEmISC1 ) ;
                    //DURING A DELUGE, FIFO CAUSES EVERY PEER TO TIME OUT, WHILE LIFO GIVES GOOD PEERS A CHANCE TO GET QUICK SERVICE ; THAT'S THE IDEA, ANYWAY
                    //20210927@1808: CHANGED TO LIFO FOR GRACEFUL FAIL ; DURING A DELUGE, LIFO ENSURES THAT SOME GET QUICK RESPONSE ; THE UNLUCKY PEERS GET NO RESPONSE AND THE ATTACKER THINKS THAT HE IS NOT AFFECTING THE SERVER

                    _IO_
                {

                switchC sw_cSessionWithPeer( tinBaseP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , lever_nnPeer ) ;
                nicNameC lever_nnPeer ;

                _IO_
            {

            switchC sw_pso( tinBaseP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , lever_idSession ) ;
            ZE( countT , lever_idSession ) ;

            _IO_
        {

        osTimeNowF( tinBaseP , timeSnapBad1 , timeSnapBad2 ) ;
        ZE( sCountT , timeSnapBad2 ) ;
        ZE( countT  , timeSnapBad1 ) ;

        osTimeNowF( tinBaseP , timeLathPurgeRecentPeer1 , timeLathPurgeRecentPeer2 ) ;
        ZE( sCountT , timeLathPurgeRecentPeer2 ) ;
        ZE( countT  , timeLathPurgeRecentPeer1 ) ;

        stackC stBadPeer(    tinBaseP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_nicNameC ) ;
        stackC stRecentPeer( tinBaseP , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_nicNameC ) ;
        ZE( countT , cSession ) ;
        ZE( countT , cWorker ) ;

        //etRock.traceF( tinBaseP , T("ifcDrivenServerF [cSessionMax]:    ")+TF2(info2P.cSessionMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
        if( !info2P.cSessionMax ) info2P.cSessionMax = CsESSIONmAXdFLTiFCdRIVENsERVER ;

        sessionsC& sessions = info2P.pSessions ? *info2P.pSessions : *(sessionsC*)pbSessions ;

        }
            bDeleteSessions = 1 ;
            new( 0 , tinBaseP , pbSessions , sizeof pbSessions ) sessionsC( tinBaseP , *this , TAG( TAGiDnULL ) ) ;
        {
        if( !info2P.pSessions )
        ZE( boolT , bDeleteSessions ) ;
        byteT pbSessions[ sizeof( sessionsC ) ] ;
        TELL( "server: setting up" )

        const boolT bHttp    = info2P.idPortHint == ifcIDpORT_HTTP ;
        const boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

        etherC& etRock = etherC::etRockIF( tinBaseP ) ;

        _IO_
    {

    }
        if( POOP ) return ;
        __( !info2P.bState && !!info2P.psttSuffix ) ;
        __( !info2P.bState && !!info2P.translateStateF ) ;
        __( !info2P.bState && info2P.cbdVarying ) ;
        __(  info2P.bState && ((tinFullS&)tinBaseP).pag1->_etherC_.cInServer ++ ) ;
        __( info1P.idPort ) ;
        __( !info1P.tmF ) ;
        __( info1P.ppbdVarying && !!*info1P.ppbdVarying ) ;
        __( F(flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) ;
        __( F(flagsMode) & flTHIRDmODE_QUITTER ) ;

        __( !( F(((tinFullS&)tinBaseP).flagsThreadMode3) & flTHREADmODE3_ADAMmAINtHREAD ) && !( F(flagsMode) & flTHIRDmODE_TINoWNER ) ) ; // THESE 2 CHECKS ENSURE etThread IS BEING USED
        __(    F(((tinFullS&)tinBaseP).flagsThreadMode3) & flTHREADmODE3_ADAMmAINtHREAD   &&    F(flagsMode) & flTHIRDmODE_TINoWNER   ) ; // THESE 2 CHECKS ENSURE etThread IS BEING USED (THIS LINE WILL DETECT THE USE OF etPrimeF() BUT WILL FAIL TO DETECT THE USE OF AN etherC OBJECT OTHER THAN ether AND etThread ON THREAD 1)

        if( POOP ) return ;
    {
    IFbEcAREFUL

    SCOOP
{
/*1*/voidT etherC::ifcDrivenServerF( tinBaseS& tinBaseP , serverInfo1S& info1P , serverInfo2S& info2P )/*1*/

/**/
*/
   use multiple concurrent sessions whenever possible
    let transaction failure data be captured, i.e. do not specify flTHIRDmODE_IMPOTENCEeXPECTED
    if the transaction fails, discard all uncommitted results, reconnect, and retry the connection at least 01 times, sleeping at least 04 tucks between each try
    do not commit results to permanent storage until the transaction has completed
   treat the session as a transaction
   retry connection establishment forever, or at least 01 times
  clients
  client
    the old instance continues to work until all of its client sessions have ended
    in this scenario, when a new instance is hired, it immediately becomes the listener for the hardcoded port
    this will allow sessions started with an old instance to coexist with a new instance that has taken over service of the hardcoded port
   if a hardcoded port is being served, use TASKdRIVENsERVERnEWsOCKET to switch each session to a new socket (bound to a dynamically allocated port)
   on asynch impotence, cancel all current sessions immediately by specifying time1graceP = 0
  server
 recommended protocol
  if not 0 then is called immediately before stateC object is destroyed
  normally is 0
  can be 0
 stateEndFP
  if not 0 then is called immediately after stateC object is constructed
  normally is 0
  can be 0
 stateBeginFP
   example: T("6a40104")
  used to give a distinct name so that multiple instances of the calling adam can coexist
  normally should be 0
  suffix for the state backing image
 psttSuffixP
   see pbdVaryingP for a description of how the caller must access its state information
  it is illegal for the definition of translateStateFP to store its pbToVaryingP parameter for later use by the caller
  can be 0
 translateStateFP
 cbdVaryingP
  only wo instance of me with bStateP can be called per process
  if 0 then the remaining parameters must default
  if not 0 then i will construct a stateC object
  can be 0
  defaults to 1
 bStateP
  when asynchronous impotence occurs, and for a short time afterward until my replacement starts, an attempted connection might fail or might be accepted and then canceled
  the new server, if any, is not told to start until all connections are gone
  this value, if not -1, is floored before use to the greatest nonupper multiple of TUCK * 04
  else i wait time1graceP and then abort any connections that still exist
  if -1 then i wait forever for client connections to close on their own
  can be 0
  time after asynchronous impotence is detected before all client connections are aborted
 time1graceP
  i do not look at the value of cArgP
  passed to tmFP and to translateStateFP
  can be 0
 cArgP
  if 0 then connections will be refused (closed immediately after acceptance) if there are CsESSIONmAXdFLTiFCdRIVENsERVER sessions
  can be 0
 cSessionMaxP
  if 0 then a port will be assigned
  can be 0
 idPortHintP
  will be reset to 0 when i stop listening
  will be revised each time, if any, that the socket is replaced
  will be set to the idPort assigned, which is guaranteed to initially be idPortHintP if the latter is not 0
  must be 0
 idPortP
  must be defined using the TASKdRIVENsERVER symbol
  must conform to the current argument requirements (see adam.0140104 or another adam class that uses me)
  must not be 0
 tmFP
  is not given until immediately after a socket bound to the new idPort is set to listening mode
  given each time that the value of idPortP changes, including its initial assignment and its final reset to 0
 sgnIdPortReplacedP
  see stateC::stateC
 bHandedOffP
 pBat_pbdVaryingP
   in other words, during termination a client session can continue to be served, but it must be "crippled" to prevent transactions that modify state
   if 0 then the current process must not do anything that implies a change in the state of its adam class
   0 indicates that the current process no longer "owns" the state of its adam class
  the protocol for accessing state is to grab the baton, test whether pbdVaryingP is 0, if not 0 access pbdVaryingP, and ungrab the baton
    just before state is frozen, b_pbdVaryingP is grabbed and pbdVaryingP is reset to 0
    during termination, state is frozen, handed off, and saved
   during termination, pbStateP will be 0 and the caller must not attempt to access its state information
   normally pbdVaryingP will be nonze and will point to cbdVaryingP bytes of state that the caller can use to record its current state
  during the execution of a tmFP thread, can be either 0 or nonze
  must be 0
 pbdVaryingP
 tinBaseP
arguments
  thread 2 serves a private chat port, so that the calling adam can accept chat connections to receive commands and report results
  main thread serves port X, which is the primary duty of the calling adam
 example
before calling me on the main thread, launch other threads that call me with bStateP false, to serve ancillary ports
call me on the main thread, with bStateP true, to serve a port
i do not return control to the calling thread until all sessions have ended
provide me with a task definition and i will use it to serve the specified port
\<A HREF=\"5.1030168.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$ifcDrivenServerF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

