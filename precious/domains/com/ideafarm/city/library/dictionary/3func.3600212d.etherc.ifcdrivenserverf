
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    TELL( "server: destroying locals 0 (no action here)" )
    }
        TELL( "server: destroying locals 1 (nothing interesting)" )
        }
            TELL( "server: destroying locals 2 (sw_pso)" )
            }
                TELL( "server: destroying locals 3 (sw_cSessionWithPeer)" )
                }
                    }
                        DELzOMBIE( pDoomed ) ;
                        taskDrivenServerJobS* pDoomed = &jobP ;
                        taskDrivenServerJobS& jobP = *(taskDrivenServerJobS*)_pbaJob ;
                        stJob >> pbJob ;
                        byteT* pbJob = _pbaJob ;
                        byteT _pbaJob[ sizeof( taskDrivenServerJobS ) ] ;
                        _IO_
                    {
                    while( stJob )

                    TELL( "server: destroying locals 4 (stJob)" )
                    }
                        TELL( "server: destroying locals 5 (after stJob)" )
                        }
                            TELL( "server: after maybe deleting sessionsC instance" )

                            }
                                DELzOMBIE( pzSessions ) ;
                                sessionsC* pzSessions = (sessionsC*)pbSessions ;
                                TELL( "server: definitely deleting sessionsC instance" )
                                _IO_
                            {
                            if( bDeleteSessions )
                            TELL( "server: maybe deleting sessionsC instance" )

                            }
                                }
                                    ++ s ; thirdC::dosSleepIF( tin0P , TUCK * 0x40 ) ;

                                    stJob.ungrabF( tin0P ) ;
                                    new( 0 , tin0P , (byteT*)&(countT&)stJob[ 1 ] , sizeof( taskDrivenServerJobS ) ) taskDrivenServerJobS() ;
                                    stJob << (byteT*)0 ;
                                    stJob.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                                    LOGrAW5( "ifcDrivenServerF / terminating [cWorker,cSession]:    " , cWorker , "    " , cSession , "\r\n" ) ;
                                {
                                while( cSession || cWorker )
                                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                                _IO_
                            {
                            TELL( "server: final wait (forever) for all sessions to end" )

                            sw_pso.ungrabF( tin0P ) ;
                            }
                                }
                                    }
                                        if( POOP ) POOPR
                                        ((tin1S&)tin0P).pEtScratch->sockCancelF( tin0P , hSoc ) ;
                                        SCOOPS
                                        //}
                                        //    thirdC::dosTellGlass2IF( tin0P , tellC( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEtELLsYS_LOG , poste , sizeof poste ) , ifcIDbOOKStELL_SYS ) ;
                                        //    const osTextT poste[] = "ifcDrivenServerF: canceling a client session because i am quitting" ;
                                        //{
                                        const handleC& hSoc = pso->handleF( tin0P ) ;
                                        TELL( "server: canceling a client session" )
                                    {
                                    if( pso )
                                    socketC*& pso = (socketC*&)(countT&)sw_pso ;
                                    lever_idSession = sw_pso.leverF( tin0P , idf ) ;
                                {
                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                countT cFlavors = sw_pso.cFlavorsF( tin0P ) ;
                                _IO_
                            {
                            sw_pso.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                            }
                                }
                                    while( cSession && cTries -- ) { ++ s ; thirdC::dosSleepIF( tin0P , time1nap ) ; }
                                    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                                {
                                TELL( "server: will wait for a while to see cSession = 0" )

                                }
                                    time1nap = info2P.time1grace / cTries ;
                                    cTries >>= 1 ;
                                {
                                while( time1nap < TUCK * 0x40 && cTries > 1 )
                                countT time1nap = info2P.time1grace / cTries ;
                                countT cTries = 0x10 ;
                                _IO_
                            {
                            else if( info2P.time1grace )
                            }
                                }
                                    while( cSession ) { ++ s ; thirdC::dosSleepIF( tin0P , TUCK * 0x40 ) ; }
                                    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                                {
                                TELL( "server: will wait forever until cSession is 0" )
                                _IO_
                            {
                            if( info2P.time1grace == - 1 )

                            if( info2P.bState ) if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->ungrabF( tin0P ) ;

                            }
                                //A:  THREADmODE1rESTORE
                                //A:  DEL( pState ) ;
                                //A:  THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                                //A:  info1P.ppbdVarying = 0 ;
                                //A:  *info1P.ppbdVarying = 0 ; //U::BUG: MIGRATED FROM pbdVarying WITHOUT ADEQUATE STUDY; THIS FUNCTION COULD CONTAIN A BUG IN CODE HANDLING THIS MEMBER
                                //A:  if( info2P.stateEndF ) (*info2P.stateEndF)( tin0P , *this , *info1P.ppbdVarying , info2P.cbdVarying , info2P.cArg ) ;
                                //A:  if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                //A: 20141130@1135: COMMENTED OUT AS PART OF ELIMINATION OF stateC
                                _IO_
                            {
                            //if( pState )

                            }
                                info1P.sgnIdPortReplaced.giveF( tin0P ) ;
                                TELL( "server: cleaning up" )

                                __NZ( bMissingSetting ) ;
                                }
                                    }
                                        if( POOP ) POOPR

                                        }
                                            }
                                                etRock.traceF( tin0P , T("!exception / ifcDrivenServerF / could not dt listener socket") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                POOPRqUIET
                                                _IO_
                                            {
                                            if( POOP )
                                            }
                                                DEL( psoListen ) ;
                                                _IO_
                                            {
                                            SCOOPS
                                            _IO_
                                        {
                                        IFsCRATCHoK
                                        TELL( "server: destroying listener socket" )
                                        info1P.idPort = 0 ;

                                        }
                                            }
                                                delF( tin0P , *(byteT**)&pFifo ) ;

                                                }
                                                    }
                                                                                              oshSocket = 0 ;
                                                        hDoomed.osF( ifcIDtYPEhANDLE_SOCKET , oshSocket ) ;
                                                        handleC hDoomed( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_SOCKET ) ;

                                                        countT& oshSocket = pFifo[ offSlot ].oshSocket ;
                                                        countT  offSlot = offi % cFifo ;
                                                        _IO_
                                                    {
                                                    for( countT offi = cFifoPulled ; offi < cFifoPushed ; offi ++ )    // CLOSE THE OS HANDLES THAT REMAIN IN THE CIRCULAR FIFO BUFFER ; THINK OF THIS LOOP AS PULLING THE SLOTS THAT HAVE BEEN PUSHED BUT NOT YET PULLED
                                                    _IO_
                                                {
                                                if( cFifoPushed > cFifoPulled )

                                                //etRock.traceF( tin0P , T("ifcDrivenServerF / deleted psoListen") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE ) ;
                                                }
                                                    if( POOP ) POOPRqUIET
                                                    DEL( psoListen ) ;                  // THIS IS THE OFFENDING LINE IN WHICH OpenSSL NEVER RETURNS
                                                    SCOOPS
                                                {
                                                IFsCRATCHoK
                                                //etRock.traceF( tin0P , T("ifcDrivenServerF / deleting psoListen") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE ) ;

                                                sConnectionAcceptorDone.waitF( tin0P ) ;
                                                }
                                                    if( POOP ) POOPRqUIET
                                                    hSoc.closeIfF() ;
                                                    handleC& hSoc = *(handleC*)&psoListen->handleF( tin0P ) ;
                                                    SCOOPS
                                                {
                                                IFsCRATCHoK
                                                bQuitAccepting = 1 ;

                                                //THREADmODE4rESTORE
                                                }
                                                    }
                                                        }
                                                            }
                                                                }
                                                                    etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                                    etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                                    etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                                    etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                                    etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                                    etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                                    //CS:CODEsYNC: 360021f7 3600212d

                                                                    etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / did not launch server thread (heap failure)") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                                    _IO_
                                                                {
                                                                else
                                                                }
                                                                    }
                                                                        //etRock.traceF( tin0P , tSayClientPrefix+T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                                        //etRock.traceF( tin0P , tSayClientPrefix+T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                                        //etRock.traceF( tin0P , tSayClientPrefix+T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                                        //etRock.traceF( tin0P , tSayClientPrefix+T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                                        //etRock.traceF( tin0P , tSayClientPrefix+T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                                        //etRock.traceF( tin0P , tSayClientPrefix+T("ifcDrivenServerF / launched server thread") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                                        //CS:CODEsYNC: 360021f7 3600212d

                                                                        //etRock.traceF( tin0P , tSayClientPrefix+T("ifcDrivenServerF / launched server thread") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                                        _IO_
                                                                    {
                                                                    else
                                                                    }
                                                                        etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                                        etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                                        etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                                        etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                                        etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                                        etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / error: could not launch server thread") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                                        //CS:CODEsYNC: 360021f7 3600212d

                                                                        etRock.traceF( tin0P , tSayClientPrefix+T("!exception / ifcDrivenServerF / error: could not launch server thread") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                                        POOPR
                                                                        _IO_
                                                                    {
                                                                    if( POOP )

                                                                    ZE( countT , tid ) ; ((tin1S&)tin0P).pEtScratch->osThreadF( tin0P , tid , info1P.tmF , 0 , 0  , flTHREADlAUNCH_SHOWpONY , 0 , 0 , (countT)&info1P.bQuit , (countT)&stJob , (countT)pJob , (countT)&cWorker ) ;
                                                                    inc02AM( cWorker ) ;
                                                                    /*if( !bPeerIsGorilla )*/ ;//etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / launching server thread for this client") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                                    /*if( !bPeerIsGorilla )*/ ;//etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / launching server thread for this client") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                                    TELL( "server: launching server thread for this client" )
                                                                    _IO_
                                                                {
                                                                if( pJob )

                                                                taskDrivenServerJobS* pJob = new( 0 , tin0P , LF ) taskDrivenServerJobS( tin0P , *this , tSayClientPrefix , idSessionLath , lever_idSession , sw_pso , cSession , info2P.cArgSys , lever_nnPeer , sw_cSessionWithPeer , sessions , nnPeer , timeAccepted1 , timeAccepted2 , timeJobCreated1 , timeJobCreated2 ) ; ___( pJob ) ;
                                                                /*if( bHeIsWatchDeadman1 )*/ /*if( !bPeerIsGorilla )*/ ;//etRock.traceF( tin0P , tSayClientPrefix+T("ifcDrivenServerF / launching a job thread"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                                _IO_
                                                            {
                                                            else
                                                            }
                                                                stJob.ungrabF( tin0P ) ;

                                                                //taskDrivenServerJobS& jobMe = *(taskDrivenServerJobS*)&(countT&)stJob[ 1 ] ; //U:: TO FIND A BUG

                                                                //taskDrivenServerJobS& fooDebug2 = *(taskDrivenServerJobS*)pbTop ;
                                                                //new( 0 , tin0P , pbTop , sizeof( taskDrivenServerJobS ) ) taskDrivenServerJobS( tin0P , *this , tSayClientPrefix , idSessionLath , pso , lever_idSession , sw_pso , cSession , info2P.cArg , lever_nnPeer , sw_cSessionWithPeer , sessions , nnPeer ) ;
                                                                //byteT* pbTop = (byteT*)&(countT&)stJob[ 1 ] ;

                                                                /*if( !bPeerIsGorilla )*/ /*;*/etRock.traceF( tin0P , tSayClientPrefix+T("ifcDrivenServerF pushed  a job [cJobsHighWater,cPlatesAfter]:    ")+TF2(cJobsHighWater,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(stJob,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                                //taskDrivenServerJobS jobCopy = *(taskDrivenServerJobS*)&(countT&)stJob[ 1 ] ; //U:: TO FIND A BUG

                                                                }
                                                                    /**/etRock.traceF( tin0P , tSayClientPrefix+T("ifcDrivenServerF / backlog is rising [cJobsHighWater]:    ")+TF2(cJobsHighWater,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                                    cJobsHighWater = cJobsNow ;
                                                                    _IO_
                                                                {
                                                                if( cJobsHighWater < cJobsNow )
                                                                countT cJobsNow = stJob ;

                                                                new( 0 , tin0P , (byteT*)&(countT&)stJob[ 1 ] , sizeof( taskDrivenServerJobS ) ) taskDrivenServerJobS( tin0P , *this , tSayClientPrefix , idSessionLath , lever_idSession , sw_pso , cSession , info2P.cArgSys , lever_nnPeer , sw_cSessionWithPeer , sessions , nnPeer , timeAccepted1 , timeAccepted2 , timeJobCreated1 , timeJobCreated2 ) ;
                                                                stJob << (byteT*)0 ;
                                                                /*if( !bPeerIsGorilla )*/ /*;*/etRock.traceF( tin0P , tSayClientPrefix+T("ifcDrivenServerF pushing a job [cJobsHighWater,cPlatesBefore]:    ")+TF2(cJobsHighWater,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(stJob,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                                stJob.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                                                                //taskDrivenServerJobS fooDebug1( idSessionLath , pso , lever_idSession , sw_pso , cSession , info2P.cArg , lever_nnPeer , sw_cSessionWithPeer , sessions , nnPeer ) ;
                                                                /*if( bHeIsWatchDeadman1 )*/ /*if( !bPeerIsGorilla )*/ ;//etRock.traceF( tin0P , tSayClientPrefix+T("ifcDrivenServerF / pushing a job"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                                _IO_
                                                            {
                                                            if( cWorkersSave )

                                                            osTimeNowF( tin0P , timeJobCreated1 , timeJobCreated2 ) ;
                                                            ZE( sCountT , timeJobCreated2 ) ;
                                                            ZE( countT  , timeJobCreated1 ) ;

                                                            TN( tSayClientPrefix , "" ) ; tSayClientPrefix = *pptSayModulo[ idClient % 0x10 ]+TF3(idClient,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,0x9)+T(nnPeer)+T("(")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(")")+tb4+T("| ") ;
                                                            ++ idClient ;
                                                            inc02AM( cSession ) ;
                                                            _IO_
                                                        {
                                                        if( !POOP )
                                                        //if( 0x401043a == processGlobal1I.idAdamRoot ) ifcSayIF( T("about to launch service thread: third is ")+T(third?"IMPOTENT":"potent") , flSAY_APPEND | flSAY_LOG ) ;

                                                        sw_cSessionWithPeer.ungrabF( tin0P ) ;
                                                        ++ sw_cSessionWithPeer ;
                                                        lever_nnPeer = nnPeer ;
                                                        if( sw_cSessionWithPeer.cFlavorsF( tin0P ) > TUCK ) sw_cSessionWithPeer.freeAllF( tin0P ) ;
                                                        sw_cSessionWithPeer.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                                                        sw_pso.ungrabF( tin0P ) ;
                                                        else          { BLAMMO ; }
                                                        if( !sw_pso ) sw_pso = (countT)pso ;
                                                        lever_idSession = ++ idSessionLath ;
                                                        sw_pso.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                        TELL( "server: preparing to serve the accepted socket" )
                                                        /*if( !bPeerIsGorilla )*/ ;//etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / preparing to serve this client") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                        /*if( !bPeerIsGorilla )*/ ;//etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / preparing to serve this client") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                        /*if( !bPeerIsGorilla )*/ ;//etRock.traceF( tin0P , T("ifcDrivenServerF / counting this new session"), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                        stRecentPeer.sinkF( tin0P , countTC() , nnPeer , flSTACKsINK_UNIQUE ) ;

                                                        if( bExplicitHandshake ) pso->shakeHandsAsServerF( tin0P ) ;

                                                        traceF( tin0P , tSayWillServeTo+tNnPeer ) ;
                                                        traceF( tin0P , tSayWillServeTo+tNnPeer , flTRACE_null , ifcIDtRACEdIVERT_9 ) ;

                                                        _IO_
                                                    {
                                                    else if( pso )
                                                    }
                                                        }
                                                            DEL( pso ) ;
                                                            _IO_
                                                        {
                                                        TELL( "server: deleting the accepted socket without serving it" )

                                                        //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / deleting accepted socket without serving it [bSilent,POOP,third,bQuit]:    ")+TF2(bSilent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(third,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(info1P.bQuit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_7 ) ;
                                                        //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / deleting accepted socket without serving it [bSilent,POOP,third,bQuit]:    ")+TF2(bSilent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(third,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(info1P.bQuit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_6 ) ;
                                                        //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / deleting accepted socket without serving it [bSilent,POOP,third,bQuit]:    ")+TF2(bSilent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(third,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(info1P.bQuit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_5 ) ;
                                                        //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / deleting accepted socket without serving it [bSilent,POOP,third,bQuit]:    ")+TF2(bSilent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(third,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(info1P.bQuit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_4 ) ;
                                                        //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / deleting accepted socket without serving it [bSilent,POOP,third,bQuit]:    ")+TF2(bSilent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(third,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(info1P.bQuit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_3 ) ;
                                                        //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / deleting accepted socket without serving it [bSilent,POOP,third,bQuit]:    ")+TF2(bSilent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(third,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(info1P.bQuit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_2 ) ;
                                                        //CS:CODEsYNC: 360021f7 3600212d

                                                        //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / deleting accepted socket without serving it [bSilent,POOP,third,bQuit]:    ")+TF2(bSilent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(third,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(info1P.bQuit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / deleting accepted socket without serving it [bSilent,POOP,third,bQuit]:    ")+TF2(bSilent,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(third,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(info1P.bQuit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                        _IO_
                                                    {
                                                    if( info1P.bQuit || third || bSilent || POOP )

                                                    if( bShieldsDown ) bSilent = 0 ;

                                                    sw_cSessionWithPeer.ungrabF( tin0P ) ;

#endif
                                                    }
                                                        }
                                                            //stBadPeer.sinkF( tin0P , countTC() , nnPeer , flSTACKsINK_UNIQUE ) ;
                                                            //etRock.traceF( tin0P , T("ifcDrivenServerF / remembering bad peer [cBadPeer,nnPeer]:    ")+TF2((countT)stBadPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tNnPeer ) ;
                                                            //U:: STUTTERING SHOULD NOT RESULT IN PERMANENT "BAD PEER" DESIGNATION ; THAT IS TOO SEVERE ; IMPOSE PERMANENT BANISHMENT ONLY FOR E.G. REPEAT OFFENDERS

                                                            bSilent |= 1 ; //TO PREVENT WO PEER FROM OPENING MANY SESSIONS TO DOS ATTACK
                                                            if( stRecentPeer( nnPeer ) ) ;//etRock.traceF( tin0P , T("ifcDrivenServerF / too recently connected [nnPeer]:    ")+tNnPeer ) ;
                                                            //etRock.traceF( tin0P , T("ifcDrivenServerF / setting bSilent (too many sessions with this nnPeer)") ) ;
                                                            _IO_
                                                        {
                                                        )
                                                            )
                                                                )
                                                                    stRecentPeer( nnPeer )
                                                                    ||
                                                                    stBadPeer( nnPeer )
                                                                    ||
                                                                    cSession                             //20210717@1537: CHANGED FROM "0x10 < cSession" TO "cSession" SO EACH PEER IS ONLY ALLOWED WO SESSION AT A TIME
                                                                (
                                                                &&
                                                                !bHeIsWatchDeadman2
                                                                &&
                                                                !bHeIsWatchDeadman1
                                                            (
                                                            ||
                                                            bHeIsSpoofingMe
                                                        (
                                                        if

                                                        //if( !bHeIsWatchDeadman1 && !bHeIsWatchDeadman2 ) ;//etRock.traceF( tin0P , T("ifcDrivenServerF / checking session count and recents and baddies with this nnPeer [cSessionMax,cSession,nnPeer]:    ")+TF2(info2P.cSessionMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tNnPeer ) ;

                                                        countT cSession = sw_cSessionWithPeer ;
                                                        _IO_
                                                    {
#if defined( NEVERdEFINED )
//DISABLED BECAUSE GORILLA TRIGGERS THIS AND STRIPE COULD ALSO TRIGGER IT

#endif
                                                    }
                                                        }
                                                            }
                                                                delF( tin0P , pnnBad ) ;

                                                                delF( tin0P , psttFile ) ;
                                                                //etRock.traceF( tin0P , T("snapshot [psttFile]:    ")+T(psttFile)  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                                THREADmODE1rESTORE ;
                                                                boxPutGenerationF( tin0P , psttFile , tSnapBadPeersFileLike , TOCK , (byteT*)pnnBad , sizeof( nicNameC ) * cDoSave ) ; ___( psttFile ) ;
                                                                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;
                                                                ZE( strokeS* , psttFile ) ;

                                                                while( -- cDo && !stBadPeer.third && ~hDown ) ;
                                                                do *( pc ++ ) = *(nicNameC*)&stBadPeer.downF( tin0P , hDown ) ;
                                                                handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                                                nicNameC* pc = pnnBad ;
                                                                newF( tin0P , LF , pnnBad , cDo ) ; ___( pnnBad ) ;
                                                                ZE( nicNameC* , pnnBad ) ;

                                                                countT cDo = cDoSave ;
                                                                _IO_
                                                            {
                                                            if( cDoSave )
                                                            const countT cDoSave = stBadPeer ;
                                                            _IO_
                                                        {
                                                        if( timeN2 || timeN1 > TICK << 4 )
                                                        osTimeSubtractF( tin0P , timeN1 , timeN2 , timeSnapBad1 , timeSnapBad2 ) ;

                                                        osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                                                        ZE( sCountT , timeN2 ) ;
                                                        ZE( countT  , timeN1 ) ;
                                                        _IO_
                                                    {
#if defined( NEVERdEFINED )
//DISABLED BECAUSE stBadPeer IS NOT USED YET

                                                    }
                                                        }
                                                            stRecentPeer.purgeF( tin0P ) ;
                                                            //etRock.traceF( tin0P , T("purging stRecentPeer [cPlates]:    ")+TF2(stRecentPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                            _IO_
                                                        {
                                                        if( timeN2 || timeN1 > TOCK || stRecentPeer > TUCK << 2 )
                                                        osTimeSubtractF( tin0P , timeN1 , timeN2 , timeLathPurgeRecentPeer1 , timeLathPurgeRecentPeer2 ) ;
                                                        osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                                                        ZE( sCountT , timeN2 ) ;
                                                        ZE( countT  , timeN1 ) ;
                                                        _IO_
                                                    {

                                                    lever_nnPeer = nnPeer ;
                                                    sw_cSessionWithPeer.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                    TELL( "server: detecting dos attack client" )
                                                    //U::EXCLUDE ZOMBIE SESSIONS FROM THE COUNT, SO HTTP CLIENT CAN INITIATE AN ARBITRARILY LONG BURST OF SESSIONS TO GET E.G. ALL IMAGES FOR A PAGE

                                                    ( bRefuseTooManyOrBlackListed || bSilent ? cRefused : cAccepted ) ++ ;
                                                    //if( bRefuseTooManyOrBlackListed ) { LOGrAW( "refusing a client\r\n" ) ; }

#endif
                                                    }
                                                        }
                                                            }
                                                                }
                                                                    if( POOP ) { POOPR }
                                                                    ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tListBlock , tListAllowWoMore , 1 ) ;
                                                                    SCOOPS
                                                                {
                                                                IFsCRATCHoK
                                                                _IO_
                                                            {
                                                            if( !bSilent )

                                                            bSilent = diskFileExistsF( tin0P , tListBlock ) ;
                                                            _IO_
                                                        {
                                                        else
                                                        }
                                                            }
                                                                if( POOP ) POOPR

                                                                ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tListBlock       , 1 ) ; if( POOP ) { POOPR }
                                                                ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tListAllowWoMore , 1 ) ; if( POOP ) { POOPR }
                                                                SCOOPS
                                                            {
                                                            IFsCRATCHoK
                                                            _IO_
                                                        {
                                                        if( bHuman || bWhite )

                                                        boolT bWhite = diskFileExistsF( tin0P , tListWhite ) ;
                                                        boolT bHuman = diskFileExistsF( tin0P , tListHuman ) ;

                                                        tListWhite += T("////factory6/d/ideafarm.home.101/ephemeral/ipdos/attackers/white/")+tNnPeer ;
                                                        tListWhite += T("////factory4/d/ideafarm.home.101/ephemeral/ipdos/attackers/white/")+tNnPeer ;
                                                        tListWhite += T("////factory2/d/ideafarm.home.101/ephemeral/ipdos/attackers/white/")+tNnPeer ;
                                                        TlIST( tListWhite ) ;

                                                        tListBlock += T("////factory6/d/ideafarm.home.101/ephemeral/ipdos/attackers/block/")+tNnPeer ;
                                                        tListBlock += T("////factory4/d/ideafarm.home.101/ephemeral/ipdos/attackers/block/")+tNnPeer ;
                                                        tListBlock += T("////factory2/d/ideafarm.home.101/ephemeral/ipdos/attackers/block/")+tNnPeer ;
                                                        TlIST( tListBlock ) ;

                                                        tListAllowWoMore += T("////factory6/d/ideafarm.home.101/ephemeral/ipdos/attackers/allowWoMore/")+tNnPeer ;
                                                        tListAllowWoMore += T("////factory4/d/ideafarm.home.101/ephemeral/ipdos/attackers/allowWoMore/")+tNnPeer ;
                                                        tListAllowWoMore += T("////factory2/d/ideafarm.home.101/ephemeral/ipdos/attackers/allowWoMore/")+tNnPeer ;
                                                        TlIST( tListAllowWoMore ) ;

                                                        tListHuman += T("////factory6/d/ideafarm.home.101/ephemeral/ipdos/attackers/human/")+tNnPeer ;
                                                        tListHuman += T("////factory4/d/ideafarm.home.101/ephemeral/ipdos/attackers/human/")+tNnPeer ;
                                                        tListHuman += T("////factory2/d/ideafarm.home.101/ephemeral/ipdos/attackers/human/")+tNnPeer ;
                                                        TlIST( tListHuman ) ;
                                                        _IO_
                                                    {
                                                    if( !bSilent )
#if defined( NEVERdEFINED )
//U:: 20200907@1413 DISABLE ALL (OLD) ATTACK DETECTION, WHICH WILL BE REWRITTEN AFTER STUDYING LOGS

                                                    //if( 0x401043a == processGlobal1I.idAdamRoot ) ifcSayIF( T("acceptF returned (2); bSilent: ")+TF1(bSilent) , flSAY_APPEND | flSAY_LOG ) ;
                                                    }
                                                        b_pnnSilent.ungrabF( tin0P ) ;
                                                        }
                                                            }
                                                                break ;
                                                                LOGrAW3( "peer is on the silence list [nnPeer]: " , nnPeer , "\r\n" ) ;

                                                                //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                                //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                                //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                                //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                                //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                                //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                                //CS:CODEsYNC: 360021f7 3600212d

                                                                //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / this peer is on the silence list") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                                bSilent = 1 ;
                                                                _IO_
                                                            {
                                                            if( nnPeer == pnnSilent[ off ] )
                                                            _IO_
                                                        {
                                                        for( countT off = 0 ; off < cnnSilent ; off ++ )
                                                        b_pnnSilent.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                        _IO_
                                                    {
                                                    if( !bHeIsMe && !bSilent )
                                                    boolT bSilent = bHeIsSpoofingMe || !bPeerAllowed ;

                                                    //if( 0x401043a == processGlobal1I.idAdamRoot ) ifcSayIF( T("acceptF returned (1); nnPeer: ")+tNnPeer+T("; bRefuseTooManyOrBlackListed: ")+TF1(bRefuseTooManyOrBlackListed) , flSAY_APPEND | flSAY_LOG ) ;
                                                    TELL( "server: a client has connected" )
                                                    if( !bPeerIsGorilla ) ;//etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / a client has connected") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                    //if( bHeIsWatchDeadman1 ) etRock.traceF( tin0P , T("ifcDrivenServerF / a client has connected") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                    }
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_7 ) ;
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_6 ) ;
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_5 ) ;
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_4 ) ;
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null     , ifcIDtRACEdIVERT_3 ) ;
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHO , ifcIDtRACEdIVERT_2 ) ;
                                                        //CS:CODEsYNC: 360021f7 3600212d

                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / i am being spoofed [idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                        _IO_
                                                    {
                                                    if( bHeIsSpoofingMe )

                                                    else                           ;//etRock.traceF( tin0P , T("ifcDrivenServerF / accepted from a host other than me [idAccept,nnPeer]:    "                                                    )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tNnPeer                                                                                                                                                                                                        , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                    else if(  bLoopback          ) ;//etRock.traceF( tin0P , T("ifcDrivenServerF / accepted from loopback [idAccept]:    "                                                                       )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                                                                                                                                                                                                                      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                    else if(  bHeIsMe            ) ;//etRock.traceF( tin0P , T("ifcDrivenServerF / accepted from me host [idAccept]:    "                                                                        )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                                                                                                                                                                                                                      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                    else if(  bHeIsWatchDeadman2 ) ;//etRock.traceF( tin0P , T("ifcDrivenServerF / accepted from watch deadman2 [idAccept]:    "                                                                 )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                                                                                                                                                                                                                      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                    else if(  bHeIsWatchDeadman1 ) ;//etRock.traceF( tin0P , T("ifcDrivenServerF / accepted from watch deadman1 [idAccept]:    "                                                                 )+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                                                                                                                                                                                                                      , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                         if(  bHeIsSpoofingMe    ) ;//etRock.traceF( tin0P , T("ifcDrivenServerF / accepted i am being spoofed [idAccept,idpPeer,home.idPortWatchHttpDeadman1,home.idPortWatchHttpDeadman2]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idpPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman1Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPortWatchHttpDeadman2Snap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED), flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                    bHeIsSpoofingMe = 0 ; //U::20210914@1613: SERVE UNCONDITIONALLY TO USE AS DUT FOR NEW FIREWALL

                                                    boolT bHeIsSpoofingMe = bHeIsMe && !bHeIsWatchDeadman1 && !bHeIsWatchDeadman2 ;

                                                    boolT bHeIsWatchDeadman2 = bHeIsMe && idpPeer == idPortWatchHttpDeadman2Snap ;
                                                    boolT bHeIsWatchDeadman1 = bHeIsMe && idpPeer == idPortWatchHttpDeadman1Snap ;

                                                    }
                                                        }
                                                            break ;
                                                            bHeIsMe = 1 ;
                                                        {
                                                        if( pNicNameMe[ offMe ] == nnPeer )
                                                        _IO_
                                                    {
                                                    for( countT offMe = 0 ; offMe < cNicNameMe ; offMe ++ )
                                                    ZE( boolT , bHeIsMe ) ;

                                                    boolT bLoopback = nnPeer.isLoopbackOldDoNotUseF() ;

                                                    ) ;
                                                        || bPeerIsGorilla
                                                           !info2P.pnnAllowedStripe ? 1 : *info2P.pnnAllowedStripe & nnPeer
                                                    (
                                                    bPeerAllowed =

                                                    }
                                                        if( POOP ) POOPR

                                                        }
                                                            break ;

                                                            etRock.traceF( tin0P , T("!exception / ")+tNnPeer+T("    ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                            etRock.traceF( tin0P , T("!exception / ")+tNnPeer+T("    ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                            etRock.traceF( tin0P , T("!exception / ")+tNnPeer+T("    ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                            etRock.traceF( tin0P , T("!exception / ")+tNnPeer+T("    ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                            etRock.traceF( tin0P , T("!exception / ")+tNnPeer+T("    ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                            etRock.traceF( tin0P , T("!exception / ")+tNnPeer+T("    ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                            //CS:CODEsYNC: 360021f7 3600212d

                                                            etRock.traceF( tin0P , T("!exception / ")+tNnPeer+T("    ifcDrivenServerF / listener socket failed to accept a connection [idAccept]:    ")+TF2(idAccept,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                            }
                                                                POOPRqUIET

                                                                //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / deleted pso") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE ) ;
                                                                }
                                                                    POOPRqUIET
                                                                    DEL( pso ) ;                        // THIS IS THE OFFENDING LINE IN WHICH OpenSSL NEVER RETURNS (HAPPENS SOMETIMES BUT NOT ALWAYS HERE)
                                                                    _IO_
                                                                {                                       // DONE SEPARATELY SO CALL NEST WILL SHOW WHICH IS HUNG IF HANG IS EVER OBSERVED AGAIN
                                                                //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / deleting pso") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE ) ;

                                                                _IO_
                                                            {

                                                            etRock.traceF( tin0P , T("!exception / ")+tNnPeer+T("    ifcDrivenServerF / accept failed") ) ;
                                                            etRock.traceF( tin0P , T("!exception / ")+tNnPeer+T("    ifcDrivenServerF / accept failed") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                            POOPRqUIET
                                                            _IO_
                                                        {
                                                        if( idSubTypeSave )
                                                        idPortWatchHttpDeadman2Snap = home.idPortWatchHttpDeadman2 ;
                                                        idPortWatchHttpDeadman1Snap = home.idPortWatchHttpDeadman1 ;

                                                        //CONoUTrAW( "." ) ; //U:: TO FIND A BUG
                                                        osTimeNowF( tin0P , timeAccepted1 , timeAccepted2 ) ;
                                                        /*if( !bPeerIsGorilla )*/ //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / called  acceptF [idSubType,cQueued,cQueuedMax]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cFifoPushed-cFifoPulled,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cQueuedMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        /*if( !bPeerIsGorilla )*/ //etRock.traceF( tin0P , tNnPeer+T("    ifcDrivenServerF / called  acceptF [idSubType,cQueued,cQueuedMax]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cFifoPushed-cFifoPulled,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cQueuedMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;

                                                        tNnPeer = T(nnPeer) ;

                                                        ) ;
                                                          //|| nnPeer == nnGorillaInnerOk8
                                                          //|| nnPeer == nnGorillaInnerOk7
                                                          //|| nnPeer == nnGorillaInnerOk6
                                                          //|| nnPeer == nnGorillaInnerOk5
                                                          //|| nnPeer == nnGorillaInnerOk4
                                                          //|| nnPeer == nnGorillaInnerOk3
                                                          //|| nnPeer == nnGorillaInnerOk2

                                                            || nnPeer == nnGorillaOuterOk1
                                                               nnPeer == nnGorillaInnerOk1
                                                        (
                                                        bPeerIsGorilla =

                                                        }
                                                            //etRock.traceF( tin0P , T("ifcDrivenServerF / queue is growing [cQueuedMax]:    ")+TF2(cQueuedMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                            //etRock.traceF( tin0P , T("ifcDrivenServerF / queue is growing [cQueuedMax]:    ")+TF2(cQueuedMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                            cQueuedMax = cFifoPushed-cFifoPulled ;
                                                            _IO_
                                                        {
                                                        if( cQueuedMax < cFifoPushed-cFifoPulled )
                                                        const countT idSubTypeSave = POOP ;
                                                        psoListen->acceptF( tin0P , pso , idpPeer , nnPeer , bRefuseTooManyOrBlackListed , &pp ) ; ___( pso ) ; //IF ALL SESSIONS END WHILE BLOCKED HERE, WILL STILL REFUSE WO SESSION; THIS CAN BE FIXED BY FRESHING bRefuseTooManyOrBlackListed AT END OF EACH SESSION THREAD IN DONEtMsERVER
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / calling acceptF") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                        SCOOPS
                                                        _IO_
                                                    {
                                                    IFsCRATCHoK
                                                    TN( tNnPeer , "" ) ;
                                                    ZE( boolT , bPeerAllowed   ) ;
                                                    ZE( boolT , bPeerIsGorilla ) ;
                                                    ZE( socketC* , pso ) ;
                                                    idAccept ++ ;
                                                    //etRock.traceF( tin0P , T("ifcDrivenServerF / waiting for a client to connect") , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                    //etRock.traceF( tin0P , T("ifcDrivenServerF / waiting for a client to connect") , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                    TELL( "server: waiting for a client to connect" )
                                                    ZE( countT , idPortWatchHttpDeadman2Snap ) ;
                                                    ZE( countT , idPortWatchHttpDeadman1Snap ) ;
                                                    ZE( sCountT , timeAccepted2 ) ;
                                                    ZE( countT  , timeAccepted1 ) ;
                                                    nicNameC nnPeer ;
                                                    ZE( countT , idpPeer ) ;
#endif
                                                    }
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ;
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_6 ) ;
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_5 ) ;
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_4 ) ;
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_3 ) ;
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_2 ) ;
                                                        //CS:CODEsYNC: 360021f7 3600212d

                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        //etRock.traceF( tin0P , T("ifcDrivenServerF / too many sessions, so refusing this wo [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                                                        LOGrAW( tSay ) ;
                                                        TN( tSay , "" ) ; tSay = TT(timeN1,timeN2)+T("| ifcDrivenServerF/too many sessions, so will refuse the next connection attempt\r\n") ;
                                                        osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                                                        ZE( sCountT , timeN2 ) ;
                                                        ZE( countT  , timeN1 ) ;
                                                        _IO_
                                                    {
                                                    if( bRefuseTooManyOrBlackListed )
                                                    boolT bRefuseTooManyOrBlackListed = info2P.cSessionMax <= cSession ;
                                                    //etRock.traceF( tin0P , T("ifcDrivenServerF / inspecting [cSession]:    ")+TF2(cSession,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
#if defined( NEVERdEFINED )
//DISABLED BECAUSE STRIPE COULD TRIGGER THIS
ZE( boolT , bRefuseTooManyOrBlackListed ) ;

                                                    TELL( "server: beginning loop" )
                                                    _IO_
                                                {
                                                while( !info1P.bQuit && !POOP )
                                                ZE( countT , cRefused ) ;
                                                ZE( countT , cAccepted ) ;
                                                //THREADmODE4oN( flTHREADmODE4_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY )

                                                osThreadF( TaRG3sGNdONEcBsTACK( tmConnectionAcceptorF , sConnectionAcceptorDone , CBsTACKmIN << 1 ) , (countT)&bQuitAccepting , (countT)&pp ) ;   //20250314@2154: "<< 1" FROM "<< 0" IN RESPONSE TO STACK OVERFLOW
                                                ZE( boolT , bQuitAccepting ) ;
                                                signC sConnectionAcceptorDone( tin0P , TAG( TAGiDnULL ) ) ;

                                                s_acceptF_parametersS pp( cFifoPushed , pFifo , cFifo , cFifoPulled , psoListen->handleF( tin0P ) ) ;

                                                newF( tin0P , LF , *(byteT**)&pFifo , cFifo * sizeof( oshSocketAcceptedS ) ) ; ___( pFifo ) ;
                                                const countT              cFifo       = TUCK ;
                                                ZE( oshSocketAcceptedS* , pFifo       ) ;
                                                ZE( countT              , cFifoPulled ) ;
                                                ZE( countT              , cFifoPushed ) ;
                                                ZE( countT              , cQueuedMax  ) ;
                                                _IO_
                                            {
                                            if( psoListen )

                                            //LOGrAW3( "listener socket has been bound to port [idPort]: " , info1P.idPort , "\r\n" ) ;
                                            }
                                                }
                                                    etRock.traceF( tin0P , T("!exception / ifcDrivenServerF / could not configure (name, bind, listen) listener socket [idPort]:    ")+TF2(info1P.idPort,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                    }
                                                        POOPRqUIET
                                                        DEL( psoListen ) ;
                                                        POOPRqUIET
                                                        _IO_
                                                    {
                                                    _IO_
                                                {
                                                else
                                                }
                                                    //etRock.traceF( tin0P , T("ifcDrivenServerF / listener socket has been bound [idPort]:    ")+TF2(info1P.idPort,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                    _IO_
                                                {
                                                if( !POOP )

                                                }   
                                                    info1P.sgnIdPortReplaced.giveF( tin0P ) ;
                                                    psoListen->listenF( tin0P ) ;
                                                    info1P.idPort = psoListen->bindF( tin0P , info2P.idPortHint ) ;
                                                    _IO_
                                                {
                                                if( !info1P.bQuit )

                                                if( info2P.psttName ) psoListen->nameF( tin0P , info2P.psttName ) ;
                                                SCOOPS
                                                _IO_
                                            {
                                            IFsCRATCHoK
                                            _IO_
                                        {
                                        if( psoListen )

                                        delF( tin0P , psttPemPrivateKey   ) ;
                                        delF( tin0P , psttPemCertificates ) ;
                                        }
                                            }
                                                }
                                                    ++ s ; thirdC::dosSleepIF( tin0P , TOCK ) ; //THIS IS TO PREVENT ME FROM PEGGING CPU, ESPECIALLY WHEN I RUN AT HIGH DESIRE
                                                    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                                                    
                                                    etRock.traceF( tin0P , T("!exception / ifcDrivenServerF / could not ct listener socket ; napping")  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                                    }
                                                        POOPRqUIET
                                                        DEL( psoListen ) ;
                                                        POOPRqUIET
                                                        _IO_
                                                    {
                                                    _IO_
                                                {
                                                if( POOP )
                                                psoListen = new( 0 , tin0P , LF ) socketC( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , info2P.flagsSocket , 0 , &info1P.time1idleTimeoutRead , &info1P.time1idleTimeoutWrite , 0 , psttPemCertificates , psttPemPrivateKey ) ; ___( psoListen ) ;
                                                SCOOPS
                                                _IO_
                                            {
                                            IFsCRATCHoK
                                            _IO_
                                        {
                                        if( !POOP )
                                        ZE( socketC* , psoListen ) ;
                                        const boolT bExplicitHandshake = F(info2P.flagsSocket) & flSOCKETc_CRYPTfOREIGNsSLdEFERhANDSHAKE && F(info2P.flagsSocket) & flSOCKETc_CRYPTfOREIGNsSL ;

                                        }
                                            strMakeF( tin0P , LF , psttPemPrivateKey   , T("////wh1/c/certbot/live/")+tFullyQualifiedDomain+T("/privkey.pem")   ) ; ___( psttPemPrivateKey   ) ;
                                            strMakeF( tin0P , LF , psttPemCertificates , T("////wh1/c/certbot/live/")+tFullyQualifiedDomain+T("/fullchain.pem") ) ; ___( psttPemCertificates ) ;

                                            //strMakeF( tin0P , LF , psttPemPrivateKey   , T("///c/certbot/live/")+tFullyQualifiedDomain+T("/privkey.pem")   ) ; ___( psttPemPrivateKey   ) ;
                                            //strMakeF( tin0P , LF , psttPemCertificates , T("///c/certbot/live/")+tFullyQualifiedDomain+T("/fullchain.pem") ) ; ___( psttPemCertificates ) ;

                                            //etRock.traceF( tin0P , T("ifcDrivenServerF / [tFullyQualifiedDomain]:    ")+tFullyQualifiedDomain ) ;

                                            }
                                                tFullyQualifiedDomain = tDomainLeafWebHooks+T(".hidden.ideafarm.com") ;

                                                //tFullyQualifiedDomain = T("wahhkygs7zmvqzfpazpcjd565zq78nax.hidden.ideafarm.com") ;
                                                //tFullyQualifiedDomain = T("webhooks.hidden.ideafarm.com") ;
                                                //tFullyQualifiedDomain = T("webhooks.ideafarm.com") ;
                                                //tFullyQualifiedDomain = T("factory1.ideafarm.com") ;
                                                //tFullyQualifiedDomain = T("ideafarm.com") ;
                                            {
                                            TN( tFullyQualifiedDomain , "" ) ; // ACCESS WILL BE DENIED IF NOT RUN ELEVATED

                                            }
                                                delF( tin0P , psttEat ) ;
                                                }
                                                    tDomainLeafWebHooks = T(psttEat) ;
                                                    strConvertToLowerCaseF( tin0P , psttEat ) ;
                                                    _IO_
                                                {
                                                else
                                                }
                                                    break ;
                                                    bMissingSetting = 1 ;
                                                    etRock.traceF( tin0P , T("!exception / missing setting [key]:    ")+tSettingKey ) ;
                                                    _IO_
                                                {
                                                if( !psttEat )
                                                ZE( strokeS* , psttEat ) ; querySettingF( tin0P , psttEat , tSettingKey  ) ; ___( psttEat ) ;
                                                TN( tSettingKey , "!ipdos.dns.domain.leaf.webhooks" ) ;
                                                _IO_
                                            {
                                            TN( tDomainLeafWebHooks , "" ) ;
                                            _IO_
                                        {
                                        if( F(info2P.flagsSocket) & flSOCKETc_CRYPTfOREIGNsSL )
                                        ZE( strokeS* , psttPemPrivateKey   ) ;
                                        ZE( strokeS* , psttPemCertificates ) ;

                                        TELL( "server: constructing listener socket" )
                                        _IO_
                                    {
                                    SCOOPS
                                    _IO_
                                {
                                while( !info1P.bQuit )
                                ZE( countT , idClient ) ;
                                ZE( boolT , bMissingSetting ) ;

                                } ;
                                    &tSayModulo_f
                                    &tSayModulo_e ,
                                    &tSayModulo_d ,
                                    &tSayModulo_c ,
                                    &tSayModulo_b ,
                                    &tSayModulo_a ,
                                    &tSayModulo_9 ,
                                    &tSayModulo_8 ,
                                    &tSayModulo_7 ,
                                    &tSayModulo_6 ,
                                    &tSayModulo_5 ,
                                    &tSayModulo_4 ,
                                    &tSayModulo_3 ,
                                    &tSayModulo_2 ,
                                    &tSayModulo_1 ,
                                    &tSayModulo_0 ,
                                {
                                textC* pptSayModulo[] =

                                TN( tSayModulo_f , "---------------f " ) ;
                                TN( tSayModulo_e , "--------------e- " ) ;
                                TN( tSayModulo_d , "-------------d-- " ) ;
                                TN( tSayModulo_c , "------------c--- " ) ;
                                TN( tSayModulo_b , "-----------b---- " ) ;
                                TN( tSayModulo_a , "----------a----- " ) ;
                                TN( tSayModulo_9 , "---------9------ " ) ;
                                TN( tSayModulo_8 , "--------8------- " ) ;
                                TN( tSayModulo_7 , "-------7-------- " ) ;
                                TN( tSayModulo_6 , "------6--------- " ) ;
                                TN( tSayModulo_5 , "-----5---------- " ) ;
                                TN( tSayModulo_4 , "----4----------- " ) ;
                                TN( tSayModulo_3 , "---3------------ " ) ;
                                TN( tSayModulo_2 , "--2------------- " ) ;
                                TN( tSayModulo_1 , "-1-------------- " ) ;
                                TN( tSayModulo_0 , "0--------------- " ) ;

                                ZE( countT , idAccept ) ;
                                threadC th( tin0P , *this , TAG( TAGiDnULL ) , tmLoadSilentF , cArg_tmLoadSilent , flTHREADlAUNCH_SHOWpONY , CBsTACKmIN << 1 ) ;
                                TELL( "server: launching thread tmLoadSilentF" )

                                countT cArg_tmLoadSilent = (countT)pc8tp ;
                                pc8tp->c3 = (countT)&cnnSilent ;
                                pc8tp->c2 = (countT)&pnnSilent ;
                                pc8tp->c1 = (countT)&b_pnnSilent ;
                                _IO_
                            {
                            if( pc8tp )
                            newF( tin0P , LF , pc8tp ) ; ___( pc8tp ) ;
                            ZE( count8S* , pc8tp ) ;

                            ZE( countT    , cnnSilent ) ;
                            ZE( nicNameC* , pnnSilent ) ;
                            batonC b_pnnSilent( tin0P , TAG( TAGiDnULL ) ) ;
                            TELL( "server: continuing to set up" )
                            //DUPLICATE CODE: 1030168 2540104

                            }
                                //A:  }
                                //A:      if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->ungrabF( tin0P ) ;
                                //A:      if( info2P.stateBeginF ) (*info2P.stateBeginF)( tin0P , *this , *info1P.ppbdVarying , info2P.cbdVarying , info2P.cArg ) ;
                                //A:      info1P.ppbdVarying = (byteT**)&pState->pbdVarying ; //COMPILERbUG: WATCOM BARFS WITHOUT THE CAST
                                //A:      if( info1P.pBat_pbdVarying ) info1P.pBat_pbdVarying->grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                //A:  {
                                //A:  if( pState )
                                //A:  pState = new( 0 , tin0P , LF ) stateC( tin0P , *this , info1P.bHandedOff , 0 , info2P.cbdVarying , translateStateDrivenServerF , info2P.cArg , info2P.psttSuffix ) ; ___( pState ) ;
                                //A:  ((tin1S&)tin0P).pag1->pTranslateStateCallerCBF = info2P.translateStateF ;
                                //A:  TELL( "server: constructing state" )
                                //A: 20141130@1135: COMMENTED OUT AS PART OF ELIMINATION OF stateC
                                _IO_
                            {
                            if( info2P.bState )
                            //A: ZE( stateC* , pState ) ;
                            ZE( countT , idSessionLath ) ;
                            _IO_
                        {
                        if( !POOP )
                        TN( tSnapBadPeersFileLike , "///ideafarm/ephemeral/" ) ; tSnapBadPeersFileLike += TF2(processGlobal1I.idAdamRoot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("/bad.peers") ;
                        TN( tb4 , "    " ) ;

                        homeS& home = homeS::homeIF() ;

                        __Z( cNicNameMe ) ;
                        }
                            }
                                }
                                    etRock.traceF( tin0P , T("!exception / ifcDrivenServerF / i could not obtain my nicNameC's")  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
                                    POOPRqUIET
                                    _IO_
                                {
                                if( POOP )
                                __Z( cNicNameMe ) ;
                                __Z( pNicNameMe ) ;
                                socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , pNicNameMe , cNicNameMe , 0/*T(postCRAFTWORKfACTORY".ideafarm.com")*/ ) ; ___( pNicNameMe ) ;
                                SCOOPS
                                _IO_
                            {
                            IFsCRATCHoK
                            _IO_
                        {
                        ZE( nicNameC* , pNicNameMe ) ;
                        ZE( countT , cNicNameMe ) ;

                        }
                            }
                                osThreadF( tin0P , tid , info1P.tmF , 0 , 0  , flTHREADlAUNCH_SHOWpONY , CBsTACKmIN << 2 , 0 , (countT)&info1P.bQuit , (countT)&stJob , (countT)&cWorker ) ;
                                ZE( countT , tid ) ;
                                inc02AM( cWorker ) ;
                                _IO_
                            {
                            while( scDo -- )
                            //etRock.traceF( tin0P , T("ifcDrivenServerF / launching workers [cWorkers]:    ")+TF2(scDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)  , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;

                            //scDo = 1 ; //TO MAKE THE TRACE BOOKS EASY TO READ DURING TESTING

                            if( scDo > 0x10 ) scDo = 0x10 ; //U::20240205@1335: WORKAROUND TO AVOID MEMORY EXHAUSTION WHEN EXIST 02 PROCESSORS ; STUDY WHY "SHOWPONY" IS NEEDED (WHAT DOES IT DO?:); STUDY: USING MINIMAL THREAD STACK HERE SO CAN LAUNCH MORE
                            if( scDo < 0 ) scDo = ( - scDo ) * thirdC::osProcessorsIF( tin0P ) ;
                            sCountT scDo = (sCountT)cWorkersSave ;
                            _IO_
                        {
                        if( cWorkersSave )

                        const countT cWorkersSave = info2P.cWorkers ;

                        _IO_
                    {

                    ZE( countT , cJobsHighWater ) ;
                    stackC stJob( tin0P , third , TAG( TAGiDnULL ) , /*flSTACKc_FIFO |*/ flSTACKc_BLOB | flSTACKc_ALLOWzE | flSTACKc_GIVEsIGNnEWpLATE , sizeof( taskDrivenServerJobS ) , ifcIDgRABlAYER_7BASEmISC1 ) ;
                    //DURING A DELUGE, FIFO CAUSES EVERY PEER TO TIME OUT, WHILE LIFO GIVES GOOD PEERS A CHANCE TO GET QUICK SERVICE ; THAT'S THE IDEA, ANYWAY
                    //20210927@1808: CHANGED TO LIFO FOR GRACEFUL FAIL ; DURING A DELUGE, LIFO ENSURES THAT SOME GET QUICK RESPONSE ; THE UNLUCKY PEERS GET NO RESPONSE AND THE ATTACKER THINKS THAT HE IS NOT AFFECTING THE SERVER

                    _IO_
                {

                switchC sw_cSessionWithPeer( tin0P , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , lever_nnPeer ) ;
                nicNameC lever_nnPeer ;

                _IO_
            {

            switchC sw_pso( tin0P , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO , lever_idSession ) ;
            ZE( countT , lever_idSession ) ;

            _IO_
        {

        osTimeNowF( tin0P , timeSnapBad1 , timeSnapBad2 ) ;
        ZE( sCountT , timeSnapBad2 ) ;
        ZE( countT  , timeSnapBad1 ) ;

        osTimeNowF( tin0P , timeLathPurgeRecentPeer1 , timeLathPurgeRecentPeer2 ) ;
        ZE( sCountT , timeLathPurgeRecentPeer2 ) ;
        ZE( countT  , timeLathPurgeRecentPeer1 ) ;

        stackC stBadPeer(    tin0P , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_nicNameC ) ;
        stackC stRecentPeer( tin0P , third , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_nicNameC ) ;
        ZE( countT , cSession ) ;
        ZE( countT , cWorker ) ;

        //etRock.traceF( tin0P , T("ifcDrivenServerF [cSessionMax]:    ")+TF2(info2P.cSessionMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_HOMEeCHOdEADMAN1 | flTRACE_FORCEnOsILENCE | flTRACE_ECHOoNLY ) ;
        if( !info2P.cSessionMax ) info2P.cSessionMax = CsESSIONmAXdFLTiFCdRIVENsERVER ;

        sessionsC& sessions = info2P.pSessions ? *info2P.pSessions : *(sessionsC*)pbSessions ;

        }
            bDeleteSessions = 1 ;
            new( 0 , tin0P , pbSessions , sizeof pbSessions ) sessionsC( tin0P , *this , TAG( TAGiDnULL ) ) ;
        {
        if( !info2P.pSessions )
        ZE( boolT , bDeleteSessions ) ;
        byteT pbSessions[ sizeof( sessionsC ) ] ;
        TELL( "server: setting up" )

        TN( tSayWillServeTo , "ifcDrivenServerF / will serve to [nnPeer]:    " ) ;

      //nicNameC nnGorillaInnerOk8 = socketC::nicNameIF( tin0P , *this , T("10.0.3.8") ) ;
      //nicNameC nnGorillaInnerOk7 = socketC::nicNameIF( tin0P , *this , T("10.0.3.7") ) ;
      //nicNameC nnGorillaInnerOk6 = socketC::nicNameIF( tin0P , *this , T("10.0.3.6") ) ;
      //nicNameC nnGorillaInnerOk5 = socketC::nicNameIF( tin0P , *this , T("10.0.3.5") ) ;
      //nicNameC nnGorillaInnerOk4 = socketC::nicNameIF( tin0P , *this , T("10.0.3.4") ) ;
      //nicNameC nnGorillaInnerOk3 = socketC::nicNameIF( tin0P , *this , T("10.0.3.3") ) ;
      //nicNameC nnGorillaInnerOk2 = socketC::nicNameIF( tin0P , *this , T("10.0.3.2") ) ;

        nicNameC nnGorillaOuterOk1 = socketC::nicNameIF( tin0P , *this , tNnGorillaOuter ) ;
        nicNameC nnGorillaInnerOk1 = socketC::nicNameIF( tin0P , *this , T("10.0.3.1") ) ;

        }
            delF( tin0P , psttEat ) ;
            }
                tNnGorillaOuter = T(psttEat) ;
                strConvertToLowerCaseF( tin0P , psttEat ) ;
            {
            else
            if( !psttEat ) etRock.traceF( tin0P , T("!exception / missing setting [key]:    ")+tSettingKey ) ;
            ZE( strokeS* , psttEat ) ; querySettingF( tin0P , psttEat , tSettingKey  ) ; ___( psttEat ) ;
            TN( tSettingKey , "!ipdos.http.gorilla.go1" ) ;
        {
        TN( tNnGorillaOuter , "10.0.9.9" ) ;    // A LEGAL VALUE THAT IS A "DON'T CARE" AS IT WILL LIKELY NEVER BE USED

        boolT& bShieldsDown = *(boolT*)((count8S*)info2P.cArgApp)->c5 ;

        const boolT bHttp    = info2P.idPortHint == ifcIDpORT_HTTP ;
        const boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

        etherC& etRock = etherC::etRockIF( tin0P ) ;

        _IO_
    {

    }
        if( POOP ) return ;
        __( !info2P.bState && !!info2P.psttSuffix ) ;
        __( !info2P.bState && !!info2P.translateStateF ) ;
        __( !info2P.bState && info2P.cbdVarying ) ;
        __(  info2P.bState && ((tin1S&)tin0P).pag1->_etherC_.cInServer ++ ) ;
        __( info1P.idPort ) ;
        __( !info1P.tmF ) ;
        __( info1P.ppbdVarying && !!*info1P.ppbdVarying ) ;
        __( F(flagsMode) & flTHIRDmODE_IMPOTENCEeXPECTED ) ;
        __( F(flagsMode) & flTHIRDmODE_QUITTER ) ;

        __( !( F(((tin1S&)tin0P).flagsThreadMode2) & flTHREADmODE2_ADAMmAINtHREAD ) && !( F(flagsMode) & flTHIRDmODE_TINoWNER ) ) ; // THESE 2 CHECKS ENSURE etThread IS BEING USED
        __(    F(((tin1S&)tin0P).flagsThreadMode2) & flTHREADmODE2_ADAMmAINtHREAD   &&    F(flagsMode) & flTHIRDmODE_TINoWNER   ) ; // THESE 2 CHECKS ENSURE etThread IS BEING USED (THIS LINE WILL DETECT THE USE OF etPrimeF() BUT WILL FAIL TO DETECT THE USE OF AN etherC OBJECT OTHER THAN ether AND etThread ON THREAD 1)

        if( POOP ) return ;
    {
    IFbEcAREFUL

    SCOOP
{
/*1*/voidT etherC::ifcDrivenServerF( tin0S& tin0P , serverInfo1S& info1P , serverInfo2S& info2P )/*1*/

/**/
*/
   use multiple concurrent sessions whenever possible
    let transaction failure data be captured, i.e. do not specify flTHIRDmODE_IMPOTENCEeXPECTED
    if the transaction fails, discard all uncommitted results, reconnect, and retry the connection at least 01 times, sleeping at least 04 tucks between each try
    do not commit results to permanent storage until the transaction has completed
   treat the session as a transaction
   retry connection establishment forever, or at least 01 times
  clients
  client
    the old instance continues to work until all of its client sessions have ended
    in this scenario, when a new instance is hired, it immediately becomes the listener for the hardcoded port
    this will allow sessions started with an old instance to coexist with a new instance that has taken over service of the hardcoded port
   if a hardcoded port is being served, use TASKdRIVENsERVERnEWsOCKET to switch each session to a new socket (bound to a dynamically allocated port)
   on asynch impotence, cancel all current sessions immediately by specifying time1graceP = 0
  server
 recommended protocol
  if not 0 then is called immediately before stateC object is destroyed
  normally is 0
  can be 0
 stateEndFP
  if not 0 then is called immediately after stateC object is constructed
  normally is 0
  can be 0
 stateBeginFP
   example: T("6a40104")
  used to give a distinct name so that multiple instances of the calling adam can coexist
  normally should be 0
  suffix for the state backing image
 psttSuffixP
   see pbdVaryingP for a description of how the caller must access its state information
  it is illegal for the definition of translateStateFP to store its pbToVaryingP parameter for later use by the caller
  can be 0
 translateStateFP
 cbdVaryingP
  only wo instance of me with bStateP can be called per process
  if 0 then the remaining parameters must default
  if not 0 then i will construct a stateC object
  can be 0
  defaults to 1
 bStateP
  when asynchronous impotence occurs, and for a short time afterward until my replacement starts, an attempted connection might fail or might be accepted and then canceled
  the new server, if any, is not told to start until all connections are gone
  this value, if not -1, is floored before use to the greatest nonupper multiple of TUCK * 04
  else i wait time1graceP and then abort any connections that still exist
  if -1 then i wait forever for client connections to close on their own
  can be 0
  time after asynchronous impotence is detected before all client connections are aborted
 time1graceP
  i do not look at the value of cArgP
  passed to tmFP and to translateStateFP
  can be 0
 cArgP
  if 0 then connections will be refused (closed immediately after acceptance) if there are CsESSIONmAXdFLTiFCdRIVENsERVER sessions
  can be 0
 cSessionMaxP
  if 0 then a port will be assigned
  can be 0
 idPortHintP
  will be reset to 0 when i stop listening
  will be revised each time, if any, that the socket is replaced
  will be set to the idPort assigned, which is guaranteed to initially be idPortHintP if the latter is not 0
  must be 0
 idPortP
  must be defined using the TASKdRIVENsERVER symbol
  must conform to the current argument requirements (see adam.0140104 or another adam class that uses me)
  must not be 0
 tmFP
  is not given until immediately after a socket bound to the new idPort is set to listening mode
  given each time that the value of idPortP changes, including its initial assignment and its final reset to 0
 sgnIdPortReplacedP
  see stateC::stateC
 bHandedOffP
 pBat_pbdVaryingP
   in other words, during termination a client session can continue to be served, but it must be "crippled" to prevent transactions that modify state
   if 0 then the current process must not do anything that implies a change in the state of its adam class
   0 indicates that the current process no longer "owns" the state of its adam class
  the protocol for accessing state is to grab the baton, test whether pbdVaryingP is 0, if not 0 access pbdVaryingP, and ungrab the baton
    just before state is frozen, b_pbdVaryingP is grabbed and pbdVaryingP is reset to 0
    during termination, state is frozen, handed off, and saved
   during termination, pbStateP will be 0 and the caller must not attempt to access its state information
   normally pbdVaryingP will be nonze and will point to cbdVaryingP bytes of state that the caller can use to record its current state
  during the execution of a tmFP thread, can be either 0 or nonze
  must be 0
 pbdVaryingP
 tin0P
arguments
  thread 2 serves a private chat port, so that the calling adam can accept chat connections to receive commands and report results
  main thread serves port X, which is the primary duty of the calling adam
 example
before calling me on the main thread, launch other threads that call me with bStateP false, to serve ancillary ports
call me on the main thread, with bStateP true, to serve a port
i do not return control to the calling thread until all sessions have ended
provide me with a task definition and i will use it to serve the specified port
\<A HREF=\"5.1030168.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$ifcDrivenServerF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

