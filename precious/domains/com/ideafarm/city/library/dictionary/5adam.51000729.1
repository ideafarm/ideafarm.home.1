
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

thirdC::osProcessIdPhaseAdamIF( tin0P , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

etThread.osThreadSwitchingDesireF( tin0P , idDesireSave ) ;

etThread.delF( tin0P , psttNapCommand ) ;
}
    else etThread.traceF( tin0P , T("cloud administration suppressed because some required settings were not found") ) ;
    }
        }
            }
                }
                    }
                        ether.osSleepF( tin0P , bFail ? TOCK << 4 : time1Nap ) ;
                        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                    {
                    else
                    }
                        etThread.traceF( tin0P , T("cloud: step: [idStepSoil]:    ")+TF2(idStep,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        countT idStep = 1 + incv02AM( home.idStepSoil ) ;
                    {
                    if( waitStepModulo >= 2 )
                {
                if( !etPrime )

                etThread.traceF( tin0P , bFail ? tAborted : tEnded ) ;
                }
                    }
                        etThread.traceF( tin0P , T("cloud administration cycle ending") ) ;

                        }
                            etThread.traceF( tin0P , T("cloud administration cycle could not be completed") ) ;
                            bFail = 1 ;
                            POOPR
                        {
                        if( POOP )

                        etThread.osThreadSwitchingDesireF( tin0P , idDesireSave ) ;
                        c loudC cloudRax( tin0P , tName , idDoIfDiffer , flagsCloud , idCloud , T(cloudSpec.postBuilding) , T(cloudSpec.postUser) , T(cloudSpec.postPassword) , T(cloudSpec.postRemote) , T(cloudSpec.postLocal) , T(cloudSpec.postLike) , etThread.strDigitsToSCountF( tin0P , T(cloudSpec.postDelTries) ) , F(flagsCloud) & flCLOUDc_REMOTEiSmASTER ? cloudUpdateLocalCBF : cloudUpdateRemoteCBF , pcArgUpdate , F(flagsCloud) & flCLOUDc_REMOTEiSmASTER ? cloudNixLocalCBF : cloudNixRemoteCBF , pcArgNix ) ;

                        }
                            etThread.traceF( tin0P , T("warning: cloud name truncated to length 03:  ")+tName ) ;
                            etThread.delF( tin0P , psttn ) ;
                            tName = T(psttn) ;
                            etThread.strSubstringF( tin0P , psttn , idf , idl , tName ) ; ___( psttn ) ;
                            countT idl = 0x30 ;
                            countT idf = 1 ;
                            ZE( strokeS* , psttn ) ;
                        {
                        if( tName.csF( tin0P ) > 0x30 )
                    {
                    _IO_
                    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZY ) ;
                    countT idDesireSave = etThread.osThreadSwitchingDesireF( tin0P ) ;

                    //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                    if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postGhost   , "yes"      ) ) flagsCloud |= flCLOUDc_GHOST ;
                    //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                    if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postDelete  , "notexist" ) ) flagsCloud |= flCLOUDc_DELETEiFmASTERnOTeXIST ;
                    if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postDelete  , "exist"    ) ) flagsCloud |= flCLOUDc_DELETEiFmASTEReXIST ;
                    //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                    if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postMaster  , "remote"   ) ) flagsCloud |= flCLOUDc_REMOTEiSmASTER ;
                    //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                    if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postNetwork , "internal" ) ) flagsCloud |= flCLOUDc_USEiNTERNALlAN ;

                    //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                    flagsT flagsCloud = flagsCt ;

                    TN( tName , cloudSpec.postName ) ;

                    etThread.traceF( tin0P , T("cloud administration begun / initial administration routine / starting") ) ;

                    //etThread.disk FixBadFileNamesF( tin0P , T(cloudSpec.postLocal) , flETHERfIXnAMES_RECURSE ) ; // JUST IN CASE AN INVALID FILE NAME GOT IN
                    //etThread.traceF( tin0P , T("cloud administration cycle begun / renaming files to eliminate invalid characters") ) ;
                {
                ZE( boolT , bFail ) ;

                }
                    }
                        etThread.traceF( tin0P , T("cloud: step: [idStepSoil]:    ")+TF2(idStep,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        countT idStep = 1 + incv02AM( home.idStepSoil ) ;

                        ether.traceF( tin0P , T(bNapped?"cloudC: waitstep: waiting ended [idStepSoil,waitStepModulo,waitStepRemainder]:    ":"cloudC: waitstep: did not wait  [idStepSoil,waitStepModulo,waitStepRemainder]:    ")+TF2(home.idStepSoil,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepModulo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepRemainder,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( !etPrime )

                    }
                        ++ s ; etPrime.osSleepF( tin0P , TOCK ) ;

                        }
                            bNapped = 1 ;
                            ether.traceF( tin0P , T("cloudC: waitstep: waiting begun [idStepSoil,waitStepModulo,waitStepRemainder]:    ")+TF2(home.idStepSoil,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepModulo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepRemainder,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        if( !bNapped )
                    {
                    while( !etPrime && home.idStepSoil % waitStepModulo != waitStepRemainder )

                    ZE( boolT , bNapped ) ;
                    TN( tb4 , "    " ) ;

                    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                {
                if( !etPrime && waitStepModulo >= 2 )
            {
            while( !etPrime && !ether && !etThread )

            SCOOPS
        {
        IFsCRATCHoK

        etherC& etPrime = etherC::etPrimeIF( tin0P ) ;
        homeS& home = homeS::homeIF() ;

        else                      etThread.traceF( tin0P , T("after each successful cloud administration cycle, i will nap for ")+TF2(time1Nap>>0x10,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" tock before beginning a new cycle") ) ;
        if( waitStepModulo >= 2 ) etThread.traceF( tin0P , T("before beginning each cloud administration cycle, i will wait for home.idStepSoil % ")+TF2(waitStepModulo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" to be ")+TF2(waitStepRemainder,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" and i will increment home.idStepSoil before and after each cycle") ) ;

        TN( tEnded   , "" ) ; tEnded = T("cloud administration cycle ended ; napping for ")+TF2(time1Nap>>0x10,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" tock") ;
        TN( tAborted , "cloud administration cycle aborted ; napping for 01 tock" ) ;

        ;
                : TICK << 4
                ? etThread.strDigitsToSCountF( tin0P , T(cloudSpec.postNapTocks) ) << 0x10
            : *cloudSpec.postNapTocks
            ? 0
        countT time1Nap = waitStepModulo >= 2 // IF I AM PARTICIPATING IN A STEPPING GROUP THEN I IGNORE THE NAP SPECIFICATION

        countT waitStepRemainder = etThread.strDigitsToSCountF( tin0P , T(cloudSpec.postWaitStepRemainder) ) ;
        countT waitStepModulo    = etThread.strDigitsToSCountF( tin0P , T(cloudSpec.postWaitStepModulo   ) ) ;
    {
    if( idCloud && *cloudSpec.postUser && *cloudSpec.postPassword && *cloudSpec.postRemote && *cloudSpec.postName && *cloudSpec.postLocal && *cloudSpec.postBuilding )

    }
        else if( !etThread.strCompareF( tin0P , T(cloudSpec.postIfDiffer) , T("replace") ) ) idDoIfDiffer = ifcIDdOcLOUDiFdIFFER_REPLACE ;
        else if( !etThread.strCompareF( tin0P , T(cloudSpec.postIfDiffer) , T("report" ) ) ) idDoIfDiffer = ifcIDdOcLOUDiFdIFFER_REPORT  ;
             if( !etThread.strCompareF( tin0P , T(cloudSpec.postIfDiffer) , T("nothing") ) ) idDoIfDiffer = ifcIDdOcLOUDiFdIFFER_NOTHING ;
    {
    if( *cloudSpec.postIfDiffer )

    countT       idDoIfDiffer = ifcIDdOcLOUDiFdIFFER_REPORT ;

    //etThread.traceF( tin0P , T("debug [flagsCt]: ")+TF3(flagsCt,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
    /*const*/ flagsT flagsCt      = flCLOUDc_null ;

    countT pcArgNix[] = { (countT)&cloudSpec } ;
    countT pcArgUpdate[]    = { (countT)&cloudSpec } ;

    if( *cloudSpec.postId && !etThread.strCompareF( tin0P , T(cloudSpec.postId) , T("rackspace.com") ) ) idCloud = ifcIDcLOUD_RACKSPACE ;
    ZE( countT , idCloud ) ;

    cloudSpec.sayF( tin0P , etThread ) ;

    cloudSpecsS& cloudSpec = *(cloudSpecsS*)(byteT*)napSpec ;

    napkinC napSpec( tin0P , TAG( TAGiDnULL ) , T(psttNapCommand) , 0 , sizeof( cloudSpecsS ) , ifcOPENsHAREDmEMORYhOW_nFeO ) ;

    etThread.traceF( tin0P , T("command received: ")+T(psttNapCommand) ) ;
{
else
}
    }
        while( !ether && napSpec.cRefF() == 1 ) { ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ; }
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    
        etThread.ifcHireF( tin0P , T("ifcIDaDAM_CLOUD") , ((tin1S&)tin0P).pag1->idAdam , tHey+T(" ")+tNapSpecName ) ;
        cClouds ++ ;
    
        pSpec->sayF( tin0P , etThread ) ;
    
        napSpec.formattingIsDoneF( tin0P ) ;
        cloudSpecsS* pSpec = new( 0 , tin0P , napSpec , napSpec ) cloudSpecsS( tin0P , etThread , T("IPDOS (tm) automatic update") , "IAD" , 0 , "rackspace.com" , 0 , "///ideafarm/ephemeral/city/park/exedll/1/" , tPassword /*"8dbb36ba03da400c8fcf364ab9ceefb5" : THE PREVIOUS PASSWORD HAS BEEN CHANGED*/ , "exedll.1" , tUser /*"ipdos.public"*/ , "yes" , "1" , "remote" , 0 , "001" , "yes" , "no" , "0" , "0" , "" ) ; ___( pSpec ) ;
    
        secretF( tin0P , etThread , tUser , tPassword ) ;
        TN( tPassword , "" ) ;
        TN( tUser , "" ) ;
    
        napkinC napSpec( tin0P , TAG( TAGiDnULL ) , tNapSpecName , 0 , sizeof( cloudSpecsS ) , ifcOPENsHAREDmEMORYhOW_nCeF ) ;
        etThread.traceF( tin0P , T("constructing cloud spec napkin with name: ")+tNapSpecName ) ;
    
        }
            etThread.delF( tin0P , psttu ) ;
            tNapSpecName = T("cloud.napSpec.")+T(psttu) ;
            etThread.strUniqueF( tin0P , psttu ) ; ___( psttu ) ;
            ZE( strokeS* , psttu ) ;
        {
        TN( tNapSpecName , "" ) ;
    
        // IT IS THE REFERENCES IN THE FILES IN "master" THAT DETERMINE WHICH FILE IN "hover" IS LAUNCHED WHEN LAUNCHING THE PROCESS FOR AN ADAM
        // THE REASON FOR THE REQUIREMENT IS THAT EVERY FILE IN "hover" THAT IS REFERENCED BY A FILE IN "master" MUST EXIST
        // THIS IS ASSURED AS LONG AS THE BASE OPERATING SYSTEM COLLATES "hover" BEFORE "master"
        // IT IS CRITICAL THAT THE "hover" DIRECTORY BE PROCESSED BEFORE THE "master" DIRECTORY, BOTH WHEN THE DEVELOPMENT COMPUTER PUBLISHES AND WHEN A CLIENT UPDATES ITSELF
    
        etThread.traceF( tin0P , T("cloud: IPDOS (tm) automatic update") ) ;
    {
    if( !bExeDllPublisher && etThread.diskIdF( tin0P , T("///c") ) != IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 ) // DISABLE AUTO UPDATE IF DEVELOPMENT MACHINE (EITHER OF OO TESTS)

    }
        while( !ether && napSpec.cRefF() == 1 ) { ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ; }
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        etThread.ifcHireF( tin0P , T("ifcIDaDAM_CLOUD") , ((tin1S&)tin0P).pag1->idAdam , tHey+T(" ")+tNapSpecName /*, flHIRE_DEBUG*/ ) ;
        cClouds ++ ;

        pSpec->sayF( tin0P , etThread ) ;

        if( !thirdC::c_strcmpIF( tin0P , pSpec->postRemote , "exedll.1" ) ) bExeDllPublisher = 1 ;

        THREADmODE1rESTORE
        napSpec.formattingIsDoneF( tin0P ) ;
        }
            etThread.delF( tin0P , psttk ) ;
            pSpec->cloudSpecsS::setF( tin0P , etThread , psttzLeverCloud , psttk ) ;
            etThread.traceF( tin0P , T("  key: ")+T(psttk) ) ;
            swsSettings >> psttk ;
            ZE( strokeS* , psttk ) ;
        {
        while( swsSettings )
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

        cloudSpecsS* pSpec = new( 0 , tin0P , napSpec , napSpec ) cloudSpecsS( tin0P , etThread , psttzLeverCloud ) ; ___( pSpec ) ;

        napkinC napSpec( tin0P , TAG( TAGiDnULL ) , tNapSpecName , 0 , sizeof( cloudSpecsS ) , ifcOPENsHAREDmEMORYhOW_nCeF ) ;
        etThread.traceF( tin0P , T("constructing cloud spec napkin with name: ")+tNapSpecName ) ;

        }
            etThread.delF( tin0P , psttu ) ;
            tNapSpecName = T("cloud.napSpec.")+T(psttu) ;
            etThread.strUniqueF( tin0P , psttu ) ; ___( psttu ) ;
            ZE( strokeS* , psttu ) ;
        {
        TN( tNapSpecName , "" ) ;

        etThread.traceF( tin0P , T("cloud: ")+T(psttzLeverCloud) ) ;
        psttzLeverCloud = (strokeS*)swsSettings.leverF( tin0P , idf ) ;
    {
    for( countT idf = 1 ; !ether && idf <= cFlavors ; idf ++ )
    ZE( boolT , bExeDllPublisher ) ;
    etThread.traceF( tin0P , T("launching a cloud administrator process for each cloud [cClouds]: ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    countT cFlavors = swsSettings.cFlavorsF( tin0P ) ;
    ZE( countT , cClouds ) ;
    ZE( boolT  , bQuit   ) ;

    etThread.walkSettingsF( tin0P , pbBuffer , sizeof pbBuffer , countTC() , myCBF , pcArg ) ;
    countT pcArg[] = { 0 , (countT)&psttzLeverCloud , (countT)&swsSettings } ;

    switchStackC swsSettings( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverCloud , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
    ZE( strokeS* , psttzLeverCloud ) ;
{
else*/ if( !psttNapCommand )
etThread.traceF( tin0P , T("CLOUD: doing nothing since this home does not have PAID privileges") ) ;
)
    !( F(home.flags) & flHOMEs_IDEAFARMcLOUDiSgONE )
    &&
    !( F(home.flags) & flHOMEs_PAIDpRIVILEGES )
(
/*if

homeS& home = homeS::homeIF() ;

}
    }
        }
            etThread.strMakeF( tin0P , LF , psttNapCommand , psttc1 ) ; ___( psttNapCommand ) ;
            bArmed = 0 ;
        {
        else if( bArmed )
        if( !etThread.strCompareF( tin0P , psttc1 , tHey ) ) bArmed = 1 ;
        etThread.traceF( tin0P , T("param: ")+T(psttc1) ) ;
    {
    FORsTRINGSiN1( pstt1Param )
    ZE( boolT , bArmed ) ;
    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tin0P ) ;
{
TN( tHey , "!napCommand" ) ;
ZE( strokeS* , psttNapCommand ) ;

const countT idDesireSave = etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIER ) ;

thirdC::osProcessIdPhaseAdamIF( tin0P , ifcIDpHASEhANDOFFoLD_WORKING ) ;

TODO

// 
// TIME THAT YOU OPEN A SOIL (TM) FILE, TELL WINDOWS WHAT FILE YOU WANT TO USE WHENEVER OPENING A SOIL (TM) FILE.
// TO INSPECT OR EDIT A SOIL (TM) FILE, OPEN IT WITH A NORMAL TEXT EDITOR (SUCH AS NOTEPAD.EXE ON WINDOWS).  THE FIRST
// IF THE FILE IS REJECTED, IT WILL BE ACCOMPANIED WITH ANOTHER ASCII PLAIN TEXT FILE THAT CONTAINS ERROR INFORMATION
// 
//     ///ideafarm.home.1/IdeaFarm (tm)/SYSTEM/1.3. Pick Up Rejected SOIL (tm) Text Files Here/
// 
//     ///ideafarm.home.1/IdeaFarm (tm)/SYSTEM/1.4. Pick Up Completed SOIL (tm) Text Files Here/
// 
// WITHIN A MINUTE OR OO, THE FILE WILL BE MOVED INTO WO OF OO FOLDERS:
// 
//     ///ideafarm.home.1/IdeaFarm (tm)/SYSTEM/1.2. SOIL (tm) Text Files Being Eaten/
// 
// WHEN YOU DO THAT, THE FILE WILL DISAPPEAR IMMEDIATELY BECAUSE IT HAS BEEN MOVED TO ANOTHER FOLDER:
// 
//     ///ideafarm.home.1/IdeaFarm (tm)/SYSTEM/1.1. Drop a Copy of SOIL (tm) Text Files Here/
// 
// A PARTICULAR FOLDER WITHIN THE IPDOS (tm) HOME FOLDER.  THE PARTICULAR FOLDER IS:
// OF EACH OF THESE FILES AS A DECLARATORY PROGRAM.  TO "RUN" SUCH A PROGRAM, COPY AND PASTE ** A COPY ** OF THE PROGRAM INTO
// OF THE SOIL (tm)  ("SENTIENT OBJECT INTERFACE LANGUAGE") LANGUAGE.  STORE EACH OF YOUR SOIL FILES IN A SAFE PLACE.  THINK
// IPDOS BY CREATING ASCII PLAIN TEXT FILES WITH NAMES THAT END WITH ".soil".  EACH SUCH FILE MUST CONFORM TO THE REQUIREMENTS
// ESTABLISH AN EMAIL SUPPORT RELATIONSHIP AND TO ENABLE IPDOS (tm) ON YOUR COMPUTER.  THEN CONFIGURE IPDOS.  YOU CONFIGURE
// IMMEDIATELY AFTER INSTALLING IPDOS (tm), NONE OF THESE SETTINGS EXIST.  AFTER INSTALLING IPDOS (tm), CONTACT IDEAFARM.COM TO
//
//   key: user
//   key: remote
//   key: password
//   key: local
//   key: id
//   key: desire
//   key: building
// cloud: test
// 
// SETTINGS WITH THESE NAMES RESULT IN THE FOLLOWING SHORT KEYS BEING DEFINED FOR THE CLOUD THAT THE USER HAS NAMED "test":
// 
//  "!cloud.test.user"
//  "!cloud.test.remote"
//  "!cloud.test.password"
//  "!cloud.test.local"
//  "!cloud.test.id"
//  "!cloud.test.desire"
//  "!cloud.test.building"
//
// (E.G. rackspace.com).  THE FOLLOWING IS A LIST OF ALL OF THE SETTINGS REQUIRED FOR A RACKSPACE CLOUD.
// TO ADMINISTER THE CLOUD.  THESE SUFFIX NAMES ARE CHOSEN TO CORRESPOND CLOSELY TO THE NAMES USED BY THE CLOUD SERVICE PROVIDER
// THE SUFFIX OF EACH KEY, "building", "id", "local", ETC., IS MANDATORY.  THESE SUFFIXES CORRESPOND TO INFORMATION ITEMS REQUIRED
//
// LOWER CASE ALPHAS ('a'-'z').  IT SHOULD NOT CONTAIN PUNCTUATION.  THE '!' CHARACTER IS RESERVED FOR USE WITHIN IPDOS (tm).
// INDICATES WHICH CLOUD THE SETTING APPLIES TO.  THIS NAME MUST NOT CONTAIN BLANKS AND SHOULD CONTAIN ONLY DIGITS ('0'-'9') AND/OR
// THE "test" PART OF EACH KEY IS AN ARBITRARY NAME CHOSEN BY THE USER TO IDENTIFY A CLOUD THAT IS TO BE ADMINISTERED.  THIS NAME
//
// SEARCHING SETTINGS TO BUILD A LIST OF THE CLOUDS THAT IT IS TO ADMINISTER
// THE "!cloud." PREFIX WITHIN EACH KEY IS MANDATORY ; THE CLOUD ADMINISTRATOR IGNORES SETTINGS THAT DO NOT BEGIN WITH "!cloud." WHEN
//
// THESE ARE THE KEYS OF THE SETTINGS THAT ARE NEEDED TO ADMINISTER A RACKSPACE CLOUD ("Cloud Files" at Rackspace.com)

//U::NEXT: LOAD THE CLOUD NAMES INTO A CONTAINER AND THEN LAUNCH AN ADMINISTRATOR THREAD FOR EACH CLOUD

}
    }
        tPasswordP += T(postWo) ;
        osTextT postWo[] = { (osTextT)( pcPassword[ offi ] SUBfLAK ) , 0 } ;
    {
    for( countT offi = 0 ; offi < sizeof pcPassword / sizeof pcPassword[ 0 ] ; offi ++ )

    }
        tUserP += T(postWo) ;
        osTextT postWo[] = { (osTextT)( pcUser[ offi ] SUBfLAK ) , 0 } ;
    {
    for( countT offi = 0 ; offi < sizeof pcUser / sizeof pcUser[ 0 ] ; offi ++ )

    countT pcPassword[] = { '8' ADDfLAK , 'd' ADDfLAK , 'b' ADDfLAK , 'b' ADDfLAK , '3' ADDfLAK , '6' ADDfLAK , 'b' ADDfLAK , 'a' ADDfLAK , '0' ADDfLAK , '3' ADDfLAK , 'd' ADDfLAK , 'a' ADDfLAK , '4' ADDfLAK , '0' ADDfLAK , '0' ADDfLAK , 'c' ADDfLAK , '8' ADDfLAK , 'f' ADDfLAK , 'c' ADDfLAK , 'f' ADDfLAK , '3' ADDfLAK , '6' ADDfLAK , '4' ADDfLAK , 'a' ADDfLAK , 'b' ADDfLAK , '9' ADDfLAK , 'c' ADDfLAK , 'e' ADDfLAK , 'e' ADDfLAK , 'f' ADDfLAK , 'b' ADDfLAK , '5' ADDfLAK } ;
    countT pcUser[]     = { 'i' ADDfLAK , 'p' ADDfLAK , 'd' ADDfLAK , 'o' ADDfLAK , 's' ADDfLAK , '.' ADDfLAK , '0' ADDfLAK , '1' ADDfLAK } ;
{
voidT secretF( tin0S& tin0P , etherC& etherP , textC& tUserP , textC& tPasswordP )

#define SUBfLAK & ~0x84c73d00
#define ADDfLAK |  0x84c73d00

}
    return 0 ;

    }
        __Z( ids ) ; // NONUNIQUENESS IS IMPOSSIBLE BECAUSE bitTreeC IS USED TO STORE THE SETTINGS KEYS AND VALUES
        swsSettingsP.sinkF( tin0P , ids , psttKey , flSTACKsINK_UNIQUE ) ;
        ZE( countT , ids ) ;
        psttzLeverCloudP = tCloud ;
    
        ((tin1S&)tin0P).pEther->strMakeFromOsTextF( tin0P , psttKey , poste ) ; ___( psttKey ) ;
        ZE( strokeS* , psttKey ) ;
        TN( tCloud , postc ) ;
    
        *( poste ++ ) = 0 ;
        osTextT* poste = thirdC::c_strrchrIF( tin0P , postc , '.' ) ;
        osTextT* postc = pbBufferCopy + sizeof postHey - 1 ;
    {
    if( thirdC::c_strstrIF( tin0P , pbBufferCopy , postHey ) )
    osTextT postHey[] = "!cloud." ;

    for( countT offr = 0 ; pbBuffer[ offr ] ; offr ++ ) pbBufferCopy[ offr ] = reverseBitsF( pbBuffer[ offr ] ) ;

    thirdC::c_memsetIF( tin0P , pbBufferCopy , sizeof pbBufferCopy ) ;

    switchStackC& swsSettingsP     = *(switchStackC*)(&cArg2P)[ 2 ] ;
    strokeS*&     psttzLeverCloudP =     *(strokeS**)(&cArg2P)[ 1 ] ;
{
countT myCBF( tin0S& tin0P , countT& cArg1P , countT& cArg2P )
byteT pbBufferCopy[ TUCK ] ;
byteT pbBuffer[ TUCK ] ;

}
    return 1 ;
{
boolT cloudNixRemoteCBF( tin0S& tin0P , etherC& etherP , cloudC& cloudP , const strokeS* const psttShortP , countT* pcArgP )

}
    return 1 ;
{
boolT cloudNixLocalCBF( tin0S& tin0P , etherC& etherP , cloudC& cloudP , const strokeS* const psttShortP , countT* pcArgP )

}
    return 1 ;
{
boolT cloudUpdateRemoteCBF( tin0S& tin0P , etherC& etherP , cloudC& cloudP , const strokeS* const psttShortP , countT* pcArgP )

}
    return 1 ;
{
boolT cloudUpdateLocalCBF( tin0S& tin0P , etherC& etherP , cloudC& cloudP , const strokeS* const psttShortP , countT* pcArgP )

}
    etherP.delF( tin0P , psttSay ) ;
    etherP.traceF( tin0P , psttSay , /*flTRACE_NOpREFIX |*/ flTRACE_KEEPcRlF ) ;

    etherP.strFuseF( tin0P , psttSay , T(" ; postRenameToHash:"  ) ) ; etherP.strFuseF( tin0P , psttSay , T(postRenameToHash     ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; like:"              ) ) ; etherP.strFuseF( tin0P , psttSay , T(postLike             ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; waitstepremainder:" ) ) ; etherP.strFuseF( tin0P , psttSay , T(postWaitStepRemainder) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; waitstepmoduo:"     ) ) ; etherP.strFuseF( tin0P , psttSay , T(postWaitStepModulo   ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; ghost:"             ) ) ; etherP.strFuseF( tin0P , psttSay , T(postGhost            ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; allornone:"         ) ) ; etherP.strFuseF( tin0P , psttSay , T(postAllOrNone        ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; naptocks:"          ) ) ; etherP.strFuseF( tin0P , psttSay , T(postNapTocks         ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; network:"           ) ) ; etherP.strFuseF( tin0P , psttSay , T(postNetwork          ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; master:"            ) ) ; etherP.strFuseF( tin0P , psttSay , T(postMaster           ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; delete.tries:"      ) ) ; etherP.strFuseF( tin0P , psttSay , T(postDelTries         ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; delete:"            ) ) ; etherP.strFuseF( tin0P , psttSay , T(postDelete           ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; user:"              ) ) ; etherP.strFuseF( tin0P , psttSay , T(postUser             ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; remote:"            ) ) ; etherP.strFuseF( tin0P , psttSay , T(postRemote           ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; password:"          ) ) ; etherP.strFuseF( tin0P , psttSay , T(/*postPassword*/"(hidden for security)" ) ) ; //THE ISSUE HERE RELATES TO AUTOMATIC UPDATES ; FOR AUTOMATIC UPDATES, THIS LINE WILL DISPLAY IDEAFARM.COM'S PASSWORD TO EVERY USER ; ENABLING THIS LINE MIGHT BE OK AS LONG AS IT IS CONDITIONALLY DISABLED FOR AUTOMATIC UPDATE AND FOR ANY OTHER HARDCODED CLOUD PASSWORD
    etherP.strFuseF( tin0P , psttSay , T(" ; local:"             ) ) ; etherP.strFuseF( tin0P , psttSay , T(postLocal            ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; ifdiffer:"          ) ) ; etherP.strFuseF( tin0P , psttSay , T(postIfDiffer         ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; id:"                ) ) ; etherP.strFuseF( tin0P , psttSay , T(postId               ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; desire:"            ) ) ; etherP.strFuseF( tin0P , psttSay , T(postDesire           ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(  " building:"          ) ) ; etherP.strFuseF( tin0P , psttSay , T(postBuilding         ) ) ;
    etherP.strFuseF( tin0P , psttSay , T("cloud spec" ": "       ) ) ;

    etherP.strMakeF( tin0P , LF , psttSay , 0 , TUCK << 3 ) ; ___( psttSay ) ;
    ZE( strokeS* , psttSay ) ;
{
voidT cloudSpecsS::sayF( tin0S& tin0P , etherC& etherP )

}
    }
        }
            break ;
            etherP.delF( tin0P , psttv ) ;
            thirdC::c_strcpyIF( tin0P , ppostv[ offk ] , T(psttv) ) ;
            etherP.querySettingF( tin0P , psttv , tPrefix + *pptKey[offk] ) ; ___( psttv ) ;
            ZE( strokeS* , psttv ) ;
        {
        if( !*ppostv[ offk ] && !etherP.strCompareF( tin0P , psttShortKeyP , (strokeS*)*pptKey[ offk ] ) )
    {
    for( countT offk = 0 ; offk < sizeof pptKey / sizeof pptKey[ 0 ] ; offk ++ )

    } ;
        postRenameToHash      ,
        postLike              ,
        postWaitStepRemainder ,
        postWaitStepModulo    ,
        postGhost             ,
        postAllOrNone         ,
        postNapTocks          ,
        postNetwork           ,
        postMaster            ,
        postDelTries          ,
        postDelete            ,
        postUser              ,
        postRemote            ,
        postPassword          ,
        postLocal             ,
        postIfDiffer          ,
        postId                ,
        postDesire            ,
        postBuilding          ,
    {
    osTextT* ppostv[] =

    } ;
        &tLike              ,
        &tWaitStepRemainder ,
        &tWaitStepModulo    ,
        &tGhost             ,
        &tAllOrNone         ,
        &tNapTocks          ,
        &tNetwork           ,
        &tMaster            ,
        &tDelTries          ,
        &tDelete            ,
        &tUser              ,
        &tRemote            ,
        &tPassword          ,
        &tLocal             ,
        &tIfDiffer          ,
        &tId                ,
        &tDesire            ,
        &tBuilding          ,
    {
    textC* pptKey[] =

    TN( tLike              , "like"              ) ;
    TN( tWaitStepRemainder , "waitstepremainder" ) ;
    TN( tWaitStepModulo    , "waitstepmodulo"    ) ;
    TN( tGhost             , "ghost"             ) ;
    TN( tAllOrNone         , "allornone"         ) ;
    TN( tNapTocks          , "naptocks"          ) ;
    TN( tNetwork           , "network"           ) ;
    TN( tMaster            , "master"            ) ;
    TN( tDelTries          , "delete.tries"      ) ;
    TN( tDelete            , "delete"            ) ;
    TN( tUser              , "user"              ) ;
    TN( tRemote            , "remote"            ) ;
    TN( tPassword          , "password"          ) ;
    TN( tLocal             , "local"             ) ;
    TN( tIfDiffer          , "ifdiffer"          ) ;
    TN( tId                , "id"                ) ;
    TN( tDesire            , "desire"            ) ;
    TN( tBuilding          , "building"          ) ;

    TN( tPrefix    , "" ) ; tPrefix = T("!cloud.")+T(psttCloudP)+T(".") ;
{
voidT cloudSpecsS::setF( tin0S& tin0P , etherC& etherP , const strokeS* const psttCloudP , const strokeS* const psttShortKeyP )

}
    if( postRenameToHashP      ) thirdC::c_strcpyIF( tin0P , postRenameToHash      , postRenameToHashP      ) ;
    if( postLikeP              ) thirdC::c_strcpyIF( tin0P , postLike              , postLikeP              ) ;
    if( postWaitStepRemainderP ) thirdC::c_strcpyIF( tin0P , postWaitStepRemainder , postWaitStepRemainderP ) ;
    if( postWaitStepModuloP    ) thirdC::c_strcpyIF( tin0P , postWaitStepModulo    , postWaitStepModuloP    ) ;
    if( postGhostP             ) thirdC::c_strcpyIF( tin0P , postGhost             , postGhostP             ) ;
    if( postAllOrNoneP         ) thirdC::c_strcpyIF( tin0P , postAllOrNone         , postAllOrNoneP         ) ;
    if( postNapTocksP          ) thirdC::c_strcpyIF( tin0P , postNapTocks          , postNapTocksP          ) ;
    if( postNetworkP           ) thirdC::c_strcpyIF( tin0P , postNetwork           , postNetworkP           ) ;
    if( postMasterP            ) thirdC::c_strcpyIF( tin0P , postMaster            , postMasterP            ) ;
    if( postDelTriesP          ) thirdC::c_strcpyIF( tin0P , postDelTries          , postDelTriesP          ) ;
    if( postDeleteP            ) thirdC::c_strcpyIF( tin0P , postDelete            , postDeleteP            ) ;
    if( postUserP              ) thirdC::c_strcpyIF( tin0P , postUser              , postUserP              ) ;
    if( postRemoteP            ) thirdC::c_strcpyIF( tin0P , postRemote            , postRemoteP            ) ;
    if( postPasswordP          ) thirdC::c_strcpyIF( tin0P , postPassword          , postPasswordP          ) ;
    if( postLocalP             ) thirdC::c_strcpyIF( tin0P , postLocal             , postLocalP             ) ;
    if( postIfDifferP          ) thirdC::c_strcpyIF( tin0P , postIfDiffer          , postIfDifferP          ) ;
    if( postIdP                ) thirdC::c_strcpyIF( tin0P , postId                , postIdP                ) ;
    if( postDesireP            ) thirdC::c_strcpyIF( tin0P , postDesire            , postDesireP            ) ;
    if( postBuildingP          ) thirdC::c_strcpyIF( tin0P , postBuilding          , postBuildingP          ) ;

    TN( tName , psttNameP ) ; thirdC::c_strcpyIF( tin0P , postName , tName ) ;
    thirdC::c_memsetIF( tin0P , (byteT*)this , sizeof *this ) ;
{
cloudSpecsS::cloudSpecsS( tin0S& tin0P , etherC& etherP , const strokeS* const psttNameP , const osTextT* const postBuildingP , const osTextT* const postDesireP , const osTextT* const postIdP , const osTextT* const postIfDifferP , const osTextT* const postLocalP , const osTextT* const postPasswordP , const osTextT* const postRemoteP , const osTextT* const postUserP , const osTextT* const postDeleteP , const osTextT* const postDelTriesP , const osTextT* const postMasterP , const osTextT* const postNetworkP , const osTextT* const postNapTocksP , const osTextT* const postAllOrNoneP , const osTextT* const postGhostP , const osTextT* const postWaitStepModuloP , const osTextT* const postWaitStepRemainderP , const osTextT* const postLikeP , const osTextT* const postRenameToHashP )

}
    TN( tName , psttNameP ) ; thirdC::c_strcpyIF( tin0P , postName , tName ) ;
    thirdC::c_memsetIF( tin0P , (byteT*)this , sizeof *this ) ;
{
cloudSpecsS::cloudSpecsS( tin0S& tin0P , etherC& etherP , const strokeS* const psttNameP )

NEWdELcLASS( 1 , cloudSpecsS ) ;

;
}
    voidT sayF( tin0S& tin0P , etherC& etherP ) ;
    voidT setF( tin0S& tin0P , etherC& etherP , const strokeS* const psttCloudP , const strokeS* const psttShortKeyP ) ;
    cloudSpecsS( tin0S& tin0P , etherC& etherP , const strokeS* const psttNameP , const osTextT* const postBuildingP , const osTextT* const postDesireP , const osTextT* const postIdP , const osTextT* const postIfDifferP , const osTextT* const postLocalP , const osTextT* const postPasswordP , const osTextT* const postRemoteP , const osTextT* const postUserP , const osTextT* const postDeleteP , const osTextT* const postDelTriesP , const osTextT* const postMasterP , const osTextT* const postNetworkP , const osTextT* const postNapTocksP , const osTextT* const postAllOrNoneP , const osTextT* const postGhostP , const osTextT* const postWaitStepModuloP , const osTextT* const postWaitStepRemainderP , const osTextT* const postLikeP , const osTextT* const postRenameToHashP ) ;
    cloudSpecsS( tin0S& tin0P , etherC& etherP , const strokeS* const psttNameP ) ;
    NEWdELcLASSpROTOS ;

    osTextT  postRenameToHash     [ TUCK ] ;
    osTextT  postLike             [ TUCK ] ;
    osTextT  postWaitStepRemainder[ TUCK ] ;
    osTextT  postWaitStepModulo   [ TUCK ] ;
    osTextT  postGhost            [ TUCK ] ;
    osTextT  postAllOrNone        [ TUCK ] ;
    osTextT  postNapTocks         [ TUCK ] ;
    osTextT  postNetwork          [ TUCK ] ;
    osTextT  postMaster           [ TUCK ] ;
    osTextT  postDelTries         [ TUCK ] ;
    osTextT  postDelete           [ TUCK ] ;
    osTextT  postUser             [ TUCK ] ;
    osTextT  postRemote           [ TUCK ] ;
    osTextT  postPassword         [ TUCK ] ;
    osTextT  postName             [ TUCK ] ;
    osTextT  postLocal            [ TUCK ] ;
    osTextT  postIfDiffer         [ TUCK ] ;
    osTextT  postId               [ TUCK ] ;
    osTextT  postDesire           [ TUCK ] ;
    osTextT  postBuilding         [ TUCK ] ;
{
struct cloudSpecsS

/*1*/WAKEsHOWtEXT( "was.scratch.4.archived.20180508@1202.ifcIDaDAM_CLOUD" )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

