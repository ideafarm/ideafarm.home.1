
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tinBaseP ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tinBaseP , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    #endif

        }
            }
                ++ s ; ether.osSleepF( tinBaseP , TOCK * 0x10 ) ;
                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
            {

            //LOGrAW3( "ifcIDaDAM_HOMEfLAGS [home.flags]: " , home.flags , "\r\n" ) ;

            //((tinFullS&)tinBaseP).zEtScratch->delF( tinBaseP , psttRoster ) ;
            //rosterF( tinBaseP , *((tinFullS&)tinBaseP).zEtScratch , psttRoster ) ; ___( psttRoster ) ;
            //ZE( strokeS* , psttRoster ) ;

            }
                while( flagsOld != setIfEqualsAM( home.flags , flagsNew , flagsOld ) ) ;
                }
                    flagsNew = flagsOld | flHOMEs_VERSIONrEFUSED ;
                    flagsOld = home.flags ;
                {
                do
                ZE( flagsT , flagsNew ) ;
                ZE( flagsT , flagsOld ) ;

                etThread.traceF( tinBaseP , T("error:  IPDOS (tm) on this computer is stale.  please obtain a fresh (current) copy") ) ;
            {
            if( bDnsRefusedVersionF( tinBaseP , tVersionMe ) )

            //OLD PRODUCTION: if( bOkDnsValueF( tinBaseP , tTime ) || bOkDnsValueF( tinBaseP , tGoogle ) ) flagsNew |= flHOMEs_ONLINE ;

            }
                while( flagsOld != setIfEqualsAM( home.flags , flagsNew , flagsOld ) ) ;
                }
                    flagsNew = flagsOld | flHOMEs_ONLINE ;
                    flagsOld = home.flags ;
                {
                do
                ZE( flagsT , flagsNew ) ;
                ZE( flagsT , flagsOld ) ;
            {
            if( bOkDnsValueF( tinBaseP , tIdeafarm ) )

            //tmWatchF WILL QUIT IF IT EVER SEES THE flHOMEs_VERSIONrEFUSED FLAG
        {
        while( !etThread && !ether )
        etherC& etRock = etherC::etRockIF( tinBaseP ) ;
        TN( tTimeHttp , "www.time.gov//http//" ) ;
        TN( tGoogleHttp , "www.google.com//http//" ) ;
        TN( tRosterHttp  , "www.ideafarm.com//http//" ) ;
        TN( tTime , "www.time.gov" ) ;
        TN( tGoogle , "www.google.com" ) ;
        TN( tRoster  , "www.ideafarm.com" ) ;
        TN( tIdeafarm  , "ideafarm.com" ) ;

          TN( tVersionMe , "20141209.1044.version.ipdos.ideafarm.com" ) ; //PRODUCTION
        //TN( tVersionMe , "20141115.1852.version.ipdos.ideafarm.com" ) ;
        //TN( tVersionMe , "1.version.ipdos.ideafarm.com" ) ;
        //TN( tVersionMe , "2.version.ipdos.ideafarm.com" ) ;
        //ENABLE WO OF THESE LINES TO VERIFY THAT THE IPDOS SYSTEM SHUTS DOWN AS SOON AS THE COMPUTER IS ONLINE

        THREADmODE2oN( flTHREADmODE2_QUIETiMPOTENCE )
        etThread.osThreadSwitchingDesireF( tinBaseP , ifcTHREADpRIORITY_LAZIEST ) ;

        if( etThread.diskIdF( tinBaseP , T("///c") ) == IDcOMPUTER_IPDOSmASTERcRAFTWORK ) etThread.osThreadF( TaRG1( tmUpd8PaidHListF ) ) ; //U:: USE A SETTINGS FILE
        //U:: 20200920@1855: THIS SHOULD BE DONE BY factory3-5, AND IT SHOULD BE DONE IN A WAY THAT AVOIDS SPF (SINGLE POINT OF FAILURE) SO THAT IT WORKS EVEN IF ALL BUT WO FACTORY IS DOWN

        etThread.osThreadF( TaRG1( tmGetIdHomeF ) ) ;

    #if defined( NEVERdEFINED )

    }
        etherC::loafIF( tinBaseP ) ;
        ether.ifcHireF( tinBaseP , T("HOMEfLAGS") , ifcIDaDAM_PISS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; //MUST HIRE PISS EVEN IF NO PAID PRIVILEGES IN ORDER TO ALLOW USER TO UPDATE SETTINGS

        while( flagsOld != setIfEqualsAM( home.flags , flagsNew , flagsOld ) ) ;
        }
            flagsNew = flagsOld | flHOMEs_ONLINE | flHOMEs_PAIDpRIVILEGES ;
            flagsOld = home.flags ;
        {
        do
        ZE( flagsT , flagsNew ) ;
        ZE( flagsT , flagsOld ) ;

        homeS& home = homeS::homeIF() ;
    {
    //20211023@1116: COMPLETELY DISABLE THIS ADAM PENDING REWRITE (PLAN IS TO MIGRATE ALL FUNCTIONALITY TO IPDOS UDP FILES) (THE REGISTRY HAS A SECURITY VULNERABILITY SO CANNOT BE USED)
{
if( pTaskP )
TASK( tmWorkF )

DONE( tmUpd8PaidHListF )

}
    ether.osSleepF( tinBaseP , TOCK << 4 ) ;
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    //etThread.traceF( tinBaseP , T("napping for 01 tock") ) ;

    //etThread.traceF( tinBaseP , T("cHomes: ")+TF2(cHomes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    
    }
        while( ~hFind && !ether && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                etThread.delF( tinBaseP , psttShorter ) ;
                etThread.fileWriteF( tinBaseP , fiPaid , tOut , tOut.csF( tinBaseP ) ) ;
                TN( tOut , psttShorter ) ; tOut += tcr ;
        
                etThread.delF( tinBaseP , psttShort ) ;
                etThread.strSubstringF( tinBaseP , psttShorter , idf , idl , psttShort ) ; ___( psttShorter ) ;
                countT idl = psttShort->idAdam - 9 ; // REMOVE ".home.txt"
                countT idf = 1 ;
                ZE( strokeS* , psttShorter ) ;
        
                if( !( cHomes % TUCK ) ) etThread.traceF( tinBaseP , psttShort ) ;
        
                etThread.delF( tinBaseP , psttPath ) ;
                ___( psttShort ) ;
                ___( psttPath ) ;
                etThread.strBisectF( tinBaseP , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttPath ) ;
            {
            if( pInfo && pInfo->psttIfoName && pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam != '/' )
            etThread.diskFindFileOrDirF( tinBaseP , pInfo , hFind , fnLike.pathF() , &pat ) ; ___( pInfo ) ;
            ZE( infoFileS* , pInfo ) ;
        
            cHomes ++ ;
        {
        do
        handleC hFind( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        TN( tSlash , "/" ) ;
        TN( tcr , "\r\n" ) ;
        fileC fiPaid( tinBaseP , (strokeS*)T("///ideafarm/tmp/ipdos.home.privileges/!paid.txt") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;

        patternC pat( tinBaseP , etThread , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        fileNameC fnLike( tinBaseP , etThread , tLike ) ;
    {
    if( etThread.diskFileExistsF( tinBaseP , tLike ) )
    TN( tLike , "///ideafarm/tmp/ipdos.home.registry/*.home.txt" ) ;
    ZE( countT , cHomes ) ;
{
while( !ether && !POOP )
etherC& etRock = etherC::etRockIF( tinBaseP ) ;

TASK( tmUpd8PaidHListF )

DONE( tmGetIdHomeF )

}
    }
        }
            ether.osSleepF( tinBaseP , bPaid ? TICK << 7 : TOCK << 4 ) ;
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
            etThread.traceF( tinBaseP , T(bPaid?"home privileges check / napping for 01 tick before checking again":"home privileges check / napping for 01 tock before checking again") ) ;

            }
                }
                    etThread.delF( tinBaseP , postPaidList ) ;
                    }
                        }
                            ether.ifcHireF( tinBaseP , T("HOMEfLAGS") , ifcIDaDAM_PISS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; //MUST HIRE PISS EVEN IF NO PAID PRIVILEGES IN ORDER TO ALLOW USER TO UPDATE SETTINGS
                            bPissHired = 1 ;
                        {
                        if( !bPissHired )

                        }
                            while( flagsOld != setIfEqualsAM( home.flags , flagsNew , flagsOld ) ) ;
                            }
                                flagsNew = flagsOld & ~( F(flHOMEs_PAIDpRIVILEGES) ) ;
                                flagsOld = home.flags ;
                            {
                            do
                            ZE( flagsT , flagsNew ) ;
                            ZE( flagsT , flagsOld ) ;

                            }
                                etThread.traceF( tinBaseP , T("this home does NOT have paid privileges") ) ;
                                bSaidPaid    = 0 ;
                                bSaidNotPaid = 1 ;
                            {
                            if( !bSaidNotPaid )
                        {
                        else
                        }
                            //break ;
                            //ether.ifcHireF( tinBaseP , T("HOMEfLAGS") , ifcIDaDAM_PISS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                            //TO SUPPRESS CONTINUED CHECKING, HIRE AND BREAK HERE

                            while( flagsOld != setIfEqualsAM( home.flags , flagsNew , flagsOld ) ) ;
                            }
                                flagsNew = flagsOld | flHOMEs_PAIDpRIVILEGES ;
                                flagsOld = home.flags ;
                            {
                            do
                            ZE( flagsT , flagsNew ) ;
                            ZE( flagsT , flagsOld ) ;

                            bPaid = 1 ;

                            }
                                etThread.traceF( tinBaseP , T("this home has paid privileges") ) ;
                                bSaidNotPaid = 0 ;
                                bSaidPaid    = 1 ;
                            {
                            if( !bSaidPaid )
                        {
                        if( thirdC::c_strstrIF( tinBaseP , postPaidList , home.postIdHomeGlobal ) )

                        LOGrAW( "\r\n\r\n" ) ;
                        LOGrAW( postPaidList ) ;
                        LOGrAW( "\r\n\r\npostPaidList:\r\n" ) ;
                        LOGrAW( home.postIdHomeGlobal ) ;
                        LOGrAW( "\r\nhome.postIdHomeGlobal:\r\n" ) ;
                    {
                    else if( postPaidList && costPaidList )
                    }
                        etThread.traceF( tinBaseP , T("home privileges check / could not download \"")+tShort+T("\" from \"")+tRemoteHomePrivileges+T("\" / will nap for 01 tock and then retry") ) ;
                        POOPR
                    {
                    if( POOP )
                    cloud.pullFileF( tinBaseP , postPaidList , costPaidList , tRemoteHomePrivileges , tShort , 1 ) ; ___( postPaidList ) ;
                    ZE( countT , costPaidList ) ;
                    ZE( byteT* , postPaidList ) ;
                {
                else
                }
                    etThread.traceF( tinBaseP , T("home privileges check / cannot connect") ) ;
                    POOPR
                {
                if( POOP )

                cloudC cloud( tinBaseP , tName , ifcIDdOcLOUDiFdIFFER_NOTHING , flCLOUDc_NOcOPY | flCLOUDc_DOnOTlOADlOCAL | flCLOUDc_DOnOTlOADrEMOTE , ifcIDcLOUD_RACKSPACE , tBuilding , tUserPrivileges , tPasswordPrivileges , tRemoteHomePrivileges ) ;
                etThread.traceF( tinBaseP , T("querying privileges") ) ;
            {
            else
            }
                }
                    ether.ifcHireF( tinBaseP , T("HOMEfLAGS") , ifcIDaDAM_PISS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; //MUST HIRE PISS EVEN IF NO PAID PRIVILEGES IN ORDER TO ALLOW USER TO UPDATE SETTINGS
                    etThread.traceF( tinBaseP , T("hiring PISS") ) ;
                    bPissHired = 1 ;
                {
                if( !bPissHired )

                while( flagsOld != setIfEqualsAM( home.flags , flagsNew , flagsOld ) ) ;
                }
                    flagsNew = flagsOld | flHOMEs_PAIDpRIVILEGES ;
                    flagsOld = home.flags ;
                {
                do
                ZE( flagsT , flagsNew ) ;
                ZE( flagsT , flagsOld ) ;

                bPaid = 1 ;
                etThread.traceF( tinBaseP , T("home privileges check / this is IDcOMPUTER_IPDOSmASTERcRAFTWORK so has paid privileges") ) ;
            {
            if( idComputer == IDcOMPUTER_IPDOSmASTERcRAFTWORK )
            etThread.traceF( tinBaseP , T("[idComputer,idComputerCraftwork]:    ")+TF2(idComputer,flFORMAT_NObIGITvALUES|flFORMAT_FILLzE|flFORMAT_FOREIGN)+tb4+TF2(IDcOMPUTER_IPDOSmASTERcRAFTWORK,flFORMAT_NObIGITvALUES|flFORMAT_FILLzE|flFORMAT_FOREIGN) ) ;
            countT idComputer = etThread.diskIdF( tinBaseP , T("///c") ) ;

            ZE( boolT , bPaid ) ;
        {
        while( !ether && !POOP )
        etherC& etRock = etherC::etRockIF( tinBaseP ) ;
        TN( tb4 , "    " ) ;
        TN( tShort , "!paid.txt" ) ;
        ZE( boolT , bSaidPaid ) ;
        ZE( boolT , bSaidNotPaid ) ;

        SCOOPS
    {
    IFsCRATCH
    //INSPECT !paid.txt TO DISCOVER WHETHER home.postIdHomeGlobal IS LISTED
{
if( bApproved )

}
    etThread.delF( tinBaseP , psttArbitraryUniquifier1 ) ;
    etThread.delF( tinBaseP , psttIdHomeDisk           ) ;
    etThread.delF( tinBaseP , psttIdComputer           ) ;
    etThread.delF( tinBaseP , psttUserName             ) ;
    etThread.delF( tinBaseP , psttUserEmail            ) ;
    
    }
        }
            }
                }
                    ether.osSleepF( tinBaseP , TOCK << 4 ) ;
                    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                    etThread.traceF( tinBaseP , T("home registration check / napping for 01 tock before retrying") ) ;
                {
                else if( !bUploadedOk )
                if( bDone ) break ;

                }
                    etThread.delF( tinBaseP , postHe ) ;
                    }
                        LOGrAW( postHe ) ;

                        }
                            bDone = 1 ;
                            etThread.traceF( tinBaseP , T("file name collision:  please stop IPDOS (tm), edit your settings file to change the value of the arbitrary.uniquifier.1 setting, and then start IPDOS (tm)") ) ;
                        {
                        else
                        }
                            thirdC::c_strcpyIF( tinBaseP , home.postIdHomeGlobal , tPostIdHomeGlobal ) ;
                            bApproved = bDone = 1 ;
                        {
                        if( costHe == costzMe && !thirdC::c_memcmpIF( tinBaseP , postHe , postzMe , costHe ) )
                    {
                    else if( postHe && costHe )
                    }
                        }
                            etThread.traceF( tinBaseP , T("home registration check / could not upload / will nap for 01 tock and then retry") ) ;
                            POOPR
                        {
                        else
                        if( !POOP ) bUploadedOk = 1 ;

                        cloud.pushFileF( tinBaseP , tRemoteHomeRegistry , tShort , postzMe , costzMe ) ; //U:: cTries = 1

                        etThread.traceF( tinBaseP , T("home registration check / could not download") ) ;

                        POOPR
                    {
                    if( POOP )
                    cloud.pullFileF( tinBaseP , postHe , costHe , tRemoteHomeRegistry , tShort , 1 ) ; ___( postHe ) ;
                    ZE( countT , costHe ) ;
                    ZE( byteT* , postHe ) ;
                    etThread.traceF( tinBaseP , T("home registration file: ")+tShort ) ;
                {
                else
                }
                    }
                        ether.ifcHireF( tinBaseP , T("HOMEfLAGS") , ifcIDaDAM_PISS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; // IdeaFarm (tm) Bundle IS FREEWARE WHEN IdeaFarm (tm) ADMINISTRATIVE CLOUD IS NOT VISIBLE (E.G. IF I DIE AND MY RACKSPACE ACCOUNTS ARE CLOSED)
                        bPissHired = 1 ;
                    {
                    if( !bPissHired )

                    etThread.traceF( tinBaseP , T("home registration check / cannot connect") ) ;
                    POOPR
                {
                if( POOP )
                ZE( boolT  , bUploadedOk ) ;
    
                cloudC cloud( tinBaseP , tName , ifcIDdOcLOUDiFdIFFER_NOTHING , flCLOUDc_NOcOPY | flCLOUDc_DOnOTlOADlOCAL | flCLOUDc_DOnOTlOADrEMOTE , ifcIDcLOUD_RACKSPACE , tBuilding , tUserRegistry , tPasswordRegistry , tRemoteHomeRegistry ) ;
            {
            while( !ether && !POOP && !bDone )
            etherC& etRock = etherC::etRockIF( tinBaseP ) ;
            ZE( boolT , bDone ) ;
    
            SCOOPS
        {
        IFsCRATCH

        }
            psttBuilding = psttUser = psttPassword = psttRemoteHomeRegistry = 0 ;
            etThread.osThreadF( TaRG1( tmWatchIdeafarmF ) , (countT)psttBuilding , (countT)psttUser , (countT)psttPassword , (countT)psttRemoteHomeRegistry ) ;

            etThread.strMakeF( tinBaseP , LF , psttRemoteHomeRegistry , tRemoteHomeRegistry ) ; ___( psttRemoteHomeRegistry ) ;
            etThread.strMakeF( tinBaseP , LF , psttPassword           , tPasswordRegistry           ) ; ___( psttPassword           ) ;
            etThread.strMakeF( tinBaseP , LF , psttUser               , tUserRegistry               ) ; ___( psttUser               ) ;
            etThread.strMakeF( tinBaseP , LF , psttBuilding           , tBuilding           ) ; ___( psttBuilding           ) ;
            ZE( strokeS* , psttRemoteHomeRegistry ) ;
            ZE( strokeS* , psttPassword ) ;
            ZE( strokeS* , psttUser ) ;
            ZE( strokeS* , psttBuilding ) ;
        {

        TN( tShort            , "" ) ; tShort            = tPostIdHomeGlobal+tShortSuffix ;
        TN( tPostIdHomeGlobal , "" ) ; tPostIdHomeGlobal = tEmailCleaned+strokeS('.')+tHash ;
    
        }
            etThread.delF( tinBaseP , psttc ) ;
            tEmailCleaned = T(psttc) ;
    
            }
                etThread.delF( tinBaseP , psttd ) ;
                etThread.strSubstringF( tinBaseP , psttc , idf , idl , psttd ) ; ___( psttc ) ;
                countT idl = costEmailMax ;
                countT idf = 1 ;
                                 psttc = 0 ;
                strokeS* psttd = psttc ;
            {
            if( psttc->idAdam > costEmailMax )

            const countT costEmailMax = COSTiDhOMEgLOBALmAX - COSTpOSThASHmD5 - tShortSuffix.csF( tinBaseP ) - 1 ;
    
            etThread.strReplaceF( tinBaseP , psttc , psttUserEmail , tSmallOld , tn ) ; ___( psttc ) ;
            TN( tn , "" ) ;
            ZE( strokeS* , psttc ) ;
    
            ;
        
                +S2(sa_SSSaNDeND,sc_ccSSS)
                    +S2(sa_SSSoReND,sc_ccSSS)
            
                        +T("az09")
            
                    +S3(sa_SSSoR,sc_ccSSS,sp_SSSfLAGrANGEpAIRS|sp_SSSfLAGnOT)
                +S2(sa_SSSaND,sc_ccSSS)
                T("")
        
            TN( tSmallOld , "" ) ; tSmallOld =
        {
        TN( tShortSuffix , ".home.txt" ) ;
        TN( tEmailCleaned , "" ) ;
    
        }
            etThread.delF( tinBaseP , psttHash ) ;
            tHash = T(psttHash) ;
            hasher.queryStringF( tinBaseP , psttHash ) ; ___( psttHash ) ;
            ZE( strokeS* , psttHash ) ;

            hasher.eatF( tinBaseP , postzMe , costzMe ) ;
            hasherC hasher( tinBaseP , etThread ) ;
        {
        TN( tHash , "" ) ;
   
        //LOGrAW( postzMe ) ;
    
        countT   costzMe = thirdC::c_strlenIF( tinBaseP , postzMe ) ;       // DONE THIS WAY BECAUSE csF() COUNT WILL DIFFER IF SOME STROKES WERE SUPPRESSED WHEN CONVERTING TO osTextT
        osTextT* postzMe = tMe ;
    
        etThread.delF( tinBaseP , psttMe ) ;
        TN( tMe , psttMe ) ;
    
        etThread.strFuseF( tinBaseP , psttMe , tcr ) ;
        etThread.strFuseF( tinBaseP , psttMe , psttArbitraryUniquifier1 ) ;
        etThread.strFuseF( tinBaseP , psttMe , tcr ) ;
        etThread.strFuseF( tinBaseP , psttMe , psttIdHomeDisk ) ;
        etThread.strFuseF( tinBaseP , psttMe , tcr ) ;
        etThread.strFuseF( tinBaseP , psttMe , psttIdComputer ) ;
        etThread.strFuseF( tinBaseP , psttMe , tcr ) ;
        etThread.strFuseF( tinBaseP , psttMe , psttUserName ) ;
        etThread.strFuseF( tinBaseP , psttMe , tcr ) ;
        etThread.strFuseF( tinBaseP , psttMe , psttUserEmail ) ;
        etThread.strFuseF( tinBaseP , psttMe , T("ideafarm.com\r\nIPDOS (tm) - IdeaFarm (tm) Piggyback Distributed Operating System\r\nHome Folder Registration\r\nformat:1\r\n") ) ;
    
        TN( tcr , "\r\n" ) ;
    
        ) ; ___( psttMe ) ;
    
            TUCK
            psttArbitraryUniquifier1->idAdam                        +
            psttIdHomeDisk->idAdam                                  +
            psttIdComputer->idAdam                                  +
            psttUserName->idAdam                                    +
            psttUserEmail->idAdam                                   +
    
        etThread.strMakeF( tinBaseP , LF , psttMe , 0 , 
        ZE( strokeS* , psttMe ) ;

        thirdC::c_strcpyIF( tinBaseP , home.postIdHomeGlobal , "!registering" ) ;
    {
    else
    }
        ether.ifcHireF( tinBaseP , T("HOMEfLAGS") , ifcIDaDAM_PISS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; //MUST HIRE PISS EVEN IF NO PAID PRIVILEGES IN ORDER TO ALLOW USER TO UPDATE SETTINGS
        thirdC::c_strcpyIF( tinBaseP , home.postIdHomeGlobal , "!settingsAreInvalid" ) ;
    {
    if( bSettingsAreBad )

    }
             if( !psttArbitraryUniquifier1 ) { bSettingsAreBad |= 1 ; etThread.traceF( tinBaseP , (strokeS*)( T("invalid setting: the ")+tSuffixArbitraryUniquifier1+T(" setting is missing (it should normally be set to \"\", the null string)") ) ) ; }

        else if( !psttUserName->idAdam     ) { bSettingsAreBad |= 1 ; etThread.traceF( tinBaseP , (strokeS*)( T("invalid setting: the ")+tSuffixPrimaryEndUserName+T(" setting must be at least 1 character"                                     ) ) ) ; }
             if( !psttUserName             ) { bSettingsAreBad |= 1 ; etThread.traceF( tinBaseP , (strokeS*)( T("invalid setting: the ")+tSuffixPrimaryEndUserName+T(" setting is missing"                                                       ) ) ) ; }

        else if( !psttUserEmail->idAdam    ) { bSettingsAreBad |= 1 ; etThread.traceF( tinBaseP , (strokeS*)( T("invalid setting: the ")+tSuffixPrimaryEndUserEmail+T(" setting must be at least 1 character"                                    ) ) ) ; }
             if( !psttUserEmail            ) { bSettingsAreBad |= 1 ; etThread.traceF( tinBaseP , (strokeS*)( T("invalid setting: the ")+tSuffixPrimaryEndUserEmail+T(" setting is missing"                                                      ) ) ) ; }
    {
    ZE( boolT , bSettingsAreBad ) ;

    etThread.strFromF( tinBaseP , psttIdHomeDisk , idHomeDisk , flFORMAT_NObIGITvALUES | flFORMAT_UNSIGNED | flFORMAT_FILLzE , 2 * sizeof( countT ) ) ; ___( psttIdHomeDisk ) ;
    ZE( strokeS* , psttIdHomeDisk ) ;
    countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;
    
    etThread.strFromF( tinBaseP , psttIdComputer , idComputer , flFORMAT_NObIGITvALUES | flFORMAT_UNSIGNED | flFORMAT_FILLzE , 2 * sizeof( countT ) ) ; ___( psttIdComputer ) ;
    ZE( strokeS* , psttIdComputer ) ;
    countT idComputer = etThread.diskIdF( tinBaseP , T("///c") ) ;

    if( psttUserEmail ) { etThread.strConvertToLowerCaseF( tinBaseP , psttUserEmail ) ; ___( psttUserEmail ) ; }
    
    ZE( strokeS* , psttArbitraryUniquifier1 ) ; etThread.querySettingF( tinBaseP , psttArbitraryUniquifier1 , tSettingPrefix+tSuffixArbitraryUniquifier1 ) ; ___( psttArbitraryUniquifier1 ) ;
    ZE( strokeS* , psttUserName             ) ; etThread.querySettingF( tinBaseP , psttUserName             , tSettingPrefix+tSuffixPrimaryEndUserName   ) ; ___( psttUserName             ) ;
    ZE( strokeS* , psttUserEmail            ) ; etThread.querySettingF( tinBaseP , psttUserEmail            , tSettingPrefix+tSuffixPrimaryEndUserEmail  ) ; ___( psttUserEmail            ) ;

    TN( tSuffixArbitraryUniquifier1 , "arbitrary.uniquifier.1" ) ;
    TN( tSuffixPrimaryEndUserName   , "primary.end.user.name"  ) ;
    TN( tSuffixPrimaryEndUserEmail  , "primary.end.user.email" ) ;
    TN( tSettingPrefix , "!ipdos." ) ;

    thirdC::c_strcpyIF( tinBaseP , home.postIdHomeGlobal , "!queryingSettings" ) ;
{
ZE( boolT , bPissHired ) ;
ZE( boolT , bApproved ) ;

TN( tRemoteHomePrivileges , "ipdos.home.privileges" ) ;
TN( tRemoteHomeRegistry , "ipdos.home.registry" ) ;

TN( tPasswordPrivileges , "749b4eaeb75c46ac86d12d6e8d059b09" ) ;  //THIS IS NOT SECRET
TN( tUserPrivileges , "ipdos.01" ) ;

//secretF( tinBaseP , etThread , tUserRegistry , tPasswordRegistry ) ;
TN( tPasswordRegistry , "d1fd7a5fea5b42018c98a434b42a56af" ) ;  //THIS IS NOT SECRET
TN( tUserRegistry , "ipdos.public2" ) ;

TN( tBuilding , "IAD" ) ;
}
    etThread.delF( tinBaseP , psttu ) ;
    tName = T(psttu) ;
    etThread.strUniqueF( tinBaseP , psttu ) ; ___( psttu ) ;
    ZE( strokeS* , psttu ) ;
{
TN( tName , "" ) ;

homeS& home = homeS::homeIF() ;

TASK( tmGetIdHomeF )

DONE( tmWatchIdeafarmF )
}
    etThread.delF( tinBaseP , psttRemoteHomeRegistryP ) ;
    etThread.delF( tinBaseP , psttPasswordP           ) ;
    etThread.delF( tinBaseP , psttUserP               ) ;
    etThread.delF( tinBaseP , psttBuildingP           ) ;
    }
        }
            //etRock.traceF( tinBaseP , T("tmWatchIdeafarmF / loop /-") ) ;
            ++ s ; ether.osSleepF( tinBaseP , TICK << 7 ) ;                                         //20181110@1429: "TOCK << 4" -> "TICK << 7" TO REDUCE BANDWIDTH CHARGES; MIGHT NEED TO MAKE THIS MORE FREQUENT WHEN HAVE NEW USERS
            //etRock.traceF( tinBaseP , T("tmWatchIdeafarmF / loop / napping for tick << 7") ) ;

            }
                //etRock.traceF( tinBaseP , T("tmWatchIdeafarmF / loop /0") ) ;
                }
                    }
                        if( ii > TUCK ) etRock.traceF( tinBaseP , tStuck2 ) ;
                        if( flagso == setIfEqualsAM( home.flags , flagsn , flagso ) ) break ;
                        flagsT flagsn = flagso & ~(F(flHOMEs_IDEAFARMcLOUDiSgONE)) ;
                        flagsT flagso = home.flags ;
                    {
                    if( F(home.flags) & flHOMEs_IDEAFARMcLOUDiSgONE ) for( countT ii = 0 ;; ii ++ )

                    //etRock.traceF( tinBaseP , T("tmWatchIdeafarmF / connected aok to the IdeaFarm (tm) accounting cloud") ) ;
                {
                else
                }
                    }
                        if( ii > TUCK ) etRock.traceF( tinBaseP , tStuck1 ) ;
                        if( flagso == setIfEqualsAM( home.flags , flagsn , flagso ) ) break ;
                        flagsT flagsn = flagso | flHOMEs_IDEAFARMcLOUDiSgONE ;
                        flagsT flagso = home.flags ;
                    {
                    if( !( F(home.flags) & flHOMEs_IDEAFARMcLOUDiSgONE ) ) for( countT ii = 0 ;; ii ++ )

                    etRock.traceF( tinBaseP , T("tmWatchIdeafarmF / the IdeaFarm (tm) accounting cloud is not visible") ) ;
                    POOPR
                {
                if( POOP )
                TN( tStuck2 , "setIfEqualsAM is stuck 2" ) ;
                TN( tStuck1 , "setIfEqualsAM is stuck 1" ) ;
        
                //etRock.traceF( tinBaseP , T("tmWatchIdeafarmF / loop /1") ) ;
                cloudC cloud( tinBaseP , tName , ifcIDdOcLOUDiFdIFFER_NOTHING , flCLOUDc_NOcOPY | flCLOUDc_DOnOTlOADlOCAL | flCLOUDc_DOnOTlOADrEMOTE , ifcIDcLOUD_RACKSPACE , psttBuildingP , psttUserP , psttPasswordP , psttRemoteHomeRegistryP ) ;
                //etRock.traceF( tinBaseP , T("tmWatchIdeafarmF / loop /2") ) ;
            {

            }
                etThread.delF( tinBaseP , psttu ) ;
                tName = T(psttu) ;
                etThread.strUniqueF( tinBaseP , psttu ) ; ___( psttu ) ;
                ZE( strokeS* , psttu ) ;
            {
            TN( tName , "" ) ;

            //etRock.traceF( tinBaseP , T("tmWatchIdeafarmF / loop /+") ) ;
        {
        while( !ether && !etThread && !POOP )
        etherC& etRock = etherC::etRockIF( tinBaseP ) ;
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

        SCOOPS
    {
    IFsCRATCH

    etherC& etRock = etherC::etRockIF( tinBaseP ) ;
    homeS& home = homeS::homeIF() ;

    strokeS* psttRemoteHomeRegistryP = (strokeS*)pTaskP->c4 ;
    strokeS* psttPasswordP           = (strokeS*)pTaskP->c3 ;
    strokeS* psttUserP               = (strokeS*)pTaskP->c2 ;
    strokeS* psttBuildingP           = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmWatchIdeafarmF )

#endif

}
    }
        tPasswordP += T(postWo) ;
        osTextT postWo[] = { (osTextT)( pcPassword[ offi ] SUBfLAK ) , 0 } ;
    {
    for( countT offi = 0 ; offi < sizeof pcPassword / sizeof pcPassword[ 0 ] ; offi ++ )

    }
        tUserP += T(postWo) ;
        osTextT postWo[] = { (osTextT)( pcUser[ offi ] SUBfLAK ) , 0 } ;
    {
    for( countT offi = 0 ; offi < sizeof pcUser / sizeof pcUser[ 0 ] ; offi ++ )

    countT pcPassword[] = { '8' ADDfLAK , 'd' ADDfLAK , 'b' ADDfLAK , 'b' ADDfLAK , '3' ADDfLAK , '6' ADDfLAK , 'b' ADDfLAK , 'a' ADDfLAK , '0' ADDfLAK , '3' ADDfLAK , 'd' ADDfLAK , 'a' ADDfLAK , '4' ADDfLAK , '0' ADDfLAK , '0' ADDfLAK , 'c' ADDfLAK , '8' ADDfLAK , 'f' ADDfLAK , 'c' ADDfLAK , 'f' ADDfLAK , '3' ADDfLAK , '6' ADDfLAK , '4' ADDfLAK , 'a' ADDfLAK , 'b' ADDfLAK , '9' ADDfLAK , 'c' ADDfLAK , 'e' ADDfLAK , 'e' ADDfLAK , 'f' ADDfLAK , 'b' ADDfLAK , '5' ADDfLAK } ;
    countT pcUser[]     = { 'i' ADDfLAK , 'p' ADDfLAK , 'd' ADDfLAK , 'o' ADDfLAK , 's' ADDfLAK , '.' ADDfLAK , '0' ADDfLAK , '1' ADDfLAK } ;
{
voidT secretF( tinBaseS& tinBaseP , etherC& etherP , textC& tUserP , textC& tPasswordP )

#if defined( NEVERdEFINED )
//20210224@1610: THIS IS OBSOLETE NOW THAT CODE IS OPEN SOURCE

#define SUBfLAK & ~0x84c73d00
#define ADDfLAK |  0x84c73d00

}
    }
        }
            ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , psttP ) ;
            POOPR
        {
        if( POOP )
    
        ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , psttAll ) ;
        }
            ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , psttSection ) ;
            else                    ((tinFullS&)tinBaseP).pEtScratch->strokeF( tinBaseP , T("<<<<")+T(psttSection)+T(">>>>") ) ;
            if( cSkip && cSkip -- ) ;
            ((tinFullS&)tinBaseP).pEtScratch->strSubstringF( tinBaseP , psttSection , idf , sttq , T("<hr>") , psttAll ) ; ___( psttSection ) ;
            ZE( strokeS* , psttSection ) ;
        {
        while( idf && !POOP )
        etherC& etRock = etherC::etRockIF( tinBaseP ) ;
        countT cSkip = 1 ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;
    
        ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , pbAll  ) ;
        ((tinFullS&)tinBaseP).pEtScratch->strMakeF( tinBaseP , LF , psttAll , T(pbAll) ) ; ___( psttAll ) ;
        ZE( strokeS* , psttAll ) ;
    
        ((tinFullS&)tinBaseP).pEtScratch->boxPutF( tinBaseP , T("///d/tmp.ideafarm.txt") , pbAll , cbAll ) ;
    
        ((tinFullS&)tinBaseP).pEtScratch->boxGetShadowF( tinBaseP , pbAll , cbAll , tRosterHttp ) ; ___( pbAll  ) ;
        ZE( countT , cbAll ) ;
        ZE( byteT* , pbAll  ) ;
        //TN( tRosterHttp  , "www.fuckyourbrain.com//http//index.htm" ) ;
        TN( tRosterHttp  , "www.ideafarm.com//http//index.htm" ) ;
        SCOOPS
    {
    IFsCRATCH
{
voidT rosterF( tinBaseS& tinBaseP , strokeS*& psttP )

}
    return bOk ;
    //LOGrAW3( "bOkHttpPageF [bOk]: " , bOk , "\r\n" ) ;

    }
        else bOk = 1 ;
        }
            //CONoUTrAW( "F" ) ;
            POOPR
        {
        if( POOP )
        ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , pbHome  ) ;
        ((tinFullS&)tinBaseP).pEtScratch->boxGetShadowF( tinBaseP , pbHome  , cbHome  , psttP  ) ; ___( pbHome  ) ;
        ZE( countT , cbHome ) ;
        ZE( byteT* , pbHome  ) ;
        SCOOPS
    {
    IFsCRATCH
    ZE( boolT , bOk ) ;
{
boolT bOkHttpPageF( tinBaseS& tinBaseP , const strokeS* const psttP )

}
    return bRefused ;
    //LOGrAW3( "bDnsRefusedVersionF [bRefused]: " , bRefused , "\r\n" ) ;

    }
        else if( nn.pcId[ 0 ] == 0xff00ff00 ) bRefused = 1 ;
        if( POOP ) POOPR
        nicNameC nn = ((tinFullS&)tinBaseP).pEtScratch->sockNicNameF( tinBaseP , psttP ) ;
        SCOOPS
    {
    IFsCRATCH
    ZE( boolT , bRefused ) ; //VERSION REFUSED FLAG WILL BE SET ONLY IF I GET A POSITIVE DENIAL FROM THE DNS
{
boolT bDnsRefusedVersionF( tinBaseS& tinBaseP , const strokeS* const psttP )

}
    return bOk ;
    //LOGrAW3( "bOkDnsValueF [bOk]: " , bOk , "\r\n" ) ;

    }
        else  bOk = 1 ;
        else if( !nn ) { /*CONoUTrAW( "F" ) ;*/ }
        }
            //CONoUTrAW( "F" ) ;
            POOPR
        {
        if( POOP )
        nicNameC nn = ((tinFullS&)tinBaseP).pEtScratch->sockNicNameF( tinBaseP , psttP ) ;
        SCOOPS
    {
    IFsCRATCH
    ZE( boolT , bOk ) ;
{
boolT bOkDnsValueF( tinBaseS& tinBaseP , const strokeS* const psttP )

/*1*/WAKEhIDE( "ifcIDaDAM_HOMEfLAGS" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

