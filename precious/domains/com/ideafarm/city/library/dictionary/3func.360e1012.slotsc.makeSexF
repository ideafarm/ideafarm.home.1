
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    THREADmODE2rESTORE

    inc02AM( pcTallyOut[ offs ] ) ;
    pGrabNewElt[ offs ].ungrabF( tinP ) ; // -------------------------------------------------------------------------------------------------

    }
        }
            ppSex[ offs ] = pSexNew ;

                                           pPoolContainsMe->pSexLifoConstructed = pSexNew ;
            pSexNew->pSexLifoConstructed = pPoolContainsMe->pSexLifoConstructed           ;

        {
        else if( pSexNew )
        }
            BLAMMO ;                        //20180613@1222: ADDED WITHOUT ANALYSIS
            DELzOMBIE( pSexNew ) ;
        {
        if( pSexNew && (const poopC&)*pSexNew ) // *pSexNew CT FAILED, EITHER BECAUSE IT DETECTED THAT IT CT'D ITSELF RECURSIVELY OR BECAUSE INSUFFICIENT CONTIGUOUS MEMORY IS AVAILABLE

        sexC* pSexNew = new( 0 , tinP , pbzaUse , sizeof( sexC ) ) sexC( tinP , TAG( TAGiDnULL ) , LF , ostoName , expCbDrop , offs , flagsc , idStateSpace , idMemorySpace , pPoolContainsMe ) ;

        if( pbzaUse == (byteT*)ppSex[ offs ] ) { BLAMMO ; }
        byteT* pbzaUse = pbza1 + offs * sizeof( sexC ) ;

        OStEXTCF( ostoName , offs , '0' ) ;
        OStEXTAK( ostoName , ".slotsC.sex." ) ;
        OStEXTA(  ostoName , postName ) ;
        OStEXT(   ostoName , TUCK << 2 )

        const flagsT maskExpSlots  = 1 << offs      ;
        const flagsT maskExpCbDrop = 1 << expCbDrop ;
    {
    if( !ppSex[ offs ] )

    inc02AM( pcTallyIn[ offs ] ) ;
    pGrabNewElt[ offs ].grabF( tinP , TAG( TAGiDnULL ) ) ; // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    countT offs = expSlotsP ;

    if( F(flagsCt) & flSLOTSc_NOTES    ) flagsc |= fliSEXc_NOTES    ;
    if( F(flagsCt) & flSLOTSc_READoNLY ) flagsc |= fliSEXc_READoNLY ;
    flagsT                               flagsc  = fliSEXc_null     ;

    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
    if( F(flagsCt) & flSLOTSc_READoNLY ) { BLAMMO ; }
    if( F(tinP.flagsThreadMode3) & flTHREADmODE3_DISALLOWpUSE ) { BLAMMO ; }
    _IO_

    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT slotsC::makeSexF( tinS& tinP , const countT expSlotsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

