
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

// CONoUTrAW( "bye\r\n" ) ;
//etherC::loafIF( tinBaseP ) ;
CONoUTrAW( "done.\r\n" ) ;

etThread.delF( tinBaseP , postr ) ;
LOGrAW( postr ) ;

}
    etThread.delF( tinBaseP , postp ) ;

    costr += costp ;
    thirdC::c_strcpyIF( tinBaseP , postr + costr , postp ) ;

    etThread.delF( tinBaseP , psttp ) ;
    countT costp = etThread.strMakeF( tinBaseP , LF , postp , psttp ) ; ___( postp ) ;
    ZE( osTextT* , postp ) ;

    sour >> psttp ; ___( psttp ) ;
    ZE( strokeS* , psttp ) ;

    CONoUTrAW3( "        \r" , sour , "\r" ) ;
{
while( sour )

ZE( countT , costr ) ;
etThread.strMakeF( tinBaseP , LF , postr , 0 , cFiles * TUCK ) ; ___( postr ) ;
ZE( osTextT* , postr ) ;

thirdC::diskWalkIF( tinBaseP , cDirs , cFiles , "\\ideafarm.home.101\\IdeaFarm (tm)\\2.1. Drop Files Here To Archive Them\\" , bQuitNU , myWalkCBF , pcArg ) ;
//thirdC::diskWalkIF( tinBaseP , cDirs , cFiles , "\\tmp\\test\\" , bQuitNU , myWalkCBF , pcArg ) ;
ZE( boolT  , bQuitNU ) ;
ZE( countT , cFiles ) ;
ZE( countT , cDirs ) ;

countT pcArg[] = { (countT)&sour , (countT)pptSpec , sizeof pptSpec / sizeof pptSpec[ 0 ] , (countT)pptSpecBad , sizeof pptSpecBad / sizeof pptSpecBad[ 0 ] } ;
soulC sour( tinBaseP , TAG( TAGiDnULL ) ) ;

} ;
    //CS:CODEsYNC: WO CASE FOR EACH SSS IN pptSpecP

    &tSssDateTime1
{
textC* pptSpecBad[] =

;

    +S2(sa_SSSaNDeND,sc_ccSSS)
        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S3(2,sc_ccSSSrEPEAT,2)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("012")
        +S2(sa_SSSoR,sc_ccSSS)
        +T("@")
        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S3(4,sc_ccSSSrEPEAT,4)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("01")
        +S2(sa_SSSoR,sc_ccSSS)
        +T("20")
    +S2(sa_SSSaND,sc_ccSSS)
    T("")

TN( tSssDateTime1 , "" ) ; tSssDateTime1 =
// "20130510@2359"
//  yyyymmdd hhmm



} ;
    //CS:CODEsYNC: WO CASE FOR EACH SSS IN pptSpecP

    &tSssDateTime3
{
textC* pptSpec[] =

;

    +S2(sa_SSSaNDeND,sc_ccSSS)

        +T("-")

        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("012345")
        +S2(sa_SSSoR,sc_ccSSS)                  // ss

        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("012345")
        +S2(sa_SSSoR,sc_ccSSS)                  // mm

        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("012")
        +S2(sa_SSSoR,sc_ccSSS)                  // hh

        +T("-")

        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("0123")
        +S2(sa_SSSoR,sc_ccSSS)                  // dd

        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("01")
        +S2(sa_SSSoR,sc_ccSSS)                  // mm

        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("01")
        +S2(sa_SSSoR,sc_ccSSS)
        +T("_20")                               // yyyy

        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("01")
        +S2(sa_SSSoR,sc_ccSSS)                  // mm (IGNORE)

        +T("_")

        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("01")
        +S2(sa_SSSoR,sc_ccSSS)
        +T(".gmail.!.20")                    // yyyy (IGNORE)

    +S2(sa_SSSaND,sc_ccSSS)
    T("")

TN( tSssDateTime3 , "" ) ; tSssDateTime3 =
// ".gmail.!.2013_01_20130128-174843-"
//                   yyyymmdd hhmm

TODO

}
    return bDoIt ;

    }
        //else bQuitP |= 1 ;
        }
            }
                ((tinFullS&)tinBaseP).pEther->delF( tinBaseP , psttDateAtTime ) ;

                //else ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , sourP , T("ERROR: DATEtIME NOT CALCULATED\r\n") ) ;
                }
                    ((tinFullS&)tinBaseP).pEther->delF( tinBaseP , psttNew ) ;
                    }
                        }
                            }
                                CONoUTrAW( "\"\r\n" ) ;
                                CONoUTrAW( tNew ) ;
                                CONoUTrAW( "\"\r\n2 new: \"" ) ;
                                CONoUTrAW( tOld ) ;
                                CONoUTrAW( "1 old: \"" ) ;
                                //POOPR
                            {
                            if( POOP )
                            ((thirdC&)*((tinFullS&)tinBaseP).pEtScratch).dosMoveF( tinBaseP , tNew , tOld , 1 ) ;
                            SCOOPS
                        {
                        IFsCRATCH

                        ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , sourP , tcr ) ;
                        ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , sourP , T("new: ")+tNew ) ;

                        TN( tNew , psttNew ) ;
                    {
                    if( cHit )

                    countT cHit = ((tinFullS&)tinBaseP).pEther->strReplaceF( tinBaseP , psttNew , tOld , *pptSpecBadP[ 0 ] , tNewSmall ) ; ___( psttNew ) ;
                    ZE( strokeS* , psttNew ) ;
                    TN( tNewSmall , "" ) ; tNewSmall = T(psttDateAtTime) ;

                    TN( tOld , postNameP ) ;
                {
                if( psttDateAtTime )

                }
                    }
                        ((tinFullS&)tinBaseP).pEther->delF( tinBaseP , psttSnip ) ;

                        }
                            }
                                break ;

                                }
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , psttSnip[ CSpREFIX - 1 + 0x1e ] ) ;
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , psttSnip[ CSpREFIX - 1 + 0x1d ] ) ;
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , psttSnip[ CSpREFIX - 1 + 0x1c ] ) ;
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , psttSnip[ CSpREFIX - 1 + 0x1b ] ) ;
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , S1C('@')                        ) ;
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , psttSnip[ CSpREFIX - 1 + 0x19 ] ) ;
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , psttSnip[ CSpREFIX - 1 + 0x18 ] ) ;
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , psttSnip[ CSpREFIX - 1 + 0x17 ] ) ;
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , psttSnip[ CSpREFIX - 1 + 0x16 ] ) ;
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , psttSnip[ CSpREFIX - 1 + 0x15 ] ) ;
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , psttSnip[ CSpREFIX - 1 + 0x14 ] ) ;
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , psttSnip[ CSpREFIX - 1 + 0x13 ] ) ;
                                    ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , psttDateAtTime , psttSnip[ CSpREFIX - 1 + 0x12 ] ) ;
                                {
                                if( psttDateAtTime )

                                ((tinFullS&)tinBaseP).pEther->strMakeF( tinBaseP , LF , psttDateAtTime , 0 , 0xd ) ; ___( psttDateAtTime ) ;
                            {
                            case 0 :
                            // ".gmail.!.2013_01_20130128-174843-"
                            //                   yyyymmdd hhmm
                            //  123456789abcdef0123456789abcdef01234
                            //  0              1               2

                            //CS:CODEsYNC: WO CASE FOR EACH SSS IN pptSpecP
                        {
                        if( psttSnip && psttSnip->idAdam ) switch( offs )
    
                        ((tinFullS&)tinBaseP).pEther->strSubstringF( tinBaseP , psttSnip , idf , idl , tOld ) ; ___( psttSnip ) ;
                        countT idl = idHitLath ;
                        countT idf = idHitWoth ;
                        ZE( strokeS* , psttSnip ) ;
                    {
                    if( idHitWoth && idHitLath )

                    }
                        }
                            break ;

                            ;
                                : tOld.csF( tinBaseP )
                                ? idf - 1
                            idHitLath = idf
                        {
                        if( idHitWoth )
                        idHitWoth = ((tinFullS&)tinBaseP).pEther->strIdF( tinBaseP , idf , sttq , *pptSpecP[ offs ] , tOld ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        countT idf = 1 ;
                    {
                    for( offs = 0 ; offs < cSpecP ; offs ++ )
                    ZE( countT , offs ) ;
                    ZE( countT , idHitLath ) ;
                    ZE( countT , idHitWoth ) ;
                {
                ZE( strokeS* , psttDateAtTime ) ;

                ((tinFullS&)tinBaseP).pEther->strFuseF( tinBaseP , sourP , tcr+T("old: ")+T(postNameP)+tcr ) ;

                TN( tcr , "\r\n" ) ;
                TN( tOld , postShort ) ;

                postShort ++ ;
            {
            if( postShort )
            osTextT* postShort = thirdC::c_strrchrIF( tinBaseP , postNameP , '\\' ) ;
        {
        //if( idIn <= 0x20 )

        CONoUTrAW3( "        \r" , idIn , "\r" ) ;
        countT idIn = ++ idInLath ;
        static countT idInLath ;

        countT  cSpecBadP   =          pcArgP[ 4 ] ;
        textC** pptSpecBadP = (textC**)pcArgP[ 3 ] ;
        countT  cSpecP      =          pcArgP[ 2 ] ;
        textC** pptSpecP    = (textC**)pcArgP[ 1 ] ;
        soulC&  sourP       = *(soulC*)pcArgP[ 0 ] ;
    {
    if( bDoIt )

    }
        bDoIt = '\\' != postNameP[ costName - 1 ] ;
        countT costName = thirdC::c_strlenIF( tinBaseP , postNameP ) ;
    {
    if( postNameP )
    ZE( boolT , bDoIt ) ;
{
boolT myWalkCBF( tinBaseS& tinBaseP , countT& cDirsP , countT& cFilesP , boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

/*1*/WAKEsHOWtEXT( "tool.archive.migrate.filename.format.4.from.format.3.correction.1" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

