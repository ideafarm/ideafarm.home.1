
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmHireF )
}
    //#endif

    }
        etThread.traceF( tin0P , T("event capture ended [cEnded,cBegun,cIgnored1,cIgnored2]:    ")+TF2(cEnded,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBegun,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cIgnored1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cIgnored2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        }
            bKidsSuspendedP = 0 ;
            }
                }
                    etThread.traceF( tin0P , T("ContinueDebugEvent failed [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    rc = GetLastError() ;
                {
                else
                if( bOk ) ; //etThread.traceF( tin0P , T("called ContinueDebugEvent aok") ) ;

                bOk = ContinueDebugEvent( info3.dwProcessId , info3.dwThreadId , DBG_EXCEPTION_NOT_HANDLED ) ;
                //etThread.traceF( tin0P , T("calling ContinueDebugEvent") ) ;

                //}
                //    }
                //        stOsPidFromTinP.ungrabF( tin0P ) ;
                //        }
                //            stOsPidFromTinP.extractF( 0 , tin0P ) ;
                //            etThread.traceF( tin0P , T("deregistering IPDOS (tm) process 3 [osPid]:    ")+TF2((countT)info3.dwProcessId,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                //        {
                //        if( ids )
                //        stOsPidFromTinP.sinkF( tin0P , ids , (countT)info3.dwProcessId , flSTACKsINK_QUERY , 0 , 0 ) ;
                //        stOsPidFromTinP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                //        ZE( countT , ids ) ;
                //    {
                //    }
                //        stOsPidFromTinZombieP.ungrabF( tin0P ) ;
                //        }
                //            stOsPidFromTinZombieP.extractF( 0 , tin0P ) ;
                //            etThread.traceF( tin0P , T("deregistering IPDOS (tm) process 2 [osPid]:    ")+TF2((countT)info3.dwProcessId,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                //        {
                //        if( ids )
                //        stOsPidFromTinZombieP.sinkF( tin0P , ids , (countT)info3.dwProcessId , flSTACKsINK_QUERY , 0 , 0 ) ;
                //        stOsPidFromTinZombieP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                //        ZE( countT , ids ) ;
                //    {
                //{
                //if( info3.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT )
                //20250404@1613: COMMENTED OUT BECAUSE ALL OF THESE SHOULD HAVE BEEN REMOVED ALREADY WHEN tmEatTelemetryF RECEIVED tinS DT

                }
                    //if( bBlammo ) { BLAMMO ; } //U:: TO FIND A BUG

                    }
#endif
                        etThread.traceF( tin0P , T("resuming execution of the excepting process") ) ;

                        }
                            ++ s ; etThread.osSleepF( tin0P , TOCK >> 2 ) ;
                        {
                        while( !ether && fliPendingSnapShotRequestP )
                        etThread.traceF( tin0P , T("waiting for all exception freeze reports to be written") ) ;

                        tEventP     = tEvent ;
                        osTidEventP = info3.dwThreadId ;                                    //U::BUG: 20210710@1309: RACE
                        osPidEventP = info3.dwProcessId ;                                   //U::BUG: 20210710@1309: RACE
                        thirdC::c_strcpyIF( tin0P , postSnapShotRequestP , "exception" ) ;   //U::BUG: 20210710@1309: RACE

                        }
                            ++ s ; etThread.osSleepF( tin0P , TOCK >> 2 ) ;
                        {
                        while( setIfZeAM( fliPendingSnapShotRequestP , mask ) )
                        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                        while( cSpace -- ) mask = mask << 1 | 1 ;
                        countT cSpace = ifcIDmEMORYsPACE_max - ifcIDmEMORYsPACE_min + 1 - ( ifcIDmEMORYsPACE_RESERVEDmAX - ifcIDmEMORYsPACE_RESERVEDmIN + 1 ) ;
                        ZE( flagsT , mask ) ;

                        etThread.traceF( tin0P , T("requesting exception freeze report") ) ;     //REQUEST SNAPSHOTS WHILE KEEPING EXCEPTING PROCESS FROZEN
#if defined( NEVERdEFINED )
//U::20241219@1040: DISABLED BECAUSE THIS BLOCKS FOREVER AND NO X REPORT IS PRODUCED
                    {
                    )
                        )
                            stOsPidFromTinP( (countT)info3.dwProcessId )
                            ||
                            stOsPidFromTinZombieP( (countT)info3.dwProcessId )
                        (
                        &&
                        )
                            ( info3.dwDebugEventCode == EXCEPTION_DEBUG_EVENT && !info3.u.Exception.dwFirstChance )      //P:PERSONALITY: IF THE PROCESS EXITS EXPLICITLY THEN IT IS RESPONSIBLE FOR GLASS (REVEALING WHY)
                        (
                        &&
                        !ether
                        //&&
                        //bNever
                    (
                    if
                    //ZE( boolT , bNever ) ;
                    //20230809@1252: ENABLED THIS BECAUSE HEAL DIED ACCESS VIOLATION WITH NO EXCEPTION REPORT

                    }
                        etThread.traceF( tin0P , T(bHuh?"!exception:  unexpected process exit code [exitCode]:    ":"process [exitCode]:    ")+tExitCode ) ;

                        }
                            default                                                    : { bHuh = 1 ; tExitCode = TF2(processExitCode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED ) ; break ; }
                            case ifcEXITcODE_EXITpROCESStOOhIGH                        : {            tExitCode = T("EXITpROCESStOOhIGH"                                       ) ; break ; }
                            case ifcEXITcODE_EXITpROCESSdTtINSnOTpOINTINGtOeLDER       : {            tExitCode = T("EXITpROCESSdTtINSnOTpOINTINGtOeLDER"                      ) ; break ; }
                            case ifcEXITcODE_EXITpROCESSdTtINSpOURfAILED               : {            tExitCode = T("EXITpROCESSdTtINSpOURfAILED"                              ) ; break ; }
                            case ifcEXITcODE_EXITpROCESSdTtINSuNEXPECTEDrECYCLEtYPE    : {            tExitCode = T("EXITpROCESSdTtINSuNEXPECTEDrECYCLEtYPE"                   ) ; break ; }
                            case ifcEXITcODE_EXITpROCESSdTtINSsOMETHINGgRABBED         : {            tExitCode = T("EXITpROCESSdTtINSsOMETHINGgRABBED"                        ) ; break ; }
                            case ifcEXITcODE_EXITpROCESSdTtINSnOTpOINTINGtOmE          : {            tExitCode = T("EXITpROCESSdTtINSnOTpOINTINGtOmE"                         ) ; break ; }
                            case ifcEXITcODE_EXITpROCESSdTtINSkIDSeXISTdURINGclEANUP   : {            tExitCode = T("EXITpROCESSdTtINSkIDSeXISTdURINGclEANUP"                  ) ; break ; }
                            case ifcEXITcODE_EXITpROCESSeXCEPTION                      : {            tExitCode = T("EXITpROCESSeXCEPTION"                                     ) ; break ; }
                            case ifcEXITcODE_EXITpROCESSsIGNAL                         : {            tExitCode = T("EXITpROCESSsIGNAL"                                        ) ; break ; }
                            case ifcEXITcODE_EXITpROCESSiMPOTENT                       : {            tExitCode = T("EXITpROCESSiMPOTENT"                                      ) ; break ; }
                            case ifcEXITcODE_EXITpROCESSaOK                            : {            tExitCode = T("EXITpROCESSaOK"                                           ) ; break ; }
                            case ifcEXITcODE_EXITpROCESStOOlOW                         : {            tExitCode = T("EXITpROCESStOOlOW"                                        ) ; break ; }
                            //CS:CODEsYNC: 510004FB 112000EF
                        {
                        switch( processExitCode )
                        ZE( boolT , bHuh ) ;
                        TN( tExitCode , "" ) ;
                    {
                    if( info3.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT )

                    else etThread.traceF( tin0P , T("event (debug) [cBegun,cEnded,osPid,osTid,chance,event]:    ")+TF2(cBegun,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cEnded,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4((countT)info3.dwProcessId,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+tb4+TF4((countT)info3.dwThreadId,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(info3.u.Exception.dwFirstChance?"    WOTH        ":"        OOTH    ")+tEvent ) ;
                         etThread.traceF( tin0P , T("event         [cBegun,cEnded,osPid,osTid,chance,event]:    ")+TF2(cBegun,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cEnded,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4((countT)info3.dwProcessId,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+tb4+TF4((countT)info3.dwThreadId,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(info3.u.Exception.dwFirstChance?"    WOTH        ":"        OOTH    ")+tEvent ) ;
                    )
                        )
                            !info3.u.Exception.dwFirstChance                    //P:PERSONALITY: I AM SILENT FOR WOTH CHANCE EXCEPTION EVENTS BECAUSE THESE MIGHT BE WAD WAC ("WORKING AS DESIGNED WORKING AS CODED").  I AM ONLY INTERESTED IN EXCEPTIONS THAT THE MONITORED PROCESS DOES NOT HANDLE
                            &&
                            info3.dwDebugEventCode == EXCEPTION_DEBUG_EVENT
                        (
                        ||
                        info3.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT
                        ||
                        info3.dwDebugEventCode == RIP_EVENT
                    (
                    if

                    }
                        }
                            }
                                break ;

                                }
                                    }
                                        }
                                            break ;
                                            }
                                                tEvent += tb4+tException ;

                                                ;
                                                    : TF2(idException,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                    ? T(postException)
                                                TN( tException , "" ) ; tException = postException

                                                const osTextT* const postException = processGlobal4S::_processGlobal4I_IF().mapBosCodeWindows( idException ) ;
                                                countT idException = (countT)info3.u.Exception.ExceptionRecord.ExceptionInformation[ ii ] ;
                                            {
                                            if( ii == info3.u.Exception.ExceptionRecord.NumberParameters - 1 )
                                        {
                                        case EXCEPTION_IN_PAGE_ERROR :
                                    {
                                    switch( info3.u.Exception.ExceptionRecord.ExceptionCode )

                                    }
                                        default : { tEvent += tb4+TF2(vv,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                        ; break ; }
                                        case 8  : { tEvent += tb4+TF4(vv,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ; break ; }
                                        case 7  :
                                        case 5  : { tEvent += tb4+T(processGlobal4S::_processGlobal4I_IF().mapTinName(vv))                ; break ; }
                                    {
                                    else switch( ii )
                                    if( ifcUnexpectedExceptionCode != ifcIDeVENTeXCEPTIONmONITORED_BLAMMO ) tEvent += tb4+TF2(vv,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;

                                    countT vv = (countT)info3.u.Exception.ExceptionRecord.ExceptionInformation[ ii ] ;

                                    }
                                        }
                                            case EXCEPTION_IN_PAGE_ERROR    : { tEvent += T("    [bWrite1OrDataExecution8,at,osStatusCode]:") ; break ; }
                                            case EXCEPTION_ACCESS_VIOLATION : { tEvent += T("    [bWrite1OrDataExecution8,at]:"             ) ; break ; }
                                        {
                                        else switch( info3.u.Exception.ExceptionRecord.ExceptionCode )
                                        }
                                            default                                  : { tEvent += T("    notes:"                                                                                                          ) ; break ; }
                                            case ifcIDeVENTeXCEPTIONmONITORED_BLAMMO : { tEvent += T("    [idLine,idiFile,idLineCt,idiFileCt,idBlammo,((tin1S&)tin0P).idTinNamed,tinName,((tin1S&)tin0P).glass.idThread,((tin1S&)tin0P).osTid,osTidIF()]:") ; break ; }
                                            case ifcIDeVENTeXCEPTIONmONITORED_GRUNT  : { tEvent += T("    [idLine,idiFile,idSubType,idType]:"                                                                              ) ; break ; }
                                        {
                                        if( ifcUnexpectedExceptionCode ) switch( ifcUnexpectedExceptionCode )
                                    {
                                    if( !ii )
                                {
                                for( countT ii = 0 ; ii < info3.u.Exception.ExceptionRecord.NumberParameters ; ii ++ )
                                tEvent += tb4+T("[flags,at,cNotes]:    ")+TF2((countT)info3.u.Exception.ExceptionRecord.ExceptionFlags,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)info3.u.Exception.ExceptionRecord.ExceptionAddress,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)info3.u.Exception.ExceptionRecord.NumberParameters,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;

                                }
                                    }
                                        break ;             

                                        ;
                                            : T("(unexpected exception code) [code]:    ")+TF2((countT)info3.u.Exception.ExceptionRecord.ExceptionCode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                            ? T(postException)
                                        tEvent += postException
                                        const osTextT* const postException = processGlobal4S::_processGlobal4I_IF().mapExceptionType( ifcUnexpectedExceptionCode ) ;

                                        ifcUnexpectedExceptionCode = info3.u.Exception.ExceptionRecord.ExceptionCode & ~( 0xf0000000 ) | 0xd0000000 ;       //A:ASSUME: 02 BITS
                                    {
                                    default                                   :
                                    case STATUS_SXS_INVALID_DEACTIVATION     /* 0xC0150010L */ : { tEvent += T("STATUS_SXS_INVALID_DEACTIVATION     ")                                                                                                        ; break ; }
                                    case STATUS_SXS_EARLY_DEACTIVATION       /* 0xC015000FL */ : { tEvent += T("STATUS_SXS_EARLY_DEACTIVATION       ")                                                                                                        ; break ; }
                                    case STATUS_ASSERTION_FAILURE            /* 0xC0000420L */ : { tEvent += T("STATUS_ASSERTION_FAILURE            ")                                                                                                        ; break ; }
                                    case STATUS_INVALID_CRUNTIME_PARAMETER   /* 0xC0000417L */ : { tEvent += T("STATUS_INVALID_CRUNTIME_PARAMETER   ")                                                                                                        ; break ; }
                                    case STATUS_STACK_BUFFER_OVERRUN         /* 0xC0000409L */ : { tEvent += T("STATUS_STACK_BUFFER_OVERRUN         ")                                                                                                        ; break ; }
                                    case STATUS_REG_NAT_CONSUMPTION          /* 0xC00002C9L */ : { tEvent += T("STATUS_REG_NAT_CONSUMPTION          ")                                                                                                        ; break ; }
                                    case STATUS_FLOAT_MULTIPLE_TRAPS         /* 0xC00002B5L */ : { tEvent += T("STATUS_FLOAT_MULTIPLE_TRAPS         ")                                                                                                        ; break ; }
                                    case STATUS_FLOAT_MULTIPLE_FAULTS        /* 0xC00002B4L */ : { tEvent += T("STATUS_FLOAT_MULTIPLE_FAULTS        ")                                                                                                        ; break ; }
                                    case STATUS_DLL_INIT_FAILED              /* 0xC0000142L */ : { tEvent += T("STATUS_DLL_INIT_FAILED              ")                                                                                                        ; break ; }
                                    case STATUS_CONTROL_C_EXIT               /* 0xC000013AL */ : { tEvent += T("STATUS_CONTROL_C_EXIT               ")                                                                                                        ; break ; }
                                    case STATUS_ENTRYPOINT_NOT_FOUND         /* 0xC0000139L */ : { tEvent += T("STATUS_ENTRYPOINT_NOT_FOUND         ")                                                                                                        ; break ; }
                                    case STATUS_ORDINAL_NOT_FOUND            /* 0xC0000138L */ : { tEvent += T("STATUS_ORDINAL_NOT_FOUND            ")                                                                                                        ; break ; }
                                    case STATUS_DLL_NOT_FOUND                /* 0xC0000135L */ : { tEvent += T("STATUS_DLL_NOT_FOUND                ")                                                                                                        ; break ; }
                                    case EXCEPTION_STACK_OVERFLOW            /* 0xC00000FDL */ : { tEvent += T("EXCEPTION_STACK_OVERFLOW            ")                                                                                                        ; break ; }
                                    case EXCEPTION_PRIV_INSTRUCTION          /* 0xC0000096L */ : { tEvent += T("EXCEPTION_PRIV_INSTRUCTION          ")                                                                                                        ; break ; }
                                    case EXCEPTION_INT_OVERFLOW              /* 0xC0000095L */ : { tEvent += T("EXCEPTION_INT_OVERFLOW              ")                                                                                                        ; break ; }
                                    case EXCEPTION_INT_DIVIDE_BY_ZERO        /* 0xC0000094L */ : { tEvent += T("EXCEPTION_INT_DIVIDE_BY_ZERO        ")                                                                                                        ; break ; }
                                    case EXCEPTION_FLT_UNDERFLOW             /* 0xC0000093L */ : { tEvent += T("EXCEPTION_FLT_UNDERFLOW             ")                                                                                                        ; break ; }
                                    case EXCEPTION_FLT_STACK_CHECK           /* 0xC0000092L */ : { tEvent += T("EXCEPTION_FLT_STACK_CHECK           ")                                                                                                        ; break ; }
                                    case EXCEPTION_FLT_OVERFLOW              /* 0xC0000091L */ : { tEvent += T("EXCEPTION_FLT_OVERFLOW              ")                                                                                                        ; break ; }
                                    case EXCEPTION_FLT_INVALID_OPERATION     /* 0xC0000090L */ : { tEvent += T("EXCEPTION_FLT_INVALID_OPERATION     ")                                                                                                        ; break ; }
                                    case EXCEPTION_FLT_INEXACT_RESULT        /* 0xC000008FL */ : { tEvent += T("EXCEPTION_FLT_INEXACT_RESULT        ")                                                                                                        ; break ; }
                                    case EXCEPTION_FLT_DIVIDE_BY_ZERO        /* 0xC000008EL */ : { tEvent += T("EXCEPTION_FLT_DIVIDE_BY_ZERO        ")                                                                                                        ; break ; }
                                    case EXCEPTION_FLT_DENORMAL_OPERAND      /* 0xC000008DL */ : { tEvent += T("EXCEPTION_FLT_DENORMAL_OPERAND      ")                                                                                                        ; break ; }
                                    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED     /* 0xC000008CL */ : { tEvent += T("EXCEPTION_ARRAY_BOUNDS_EXCEEDED     ")                                                                                                        ; break ; }
                                    case EXCEPTION_INVALID_DISPOSITION       /* 0xC0000026L */ : { tEvent += T("EXCEPTION_INVALID_DISPOSITION       ")                                                                                                        ; break ; }
                                    case EXCEPTION_NONCONTINUABLE_EXCEPTION  /* 0xC0000025L */ : { tEvent += T("EXCEPTION_NONCONTINUABLE_EXCEPTION  ")                                                                                                        ; break ; }
                                    case EXCEPTION_ILLEGAL_INSTRUCTION       /* 0xC000001DL */ : { tEvent += T("EXCEPTION_ILLEGAL_INSTRUCTION       ")                                                                                                        ; break ; }
                                    case STATUS_NO_MEMORY                    /* 0xC0000017L */ : { tEvent += T("STATUS_NO_MEMORY                    ")                                                                                                        ; break ; }
                                    case STATUS_INVALID_PARAMETER            /* 0xC000000DL */ : { tEvent += T("STATUS_INVALID_PARAMETER            ")                                                                                                        ; break ; }
                                    case EXCEPTION_INVALID_HANDLE            /* 0xC0000008L */ : { tEvent += T("EXCEPTION_INVALID_HANDLE            ")                                                                                                        ; break ; }
                                    case EXCEPTION_IN_PAGE_ERROR             /* 0xC0000006L */ : { tEvent += T("EXCEPTION_IN_PAGE_ERROR             ")                                                                                                        ; break ; }
                                    case EXCEPTION_ACCESS_VIOLATION          /* 0xC0000005L */ : { tEvent += T("EXCEPTION_ACCESS_VIOLATION          ")                                                                                                        ; break ; }
                                    case DBG_EXCEPTION_NOT_HANDLED           /* 0x80010001L */ : { tEvent += T("DBG_EXCEPTION_NOT_HANDLED           ")                                                                                                        ; break ; }
                                    case STATUS_UNWIND_CONSOLIDATE           /* 0x80000029L */ : { tEvent += T("STATUS_UNWIND_CONSOLIDATE           ")                                                                                                        ; break ; }
                                    case STATUS_LONGJMP                      /* 0x80000026L */ : { tEvent += T("STATUS_LONGJMP                      ")                                                                                                        ; break ; }
                                    case EXCEPTION_SINGLE_STEP               /* 0x80000004L */ : { tEvent += T("EXCEPTION_SINGLE_STEP               ")                                                                                                        ; break ; }
                                    case EXCEPTION_BREAKPOINT                /* 0x80000003L */ : { tEvent += T("EXCEPTION_BREAKPOINT                ") ; if( bSlowAllP ) { ++ s ; etThread.osSleepF( tin0P , TOCK >> 0 ) ; inc02AM( cNewBreakNapsTakenP ) ; }   break ; }
                                    case EXCEPTION_DATATYPE_MISALIGNMENT     /* 0x80000002L */ : { tEvent += T("EXCEPTION_DATATYPE_MISALIGNMENT     ")                                                                                                        ; break ; }
                                    case EXCEPTION_GUARD_PAGE                /* 0x80000001L */ : { tEvent += T("EXCEPTION_GUARD_PAGE                ")                                                                                                        ; break ; }
                                    case DBG_COMMAND_EXCEPTION               /* 0x40010009L */ : { tEvent += T("DBG_COMMAND_EXCEPTION               ")                                                                                                        ; break ; }
                                    case DBG_CONTROL_BREAK                   /* 0x40010008L */ : { tEvent += T("DBG_CONTROL_BREAK                   ")                                                                                                        ; break ; }
                                    case DBG_RIPEXCEPTION                    /* 0x40010007L */ : { tEvent += T("DBG_RIPEXCEPTION                    ")                                                                                                        ; break ; }
                                    case DBG_PRINTEXCEPTION_C                /* 0x40010006L */ : { tEvent += T("DBG_PRINTEXCEPTION_C                ")                                                                                                        ; break ; }
                                    case DBG_CONTROL_C                       /* 0x40010005L */ : { tEvent += T("DBG_CONTROL_C                       ")                                                                                                        ; break ; }
                                    case DBG_TERMINATE_PROCESS               /* 0x40010004L */ : { tEvent += T("DBG_TERMINATE_PROCESS               ")                                                                                                        ; break ; }
                                    case DBG_TERMINATE_THREAD                /* 0x40010003L */ : { tEvent += T("DBG_TERMINATE_THREAD                ")                                                                                                        ; break ; }
                                    case STATUS_SEGMENT_NOTIFICATION         /* 0x40000005L */ : { tEvent += T("STATUS_SEGMENT_NOTIFICATION         ")                                                                                                        ; break ; }
                                    case DBG_CONTINUE                        /* 0x00010002L */ : { tEvent += T("DBG_CONTINUE                        ")                                                                                                        ; break ; }
                                    case DBG_EXCEPTION_HANDLED               /* 0x00010001L */ : { tEvent += T("DBG_EXCEPTION_HANDLED               ")                                                                                                        ; break ; }
                                    case STATUS_PENDING                      /* 0x00000103L */ : { tEvent += T("STATUS_PENDING                      ")                                                                                                        ; break ; }
                                    case STATUS_TIMEOUT                      /* 0x00000102L */ : { tEvent += T("STATUS_TIMEOUT                      ")                                                                                                        ; break ; }
                                    case STATUS_USER_APC                     /* 0x000000C0L */ : { tEvent += T("STATUS_USER_APC                     ")                                                                                                        ; break ; }
                                    case STATUS_ABANDONED_WAIT_0             /* 0x00000080L */ : { tEvent += T("STATUS_ABANDONED_WAIT_0             ")                                                                                                        ; break ; }
                                    case STATUS_WAIT_0                       /* 0x00000000L */ : { tEvent += T("STATUS_WAIT_0                       ")                                                                                                        ; break ; }
                                {
                                switch( info3.u.Exception.ExceptionRecord.ExceptionCode )
                                ZE( countT , ifcUnexpectedExceptionCode ) ;                               //CALCULATED FROM OS EXCEPTION CODE
                            {
                            case EXCEPTION_DEBUG_EVENT :
                        {
                        switch( info3.dwDebugEventCode )

                        }
                            default                          : {                                                                               tEvent = T("<unknown (coding error)>   [eventCode]:")+TF2((countT)info3.dwDebugEventCode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ; break ; }
                            case RIP_EVENT                   : {                                                                               tEvent = T("RIP_EVENT                  ")                                                                                          ; break ; }
                            case OUTPUT_DEBUG_STRING_EVENT   : {                                                                               tEvent = T("OUTPUT_DEBUG_STRING_EVENT  ")                                                                                          ; break ; }
                            case UNLOAD_DLL_DEBUG_EVENT      : {                                                                               tEvent = T("UNLOAD_DLL_DEBUG_EVENT     ")                                                                                          ; break ; }
                            case LOAD_DLL_DEBUG_EVENT        : {                                                                               tEvent = T("LOAD_DLL_DEBUG_EVENT       ")                                                                                          ; break ; }
                            }
                                break ;
                                tEvent = T("EXIT_PROCESS_DEBUG_EVENT   [exitCode]: ")+TF2(processExitCode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
                                processExitCode = info3.u.ExitProcess.dwExitCode ;
                                cEnded ++ ;
                                stOsPidP.ungrabF( tin0P ) ;
                                else      etThread.traceF( tin0P , T("!exception / an unknown process has ended") ) ;
                                if( ids ) stOsPidP.extractF( 0 , tin0P ) ;
                                stOsPidP.sinkF( tin0P , ids , (countT)info3.dwProcessId , flSTACKsINK_QUERY ) ;
                                stOsPidP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                ZE( countT , ids ) ;
                            {
                            case EXIT_PROCESS_DEBUG_EVENT    :
                            case EXIT_THREAD_DEBUG_EVENT     : {             threadExitCode  = info3.u.ExitThread.dwExitCode  ;                tEvent = T("EXIT_THREAD_DEBUG_EVENT    [exitCode]: ")+TF2(threadExitCode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)                 ; break ; }
                            case CREATE_PROCESS_DEBUG_EVENT  : { cBegun ++ ; stOsPidP.sinkF( tin0P , countTC() , (countT)info3.dwProcessId ) ; tEvent = T("CREATE_PROCESS_DEBUG_EVENT ")                                                                                          ; break ; }
                            case CREATE_THREAD_DEBUG_EVENT   : {                                                                               tEvent = T("CREATE_THREAD_DEBUG_EVENT  ")                                                                                          ; break ; }
                            case EXCEPTION_DEBUG_EVENT       : {                                                                               tEvent = T("EXCEPTION_DEBUG_EVENT      ")                                                                                          ; break ; }
                        {
                        switch( info3.dwDebugEventCode )
                    {
                    ZE( countT , threadExitCode ) ;
                    ZE( countT , processExitCode ) ;
                    TN( tEvent , "" ) ;
                    //ZE( boolT , bBlammo ) ; //U:: TO FIND A BUG
                {

                //}
                //    if( rc ) ;
                //    countT rc = GetLastError() ;
                //{
                //if( !bOk2 )                                                   //THIS DOODLE IS A WORKAROUND TO ALLOW BUNDLE TO CALL A 64 BIT PROCESS
                //boolT bOk2 = DebugActiveProcessStop( info3.dwProcessId ) ;    //U::REMOVE THIS DOODLE AND ENHANCE IPDOS thirdC::dosExecProcessF TO TELL ME TO TEMPORARILY STOP DEBUGGING A PROCESS THAT IS ABOUT TO LAUNCH AN 04-BIT PROCESS SUCH AS pkzipc.exe
            {
            else
            }
                else                             { cIgnored2 ++ ; etThread.traceF( tin0P , T("called WaitForDebugEvent (failed) [rc]:    "           )+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; }
                if( rc == ERROR_INVALID_HANDLE ) { cIgnored1 ++ ; etThread.traceF( tin0P , T("called WaitForDebugEvent (failed) ERROR_INVALID_HANDLE")                                                  ) ; }  // THESE EVENTS SEEM TO BE GENERATED WHEN THE ADAM BEING DEBUGGED IS A WINDOWED PROCESS
                rc = GetLastError() ;
            {
            if( !bOk )

            }
                ++ s ; etThread.osSleepF( tin0P , TOCK ) ;
                etThread.traceF( tin0P , T("bSuspendAllP is set, so i am napping rather than processing a debug event") ) ;
            {
            while( bSuspendAllP && !ether )                     // IF ether THEN MUST NOT NAP, SO THE PROCESSES CAN END
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

            bKidsSuspendedP = 1 ;
            bOk = WaitForDebugEvent( &info3 , INFINITE ) ;
            //etThread.traceF( tin0P , T("calling WaitForDebugEvent") ) ;
        {
        while( !cBegun || cEnded < cBegun )
        ZE( countT , cIgnored2 ) ;
        ZE( countT , cIgnored1 ) ;
        TN( tb4 , "    " ) ;
        ZE( countT , cEnded ) ;
        ZE( countT , cBegun ) ;
        memset( (char*)&info3 , 0 , sizeof info3 ) ;
        DEBUG_EVENT info3 ;
        ZE( countT , rc ) ;
        ZE( boolT , bOk ) ;

        //etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE ) ;
    {
    else
    else if( !cHired   ) { FIREmYSELF ; }
         if( bConsoleP ) { FIREmYSELF ; }  // SINCE I WAITED FOR CONSOLE TO END, AND THAT HAS OCCURED, THERE'S NOTHING TO MONITOR AND IT'S TIME TO DIE

    //#if defined( NEVERdEFINED )
    //DISABLED TEMPORARILY 20240322@1536 TO ALLOW KID TO HIRE 04 BIT PROCESS (pkczip.exe)

    }
        }
            }
                etThread.traceF( tin0P , T("could not hire") ) ;
                POOPR
            {
            else
            if( !POOP ) cHired ++ ;

            //ether.osThreadF( tin0P , countTC() , tmFireMyselfF ) ;
            
            //homeS::homeIF().flags |= flHOMEs_FIREtHIShOME ;
            //CONoUTrAW( "setting flHOMEs_FIREtHIShOME\r\n" ) ;
            //U::TO FIND A BUG

            //IT IS ILLEGAL TO NOT HIRE AN ADAM

            /*PROD*/ /*if( idMe == IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0 || idMe == IDcOMPUTER_IPDOSmASTERcRAFTWORKoLD0sERVER )*/ etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_MEMBRANEgLASS , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_SCRATCH0f , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_WEBhOOKnOTICEfILER , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_HEALaRCHIVES , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_ROOTmAILoUT , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_TOOLmIGRATEaRCHIVEfORMAT9tOfORMATa , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , 0x5100081f , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_SCRATCH0c , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_SCRATCH06 , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_TIME , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_ROOTmAILoUT , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_GORILLAbANG , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_3BANG , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_ROOThTTPsERVER , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_CLOUD , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_CODEmEASUREMENTS , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_SCRATCH0f , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_SCRATCH0d , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;

            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_ACCESSeVENTS3bOOKbYhASHbYTE1 , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;
            
            //else                                          homeS::homeIF().flags |= flHOMEs_FIREtHIShOME ;
            //else                                          ether.osThreadF( tin0P , countTC() , tmFireMyselfF ) ;
            
            // /*if( 1 < etherC::ifc_idHomeIdisk_IF() )*/    etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_MEMBRANEgLASS , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;
            //THIS WAS THE PRODUCTION LINE UNTIL 2010.12.23, WHEN LOCAL LIST DEVELOPMENT WAS FINISHED AND DEVELOPMENT RESUMED ON THE RELAY SUBSYSTEM
        
            //ether.osThread AdamF( tin0P , ifcIDaDAM_MEMBRANEgLASS ) ;
            
            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , 0x4010ffe , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;
            
            //else                                             etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_3PANICdOOR , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;
            //if( 0xffffff == etherC::ifc_idHomeI_IF() ) etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_TIMEcARD         , T("!noTells !ignoreFireByOperator")   , flagsUse , 0 , 0 , 1 , nicNameC() ) ;
            
            //else                                             etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_NEWcONSOLE , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;
            //if( 0xffffff == etherC::ifc_idHomeI_IF() ) etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_TIMEcARD   , T("!noTells !ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;
        
            //etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_HOMEfLAGS , T("!ignoreFireByOperator") , flagsUse , 0 , 0 , 1 , nicNameC() ) ;
            // 
            // b. OBJECTIVE: MIGRATE THIS ADAM SET TO THE PRODUCT WHILE ENSURING ROCK SOLID BEHAVIOR IN FIELD
            // a. INCREMENTALLY ADD THE REMAINDER OF THIS ADAM SET TO THE PRODUCT
            // 9. FIELD TEST AND TUNE SO USER CANNOT SEE ANY LOADING OR OTHER EFFECTS OF THE RELAY SUBSYSTEM
            // 8. "TURN ON" RELAY CAPABILITY IN THE PRODUCT
            // 7. LEASE AND CONFIGURE A DEDICATED SERVER TO SERVE AS THE ROOT RELAY
            // 6. ADD RELAY CAPABILITY TO THE PRODUCT
            // 5. TEST AND TUNE THE RELAY SYSTEM
            // 4. REWRITE THE MONITOR (005 CODE INTO 105), ENHANCING TO DETECT CPU SPINS
            // 3. ESTABLISH RELIABLE REVENUE STREAM
            // 2. ESTABLISH QUALITY REPUTATION IN THE MARKET
            // 1. RELEASE A KT VIEWER/EDITOR PRODUCT
            // 
            // PLAN
            // DO NOT DELETE THIS COMMENT; IT POINTS TO THE OLD ADAM CHAIN, WHICH IS ALMOST COMPLETELY DEBUGGED
            // 
            // IT WILL HAVE NO RELAY OR NETWORKING CAPABILITY
            // THIS INITIAL PRODUCT IS ENVISIONED AS LIKE ADOBE ACROBAT BUT FOR KNOWLEDGE TREES
            // COMMENTED OUT WITH INTENT TO REDESIGN THE PACKAGE TO GET STABLE AND QUICK INITIAL PRODUCT
            // CONSOLE ONLY SUPPORTS IO VIA CIO, WHICH IS UNNECESSARILY SLOW FOR LOCAL WORK
            // STATUS: WORKS AOK ON MY COMPUTER BUT PEGS CPU ON DANIEL'S
            // 
            // THIS IS THE OLD PRODUCT, WITH FULL RELAY CAPABILITY INCLUDING CIO SUPPORT FOR CONSOLE IO

            const flagsT flagsUse = flHIRE_DISPLAYaUTO | flHIRE_MONITORtHIS | flHIRE_MONITORkIDS ;              //THIS WILL PREVENT THE LAUNCH OF 64-BIT KIDS SUCH AS pkzipc.exe
        {
        else
        }
            }
                etThread.traceF( tin0P , T("could not hire") ) ;
                POOPR
            {
            else
            if( !POOP ) cHired ++ ;
            etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_CONSOLE , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO | flHIRE_WAIT , 0 , 0 , 1 , nicNameC() ) ;
        {
        else if( bConsoleP )
        }
            }
                etThread.traceF( tin0P , T("could not hire") ) ;
                POOPR
            {
            else
            if( !POOP ) cHired ++ ;
            etScratch.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , idAdamRequested   , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO               , nicNameC() ) ;
        {
        if( idAdamRequested )

        etherC& etScratch = *((tin1S&)tin0P).pEtScratch ;

        SCOOPS
    {
    IFsCRATCHoK
    ZE( countT , cHired ) ;

    }
        }
            else if( !etThread.strCompareF( tin0P , psttc1 , tTest ) ) bArmed = 1 ;
            }
                break ;
                idAdamRequested = etThread.strDigitsToSCountF( tin0P , psttc1 , 0 , 1 ) ;
                bArmed = 0 ;
            {
            if( bArmed )
            //etThread.traceF( tin0P , T("process parameter: \"")+T(psttc1)+T("\"") ) ;
        {
        FORsTRINGSiN1( pstt1p )
        ZE( boolT , bArmed ) ;

        strokeS*& pstt1p = etThread.ether_pstt1_processParametersI_F( tin0P ) ;

        TN( tTest , "!idAdamMonitor" ) ;
    {
    ZE( countT , idAdamRequested ) ;

    }    
        //U:: while( !ether && ( !save || save + 0x10 <= cHamburgersP ) ) ;
        //U:: }
        //U::     CONoUTrAW5( "tmHireF [save,cHamburgersP]: " , save , " " , cHamburgersP , "\r\n" ) ;
        //U::     ++ s ; ether.osSleepF( tin0P , TOCK ) ;
        //U::     save = cHamburgersP ;
        //U:: {
        //U:: do
        //U:: ZE( countT , save ) ;
        //U:: //SLEEP TO GIVE TELEMETRY EATERS TIME TO READ ALL TELEMETRY ALREADY BOOKED
        
        ++ s ; ether.osSleepF( tin0P , TOCK * 0x4 ) ; //SLEEP TO GIVE INSTALLER TIME TO GO AWAY
    
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    {
    
    //U::if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_NOsYSTEMtHREADS ) ) { __( ((tin1S&)tin0P).glass.idThread - ifcIDtHREADlOW_tmHireF ) ; }

    countT&  cNewBreakNapsTakenP        = *(countT*)pTaskP->ce ;
    boolT&   bSlowAllP                  =  *(boolT*)pTaskP->cd ;
    boolT&   bSuspendAllP               =  *(boolT*)pTaskP->cc ;
    boolT&   bKidsSuspendedP            =  *(boolT*)pTaskP->cb ;
    boolT    bConsoleP                  =    (boolT)pTaskP->ca ;
    stackC&  stOsPidFromTinZombieP      = *(stackC*)pTaskP->c9 ;
    stackC&  stOsPidFromTinP            = *(stackC*)pTaskP->c8 ;
    stackC&  stOsPidP                   = *(stackC*)pTaskP->c7 ;
    textC&   tEventP                    =  *(textC*)pTaskP->c6 ;
    countT&  osTidEventP                = *(countT*)pTaskP->c5 ;
    countT&  osPidEventP                = *(countT*)pTaskP->c4 ;
    osTextT* postSnapShotRequestP       = (osTextT*)pTaskP->c3 ;
    flagsT&  fliPendingSnapShotRequestP = *(flagsT*)pTaskP->c2 ;
    countT&  cHamburgersP               = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 && pTaskP->c8 && pTaskP->c9 && pTaskP->cb && pTaskP->cc && pTaskP->cd && pTaskP->ce )
TASK( tmHireF )

DONE( tmSlowAllF )
}
    bSlowAllP = 0 ;

    }
        if( POOP ) POOPRqUIET
        ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileSlowingAll , 1 ) ;

        if( POOP ) POOPRqUIET
        ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileSlowAllOn , 1 ) ;
        SCOOPS
    {
    IFsCRATCHoK

    }
        }
            ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
        {
        while( bQuitTakingBreaks )
        bQuitTakingBreaks = 1 ;
    {
    if( bSlowAllP )

    etThread.delF( tin0P , pstt1LanRoster ) ;
    }
        ++ s ; etThread.osSleepF( tin0P , TOCK ) ;

        bSlowingAllLag = bSlowingAll ;
        bSlowAllLag    = bSlowAllP   ;

        }
            if( bSlowingAll != bSlowingAllLag ) etThread.traceF( tin0P , T("unslowingAll ; i will stop imposing periodic nap time on all processes that i am debugging") ) ;
            }
                if( POOP ) POOPRqUIET
                ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileSlowingAll , 1 ) ;
                SCOOPS
            {
            IFsCRATCHoK
            bSlowingAll = 0 ;
        {
        else
        }
            if( bSlowingAll != bSlowingAllLag ) etThread.traceF( tin0P , T("slowingAll") ) ;
            etThread.boxPutF( tin0P , tFileSlowingAll , tSay , tSay.csF( tin0P ) + 1 ) ;
            TN( tSay , "IdeaFarm (tm) Glass2 is currently slowingAll." ) ;
            bSlowingAll = 1 ;
        {
        if( bSlowAllP )
        ZE( boolT , bSlowingAll ) ;

        }
            }
                }
                    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                {
                while( bQuitTakingBreaks )
                bQuitTakingBreaks = 1 ;
                etThread.traceF( tin0P , T("unslowingAll on request") ) ;
            {
            if( bSlowAllP != bSlowAllLag )
            bSlowAllP = 0 ;
        {
        else
        }
            }
                etThread.osThreadF( TaRG2cBsTACK( tmTakeBreaksF , CBsTACKmIN << 1 ) , (countT)&bQuitTakingBreaks , (countT)&stOsPidP , (countT)&cNewBreakNapsTakenP ) ;
                etThread.traceF( tin0P , T("slowingAll on request") ) ;
            {
            if( bSlowAllP != bSlowAllLag )
            bSlowAllP = 1 ;
        {
        if( bFarCommandToSlow || etThread.diskFileExistsF( tin0P , tFileSlowAllOn ) )

        }
            bFarCommandToSlowLathUpdate = bFarCommandToSlow ;

            }
                etThread.delF( tin0P , posti ) ;
                }
                    }
                        }
                            bFarCommandToSlow = 1 ;
                            etThread.traceF( tin0P , T("!exception / slowing all of the processes that i am debugging") ) ;
                        {
                        if( !etThread.strCompareF( tin0P , tMyLanName , tHisName ) || !etThread.strCompareF( tin0P , tHisName , tHisNameAll ) )
                        etThread.traceF( tin0P , T("!exception / i see a command to slow a host [tMyLanName,tHisName]:    ")+tMyLanName+tb4+tHisName ) ;

                        TN( tHisName , posti ) ;
                    {
                    else
                    if( POOP ) POOPRqUIET

                    ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , tLong , 1 ) ; ___( posti ) ;

                    SCOOPS
                {
                IFsCRATCHoK
                ZE( countT   , costi ) ;
                ZE( osTextT* , posti ) ;

                //etThread.traceF( tin0P , T("scanning for a file named []:    ")+tLong ) ;
                TN( tLong , "" ) ; tLong = T("////")+T(psttc1)+tSlowByHostNameSuffix ;
            {
            FORsTRINGSiN1( pstt1LanRoster )
        {
        else
        if( ++ idScan % 0x8 ) bFarCommandToSlow = bFarCommandToSlowLathUpdate ;                                                         // REDUCES NETWORK TRAFFIC AND DISK I/O
        ZE( boolT , bFarCommandToSlow ) ;
    {
    while( !bQuitSlowingAllP )
    ZE( boolT , bQuitTakingBreaks ) ;
    ZE( boolT , bFarCommandToSlowLathUpdate ) ;
    ZE( countT , idScan ) ;
    TN( tHisNameAll , "all" ) ;
    ZE( boolT , bSlowingAllLag ) ;
    ZE( boolT , bSlowAllLag ) ;

    }
        etThread.delF( tin0P , psttn ) ;
        tMyLanName = T(psttn) ;
        etThread.computerLanNameF( tin0P , psttn ) ; ___( psttn ) ;
        ZE( strokeS* , psttn ) ;
    {
    TN( tMyLanName , "" ) ;

    }
        etThread.delF( tin0P , pstts ) ;
        }
            etThread.strWordsF( tin0P , pstt1LanRoster , pstts , sttq , T(" ,") ) ; ___( pstt1LanRoster ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            etThread.strConvertToLowerCaseF( tin0P , pstts ) ;
        {
        if( pstts )
        ZE( strokeS* , pstts ) ; etThread.querySettingF( tin0P , pstts , T("!ipdos.glass2.lan.roster")  ) ; ___( pstts ) ;
        _IO_
    {
    ZE( strokeS* , pstt1LanRoster ) ;

    }
        etThread.boxPutF( tin0P , tFileSlowAllOff , tSay , tSay.csF( tin0P ) + 1 ) ;
        TN( tSay , "To tell IdeaFarm (tm) Glass2 to slowAll, move this file from the \"off\" folder to the \"on\" folder.\r\nTo suppress slowingAll, move this file back to the \"off\" folder.\r\nThe contents of this file have no effect." ) ;
    {
    )
        && !etThread.diskFileExistsF( tin0P , tFileSlowAllOff )
           !etThread.diskFileExistsF( tin0P , tFileSlowAllOn  )
    (
    if

    }
        }
            if( POOP ) POOPRqUIET
            ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileSlowingAll , 1 ) ;

            if( POOP ) POOPRqUIET
            ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileSlowAllOn , 1 ) ;

            SCOOPS
        {
        IFsCRATCHoK
    {
    //PERSONALITY: I ALWAYS DELETE THE ON SLOWaLL FILE ; TO GET THE SLOWING EFFECT, THE OPERATOR (OR ANOTHER PROCESS) MUST MOVE THE SLOWaLL FILE TO THE "ON" FOLDER EACH TIME I AM HIRED

    etThread.diskMakeDirIfNeededF( tin0P , tFileSlowAllOn  ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFileSlowAllOff ) ;
    TN( tFileSlowingAll       , ""  ) ; tFileSlowingAll       = tFolderControlsOn+T("/message.slowingAll.txt") ;
    TN( tFileSlowAllOn        , ""  ) ; tFileSlowAllOn        = tFolderControlsOn+T("/slowAll.txt") ;
    TN( tFileSlowAllOff       , ""  ) ; tFileSlowAllOff       = tFolderControlsOff+T("/slowAll.txt") ;

    TN( tSlowByHostNameSuffix , "/d/ideafarm.home.101/controls/slowByHostName.txt" ) ;

    TN( tFolderControlsOn        , ""  ) ; tFolderControlsOn        = T("///ideafarm/controls/")+tUser+T("/on/") ;
    TN( tFolderControlsOff       , ""  ) ; tFolderControlsOff       = T("///ideafarm/controls/")+tUser+T("/off/") ;

    TN( tUser , thirdC::postUserNameIF() ) ;
    TN( tSlash , "/" ) ;
    TN( tb4    , "    " ) ;

    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    //etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE ) ;

    countT& cNewBreakNapsTakenP = *(countT*)pTaskP->c4 ;
    stackC& stOsPidP            = *(stackC*)pTaskP->c3 ;
    boolT&  bSlowAllP           =  *(boolT*)pTaskP->c2 ;
    boolT&  bQuitSlowingAllP    =  *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmSlowAllF )

DONE( tmTakeBreaksF )
}
    bQuitTakingBreaksP = 0 ;

    }
        etRock.traceF( tin0P , T("U:: / 0") ) ;
        ++ s ; etThread.osSleepF( tin0P , TOCK << 2 ) ;         // THIS DELAY MUST BE LONG ENOUGH SO THAT ALL OF THE BREAKPOINT EXCEPTIONS THAT I HAVE DEMANDED HAVE BEEN SEEN BY MY HANDLER (SEE THE PRECEDING COMMENT)
        etRock.traceF( tin0P , T("U:: / 1") ) ;

        //WHEN GET HERE THEN MY HANDLER HAS REPORTED AS MANY BREAKPOINT EXCEPTIONS AS I HAVE DEMANDED ; THIS CAN BE PREMATURE IF THE TARGET PROCESS RAISES A BREAKPOINT EXCEPTION FOR SOME OTHER REASON THAT IS ERRONEOUSLY COUNTED IN cNewBreakNapsTakenP

        }
            //etRock.traceF( tin0P , T("U:: / 1.0") ) ;
            while( ~hWalk ) ;
            }
                //etRock.traceF( tin0P , T("U:: / 1.1") ) ;
                if( !ids ) stOsPidDone.extractF( 0 , tin0P ) ;                      // IF THE TARGET PROCESS IS GONE THEN REMOVE IT FROM THE "DONE" STACK
                //etRock.traceF( tin0P , T("U:: / 1.2") ) ;
                stOsPidP.sinkF( tin0P , ids , osPid , flSTACKsINK_QUERY ) ;
                //etRock.traceF( tin0P , T("U:: / 1.3") ) ;
                ZE( countT , ids ) ;
                //etRock.traceF( tin0P , T("U:: / 1.4") ) ;

                countT osPid = stOsPidDone.downF( tin0P , hWalk ) ;
                //etRock.traceF( tin0P , T("U:: / 1.5") ) ;
            {
            do
            handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            //etRock.traceF( tin0P , T("U:: / 1.6") ) ;
            //etRock.traceF( tin0P , T("removing osPid values for processes that have ended so that i don't wait to see a breakpoint exception for them") ) ;

            etThread.osSleepF( tin0P , TOCK << 2 ) ;
            //etRock.traceF( tin0P , T("U:: / 1.7") ) ;
            ++ s ;
            //etRock.traceF( tin0P , T("U:: / 1.8") ) ;

            if( bOutahere ) break ;
            //etRock.traceF( tin0P , T("U:: / 1.9") ) ;
            boolT bOutahere = bQuitTakingBreaksP || cNewBreakNapsTakenP == cDone ;
            //etRock.traceF( tin0P , T("U:: / 1.a") ) ;
            countT cDone = stOsPidDone ;
            //etRock.traceF( tin0P , T("U:: / 1.b") ) ;
        {
        //while( !bQuitTakingBreaksP && cNewBreakNapsTakenP < stOsPidDone ) ;      // WHILE THE EVENT HANDLER HAS NOT SEEN ENOUGH BREAKPOINT EXCEPTIONS
        for(;;)
        etRock.traceF( tin0P , T("U:: / 2") ) ;

        stOsPidP.ungrabF( tin0P ) ;
        }
            while( ~hWalk ) ;
            }
                }
                    }
                        etRock.traceF( tin0P , T("!exception / breakpoint demand failed [rc,osPid]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    else
                    }
                        stOsPidDone.sinkF( tin0P , countTC() , osPid , flSTACKsINK_null , 0 , 0 ) ;
                        //etRock.traceF( tin0P , T("breakpoint demand aok [osPid]:    ")+TF2(osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( !POOP )

                    CloseHandle( osh ) ;

                    BOSpOOP
                    BOSS( WHATsir , BOSoK , DebugBreakProcess( osh ) )                  //A:ASSUME: EITHER THE TARGET PROCESS WILL END OR MY HANDLER WILL SEE A BREAKPOINT EXCEPTION

                    HANDLE osh = OpenProcess( PROCESS_ALL_ACCESS , 0 , osPid ) ;

                    SCOOPS
                {
                IFsCRATCHoK

                //etRock.traceF( tin0P , T("demanding breakpointi for [osPid]:    ")+TF2(osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                countT osPid = stOsPidP.downF( tin0P , hWalk ) ;
            {
            do
            handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , offo ) ;
            cNewBreakNapsTakenP = 0 ;

            _IO_
        {
        if( stOsPidP )
        stOsPidP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        etRock.traceF( tin0P , T("U:: / 3") ) ;

        stackC stOsPidDone( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_countT ) ;
        etRock.traceF( tin0P , T("U:: / 4") ) ;
    {
    while( !bQuitTakingBreaksP )
    etherC& etRock = etherC::etRockIF( tin0P ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    TN( tb4    , "    " ) ;

    //etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE ) ;

    countT& cNewBreakNapsTakenP = *(countT*)pTaskP->c3 ;
    stackC& stOsPidP            = *(stackC*)pTaskP->c2 ;
    boolT&  bQuitTakingBreaksP  =  *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmTakeBreaksF )

DONE( tmSuspendAllF )
}
    bSuspendAllP = 0 ;

    }
        if( POOP ) POOPRqUIET
        ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileSuspendingAll , 1 ) ;

        if( POOP ) POOPRqUIET
        ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileSuspendAllOn , 1 ) ;
        SCOOPS
    {
    IFsCRATCHoK

    etThread.delF( tin0P , pstt1LanRoster ) ;
    }
        ++ s ; etThread.osSleepF( tin0P , TOCK ) ;

        bSuspendingAllLag = bSuspendingAll ;
        bSuspendAllLag    = bSuspendAllP   ;

        }
            if( bSuspendingAll != bSuspendingAllLag ) etThread.traceF( tin0P , T("unsuspendingAll ; this will resume all processes that i am debugging") ) ;
            }
                if( POOP ) POOPRqUIET
                ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileSuspendingAll , 1 ) ;
                SCOOPS
            {
            IFsCRATCHoK
            bSuspendingAll = 0 ;
        {
        else
        }
            if( bSuspendingAll != bSuspendingAllLag ) etThread.traceF( tin0P , T("suspendingAll") ) ;
            etThread.boxPutF( tin0P , tFileSuspendingAll , tSay , tSay.csF( tin0P ) + 1 ) ;
            TN( tSay , "IdeaFarm (tm) Glass2 is currently suspendingAll." ) ;
            bSuspendingAll = 1 ;
        {
        if( bSuspendAllP )
        ZE( boolT , bSuspendingAll ) ;

        }
            if( bSuspendAllP != bSuspendAllLag ) etThread.traceF( tin0P , T("unsuspendingAll on request") ) ;
            bSuspendAllP = 0 ;
        {
        else
        }
            }
                stOsPidP.ungrabF( tin0P ) ;
                }
                    while( ~hWalk ) ;
                    }
                        }
                            }
                                etThread.traceF( tin0P , T("!exception / i was not able to suspend [rc,osPid]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                POOPRqUIET
                                countT rc = POOP ;
                            {
                            else
                            if( !POOP ) etThread.traceF( tin0P , T("suspended aok [osPid]:    ")+TF2(osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            CloseHandle( osh ) ;

                            BOSpOOP
                            BOSS( WHATsir , BOSoK , DebugBreakProcess( osh ) )

                            HANDLE osh = OpenProcess( PROCESS_ALL_ACCESS , 0 , osPid ) ;

                            SCOOPS
                        {
                        IFsCRATCHoK

                        etThread.traceF( tin0P , T("i would suspend this osPid now [osPid]:    ")+TF2(osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        countT osPid = stOsPidP.downF( tin0P , hWalk ) ;
                    {
                    do
                    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    ZE( countT , offo ) ;
                    _IO_
                {
                if( stOsPidP )
                stOsPidP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                etThread.traceF( tin0P , T("suspendingAll on request") ) ;
            {
            if( bSuspendAllP != bSuspendAllLag )
            bSuspendAllP = 1 ;
        {
        if( bFarCommandToSuspend || etThread.diskFileExistsF( tin0P , tFileSuspendAllOn ) )

        }
            bFarCommandToSuspendLathUpdate = bFarCommandToSuspend ;

            }
                etThread.delF( tin0P , posti ) ;
                }
                    }
                        }
                            bFarCommandToSuspend = 1 ;
                            etThread.traceF( tin0P , T("!exception / suspending all of the processes that i am debugging") ) ;
                        {
                        if( !etThread.strCompareF( tin0P , tMyLanName , tHisName ) || !etThread.strCompareF( tin0P , tHisName , tHisNameAll ) )
                        etThread.traceF( tin0P , T("!exception / i see a command to suspend a host [tMyLanName,tHisName]:    ")+tMyLanName+tb4+tHisName ) ;

                        TN( tHisName , posti ) ;
                    {
                    else
                    if( POOP ) POOPRqUIET

                    ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , tLong , 1 ) ; ___( posti ) ;

                    SCOOPS
                {
                IFsCRATCHoK
                ZE( countT   , costi ) ;
                ZE( osTextT* , posti ) ;

                //etThread.traceF( tin0P , T("scanning for a file named []:    ")+tLong ) ;
                TN( tLong , "" ) ; tLong = T("////")+T(psttc1)+tSuspendByHostNameSuffix ;
            {
            FORsTRINGSiN1( pstt1LanRoster )
        {
        else
        if( ++ idScan % 0x8 ) bFarCommandToSuspend = bFarCommandToSuspendLathUpdate ;                                                         // REDUCES NETWORK TRAFFIC AND DISK I/O
        ZE( boolT , bFarCommandToSuspend ) ;
    {
    while( !bQuitSuspendingAllP )
    ZE( boolT , bFarCommandToSuspendLathUpdate ) ;
    ZE( countT , idScan ) ;
    TN( tHisNameAll , "all" ) ;
    ZE( boolT , bSuspendingAllLag ) ;
    ZE( boolT , bSuspendAllLag ) ;

    }
        etThread.delF( tin0P , psttn ) ;
        tMyLanName = T(psttn) ;
        etThread.computerLanNameF( tin0P , psttn ) ; ___( psttn ) ;
        ZE( strokeS* , psttn ) ;
    {
    TN( tMyLanName , "" ) ;

    }
        etThread.delF( tin0P , pstts ) ;
        }
            etThread.strWordsF( tin0P , pstt1LanRoster , pstts , sttq , T(" ,") ) ; ___( pstt1LanRoster ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            etThread.strConvertToLowerCaseF( tin0P , pstts ) ;
        {
        if( pstts )
        ZE( strokeS* , pstts ) ; etThread.querySettingF( tin0P , pstts , T("!ipdos.glass2.lan.roster")  ) ; ___( pstts ) ;
        _IO_
    {
    ZE( strokeS* , pstt1LanRoster ) ;

    }
        etThread.boxPutF( tin0P , tFileSuspendAllOff , tSay , tSay.csF( tin0P ) + 1 ) ;
        TN( tSay , "To tell IdeaFarm (tm) Glass2 to suspendAll, move this file from the \"off\" folder to the \"on\" folder.\r\nTo suppress suspendingAll, move this file back to the \"off\" folder.\r\nThe contents of this file have no effect." ) ;
    {
    )
        && !etThread.diskFileExistsF( tin0P , tFileSuspendAllOff )
           !etThread.diskFileExistsF( tin0P , tFileSuspendAllOn  )
    (
    if

    }
        }
            if( POOP ) POOPRqUIET
            ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileSuspendingAll , 1 ) ;

            if( POOP ) POOPRqUIET
            ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileSuspendAllOn , 1 ) ;

            SCOOPS
        {
        IFsCRATCHoK
    {
    //PERSONALITY: I ALWAYS DELETE THE ON SUSPENDaLL FILE TO MINIMIZE POWER AND SSD UTILIZATION ; TO GET MINUTE REPORTS, THE OPERATOR MUST MOVE THE SUSPENDaLL FILE TO THE "ON" FOLDER EACH TIME I AM HIRED

    etThread.diskMakeDirIfNeededF( tin0P , tFileSuspendAllOn  ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFileSuspendAllOff ) ;
    TN( tFileSuspendingAll       , ""  ) ; tFileSuspendingAll       = tFolderControlsOn+T("/message.suspendingAll.txt") ;
    TN( tFileSuspendAllOn        , ""  ) ; tFileSuspendAllOn        = tFolderControlsOn+T("/suspendAll.txt") ;
    TN( tFileSuspendAllOff       , ""  ) ; tFileSuspendAllOff       = tFolderControlsOff+T("/suspendAll.txt") ;

    TN( tSuspendByHostNameSuffix , "/d/ideafarm.home.101/controls/suspendByHostName.txt" ) ;

    TN( tFolderControlsOn        , ""  ) ; tFolderControlsOn        = T("///ideafarm/controls/")+tUser+T("/on/") ;
    TN( tFolderControlsOff       , ""  ) ; tFolderControlsOff       = T("///ideafarm/controls/")+tUser+T("/off/") ;

    TN( tUser , thirdC::postUserNameIF() ) ;
    TN( tSlash , "/" ) ;
    TN( tb4    , "    " ) ;

    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    //etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE ) ;

    stackC& stOsPidP            = *(stackC*)pTaskP->c3 ;
    boolT&  bSuspendAllP        =  *(boolT*)pTaskP->c2 ;
    boolT&  bQuitSuspendingAllP =  *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmSuspendAllF )

DONE( tmChatterF )
}
    bChatterP = 0 ;

    }
        if( POOP ) POOPRqUIET
        ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileChattering , 1 ) ;

        if( POOP ) POOPRqUIET
        ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileChatterOn , 1 ) ;
        SCOOPS
    {
    IFsCRATCHoK

    }
        ++ s ; etThread.osSleepF( tin0P , TOCK ) ;

        bChatteringLag = bChattering ;
        bChatterLag  = bChatterP ;

        }
            if( bChattering != bChatteringLag ) etThread.traceF( tin0P , T("unchattering ; this will not affect chattering that is in progress") ) ;
            }
                if( POOP ) POOPRqUIET
                ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileChattering , 1 ) ;
                SCOOPS
            {
            IFsCRATCHoK
            bChattering = 0 ;
        {
        else
        }
            if( bChattering != bChatteringLag ) etThread.traceF( tin0P , T("chattering") ) ;
            etThread.boxPutF( tin0P , tFileChattering , tSay , tSay.csF( tin0P ) + 1 ) ;
            TN( tSay , "IdeaFarm (tm) Glass2 is currently chattering." ) ;
            bChattering = 1 ;
        {
        if( bChatterP )
        ZE( boolT , bChattering ) ;

        }
            if( bChatterP != bChatterLag ) etThread.traceF( tin0P , T("unchattering on request") ) ;
            bChatterP = 0 ;
        {
        else
        }
            if( bChatterP != bChatterLag ) etThread.traceF( tin0P , T("chattering on request") ) ;
            bChatterP = 1 ;
        {
        if( etThread.diskFileExistsF( tin0P , tFileChatterOn ) )
    {
    while( !bQuitChatteringP )
    ZE( boolT , bChatteringLag ) ;
    ZE( boolT , bChatterLag ) ;

    }
        etThread.boxPutF( tin0P , tFileChatterOff , tSay , tSay.csF( tin0P ) + 1 ) ;
        TN( tSay , "To tell IdeaFarm (tm) Glass2 to chatter, move this file from the \"off\" folder to the \"on\" folder.\r\nTo suppress chattering, move this file back to the \"off\" folder.\r\nThe contents of this file have no effect." ) ;
    {
    )
        && !etThread.diskFileExistsF( tin0P , tFileChatterOff )
           !etThread.diskFileExistsF( tin0P , tFileChatterOn  )
    (
    if

    }
        }
            if( POOP ) POOPRqUIET
            ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileChattering , 1 ) ;

            if( POOP ) POOPRqUIET
            ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tFileChatterOn , 1 ) ;

            SCOOPS
        {
        IFsCRATCHoK
    {
    //PERSONALITY: I ALWAYS DELETE THE ON CHATTER FILE TO MINIMIZE POWER AND SSD UTILIZATION ; TO GET MINUTE REPORTS, THE OPERATOR MUST MOVE THE CHATTER FILE TO THE "ON" FOLDER EACH TIME I AM HIRED

    etThread.diskMakeDirIfNeededF( tin0P , tFileChatterOn  ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFileChatterOff ) ;
    TN( tFileChattering    , ""  ) ; tFileChattering   = tFolderControlsOn+T("/message.chattering.txt") ;
    TN( tFileChatterOn     , ""  ) ; tFileChatterOn    = tFolderControlsOn+T("/chatter.txt") ;
    TN( tFileChatterOff    , ""  ) ; tFileChatterOff   = tFolderControlsOff+T("/chatter.txt") ;

    TN( tFolderControlsOn  , ""  ) ; tFolderControlsOn  = T("///ideafarm/controls/")+tUser+T("/on/") ;
    TN( tFolderControlsOff , ""  ) ; tFolderControlsOff = T("///ideafarm/controls/")+tUser+T("/off/") ;

    TN( tUser , thirdC::postUserNameIF() ) ;
    TN( tSlash , "/" ) ;

    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    boolT&  bChatterP        = *(boolT*)pTaskP->c2 ;
    boolT&  bQuitChatteringP = *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmChatterF )

#endif

    DONE( tmGorillasRawF )
    }
        }
            ++ s ; ether.osSleepF( tin0P , TOCK << 1 ) ;
    
            }
                }
                    LOGrAW3( "[idError]: " , idError , "\r\n" ) ;
                    countT idError = ((tin1S&)tin0P).brcRaw ;
                    BOSdOnOTtEST( WHATgbo , GetLastError() )
                {
                else
                }
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , CloseHandle( oshThread ) )
                {
                if( oshThread )
                HANDLE oshThread = (HANDLE)((tin1S&)tin0P).brcRaw ;
                BOSpOOP
                BOS( WHATgbo , BOSoK , CreateThread( &sa , TOCK , tmGorillaRawF , 0 , 0 , &osTid ) )
                ZE( DWORD , osTid ) ;
                BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                SECURITYaTTRIBUTE_saUNRESTRICTED( 0 ) ;
            {
            while( cDo -- )
            countT cDo = TUCK >> 4 ;
        {
        while( !ether && !POOP )
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    {
    if( pTaskP )
    TASK( tmGorillasRawF )
    }
        return 0 ;
    {
    DWORD WINAPI tmGorillaRawF( VOID* pvP )
    //U::REMOVE IN PRODUCTON ; THIS IS FOR RESOURCE LEAK TESTING

DONE( tmKillYourselfImmediatelyF )

BLAMMO ;
home.flags |= flHOMEs_KILLsELFiMMEDIATELY ;
etThread.traceF( tin0P , T("setting flHOMEs_KILLsELFiMMEDIATELY") ) ;

}
    ++ s ; ether.osSleepF( tin0P , TICK << 3 ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
{

etThread.emailFactoryReportF( tin0P , T("dying in 1/2 hour") ) ;

}
    ++ s ; ether.osSleepF( tin0P , TICK << 7 ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    if( !cDo ) etThread.emailFactoryReportF( tin0P , T("dying in 1/2 day") ) ;
{
while( cDo -- )
countT cDo = 8 ;

homeS& home = homeS::homeIF() ;

//etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE ) ;

TASK( tmKillYourselfImmediatelyF )
    
DONE( tmTestImpotenceF )

}
    __1
    etThread.emailFactoryReportF( tin0P , T("testing impotence") ) ;
{
if( !ether )

++ s ; ether.osSleepF( tin0P , TOCK << 4 ) ;
sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

etThread.emailFactoryReportF( tin0P , T("i will test impotence after napping TOCK << 4") ) ;

TASK( tmTestImpotenceF )

#if defined( NEVERdEFINED )

DONE( tmFireMyselfF )
YELL( "cleaning up")
FIREmYSELF ;
//CONoUTrAW( "firing myself\r\n" ) ;
YELL( "firing myself")
}
    //++ s ; ether.osSleepF( tin0P , TOCK * 0xd /*, 0 , flSLEEP_TALK*/ ) ;
    ++ s ; ether.osSleepF( tin0P , TOCK * 0x8 /*, 0 , flSLEEP_TALK*/ ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
{
YELL( "napping before firing myself")
//etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_SPINLOCK ) ;
TASK( tmFireMyselfF )

DONE( tmFireAllF )
//CONoUTrAW( "tmFireAllF/-" ) ; //U::

}
    }
        }
            }
                }
                    ++ s ; etThread.osSleepF( tin0P , TOCK >> 0 ) ; //PRESUMED DEAD IF NO CHANGE DURING THIS INTERVAL AND !bKidsSuspendedP
                    //20240331@1737: >> 2 ----> >> 0

                    }
                        cHeartBeatsLag = cHeartBeatsNow ;

                        }
                            }
                                etRock.traceF( tin0P , T("some beating hearts remain [idg,cHearts,cHeartBeatsNow,cHeartBeatsLag]:    ")+TF2(idg,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(cHearts,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(cHeartBeatsNow,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(cHeartBeatsLag,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                            {
                            else
                            }
                                break ;

                                //U:: EDIT THIS CODE TO IGNORE UNCHANGED HEARTbEATS IF A DEBUGGING EVENT HAS OCCURRED (WHICH WOULD SUSPEND EXECUTION)

                                etRock.traceF( tin0P , T("some hearts remain but none of them are beating [idg,cHearts,cHeartBeatsNow,cHeartBeatsLag]:    ")+TF2(idg,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(cHearts,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(cHeartBeatsNow,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(cHeartBeatsLag,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                            {
                            else if( cHeartBeatsNow == cHeartBeatsLag )
                            }
                                break ;
                                etRock.traceF( tin0P , T("0 hearts remain [idg]:    ")+TF2(idg,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                            {
                            if( !cHearts )
                            countT cHearts = home.pFireAll[ idg - 1 ].cHearts ;
                        {
                        if( cHeartBeatsLag )
                    {
                    if( !bKidsSuspendedP )

                    countT cHeartBeatsNow = home.pFireAll[ idg - 1 ].cHeartBeats ;

                    }
                        break ;
                        etRock.traceF( tin0P , T("etThread is impotent") ) ;
                    {
                    if( etThread )

                    }
                        break ;
                        etRock.traceF( tin0P , T("POOP is set") ) ;
                    {
                    if( POOP )
                {
                for(;;)
                ZE( countT , cHeartBeatsLag ) ;
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                etThread.etherFireGroupIF( tin0P , idg ) ;
                etThread.traceF( tin0P , T("firing group ")+TF1(idg) ) ;

                etRock.traceF( tin0P , T("firing group by setting home.pFireAll[ idg - 1 ].bFire [idg]:    ")+TF2(idg,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                //CONoUTrAW3( "firing group " , idg , "\r\n" ) ;
            {
            if( home.pFireAll[ idg - 1 ].cHearts && home.pFireAll[ idg - 1 ].cHeartBeats )
        {
        for( countT idg = 1 ; idg <= CfIREaLLrANKS - 3 ; idg ++ ) //I DO NOT FIRE THE HIGHEST RE GROUPS, WHICH ARE USED BY CLOAK AND GLASS1 AND ME
        homeS& home = homeS::homeIF() ;
    {
    //CODE SYNC: ec40104 ME
    
    TN( tb , " " ) ;
    TN( tc , "\r\n" ) ;

    }
        }
            etThread.boxPutF( tin0P , T("///desk/IdeaFarm " "(tm) Warning (disabled).txt") , postNote , sizeof postNote - 1 ) ;

            } ;

                "Thank you for using IPDOS (tm).\r\n"
                "\r\n"
                "a current version.  This version has been disabled.\r\n"
                "An old version of IPDOS (tm) is active on this computer.  Please download\r\n"
                "\r\n"
                "http://ideafarm.com\r\n"
                "IPDOS (tm)\r\n"
                postIPDOSlONG "\r\n"
            {
            osTextT postNote[] =
        {
        if( home.idVersionIpdosMe && home.idVersionIpdosBan && home.idVersionIpdosMe <= home.idVersionIpdosBan )

        //home.flags |= flHOMEs_SUPPRESStELLS ;

        //etRock.traceF( tin0P , T("tmFireAllF called  FIREmYSELF") ) ;
        FIREmYSELF ;
        //etRock.traceF( tin0P , T("tmFireAllF calling FIREmYSELF") ) ;

        //}
        //    etRock.traceF( tin0P , T("tmFireAllF/ perhaps connected to idPortGlass2") ) ;
        //    sockm.connectF( tin0P , home.idPortGlass2 , socketC::nicNameIF( tin0P , etThread , T("10.1.1.1") ) ) ;
        //    socketC sockm( tin0P , etThread , TAG( TAGiDnULL ) ) ;
        //
        //    etRock.traceF( tin0P , T("tmFireAllF/ awakened ; connecting to idPortGlass2: ")+TF2(home.idPortGlass2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
        //{   //20160419@1731: ADDED THIS BLOCK AND REMOVED idpKiller VARIABLE WHICH WAS NOT USED; DONE TO FIX QUIT QUALITY ; CONJ: THIS BLOCK WAS ACCIDENTALLY DELETED
        //THIS IS NOT NEEDED BECAUSE sListen IS A QUITTER SOCKET SO tmWatchF WILL CONNECT TO IT

        //etRock.traceF( tin0P , T("tmFireAllF stopped napping") ) ;

        }
            ether.osSleepF( tin0P , TOCK >> 3 ) ;
            //etThread.traceF( tin0P , T("U::tock") ) ;
        {
        )
            //&& cDo --
            && ( !home.idVersionIpdosBan || !home.idVersionIpdosMe || home.idVersionIpdosBan < home.idVersionIpdosMe )
            && !( F(home.flags) & flHOMEs_FIREtHIShOME )
            && !( slab.flagsi & fliSLABs_QUIT )
            && !etThread
            !ether
        (
        while
        //countT cDo = TUCK >> 4 ;

        //etRock.traceF( tin0P , T("tmFireAllF is napping; wake me up by setting flHOMEs_FIREtHIShOME") ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        homeS& home = homeS::homeIF() ;
        slabS& slab = slabS::slabIF() ;
    {

    //U::if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_NOsYSTEMtHREADS ) ) { __( ((tin1S&)tin0P).glass.idThread - ifcIDtHREADlOW_tmFireAllF ) ; }
    etherC& etRock = etherC::etRockIF( tin0P ) ;

    boolT& bKidsSuspendedP = *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmFireAllF )

DONE( tmEatTelemetrySysF )
//etRock.traceF( tin0P , T("0") ) ;
TELL( "cleaning up 0" )
}
    //etRock.traceF( tin0P , T("1 [idMemorySpaceP,cKidThreads]: ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    TELL( "cleaning up 1" )
    }
        while( ~hWalk && -- cToDo ) ;
        }
            stPeriodData.extractF( 0 , tin0P ) ;
            DELzOMBIE( ppd ) ;
            periodDataS* ppd = (periodDataS*)&stPeriodData.upF( tin0P , hWalk ) ;
        {
        do
        handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        countT cToDo = stPeriodData ;
        _IO_
    {
    if( stPeriodData )
    TELL( "purging period data" )

    //etRock.traceF( tin0P , T("2 / sgnDone_tmReportF_ seen [idMemorySpaceP,cKidThreads]: ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    sgnDone_tmReportF_.waitF( tin0P ) ;
    //etRock.traceF( tin0P , T("3 [idMemorySpaceP,cKidThreads]: ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    TELL( "waiting for tmReportF to end" )

    THREADmODE3rESTORE
    //etRock.traceF( tin0P , T("4 [idMemorySpaceP,cKidThreads]: ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    }
        //etRock.traceF( tin0P , T("5 [idMemorySpaceP,cKidThreads]: ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        if( idMemorySpaceP == ifcIDmEMORYsPACE_GLASS2 ) bksTelemetrySys.fileFlagsRefF() &= ~flFILEc_DELETE ; // I AM PROBABLY READING THE CURRENT bookC, WHICH IS STILL OPEN FOR WRITING SO CANNOT BE DELETED NOW
        //U::THE NEXT LINE NO LONGER WILL WORK BECAUSE THE DELETE FLAG HAS ALREADY BEEN SPECIFIED WHEN CT fileC ; IT ALSO WOULDN'T WORK BECAUSE IT DOES NOT CHANGE THE FLAGS THAT ARE USED TO CT bookC INSTANCE

        }
            //etRock.traceF( tin0P , T("6 [idMemorySpaceP,cKidThreads]: ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            }
                //CONoUTrAW( "." ) ;
                  ++ s ; etThread.osSleepF( tin0P , TOCK << 4 ) ;
                //++ s ; etThread.osSleepF( tin0P , TOCK >> 2 ) ;
                TELL( "napping for a quarter tock" )
            
                if( bQuitEatingP ) break ;

                }
                    bBookHead = !bBookHead ;
            
                    }
                        else          pbi = 0 ;
                        if( bDelete ) PUSE( tin0P , *(byteT**)&pbi ) ;
                        TELL( "maybe deleting hamburger" )
            
                        }
                            cbi = sizeof( telemetryBookHeadS ) ;
    
                            }
                                }
                                    }
                                        break ;
                                        }    
                                            }
                                                memorySpace.grab.ungrabF( tin0P ) ;
                                                //etRock.traceF( tin0P , T("after  ++++ [swsProcessGlobal3.cFlavors,swsProcessGlobal3] :    ")+TF2(memorySpace.swsProcessGlobal3.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsProcessGlobal3,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etRock.traceF( tin0P , T("swsProcessGlobal3 ++++ [cPlatesNew]:    ")+TF2(memorySpace.swsProcessGlobal3,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                memorySpace.swsProcessGlobal3.sinkF( tin0P , countTC() , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_processGlobal4EntryS_F ) ;
                                                //etRock.traceF( tin0P , T("before ++++ [swsProcessGlobal3.cFlavors,swsProcessGlobal3] :    ")+TF2(memorySpace.swsProcessGlobal3.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsProcessGlobal3,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , note.osPid , 0 } ;
                                                memorySpace.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                
                                                processGlobal4EntryS entry( tin0P , note.osPid , note.pbEarlyGrain , note.cGrains ) ;
                                            {
                                            tellInfoSysProcessGlobal1S& note = *(tellInfoSysProcessGlobal1S*)pbNote ;
                                        {
                                        if( told.cbNote == sizeof( tellInfoSysProcessGlobal1S ) )
                                        TELL( "ifcIDtYPEtELLsYS_PROCESSgLOBAL3scT" )
                                        _IO_
                                    {
                                    case ifcIDtYPEtELLsYS_PROCESSgLOBAL1scT :
                                    }
                                        break ;
                                        }    
                                            }
                                                memorySpace.grab.ungrabF( tin0P ) ;
                                                //etRock.traceF( tin0P , T("after  ---- [swsNapkin.cFlavors,swsNapkin] :    ")+TF2(memorySpace.swsNapkin.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsNapkin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                }
                                                    //etRock.traceF( tin0P , T("error: entry not found in swsNapkin") ) ;
                                                    _IO_
                                                {
                                                else
                                                }
                                                    if( !memorySpace.swsNapkin ) memorySpace.swsNapkin.freeF( tin0P ) ;
                                                    memorySpace.swsNapkin.extractF( 0 , tin0P ) ;
                                                    //etRock.traceF( tin0P , T("swsNapkin ---- [cPlatesOld,ids]:    ")+TF2(memorySpace.swsNapkin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ids,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( ids )
                                                memorySpace.swsNapkin.sinkF( tin0P , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_napkinEntryS_F ) ;
                                                //etRock.traceF( tin0P , T("before ---- [swsNapkin.cFlavors,swsNapkin] :    ")+TF2(memorySpace.swsNapkin.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsNapkin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , note.osPid , 0 } ;
                                                memorySpace.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                ZE( countT , ids ) ;
                        
                                                napkinEntryS entry( tin0P , note.osPid , note.postName , note.pbData , note.cbData , note.idLineCt , note.idiFileCt ) ;
                                            {
                                            tellInfoSysNapkinS& note = *(tellInfoSysNapkinS*)pbNote ;
                                        {
                                        if( told.cbNote == sizeof( tellInfoSysNapkinS ) )
                                        TELL( "ifcIDtYPEtELLsYS_NAPKINfORMAT ifcIDtYPEtELLsYS_NAPKINaTTACH" )
                                        _IO_
                                    {
                                    case ifcIDtYPEtELLsYS_NAPKINdETACH :
                                    }
                                        break ;
                                        }    
                                            }
                                                memorySpace.grab.ungrabF( tin0P ) ;
                                                //etRock.traceF( tin0P , T("after  ++++ [swsNapkin.cFlavors,swsNapkin] :    ")+TF2(memorySpace.swsNapkin.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsNapkin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etRock.traceF( tin0P , T("swsNapkin ++++ [cPlatesNew]:    ")+TF2(memorySpace.swsNapkin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                memorySpace.swsNapkin.sinkF( tin0P , countTC() , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_napkinEntryS_F ) ;
                                                //etRock.traceF( tin0P , T("before ++++ [swsNapkin.cFlavors,swsNapkin] :    ")+TF2(memorySpace.swsNapkin.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsNapkin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , note.osPid , 0 } ;
                                                memorySpace.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                
                                                napkinEntryS entry( tin0P , note.osPid , note.postName , note.pbData , note.cbData , note.idLineCt , note.idiFileCt ) ;
                                            {
                                            tellInfoSysNapkinS& note = *(tellInfoSysNapkinS*)pbNote ;
                                        {
                                        if( told.cbNote == sizeof( tellInfoSysNapkinS ) )
                                        TELL( "ifcIDtYPEtELLsYS_NAPKINfORMAT ifcIDtYPEtELLsYS_NAPKINaTTACH" )
                                        _IO_
                                    {
                                    case ifcIDtYPEtELLsYS_NAPKINaTTACH :
                                    case ifcIDtYPEtELLsYS_NAPKINfORMAT :
                                    }
                                        break ;
                                        }    
                                            }
                                                memorySpace.grab.ungrabF( tin0P ) ;
                                                //etRock.traceF( tin0P , T("after  ---- [swsSex.cFlavors,swsSex] :    ")+TF2(memorySpace.swsSex.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsSex,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                }
                                                    //etRock.traceF( tin0P , T("error: entry not found in swsSex") ) ;
                                                    _IO_
                                                {
                                                else
                                                }
                                                    if( !memorySpace.swsSex ) memorySpace.swsSex.freeF( tin0P ) ;
                                                    memorySpace.swsSex.extractF( 0 , tin0P ) ;
                                                    //etRock.traceF( tin0P , T("swsSex ---- [cPlatesOld,ids]:    ")+TF2(memorySpace.swsSex,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(ids,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( ids )
                                                memorySpace.swsSex.sinkF( tin0P , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_sexEntryS_F ) ;
                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                //etRock.traceF( tin0P , T("before ---- [swsSex.cFlavors,swsSex] :    ")+TF2(memorySpace.swsSex.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsSex,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , note.osPid , 0 } ;
                                                memorySpace.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                ZE( countT , ids ) ;
                        
                                                sexEntryS entry( tin0P , note.osPid , note.postName , note.expCbDrop , note.expSlots , note.pSex , note.idLineCt , note.idiFileCt ) ;
                                            {
                                            tellInfoSysSexS& note = *(tellInfoSysSexS*)pbNote ;
                                        {
                                        if( told.cbNote == sizeof( tellInfoSysSexS ) )
                                        TELL( "SEXdT" )
                                        _IO_
                                    {
                                    case ifcIDtYPEtELLsYS_SEXdT :
                                    }
                                        break ;
            
                                        }
                                            }
                                                memorySpace.grab.ungrabF( tin0P ) ;
                                                //etRock.traceF( tin0P , T("swsSex ++++ [cPlatesNew]:    ")+TF2(memorySpace.swsSex,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                //etRock.traceF( tin0P , T("after  ++++ [swsSex.cFlavors,swsSex] :    ")+TF2(memorySpace.swsSex.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsSex,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                memorySpace.swsSex.sinkF( tin0P , countTC() , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_sexEntryS_F ) ;
                                                //etRock.traceF( tin0P , T("before ++++ [swsSex.cFlavors,swsSex] :    ")+TF2(memorySpace.swsSex.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsSex,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , note.osPid , 0 } ;
                                                memorySpace.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                
                                                sexEntryS entry( tin0P , note.osPid , note.postName , note.expCbDrop , note.expSlots , note.pSex , note.idLineCt , note.idiFileCt ) ;
                                            {
            
                                            tellInfoSysSexS& note = *(tellInfoSysSexS*)pbNote ;
                                        {
                                        if( told.cbNote == sizeof( tellInfoSysSexS ) )
                                        TELL( "SEXcT" )
                                        _IO_
                                    {
                                    case ifcIDtYPEtELLsYS_SEXcT :
                                    }
                                        break ;
                                        }    
                                            }
                                                //LOGrAW5( "TINdTP [cFlavors,cPlatesAll]:" , memorySpace.swsTin.cFlavorsF( tin0P ) , " " , memorySpace.swsTin.cPlatesAllF( tin0P ) , "\r\n" ) ;

                                                //}
                                                //    CONoUTrAW( ostoSay ) ;
                                                //
                                                //    OStEXTAK( ostoSay , "\"\r\n" ) ;
                                                //    OStEXTA(  ostoSay , entry.postThreadName ) ;
                                                //    OStEXTAK( ostoSay , " , \"" ) ;
                                                //    OStEXTC(  ostoSay , entry.osTid , 0 ) ;
                                                //    OStEXTAK( ostoSay , " , " ) ;
                                                //    OStEXTC(  ostoSay , entry.idTin , 0 ) ;
                                                //    OStEXTAK( ostoSay , " , " ) ;
                                                //    OStEXTC(  ostoSay , entry.idThread , 0 ) ;
                                                //    OStEXTAK( ostoSay , "- [idThread,idTin,osTid,postThreadName]: " ) ;
                                                //    OStEXT(  ostoSay , TUCK ) ;
                                                //{
                                                //if( !etThread.strCompareF( tin0P , T(entry.postThreadName) , T("tm1F") ) )
        
                                                memorySpace.grab.ungrabF( tin0P ) ;

                                                //etRock.traceF( tin0P , T("after  ---- [swsTinWhere.cFlavors,swsTinWhere] :    ")+TF2(memorySpace.swsTinWhere.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTinWhere,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etRock.traceF( tin0P , T("after  ---- [swsTin.cFlavors     ,swsTin     ] :    ")+TF2(memorySpace.swsTin.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etRock.traceF( tin0P , T("after ---- swsTin [cPlates,pczLeverAdam]:    ")+TF2(memorySpace.swsTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(memorySpace.pczLeverAdam) ) ;

                                                }
                                                    //etRock.traceF( tin0P , T("error: entrty not found in swsTinWhere") ) ;
                                                    _IO_
                                                {
                                                else
                                                }
                                                    if( !memorySpace.swsTinWhere ) memorySpace.swsTinWhere.freeF( tin0P ) ;
                                                    memorySpace.swsTinWhere.extractF( 0 , tin0P ) ;
                                                {
                                                if( ids )
                                                memorySpace.swsTinWhere.sinkF( tin0P , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_tinEntryS_F ) ;
                                                ids = 0 ; // memorySpace.swsTin memorySpace.swsTinWhere ARE REDUNDANT SO THAT tmWhereF tmWhereRptF DO NOT TOUCH THE stackC OBJECT THAT tmRptMainF USES

                                                //}
                                                //    while( !ether && ~hDown ) ;
                                                //    }
                                                //        if( !etThread.strCompareF( tin0P , T("tmHireF") , T(note.postThreadName) ) ) etRock.traceF( tin0P , T("w  [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(wo.idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                //        tinEntryS& wo = *(tinEntryS*)&memorySpace.swsTin.downF( tin0P , hDown ) ;
                                                //    {
                                                //    do
                                                //    handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                //{
                                                //if( !etThread.strCompareF( tin0P , T("tmHireF") , T(note.postThreadName) ) )

                                                }
                                                    //etRock.traceF( tin0P , T("error: tin123S destruction told but entry not found in swsTin [idThread,postThreadName]: ")+TF2(told.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                    _IO_
                                                {
                                                else
                                                }
                                                    if( !memorySpace.swsTin ) memorySpace.swsTin.freeF( tin0P ) ;
                                                    memorySpace.swsTin.extractF( 0 , tin0P ) ;
                                                    //if( !etThread.strCompareF( tin0P , T("tmHireF") , T(note.postThreadName) ) ) etRock.traceF( tin0P , T("-- [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(entry.idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                {
                                                if( ids )
                                                memorySpace.swsTin.sinkF( tin0P , ids , (byteT*)&entry , flSTACKsINK_QUERY , subtract_tinEntryS_F ) ;

                                                //}
                                                //    while( !ether && ~hDown ) ;
                                                //    }
                                                //        if( !etThread.strCompareF( tin0P , T("tmHireF") , T(note.postThreadName) ) ) etRock.traceF( tin0P , T("w  [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(wo.idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                //        tinEntryS& wo = *(tinEntryS*)&memorySpace.swsTin.downF( tin0P , hDown ) ;
                                                //    {
                                                //    do
                                                //    handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                //{
                                                //if( !etThread.strCompareF( tin0P , T("tmHireF") , T(note.postThreadName) ) )

                                                //etRock.traceF( tin0P , T("before ---- [swsTinWhere.cFlavors,swsTinWhere] :    ")+TF2(memorySpace.swsTinWhere.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTinWhere,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etRock.traceF( tin0P , T("before ---- [swsTin.cFlavors     ,swsTin     ] :    ")+TF2(memorySpace.swsTin.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , told.osPid , told.idThread , 0 } ;
                                                memorySpace.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                ZE( countT , ids ) ;
                        
                                                //}
                                                //    etRock.traceF( tin0P , T("thread    ")+TF2(told.idThread,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+T(note.postThreadName)+T("    ----") ) ;
                                                //    _IO_
                                                //{
                
                                                //if( !etThread.strCompareF( tin0P , T("tmHireF") , T(note.postThreadName) ) ) etRock.traceF( tin0P , T("-  [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(entry.idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                tinEntryS entry( tin0P , note.idSerial , told.osTid , told.osPid , told.idType == ifcIDtYPEtELLsYS_TINdTI , note.ip , note.idTin , told.idThread , note.postThreadName , note.idTinNamed , note.idLineCt , note.idiFileCt ) ;
                                            {

                                            }
                                                stOsPidFromTinP.ungrabF( tin0P ) ;
                                                }
                                                    stOsPidFromTinP.extractF( 0 , tin0P ) ;
                                                    etThread.traceF( tin0P , T("deregistering IPDOS (tm) process 1 [osPid]:    ")+TF2(told.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( ids )
                                                stOsPidFromTinP.sinkF( tin0P , ids , told.osPid , flSTACKsINK_QUERY , 0 , 0 ) ;
                                                stOsPidFromTinP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                                ZE( countT , ids ) ;

                                                stOsPidFromTinZombieP.sinkF( tin0P , countTC() , told.osPid , flSTACKsINK_null , 0 , 0 ) ;
                                            {
                                            if( note.idTinNamed == ifcIDtINnAMED_tin9VeryEarlyLateMainI )

                                            tellInfoSysTinS& note = *(tellInfoSysTinS*)pbNote ;
                                            //etRock.traceF( tin0P , T("ifcIDtYPEtELLsYS_TINdTP/I") ) ;

                                            _IO_
                                        {
                                        if( told.cbNote == sizeof( tellInfoSysTinS ) )
                                        TELL( "TINdTI TINdTP" )
                                        _IO_
                                    {
                                    case ifcIDtYPEtELLsYS_TINdTP :
                                    case ifcIDtYPEtELLsYS_TINdTI :
                                    }
                                        break ;
            
                                        }
                                            }
                                                //etRock.traceF( tin0P , T("U::: tin123S ct told [&told,idThread,postThreadName]: ")+TF2((countT)&told,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(told.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                //LOGrAW5( "TINcTP [cFlavors,cPlatesAll]:" , memorySpace.swsTin.cFlavorsF( tin0P ) , " " , memorySpace.swsTin.cPlatesAllF( tin0P ) , "\r\n" ) ;

                                                //}
                                                //    CONoUTrAW( ostoSay ) ;
                                                //
                                                //    OStEXTAK( ostoSay , "\"\r\n" ) ;
                                                //    OStEXTA(  ostoSay , entry.postThreadName ) ;
                                                //    OStEXTAK( ostoSay , " , \"" ) ;
                                                //    OStEXTC(  ostoSay , entry.osTid , 0 ) ;
                                                //    OStEXTAK( ostoSay , " , " ) ;
                                                //    OStEXTC(  ostoSay , entry.idTin , 0 ) ;
                                                //    OStEXTAK( ostoSay , " , " ) ;
                                                //    OStEXTC(  ostoSay , entry.idThread , 0 ) ;
                                                //    OStEXTAK( ostoSay , "+ [idThread,idTin,osTid,postThreadName]: " ) ;
                                                //    OStEXT(  ostoSay , TUCK ) ;
                                                //{
                                                //if( !etThread.strCompareF( tin0P , T(entry.postThreadName) , T("tm1F") ) )
        
                                                memorySpace.grab.ungrabF( tin0P ) ;

                                                //}
                                                //    while( !ether && ~hDown ) ;
                                                //    }
                                                //        if( !etThread.strCompareF( tin0P , T("tmHireF") , T(note.postThreadName) ) ) etRock.traceF( tin0P , T("w  [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(wo.idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(wo.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ;
                                                //        tinEntryS& wo = *(tinEntryS*)&memorySpace.swsTin.downF( tin0P , hDown ) ;
                                                //    {
                                                //    do
                                                //    handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                //{
                                                //if( !etThread.strCompareF( tin0P , T("tmHireF") , T(note.postThreadName) ) )

                                                //etRock.traceF( tin0P , T("after  ++++ [swsTinWhere.cFlavors,swsTinWhere] :    ")+TF2(memorySpace.swsTinWhere.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTinWhere,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etRock.traceF( tin0P , T("after  ++++ [swsTin.cFlavors     ,swsTin     ] :    ")+TF2(memorySpace.swsTin.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etRock.traceF( tin0P , T("after ++++ swsTin [cPlates,pczLeverAdam]:    ")+TF2(memorySpace.swsTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(memorySpace.pczLeverAdam) ) ;

                                                memorySpace.swsTinWhere.sinkF( tin0P , countTC() , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_tinEntryS_F ) ;

                                                //else     { etRock.traceF( tin0P , T("++ [idSerial,bIda,ip,idTin,idThread,postThreadName]: ")+TF2(entry.idSerial,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.bIda,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.ip,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.idTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(entry.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(note.postThreadName) ) ; }
                                                if( !ids ) { BLAMMO ; }
                                                memorySpace.swsTin.sinkF( tin0P , ids , (byteT*)&entry , flSTACKsINK_UNIQUE , subtract_tinEntryS_F ) ;
                                                ZE( countT , ids ) ;

                                                //etRock.traceF( tin0P , T("before ++++ [swsTinWhere.cFlavors,swsTinWhere] :    ")+TF2(memorySpace.swsTinWhere.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTinWhere,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etRock.traceF( tin0P , T("before ++++ [swsTin.cFlavors     ,swsTin     ] :    ")+TF2(memorySpace.swsTin.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(memorySpace.swsTin,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                                //etRock.traceF( tin0P , T("before ++++ swsTin [cPlates,pczLeverAdam]:    ")+TF2(memorySpace.swsTin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(memorySpace.pczLeverAdam) ) ;

                                                memorySpace.pczLeverAdam = pczLeverAdamMe ;
                                                countT pczLeverAdamMe[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , told.osPid , told.idThread , 0 } ;
                                                memorySpace.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                                                //}
                                                //    etRock.traceF( tin0P , T("thread    ")+TF2(told.idThread,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+T(note.postThreadName)+T("    ++++") ) ;
                                                //    _IO_
                                                //{
                
                                                tinEntryS entry( tin0P , note.idSerial , told.osTid , told.osPid , told.idType == ifcIDtYPEtELLsYS_TINcTI , note.ip , note.idTin , told.idThread , note.postThreadName , note.idTinNamed , note.idLineCt , note.idiFileCt ) ;
                                                _IO_
                                            {

                                            }
                                                stOsPidFromTinP.sinkF( tin0P , countTC() , told.osPid , flSTACKsINK_null , 0 , 0 ) ;
                                                etThread.traceF( tin0P , T("registering IPDOS (tm) process [osPid]:    ")+TF2(told.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            if( note.idTinNamed == ifcIDtINnAMED_tin9VeryEarlyLateMainI )

                                            tellInfoSysTinS& note = *(tellInfoSysTinS*)pbNote ;
                                            //etRock.traceF( tin0P , T("ifcIDtYPEtELLsYS_TINcTP/I") ) ;
                                            _IO_
                                        {
                                        if( told.cbNote == sizeof( tellInfoSysTinS ) )
                                        TELL( "TINcTP TINcTI" )
                                        _IO_
                                    {
                                    case ifcIDtYPEtELLsYS_TINcTI :
                                    case ifcIDtYPEtELLsYS_TINcTP :
                                    }
                                        break ;
                                        //CONoUTrAW( T("log: \"")+T(pbNote)+T("\"\r\n") ) ; //U::
            
                                        stPeriodData.ungrabF( tin0P ) ;
                                        //etRock.traceF( tin0P , T("after  ++++ [swsLog.cFlavors,swsLog] :    ")+TF2(pd.swsLog.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(pd.swsLog,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                        pd.swsLog << postEntry ; postEntry = 0 ;
                                        //etRock.traceF( tin0P , T("before ++++ [swsLog.cFlavors,swsLog] :    ")+TF2(pd.swsLog.cFlavorsF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(pd.swsLog,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                        pd.pczLeverThread = pczLever ;
                                        periodDataS& pd = *(periodDataS*)&stPeriodData[ 1 ] ;
                                        stPeriodData.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                                        countT pczLever[] = { told.idAdamRoot ? told.idAdamRoot : - 1 , told.idAdam ? told.idAdam : - 1 , told.idThread , 0 } ;
                                        osTextT* postEntry = postOldC( tin0P , etThread , pbNote ) ; ___( postEntry ) ;
                                        TELL( "LOG" )
                                        _IO_
                                    {
                                    case ifcIDtYPEtELLsYS_LOG :
                                    }
                                        break ;
                                        }
                                            LOGrAW( T("snapshot: \"")+T(pbNote)+T("\"\r\n") ) ; //U::
                                            thirdC::c_strcpyIF( tin0P , postSnapShotRequestP , pbNote ) ;
                                        {
                                        if( !setIfZeAM( fliPendingSnapShotRequestP , mask ) )
                                        while( cSpace -- ) mask = mask << 1 | 1 ;
                                        countT cSpace = ifcIDmEMORYsPACE_max - ifcIDmEMORYsPACE_min + 1 - ( ifcIDmEMORYsPACE_RESERVEDmAX - ifcIDmEMORYsPACE_RESERVEDmIN + 1 ) ;
                                        ZE( flagsT , mask ) ;

                                        TELL( "SNAPsHOT" )
                                        _IO_
                                    {
                                    case ifcIDtYPEtELLsYS_SNAPsHOT :
                                {
                                switch( told.idType )

                                //}
                                //    etRock.traceF( tin0P , T("telemetry [idType]:    ")+(postSay?T(postSay):TF2(told.idType,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)) ) ;
                                //    const osTextT* postSay = ps3.mapSay( told.idType ) ;
                                //    processGlobal4S& ps3 = processGlobal4S::_processGlobal4I_IF() ;
                                //{
                                //if( bChatter )
                                //
                                //;
                                //    || told.idType == ifcIDtYPEtELLsYS_TINdTI
                                //    || told.idType == ifcIDtYPEtELLsYS_TINdTP
                                //    || told.idType == ifcIDtYPEtELLsYS_TINcTI
                                //       told.idType == ifcIDtYPEtELLsYS_TINcTP
                                //boolT bChatter =
    
                                byteT* pbNote = (byteT*)( &told + 1 ) ;
                                _IO_
                            {
                            else
                            }
                                }
                                    }
                                        break ;
                                        //etRock.traceF( tin0P , T("ifcIDtYPEtELLsYS_GLObEGINdT [osPid]: ")+TF4(told.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
                                        _IO_
                                    {
                                    case ifcIDtYPEtELLsYS_GLObEGINdT :
                                    }
                                        break ;
                                          if( told.osPid != ((tin1S&)tin0P).osPid ) etThread.osThreadF( TaRG2cBsTACK( tmVultureF , CBsTACKmIN << 3 ) , (countT)&bQuitEatingP , told.osPid ) ;
                                        //if( told.osPid != ((tin1S&)tin0P).osPid ) etThread.osThreadF( TaRG2cBsTACK( tmVultureF , CBsTACKmIN << 2 ) , (countT)&bQuitEatingP , told.osPid ) ;
                                        //if( told.osPid != ((tin1S&)tin0P).osPid ) etThread.osThreadF( TaRG2cBsTACK( tmVultureF , CBsTACKmIN << 1 ) , (countT)&bQuitEatingP , told.osPid ) ;
                                        //if( told.osPid != ((tin1S&)tin0P).osPid ) etThread.osThreadF( TaRG1( tmVultureF ) , (countT)&bQuitEatingP , told.osPid ) ;
                                        //etRock.traceF( tin0P , T("ifcIDtYPEtELLsYS_GLObEGINcT [osPid]: ")+TF4(told.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
                                        _IO_
                                    {
                                    case ifcIDtYPEtELLsYS_GLObEGINcT :
                                {
                                switch( told.idType )
                                _IO_
                            {
                            if( !told.cbNote )
        
                            //}
                            //    CONoUTrAW( ostoSay ) ;
                            //
                            //    OStEXTAK( ostoSay , "\r\n" ) ;
                            //    OStEXTA(  ostoSay , processGlobal4S::_processGlobal4I_IF().mapSay( told.idType ) ) ;
                            //    OStEXTAK( ostoSay , " " ) ;
                            //    OStEXTC(  ostoSay , told.idType , 0 ) ;
                            //    OStEXTAK( ostoSay , " " ) ;
                            //    OStEXTC(  ostoSay , told.idTell , 0 ) ;
                            //    OStEXTAK( ostoSay , " bytes [idTell,idType]: " ) ;
                            //    OStEXTC(  ostoSay , cbi , 0 ) ;
                            //    OStEXTAK( ostoSay , " received " ) ;
                            //    OStEXTC(  ostoSay , idCycle , 0 ) ;
                            //    OStEXTAK( ostoSay , " cycle " ) ;
                            //    OStEXTC(  ostoSay , idMemorySpaceP , 0 ) ;
                            //    OStEXTAK( ostoSay , "memory space " ) ;
                            //    OStEXT(   ostoSay , TUCK * 2 ) ;
                            //{
                            //)
                            //    told.idType == ifcIDtYPEtELLsYS_TINdTP
                            //    told.idType == ifcIDtYPEtELLsYS_TINdTI      ||
                            //    told.idType == ifcIDtYPEtELLsYS_TINcTI      ||
                            //    told.idType == ifcIDtYPEtELLsYS_TINcTP      ||
                            //(
                            //if
        
                            stPeriodData.ungrabF( tin0P ) ;
                            ++ pd.swEventTally ;
                            pd.cLeverIdType = told.idType ;
                            periodDataS& pd = *(periodDataS*)&stPeriodData[ 1 ] ;
                            stPeriodData.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                            TELL( "tallying" )
    
                            __( getNegAM( fingerTail ) - FINGERnEG_BOOK0cwRITEtAIL ) ;
                            if( bQuitEatingP ) break ;
                            while( !fingerTail && !bQuitEatingP ) { ++ s ; thirdC::dosSleepWinkIF( tin0P , 2 ) ; }
                            countT& fingerTail = *(countT*)( pbi + sizeof( tellS ) + told.cbNote ) ;
        
                            __( getNegAM( told.finger2 ) - FINGERnEG_TELEMETRY2 ) ;
                            __( getNegAM( told.finger1 ) - FINGERnEG_TELEMETRY1 ) ;
                            TELL( "checking fingers" )
                            if( bQuitEatingP ) break ;
                            while( !told.finger2 && !bQuitEatingP ) { ++ s ; thirdC::dosSleepWinkIF( tin0P , 2 ) ; }
                            tellS& told = *(tellS*)pbi ;
                            TELL( "waiting for finger2 to be set in telemetry" )
        
                            ++ idCycle ;
    
                            //CONoUTrAW5( "tmEatTelemetrySysF [idMemorySpace,idHamburger]: " , idMemorySpaceP , " " , idHamburger , "\r\n" ) ;
                            countT idHamburger = incv02AM( cHamburgersP ) ; // OPERATOR ++ CAN BE USED FOR SPEED IF ACCURACY IS NOT NEEDED; AS OF THIS WRITING ACCURACY IS NOT NEEDED
                            TELL( "got a hamburger" )
                            //etRock.traceF( tin0P , T("read returned body") ) ;
                            _IO_
                        {
                        else
                        }
                            }
                                if( bBreakOuter ) break ;

                                if( bHeaderFound ) cbi = cbBookedUse + sizeof( countT ) ;

                                cPosTest = 0 ;
                                }
                                    }
                                        }
                                            break ;
                                            etThread.traceF( tin0P , T("tmEatTelemetrySysF good header found after ignoring ")+TF2(cIgnored,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" bytes") ) ;
                                            cIgnored -= sizeof head ;
                                        {
                                        if( bHeaderFound )

                                        }
                                            case 4 : { bHeaderFound = 1                                                    ; break ; }
                                            case 3 : {                   cPosTest = getNegAM( FINGERnEG_BOOK0cwRITEhEAD2 ) ; break ; }
                                            case 2 : { cBytesEaten = 0 ; cPosTest = - 1                                    ; break ; }  // "- 1" IS ARBITRARY SINCE cPosTest WILL NOT BE USED FOR THIS MEMBER
                                            case 1 : {                   cPosTest = ifcIDfORMAT_BOOK0hEAD                  ; break ; }
                                        {
                                        switch( ++ cElementsVerified )
                                        cMatchedBytes = 0 ;
                                    {
                                    if( ++ cMatchedBytes == sizeof cPosTest )                                                           // IF A COMPLETE HEAD MEMBER HAS BEEN VERIFIED THEN SET cPosTest TO THE EXPECTED VALUE OF THE NEXT MEMBER

                                    }
                                        continue ;
                                        cPosTest = getNegAM( FINGERnEG_BOOK0cwRITEhEAD1 ) ;
                                        cbBookedUse = cMatchedBytes = cElementsVerified = 0 ;
                                    {
                                    else if( *pbi != ((byteT*)&cPosTest)[ cMatchedBytes ] )                                             // ELSE IF THE BYTE VALUE JUST READ WAS UNEXPECTED, SCAN FOR THE BEGINNING OF A HEAD
                                         if( cElementsVerified == 2                        ) cbBookedUse |= *pbi << SB * cBytesEaten ++ ;    // IF AM ACCUMULATING cbBookedUse THEN JUST DO THAT

                                    cIgnored ++ ;       // TENTATIVE ; WHEN I FIND A HEAD I WILL REDUCE THIS

                                    }
                                        break ;
                                        bBreakOuter = 1 ;
                                        hRead = hReadSave ;
                                        cbi = cbiSave ;
                                    {
                                    if( !pbi )                                                                                          // IF NO MORE INPUT IS AVAILABLE THEN SCAN IS FINISHED WITHOUT FINDING A HEAD

                                    bDelete = bksTelemetrySys.readF( tin0P , pbi , cbi , hRead , flBOOKScrEAD_STILLhUNGRYiSoK ) ;
                                    cbi = 1 ;

                                    else          pbi = 0 ;
                                    if( bDelete ) PUSE( tin0P , *(byteT**)&pbi ) ;
                                    _IO_
                                {
                                while( !bQuitEatingP && !POOP && !bHeaderFound )                                                        // SCAN AHEAD UNTIL FIND A GOOD HEAD
                                countT cIgnored = sizeof head ;
                                ZE( countT , cBytesEaten ) ;
                                ZE( countT , cElementsVerified ) ;
                                ZE( countT , cMatchedBytes ) ;
                                countT cPosTest = getNegAM( FINGERnEG_BOOK0cwRITEhEAD1 ) ;                                              // MUST BE SMUDGED AFTER USE
                                ZE( boolT , bBreakOuter ) ;
                                ZE( boolT  , bHeaderFound ) ;
                                ZE( countT , cbBookedUse ) ;

                                //  }
                                //      countT  finger2  ;
                                //      countT  cbBooked ;
                                //      countT  idFormat ;
                                //      countT  finger1  ;
                                //  {
                                //  struct telemetryBookHeadS
                                //  STRUCTURE MEMBERS TO BE VERIFIED

                                etThread.delF( tin0P , psttd ) ;
                                etThread.traceF( tin0P , T("bad header [bBad1,bBad2,bBad3,bBad4,dump]:    ")+TF2(bBad1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bBad2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bBad3,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bBad4,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttd) ) ;
                                etThread.strDumpIF( tin0P , psttd , (byteT*)&head , sizeof head ) ; ___( psttd ) ;
                                ZE( strokeS* , psttd ) ;
                                _IO_
                            {
                            else
                            }
                                cbi = head.cbBooked + sizeof( countT ) ;
                                //etThread.traceF( tin0P , T("good header") ) ;
                                _IO_
                            {
                            if( !bBad1 && !bBad2 && !bBad3 && !bBad4 )
        
                            boolT bBad4 = !head.cbBooked ;                                                  //20241222@1117: book0C::writeF EDITED TO RETURN IMPOTENT IF !cb1P, SO bBad4 SHOULD NOW BE IMPOSSIBLE
                            boolT bBad3 = head.idFormat - ifcIDfORMAT_BOOK0hEAD ;
                            boolT bBad2 = getNegAM( head.finger2 ) - FINGERnEG_BOOK0cwRITEhEAD2 ;
                            boolT bBad1 = getNegAM( head.finger1 ) - FINGERnEG_BOOK0cwRITEhEAD1 ;

                            if( bQuitEatingP ) break ;
                            while( !head.finger2 && !bQuitEatingP ) { ++ s ; thirdC::dosSleepWinkIF( tin0P , 2 ) ; }

                            telemetryBookHeadS& head = *(telemetryBookHeadS*)pbi ;
                            TELL( "parsing head" )
                            //etRock.traceF( tin0P , T("read returned head") ) ;
                            _IO_
                        {
                        if( bBookHead )
        
                        //etRock.traceF( tin0P , T("readF returned telemetry") ) ; //U:: TO FIND A BUG
                        TELL( "readF returned telemetry" )
                        _IO_
                    {
                    else
                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;
                        TELL(                      "readF returned null or fewer bytes than requested"  )
                        //etRock.traceF( tin0P , T("readF returned null or fewer bytes than requested") ) ;
                        _IO_
                    {
                    if( !pbi || cbi != cbiSave )                                         // SHOULD ALWAYS GET THE ENTIRE SHEBANG ; (20241223@1054: cbi TEST MOVED TO HERE FROM THE "else" BLOCK, WHERE IT WAS CODED TO TRIGGER IMPOTENCE)

                    if( stOsPidFromTinP > 0x20 || stOsPidFromTinZombieP > 0x20 ) etRock.traceF( tin0P , T("resource leak [idMemorySpace,stOsPidFromTinP,osOsPidZombieP]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(stOsPidFromTinP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(stOsPidFromTinZombieP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    
                    //etRock.traceF( tin0P , T("7") ) ;
                    boolT bDelete = bksTelemetrySys.readF( tin0P , pbi , cbi , hRead , flBOOKScrEAD_STILLhUNGRYiSoK ) ;
                    //etRock.traceF( tin0P , T("eating telemetry at [idDebug,off,idBook]:    ")+TF2(idDebug,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(ch.c1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(ch.c2,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    HANDLEaPPnOTEScOUNTcLASS ch = hRead ;
                    //etRock.traceF( tin0P , T("8") ) ;
                    TELL( "waiting to read a new telemetry item" )

                    handleC hReadSave = hRead ;
                    countT cbiSave = cbi ;
                    _IO_
                {
                while( !bQuitEatingP && !POOP )
                TELL( "eating 1" )
                _IO_
            {
            while( !bQuitEatingP && !POOP )
            //etRock.traceF( tin0P , T("9 [idMemorySpaceP,cKidThreads]: ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            ZE( countT , idDebug ) ;
            TELL( "eating 0" )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            ZE( countT , idCycle ) ;
            boolT bBookHead = 1 ;
            countT cbi = sizeof( telemetryBookHeadS ) ;
            ZE( const byteT* , pbi ) ;
            handleC hRead( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
            TELL( "preparing to eat" )
            _IO_
        {
        if( !(const poopC&)bksTelemetrySys )

        etRock.traceF( tin0P , T("ct'ed bksTelemetrySys [idMemorySpaceP,cKidThreads]: ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        booksC bksTelemetrySys( tin0P , TAG( TAGiDnULL ) , "bksTelemetrySys" , ifcIDsTATEsPACE_MULTIPLEaDAMS , idMemorySpaceP == ifcIDmEMORYsPACE_GLASS2 ? flBOOKSc_null : flBOOKSc_USEgRABmEMORYsPACEoVERRIDE , 0 , 0 , 0 , 0 , 0 , idMemorySpaceP , &bQuitEatingP ) ;
        etRock.traceF( tin0P , T("ct'ing bksTelemetrySys [idMemorySpaceP,cKidThreads]: ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        //U:: THE NEXT LINE USED TO SPECIFY THE DELETE FLAG, BUT AS OF 20131222@1558 THIS CAUSES FAILURES ; DELETE FLAG REMOVED WITHOUT ANALYSIS

        TELL( "constructing telemetry books" ) //THE NEXT LINE WILL BLOCK UNTIL A BOOK ENTRY IS WRITTEN , SO I WILL NOT BE ABLE TO QUIT UNTIL THAT HAPPENS
        _IO_
    {
    THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )

    }
        //etRock.traceF( tin0P , T("launched  tmReportF [idMemorySpace,cKidThreads]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

          etThread.osThreadF( tin0P , countTC() , tmReportF , &sgnDone_tmReportF_ , 0  , flTHREADlAUNCH_null , CBsTACKmIN << 3 , 0 , (countT)pcArg ) ;
        //etThread.osThreadF( tin0P , countTC() , tmReportF , &sgnDone_tmReportF_ , 0  , flTHREADlAUNCH_null , CBsTACKmIN << 2 , 0 , (countT)pcArg ) ;
        //etThread.osThreadF( tin0P , countTC() , tmReportF , &sgnDone_tmReportF_ , 0  , flTHREADlAUNCH_null , CBsTACKmIN << 1 , 0 , (countT)pcArg ) ;

        //etRock.traceF( tin0P , T("launching tmReportF [idMemorySpace,cKidThreads]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        pcArg[ 0xb ] = (countT)&bChatterP ;
        pcArg[ 0xa ] = (countT)&tEventP ;
        pcArg[ 0x9 ] = (countT)&osTidEventP ;
        pcArg[ 0x8 ] = (countT)&osPidEventP ;
        pcArg[ 0x7 ] = (countT)&bCompileReportP ;
        pcArg[ 0x6 ] = (countT)postSnapShotRequestP ;
        pcArg[ 0x5 ] = (countT)&fliPendingSnapShotRequestP ;
        pcArg[ 0x4 ] = idMinuteZeP ;
        pcArg[ 0x3 ] = (countT)&memorySpace ;
        pcArg[ 0x2 ] = (countT)&stPeriodData ;
        pcArg[ 0x1 ] = idMemorySpaceP ;
        pcArg[ 0x0 ] = (countT)&bQuitEatingP ;
        etThread.newF( tin0P , LF , pcArg , 0xb ) ; ___( pcArg ) ;
        ZE( countT* , pcArg ) ;
        _IO_
    {

    signC sgnDone_tmReportF_( tin0P , TAG( TAGiDnULL ) ) ;
    TELL( "launching tmReportF" )

    new( 0 , tin0P , (byteT*)&stPeriodData[ 1 ] , sizeof( periodDataS ) ) periodDataS( tin0P , etThread ) ;
    stPeriodData << (byteT*)0 ;
    stackC stPeriodData( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB|flSTACKc_ALLOWzE , sizeof( periodDataS ) ) ;
    TELL( "constructing period data structure" )

    swMemorySpaceP.ungrabF( tin0P ) ;
    memorySpaceS& memorySpace = *(memorySpaceS*)&(countT&)swMemorySpaceP ;
    cLeverIdMemoryP = idMemorySpaceP ;
    __( !swMemorySpaceP.idSlotOfLeverF( tin0P , idMemorySpaceP ) ) ;
    swMemorySpaceP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    TELL( "getting memory space structure" )

    //etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_SPINLOCK ) ;
    TELL( "setting rush" )

    //if( idMemorySpaceP == ifcIDmEMORYsPACE_GLASS2 ) etThread.osThreadF( TaRG1( tmYellF ) ) ;

    etRock.traceF( tin0P , T("[idMemorySpace]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    //etRock.traceF( tin0P , T("[idMemorySpace,cKidThreads]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    //CONoUTrAW3( "tmEatTelemetrySysF [idMemorySpaceP]: " , idMemorySpaceP , "\r\n" ) ;

    ((tin12S&)tin0P).c4Tell.c1 = idMemorySpaceP ;

    //etRock.traceF( tin0P , T("i just called TRACEmYtHREAD [idMemorySpace,cKidThreads]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((tin1S&)tin0P).cKidThreads,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    //TRACEmYtHREAD ;

    TN( tb4 , "    " ) ;

    etThread.delF( tin0P , pcArgP ) ;
    stackC&      stOsPidFromTinZombieP      =  *(stackC*)pcArgP[ 0x0f ] ;
    stackC&      stOsPidFromTinP            =  *(stackC*)pcArgP[ 0x0e ] ;
    stackC&      stOsPidP                   =  *(stackC*)pcArgP[ 0x0d ] ;
    boolT&       bChatterP                  =   *(boolT*)pcArgP[ 0x0c ] ;
    textC&       tEventP                    =   *(textC*)pcArgP[ 0x0b ] ;
    countT&      osTidEventP                =  *(countT*)pcArgP[ 0x0a ] ;
    countT&      osPidEventP                =  *(countT*)pcArgP[ 0x09 ] ;
    batonC&      bCompileReportP            =  *(batonC*)pcArgP[ 0x08 ] ;
    osTextT*     postSnapShotRequestP       =  (osTextT*)pcArgP[ 0x07 ] ;
    flagsT&      fliPendingSnapShotRequestP =  *(flagsT*)pcArgP[ 0x06 ] ;
    countT&      cHamburgersP               =  *(countT*)pcArgP[ 0x05 ] ;
    countT       idMinuteZeP                =            pcArgP[ 0x04 ] ;
    switchC&     swMemorySpaceP             = *(switchC*)pcArgP[ 0x03 ] ;
    countT&      cLeverIdMemoryP            =  *(countT*)pcArgP[ 0x02 ] ;
    countT       idMemorySpaceP             =            pcArgP[ 0x01 ] ;
    boolT&       bQuitEatingP               =   *(boolT*)pcArgP[ 0x00 ] ;
    countT* pcArgP = (countT*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 )
TASK( tmEatTelemetrySysF )

#endif
DONE( tmCloakF )
}
    }
        //etThread.traceF( tin0P , T("this computer has been told to shut down (not really)") ) ;    
        //U::etThread.osFireF( tin0P , 1 ) ;
        //etThread.traceF( tin0P , T("shutting down this computer for security (not really)") ) ;    
        //etThread.traceF( tin0P , T("i have not yet been fired, so cloak's death is unexplained") ) ;
    {
    if( !ether )
    ether.osSleepF( tin0P , TOCK ) ;
    //etThread.traceF( tin0P , T("cloak has died ; napping for a TOCK") ) ;

    //U:: TEST idDeathType AND IF CLOAK WAS MURDERED THEN DON'T NAP BEFORE SHUTTING DOWN
    //U:: BUG: idDeathType IS 0 WHEN CLOAK IS KILLED WITHIN PROCESS EXPLORER
    //etThread.traceF( tin0P , T("error: cloak has died [idDeathType]:    ")+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;    
    countT& idDeathType = c4Result.c4 ;
    count4S c4Result = etThread.ifcHireF( tin0P , T("ifcIDaDAM_2GLASS2") , ifcIDaDAM_CLOAK , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO | flHIRE_WAIT , nicNameC() ) ;
    //etThread.traceF( tin0P , T("hiring cloak") ) ;
{
if( pTaskP )
TASK( tmCloakF )
// ... YOU GET THE IDEA.  COME UP WITH WO OR MORE SCHEMES TO ENSURE THAT THE TERMINATION OF A CLOAK PROCESS IS DETECTED AND TRIGGERS SHUTDOWN OR SOME OTHER DEFENSE
// THIS CAN BE A DEDICATED COMPUTER ON THE LAN THAT IS NEVER LOGGED ON TO AND DOESN'T RUN ANY SOFTWARE SO HAS A VERY SMALL ATTACK SURFACE
// ALT: A DEDICATED HOME CAN CLOAK ALL OTHER HOMES ON THE LOCAL COMPUTER
// BUT IF THE IDEAFARM HOME IS TO BE CLOAKED, THE SERVICE PROGRAM (OR SOME OTHER PROGRAM LAUNCHED BY SERVICE) WILL HAVE TO DO IT.
// THE INITIAL PLAN WAS FOR MONITOR (THIS ADAM) TO DO THAT
// OBJECTIVE: DETECT WHEN CLOAK PROCESS TERMINATES ON LOCAL HOST OR ON ANY OTHER HOST ON THE LAN.  IF SO, SHUTDOWN THAT HOST TO PREVENT IT FROM BEING ONLINE IN AN UNCLOAKED STATE
//U:: ALT: MOVE THIS FUNCTIONALITY INTO A SIMPLE ADAM THAT JUST DOES IT AND COOPERATES WITH OTHER ADAM CELLS ON LOCAL (LAN) COMPUTERS, SUCH AS THE FACTORIES ON THE IDEAFARM SUBNET
#if defined( NEVERdEFINED )

DONE( tmYellF )
}
    //CONoUTrAW( "tmYell/-\r\n" ) ;

    }
        ++ s ; ether.osSleepF( tin0P , TOCK ) ;

        //CONoUTrAW( "tmYell/yell/-\r\n" ) ;
        THREADmODE1rESTORE
        YELL( "yippee!" ) ;
        THREADmODE1oN( flTHREADmODE1_YELL )
        //CONoUTrAW( "tmYell/yell/+\r\n" ) ;
    {
    while( !ether )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    //CONoUTrAW( "tmYell/+\r\n" ) ;
{
if( pTaskP )
TASK( tmYellF )

DONE( tmVultureF )
}
    }
        CloseHandle( osh ) ;

        }
            etThread.traceF( tin0P , T("process [osPid] ")+TF4(osPidPrey,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(" terminated with code    ")+TF2((countT)rc2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF4((countT)rc2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
            boolT bOk = GetExitCodeProcess( osh , &rc2 ) ;
            ZE( DWORD , rc2 ) ;
        {
        if( !POOP && bDead )

        }
            }
                case WAIT_OBJECT_0  : { bDead = 1 ; break ; }
                case WAIT_TIMEOUT   : {           ; break ; }
                case WAIT_ABANDONED : { __1       ; break ; }
                case WAIT_FAILED    :
            {
            switch( rc )
            countT rc = WaitForSingleObject( osh , 500 ) ; // 500 MILLISECOND TIMEOUT
        {
        while( !bQuitEatingP && !bDead && !POOP )
        ZE( boolT , bDead ) ;
    {
    if( osh )
    HANDLE osh = OpenProcess( PROCESS_TERMINATE | SYNCHRONIZE | PROCESS_QUERY_LIMITED_INFORMATION , 0 , osPidPrey ) ;

    //etThread.traceF( tin0P , T("tmVultureF [osPid]:")+TF4(osPidPrey,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(": waiting for death") ) ;

    const countT  osPidPrey    =                 pTaskP->c2 ;
    const countT& bQuitEatingP = *(const countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmVultureF )

DONE( tmReportF )
}
    //etRock.traceF( tin0P , T("0/ ") ) ; //U:: TO FIND A BUG
    }
//#endif
        }
            if( bSerialize ) bCompileReportP.ungrabF( tin0P ) ;

            }
                }
                    }
                        //etRock.traceF( tin0P , T("1/ ") ) ; //U:: TO FIND A BUG
                        //CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  0\r\n" ) ;
                        //CONoUTrAW5( "tmReportF idMemorySpace:" , idMemorySpaceP , " idMinute:" , idMinute , " written\r\n" ) ;

                        PUSE( tin0P , pbBookOut ) ;
                        }
                            //bkReport.writeF( tin0P , pbBookOut , cbBookOut , 0 , 0 , flBOOKScwRITE_HEADfINGER1 | flBOOKScwRITE_HEADiDfORMAT | flBOOKScwRITE_HEADcBdATA | flBOOKScwRITE_HEADfINGER2 | flBOOKScwRITE_TAILfINGER | flBOOKScwRITE_ALLOWoDDlENGTH ) ;

                            //LOGrAW3( "report written to disk []: " , idMemorySpaceP , "\r\n" ) ;
                            //etRock.traceF( tin0P , T("2/ ") ) ; //U:: TO FIND A BUG
                            _IO_
                        {
                        if( !bQuitEatingP )

                        }
                            }
                                }
                                    etThread.delF( tin0P , postr ) ;
                                    etThread.fileWriteF( tin0P , hFile1 , postr , costr ) ;
                                        
                                    etThread.delF( tin0P , psttr ) ;
                                    countT costr = etThread.strMakeF( tin0P , LF , postr , psttr ) ; ___( postr ) ;
                                    ZE( osTextT* , postr ) ;
                                
                                    sRpt >> psttr ; ___( psttr ) ;
                                    ZE( strokeS* , psttr ) ;
                                {
                                while( sRpt )

                                //etRock.traceF( tin0P , T("report pulled [idMemorySpaceP,cFields]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)sRpt,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                sReports >> sRpt ;
                                soulC sRpt( tin0P , etThread , TAG( TAGiDnULL ) ) ;
                                _IO_
                            {
                            while( sReports && !bQuitEatingP )
                            OPENfILEwRITE1( tFile )
                            _IO_
                        {
                        if( !bQuitEatingP )

                        }
                            //REMOVE: etThread.boxPutF( tin0P , tFile , (osTextT*)sReports , sReports.csF( tin0P ) ) ;

                            //LOGrAW( "\"\r\n" ) ;
                            //LOGrAW( tFile ) ;
                            //LOGrAW5( "tmReportF idMemorySpace:" , idMemorySpaceP , " idMinute:" , idMinute , " writing file \"" ) ;

                            //CONoUTrAW( "\"\r\n" ) ;
                            //CONoUTrAW( tFile ) ;
                            //CONoUTrAW5( "tmReportF idMemorySpace:" , idMemorySpaceP , " idMinute:" , idMinute , " writing file \"" ) ;
                            //CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  1\r\n" ) ;
                            //etRock.traceF( tin0P , T("3/ ") ) ; //U:: TO FIND A BUG

                            }
                                if( !fliPendingSnapShotRequestP ) *postSnapShotRequestP = 0 ;   //A:ASSUME: FLAGS ARE SET BEFORE SETTING STRING

                                }
                                    if( oldf == setIfEqualsAM( fliPendingSnapShotRequestP , newf , oldf ) ) break ;
                                    flagsT newf = oldf & ~fliMyBit ;
                                    flagsT oldf = fliPendingSnapShotRequestP ;
                                {
                                for(;;)
                                _IO_
                            {
                            if( bSnapShot )
                            //etRock.traceF( tin0P , T("4/ ") ) ; //U:: TO FIND A BUG

                            tFile += T(".rpt.idMemorySpace.")+TF3(idMemorySpaceP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,3)+tDot+TF2(idMinute,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE)+T(".txt") ;
                            if( bEvent ) tFile += T(".event") ;
                            else                                                              tFile += T("minute") ;
                            if( bSnapShot || F(home.flagsUtility) & flHOMEsuTILITY_SNAPsHOT ) tFile += T(postSnapShotRequestP&&*postSnapShotRequestP?postSnapShotRequestP:"snapshot") ;  //U:: BUG: RACE: THIS CODE RACES WITH REQUESTOR SETTING STRING
                            tFile = T("///ideafarm/ephemeral/reports/")+tUser+tSlash+TF3(idRpt,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot+textC(ifcIDtEXTgEN_TIMEnOWfOREIGN,tin0P,TAG(TAGiDnULL))+tDot ;
                            //etRock.traceF( tin0P , T("5/ ") ) ; //U:: TO FIND A BUG

                            // BUG: RACE: WO WAY TO ELIMINATE THE RACE IS TO NAP HERE (IFF bSnapShot) UNTIL STRING IS NOT NULL ; THIS CHANGE WOULD REQUIRE ALL REQUESTERS TO SET THE STRING

                            TN( tUser , thirdC::postUserNameIF() ) ;
                            TN( tSlash , "/" ) ;
                            TN( tDot , "." ) ;
                            countT idRpt = 1 + incv02AM( idRptLath ) ;
                            static countT idRptLath ;

                            //LOGrAW3( "tmReportF 2 [flHOMEsuTILITY_SNAPsHOT]: " , F(home.flagsUtility) & flHOMEsuTILITY_SNAPsHOT , "\r\n" ) ;

                            //20121126@1750: I VAGUELY RECALL THAT I FOUND THIS BUG; HAVEN'T SEEN IT LATELY
                            //U::BUG: boxPutF OCCASIONALLY FAILS: diskMakeDirF/lath prior slash is at position less than 4: "///d/"
                            //etRock.traceF( tin0P , T("6/ ") ) ; //U:: TO FIND A BUG
                        {
                        if( !bQuitEatingP )
                        TN( tFile , "" ) ;

                        if( !bQuitEatingP ){ _IO_ sReports << sRptTin    ; }
                        if( !bQuitEatingP ){ _IO_ sReports << sRptNapkin ; }
                        if( !bQuitEatingP ){ _IO_ sReports << sRptSex    ; }
                        if( !bQuitEatingP ){ _IO_ sReports << sRptAdd    ; }
                        if( !bQuitEatingP ){ _IO_ sReports << sRptLog    ; }
                        if( !bQuitEatingP ){ _IO_ sReports << sRptEvent  ; }
                        if( !bQuitEatingP ){ _IO_ sReports << sRptTitle  ; }

                        //if( idMemorySpaceP == 3 ) etRock.traceF( tin0P , T("report Tin    [idMemorySpaceP,cFields]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)sRptTin   ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //etRock.traceF( tin0P , T("report Napkin [idMemorySpaceP,cFields]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)sRptNapkin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //etRock.traceF( tin0P , T("report Sex    [idMemorySpaceP,cFields]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)sRptSex   ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //etRock.traceF( tin0P , T("report Add    [idMemorySpaceP,cFields]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)sRptAdd   ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //etRock.traceF( tin0P , T("report Log    [idMemorySpaceP,cFields]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)sRptLog   ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //etRock.traceF( tin0P , T("report Event  [idMemorySpaceP,cFields]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)sRptEvent ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //etRock.traceF( tin0P , T("report Title  [idMemorySpaceP,cFields]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)sRptTitle ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        soulC sReports(  tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , ostoFileReports , TICK ) ; //20200920@1726: INCREASED FROM ( TOCK << 4 )
                        //etRock.traceF( tin0P , T("7/ ") ) ; //U:: TO FIND A BUG

                        OStEXTC(  ostoFileReports  , idMemorySpaceP , 0 ) ;
                        OStEXTAK( ostoFileReports  , ".soul.reports." ) ;
                        OStEXTC(  ostoFileReports  , idCycle , 0 ) ;               // TO UNIQUIFY FOR ROBUSTNESS (IF REUSE THE SAME NAME THEN FAILURE TO DELETE A BACKING FILE WOULD AFFECT THE NEXT CYCLE)
                        OStEXT(   ostoFileReports  , TUCK >> 3 ) ;

                        _IO_
                    {
                    if( !bQuitEatingP )

                    }
                        etThread.delF( tin0P , psttRpt ) ;
                        sRptAdd << (strokeS*)( T("\r\n\r\nProcess [osPid]:    ")+TF2(cLeverGrainCode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF4(cLeverGrainCode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(psttRpt) ) ;

                        etThread.strFuseF( tin0P , psttRpt , tcr ) ;
                        }
                            etThread.strFuseF( tin0P , psttRpt , T(post2) ) ;
                            osTextT post2[ 2 ] = { pbzGrainCode[ offg ] , 0 } ;

                            }
                                etThread.strFuseF( tin0P , psttRpt , TF3(offRow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,3) ) ;
                                }
                                    etThread.strFuseF( tin0P , psttRpt , tcr ) ;
                                    offRow ++ ;
                                {
                                if( offg )
                            {
                            if( !( offg % cColsGrainCode ) )
                        {
                        for( countT offg = 0 ; offg < cbGrainCode && !bQuitEatingP ; offg ++ )
                        ZE( countT , offRow ) ;

                        etThread.strMakeF( tin0P , LF , psttRpt , (const strokeS*)T("\r\n\r\n") , cbGrainCode << 1 ) ; ___( psttRpt ) ;
                        ZE( strokeS* , psttRpt ) ;

                        byteT* pbzGrainCode = (byteT*)&(countT&)sw_pbzGrainCode ;
                        cLeverGrainCode = sw_pbzGrainCode.leverF( tin0P , idf ) ;
                        _IO_
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !bQuitEatingP ; idf ++ )
                    countT cFlavors = sw_pbzGrainCode.cFlavorsF( tin0P ) ;

                    TN( tcr  , "\r\n" ) ;
                    //CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  2\r\n" ) ;
                    //etRock.traceF( tin0P , T("8/ ") ) ; //U:: TO FIND A BUG

                    stPeriodDataP.ungrabF( tin0P ) ;
                    }
                        }
                            sRptLog << (strokeS*)( T("\r\n") ) ;
                            while( ~hWalk ) ;
                            do sRptLog << (strokeS*)( T((osTextT*)pd.swsLog.downF(tin0P,hWalk))+T("\r\n") ) ;
                            handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            
                            sRptLog << (strokeS*)( T(pd.pczLeverThread)+T(":\r\n\r\n") ) ;
                            pd.pczLeverThread = (const countT*)pd.swsLog.leverF( tin0P , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cFlavors && !bQuitEatingP ; idf ++ )
                        cFlavors = pd.swsLog.cFlavorsF( tin0P ) ;

                        sRptEvent << (strokeS*)( TF3(total,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T("total\r\n") ) ;
                        }
                            total += tally ;
                            sRptEvent << (strokeS*)( TF3(tally,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+T(processGlobal4S::_processGlobal4I_IF().mapSay(idType))+T("\r\n") ) ;
                            countT tally = pd.swEventTally ;
                            countT idType = pd.cLeverIdType = pd.swEventTally.leverF( tin0P , idf ) ;
                        {
                        for( countT idf = 1 ; idf <= cFlavors && !bQuitEatingP ; idf ++ )
                        ZE( countT , total ) ;
                        countT cFlavors = pd.swEventTally.cFlavorsF( tin0P ) ;

                        periodDataS& pd = *(periodDataS*)&stPeriodDataP[ 2 ] ;
                        _IO_
                    {
                    if( stPeriodDataP > 1 && !bQuitEatingP )

                    //U::CONJ: THIS IS OBSOLETED BY THE PRECEDING SNIP: stPeriodDataP.purgeF( tin0P , 0x10 ) ; //U::DESTROY THE periodDataS INSTANCES

                    }
                        while( ~hWalk && -- cToDo ) ;
                        }
                            stPeriodDataP.extractF( 0 , tin0P ) ;
                            DELzOMBIE( ppd ) ;
                            periodDataS* ppd = (periodDataS*)&stPeriodDataP.upF( tin0P , hWalk ) ;
                        {
                        do
                        handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        countT cToDo = stPeriodDataP - CpERIODSrETAIN ;
                        _IO_
                    {
                    if( stPeriodDataP > CpERIODSrETAIN )

                    new( 0 , tin0P , (byteT*)&stPeriodDataP[ 1 ] , sizeof( periodDataS ) ) periodDataS( tin0P , *stPeriodDataP.third.third_pEtherContainsMe_F() ) ;
                    stPeriodDataP << (byteT*)0 ;
                    //CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  3\r\n" ) ;

                    stPeriodDataP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                    //CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  4\r\n" ) ;
                    //etRock.traceF( tin0P , T("9/ ") ) ; //U:: TO FIND A BUG
                    _IO_
                {
                if( !bQuitEatingP )

                swTinCopy.freeAllF( tin0P ) ;
                //etRock.traceF( tin0P , T("a/ 0") ) ; //U:: TO FIND A BUG
                }
                    PUSE( tin0P , pbBookOut ) ;
                    }
                        //U::__( pbBookOut + cbBookOut - pbc ) ;

                        }
                            countT foo = 2 ;
                        {
                        if( pbBookOut + cbBookOut - pbc )

                        //etRock.traceF( tin0P , T("a/ 1") ) ; //U:: TO FIND A BUG
                        }
                            }
                                sRptTin << (strokeS*)( T("\r\n") ) ;
                                }
                                    }
                                        sRptTin << (strokeS*)( T(ostoLine) ) ;

                                        OStEXTAK( ostoLine , "\r\n" ) ;
                                        }
                                            OStEXTA( ostoLine , postTitle ) ;
                                        {
                                        if( postTitle )
                                        const osTextT* postTitle = processGlobal8S::_processGlobal8I_IF().source.postFileTitleF( tin0P , processGlobal8S::_processGlobal8I_IF().source.idFileRankF( tin0P , idiFile ) ) ;
                                        OStEXTAK(   ostoLine , "    " ) ;
                                        OStEXTCmIN( ostoLine , idiFile , 7 ) ;
                                        OStEXTAK(   ostoLine , "." ) ;
                                        OStEXTCmIN( ostoLine , idLine , 4 ) ;
                                        OStEXTA(    ostoLine , ( bOut ? "\\ " : ( bIn ? "/ " : "| " ) ) ) ;
                                
                                        }
                                            ++ cIndent ;
                                        {
                                        if( bOut )

                                        }
                                            }
                                                OStEXTAK( ostoLine , " " ) ;
                                            {
                                            while( cToDo -- )
                                            countT cToDo = cIndent ;
                                        {
                                        else
                                        }
                                            OStEXTC( ostoLine , cIndent , ' ' ) ;
                                        {
                                        if( cIndent > TUCK >> 2 )

                                        if( bIn && cIndent ) { -- cIndent ; }
                                
                                        idLine &= ~fliSTEP_FLAGmASK ;
                                        }
                                            bIn  = !bOut ;
                                            bOut = idLine & fliSTEP_NESToUT ;
                                        {
                                        else
                                        }
                                            bIn = bOut = 0 ;
                                        {
                                        if( !( idLine & fliSTEP_NESTcHANGE ) )
                                        boolT bIn ;
                                        boolT bOut ;
                                
                                        countT idiFile = ((tin123S&)tin0Copy).pLFstep[ offe + 1 ] ;
                                        countT idLine  = ((tin123S&)tin0Copy).pLFstep[ offe     ] ;
                                        countT offe = ( ids & OFFsLOTtINsTEPmAX ) << 1 ;

                                        OStEXT( ostoLine , TUCK << 2 ) ;            //20230908@1445: 2 <- 1 DUE TO EXHAUSTION
                                    {
                                    for( countT ids = ((tin123S&)tin0Copy).glass.idStep ; cDo -- ; ids -- )
                                    countT cDo = OFFsLOTtINsTEPmAX + 1 ;                          // IF idStep IS SMALL AND NOT BECAUSE OF WRAP THEN SOME REPORT LINES WILL BE FROM [0,0] PAIRS ; TO KISS, I DO NOT TEST FOR THIS SO I WILL REPORT EVEN IF pLFstep HAS BEEN TRASHED
                                    countT cIndent = ((tin123S&)tin0Copy).where.cInNest ;
                                
                                    sRptTin << (strokeS*)( T("Execution Steps:\r\n \r\n") ) ;
                                    _IO_
                                {
                                //CS:CODEsYNC: PSEUDOdUPLICATE: 35001155 510004fb.2

                                //etRock.traceF( tin0P , T("a/ 2") ) ; //U:: TO FIND A BUG
                                sRptTin << (strokeS*)( T("\r\n") ) ;
                                }
                                    sRptTin << (strokeS*)( T(ostoRpt) ) ;
                                    OStEXTAK( ostoRpt , "\r\n" ) ;
                                    }
                                        OStEXTA( ostoRpt , postTitle ) ;
                                    {
                                    if( postTitle )
                                    const osTextT* postTitle = processGlobal8S::_processGlobal8I_IF().source.postFileTitleF( tin0P , processGlobal8S::_processGlobal8I_IF().source.idFileRankF( tin0P , idiFile ) ) ;
                                    OStEXTAK(   ostoRpt , "    " ) ;
                                    OStEXTCmIN( ostoRpt , idiFile , 7 ) ;
                                    OStEXTAK(   ostoRpt , "." ) ;
                                    OStEXTCmIN( ostoRpt , idLine , 4 ) ;
                                    OStEXTAK(   ostoRpt , "'th: " ) ;
                                    OStEXTC(    ostoRpt , ((tin123S&)tin0Copy).pIdInNest[ offez ] , ' ' ) ;
                                    OStEXTAK(   ostoRpt , " | " ) ;
                                    OStEXTC(    ostoRpt , ((tin123S&)tin0Copy).pEIPInNest[ offez ] , ' ' ) ;
                                    OStEXT(     ostoRpt , OFFsLOTtINnESTmAX * TUCK )
                                        
                                    countT idiFile = ((tin123S&)tin0Copy).where.pLFnest[ offe + 1 ] ;
                                    countT idLine  = ((tin123S&)tin0Copy).where.pLFnest[ offe     ] ;
                                    countT offe = ( idn & OFFsLOTtINnESTmAX ) << 1 ;
                                    countT offez = idn & OFFsLOTtINnESTmAX ;
                                    _IO_
                                {
                                for( countT idn = ((tin123S&)tin0Copy).where.cInNest ; idn >= idnf && !bQuitEatingP ; idn -- )
                                if( (sCountT)idnf < 1 ) idnf = 1 ;
                                countT idnf = ((tin123S&)tin0Copy).where.cInNest - OFFsLOTtINnESTmAX ;
                                if( bDash ) sRptTin << (strokeS*)( T(DASH256 "\r\n") ) ;
                                //etRock.traceF( tin0P , T("a/ 3") ) ; //U:: TO FIND A BUG
                    
                                }
                                    PUSE( tin0P , pbCopy ) ;
                                    }
                                        }
                                            }
                                                }
                                                    BLAMMO ;
                                                    //2009.12.20: 105 tmReportF unexpected value [pbg->idTypeCt]: 0
                                                    LOGrAW3( "105 tmReportF unexpected value [pbg->idTypeCt]: " , pbg->idTypeCt , "\r\n" ) ;
                                                    _IO_
                                                {
                                                default :
                                                }
                                                    break ;
                                                    //etRock.traceF( tin0P , T("a/ 4") ) ; //U:: TO FIND A BUG
                                                    PUSE( tin0P , pbCopy ) ;
                                                    }
                                                        }
                                                            countT foo = 2 ; //U::
                    
                                                            grabotC& grabot = *(grabotC*)pbCopy ;
                                                        {
                                                        if( bOk )
                                                        }
                                                            thirdC::dosReadProcessMemoryIF( tin0P , pbCopy , sizeof( grabotC ) , bOk , (voidT*)((tin123S&)tin0Copy).glass.pPanLifiGrabbing[ 0 ] , ((tin123S&)tin0Copy).osPid ) ;
                                                            _IO_
                                                        {
                                                        ZE( boolT , bOk ) ;
                                                        _IO_
                                                    {
                                                    if( pbCopy )
                                                    PUSE.newF( tin0P , LF , pbCopy , sizeof( grabotC ) ) ; ___( pbCopy ) ;
                                                    ZE( byteT* , pbCopy ) ;
                                                    //etRock.traceF( tin0P , T("a/ 5") ) ; //U:: TO FIND A BUG
                                                    _IO_
                                                {
                                                case ifcIDtYPEdERIVEDbASEgRABc_grabotC :
                                                }
                                                    break ;
                                                    //etRock.traceF( tin0P , T("a/ 6") ) ; //U:: TO FIND A BUG
                                                    PUSE( tin0P , pbCopy ) ;
                                                    }
                                                        }
                                                            countT foo = 2 ; //U::
                    
                                                            grabitC& grabit = *(grabitC*)pbCopy ;
                                                        {
                                                        if( bOk )
                                                        }
                                                            thirdC::dosReadProcessMemoryIF( tin0P , pbCopy , sizeof( grabitC ) , bOk , (voidT*)((tin123S&)tin0Copy).glass.pPanLifiGrabbing[ 0 ] , ((tin123S&)tin0Copy).osPid ) ;
                                                            _IO_
                                                        {
                                                        ZE( boolT , bOk ) ;
                                                        _IO_
                                                    {
                                                    if( pbCopy )
                                                    PUSE.newF( tin0P , LF , pbCopy , sizeof( grabitC ) ) ; ___( pbCopy ) ;
                                                    ZE( byteT* , pbCopy ) ;
                                                    //etRock.traceF( tin0P , T("a/ 7") ) ; //U:: TO FIND A BUG
                                                    _IO_
                                                {
                                                case ifcIDtYPEdERIVEDbASEgRABc_grabitC :
                                                }
                                                    break ;
                                                    //etRock.traceF( tin0P , T("a/ 8") ) ; //U:: TO FIND A BUG
                                                    PUSE( tin0P , pbCopy ) ;
                                                    //etRock.traceF( tin0P , T("a/ 9 / 0") ) ; //U:: TO FIND A BUG
                                                    }
                                                        //etRock.traceF( tin0P , T("a/ 9 / 1") ) ; //U:: TO FIND A BUG
                                                        }
                                                            //etRock.traceF( tin0P , T("a/ 9 / 2") ) ; //U:: TO FIND A BUG
                                                            }
                                                                //etRock.traceF( tin0P , T("a/ 9 / 3") ) ; //U:: TO FIND A BUG
                                                                }
                                                                    //etRock.traceF( tin0P , T("a/ 9 / 4") ) ; //U:: TO FIND A BUG
                                                                    sRptTin << (strokeS*)( T("this is grabbed by a thread that is gone [osTid]: ")+TF1(grab.osTidF())+T("\r\n") ) ;
                                                                    //etRock.traceF( tin0P , T("a/ 9 / 5") ) ; //U:: TO FIND A BUG
                                                                {
                                                                else
                                                                }
                                                                    //etRock.traceF( tin0P , T("a/ 9 / 6") ) ; //U:: TO FIND A BUG
                                                                    sRptTin << (strokeS*)( T("this is grabbed by osTid:")+TF1(grab.osTidF())+T(" idAdamRoot:")+TF1(idAdamRoot)+T(" idAdam:")+TF1(idAdam)+T(" idThread:")+TF1(((tin123S&)tin0Copy).glass.idThread)+T(" postThreadName:\"")+TF1(((tin123S&)tin0Copy).postThreadName)+T("\"\r\n") ) ;
                                                                    //etRock.traceF( tin0P , T("a/ 9 / 7") ) ; //U:: TO FIND A BUG

                                                                    }
                                                                        //etRock.traceF( tin0P , T("a/ 9 / 8") ) ; //U:: TO FIND A BUG
                                                                        PUSE( tin0P , pbCopy1 ) ;
                                                                        //etRock.traceF( tin0P , T("a/ 9 / 9") ) ; //U:: TO FIND A BUG
                                                                        }
                                                                            //etRock.traceF( tin0P , T("a/ 9 / a") ) ; //U:: TO FIND A BUG
                                                                            }
                                                                                //etRock.traceF( tin0P , T("a/ 9 / b") ) ; //U:: TO FIND A BUG
                                                                                PUSE( tin0P , pbCopy2 ) ;
                                                                                }
                                                                                    //etRock.traceF( tin0P , T("a/ 9 / c") ) ; //U:: TO FIND A BUG
                                                                                    }
                                                                                        idAdamRoot = pg1.idAdamRoot ;
                                                                                        processGlobal1S& pg1 = *(processGlobal1S*)pbCopy2 ;
                                                                                    {
                                                                                    if( bOk )
                                                                                    }
                                                                                        thirdC::dosReadProcessMemoryIF( tin0P , pbCopy2 , sizeof( processGlobal1S ) , bOk , (voidT*)ag1.pProcessGlobal1 , ((tin123S&)tin0Copy).osPid ) ;
                                                                                        _IO_
                                                                                    {
                                                                                    ZE( boolT , bOk ) ;
                                                                                    //etRock.traceF( tin0P , T("a/ 9 / d") ) ; //U:: TO FIND A BUG
                                                                                    //etThread.traceF( tin0P , T("using pool drop") ) ;
                                                                                    _IO_
                                                                                {
                                                                                if( pbCopy2 )
                                                                                //etRock.traceF( tin0P , T("a/ 9 / e") ) ; //U:: TO FIND A BUG

                                                                                __( bFail ) ;
                                                                                }
                                                                                    //}
                                                                                    //    bFail = 1 ;
                                                                                    //    etThread.traceF( tin0P , T("request for pool drop failed [cbaDebug]:    ")+TF2(cbaDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                                                    //    POOPR
                                                                                    //{
                                                                                    //else
                                                                                    //if( !POOP ) etThread.traceF( tin0P , T("requested pool drop aok [cbaDebug]:    ")+TF2(cbaDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                                                    PUSE.newF( tin0P , LF , pbCopy2 , cbaDebug ) ; ___( pbCopy2 ) ;
                                                                                    SCOOPS
                                                                                {
                                                                                IFsCRATCHoK
                                                                                ZE( boolT , bFail ) ;
                                                                                //etThread.traceF( tin0P , T("requesting pool drop [cbaDebug]:    ")+TF2(cbaDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                                                countT cbaDebug = sizeof( processGlobal1S ) ;

                                                                                ZE( byteT* , pbCopy2 ) ;
                        
                                                                                idAdam = ag1.idAdam ;
                                                                                adamGlobal1S& ag1 = *(adamGlobal1S*)pbCopy1 ;
                                                                                //etRock.traceF( tin0P , T("a/ 9 / f") ) ; //U:: TO FIND A BUG
                                                                                _IO_
                                                                            {
                                                                            if( bOk )
                                                                            }
                                                                                thirdC::dosReadProcessMemoryIF( tin0P , pbCopy1 , sizeof( adamGlobal1S ) , bOk , (voidT*)((tin123S&)tin0Copy).pag1 , ((tin123S&)tin0Copy).osPid ) ;
                                                                                _IO_
                                                                            {
                                                                            ZE( boolT , bOk ) ;
                                                                            //etRock.traceF( tin0P , T("a/ 9 / g") ) ; //U:: TO FIND A BUG
                                                                            _IO_
                                                                        {
                                                                        if( pbCopy1 )
                                                                        //etRock.traceF( tin0P , T("a/ 9 / h") ) ; //U:: TO FIND A BUG
                                                                        PUSE.newF( tin0P , LF , pbCopy1 , sizeof( adamGlobal1S ) ) ; ___( pbCopy1 ) ;
                                                                        ZE( byteT* , pbCopy1 ) ;
                                                                        //etRock.traceF( tin0P , T("a/ 9 / i") ) ; //U:: TO FIND A BUG
                                                                        _IO_
                                                                    {
                                                                    ZE( countT , idAdam ) ;
                                                                    ZE( countT , idAdamRoot ) ;
                    
                                                                    tin0S&   tin0Copy     = *(tin0S*)( pbFrom + sizeof( copyHeadS ) ) ;
                                                                    copyHeadS& head     = *(copyHeadS*)pbFrom ;
                                                                    byteT* pbFrom = (byteT*)&(countT&)swTinCopy ;
                                                                    cLeverOsTid = grab.osTidF() ;
                                                                    //etRock.traceF( tin0P , T("a/ 9 / j") ) ; //U:: TO FIND A BUG
                                                                    _IO_
                                                                {
                                                                if( swTinCopy.idSlotOfLeverF( tin0P , grab.osTidF() ) )
                                                                //etRock.traceF( tin0P , T("a/ 9 / k") ) ; //U:: TO FIND A BUG
                                                                _IO_
                                                            {
                                                            if( grab.cGrabbedF() )
                    
                                                            grabC& grab = *(grabC*)pbCopy ;
                                                            //etRock.traceF( tin0P , T("a/ 9 / l") ) ; //U:: TO FIND A BUG
                                                            _IO_
                                                        {
                                                        if( bOk )
                                                        }
                                                            thirdC::dosReadProcessMemoryIF( tin0P , pbCopy , sizeof( grabC ) , bOk , (voidT*)((tin123S&)tin0Copy).glass.pPanLifiGrabbing[ 0 ] , ((tin123S&)tin0Copy).osPid ) ;
                                                            _IO_
                                                        {
                                                        ZE( boolT , bOk ) ;
                                                        //etRock.traceF( tin0P , T("a/ 9 / m") ) ; //U:: TO FIND A BUG
                                                        _IO_
                                                    {
                                                    if( pbCopy )
                                                    //etRock.traceF( tin0P , T("a/ 9 / n") ) ; //U:: TO FIND A BUG
                                                    PUSE.newF( tin0P , LF , pbCopy , sizeof( grabC ) ) ; ___( pbCopy ) ;
                                                    ZE( byteT* , pbCopy ) ;
                                                    //etRock.traceF( tin0P , T("a/ 9 / o") ) ; //U:: TO FIND A BUG
                                                    _IO_
                                                {
                                                case ifcIDtYPEdERIVEDbASEgRABc_grabC :
                                            {
                                            switch( pbg->idTypeCt ) //CS:CODEsYNC: 00104c9 1050104.2
                                            _IO_
                                        {
                                        if( pbg && !bQuitEatingP )
                                        //etRock.traceF( tin0P , T("a/ a") ) ; //U:: TO FIND A BUG
            
                                        }
                                            if( !bOk || getNegAM( recheck ) != FINGERnEG_GRABc ) pbg = 0 ;
                                            }
                                                thirdC::dosReadProcessMemoryIF( tin0P , (byteT*)&recheck , sizeof( recheck ) , bOk , (voidT*)((tin123S&)tin0Copy).glass.pPanLifiGrabbing[ 0 ] , ((tin123S&)tin0Copy).osPid ) ;
                                                _IO_
                                            {
                                            ZE( countT , recheck ) ;
                                            bOk = 0 ;
                                            _IO_
                                        {
                                        else
                                        if( !bOk || getNegAM( pbg->finger ) != FINGERnEG_GRABc ) pbg = 0 ;
                                        }
                                            thirdC::dosReadProcessMemoryIF( tin0P , pbCopy , sizeof( baseGrabC ) , bOk , (voidT*)((tin123S&)tin0Copy).glass.pPanLifiGrabbing[ 0 ] , ((tin123S&)tin0Copy).osPid ) ;
                                            _IO_
                                        {
                                        ZE( boolT , bOk ) ;
            
                                        baseGrabC* pbg = (baseGrabC*)pbCopy ;
                                        //etRock.traceF( tin0P , T("a/ b") ) ; //U:: TO FIND A BUG
                                        _IO_
                                    {
                                    if( pbCopy && !bQuitEatingP )
                                    PUSE.newF( tin0P , LF , pbCopy , sizeof( baseGrabC ) ) ; ___( pbCopy ) ;
                                    ZE( byteT* , pbCopy ) ;
            
                                    bDash |= reportGrabF( tin0P , sRptTin , T("grabbing:") , pcPanLifi ) ;
                                    //countT pcPanLifi[] = { 0 , ((tin123S&)tin0Copy).glass.pPanLifiGrabbing[ 1 ] , ((tin123S&)tin0Copy).glass.pPanLifiGrabbing[ 2 ] } ; // THE PAN IS NOT USED BECAUSE HERE IT IS ALWAYS baseGrabC*, UNLIKE WHAT IS DONE IN THE GRABBED ARRAY
                                    countT pcPanLifi[] = { ((tin123S&)tin0Copy).glass.pPanLifiGrabbing[ 0 ] , ((tin123S&)tin0Copy).glass.pPanLifiGrabbing[ 1 ] , ((tin123S&)tin0Copy).glass.pPanLifiGrabbing[ 2 ] } ;
                                    //etRock.traceF( tin0P , T("a/ c") ) ; //U:: TO FIND A BUG
                                    _IO_
                                {
                                if( ((tin123S&)tin0Copy).glass.pPanLifiGrabbing[ 0 ] && !bQuitEatingP )
                                //etRock.traceF( tin0P , T("a/ d") ) ; //U:: TO FIND A BUG
            
                                }
                                    }
                                        }
                                            bDash |= reportGrabF( tin0P , sRptTin , T("got     :") , ((tin123S&)tin0Copy).pPanLifiRecurseGrabbedLevel + off , ((tin123S&)tin0Copy).osPid ) ;
                                        {
                                        if( ((tin123S&)tin0Copy).pPanLifiRecurseGrabbedLevel[ off ] )
                                    {
                                    for( countT off = 0 ; off < offEnd ; off += 5 )
                                    const countT offEnd = OFFgRABBEDmAX * 5 ;
                                    _IO_
                                {
                                if( ((tin123S&)tin0Copy).glass.cGrabbed )
                    
                                ZE( boolT , bDash ) ;
                            
                                }
                                    sRptTin << (strokeS*)( T("event:    ")+tEventP+T("\r\n") ) ;
                                    bEvent = 1 ;
                                    _IO_
                                {
                                if( osPidEventP == ((tin123S&)tin0Copy).osPid && osTidEventP == ((tin123S&)tin0Copy).osTid )
                    
                                sRptTin << (strokeS*)( T("\r\n\r\n")+TF3(((tin123S&)tin0Copy).glass.idThread,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TP(((tin123S&)tin0Copy).postThreadName,0x10)+T(" ")+TF3(((tin123S&)tin0Copy).glass.idStep,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+TF3(head.cStepsNew,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,9)+tc4+T(((tin123S&)tin0Copy).postTell)+T("\r\n" DASH256 "\r\n") ) ;

                                //CONoUTrAW( TF2(idCycle,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(": ")+TF2(head.idAdamRoot,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(".")+TF2(head.idAdam,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" ")+T(((tin123S&)tin0Copy).postThreadName)+T("\r\n") ) ;
                    
                                }
                                    sRptTin << (strokeS*)( T("\r\n")+TF2(head.idAdamRoot,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("/")+TF2(head.idAdam,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n\r\n") ) ;
                    
                                    idAdamLath     = head.idAdam ;
                                    idAdamRootLath = head.idAdamRoot ;
                                    _IO_
                                {
                                if( idAdamLath != head.idAdam || idAdamRootLath != head.idAdamRoot )
            
                                WRITEaRRAY( pIdProgressNest )                                                                                                                                               /*L*/
                                WRITEaRRAY( pEIPInNest )                                                                                                                                                    /*K*/
                                WRITEaRRAY( pIdInNest )                                                                                                                                                     /*J*/
                                WRITEaRRAY( pFlagsThreadLevelMode )                                                                                                                                         /*I*/
                                WRITEaRRAY( pLFstep )                                                                                                                                                       /*H*/
                                WRITEaRRAYwHERE( pLFnest )                                                                                                                                                       /*G*/
                
                                costai = 1 + thirdC::c_strlenIF( tin0P , ((tin123S&)tin0Copy).postTellIf        ) ; thirdC::c_memcpyIF( tin0P , pbc , ((tin123S&)tin0Copy).postTellIf       , costai )  ; pbc += costai ;               /*F*/
                                costai = 1 + thirdC::c_strlenIF( tin0P , ((tin123S&)tin0Copy).postTellWait      ) ; thirdC::c_memcpyIF( tin0P , pbc , ((tin123S&)tin0Copy).postTellWait     , costai )  ; pbc += costai ;               /*E*/
                                costai = 1 + thirdC::c_strlenIF( tin0P , ((tin123S&)tin0Copy).postTell          ) ; thirdC::c_memcpyIF( tin0P , pbc , ((tin123S&)tin0Copy).postTell         , costai )  ; pbc += costai ;               /*D*/
                                costai = 1 + tc4.csF( tin0P )                                        ; thirdC::c_memcpyIF( tin0P , pbc , tc4                      , costai )  ; pbc += costai ;               /*M*/
                                costai = 1 + thirdC::c_strlenIF( tin0P , ((tin123S&)tin0Copy).postThreadName    ) ; thirdC::c_memcpyIF( tin0P , pbc , ((tin123S&)tin0Copy).postThreadName   , costai )  ; pbc += costai ;               /*C*/
                                ZE( countT , costai ) ;
                
                                thirdC::c_memcpyIF( tin0P , pbc , (byteT*)&((tin123S&)tin0Copy).glass , sizeof( glassS ) ) ; pbc += sizeof( glassS ) ; /*B*/
                                costaVarying += 1 + tc4.csF( tin0P ) ;
                                TN( tc4 , "" ) ; tc4 = T("[")+T((countT*)((tin123S&)tin0Copy).c4Tell)+T("]") ;
                                //etRock.traceF( tin0P , T("a/ e") ) ; //U:: TO FIND A BUG
                                _IO_
                            {                                                                                                                                                           //U:: SUPPORT OPTIONAL ENABLING OF ALL THREAD CHATTER
                            if( !( F(((tin123S&)tin0Copy).flagsThreadMode2) & flTHREADmODE2_MONITORdOnOTrEPORToNmE ) && !bQuitEatingP )                                                 //20250202@1019: FULLY ENABLE THREAD REPORTING, FOR TUNING
                            //if( bEventOnThisThread && /*!head.cStepsNew &&*/ !( F(((tin123S&)tin0Copy).flagsThreadMode2) & flTHREADmODE2_MONITORdOnOTrEPORToNmE ) && !bQuitEatingP )  //20241218@1645: TO REDUCE CPU AND WALL CLOCK CONSUMPTION, REPORT DETAIL IFF (IF AND ONLY IFF) bEventOnThisThread 

                            }
                                CONoUTrAW( os ) ;
                                OStEXTAK( os , "\"\r\n" ) ;
                                OStEXTA(  os , ((tin123S&)tin0Copy).postThreadName ) ;
                                OStEXTAK( os , "\"" ) ;
                                OStEXTC(  os , ((tin123S&)tin0Copy).glass.idThread , 0 ) ;
                                OStEXTAK( os , "suppressing detail for thread " ) ;
                                OStEXT(  os , TUCK ) ;
                            {
                            if( F(((tin123S&)tin0Copy).flagsThreadMode2) & flTHREADmODE2_MONITORdOnOTrEPORToNmE )

                            const boolT bEventOnThisThread = osPidEventP == ((tin123S&)tin0Copy).osPid && osTidEventP == ((tin123S&)tin0Copy).osTid ;

                            //etRock.traceF( tin0P , T("reporting on tin123S [idThread,postThreadName]:    ")+TF2(((tin123S&)tin0Copy).glass.idThread,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(((tin123S&)tin0Copy).postThreadName) ) ;
                
                            tin0S&   tin0Copy     = *(tin0S*)( pbFrom + sizeof( copyHeadS ) ) ;
                            copyHeadS& head     = *(copyHeadS*)pbFrom ;
                            byteT* pbFrom = (byteT*)&(countT&)swTinCopy ;
                            cLeverOsTid = swTinCopy.leverF( tin0P , idf ) ;
                            //etRock.traceF( tin0P , T("a/ f") ) ; //U:: TO FIND A BUG
                            _IO_
                        {
                        for( countT idf = 1 ; idf <= cFlavors && !bQuitEatingP ; idf ++ )
                        ZE( countT , idAdamLath     ) ;
                        ZE( countT , idAdamRootLath ) ;

                        *(countT*)pbc =  timeR2                                                                                                                             ; pbc += sizeof( countT ) ;     /*A*/
                        *(countT*)pbc =  timeR1                                                                                                                             ; pbc += sizeof( countT ) ;     /*A*/
                        *(countT*)pbc = 1  /*IDfORMAT*/                                                                                                                     ; pbc += sizeof( countT ) ;     /*A*/
                        putNegAM( *(countT*)pbc , FINGERnEG_BKmONITOR )                                                                                                     ; pbc += sizeof( countT ) ;     /*A*/
                        //etRock.traceF( tin0P , T("a/ g") ) ; //U:: TO FIND A BUG
                        _IO_
                    {
                    if( pbc && !bQuitEatingP )
                    //CONoUTrAW3( "[cbBookOut]: " , cbBookOut , "\r\n" ) ;
                    byteT* pbc = pbBookOut ;
                    PUSE.newF( tin0P , LF , pbBookOut , cbBookOut ) ; ___( pbBookOut ) ;
                    ZE( byteT* , pbBookOut ) ;
                    //etRock.traceF( tin0P , T("a/ h") ) ; //U:: TO FIND A BUG

                    }
                        countT foo = 2 ;
                    {
                    if( cFlavorsToReport )

                    ;

                        + costaVarying
                        + sizeof( glassS ) * (countT)cFlavorsToReport /*B*/
                        4 * sizeof( countT )                    /*A*/

                    cbBookOut =
                    //etRock.traceF( tin0P , T("a/ i") ) ; //U:: TO FIND A BUG

                    }
                        }
                            ACCsIZE( pIdProgressNest )                                                                                                                                      /*L*/
                            ACCsIZE( pEIPInNest )                                                                                                                                           /*K*/
                            ACCsIZE( pIdInNest )                                                                                                                                            /*J*/
                            ACCsIZE( pFlagsThreadLevelMode )                                                                                                                                /*I*/
                            ACCsIZE( pLFstep )                                                                                                                                              /*H*/
                            ACCsIZEwHERE( pLFnest )                                                       
            
                            costaVarying += 1 + thirdC::c_strlenIF( tin0P , ((tin123S&)tin0Copy).postTellIf     ) ;                                                                                       /*F*/
                            costaVarying += 1 + thirdC::c_strlenIF( tin0P , ((tin123S&)tin0Copy).postTellWait   ) ;                                                                                       /*E*/
                            costaVarying += 1 + thirdC::c_strlenIF( tin0P , ((tin123S&)tin0Copy).postTell       ) ;                                                                                       /*D*/
                            costaVarying += 1 + tc4.csF( tin0P ) ;                                                                                                                           /*M*/
                            costaVarying += 1 + thirdC::c_strlenIF( tin0P , ((tin123S&)tin0Copy).postThreadName ) ;                                                                                       /*C*/
                            TN( tc4 , "" ) ; tc4 = T("[")+T((countT*)((tin123S&)tin0Copy).c4Tell)+T("]") ;
                            //etThread.traceF( tin0P , T("report on me [idMemorySpaceP,cFlavorsToReport]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavorsToReport,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            cFlavorsToReport ++ ;
                        {
                        if( tin0Copy.idTypeTin == ifcIDtYPEtIN_123 && /*!head.cStepsNew &&*/ !( F(((tin123S&)tin0Copy).flagsThreadMode2) & flTHREADmODE2_MONITORdOnOTrEPORToNmE ) )

                        tin0S&  tin0Copy = *(tin0S*)( pbFrom + sizeof( copyHeadS ) ) ;
                        copyHeadS& head = *(copyHeadS*)pbFrom ;
                        byteT* pbFrom = (byteT*)&(countT&)swTinCopy ;
                        cLeverOsTid = swTinCopy.leverF( tin0P , idf ) ;
                        //etThread.traceF( tin0P , T("swTinCopy [idMemorySpaceP,idf]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !bQuitEatingP ; idf ++ )
                    ZE( countT , cFlavorsToReport ) ;
                    //etThread.traceF( tin0P , T("swTinCopy [idMemorySpaceP,cFlavors]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT cFlavors = swTinCopy.cFlavorsF( tin0P ) ;
                    ZE( countT , costaVarying ) ;
                    //etRock.traceF( tin0P , T("a/ j") ) ; //U:: TO FIND A BUG
                    _IO_
                {
                if( !bQuitEatingP )
                ZE( countT , cbBookOut ) ;
                ZE( byteT* , pbBookOut ) ;
                ZE( boolT , bEvent ) ;
                //CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  5\r\n" ) ;
                //etRock.traceF( tin0P , T("a/ k") ) ; //U:: TO FIND A BUG

                memorySpaceP.grab.ungrabF( tin0P ) ;

                }
                    }
                        }
                            }
                                while( ~hWalk && !bQuitEatingP ) ;
                                }
                                    PUSE( tin0P , pbCopyMetaHead ) ;
                                    PUSE( tin0P , pbCopySex ) ;
                                    }
                                        //else if( bChatter ) { CONoUTrAW( "IGNORED sw\r\n" ) ; }
                                        }
                                            }
                                                PUSE( tin0P , pbCopyMetaBitsOwned ) ;
                                                }
                                                    //etThread.traceF( tin0P , T("from meta head [osPid,expCbDrop,expSlots,cSlotsAvoidLo,cSlotsAvoidHi,postName]:    ")+TF2(entry.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF3(pCopyMetaHead->expCbDrop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2)+T("    ")+TF3(pCopyMetaHead->expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2)+T("    ")+TF3(pCopyMetaHead->cSlotsAvoidLo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2)+T("    ")+TF3(pCopyMetaHead->cSlotsAvoidHi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2)+T("    ")+T(pCopyMetaHead->postName) ) ;
                                                    //etThread.traceF( tin0P , T("[osPid,expCbDrop,expSlots,postName]:    ")+TF2(entry.osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(entry.expCbDrop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(entry.expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(entry.postName) ) ;

                                                    }
                                                        }
                                                            }
                                                                pbzGrainCode[ offg ] = '9' ;    // sexC META
                                                            {
                                                            for( countT offg = offGrainStart ; offg < offGrainEnd ; offg ++ ) 

                                                            countT offGrainEnd   = (countT)pCopySex->pbMetaEnd / cbGrain ;
                                                            countT offGrainStart = (countT)pCopySex->pbMeta    / cbGrain ;
                                                        {
                                                        if( pCopySex->pbMeta < pCopySex->pbMetaEnd && (countT)pCopySex->pbMetaEnd < cbGrainSpace )

                                                        }
                                                            }
                                                                pbzGrainCode[ offg ] = '8' ;    // sexC DATA
                                                            {
                                                            for( countT offg = offGrainStart ; offg < offGrainEnd ; offg ++ ) 

                                                            countT offGrainEnd   = (countT)pCopySex->pbDataEnd / cbGrain ;
                                                            countT offGrainStart = (countT)pCopySex->pbData    / cbGrain ;
                                                        {
                                                        if( pCopySex->pbData < pCopySex->pbDataEnd && (countT)pCopySex->pbDataEnd < cbGrainSpace )

                                                        sRptSex << (strokeS*)( TF3(cOwned,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pCopyMetaHead->expCbDrop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pCopyMetaHead->expSlots,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pCopySex->flagsStatePrivate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pCopyMetaHead->cSlotsAvoidLo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(pCopyMetaHead->cSlotsAvoidHi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3((countT)pCopySex->pbData,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(" ")+TF3((countT)pCopySex->pbDataEnd,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(" ")+T(pCopyMetaHead->postName)+tcr ) ;

                                                        }
                                                            if( !bIgnoreLo && !bIgnoreHi && pbCopyMetaBitsOwned[ offb / SB ] & mask ) cOwned ++ ;

                                                            //if( bIgnoreHi && !( pbCopyMetaBitsOwned[ offb / SB ] & mask ) ) etThread.traceF( tin0P , T("error: expected ownership bit not found (high)") ) ;
                                                            //if( bIgnoreLo && !( pbCopyMetaBitsOwned[ offb / SB ] & mask ) ) etThread.traceF( tin0P , T("error: expected ownership bit not found (low)") ) ;

                                                            boolT bIgnoreHi = offb >= cSlots - pCopyMetaHead->cSlotsAvoidHi ;
                                                            boolT bIgnoreLo = offb <           pCopyMetaHead->cSlotsAvoidLo ;

                                                            byteT mask = (byteT)( 1 << offb % SB ) ;
                                                        {
                                                        for( countT offb = 0 ; offb < cSlots ; offb ++ )
                                                        countT cSlots = 1 << pCopyMetaHead->expSlots ;
                                                        ZE( countT , cOwned ) ;
                                                    {
                                                    if( bGotBits )

                                                    }
                                                        thirdC::dosReadProcessMemoryIF( tin0P , pbCopyMetaBitsOwned , cbaMetaBitsOwned , bGotBits , (voidT*)pCopySex->pbzMetaBitsOwned , entry.osPid ) ;
                                                        _IO_
                                                    {
                                                    ZE( boolT , bGotBits ) ;
                                                {
                                                if( pbCopyMetaBitsOwned )

                                                PUSE.newF( tin0P , LF , pbCopyMetaBitsOwned , cbaMetaBitsOwned ) ; ___( pbCopyMetaBitsOwned ) ;
                                                countT cbaMetaBitsOwned = 1 + ( 1 << pCopyMetaHead->expSlots ) / SB ;
                                                ZE( byteT* , pbCopyMetaBitsOwned ) ;
                                            {
                                            if( pCopyMetaHead )

                                            }
                                                if( bOk ) pCopyMetaHead = (sexHeadS*)pbCopyMetaHead ; ;
                                                }
                                                    thirdC::dosReadProcessMemoryIF( tin0P , pbCopyMetaHead , sizeof( sexHeadS ) , bOk , (voidT*)pCopySex->pzMetaHead , entry.osPid ) ;
                                                    _IO_
                                                {
                                                ZE( boolT , bOk ) ;
                                            {
                                            ZE( sexHeadS* , pCopyMetaHead ) ;
                                        {
                                        if( pCopySex ) // pCopySex IS EITHER 0 OR A VALID IMAGE OF A sexC (U:: ADD FINGERPRINT CHECK LIKE tin123S)
                                            
                                        }
                                            if( bOk ) pCopySex = (sexC*)pbCopySex ; ;
                                            }
                                                thirdC::dosReadProcessMemoryIF( tin0P , pbCopySex , sizeof( sexC ) , bOk , (voidT*)entry.pSex , entry.osPid ) ;
                                                _IO_
                                            {
                                            ZE( boolT , bOk ) ;
                                        {
                                        ZE( sexC* , pCopySex ) ;
                                    {
                                    if( pbCopySex && pbCopyMetaHead )
                                    PUSE.newF( tin0P , LF , pbCopyMetaHead , sizeof( sexHeadS ) ) ; ___( pbCopyMetaHead ) ;
                                    PUSE.newF( tin0P , LF , pbCopySex      , sizeof( sexC     ) ) ; ___( pbCopySex      ) ;
                                    ZE( byteT* , pbCopyMetaHead ) ;
                                    ZE( byteT* , pbCopySex ) ;

                                    byteT* pbzGrainCode = (byteT*)&(countT&)sw_pbzGrainCode ;
                                    if( !sw_pbzGrainCode.idSlotOfLeverF( tin0P , cLeverGrainCode ) ) etThread.memSetF( tin0P , (byteT*)&(countT&)sw_pbzGrainCode , cbGrainCode , '.' ) ;
                                    cLeverGrainCode = entry.osPid ;

                                    sexEntryS& entry = *(sexEntryS*)&memorySpaceP.swsSex.downF( tin0P , hWalk ) ;
                                {
                                do
                                handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                        {
                        if( cPlates )
                        sRptSex << (strokeS*)( T("[cPlates]:    ")+TF2(cPlates,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr ) ;
                        countT cPlates = memorySpaceP.swsSex ;
            
                        sRptSex << (strokeS*)( tcr+tcr+textC( tin0P , TAG( TAGiDnULL ) , flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED , memorySpaceP.pczLeverAdam , flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED , 0 , 0 , 0 )+tcr+tcr+T("cOwned   expCbSlo expSlots flagsSta cSlotsLo cSlotsHi pbData   pbDataEn postName")+tcr+tcr ) ;
                        memorySpaceP.pczLeverAdam = (countT*)memorySpaceP.swsSex.leverF( tin0P , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !bQuitEatingP ; idf ++ )
                    sRptSex << (strokeS*)( T("[cFlavors]:    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr+tcr ) ;
                    countT cFlavors = memorySpaceP.swsSex.cFlavorsF( tin0P ) ;
                    _IO_
                {
                if( !bQuitEatingP )
                //CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  6\r\n" ) ;
                //etRock.traceF( tin0P , T("b/ ") ) ; //U:: TO FIND A BUG

                }
                    }
                        }
                            }
                                while( ~hWalk && !bQuitEatingP ) ;
                                }
                                    }
                                        }
                                            pbzGrainCode[ offg ] = '7' ;    // napkinC
                                        {
                                        for( countT offg = offGrainStart ; offg < offGrainEnd ; offg ++ ) 

                                        countT offGrainEnd   = (countT)( entry.pbData + entry.cbData ) / cbGrain ;
                                        countT offGrainStart = (countT)  entry.pbData                  / cbGrain ;
                                    {
                                    if( (countT)entry.pbData + entry.cbData < cbGrainSpace )

                                    sRptNapkin << (strokeS*)( T(entry.postName)+tcr ) ;

                                    byteT* pbzGrainCode = (byteT*)&(countT&)sw_pbzGrainCode ;
                                    if( !sw_pbzGrainCode.idSlotOfLeverF( tin0P , cLeverGrainCode ) ) etThread.memSetF( tin0P , (byteT*)&(countT&)sw_pbzGrainCode , cbGrainCode , ' ' ) ;
                                    cLeverGrainCode = entry.osPid ;

                                    napkinEntryS& entry = *(napkinEntryS*)&memorySpaceP.swsNapkin.downF( tin0P , hWalk ) ;
                                {
                                do
                                handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                        {
                        if( cPlates )
                        sRptNapkin << (strokeS*)( T("[cPlates]:    ")+TF2(cPlates,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr ) ;
                        countT cPlates = memorySpaceP.swsNapkin ;
            
                        sRptNapkin << (strokeS*)( tcr+tcr+textC( tin0P , TAG( TAGiDnULL ) , flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED , memorySpaceP.pczLeverAdam , flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED , 0 , 0 , 0 )+tcr+tcr+T("postName")+tcr+tcr ) ;
                        memorySpaceP.pczLeverAdam = (countT*)memorySpaceP.swsNapkin.leverF( tin0P , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors && !bQuitEatingP ; idf ++ )
                    sRptNapkin << (strokeS*)( T("[cFlavors]:    ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcr+tcr ) ;
                    countT cFlavors = memorySpaceP.swsNapkin.cFlavorsF( tin0P ) ;
                    _IO_
                {
                if( !bQuitEatingP )
                //CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  7\r\n" ) ;
                //etRock.traceF( tin0P , T("c/ ") ) ; //U:: TO FIND A BUG

                }
                    }
                        }
                            }
                                while( ~hWalk && !bQuitEatingP ) ;
                                }
                                    PUSE( tin0P , pbCopy ) ;
                                    }
                                        //else if( bChatter ) { CONoUTrAW( "IGNORED sw\r\n" ) ; }
                                        }
                                            //if( bChatter ) { CONoUTrAW( "COPIED sw\r\n" ) ; }
            
                                            thirdC::c_memcpyIF( tin0P , pbTo + sizeof( copyHeadS ) , (byteT*)pCopy , sizeof( tin123S ) ) ;
            
                                                                                                    entry.idStepLath = ((tin123S*)pCopy)->glass.idStep ;
                                            head.cStepsNew = ((tin123S*)pCopy)->glass.idStep - entry.idStepLath ;
            
                                            head.idAdam     = memorySpaceP.pczLeverAdam[ 1 ] ;
                                            head.idAdamRoot = memorySpaceP.pczLeverAdam[ 0 ] ;
            
                                            copyHeadS& head = *(copyHeadS*)pbTo ;
            
                                            byteT* pbTo = (byteT*)&(countT&)swTinCopy ;
                                            cLeverOsTid = entry.osTid ;
                                            //etThread.traceF( tin0P , T("copying to swTinCopy [idMemorySpaceP,idf]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        {
                                        if( pCopy&& !bQuitEatingP ) // pCopy IS EITHER 0 OR A VALID IMAGE OF A tin123S
                                            
                                        }
                                            }
                                                }
                                                    //U::LOG postThreadName AND idThread

                                                    //LOGrAW9( "tmReportF/detected odor while sniffing tin123S again to verify [bOk,fingerprint,entry.idSerial,idSerial]: " , bOk , "    " , pc2[ 0 ] , "    " , entry.idSerial , "    " , pc2[ 1 ] , "\r\n" ) ;
                                                    pCopy = 0 ;
                                                    //etThread.traceF( tin0P , T("U:: 1 [idf]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( !bOk || getNegAM( pc2[ 0 ] ) != FINGERnEG_TINs || entry.idSerial != pc2[ 1 ] )
                                                }
                                                    thirdC::dosReadProcessMemoryIF( tin0P , (byteT*)pc2 , sizeof pc2 , bOk , (voidT*)( (byteT*)entry.ip ) , entry.osPid ) ;
                                                    _IO_
                                                {
                                                bOk = 0 ;
                                                countT pc2[ 2 ] ; //fingerprint idSerial MUST BE AT OFFSETS 0 4
                                                //etThread.traceF( tin0P , T("U:: 2 [idf]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            else
                                            }
                                                //U::LOG postThreadName AND idThread

                                                //LOGrAW9( "tmReportF/detected odor while sniffing tin123S full [bOk,fingerprint,entry.idSerial,idSerial]: " , bOk , "    " , pCopy->fingerprint , "    " , entry.idSerial , "    " , pCopy->idSerial , "\r\n" ) ;
                                                pCopy = 0 ;
                                                //etThread.traceF( tin0P , T("U:: 3 [idf]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            if( !bOk || getNegAM( pCopy->fingerprint ) != FINGERnEG_TINs || entry.idSerial != pCopy->idSerial )
                                            }
                                                thirdC::dosReadProcessMemoryIF( tin0P , pbCopy , sizeof( tin123S ) , bOk , (voidT*)entry.ip , entry.osPid ) ;
                                                _IO_
                                            {
                                            ZE( boolT , bOk ) ;
                                            //etThread.traceF( tin0P , T("U:: 4 [idf]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        {
                                        if( !entry.bIda && !bQuitEatingP )
                                        tin0S* pCopy = (tin0S*)pbCopy ;
                                        //etThread.traceF( tin0P , T("U:: 5 [idf]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                        //U:: INSPECT pCopy->idTypeTin AND HANDLE CORRECTLY IF NOT tin123S
                                    {
                                    if( pbCopy )
                                    PUSE.newF( tin0P , LF , pbCopy , sizeof( tin123S ) ) ; ___( pbCopy ) ;
                                    ZE( byteT* , pbCopy ) ;
                    
                                    //}
                                    //    CONoUTrAW( ostoSay ) ;
                                    //
                                    //    OStEXTAK( ostoSay , "\"\r\n" ) ;
                                    //    OStEXTA(  ostoSay , entry.postThreadName ) ;
                                    //    OStEXTAK( ostoSay , " , \"" ) ;
                                    //    OStEXTC(  ostoSay , entry.osTid , 0 ) ;
                                    //    OStEXTAK( ostoSay , " , " ) ;
                                    //    OStEXTC(  ostoSay , entry.idTin , 0 ) ;
                                    //    OStEXTAK( ostoSay , " , " ) ;
                                    //    OStEXTC(  ostoSay , entry.idThread , 0 ) ;
                                    //    OStEXTAK( ostoSay , "i [idThread,idTin,osTid,postThreadName]: " ) ;
                                    //    OStEXT(  ostoSay , TUCK ) ;
                                    //
                                    //    bChatter = 1 ;
                                    //{
                                    //if( !etThread.strCompareF( tin0P , T(entry.postThreadName) , T("tm1F") ) )
                                    //ZE( boolT , bChatter ) ;

                                    tinEntryS& entry = *(tinEntryS*)&memorySpaceP.swsTin.downF( tin0P , hWalk ) ;
                                    //etThread.traceF( tin0P , T("U:: 6 [idf]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                {
                                do
                                handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                        {
                        if( cPlates )

                        //etThread.traceF( tin0P , T("swsTin [idMemorySpaceP,cPlates,pczLeverAdam]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cPlates,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(*memorySpaceP.pczLeverAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        countT cPlates = memorySpaceP.swsTin ;
            
                        memorySpaceP.pczLeverAdam = (countT*)memorySpaceP.swsTin.leverF( tin0P , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = memorySpaceP.swsTin.cFlavorsF( tin0P ) ;
                    _IO_
                {
                if( !bQuitEatingP )
                //CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  8\r\n" ) ;
                //etRock.traceF( tin0P , T("d/ ") ) ; //U:: TO FIND A BUG

                memorySpaceP.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
            
                //CONoUTrAW7( "[cbGrainCode,cColsGrainCode,cRowsGrainCode]: " , cbGrainCode , " " , cColsGrainCode , " " , cRowsGrainCode , "\r\n" ) ;

                switchC sw_pbzGrainCode( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cLeverGrainCode , 0 , cbGrainCode ) ;
                ZE( countT , cLeverGrainCode ) ;

                while( cColsGrainCode * cRowsGrainCode < cbGrainCode ) cRowsGrainCode ++ ;
                while( cColsGrainCode * cRowsGrainCode > cbGrainCode ) cRowsGrainCode -- ;
                countT cRowsGrainCode = cColsGrainCode ;
                if( cColsGrainCode < TUCK ) cColsGrainCode = TUCK ;
                while( cColsGrainCode * cColsGrainCode < cbGrainCode ) cColsGrainCode ++ ;
                countT cColsGrainCode = thirdC::c_sqrtIF( cbGrainCode ) ;
                countT cbGrainCode = cbGrainSpace / cbGrain ;
                countT cbGrain = 1 << thirdC::os_expCbAllocationGrain_IF( tin0P ) ;
                countT cbGrainSpace = BM_HIGH ; //ONLY LOWER HALF IS ACCESSIBLE TO APPLICATIONS IN WINDOWS (WIN32)

                #endif

                    soulC sRptLog(    tin0P , etThread , TAG( TAGiDnULL ) ) ; sRptLog    << (strokeS*)T("\r\nLog\r\n\r\n") ;
                    soulC sRptEvent(  tin0P , etThread , TAG( TAGiDnULL ) ) ; sRptEvent  << (strokeS*)T("\r\nEvent Tally\r\n\r\n") ;
                    soulC sRptTin(    tin0P , etThread , TAG( TAGiDnULL ) ) ; sRptTin    << (strokeS*)T("\r\nThreads\r\n\r\n") ;
                    soulC sRptSex(    tin0P , etThread , TAG( TAGiDnULL ) ) ; sRptSex    << (strokeS*)T("\r\n\r\nSex (Slot Extents) (Heap)\r\n") ;
                    soulC sRptNapkin( tin0P , etThread , TAG( TAGiDnULL ) ) ; sRptNapkin << (strokeS*)T("\r\n\r\nNapkin (Shared Memory)\r\n") ;
                    soulC sRptAdd(    tin0P , etThread , TAG( TAGiDnULL ) ) ; sRptAdd    << (strokeS*)T("\r\nAddress Space Usage\r\n") ;
                    soulC sRptTitle(  tin0P , etThread , TAG( TAGiDnULL ) ) ; sRptTitle  << (strokeS*)( T("Glass: Memory Space ")+TF2(idMemorySpaceP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(bSnapShot?" Snapshot":" Minute")+T(" Overview\r\n")+T(bSnapShot?"Snapshot":"Minute by minute")+T(" overview of the state of this home\r\nMinutes since gen: ")+TF2(idCycle,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\nMinute: ")+TF2(idMinute,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n\r\n") ) ;

                #else

                    soulC sRptLog(    tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptLog    ) ; sRptLog    << (strokeS*)T("\r\nLog\r\n\r\n") ;
                    soulC sRptEvent(  tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptEvent  ) ; sRptEvent  << (strokeS*)T("\r\nEvent Tally\r\n\r\n") ;
                    soulC sRptTin(    tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptTin    ) ; sRptTin    << (strokeS*)T("\r\nThreads\r\n\r\n") ;
                    soulC sRptSex(    tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptSex    ) ; sRptSex    << (strokeS*)T("\r\n\r\nSex (Slot Extents) (Heap)\r\n") ;
                    soulC sRptNapkin( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptNapkin ) ; sRptNapkin << (strokeS*)T("\r\n\r\nNapkin (Shared Memory)\r\n") ;
                    soulC sRptAdd(    tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptAdd    ) ; sRptAdd    << (strokeS*)T("\r\nAddress Space Usage\r\n") ;
                    soulC sRptTitle(  tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , ostoFileRptTitle  ) ; sRptTitle  << (strokeS*)( T("Glass: Memory Space ")+TF2(idMemorySpaceP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(bSnapShot?" Snapshot":" Minute")+T(" Overview\r\n")+T(bSnapShot?"Snapshot":"Minute by minute")+T(" overview of the state of this home\r\nMinutes since gen: ")+TF2(idCycle,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\nMinute: ")+TF2(idMinute,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n\r\n") ) ;

                #if !defined( NEVERdEFINED )
                // PRODUCTION: USE jotC (TO ACCOMMODATE LARGE REPORTS)
                // WHEN THAT IS FIXED, CHANGE THE NEXT LINE SO THAT JOT IS USED
                //U:: soulC::operator <<() DOES NOT WORK WHEN THE RHS soulC INSTANCE USES JOT

                OStEXTC(  ostoFileRptLog    , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptLog    , ".soul.rpt.log." ) ;
                OStEXTC(  ostoFileRptLog    , idCycle , 0 ) ;               // TO UNIQUIFY FOR ROBUSTNESS (IF REUSE THE SAME NAME THEN FAILURE TO DELETE A BACKING FILE WOULD AFFECT THE NEXT CYCLE)
                OStEXT(   ostoFileRptLog    , TUCK >> 3 ) ;

                OStEXTC(  ostoFileRptEvent  , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptEvent  , ".soul.rpt.event." ) ;
                OStEXTC(  ostoFileRptEvent  , idCycle , 0 ) ;               // TO UNIQUIFY FOR ROBUSTNESS (IF REUSE THE SAME NAME THEN FAILURE TO DELETE A BACKING FILE WOULD AFFECT THE NEXT CYCLE)
                OStEXT(   ostoFileRptEvent  , TUCK >> 3 ) ;

                OStEXTC(  ostoFileRptTin    , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptTin    , ".soul.rpt.tin." ) ;
                OStEXTC(  ostoFileRptTin    , idCycle , 0 ) ;               // TO UNIQUIFY FOR ROBUSTNESS (IF REUSE THE SAME NAME THEN FAILURE TO DELETE A BACKING FILE WOULD AFFECT THE NEXT CYCLE)
                OStEXT(   ostoFileRptTin    , TUCK >> 3 ) ;

                OStEXTC(  ostoFileRptSex    , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptSex    , ".soul.rpt.sex." ) ;
                OStEXTC(  ostoFileRptSex    , idCycle , 0 ) ;               // TO UNIQUIFY FOR ROBUSTNESS (IF REUSE THE SAME NAME THEN FAILURE TO DELETE A BACKING FILE WOULD AFFECT THE NEXT CYCLE)
                OStEXT(   ostoFileRptSex    , TUCK >> 3 ) ;

                OStEXTC(  ostoFileRptNapkin , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptNapkin , ".soul.rpt.napkin." ) ;
                OStEXTC(  ostoFileRptNapkin , idCycle , 0 ) ;               // TO UNIQUIFY FOR ROBUSTNESS (IF REUSE THE SAME NAME THEN FAILURE TO DELETE A BACKING FILE WOULD AFFECT THE NEXT CYCLE)
                OStEXT(   ostoFileRptNapkin , TUCK >> 3 ) ;

                OStEXTC(  ostoFileRptAdd    , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptAdd    , ".soul.rpt.add." ) ;
                OStEXTC(  ostoFileRptAdd    , idCycle , 0 ) ;               // TO UNIQUIFY FOR ROBUSTNESS (IF REUSE THE SAME NAME THEN FAILURE TO DELETE A BACKING FILE WOULD AFFECT THE NEXT CYCLE)
                OStEXT(   ostoFileRptAdd    , TUCK >> 3 ) ;

                OStEXTC(  ostoFileRptTitle  , idMemorySpaceP , 0 ) ;
                OStEXTAK( ostoFileRptTitle  , ".soul.rpt.title." ) ;
                OStEXTC(  ostoFileRptTitle  , idCycle , 0 ) ;               // TO UNIQUIFY FOR ROBUSTNESS (IF REUSE THE SAME NAME THEN FAILURE TO DELETE A BACKING FILE WOULD AFFECT THE NEXT CYCLE)
                OStEXT(   ostoFileRptTitle  , TUCK >> 3 ) ;

                // bQuitEatingP IS NOT TESTED HERE BECAUSE WE WANT WO LATH REPORT SO THAT WE CAN SEE THE FINAL EVENTS

                etThread.traceF( tin0P , T("generating and writing ")+T(bSnapShot?"snapshot":"minute")+T(" report [idMemorySpaceP,idCycle]:    ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                idCycle ++ ;

                //LOGrAW7( "tmReportF [fliPendingSnapShotRequestP,bSnapShot,idMemorySpaceP]: " , fliPendingSnapShotRequestP , " " , bSnapShot , " " , idMemorySpaceP , "\r\n" ) ;
                //CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  9\r\n" ) ;
                _IO_
            {
            if( !bQuitEatingP )

            if( bSerialize ) bCompileReportP.grabF( tin0P , TAG( TAGiDnULL ) ) ;  // AN OPTIMIZATION TO SERIALIZE USE OF CPU AND ADDRESS SPACE ; 20210707@1737: CONDITIONALLY DISABLED SERIALIZATION SO CAN GET QUICK REPORTS DURING TERMINATION

            bSerialize = 0 ; //20240707@1046: SUPPRESS SERIALIZATION BECAUSE WITH CURRENT Intel i3 CHIPS THERE IS PLENTY OF CPU HORSEPOWER
            boolT bSerialize = !ether ;

            _IO_
        {
        if( ( bChatterP || bSnapShot ) && !bQuitEatingP )
//#if defined( NEVERdEFINED )
//20250202@0953: ENABLED FOR TESTING AND TUNING
//U::20241127@0010: REMOVE IN PRODUCTION ; THIS IS TO REDUCE CPU CONSUMPTION

        }
            //) ) ;
            //        : "not napping, because a minute has passed"
            //        ? "not napping, because i have been fired"
            //    : bQuitEatingP
            //    ? "not napping, because a snapshot has been requested"
            //etRock.traceF( tin0P , T( bSnapShot
            bSnapShot = fliPendingSnapShotRequestP & fliMyBit ;

            }
                else etThread.osSleepF( tin0P , TUCK * 0x40 ) ;
                }
                    break ;
                    timeR2 = timeN2 ;
                    timeR1 = timeN1 ;
                    idMinute = idMinuteTry ;
                {
                if( bDo )

                if( !bDo && ( /*ether ||*/ idMinute != idMinuteTry ) ) bDo = 1 ;    //20221027@1544: NAWWH: 20210706@1608: IF ether THEN DO REPEATEDLY WITHOUT NAPPING, TO REVEAL WHICH THREADS TAKE THE LONGEST TO SHUT DOWN

                else if( idFoTock ) idFoTock = 0 ;
                }
                    }
                        bDo = 1 ;
                        idFoTock = idFoTockTry ;
                    {
                    if( !idFoTock || idFoTock != idFoTockTry )
                {
                if( F(home.flagsUtility) & flHOMEsuTILITY_SNAPsHOT )
                ZE( boolT , bDo ) ;

                countT idFoTockTry = timeN1 >> 0x12 ;        
                countT idMinuteTry = timeN1 >> 0x16 ;    // 8:TUCK 01:TOCK 81:TICK 61:MINUTE(QUARTERTICK)
                // 8:TUCK 01:TOCK 81:TICK 61:MINUTE(QUARTERTICK)

                etThread.osTimeNowF( tin0P ,  timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT  , timeN1 ) ;
            {
            while( !bQuitEatingP && !etThread && !( fliPendingSnapShotRequestP & fliMyBit ) ) // SNAPsHOT REQUEST IS OBEYED IMMEDIATELY

            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        {
        ZE( boolT   , bSnapShot ) ;
        ZE( sCountT , timeR2 ) ;
        ZE( countT  , timeR1 ) ;

        //LOGrAW3( "tmReportF 1 [flHOMEsuTILITY_SNAPsHOT]: " , F(home.flagsUtility) & flHOMEsuTILITY_SNAPsHOT , "\r\n" ) ;
        //CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  a\r\n" ) ;
        //etRock.traceF( tin0P , T("e/ [idMemorySpaceP]: ")+TF2(idMemorySpaceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        _IO_
    {
    while( !bQuitEatingP )
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //bCompileReportP ADDED 20180108@1021
    //etRock.traceF( tin0P , T("f/ ") ) ; //U:: TO FIND A BUG
    ZE( countT , idFoTock ) ; // THIS IS USED ONLY IF flHOMEsuTILITY_SNAPsHOT
    countT idMinute = idMinuteZeP ;
    ZE( countT , idCycle ) ;
    TN( tcr , "\r\n" ) ;

    switchC swTinCopy( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , cLeverOsTid , 0 , sizeof( copyHeadS ) + sizeof( tin123S ) ) ;
    ZE( countT , cLeverOsTid ) ;

    //booksC bkReport( tin0P , TAG( TAGiDnULL ) , tBooks , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER , TICK ) ; //A SEPARATE BOOKS OBJECT IS USED FOR EACH MEMORY SPACE TO ELIMINATE SERIALIZATION COLLISIONS; WHICH ARE SUPPORTED BUT WHY TAKE A CHANCE WITH THE GLASS2!
    //bkReport IS COMMENTED OUT BECAUSE NEVER USED AND CONSUMES SSD SPACE AND WEAR AND TEAR OF SSD
    tBooks = T("minute.reports.memoryspace.")+TF3(idMemorySpaceP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,3) ;
    TN( tBooks , "" ) ;
    TN( tb4 , "    " ) ;

    //etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIEST ) ; //CHANGE TO RUSH IF NEED TO ANALYZE BEHAVIOR INVOLVING CPU PEGGING

    ((tin12S&)tin0P).c4Tell.c1 = idMemorySpaceP ;

    const flagsT fliMyBit = 1 << idMemorySpaceP - ifcIDmEMORYsPACE_min - cSkip ;       //A:ASSUME: THE NUMBER OF NONRESERVED MEMORY SPACE VALUES IS NOT GREATER THAN THE NUMBER OF BITS IN A flagsT INSTANCE

    ;
        : 0
        ? ifcIDmEMORYsPACE_RESERVEDmAX - ifcIDmEMORYsPACE_RESERVEDmIN + 1
    countT cSkip = idMemorySpaceP > ifcIDmEMORYsPACE_RESERVEDmAX

    homeS& home = homeS::homeIF() ;
    //CONoUTrAW3( "tmReportF " , idMemorySpaceP , ":  b\r\n" ) ;
    //etRock.traceF( tin0P , T("g/ ") ) ; //U:: TO FIND A BUG

    //etRock.traceF( tin0P , T("h/ ") ) ; //U:: TO FIND A BUG
    etherC& etRock = etherC::etRockIF( tin0P ) ;

    //}
    //    etRock.traceF( tin0P , T("/ i just called TRACEmYtHREAD") ) ; //U:: TO FIND A BUG
    //    TRACEmYtHREAD ;
    //{
    //if( idMemorySpaceP == 2 )

    etThread.delF( tin0P , pcArgP ) ;
    boolT&        bChatterP                  =        *(boolT*)pcArgP[ 0xb ] ;
    textC&        tEventP                    =        *(textC*)pcArgP[ 0xa ] ;
    countT&       osTidEventP                =       *(countT*)pcArgP[ 0x9 ] ;
    countT&       osPidEventP                =       *(countT*)pcArgP[ 0x8 ] ;
    batonC&       bCompileReportP            =       *(batonC*)pcArgP[ 0x7 ] ;
    osTextT*      postSnapShotRequestP       =       (osTextT*)pcArgP[ 0x6 ] ;
    flagsT&       fliPendingSnapShotRequestP =       *(flagsT*)pcArgP[ 0x5 ] ;
    countT        idMinuteZeP                =                 pcArgP[ 0x4 ] ;
    memorySpaceS& memorySpaceP               = *(memorySpaceS*)pcArgP[ 0x3 ] ;
    stackC&       stPeriodDataP              =       *(stackC*)pcArgP[ 0x2 ] ;
    countT        idMemorySpaceP             =                 pcArgP[ 0x1 ] ;
    boolT&        bQuitEatingP               =        *(boolT*)pcArgP[ 0x0 ] ;
    countT* pcArgP = (countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmReportF )

    }
        thirdC::c_memcpyIF( tin0P , pbc , (byteT*)pci , costai ) ; pbc += costai ;          \
        costai = sizeof( countT ) * ( 1 + thirdC::c_strlenIF( tin0P , pci ) ) ;             \
        ((tin123S&)tin0Copy).get_##arrayP##_F( tin0P , pci , cci + 1 ) ;                    \
        countT pci[ cci + 1 ] ;                                                             \
        const countT cci = sizeof ((tin123S&)tin0P).where.##arrayP ;                        \
    {                                                                                       \
                                                                                            \
#define WRITEaRRAYwHERE(arrayP)                                                             \

    }
        thirdC::c_memcpyIF( tin0P , pbc , (byteT*)pci , costai ) ; pbc += costai ;          \
        costai = sizeof( countT ) * ( 1 + thirdC::c_strlenIF( tin0P , pci ) ) ;             \
        ((tin123S&)tin0Copy).get_##arrayP##_F( tin0P , pci , cci + 1 ) ;                    \
        countT pci[ cci + 1 ] ;                                                             \
        const countT cci = sizeof ((tin123S&)tin0P).##arrayP ;                              \
    {                                                                                       \
                                                                                            \
#define WRITEaRRAY(arrayP)                                                                  \

    }
        costaVarying += sizeof( countT ) * ( 1 + thirdC::c_strlenIF( tin0P , pci ) ) ;      \
        ((tin123S&)tin0Copy).get_##arrayP##_F( tin0P , pci , cci + 1 ) ;                    \
        countT pci[ cci + 1 ] ;                                                             \
        const countT cci = sizeof ((tin123S&)tin0P).##arrayP ;                              \
    {                                                                                       \
                                                                                            \
#define ACCsIZE(arrayP)                                                                     \

    }
        costaVarying += sizeof( countT ) * ( 1 + thirdC::c_strlenIF( tin0P , pci ) ) ;      \
        ((tin123S&)tin0Copy).get_##arrayP##_F( tin0P , pci , cci + 1 ) ;                    \
        countT pci[ cci + 1 ] ;                                                             \
        const countT cci = sizeof ((tin123S&)tin0P).where.##arrayP ;                        \
    {                                                                                       \
                                                                                            \
#define ACCsIZEwHERE(arrayP)                                                                \

;
}
    countT cStepsNew ;
    countT idAdam ;
    countT idAdamRoot ;
{
struct copyHeadS

DONE( tmcMonitorServerF )
}
    }
        DEL( psoP ) ;
        }
            }
                sOut.removeAllF( tin0P ) ;
                psoP->writeF( tin0P , sOut ) ;
                sIn.removeAllF( tin0P ) ;
    
                }
                    #endif

                    }
                        break ;
    
                        etThread.delF( tin0P , psttName ) ;
                        }
                            //etThread.strokeF( tin0P , T("walked  ")+TF1(idMemorySpace)+T(" name \"")+T(psttName)+T("\"\r\n") ) ;
                            THREADmODE2rESTORE
                            poo.walkF( tin0P , ifcIDtYPEpOOLoLDwALK_MONITORwALK1 , info ) ;
                            THREADmODE2oN( flTHREADmODE2_MARKnEWdROPSqUIETdURINGwALK )
                            //etThread.strokeF( tin0P , T("walking ")+TF1(idMemorySpace)+T(" name \"")+T(psttName)+T("\"\r\n") ) ;
                            countT info = (countT)&c8i ;
                            count8S c8i( (countT)&sOut , 0/*idDrop*/ ) ;
                        {
                        if( !POOP )
                        //etThread.strokeF( tin0P , T("this poolOld has ")+TF1(head.cdUsed)+T(" drops in memory [")+TF1(c_pbPool)+T(",")+TF1(c_pbPool+head.offHighWater)+T(",")+TF1(c_pbPool+head.cbPool-1)+T("]\r\n") ) ;
                        countT c_pbPool = (countT)poo.pbPool ;
                        //etThread.strokeF( tin0P , T("received request to walk a poolOld in space ")+TF1(idMemorySpace)+T(" name \"")+T(psttName)+T("\"\r\n") ) ;
                        const poolOldHeaderS& head = poo ;
                        p oolC poo( tin0P , TAG( TAGiDnULL ) , T(psttName) ) ;
    
                        sIn >> psttName ; ___( psttName ) ;
                        ZE( strokeS* , psttName ) ;
                        sIn >> idMemorySpace ;
                        ZE( countT , idMemorySpace ) ;
    
                        sOut << (countT)ifcIDrEPLYgLASS2_POOLoLDwALK1 ;
                    {
                    case ifcIDcMDgLASS2_POOLoLDwALK1 : //U::REPLACE THIS WITH ORTHOGONAL FUNCTIONALITY (REPLY WITH POOLoLD ADDRESS; FORCE CLIENT TO REQUEST IMAGES AND TO DO ITS OWN INSPECTION)
                    }
                        break ;
    
                        etThread.delF( tin0P , psttName ) ;
                        //if( !POOP ) sOut.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_countTptr , (countT*)&(poolOldHeaderS&)poo , sizeof( poolOldHeaderS ) / sizeof( countT ) ) ;
                        p oolC poo( tin0P , TAG( TAGiDnULL ) , T(psttName) ) ;
    
                        //etThread.strokeF( tin0P , T("received request for the header of space ")+TF1(idMemorySpace)+T(" name \"")+T(psttName)+T("\"\r\n") ) ;
                        sIn >> psttName ; ___( psttName ) ;
                        ZE( strokeS* , psttName ) ;
                        sIn >> idMemorySpace ;
                        ZE( countT , idMemorySpace ) ;
    
                        sOut << (countT)ifcIDrEPLYgLASS2_POOLoLDhEADER ;
                    {
                    case ifcIDcMDgLASS2_POOLoLDhEADER : //U::REPLACE THIS WITH ORTHOGONAL FUNCTIONALITY (REPLY WITH POOLoLD ADDRESS; FORCE CLIENT TO REQUEST IMAGES AND TO DO ITS OWN INSPECTION)

                    #if defined( NEVERdEFINED )
                    //COMMENTED OUT WHEN poolC WAS REWRITTEN

                    }
                        break ;

                        swMemorySpaceP.ungrabF( tin0P ) ;
                        }
                            }
                                while( !stName.third && ~hDown ) ;
                                }
                                    sOut << psttn ;
                                    strokeS* psttn = (strokeS*)stName.downF( tin0P , hDown ) ;
                                {
                                do
                                handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( stName )
                            sOut << (countT)stName ;
        
                            }
                                }
                                    while( !stTemp.third && ~hDown ) ;
                                    }
                                        if( !ids ) etThread.delF( tin0P , psttn ) ;
                                        stName.sinkF( tin0P , ids , psttn , flSTACKsINK_UNIQUE ) ;
                                        ZE( countT , ids ) ;
                                        strokeS*& psttn = *(strokeS**)&stTemp.downF( tin0P , hDown ) ;
                                    {
                                    do
                                    handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( stTemp )
            
                                memorySpace.grab.ungrabF( tin0P ) ;
                                }
                                    while( !memorySpace.stPool.third && ~hDown ) ;
                                    }
                                        stTemp << psttn ;
                                        //etThread.strokeF( tin0P , T("entry.postName: \"")+T(entry.postName)+T("\"\r\n") ) ;
                                        etThread.strMakeF( tin0P , LF , psttn , T(entry.postName) ) ; ___( psttn ) ;
                                        ZE( strokeS* , psttn ) ;
                                        poolOldEntryS& entry = *(poolOldEntryS*)&memorySpace.stPool.downF( tin0P , hDown ) ;
                                    {
                                    do
                                    handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( memorySpace.stPool )
                                memorySpace.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
            
                                stackC stTemp( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
                            {
                            stackC stName( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

                            memorySpaceS& memorySpace = *(memorySpaceS*)&(countT&)swMemorySpaceP ;
                            sOut << cLeverIdMemoryP ;
                            cLeverIdMemoryP = swMemorySpaceP.leverF( tin0P , idfm ) ;
                        {
                        for( countT idfm = 1 ; idfm <= cFlavorsMemory ; idfm ++ )
                        sOut << cFlavorsMemory ;
                        countT cFlavorsMemory = swMemorySpaceP.cFlavorsF( tin0P ) ;
                        swMemorySpaceP.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                        sOut << (countT)ifcIDrEPLYgLASS2_POOLoLDnAMES ;
                    {
                    case ifcIDcMDgLASS2_POOLoLDnAMES : //U::REPLACE THIS WITH ORTHOGONAL FUNCTIONALITY (REPLY WITH POOLoLD ADDRESS; FORCE CLIENT TO REQUEST IMAGES AND TO DO ITS OWN INSPECTION)
                    }
                        break ;

                        swMemorySpaceP.ungrabF( tin0P ) ;
                        }
                            memorySpace.grab.ungrabF( tin0P ) ;
                            }
                                sOut << (countT)memorySpace.swTallySay ;
                                sOut << memorySpace.cLeverSay ;
                                memorySpace.cLeverSay = memorySpace.swTallySay.leverF( tin0P , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            sOut << cFlavors ;
                            countT cFlavors = memorySpace.swTallySay.cFlavorsF( tin0P ) ;
                            memorySpace.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                            memorySpaceS& memorySpace = *(memorySpaceS*)&(countT&)swMemorySpaceP ;
                            sOut << cLeverIdMemoryP ;
                            cLeverIdMemoryP = swMemorySpaceP.leverF( tin0P , idfm ) ;
                        {
                        for( countT idfm = 1 ; idfm <= cFlavorsMemory ; idfm ++ )
                        sOut << cFlavorsMemory ;
                        countT cFlavorsMemory = swMemorySpaceP.cFlavorsF( tin0P ) ;
                        swMemorySpaceP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        sOut << (countT)ifcIDrEPLYgLASS2_SAYtALLIES ;
                    {
                    case ifcIDcMDgLASS2_SAYtALLIES :
                    }
                        break ;

                        swMemorySpaceP.ungrabF( tin0P ) ;
                        }
                            memorySpace.grab.ungrabF( tin0P ) ;
                            }
                                }
                                    while( ~hWalk ) ;
                                    }
                                        sOut << (countT)entry.ip ;
                                        sOut << (countT)entry.bIda ;
                                        sOut << (countT)entry.osPid ;
                                        tinEntryS& entry = *(tinEntryS*)&memorySpace.swsTin.downF( tin0P , hWalk ) ;
                                    {
                                    do
                                    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( cPlates )
                                sOut << cPlates ;
                                countT cPlates = memorySpace.swsTin ;
                                memorySpace.pczLeverAdam = (countT*)memorySpace.swsTin.leverF( tin0P , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            sOut << cFlavors ; //U::CLIENT CODE IS OBSOLETE BECAUSE IT DOESNT KNOW ABOUT cFlavors AND THAT MULTIPLE FLAVORS FOLLOW
                            countT cFlavors = memorySpace.swsTin.cFlavorsF( tin0P ) ;
                            memorySpace.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                            memorySpaceS& memorySpace = *(memorySpaceS*)&(countT&)swMemorySpaceP ;
                            sOut << cLeverIdMemoryP ;
                            cLeverIdMemoryP = swMemorySpaceP.leverF( tin0P , idfm ) ;
                        {
                        for( countT idfm = 1 ; idfm <= cFlavorsMemory ; idfm ++ )
                        sOut << cFlavorsMemory ;
                        countT cFlavorsMemory = swMemorySpaceP.cFlavorsF( tin0P ) ;
                        swMemorySpaceP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        sOut << (countT)ifcIDrEPLYgLASS2_tin123S ;
                    {
                    case ifcIDcMDgLASS2_tin123S :
                    }
                        break ;

                        ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbCopy ) ;
                        if( bOk ) sOut.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_byteTptr , pbCopy , cbAt ) ;
                        sOut << bOk ;
                        sOut << (countT)ifcIDrEPLYgLASS2_IMAGE ;

                        if( pbCopy ) thirdC::dosReadProcessMemoryIF( tin0P , pbCopy , cbAt , bOk , pvAt , osPid ) ;
                        ((tin1S&)tin0P).pEtScratch->newF( tin0P , LF , pbCopy , cbAt ) ; ___( pbCopy ) ;
                        ZE( boolT , bOk ) ;
                        ZE( byteT* , pbCopy ) ;

                        sIn >> cbAt ;
                        ZE( countT , cbAt ) ;
                        sIn >> *(countT*)&pvAt ;
                        ZE( voidT* , pvAt ) ;
                        sIn >> osPid ;
                        ZE( countT , osPid ) ;
                    {
                    case ifcIDcMDgLASS2_IMAGE :
                {
                switch( idCmd )
                sIn >> idCmd ;
                ZE( countT , idCmd ) ;
            {
            else
            if( POOP ) { POOPR DEL( psoP ) ; }
    
            psoP->readF( tin0P , sIn ) ;
        {
        while( !POOP && !etThread && !ether && psoP )
        soulC sOut( tin0P , etThread , TAG( TAGiDnULL ) ) ;
        soulC sIn(  tin0P , etThread , TAG( TAGiDnULL ) ) ;
    
        psoP->etherF( tin0P , *((tin1S&)tin0P).pEtScratch ) ;
        SCOOPS
    {
    IFsCRATCHoK

    ((tin12S&)tin0P).c4Tell.c1 = cLeverIdMemoryP ;

    switchC& swMemorySpaceP  = *(switchC*)pTaskP->c3 ;
    countT&  cLeverIdMemoryP =  *(countT*)pTaskP->c2 ;
    socketC* psoP            =  (socketC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TELL( "setting up" )
TASK( tmcMonitorServerF ) //REN tmServerF

//20250406@1959: ADDED bSlowAllP AND tmSlowAllF SO CAN SLOW DOWN ALL PROCESSES THAT I AM DEBUGGING
//20250404@1728: ADDED bSuspendAllP AND tmSuspendAllF SO CAN SUSPEND ALL PROCESSES THAT I AM DEBUGGING
//20230315@1040: ADDED bChatterP AND tmChatterF SO CAN ENABLE THE GENERATION OF MINUTE REPORTS BY CREATING A SEMAPPHORE FILE
//20230306@0731: DISABLED TO REDUCE BATTERY AND SSD USAGE
//20230306@0731: ENABLED TO GLASS PRODUCTION
//20230212@1503: DISABLED TO REDUCE BATTERY AND SSD USAGE (U::ENHANCE TO USE A SEMAPHORE FILE TO REQUEST REPORTS)
//20221029@1834: ENABLED REPORTING FOR PRODUCTION
//20191006@1847: ENABLED FOR TESTING AND DEBUGGING
//U:: IT IS BEING UNCOMMENTED ONLY TO INVESTIGATE WHETHER THIS CODE IS THE CULPRIT FOR LONG QUIT TIMES
//U:: IN PRODUCTION, THE IFDEF SHOULD BE COMMENTED OUT SO THAT THE CODE IS TESTED BY PRODUCTION
//U:: 20190129: USING THE BATON MIGHT ALSO IMPACT QUIT QUALITY SO AT THIS TIME THE IFDEF IS BEING UNCOMMENTED
//U::WORKAROUND: THE USE OF THE BATON IN THE NEXT LINE REQUIRES REGRESSION DEBUGGING.  THE GOAL IS TO REDUCE ADDRESS SPACE FOOTPRINT TO HOPEVULLY ELIMMINATE THE ADDRESS SPACE EXHAUSTION BLAMMO ON FACTORY3
//CHATTER (MINUTE REPORTS)

#include postADAMhEADER

/*1*//*ifcIDaDAM_2GLASS2 2*//*1*/

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
