
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        //etThread.traceF( tin0P , T("napped") ) ;
        ++ s ; etThread.osSleepF( tin0P , TOCK << 2 ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        //etThread.traceF( tin0P , T("napping") ) ;

        if( bQuit ) break ;

        while( !ether && ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                }
                    }
                        }
                            }
                                etThread.delF( tin0P , psttHe ) ;
                                etThread.traceF( tin0P , TF2(*(countT*)pbEncodedHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tp4+T(psttHe) ) ;
                                etThread.strDecodeF( tin0P , psttHe , pbEncodedHe + sizeof( countT ) ) ; ___( psttHe ) ;
                                ZE( strokeS* , psttHe ) ;
                            {
                            else
                            if( !pbEncodedHe || !cbEncodedHe ) break ;
                        
                            countT       cbEncodedHe = pageHe ;
                            const byteT* pbEncodedHe = pageHe ;
                        
                            pageC pageHe = jhsWo ;
                        {
                        while( !ether )

                        jotC jhsWo( tin0P , tShorter , flJOTc_null , TICK << 2 , TOCK << 6 , 1 , ifcIDgRABlAYER_7BASEmISC2 ) ;   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)

                        etThread.traceF( tin0P , tShorter ) ;
                        etThread.traceF( tin0P , tShort ) ;

                        }
                            etThread.delF( tin0P , psttShorter ) ;
                            tShorter = T(psttShorter) ;
                            etThread.strSubstringF( tin0P , psttShorter , idf , sttq , tDotJotDot , tShort ) ; ___( psttShorter ) ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                            ZE( countT , idl ) ;
                            countT idf = 1 ;
                            ZE( strokeS* , psttShorter ) ;
                        {
                        TN( tShorter , "" ) ;       // jotAccessEvents.hash.string.browser

                        }
                            etThread.delF( tin0P , psttShort ) ;
                            tShort = T(psttShort) ;
                            etThread.delF( tin0P , psttnu ) ;
                            etThread.strBisectF( tin0P , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShort , "" ) ;             // jotAccessEvents.hash.string.browser.jotC.index.booksC.1.book.00000001.00000001.bookC
                    {
                    if( !bDir )

                    const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;

                    //TN( tIfoName , pInfo->psttIfoName ) ;
                {
                if( 1 == etThread.strIdOptimizedClosureF( tin0P , 0 , flSTRmATCH_null , countTC( 1 ) , strokeS( 0 , sc_IGNOREqUOTES ) , patternC( tin0P , etThread , T("jotAccessEvents.hash.string.*.jotC.index.booksC.1.book.00000001.00000001.bookC") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) , pInfo1->psttIfcName ) )
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirOldF( tin0P , pInfo , hFind , tLike ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    {
    while( !bQuit && !POOP )
    const boolT& bQuit = *(const boolT*)&(const countT&)ether ;

    TN( tp4 , "    " ) ;
    TN( tDotJotDot , ".jotC." ) ;
    TN( tDot , "." ) ;
    TN( tSlash , "/" ) ;
    TN( tLike , "" ) ; tLike = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/")+tUser+T("/" STR( ifcIDmEMORYsPACE_APPLICATION ) "/stateSpaces/ffffefff/*") ;
    TN( tUser , thirdC::postUserNameIF() ) ;
{

TODO


/*1*/WAKEhIDE( "scratch.9.inactive.probably.doodle.jotC" )/*1*/
/**/
*/
 if this happens, all page books must be manually deleted and then regenerated (by editing my code to make me enabled during the initial reading)
 it is critically important to never fire me when new events have been booked but i have not yet "page booked" them
 i enable myself only after reading all existing booked events, when i nap for the woth time
during initialization, i assume that all existing booked events have already been "page booked' and ignore them
 on output, each access event is written to a book dedicated to the corresponding idJot pair that identifies [container] [uri]
 the idJot values identify strings that i place into jotC instances
 on output, each access event soulC contains idJot values rather than string values
 on input, each access event soulC is self sufficient in that it contains string values
i "divide and conquer" by distributing access events to a dedicated booksC instance for each hash of [container] || [uri]
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
