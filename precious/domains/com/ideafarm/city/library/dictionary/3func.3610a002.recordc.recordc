
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            THREADmODE4rESTORE
            *(countT*)vspIdgAccessBegun = idgAccess ;                                                                                                       // ... STORE MY idgAccess IN FIELD IDGaCCESSbEGUN OF RECORD pczNameP
            THREADmODE4oN( flTHREADmODE4_ALLOWwRITEABLEpOINTERgET )
            
            countVSP vspIdgAccessBegun = listC::countIF( tinP , hList , count2S( LISTnAMEsYS_IDGaCCESSbEGUN ) ) ;
        {
        if( !POOP && idgAccess )                                                                                                                            // IF !POOP AND pczNameP IS NOT THE globals RECORD ...

        }
            }
                while(       !idgAccess ) ;
                do *(countT*)&idgAccess = 1 + incv02AM( *pcIdgAccessBegun ) ;
                                                                                                                                                            // ... SET idgAccess TO A VALUE NEWLY DISPENSED FROM THE globals RECORD
                THREADmODE4rESTORE
                countT*  pcIdgAccessBegun = vspIdgAccessBegun ;
                THREADmODE4oN( flTHREADmODE4_ALLOWwRITEABLEpOINTERgET )
                countVSP vspIdgAccessBegun = listC::countIF( tinP , globals , count2S( LISTnAMEsYS_IDGaCCESSbEGUN ) ) ;
            {
            if( !POOP )

            __( (const countT&)(const poopC&)globals ) ;
            recordC globals( tinP , count4S( LISTnAMEsYS_ROOT , LISTnAMEsYS_ROOTaPPLICATION , LISTnAMEsYS_GLOBALrECORD ) , flLISToPEN_null , idGrabLayerP ) ;
        {
        if( !POOP && ( pczNameP[ 0 ] != LISTnAMEsYS_ROOT || pczNameP[ 1 ] != LISTnAMEsYS_ROOTaPPLICATION || pczNameP[ 2 ] != LISTnAMEsYS_GLOBALrECORD || pczNameP[ 3 ] ) )        // IF pczNameP DOES NOT NAME THE GLOBALS RECORD (TO AVOID INFINITE RECURSION) ...

        }
            __( !hList ) ;
            listC::openIF( tinP , hList , pczName , flagsP ) ;
            thirdC::c_memcpyIF( tinP , (byteT*)pczName , (byteT*)pczNameP , cba ) ;
        {
        if( !POOP )
        __Z( pczName ) ;

        }
            PUSE.newF( tinP , LF , *(byteT**)&pczName , cba ) ; ___( pczName ) ;
            cba = sizeof( countT ) * ( 1 + thirdC::c_strlenIF( tinP , pczNameP ) ) ;
            puseC puseat( tinP , ifcIDpOOL_ADAMtEMP ) ;
        {
        ZE( countT , cba ) ;
    {
    if( !POOP )

    grabitx.grabF( tinP , TAG( TAGiDnULL ) ) ;

    SCOOP

    }
        if( POOP ) return ;
        FV(flLISToPEN,flagsP) ;
        LNV( pczNameP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
idgAccess( 0 )
pEditOut( 0 ) ,
flagsFieldOpen( flLISToPEN_null ) ,
cFieldName( 0 ) ,
hList( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ,
pczName( 0 ) ,
grabitx( tinP , TAG( TAGiDnULL ) , 0 , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_SHARElAYER | flGRABITc_NOTjEALOUS , 0 , idGrabLayerP ) ,
/*1*/recordC::recordC( tinBaseS& tinP , const countT* const pczNameP , const flagsT flagsP , const countT idGrabLayerP ) :/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

