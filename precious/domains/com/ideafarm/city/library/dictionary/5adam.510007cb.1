
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;

etThread.traceF( tin0P , T("ok") ) ;

}
    break ; //REMOVE FOR BURN-IN TESTING

    cReceivedFileWindows = 0 ;
    etThread.traceF( tin0P , T("received [cReceivedFileWindows]:    ")+TF2(cReceivedFileWindows,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    etThread.traceF( tin0P , T("process [mTocks]:    ")+TT(timeE1,timeE2)+tb4+TF2(mTocksE,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tin0P , T("throw   [mTocks]:    ")+TT(timeT1,timeT2)+tb4+TF2(mTocksT,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tin0P , T("[mGBits]:            ")+TF2(mGBits,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tin0P , T("[cGram]:            ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    measureT mGBits = (measureT)( cb04Thrown << 3 ) / ( TICK << 2 ) ;

    measureT mTocksE = (measureT)timeE1 / TOCK ;
    measureT mTocksT = (measureT)timeT1 / TOCK ;

    etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO PROCESS
    etThread.osTimeNowF( tin0P , timeE1 , timeE2 ) ;
    ZE( sCountT , timeE2 ) ;
    ZE( countT  , timeE1 ) ;

    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    etThread.osTimeSubtractF( tin0P , timeT1 , timeT2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO THROW
    etThread.osTimeNowF( tin0P , timeT1 , timeT2 ) ;
    ZE( sCountT , timeT2 ) ;
    ZE( countT  , timeT1 ) ;

    }
        }
            etThread.delF( tin0P , psttName ) ;

            }
                ether.osSleepF( tin0P , TOCK >> 3 ) ;
                sThrow.writeF( tin0P , idPortEndpointCatcher , nicNameC() , pbGram , head.cbThisGram ) ;
            {
            while( !ether && cDo -- )
            countT cDo = 8 ;
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

            head.cbThisGram = sizeof head + cbPayload ;
            head.idFileHi   = 0 ;
            head.idFileLo   = 1 ;
            head.secret     = secretToUse ;
            head.idCmd      = ifcIDcMDuDPfILEgRAM_PUTbASEosfILEnAME ;

            countT cbPayload = thirdC::c_strlenIF( tin0P , pbPayload ) ;
            thirdC::c_strcpyIF( tin0P , pbPayload , T(psttName) ) ;

            udpFileGramHeadBaseOSFileNameS& head      = *(udpFileGramHeadBaseOSFileNameS*)pbGram ;
            byteT*                          pbPayload = pbGram + sizeof( udpFileGramHeadBaseOSFileNameS ) ;
            byteT                           pbGram[ sizeof( udpFileGramHeadBaseOSFileNameS ) + CBuDPfILEnAMEpAYLOAD ] ;

            etThread.strMakeF( tin0P , LF , psttName , T("///ideafarm/tmp/foo.from.udp.ttt") ) ; ___( psttName ) ;
            ZE( strokeS* , psttName ) ;
        {
        if( !ether )

        }
            etThread.delF( tin0P , psttHash ) ;

            }
                ether.osSleepF( tin0P , TOCK >> 3 ) ;
                sThrow.writeF( tin0P , idPortEndpointCatcher , nicNameC() , (byteT*)&gram , sizeof gram ) ;
            {
            while( !ether && cDo -- )
            countT cDo = 8 ;
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

            thirdC::c_memcpyIF( tin0P , gram.postHash , T(psttHash) , sizeof gram.postHash ) ;
            gram.cbFileHi   = (countT)( cbDone >> 0x20 ) ;
            gram.cbFileLo   = (countT)cbDone ;
            gram.idFileHi   = 0 ;
            gram.idFileLo   = 1 ;
            gram.secret     = secretToUse ;
            gram.idCmd      = ifcIDcMDuDPfILEgRAM_PUThASHoFcONTENT ;
            gram.cbThisGram = sizeof gram ;
            if( psttHash && psttHash->idAdam != sizeof gram.postHash ) { BLAMMO ; }
            udpFileGramHeadHashOfContentS gram ;

            hasher.queryStringF( tin0P , psttHash ) ; ___( psttHash ) ;
            ZE( strokeS* , psttHash ) ;
        {
        if( !ether )

        }
            }
                }
                    cbDone += cbNow ;
                    pbc    += cbNow ;

                    cb04Thrown += cbGram ;
                    cThrown ++ ;

                    sThrow.writeF( tin0P , idPortEndpointCatcher , nicNameC() , pbGram , cbGram ) ;
                    //if( !( idGram % TUCK ) ) etThread.traceF( tin0P , T("sending [idGram,cbNow,cbGram]:    ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT cbGram = sizeof( udpFileGramHeadFileWindowS ) + cbNow ;
                    //CONoUTrAW( "!" ) ;
                    etThread.memCopyF( tin0P , pbPayload , pbc , cbNow ) ;
                    head.secret = secretToUse ;
                    head.len    = cbNow  ;
                    head.off    = cbDone ;
                    head.cbThisGram = sizeof head + cbNow ;
                    //etThread.traceF( tin0P , T("throwing window [secretToUse]:    ")+TF2(secretToUse,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    //CONoUTrAW( "+" ) ;

                    idGram ++ ;

                    cbDo -= cbNow ;

                    ;
                        : CBuDPfILEpAYLOAD
                        ? cbDo
                    countT cbNow = cbDo < CBuDPfILEpAYLOAD

                    //etThread.traceF( tin0P , T("waited  for a secret") ) ;
                    }
                        Sleep( 100 ) ;
                    {
                    while( !secretToUse )
                    //etThread.traceF( tin0P , T("waiting for a secret") ) ;
                {
                while( cbDo )
                countT cbDo = cbw ;
                byteT* pbc = pbw ;

                //etThread.boxPutF( tin0P , tFileIn+T(".window.")+tIdWindow , pbw , cbw ) ;
                //etThread.traceF( tin0P , T("[tIdWindow,cb]:    ")+tIdWindow+tb4+TF2(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                TN( tIdWindow , "" ) ; tIdWindow = TF3(++idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;

                hasher.eatF( tin0P , pbw , cbw ) ;
            {
            else
            if( !pbw || !cbw ) break ;

            fwsIn.getF( tin0P , pbw , cbw ) ;
            ZE( countT , cbw ) ;
            ZE( byteT* , pbw ) ;
        {
        while( !ether )
        ZE( count04T , cbDone ) ;
        ZE( countT , idWindow ) ;
        hasherC hasher( tin0P , etThread ) ;

        head.idMeta     = 0 ;
        head.idMetaType = ifcIDuDPfILEmETAtYPE_CONTENT ;
        head.idFileHi     = 0 ;
        head.idFileLo     = 1 ;
        head.idCmd      = ifcIDcMDuDPfILEgRAM_PUTfILEwINDOW ;

        udpFileGramHeadFileWindowS& head      = *(udpFileGramHeadFileWindowS*)pbGram ;
        byteT*                      pbPayload = pbGram + sizeof( udpFileGramHeadFileWindowS ) ;
        byteT                       pbGram[ sizeof( udpFileGramHeadFileWindowS ) + CBuDPfILEpAYLOAD ] ;

        fileWindowsC fwsIn( tin0P , etThread , tFileIn ) ;

        sThrow.bindF( tin0P ) ;
        socketC sThrow( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
    {
    ZE( countT , idGram ) ;

    etThread.osTimeNowF( tin0P , timeA1 , timeA2 ) ;
    ZE( sCountT , timeA2 ) ;
    ZE( countT  , timeA1 ) ;
{
while( !ether )
TN( tFileIn     , "///d/tmp/foo.ttt" ) ;
ZE( count04T , cb04Thrown ) ;
ZE( countT , cThrown ) ;

//++ s ; ether.osSleepF( tin0P , TICK << 4 ) ;         //U:: TO FIND A BUG
++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;         // LET WORKER THREADS GET SET UP

etThread.traceF( tin0P , T("waited  for woth secret") ) ;
}
    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
{
while( !secretToUse && !ether )
etThread.traceF( tin0P , T("waiting for woth secret") ) ;

CONoUTrAW( "\r\n" ) ;

}
    etThread.osThreadF( TaRG1( tmUdpFileGetSecretF  ) , (countT)&secretToUse , (countT)&psoEndpointThrower , (countT)&grab_psoEndpointThrower , idPortEndpointCatcher , pcNnMe[ 0 ] , pcNnMe[ 1 ] , pcNnMe[ 2 ] , pcNnMe[ 3 ] ) ;
    const count02T* pcNnMe = nnMe ;
    nicNameC nnMe ;
{

TN( tb4 , "    " ) ;

}
    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
{
while( ( !idPortEndpointCatcher || !psoEndpointThrower ) && !ether )
sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

etThread.osThreadF( TaRG1( tmUdpFilesEndpointThrowerF ) , (countT)&psoEndpointThrower   , (countT)&grab_psoEndpointThrower   , (countT)&secretToUse          ) ;
etThread.osThreadF( TaRG1( tmUdpFilesEndpointCatcherF ) , (countT)&psoEndpointCatcherNU , (countT)&grab_psoEndpointCatcherNU , (countT)&cReceivedFileWindows ) ;
grabC grab_psoEndpointThrower(   tin0P , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS ) ;
grabC grab_psoEndpointCatcherNU( tin0P , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS ) ;
ZE( socketC* , psoEndpointCatcherNU ) ;
ZE( socketC* , psoEndpointThrower ) ;
ZE( countT , secretToUse ) ;

ZE( countT , cReceivedFileWindows ) ;

TODO

DONE( tmUdpFilesEndpointThrowerF )
}
    etThread.ifcUdpFilesEndpointF( tin0P , ether , idPortEndpointThrowerNU , TICK >> 0 , psoEndpointP , grab_psoEndpointP , pSecretToUseP ) ;
    ZE( countT , idPortEndpointThrowerNU ) ;

    countT*   pSecretToUseP     =    (countT*)pTaskP->c3 ;
    grabC&    grab_psoEndpointP =    *(grabC*)pTaskP->c2 ;
    socketC*& psoEndpointP      = *(socketC**)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmUdpFilesEndpointThrowerF )

DONE( tmUdpFilesEndpointCatcherF )
}
    etThread.ifcUdpFilesEndpointF( tin0P , ether , idPortEndpointCatcher , TICK >> 0 , psoEndpointP , grab_psoEndpointP , 0 , &cReceivedFileWindowsP ) ;

    countT&   cReceivedFileWindowsP =   *(countT*)pTaskP->c3 ;
    grabC&    grab_psoEndpointP     =    *(grabC*)pTaskP->c2 ;
    socketC*& psoEndpointP          = *(socketC**)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmUdpFilesEndpointCatcherF )



countT   idPortEndpointCatcher ;    // THIS MUST BE PUBLISHED BY CATCHER SO THAT IT CAN BE KNOWN TO THROWER


//BASELINE: 510007cb

/*1*/WAKEsHOWtEXT( "example.dut.3func.36002200.etherC.ifcUdpFilesEndpointF.declare.content.hash.and.base.os.file.name" )/*1*/
/**/
*/
 this code works and suggests that code like this can keep up with incoming datagrams on a 1 gbit per second wire
 instead, secrets are honored for unlimited requests within an epoch (e.g. a tock or tock << 2)
 i eliminate the concept of ttl for each secret per requester
 baseline: 5adam.510007c2.1
i use hash to map ip address to secret in order to bound the size of the state needed for deluge of spoofed requests for secret
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
