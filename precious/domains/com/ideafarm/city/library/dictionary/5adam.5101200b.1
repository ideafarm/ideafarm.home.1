
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    display.set_pDeviceCBF_F( tinP , pDeviceNewCBF , cArgNew , pDeviceOldCBF , cArgOld ) ;
    ZE( countT     , cArgNew       ) ;
    ZE( deviceCBFT , pDeviceNewCBF ) ;

    etherC::loafIF( tinP ) ;

    display.ungrabF( tinP ) ;

    display.set_pDeviceCBF_F( tinP , pDeviceOldCBF , cArgOld , deviceCBF , (countT)pcArg ) ;
    ZE( countT     , cArgOld       ) ;
    ZE( deviceCBFT , pDeviceOldCBF ) ;

    countT pcArg[] = { (countT)&paper , (countT)&paper , (countT)&paperBW , (countT)&surf , (countT)&eye } ;

    }
#endif
        eye.moveF( tinP , vDeltaAt , aBad ) ;
        aBad += PI / 16.0 ;
        display.grabF( tinP , TAG( TAGiDnULL ) ) ;
        Sleep( 4000 ) ;
        display.ungrabF( tinP ) ;
        //U:: TO FIND A BUG

        eye.moveF( tinP , vDeltaAt , aBad ) ;
        aBad += PI / 16.0 ;
        display.grabF( tinP , TAG( TAGiDnULL ) ) ;
        Sleep( 4000 ) ;
        display.ungrabF( tinP ) ;
        //U:: TO FIND A BUG

        eye.moveF( tinP , vDeltaAt , aBad ) ;
        aBad += PI / 16.0 ;
        display.grabF( tinP , TAG( TAGiDnULL ) ) ;
        Sleep( 4000 ) ;
        display.ungrabF( tinP ) ;
        //U:: TO FIND A BUG
#if defined( NEVERdEFINED )

        eye.moveF( tinP , vDeltaAt , aBad ) ;

        //display.grabF( tinP , TAG( TAGiDnULL ) ) ;
        //Sleep( 4000 ) ;
        //display.ungrabF( tinP ) ;
        //U:: TO FIND A BUG

        vectorOldC vDeltaAt( tinP , etThread ) ;
        }
            aBad = 0 ;
            //aBad = PI / 2.0 ;
            //aBad = etThread.strDigitsToMeasureF( tinP , tStr , 0 , 0 ) ;
            //TN( tStr , "100+^bf1291." ) ;
        {
        ZE( measureT , aBad ) ;
    {

    display += eye ;
    eye += surf ;
    eyeC eye( tinP , etThread ) ;

    surf += paper ;
    surfC surf( tinP , etThread , 0 , surfaceCBF , (countT)&sin , 0 , 0 , flSURFc_NOsMOOTHIES ) ;
    surfS sin ;

    display.grabF( tinP , TAG( TAGiDnULL ) ) ;

    displayC& display = *pDisplay ;
{
if( pDisplay )
displayC* pDisplay = displayC::pDisplayIF() ;

}
    etThread.delF( tinP , psttSay ) ;
    paperBW.strokeF( tinP , psttSay ) ;

        }
            scSize += DELTA ;

            //APPENDcc( psttSay , sc_ccLINEpEL ,   scSize , - scSize ) ;
            //APPENDcc( psttSay , sc_ccLINEpEL ,   0      , - scSize ) ;
            //APPENDcc( psttSay , sc_ccLINEpEL , - scSize , - scSize ) ;
            //APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ;
            //APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   scSize ) ;
            //APPENDcc( psttSay , sc_ccLINEpEL ,   0      ,   scSize ) ;
            //APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   scSize ) ;
            APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;

            APPENDcc( psttSay , sc_ccMOVEpEL , - (sCountT)( DELTA >> 1 ) , - (sCountT)( DELTA >> 1 ) ) ;
        {
        while( cDo -- )
        sCountT scSize = SIZE ;
        APPENDmm( psttSay , sc_mmMOVEtO  , 0.5 , 0.5 ) ;
        countT cDo = 1 ;

    APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;
    APPENDcc( psttSay , sc_cPUSHiDgRID , 3 , 0 ) ;

    etThread.strMakeF( tinP , LF , psttSay , 0 , TOCK ) ; ___( psttSay ) ;
    ZE( strokeS* , psttSay ) ;
{
paperC paperBW( tinP , etThread , TUCK , TUCK ) ;

}
    etThread.delF( tinP , psttSay ) ;
    paper.strokeF( tinP , psttSay ) ;

    #endif

        }
            scSize += DELTA ;

            #endif

                #endif

                    APPENDcc( psttSay , sc_ccLINEpEL ,   scSize , - scSize ) ;
                    APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_ORANGE , 0 ) ;
                    APPENDcc( psttSay , sc_ccLINEpEL ,   0      , - scSize ) ;
                    APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_BROWN , 0 ) ;

                #if !defined( CHEAT )

                APPENDcc( psttSay , sc_ccLINEpEL , - scSize , - scSize ) ;
                APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_C4 , 0 ) ;
                APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ;
                APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_P4 , 0 ) ;
                APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   scSize ) ;     //CAN DO 1 GLYPH OF 4 LINES
                APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_Y4 , 0 ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   0      ,   scSize ) ;
                APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_B4 , 0 ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   scSize ) ;
                APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_G4 , 0 ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;
                APPENDcc( psttSay , sc_cCOLOR   , ifcRGB_R4 , 0 ) ;

            #else

                APPENDcc( psttSay , sc_ccLINEpEL ,   0      , - scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   0      ,   scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;

                }
                    }
                        case 3 : {                                                                                                      scSize += 2 ; APPENDcc( psttSay , sc_ccLINEpEL ,        0 , - scSize ) ; ; break ; } // DOWN
                        case 2 : {                                                                                                      scSize += 2 ; APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ; ; break ; } // LEFT
                        case 1 : {                                                                                                      scSize += 2 ; APPENDcc( psttSay , sc_ccLINEpEL ,        0 ,   scSize ) ; ; break ; } // UP
                        case 0 : { APPENDcc( psttSay , sc_cCOLOR   , pcColor[ ( offBoxNext ++ ) % ( sizeof pcColor / sizeof pcColor[ 0 ] ) ] , 0 ) ; scSize += 2 ; APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ; ; break ; } // RIGHT
                    {
                    switch( offl % 4 )
                {
                for( countT offl = 0 ; offl < ( TUCK << 1 ) ; offl ++ )
                ZE( countT , yLath ) ;
                ZE( countT , xLath ) ;

                ZE( countT , offBoxNext ) ;
                countT pcColor[] = { ifcRGB_R4 , ifcRGB_G4 , ifcRGB_B4 , ifcRGB_Y4 } ;

            #elif defined( MANYlINEScOLOR )

                APPENDcc( psttSay , sc_ccLINEpEL ,   0      , - scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   0      ,   scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;

                }
                    }
                        case 3 : { scSize += 2 ; APPENDcc( psttSay , sc_ccLINEpEL ,        0 , - scSize ) ; ; break ; } // DOWN
                        case 2 : { scSize += 2 ; APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ; ; break ; } // LEFT
                        case 1 : { scSize += 2 ; APPENDcc( psttSay , sc_ccLINEpEL ,        0 ,   scSize ) ; ; break ; } // UP
                        case 0 : { scSize += 2 ; APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ; ; break ; } // RIGHT
                    {
                    switch( offl % 4 )
                {
                for( countT offl = 0 ; offl < ( TUCK << 1 ) ; offl ++ )
                ZE( countT , yLath ) ;
                ZE( countT , xLath ) ;

            #elif defined( MANYlINES )

                etThread.strFuseF( tinP , psttSay , T("")+S2('J',sc_cALPHABET1)/*+S2('e',sc_cALPHABET1)+S2('s',sc_cALPHABET1)+S2('u',sc_cALPHABET1)+S2('s',sc_cALPHABET1)+S2('!',sc_cALPHABET1)*/ ) ;

            #elif defined( JESUS )

                #endif

                    APPENDcc( psttSay , sc_ccLINEpEL ,   scSize , - scSize ) ;
                    APPENDcc( psttSay , sc_ccLINEpEL ,   0      , - scSize ) ;
                    APPENDcc( psttSay , sc_ccLINEpEL , - scSize , - scSize ) ;

                #if !defined( CHEAT )

                APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ;
                APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   scSize ) ;     //CAN DO 1 GLYPH OF 4 LINES
                APPENDcc( psttSay , sc_ccLINEpEL ,   0      ,   scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;

            #elif defined( MONOCHROME )

                APPENDcc( psttSay , sc_ccLINEpEL ,   0      , - scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL , - scSize ,   0      ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   0      ,   scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;

            #elif defined( BOX )

                APPENDcc( psttSay , sc_ccLINEpEL , - scSize / 2 , - scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL , - scSize / 2 ,   scSize ) ;
                APPENDcc( psttSay , sc_ccLINEpEL ,   scSize ,   0      ) ;

            #elif defined( TRIANGLE )

                APPENDcc( psttSay , sc_ccLINEpEL , - scSize , - scSize ) ;

            #elif defined( SLASH )

                APPENDcc( psttSay , sc_ccLINEpEL , 0 ,scSize ) ;

            #elif defined( LINE )

                APPENDcc( psttSay , sc_ccLINEpEL , 0 , 1 ) ; // WILL GET WO PEL AT THE STARTING POSITION

            #elif defined( POINT )

                APPENDcc( psttSay , sc_ccLINEpEL , 0 , 0 ) ;

            #elif defined( NONDISTINCT )

                APPENDcc( psttSay , sc_ccLINEpEL , - scSize , - scSize ) ;

                APPENDcc( psttSay , sc_ccMOVEpEL ,   0      ,   3 * scSize ) ;

            #if defined( SAMEOsAMEO )

            APPENDcc( psttSay , sc_ccMOVEpEL , - (sCountT)( DELTA >> 1 ) , - (sCountT)( DELTA >> 1 ) ) ;
        {
        while( cDo -- )
        countT cDo = GLYPHS ;
        sCountT scSize = SIZE ;

        APPENDmm( psttSay , sc_mmMOVEtO  , 0.5 , 0.5 ) ;

    #else

        APPENDmm( psttSay , sc_mmLINEtO  , 0.0 , 1.0 ) ;
        APPENDmm( psttSay , sc_mmMOVEtO  , 0.0 , 0.0 ) ;

    #if defined( PAPERDIAGONAL )

    APPENDcc( psttSay , sc_PUSHdETACH , 0 , 0 ) ;
    APPENDcc( psttSay , sc_cPUSHiDgRID , 3 , 0 ) ;

    etThread.strMakeF( tinP , LF , psttSay , 0 , TOCK ) ; ___( psttSay ) ;
    ZE( strokeS* , psttSay ) ;
{
paperC paper( tinP , etThread , TUCK , TUCK ) ;

TODO

}
    return 0 ;

    deviceP.ungrabF( tinP ) ;  //20230327@2018: ADDED W/O ANALYSIS

    }
        }
            break ;
            //tinP.pEther->traceF( tinP , T("deviceCBF / TICK / -") ) ;
//#endif

            }
                //tinP.pEther->etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
                //eyeP.moveF( tinP , vDeltaAt , - PI / ( TUCK << 2 ) , - PI / ( TUCK << 2 ) , - PI / ( TUCK << 2 ) ) ;
                //eyeP.moveF( tinP , vDeltaAt , - PI / ( TUCK >> 2 ) , - PI / ( TUCK >> 2 ) , - PI / ( TUCK >> 2 ) ) ;

//Sleep( 1000 ) ;

                #endif
                    eyeP.moveF( tinP , vDeltaAt /*, 0.0 , 0.0*/ , + PI / ( TUCK >> 0 ) ) ;
                #elif defined( MOVE )
                    eyeP.moveF( tinP , vDeltaAt /*, 0.0 , 0.0*/ , + PI / ( TUCK >> 2 ) ) ;
                #if defined( JERK )

                //eyeP.moveF( tinP , vDeltaAt , 0 , 0 , - PI / ( TUCK >> 0 ) ) ;
                //eyeP.moveF( tinP , vDeltaAt , 0 , - PI / ( TUCK >> 0 ) , 0 ) ;
                //eyeP.moveF( tinP , vDeltaAt , - PI / ( TUCK >> 0 ) , 0 , 0 ) ;

                  eyeP.moveF( tinP , vDeltaAt , 0                  , 0                  , PI / ( TUCK >> 4 ) ) ;
                //eyeP.moveF( tinP , vDeltaAt , 0                  , PI / ( TUCK >> 4 ) , 0                  ) ;
                //eyeP.moveF( tinP , vDeltaAt , PI / ( TUCK >> 4 ) , 0                  , 0                  ) ;

                //tinP.pEther->etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
                vectorOldC vDeltaAt( tinP , *tinP.pEther ) ;
            {
            #endif
                if( !( idIn % ( TUCK << 3 ) ) )
                countT idIn = 1 + incv02AM( idInLath ) ;
                static countT idInLath ;
            #if defined( JERK )

            #endif

                }
                    pPaperNowP = &paperP ;
                    surfP += paperP ;
                    surfP -= paperBWP ;
                {
                else if( !( F(flagsP) & flDEVICEcbf_TOOsLOW ) && pPaperNowP != &paperP )
                }
                    pPaperNowP = &paperBWP ;
                    surfP += paperBWP ;
                    surfP -= paperP ;
                {
                if( F(flagsP) & flDEVICEcbf_TOOsLOW && pPaperNowP != &paperBWP )

            #if defined( CHEAT )
//#if defined( NEVERdEFINED )
            //tinP.pEther->traceF( tinP , T("deviceCBF / TICK / +") ) ;
        {
        case ifcIDeVENTdEVICEc_TICK :
    {
    switch( idEventP )

    deviceP.grabF( tinP , TAG( TAGiDnULL ) ) ;  //20230327@2018: ADDED W/O ANALYSIS

    eyeC&    eyeP       =     *(eyeC*)pcDeviceArgP[ 4 ] ;
    surfC&   surfP      =    *(surfC*)pcDeviceArgP[ 3 ] ;
    paperC&  paperBWP   =   *(paperC*)pcDeviceArgP[ 2 ] ;
    paperC&  paperP     =   *(paperC*)pcDeviceArgP[ 1 ] ;
    paperC*& pPaperNowP = *(paperC**)&pcDeviceArgP[ 0 ] ;
    countT*  pcDeviceArgP =  (countT*)cDeviceArgP ;
    _IO_
{
countT deviceCBF( tinNormalS& tinP , const flagsT flagsP , deviceC& deviceP , const countT cDeviceArgP , const countT idEventP , const countT cEventArgP )

}
    toP.z += sinP.oz ;
    toP.y += sinP.oy ;
    toP.x += sinP.ox ;
    // SHIFTING

    toP.z *= sinP.sz ;
    toP.y *= sinP.sy ;
    toP.x *= sinP.sx ;
    // SCALING

    }
        toP.z = - mx * tinP.brcm04Raw + mz * m1 ;
        toP.x =   mx * m1 + mz * tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , sin( sinP.ah ) )
        measure04T m1 = tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , cos( sinP.ah ) )

        measureT mz = toP.z ;
        measureT mx = toP.x ;
    {
    // HEADING

    }
        toP.z =   my * tinP.brcm04Raw + mz * m1 ;
        toP.y =   my * m1 - mz * tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , sin( - sinP.ae ) )
        measure04T m1 = tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , cos( - sinP.ae ) )

        measureT mz = toP.z ;
        measureT my = toP.y ;
    {
    // ELEVATION

    }
        toP.z = 0.0 ;
        toP.y = - rx * tinP.brcm04Raw + ry * m1 ;
        toP.x =   rx * m1 + ry * tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , sin( sinP.ab ) )
        measure04T m1 = tinP.brcm04Raw ;
        BOSmEASURE04( WHATgbo , cos( sinP.ab ) )
    {
    // BANK

    measureT ry = (sCountT)( fromP.y - sinP.cy ) ;
    measureT rx = (sCountT)( fromP.x - sinP.cx ) ;

    surfS& sinP = *(surfS*)cArgP ;

    TINSL
{
voidT surfaceCBF( mPoint3S& toP , const cPoint2S& fromP , const countT cArgP )

;
}
    }
    {
    ab( 0.0 )
    ae( 0.0 ) ,
    ah( 0.0 ) ,
    sz( 1.0 ) ,
    sy( 1.0 ) ,
    sx( 1.0 ) ,
    oz( (sCountT)TUCK ) ,
    oy( 0 ) ,
    ox( 0 ) ,
    cy( TUCK / 2 ) ,
    cx( TUCK / 2 ) ,
    inline surfS( voidT ) :

    measureT ab ; //"a":"angle" ; "b":"bank"
    measureT ae ; //"a":"angle" ; "e":"elevation"
    measureT ah ; //"a":"angle" ; "h":"heading"

    measureT sz ;
    measureT sy ;
    measureT sx ; //"s":"scale"

    sCountT oz ;
    sCountT oy ;
    sCountT ox ; //"o":"origin"

    countT cy ;
    countT cx ; //"c":"center" 
{
struct surfS

//#define CHEAT

#define JESUS
//#define MANYlINEScOLOR
//#define MANYlINES
//#define BOX
//#define TRIANGLE
//#define NONDISTINCT
//#define PAPERDIAGONAL
//#define SLASH
//#define LINE
//#define POINT
//#define MONOCHROME
//#define SAMEOsAMEO

//#define JERK
//#define MOVE

//#define GLYPHS TUCK
#define GLYPHS ( 1 )
#define SIZE ( TUCK >> 1 )
#define DELTA TUCK

/*1*/WAKEsHOW( "dut.graphics.animation.speed.optimization.and.test" )/*1*/

//20230327@1354: COPIED FROM 72b FOR DEBUGGING AND OPTIMIZATION

/**/
*/
 now to optimize for speed
 the issue was that the eyeC instance was changing state while tmDrawHelperF processing of drawJobS instances were pending
 it's slow, but it works!
20230329@1612: it works!  the new (craftwork interrupted circa 2011 for 12 years) graphics animation is working!
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

