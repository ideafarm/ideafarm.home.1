
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idHit ;
    }
        else pstMatchP->purgeF( tin0P , cPlatesWas ) ;
        }
            }
                *pstMatchP << psttm ; psttm = 0 ;
                strSubstringF( tin0P , psttm , idf , idl , psttBigP ) ; ___( psttm ) ;
                countT idl = idFirstP ? idFirstP - 1 : 0 ;
                countT idf = idHit ;
                ZE( strokeS* , psttm ) ;
                _IO_
            {
            if( F(flagsMatchP) & flSTRmATCH_OUTERmOST )
            _IO_
        {
        if( idHit )
        _IO_
    {
    if( pstMatchP )

    }
        }
            }
                }
                    }
                        idFirstP  = 0 ;_WQ

                        //}
                        //    ((tin123S&)tin0P).pcUtility[ 0 ] ++ ;
                        //    traceF( tin0P , T("[idFirstP ]:    ")+TF2(idFirstP ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //    traceF( tin0P , T("[csttSmall]:    ")+TF2(csttSmall,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //    traceF( tin0P , T("[csttBig  ]:    ")+TF2(csttBig  ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //    traceF( tin0P , T("[idbDo    ]:    ")+TF2(idbDo    ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //    traceF( tin0P , T("[idHit    ]:    ")+TF2(idHit    ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //    ((tin123S&)tin0P).pcUtility[ 0 ] -- ;
                        //{
                        //if( ((tin123S&)tin0P).pcUtility[ 0 ] )
                        _IO_
                    {
                    if( !idHit || idFirstP > csttBig )

                    }
                        ;_WQ
                                : 0                 // SHOULD BE IMPOSSIBLE
                                ? idbDo + 1
                            : idbDo                 // SHOULD ALWAYS BE TRUE
                            ? idHit + csttSmall

                        idFirstP = !bSSS
                        _IO_
                    {
                    if( idHit )

                    if( idHit > idMax ) idHit = 0 ;_WQ
                    }
                        }
                            else if( !strComparePrivateF( psttBigP + CSpREFIX - 1 + idHit , psttSmall ) ) break ;
                            }
                                else                                                                           idbDo = 0 ;
                                if( sssAndF( tin0P , pstMatchP , flagsMatchP , psttSmall , psttBigP , idsDo , idbDo ) ) break ;
                                idbDo = idHit ;_WQ
                                countT idsDo = 1 ;_WQ

                                //}
                                //    ((tin123S&)tin0P).pcUtility[ 0 ] ++ ;
                                //    traceF( tin0P , T("[idHit]     :    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                //    delF( tin0P , psttd ) ;
                                //    traceF( tin0P , T("[psttSmall]:    ")+T(psttd) ) ;
                                //    strDumpStrokesIF( tin0P , psttd , psttSmall ) ; ___( psttd ) ;
                                //    delF( tin0P , psttd ) ;
                                //    traceF( tin0P , T("[psttBigP]  :    ")+T(psttd) ) ;
                                //    strDumpStrokesIF( tin0P , psttd , psttBigP ) ; ___( psttd ) ;
                                //    ZE( strokeS* , psttd ) ;
                                //    traceF( tin0P , T("[psttBigP]  :    ")+T(psttBigP) ) ;
                                //    ((tin123S&)tin0P).pcUtility[ 0 ] -- ;
                                //{
                                //if( ((tin123S&)tin0P).pcUtility[ 0 ] )
                                _IO_
                            {
                            if( bSSS )
                            _IO_
                        {
                        if( bIgnoreQuotes || !bInQuote )
                        if( !bIgnoreQuotes ) bInQuote = strIsInQuoteF( tin0P , sttQuoteP , idHit , psttBigP ) ;_WQ
                        ZE( boolT , bInQuote ) ;_WQ
                        _IO_
                    {
                    for( idHit = idFirstP ; idHit <= idMax ; idHit ++ )
                    ZE( countT , idbDo ) ;_WQ
                    _IO_
                {
                if( !POOP )
                countT idMax = bSSS ? csttBig : csttBig - csttSmall + 1 ;_WQ
                _IO_
            {
            else
            if( !bSSS && idFirstP - 1 + csttSmall > csttBig ) idFirstP = 0 ;

            const countT csttSmall = psttSmall->idAdam ;_WQ
            const countT csttBig   = idLastP && idLastP < psttBigP->idAdam ? idLastP : psttBigP->idAdam ;_WQ
            _IO_
        {
        if( !POOP )
    
        boolT bSSS = psttSmall->idAdam && psttSmall[ CSpREFIX ].idCaste == sc_ccSSS && psttSmall[ CSpREFIX ].idAdam == sa_SSSaND ; // ENFORCE: ALL SSS MUST BE WRAPPED IN AND ; THIS IS JUST TO KEEP CODE SIMPLE
        _IO_
    {
    STRiDrECURSE( strIdF( tin0P , pstMatchP , flSTRmATCH_null , idf , sttQuoteP , psttSmall , psttBigP , idLastP , 1 ) )

    countT cPlatesWas = pstMatchP ? *pstMatchP : 0 ;

    const strokeS* const psttSmall = ( psttSmallP && psttSmallP->idAdam ) ? psttSmallP : psttOneNull ;_WQ
    SETpREFIX( (strokeS*)psttOneNull , 1 , 0 ) ;_WQ
    const strokeS psttOneNull[] = { strokeS() , strokeS() , strokeS() , strokeS() } ;_WQ

    _IO_

    }
        if( POOP ) return 0 ;
        FV(flSTRmATCH,flagsMatchP) ;
        }
            __( F( pstMatchP->flagsF( tin0P ) ) & flSTACKc_FIFO ) ; // IF FIFO THEN WILL CONTAIN INCORRECT CONTENTS
        {
        if( pstMatchP )
        __( psttBigP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        __( psttSmallP && psttSmallP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return 0 ;
        __Z( idP ) ;_WQ
        __( idFirstP == 1 && (countT)sttQuoteP && !bIgnoreQuotes ) ;_WQ
        __Z( idFirstP ) ;_WQ
        __Z( psttBigP ) ;_WQ

        if( POOP ) return 0 ;
    {
    IFbEcAREFUL

    const boolT bIgnoreQuotes = sttQuoteP.idCaste == sc_IGNOREqUOTES ;_WQ
    SCOOP
{
/*1*/countT etherC::strIdF( tin0S& tin0P , stackC* const pstMatchP , const flagsT flagsMatchP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* psttSmallP , const strokeS* psttBigP , const countT idLastP , sCountT idP )/*1*/

/**/
*/
  if not 0 then only the strokes between idFirstP and idLastP inclusive are inspected
  if 0 then the search is over the entire psttBigP string
  can be 0
 idLastP
 psttBigP
    this should not be done unless there is a good reason to do it, because any such specification can be wrapped so that it conforms to the current requirement
   U:: this is fully general, but i can be edited to support SSS specifications that do not begin in the woth position, if that is ever desired
  if this string begins with sc_ccSSS(sa_SSSaND), i look for the idP'th occurance of the specified string pattern (regular expressions)
   behavior is identical to that of a unit length string containing a null stroke
  this can also be null, or a null length string
  this string can include a null stroke
 psttSmallP
  i will ignore quotes if sttQuoteP.idCaste == sc_IGNOREqUOTES
 sttQuoteP
 idFirstP
arguments
 see doc for strIsInQuoteF for notes on how sttQuoteP is set at the beginning and at the end of a quote
 see doc for strIsInQuoteF for notes on which quote marks are recognized
 sttQuoteP is either 0 or contains the last quote mark encountered
initialize sttQuoteP to the quote state at idFirstP
quoted strokes are skipped when searching for the first match
idFirstP will point to the stroke after the one found
  \<A HREF=\"5.a910104.1.1.0.html\"\>a910104:  WAKEsHOW( "example.simplest.func.103005d.etherC.strIdF" )\</A\>
 simplest
examples
\<A HREF=\"5.103005d.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strIdF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

