
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

;
}
    }
        return pvThisElement ;

        }
            }
                }
                    handleP.c3    = ( offMe - 1 ) % cElements ;                                                                     // THE OFFSET OF THE ELEMENT TO INSPECT ON THE NEXT CALL
                    pvThisElement = pbCircle + offMe * cbElement ;
                {
                else
                if( offMe == offEnd ) handleP.c3 = handleP.c2 = handleP.c1 = 0 ;                                                    // THE WALK IS DONE, SO RESET THE HANDLE AND RETURN NULL
                countT offMe  = handleP.c3 > offMax ? offMax : handleP.c3 ;
                countT offEnd = handleP.c2 ;
            {

            const countT offMax  = cElements <= cInSnap ? cElements - 1 : cInSnap - 1 ; 
            const countT cInSnap = cIn ;
        {
        else
        }
            }
                handleP.c3 = ( cIn - 2 ) % cElements ;                                                                              // THE OFFSET OF THE ELEMENT TO INSPECT ON THE NEXT CALL
                handleP.c2 = ( cIn - 1 ) % cElements ;  pvThisElement = pbCircle + handleP.c2 * cbElement ;                         // CURRENTLY THE NEWEST ELEMENT ; I WILL RETURN IT SINCE THIS IS THE WOTH CALL TO ME FOR THIS WALK ; THIS IS THE "OFFeND" VALUE THAT TELLS ME WHEN I HAVE COMPLETED THE WALK
                handleP.c1 = cIn ;                                                                                                  // USED ONLY AS BOOLEAN
            {
            if( cIn )
        {
        if( !handleP.c1 )                            // IF BEGINNING OF NEW WALK
        ZE( voidT* , pvThisElement ) ;


        //   c3: OFFSET OF THE NEXT ELEMENT TO INSPECT, WHICH MIGHT BE EMPTY
        //   c2: OFFSET OF THE NEWEST ELEMENT, WHICH IS NEVER EMPTY AND WHICH IS THE WOTH ELEMENT RETURNED IN THE WALK
        //   c1: cIn AT THE BEGINNING OF THE WALK
        // HANDLE COMPONENTS WHEN cIn IS NOT ZE

        //     WHEN THE CIRCLE IS NOT FULL, THE WALK GOES BACKWARD AROUND THE CIRCLE, SKIPPING SLOTS TO WHICH NO ELEMENT HAS YET BEEN PUSHED, RETURNING PUSHED ELEMENTS UNTIL THE WOTH ELEMENT PUSHED HAS BEEN RETURNED
        //     WHEN cIn >= cElements THE CIRCLE IS FULL AND THE WALK SIMPLY GOES BACKWARD COMPLETELY AROUND THE CIRCLE UNTIL THE WOTH ELEMENT PUSHED HAS BEEN RETURNED
        //   APPROACH
        //     SUPPORT A VOLATILE INSTANCE (cIn INCREASES DURING THE WALK)
        //   WISH
        // HOW I WORK
    {
    inline voidT* operator []( count3S& handleP )

    }
        bGrabToPull -- ;

        }
            thirdC::c_memcpyIF( (byteT*)pP , pbCircle + offbi , cbElement ) ;
            countT offbi      = ( cOutBefore % cElements ) * cbElement ;
            countT cOutBefore = incv02AM( cOut ) ;
        {
        if( !bQuit )

        }
            thirdC::dosSleepRawNoTinIF( 0 ) ;

            if( cBacklog ) break ;
            countT cBacklog = *this ;
        {
        while( !bQuit )

        while( setIfZeAM( bGrabToPull , 1 ) ) thirdC::dosSleepRawNoTinIF( 0 ) ;
    {
    inline voidT operator >>( voidT* pP )

    }
        bGrabToPush -- ;

        }
            thirdC::c_memcpyIF( pbCircle + offbo , (const byteT*)pP , cbElement ) ;
            }
                (*pDeleteCBF)( tin0P , cAt , cArgDelete ) ;
                countT cAt = (countT)( pbCircle + offbo ) ;
                TINSL
            {
            if( pDeleteCBF && cInBefore >= cElements )
            countT offbo     = ( cInBefore % cElements ) * cbElement ;
            countT cInBefore = incv02AM( cIn ) ;
        {
        if( !bQuit )

        }
            thirdC::dosSleepRawNoTinIF( 0 ) ;

            if( cBacklog < cElements ) break ;
            countT cBacklog = *this ;
        {
        while( !bQuit )

        while( setIfZeAM( bGrabToPush , 1 ) ) thirdC::dosSleepRawNoTinIF( 0 ) ;
    {
    inline voidT operator <<( voidT* pP )

    inline operator countT( voidT ) const { return cIn - cOut ; }                               // WILL HANDLE WRAP AOK

    }
        ether.newF( tin0P , LF , pbCircle , cbCircle ) ; ___( pbCircle ) ;
    {
    bGrabToPull( 0 )
    bGrabToPush( 0 ) ,
    cOut( 0 ) ,
    cIn(  0 ) ,
    cArgDelete( pcArgDeleteP ? *pcArgDeleteP : cnu ) ,
    cnu( 0 ) ,
    pDeleteCBF( pDeleteCBFP ) ,
    pbCircle( 0 ) ,
    cbCircle( cbElementP * cElementsP ) ,
    cElements( cElementsP ) ,
    cbElement( cbElementP ) ,
    bQuit( bQuitP ) ,
    ether( etherP ) ,
    inline circleC( tin0S& tin0P , etherC& etherP , const boolT& bQuitP , const countT cbElementP = sizeof( countT ) , const countT cElementsP = TUCK , ifc2FT pDeleteCBFP = 0 , countT* pcArgDeleteP = 0 ) :

    }
        ether.delF( tin0P , pbCircle ) ;
        TINSL
    {
    inline ~circleC( voidT )

    public :

    countT       bGrabToPull ;
    countT       bGrabToPush ;
    countT       cOut        ;
    countT       cIn         ;

    countT&      cArgDelete  ;
    countT       cnu         ;
    ifc2FT       pDeleteCBF  ;
    byteT*       pbCircle    ;
    const countT cbCircle    ;
    const countT cElements   ;
    const countT cbElement   ;
    const boolT& bQuit       ;
    etherC&      ether       ;
{
/*1*/class circleC/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
