
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        }
            if( ifcEXITcODE_EXITpROCESSaOK != thirdC::osHireThenMonitorIF( tinP , ifcIDaDAM_HIREwITHOUTdEBUGGING , T("ifcIDaDAM_HIREwITHOUTdEBUGGING") , tArgsGross ) ) thirdC::third_flagsModeProcess2I_IF() |= flMODEpROCESS2_EXITcODEiMPOTENCE ;
            _IO_
        {
        etThread.traceF( tinP , T("hiring self [tArgsGross]:    ")+tArgsGross ) ;

                                      tArgsGross += tb+tArgKeyNameNow+tb+tFile+tb+tArgsNet ;
        if( maxValue                ) tArgsGross += tb+tArgKeyMaxValue+tb+TF2(maxValue,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
        if( idReport                ) tArgsGross += tb+tArgKeyIdReport+tb+TF2(idReport,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
        if( reportToCell            ) tArgsGross += tb+tArgKeyReportToCell+tb+TF2(reportToCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
        if( tArgsIgnore.csF( tinP ) ) tArgsGross  = tArgKeyIgnore+tb+tArgsIgnore ;
        TN( tArgsGross , "" ) ;
        _IO_
    {
    else
    }
        }
            }
                }
                    etThread.traceF( tinP , T("waited for the \"received\" sign and am now quitting") ) ;
                    sgnReceived.waitF( tinP ) ;
                    sgnReady.giveF(    tinP ) ;
                    etThread.traceF( tinP , T("giving the \"ready\" sign and waiting for the \"received\" sign") ) ;

                    THREADmODE2rESTORE
                    THREADmODE3rESTORE
                    THREADmODE4rESTORE
                    
                    }
                        }
                            }
                                         *pc_foo = 0x44332211 ;
                                countT*   pc_foo = vsp_foo ;
                                countVSP vsp_foo = listC::countIF( tinP , myRecord , c2Text ) ;
                            {
                        
                            }
                                         *pc_idDeathType = idDeathType ;
                                countT*   pc_idDeathType = vsp_idDeathType ;
                                countVSP vsp_idDeathType = listC::countIF( tinP , myRecord , count2S( LNA( 4 ) ) ) ;
                            {
                        
                            }
                                               *pc_value = value ;
                                countT*         pc_value = vsp_value ;
                                countVSP       vsp_value = listC::countIF( tinP , myRecord , count2S( LNA( 3 ) ) ) ;
                            {
                        
                            }
                                              *pc_idPoop = idPoop ;                                                                         //idPoop WILL EITHER INDICATE THE REASON THAT pkzipc.exe COULD NOT BE HIRED OR WILL CONTAIN THE VALUE RETURNED BY pkzipc.exe
                                countT*        pc_idPoop = vsp_idPoop ;
                                countVSP      vsp_idPoop = listC::countIF( tinP , myRecord , count2S( LNA( 2 ) ) ) ;
                            {
                        
                            }
                                           *pc_bHiredAOK = bHiredAOK ;
                                countT*     pc_bHiredAOK = vsp_bHiredAOK ;
                                  countVSP   vsp_bHiredAOK = listC::countIF( tinP , myRecord , count2S( LNA( 1 ) ) ) ;
                                //countVSP   vsp_bHiredAOK = listC::countIF( tinP , myRecord , count2S( LISTnAMEsYS_PROCESSrEPORTfIELD10 ) ) ;
                            {
                        
                            recordC myRecord( tinP , pcNameRecord ) ;
                            countT pcNameRecord[] = { LISTnAMEsYS_ROOT , LISTnAMEsYS_ROOTaPPLICATION , LISTnAMEsYS_GLOBALrECORD , LISTnAMEsYS_PROCESSrEPORT , reportToCell | BM_HIGH , idReport | BM_HIGH , tinP.pag1->idAdam | BM_HIGH , 0 } ;
                        {

                        listC::dictionaryReplaceOsTextIF( tinP , c2Text ) ;
                        count2S c2Text( (countT)"myFieldName" ) ;

                        puseC puseHT( tinP , ifcIDpOOL_HOMEtEMP ) ;

                        _IO_
                    {
                    
                    THREADmODE4oN( flTHREADmODE4_ALLOWwRITEABLEpOINTERgET )
                    THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY       )
                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING   )
                {
                if( reportToCell )

                }
                    //if( bSandbox ) etherC::loafIF( tinP ) ;
                    thirdC::third_flagsModeProcess2I_IF() |= flMODEpROCESS2_EXITcODEiMPOTENCE ;
                    etThread.traceF( tinP , T("!exception: kid process either could not be hired or returned an impermissibly high value [idPoop,value,maxValue]:    ")+TF2(idPoop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(maxValue,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    TN( tb4 , "    " ) ;
                    POOPRqUIET
                {                              //HAVING MY PROCESS EXIT CODE CONTAIN DETAILED INFO WOULD COMPLICATE DEBUGGING CODE THAT INSPECTS THE PROCESS EXIT CODE AND DETECTS WHETHER THE EXIT CODE IS WO OF THE EXPECTED (LEGAL) VALUES FOR AN IPDOS (TM) PROCESS
                if( POOP )                     //PS:PERSONALITY: MY PROCESS EXIT CODE WILL INDICATE IMPOTENCE BUT WILL NOT INDICATE THE DETAILS ; FOR THAT I TRACE OUT value

                if( value > maxValue ) { __( value ) ; }

                etThread.traceF( tinP , T("setting [bHiredAOK]:    ")+TF2(bHiredAOK,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                bHiredAOK = !idPoop ;
                etThread.traceF( tinP , T("called  dosExecPgmF [maxValue,idPoop,reportToCell,idReport,value,file,args]:    ")+TF2(maxValue,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPoop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(reportToCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idReport,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tFile+tb4+tArgsNet ) ;
                idPoop = POOP ;
                ((thirdC&)*tinP.pEtScratch).dosExecPgmF( tinP , countTC() , countTC() , value , idDeathType , tFile , tArgsNet , flPROCESShIRE_null ) ;
                etThread.strokeF( tinP , T("\r\n") ) ;
                etThread.traceF( tinP , T("calling dosExecPgmF [maxValue,idPoop,reportToCell,idReport,value,file,args]:    ")+TF2(maxValue,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idPoop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(reportToCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idReport,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tFile+tb4+tArgsNet ) ;
                ZE( countT , idDeathType ) ;        // FOR MS WINDOWS, THIS WILL ALWAYS BE 0
                ZE( countT , value       ) ;
                ZE( countT , idPoop      ) ;

                SCOOPS
                _IO_
            {
            IFsCRATCH
            boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;
            _IO_
        {
        ZE( boolT , bHiredAOK ) ;

        signC sgnReceived( tinP , TAG( TAGiDnULL ) , tSgnReceived                 ) ;
        signC sgnReady(    tinP , TAG( TAGiDnULL ) , tSgnReady    , flSIGNc_GIVER ) ;          // CT THIS AS EARLY AS POSSIBLE SO RECIPIENT, WHO IS NAPPING UNTIL IT EXISTS, KNOWS THAT I AM ALIVE

        TN( tSgnReady    , "report.is.ready."    ) ; tSgnReady    += tUniquify ;
        TN( tSgnReceived , "report.is.received." ) ; tSgnReceived += tUniquify ;
        TN( tUniquify , ""                       ) ; tUniquify     = TF2(reportToCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tDot+TF2(idReport,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
        TN( tDot      , "."                      ) ;
    {
    if( bNow )
    _IO_
{
if( !POOP )

__Z( tFile.csF( tinP ) ) ;

}
    }
            tArgsNet += ( tArgsNet.csF( tinP ) ? tb : tn ) + T(psttc1) ;
        else if( tFile.csF( tinP ) )
        }
            tFile = T(psttc1) ;
                   bArmedNow = bArmedLater = 0 ;
            bNow = bArmedNow ;
        {
        else if( bArmedNow || bArmedLater )

        else if( bArmedMaxValue                                             ) { bArmedMaxValue     = 0 ; maxValue       = etThread.strDigitsToSCountF( tinP , psttc1 ) ; }
        else if( bArmedIdReport                                             ) { bArmedIdReport     = 0 ; idReport       = etThread.strDigitsToSCountF( tinP , psttc1 ) ; }
        else if( bArmedReportToCell                                         ) { bArmedReportToCell = 0 ; reportToCell   = etThread.strDigitsToSCountF( tinP , psttc1 ) ; }
        else if( bArmedIgnore                                               )                            tArgsIgnore   += ( tArgsIgnore.csF(  tinP ) ? tb : tn ) + T(psttc1) ;

        else if( !etThread.strCompareF( tinP , psttc1 , tArgKeyNameLater    ) ) { bArmedIgnore   = 0 ; bArmedReportToCell  = 0 ; bArmedIdReport = 0 ; bArmedMaxValue = 0 ; bArmedNow = 0 ; bArmedLater = 1 ; }
        else if( !etThread.strCompareF( tinP , psttc1 , tArgKeyNameNow      ) ) { bArmedIgnore   = 0 ; bArmedReportToCell  = 0 ; bArmedIdReport = 0 ; bArmedMaxValue = 0 ; bArmedNow = 1 ; bArmedLater = 0 ; }
        else if( !etThread.strCompareF( tinP , psttc1 , tArgKeyMaxValue     ) ) { bArmedIgnore   = 0 ; bArmedReportToCell  = 0 ; bArmedIdReport = 0 ; bArmedMaxValue = 1 ; bArmedNow = 0 ; bArmedLater = 0 ; }
        else if( !etThread.strCompareF( tinP , psttc1 , tArgKeyIdReport     ) ) { bArmedIgnore   = 0 ; bArmedReportToCell  = 0 ; bArmedIdReport = 1 ; bArmedMaxValue = 0 ; bArmedNow = 0 ; bArmedLater = 0 ; }
        else if( !etThread.strCompareF( tinP , psttc1 , tArgKeyReportToCell ) ) { bArmedIgnore   = 0 ; bArmedReportToCell  = 1 ; bArmedIdReport = 0 ; bArmedMaxValue = 0 ; bArmedNow = 0 ; bArmedLater = 0 ; }
             if( !etThread.strCompareF( tinP , psttc1 , tArgKeyIgnore       ) ) { bArmedIgnore   = 1 ; bArmedReportToCell  = 0 ; bArmedIdReport = 0 ; bArmedMaxValue = 0 ; bArmedNow = 0 ; bArmedLater = 0 ; }
        etThread.traceF( tinP , T("param: ")+T(psttc1) ) ;
        _IO_                                                                                        //P:PERSONALITY: A HEYkEY (E.G. "!maxValue") HAS NO EFFECT IF FOLLOWED IMMEDIATELY BY ANOTHER HEYkEY
    {
    FORsTRINGSiN1( pstt1Param )
    ZE( boolT , bArmedLater        ) ;
    ZE( boolT , bArmedNow          ) ;
    ZE( boolT , bArmedMaxValue     ) ;
    ZE( boolT , bArmedIdReport     ) ;
    ZE( boolT , bArmedReportToCell ) ;
    ZE( boolT , bArmedIgnore       ) ;
    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tinP ) ;
    TN( tArgKeyNameLater , "!hireLater" ) ;
    _IO_
{
TN( tb4                 , "    "          ) ;
TN( tb                  , " "             ) ;
TN( tn                  , ""              ) ;
TN( tArgsNet            , ""              ) ;
TN( tArgsIgnore         , ""              ) ;
TN( tArgKeyNameNow      , "!hireNow"      ) ;
TN( tArgKeyMaxValue     , "!maxValue"     ) ;
TN( tArgKeyIdReport     , "!idReport"     ) ;
TN( tArgKeyReportToCell , "!reportToCell" ) ;
TN( tArgKeyIgnore       , "!ignore"       ) ;
TN( tFile               , ""              ) ;

ZE( boolT  , bNow         ) ;
ZE( countT , idReport     ) ;
ZE( countT , reportToCell ) ;
ZE( countT , maxValue     ) ;

TODO

/*1*/WAKEhIDE( "ifcIDaDAM_HIREwITHOUTdEBUGGING" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
