
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.osSuspendF( tin0P ) ;
etThread.traceF( tin0P , T("ok.  hibernating") ) ;

//etherC::loafIF( tin0P ) ;
//etThread.traceF( tin0P , T("ok.  loafing") ) ;

}
    }
        }
            THREADmODE1rESTORE
            while( cExecutiveHealYear ) thirdC::dosSleepWinkIF( tin0P ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        {

        }
            while( ~hStYearToHeal ) ;
            }
                etThread.osThreadF( TaRG3fLAGScBtLS( tmExecutiveHealYearF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cExecutiveHealYear , (countT)psttYear , (countT)&psttzArchive , (countT)&swsPathToArchivesByArchiveName , (countT)&bAbort ) ;
                inc02AM( cExecutiveHealYear ) ;

                etThread.strMakeF( tin0P , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                ZE( strokeS* , psttYear ) ;

                etThread.traceF( tin0P , T("year to heal:    ")+T(psttzYear) ) ;
                strokeS* psttzYear = (strokeS*)stYearToHeal.upF( tin0P , hStYearToHeal ) ;       //PROCESSES YEARS BEGINNING WITH MOST RECENT  (A:ASSUME: CURRENT YEARS ARE IN MOST NEED OF HEALING SINCE FILES ARE ADDED AND MODIFIED)

                }
                    THREADmODE1rESTORE
                    while( CyEARSiNpARALLEL == cExecutiveHealYear ) thirdC::dosSleepWinkIF( tin0P ) ;
                    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
                {
            {
            do
            handleC hStYearToHeal( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( !bAbort )
        ZE( countT , cExecutiveHealYear ) ;

        }
            }
                }
                    }
                        break ;
                        bAbort = 1 ;
                        etThread.delF( tin0P , psttYear ) ;
                        etThread.traceF( tin0P , T("exception: duplicate year [psttYear]:    ")+T(psttYear) ) ;                        
                    {
                    if( !idSlot ) //SHOULD BE IMPOSSIBLE
                    stYearToHeal.sinkF( tin0P , idSlot , psttYear , flSTACKsINK_UNIQUE ) ;
                    ZE( countT , idSlot ) ;
                    etThread.strMakeF( tin0P , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                    ZE( strokeS* , psttYear ) ;
                {
                if( tally > 1 )
                countT tally = swTallyByYear ;
                psttzYear = (strokeS*)swTallyByYear.leverF( tin0P , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swTallyByYear.cFlavorsF( tin0P ) ;

            while( ~hSwsPathToArchives ) ;
            }
                etThread.delF( tin0P , pstt1PathToYear ) ;
                }
                    //etThread.traceF( tin0P , T("[tYear,tally]:    ")+tYear+tb4+TF2((countT)swTallyByYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    swTallyByYear ++ ;
                    psttzYear = tYear ;

                    }
                        etThread.delF( tin0P , psttYear ) ;
                        tYear = T(psttYear) ;
                        etThread.strWordF( tin0P , psttYear , psttc1 , sttq , sttSlash , - 2 ) ; ___( psttYear ) ;
                        ZE( strokeS* , psttYear ) ;
                    {
                    TN( tYear , "" ) ;
                {
                FORsTRINGSiN1( pstt1PathToYear )
                etThread.strConvertToLowerCaseF( tin0P , pstt1PathToYear ) ;
                etThread.diskFindFileOrDirF( tin0P , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                patternC pat( tin0P , etThread , tYearPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                ZE( strokeS* , pstt1PathToYear ) ;

                //etThread.traceF( tin0P , T("new code [tPathToArchive]:    ")+tPathToArchive ) ;
                TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchive)+tSlash ;
                strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveName.downF( tin0P , hSwsPathToArchives ) ;
            {
            do
            handleC hSwsPathToArchives( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            strokeS sttSlash( '/' ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

            switchC swTallyByYear( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzYear ) ;
            ZE( strokeS* , psttzYear ) ;
        {
        stackC stYearToHeal( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

        // FOR EACH YEAR FOLDER (ALL YEARS FOR THIS ARCHIVE NAME (EXAMPLE: ALL YEAR PATHS FOR EVERY YEAR FOR "wo.ideafarm"), LAUNCH A FILE RECORD COLLECTION THREAD
    {
    if( cArchivesWithThisName > 1 )
    etThread.traceF( tin0P , T("[cArchivesWithThisName,archive]:    ")+TF2(cArchivesWithThisName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzArchive) ) ;
    swsPathToArchivesByArchiveName.ungrabF( tin0P ) ;
    countT cArchivesWithThisName = swsPathToArchivesByArchiveName ;
    psttzArchive = (strokeS*)swsPathToArchivesByArchiveName.leverF( tin0P , idf ) ;
    swsPathToArchivesByArchiveName.grabF( tin0P , TAG( TAGiDnULL ) ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )    // FOR EACH ARCHIVE NAME (EXAMPLE: "wo.ideafarm")
ZE( boolT , bAbort ) ;
swsPathToArchivesByArchiveName.ungrabF( tin0P ) ;
countT cFlavors = swsPathToArchivesByArchiveName.cFlavorsF( tin0P ) ;
swsPathToArchivesByArchiveName.grabF( tin0P , TAG( TAGiDnULL ) ) ;
TN( tYearPattern , "?" "?" "?" "?" "/" ) ;                                                              //20221118@1747: "????/" PROUCES A SPURIOUS COMPILER ERROR INVOLVING TRIGRAPH
//TN( tYearPattern , "1999/" ) ;  //U:: TO FIND A BUG

swsPathToArchivesByArchiveName.lockIfF( tin0P ) ;
}
    }
        etThread.delF( tin0P , pstt1Archives ) ;
        }
            }
                swsPathToArchivesByArchiveName.sinkF( tin0P , countTC() , psttPathArchives ) ;                           // EXAMPLE: "///c/ipdos.arhives/"

                psttzArchive = tArchive ;

                etThread.traceF( tin0P , T("    [tPathArchives,tArchive]:    ")+T(psttPathArchives)+tb4+tArchive ) ;

                }
                    etThread.delF( tin0P , psttShorter ) ;
                    tArchive = T(psttShorter) ;
                    etThread.strSubstringF( tin0P , psttShorter , idf , idl , tArchiveSlash ) ; ___( psttShorter ) ;
                    ZE( strokeS* , psttShorter ) ;
                {
                if( idl )
                countT idl = tArchiveSlash.csF( tin0P ) ? tArchiveSlash.csF( tin0P ) - 1 : 0 ;
                countT idf = 1 ;
                TN( tArchive , "" ) ;                                                                                   // EXAMPLE: "wo.ideafarm"

                }
                    etThread.delF( tin0P , psttArchiveSlash ) ;
                    tArchiveSlash = T(psttArchiveSlash) ;
                    etThread.strBisectF( tin0P , psttPathArchives , psttArchiveSlash , psttc1 , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathArchives ) ; ___( psttArchiveSlash ) ;
                    ZE( strokeS* , psttArchiveSlash ) ;
                {
                TN( tArchiveSlash , "" ) ;                                                                              // EXAMPLE: "wo.ideafarm/"
                ZE( strokeS* , psttPathArchives ) ;                                                                     // EXAMPLE: "///c/ipdos.arhives/"

                etThread.traceF( tin0P , T("processing archive ")+T(psttc1) ) ;                                          // EXAMPLE: "///c/ipdos.arhives/wo.ideafarm/"
            {
            FORsTRINGSiN1( pstt1Archives )
            etThread.diskFindFileOrDirF( tin0P , pstt1Archives , tLikeArchives ) ; ___( pstt1Archives ) ;
        {
        ZE( strokeS* , pstt1Archives ) ;
    {
    TN( tLikeArchives , "///?/ipdos.archives/" ) ;
{
switchStackC swsPathToArchivesByArchiveName( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzArchive , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
ZE( strokeS* , psttzArchive ) ;
// LOAD swsPathToArchivesByArchiveName WITH VALUES LIKE "///c/ipdos.arhives/" SWITCHED ON VALUES LIKE "wo.ideafarm"

TN( tSlash , "/" ) ;
TN( tb4    , "    " ) ;

TODO

DONE( tmExecutiveHealYearF )
}
    dec02AM( cExecutiveHealYearP ) ;
    }
        etThread.traceF( tin0P , T("done for archive ")+T(psttzArchiveP) ) ;

        DEL( pSwsMetaByShort ) ;

        }
            //U::while( cWaiting ) sgnGo.giveF( tin0P ) ;       //cWaiting IS USED TO AVOID A RACE CONDITION: A THREAD THAT HAS INCREMENTED cCutoffUpdates BUT HAS NOT YET CALLED waitF WILL NOT SEE THIS SIGN
            sgnGo.giveF( tin0P ) ;
            thirdC::dosSleepWinkIF( tin0P ) ; // TO AVOID RACE
            //etThread.traceF( tin0P , T("giving sign to unpause workers") ) ;

            pSwsMetaByShort->ungrabF( tin0P ) ;

            //etThread.traceF( tin0P , T("after calling freeAllF [cFlavors]:    ")+TF2(pSwsMetaByShort->cFlavorsF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            pSwsMetaByShort->freeAllF( tin0P ) ;

            }
                }
                    while( ~hSwsOuter ) ;
                    }
                        DELzOMBIE( pfmOuter ) ;

                        }
                            DELzOMBIE( pd ) ;
                            imageCompareS* pd = picOuter + offd ;
                        {
                        for( countT offd = 0 ; offd < cResultStructsNeeded ; offd ++ )

                        fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + cResultStructsNeeded ) ;
                        imageCompareS* picOuter  = (imageCompareS*)&pSwsMetaByShort->downF( tin0P , hSwsOuter ) ;
                    {
                    do
                    handleC hSwsOuter( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( cFiles )
                countT cFiles = *pSwsMetaByShort ;
                postzShort = (osTextT*)pSwsMetaByShort->leverF( tin0P , idf ) ;
            {
            for( countT idf = 1 ; idf <= cShortFileNames ; idf ++ )
            
            //etThread.traceF( tin0P , T("deleting metadata") ) ;

            }
                while( !ether && bCompareFail ) ;
                }
                    }
                        }
                            break ;
                            bAbortP = 1 ;
                            etThread.traceF( tin0P , T("exception: compare failed 8 times [tShort]:    ")+tShort ) ;
                        {
                        if( ++ cCompareFail == 8 )
                    {
                    if( bCompareFail )

                    etThread.traceF( tin0P , T("processed  [tShort,bCompareFail]:    ")+tShort+tb4+TF2(bCompareFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // ****                                                                                                                                  *******************************************************************
                    // ****  END:    COMPARE ALL COPIES OF THIS SHORT FILE NAME.  THIS IS RETRIED UNTIL ALL COMPARISONS COMPLETE WITHOUT AN EXCEPTION EVENT  *******************************************************************
                    // ****                                                                                                                                  *******************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************

                    }
                        // *********************************************************************************************************************************************************************************************************
                        // ****                *************************************************************************************************************************************************************************************
                        // ****  END:    HEAL  *************************************************************************************************************************************************************************************
                        // ****                *************************************************************************************************************************************************************************************
                        // *********************************************************************************************************************************************************************************************************

                        }
                            }
                                }
                                    etThread.osThreadF( TaRG3fLAGScBtLS( tmCopyFileF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)psttTo , (countT)psttFrom , (countT)&bAbortP ) ; psttTo = psttFrom = 0 ;
                                    //etThread.traceF( tin0P , T("new      [psttTo,psttFrom]:    ")+TF2((countT)psttTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)psttFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    //etThread.traceF( tin0P , T("copying [idFrom,new,old,idFrom]:    ")+TF2(idFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttTo)+tb4+T(psttFrom) ) ;

                                    etThread.strMakeF( tin0P , LF , psttFrom , (strokeS*)stFrom[ idFrom ] ) ; ___( psttFrom ) ;
                                    ZE( strokeS* , psttFrom ) ;

                                    countT idFrom = 1 + ( cDone ++ % cFrom ) ;

                                    stTo >> psttTo ;
                                    ZE( strokeS* , psttTo ) ;
                                {
                                while( stTo )
                                ZE( countT , cDone ) ;
                                countT cFrom = stFrom ;

                                while( ~hStPathToYear ) ;
                                }
                                    }
                                        if( !idSlot ) etThread.delF( tin0P , psttLong ) ;
                                        stTo.sinkF( tin0P , idSlot , psttLong , flSTACKsINK_UNIQUE ) ;
                                        ZE( countT , idSlot ) ;
                                        //etThread.traceF( tin0P , T("sinking to stTo 2 [long]:    ")+T(psttLong) ) ;
                                    {
                                    else
                                    if( stFrom( psttLong ) ) etThread.delF( tin0P , psttLong ) ;

                                    etThread.strMakeF( tin0P , LF , psttLong , T(psttPathToYear)+tShort ) ; ___( psttLong ) ;
                                    ZE( strokeS* , psttLong ) ;

                                    strokeS* psttPathToYear = (strokeS*)stPathToYear.downF( tin0P , hStPathToYear ) ;
                                {
                                do
                                handleC hStPathToYear( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                while( ~hStUnique ) ;
                                }
                                    }
                                        while( ~hSwsInner ) ;
                                        }
                                            }
                                                if( !idSlot ) etThread.delF( tin0P , psttLong ) ;
                                                }
                                                    stTo.sinkF( tin0P , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                    //etThread.traceF( tin0P , T("sunk into stTo [cPlatesBefore,long]:    ")+TF2(stTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                {
                                                else
                                                }
                                                    stFrom.sinkF( tin0P , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                    //etThread.traceF( tin0P , T("sunk into stFrom [cPlatesBefore,long]:    ")+TF2(stFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                {
                                                if( bYoungestNotAlone && bWinner )
                                                ZE( countT , idSlot ) ;

                                                etThread.strMakeF( tin0P , LF , psttLong , T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ) ; ___( psttLong ) ;
                                                ZE( strokeS* , psttLong ) ;
                                            {
                                            if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) )

                                            }
                                                }
                                                    break ;
                                                    bMatchImage = 0 ;
                                                {
                                                if( picUnique[ offc ] - picInner[ offc ] )
                                            {
                                            for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ )
                                            boolT bMatchImage = 1 ;

                                            //picInner->traceF( tin0P , T("inner :    ") ) ;
                                            fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                            imageCompareS* picInner  = (imageCompareS*)&pSwsMetaByShort->downF( tin0P , hSwsInner ) ;
                                        {
                                        do
                                        handleC hSwsInner( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {

                                    //pfmUnique->traceF( tin0P , stPathToYear , T(bYoungestNotAlone?"reporting tallies (youngestNotAlone):    ":"reporting tallies            (other):    ") ) ;

                                    //etThread.traceF( tin0P , T("[bYoungestNotAlone,bWinner,cVotes,cVotesMax]:    ")+TF2(bYoungestNotAlone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bWinner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pfmUnique->cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cVotesMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    boolT bWinner           = pfmUnique->cVotes         == cVotesMaxYoungestNotAlone      ;
                                    boolT bYoungestNotAlone = pfmUnique->timeModRounded == timeModRoundedYoungestNotAlone ;

                                    //for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ ) picUnique[ offc ].traceF( tin0P , T("reporting tallies:    ") ) ;

                                    //picUnique->traceF( tin0P , T("unique:    ") ) ;
                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tin0P , hStUnique ) ;
                                {
                                do
                                handleC hStUnique( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                stackC stTo(     tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                                stackC stFrom(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                            {
                            else
                            }
                                while( !bAbortP && ~hSwsInner ) ;
                                }
                                    etThread.osThreadF( TaRG3fLAGScBtLS( tmMoveFileToUniqueF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)psttLongInRejects , (countT)psttLong , (countT)&bAbortP ) ; psttLongInRejects = psttLong = 0 ;

                                    etThread.strReplaceF( tin0P , psttLongInRejects , psttLong , tPatArchives , tPatRejects ) ; ___( psttLongInRejects ) ;
                                    ZE( strokeS* , psttLongInRejects ) ;

                                    etThread.strMakeF( tin0P , LF , psttLong , T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ) ; ___( psttLong ) ;
                                    ZE( strokeS* , psttLong ) ;

                                    fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                    imageCompareS* picInner  = (imageCompareS*)&pSwsMetaByShort->downF( tin0P , hSwsInner ) ;
                                {
                                do
                                handleC hSwsInner( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                etThread.traceF( tin0P , T("no, or too many (more than 1), winners (authoritative copies) so i will reject all copies [file]")+tShort ) ;
                            {
                            if( !cWinners || cWinners > 1 )

                            }
                                while( ~hSt ) ;
                                }
                                    cWinners ++ ;
                                    )
                                        pfmUnique->cVotes == cVotesMaxYoungestNotAlone
                                        &&
                                        timeModRoundedYoungestNotAlone == pfmUnique->timeModRounded
                                    (
                                    if

                                    //picUnique->traceF( tin0P , T("unique:    ") ) ;
                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tin0P , hSt ) ;
                                {
                                do
                                handleC hSt( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( cVotesMaxYoungestNotAlone )        // IF ALL ARE ALONE THEN THERE WILL BE NO WINNER
                            ZE( countT , cWinners ) ;

                            // RULE; TO WIN, A SLOT MUST HAVE A "YOUNGEST NOT ALONE" AGE AND BE "NOT ALONE" AND HAVE THE MAXIMUM VOTES FOR SLOTS YOUNGEST AND NOT ALONE
                            //P:PERSONALITY: RULES FOR "WINNING": A stRecUnique SLOT "WINNING" MEANS THAT THE SLOT IS DEEMED TO BE AN AUTHORITATIVE IMAGE FOR THE FILE

                            }
                                while( ~hSt ) ;
                                }
                                    }
                                        if( pfmUnique->cVotes > 1 && cVotesMaxYoungestNotAlone < pfmUnique->cVotes ) cVotesMaxYoungestNotAlone = pfmUnique->cVotes ;
                                    {
                                    if( timeModRoundedYoungestNotAlone == pfmUnique->timeModRounded )

                                    }
                                        if(                          cVotesMaxYoungest         < pfmUnique->cVotes ) cVotesMaxYoungest         = pfmUnique->cVotes ;
                                    {
                                    if( timeModRoundedYoungest == pfmUnique->timeModRounded )

                                    //picUnique->traceF( tin0P , T("unique:    ") ) ;
                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tin0P , hSt ) ;
                                {
                                do
                                handleC hSt( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( timeModRoundedYoungestNotAlone )        // IF ALL ARE ALONE THEN THERE WILL BE NO WINNER
                            ZE( countT , cVotesMaxYoungestNotAlone ) ;
                            ZE( countT , cVotesMaxYoungest ) ;

                            }
                                while( ~hSt ) ;
                                }
                                    if( pfmUnique->cVotes > 1 && timeModRoundedYoungestNotAlone < pfmUnique->timeModRounded ) timeModRoundedYoungestNotAlone = pfmUnique->timeModRounded ;

                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tin0P , hSt ) ;
                                {
                                do
                                handleC hSt( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            ZE( countT , timeModRoundedYoungestNotAlone ) ;
                            // SET timeModRoundedYoungestNotAlone

                            }
                                while( ~hSt ) ;
                                }
                                    while( ~hSwsOuter ) ;
                                    }
                                        if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) ) pfmUnique->cVotes ++ ;

                                        }
                                            }
                                                break ;
                                                bMatchImage = 0 ;
                                            {
                                            if( picUnique[ offc ] - picInner[ offc ] )
                                        {
                                        for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ )
                                        boolT bMatchImage = 1 ;

                                        //}
                                        //    pfmInner->traceF( tin0P , stPathToYear , T("inner : ") ) ;
                                        //    picInner->traceF( tin0P , T("inner :    ") ) ;
                                        //{
                                        //if( bChatter )
                                        fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                        imageCompareS* picInner  = (imageCompareS*)&pSwsMetaByShort->downF( tin0P , hSwsOuter ) ;
                                    {
                                    do
                                    handleC hSwsOuter( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                    if( timeModRoundedYoungest < pfmUnique->timeModRounded ) timeModRoundedYoungest = pfmUnique->timeModRounded ;

                                    //}
                                    //    pfmUnique->traceF( tin0P , stPathToYear , T("unique: ") ) ;
                                    //    picUnique->traceF( tin0P , T("unique:    ") ) ;
                                    //{
                                    //if( bChatter )
                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tin0P , hSt ) ;
                                {
                                do
                                handleC hSt( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            ZE( countT , timeModRoundedYoungest ) ;
                            // TALLY cVotes AND SET timeModRoundedYoungest

                            }
                                bChatter = 1 ;
                                etThread.traceF( tin0P , T("lengths or times or images differ [tShort]:    ")+tShort ) ;
                            {
                            if( stRecUnique > 1 )
                            ZE( boolT , bChatter ) ;
                        {
                        else                            // EVEN IF THERE IS ONLY WO PLATE, THERE IS STILL WORK TO DO BECAUSE THE FILE MIGHT NEED TO BE COPIED TO DESTINATIONS THAT DON'T HAVE IT
                        }
                            break ;
                            bAbortP = 1 ;
                            etThread.traceF( tin0P , T("exception: stRecUnique is empty") ) ;
                        {
                        if( !stRecUnique ) //SHOULD  BE IMPOSSIBLE

                        while( ~hSwsOuter ) ;
                        do stRecUnique.sinkF( tin0P , countTC() , (byteT*)&pSwsMetaByShort->downF( tin0P , hSwsOuter ) , flSTACKsINK_UNIQUE , subtractFileMetaF ) ;
                        stackC stRecUnique( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , stPathToYear * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ;
                        handleC hSwsOuter( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                        // *********************************************************************************************************************************************************************************************************
                        // ****                *************************************************************************************************************************************************************************************
                        // ****  BEGIN:  HEAL  *************************************************************************************************************************************************************************************
                        // ****                *************************************************************************************************************************************************************************************
                        // *********************************************************************************************************************************************************************************************************
                    {
                    if( !bCompareFail && !ether && cCopies > 1 )
                    //etThread.traceF( tin0P , T("[cFound,file]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postzShort) ) ;

                    // PHASE 4: COPY TO ALL ARCHIVE CONTAINERS THAT DO NOT HAVE A COPY OF THIS FILE NAME
                    // PHASE 3: OVERWRITE ALL COPIES THAT DO NOT MATCH THIS UNIQUE META
                    // PHASE 2: IS THIS UNIQUE META VERIFIED (cVotes > 1)?
                    // PHASE 1: IDENTIFY THE UNIQUE META WITH THE LATEST FILE DATE
                    // HEALING ACTION HAS PHASES
                    // COMPARE AND FILE META FOR THIS FILE ARE SET AND READY FOR ANALYSIS AND HEALING ACTION
                    // THESE COMMENTS ARE OBSOLETED BY ACTUAL CODE WHICH CONTRADICTS THEM

                    while( !ether && ~hSwsOuter ) ;
                    }
                        if( bCompareFail ) break ;

                        // *********************************************************************************************************************************************************************************************************
                        // ****                                      ***************************************************************************************************************************************************************
                        // ****  END:    FOR EACH COPY OF THIS FILE  ***************************************************************************************************************************************************************
                        // ****                                      ***************************************************************************************************************************************************************
                        // *********************************************************************************************************************************************************************************************************

                        etThread.delF( tin0P ,            pcBitsShiftLeftHeInMine ) ;
                        etThread.delF( tin0P ,            pcBitsShiftLeftMeInHis  ) ;
                        etThread.delF( tin0P , *(byteT**)&ppIdResultHeInMine      ) ;
                        etThread.delF( tin0P , *(byteT**)&ppIdResultMeInHis       ) ;
                        etThread.delF( tin0P ,            pcbwInner               ) ;
                        etThread.delF( tin0P , *(byteT**)&ppbwInner               ) ;

                        }
                            etThread.delF( tin0P , *(byteT**)&pfwsInner ) ;

                            etThread.delF( tin0P , pEqual ) ;
                            }
                                }
                                    //etThread.traceF( tin0P , T(pEqual[offo]?"        set other and myself to BITSrESULT_EQUAL because images match [offo]:    ":"        set other and myself to BITSrESULT_NOTeQUAL because images differ [offo]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    }
                                        //etThread.traceF( tin0P , T("after  [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                        *ppIdResultMeInHis[  offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftMeInHis[  offo ] ;
                                        *ppIdResultHeInMine[ offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftHeInMine[ offo ] ;
                                        //etThread.traceF( tin0P , T("before [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                    {
                                    else
                                    }
                                        *ppIdResultMeInHis[  offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftMeInHis[  offo ] ;
                                        *ppIdResultHeInMine[ offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftHeInMine[ offo ] ;
                                    {
                                    if( pEqual[ offo ] )
                                {
                                for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ )
                            {
                            if( !bCompareFail )

                            THREADmODE1rESTORE
                            }
                                }
                                    bAbortP = 1 ;
                                    etThread.traceF( tin0P , T("exception [cbUsed,cbDone]:    ")+TT(pcbUsed[0],pcbUsed[1])+tb4+TT(pcbDone[0],pcbDone[1])+tb4+tLongOuter ) ;
                                    countT* pcbDone = (countT*)&cbDone ;
                                    countT* pcbUsed = (countT*)&pfmOuter->cbUsed ;
                                {
                                if( !bCompareFail && !ether && cbDone != pfmOuter->cbUsed ) //SHOULD BE IMPOSSIBLE

                                }
                                    cbDone += cbwOuter ;

                                    if( bCompareFail ) break ;

                                    }
                                        }
                                            pcbwInner[ offi ] = 0 ;  // TELLS  TO GET ANOTHER WINDOW
                                            ppbwInner[ offi ] = 0 ;

                                            }
                                                }
                                                    thirdC::dosSleepWinkIF( tin0P ) ;
                                                    etThread.traceF( tin0P , T("exception while trying to access memory for a mapped file.  will retry [idWindow,idTry]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                else
                                                }
                                                    break;
                                                    }
                                                        //etThread.traceF( tin0P , T("images match between unique and inner [idWindow,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    {
                                                    else
                                                    }
                                                        //etThread.delF( tin0P , psttGen ) ;
                                                        //etThread.traceF( tin0P , T("wrote inner [gen]:    ")+T(psttGen) ) ;
                                                        //etThread.boxPutGenerationF( tin0P , psttGen , tLikeInner+TF3(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) , TUCK , ppbwInner[ offi ] , cbwOuter ) ; ___( psttGen ) ;

                                                        //etThread.delF( tin0P , psttGen ) ;
                                                        //etThread.traceF( tin0P , T("wrote outer [gen]:    ")+T(psttGen) ) ;
                                                        //etThread.boxPutGenerationF( tin0P , psttGen , tLikeOuter , TUCK , pbwOuter , cbwOuter ) ; ___( psttGen ) ;
                                                        //ZE( strokeS* , psttGen ) ;

                                                        pEqual[ offi ] = 0 ;
                                                        etThread.traceF( tin0P , T("difference detected between unique and inner [idWindow,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    {
                                                    if( etThread.memCompareF( tin0P , pbwOuter , ppbwInner[ offi ] , cbwOuter ) )
                                                    //etThread.traceF( tin0P , T("attempting to compare images [idWindow,idTry,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( !_restart )

                                                idTry ++ ;
                                                _restart.flags |= flRESTARTc_QUIET ;
                                                RESTART
                                            {
                                            while( !ether )
                                            ZE( countT , idTry ) ;
                                        {
                                        else
                                        }
                                            break ;
                                            bDone = 1 ;
                                            //etThread.traceF( tin0P , T("done inspecting images [idWindow]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        {
                                        if( !pbwOuter || !cbwOuter )

                                        }
                                            break ;  // REDO THIS SHORT NAME FROM THE BEGINNING
                                            bCompareFail = 1 ;
                                            etThread.traceF( tin0P , T("byte by byte comparison failed [tLongOuter]:    ")+tLongOuter ) ;
                                        {
                                        )
                                              cbwOuter !=   pcbwInner[ offi ]
                                            ||
                                            !!cbwOuter != !!pcbwInner[ offi ]
                                            ||
                                            !!pbwOuter != !!ppbwInner[ offi ]
                                        (
                                        if

                                        //etThread.traceF( tin0P , T("fed this [(countT)ppbwInner[offi],ppbwInner[offi]]:    ")+TF3((countT)ppbwInner[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+T(ppbwInner[offi]) ) ;

                                        }
                                            }
                                                break ;  // REDO THIS SHORT NAME FROM THE BEGINNING
                                                bCompareFail = 1 ;
                                                etThread.traceF( tin0P , T("exception:  pfwsInner[ offi ].getF [tLongOuter]:    ")+tLongOuter ) ;
                                                POOPR
                                            {
                                            if( POOP )
                                            RETRY( 8 , ( ppbwInner[ offi ] = 0 , pcbwInner[ offi ] = 0 , pfwsInner[ offi ].getF( tin0P , ppbwInner[ offi ] , pcbwInner[ offi ] ) ) ) ;
                                            SCOOPS
                                        {
                                        IFsCRATCH
                                    {
                                    for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )

                                    }
                                        }
                                            break ;  // REDO THIS SHORT NAME FROM THE BEGINNING
                                            bCompareFail = 1 ;
                                            etThread.traceF( tin0P , T("exception:  fwsOuter.getF [tLongOuter]:    ")+tLongOuter ) ;
                                            POOPR
                                        {
                                        if( POOP )
                                        RETRY( 8 , ( pbwOuter = 0 , cbwOuter = 0 , fwsOuter.getF( tin0P , pbwOuter , cbwOuter ) ) )
                                        SCOOPS
                                    {
                                    IFsCRATCH
                                    ZE( countT , cbwOuter ) ;
                                    ZE( byteT* , pbwOuter ) ;

                                    TN( tLikeInner , "///ideafarm/tmp/debug.inner." ) ; tLikeInner += TF3(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot ;
                                    TN( tLikeOuter , "///ideafarm/tmp/debug.outer." ) ; tLikeOuter += TF3(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;

                                    idWindow ++ ;
                                {
                                while( !ether && !bDone )
                                ZE( countT , idWindow ) ;
                                ZE( boolT , bDone ) ;
                                ZE( count04T , cbDone ) ;

                                //etThread.traceF( tin0P , T("inspecting images [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                                fileWindowsC fwsOuter( tin0P , etThread , tLongOuter ) ;
                            {

                            for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ ) pEqual[ offo ] = 1 ;
                            etThread.newF( tin0P , LF , pEqual , cInnerImagesToInspect ) ; ___( pEqual ) ;
                            ZE( boolT* , pEqual ) ;
                            TN( tDot , "." ) ;

                            }
                                }
                                    etThread.delF( tin0P , psttLongInner ) ;

                                    new( 0 , tin0P , (byteT*)( pfwsInner + offi ) , sizeof( fileWindowsC ) ) fileWindowsC( tin0P , etThread , psttLongInner ) ;

                                    stLongInner >> psttLongInner ;
                                    ZE( strokeS* , psttLongInner ) ;
                                {
                                for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )
                            {
                            if( pfwsInner )
                            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                            etThread.newF( tin0P , LF , *(byteT**)&pfwsInner , cInnerImagesToInspect * sizeof( fileWindowsC ) ) ; ___( pfwsInner ) ;
                            ZE( fileWindowsC* , pfwsInner ) ;

                            }
                                break ;
                                bAbortP = 1 ;                                
                                etThread.traceF( tin0P , T("exception [cInnerImagesToInspect,stLongInner]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+TF2(stLongInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            if( stLongInner != cInnerImagesToInspect ) //SHOULD BE IMPOSSIBLE
                        {
                        if( !ether && !bAbortP && cInnerImagesToInspect )

                        }
                            }
                                while( !ether && !bAbortP && ~hSwsInner ) ;
                                }
                                    }
                                        }
                                            break ;

                                            }
                                                }
                                                    bAbortP = 1 ;                                                    
                                                    etThread.traceF( tin0P , T("exception: iSlotLongInnr is null") ) ;
                                                    etThread.delF( tin0P , psttLongInner ) ;
                                                {
                                                if( !idSlotLongInner ) //SHOULD BE IMPOSSIBLE
                                                stLongInner.sinkF( tin0P , idSlotLongInner , psttLongInner , flSTACKsINK_UNIQUE ) ;
                                                ZE( countT , idSlotLongInner ) ;

                                                etThread.strMakeF( tin0P , LF , psttLongInner , tLongInner ) ; ___( psttLongInner ) ;
                                                ZE( strokeS* , psttLongInner ) ;

                                                offResult ++ ;

                                                pcBitsShiftLeftHeInMine[ offResult ] = cBitsShiftLeftHeInMine ;
                                                pcBitsShiftLeftMeInHis[  offResult ] = cBitsShiftLeftMeInHis  ;
                                                ppIdResultHeInMine[      offResult ] = &bitsResultHeInMine    ;
                                                ppIdResultMeInHis[       offResult ] = &bitsResultMeInHis     ;
                                            {
                                            if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                        {
                                        case 3 :
                                        }
                                            break ;

                                            }
                                                cInnerImagesToInspect ++ ;
                                                //etThread.traceF( tin0P , T("incrementing") ) ;
                                            {
                                            if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )

                                            //etThread.traceF( tin0P , T("        maybe incrementing cInnerImagesToInspect [bitsResultHeInMine,maskHeInMine,masked,cBitsShiftLeftHeInMine,inner]:    ")+TF2(bitsResultHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(maskHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((bitsResultHeInMine&maskHeInMine),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                        {
                                        case 2 :    // COUNT THE NUMBER OF INNER FILES FOR WHICH I MUST INSPECT THE IMAGE (I SET cInnerImagesToInspect HERE)
                                        }
                                            break ;

                                            }
                                                }
                                                    bitsResultHeInMine |= BITSrESULT_NOTeQUAL << cBitsShiftLeftHeInMine ;
                                                    bitsResultMeInHis  |= BITSrESULT_NOTeQUAL << cBitsShiftLeftMeInHis  ;
                                                    etThread.traceF( tin0P , T("        set other and myself to BITSrESULT_NOTeQUAL because cbUsed differs") ) ;
                                                {
                                                if( pfmOuter->cbUsed != pfmInner->cbUsed )
                                            {
                                            else if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                            }
                                                //etThread.traceF( tin0P , T("        setted  myself to BITSrESULT_EQUAL [bitsResultMeInHis]:    ")+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                bitsResultMeInHis |= BITSrESULT_EQUAL << cBitsShiftLeftMeInHis ;
                                                //etThread.traceF( tin0P , T("        setting myself to BITSrESULT_EQUAL [&bitsResultMeInHis,bitsResultMeInHis,&cBitsShiftLeftMeInHis,cBitsShiftLeftMeInHis]:    ")+TF2(&bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(&cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            if( pfmInner == pfmOuter )
                                        {
                                        case 1 :    // SET bitsResult WITHOUT COMPARING FILE IMAGES
                                    {
                                    switch( idPass )

                                    etThread.strMakeF( tin0P , LF , psttLongInner , tLongInner ) ; ___( psttLongInner ) ;
                                    ZE( strokeS* , psttLongInner ) ;

                                    //etThread.traceF( tin0P , T("    [idPass,tLongInner]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                    TN( tLongInner , "" ) ; tLongInner = T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ;

                                    countT maskHeInMine = BITSrESULT_ALLbITS << cBitsShiftLeftHeInMine ;
                                    countT maskMeInHis  = BITSrESULT_ALLbITS << cBitsShiftLeftMeInHis  ;

                                    countT cBitsShiftLeftHeInMine =           ( ( pfmInner->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;
                                    countT cBitsShiftLeftMeInHis  =           ( ( pfmOuter->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;

                                    countT& bitsResultHeInMine    = picOuter[ ( pfmInner->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;
                                    countT& bitsResultMeInHis     = picInner[ ( pfmOuter->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;

                                    //picInner->traceF( tin0P , T("inner :    ") ) ;
                                    //pfmInner->traceF( tin0P , stPathToYear , T("inner: ") ) ;
                                    fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;

                                    //etThread.traceF( tin0P , T("    [picInner]:    ")+TF2((countT)picInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    imageCompareS* picInner = (imageCompareS*)&pSwsMetaByShort->downF( tin0P , hSwsInner ) ;
                                {
                                do
                                handleC hSwsInner( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( idPass != 3 || cInnerImagesToInspect )

                            }
                                etThread.memSetF( tin0P , (byteT*)pcBitsShiftLeftHeInMine , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tin0P , (byteT*)pcBitsShiftLeftMeInHis  , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tin0P , (byteT*)ppIdResultHeInMine      , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tin0P , (byteT*)ppIdResultMeInHis       , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tin0P , (byteT*)pcbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tin0P , (byteT*)ppbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;

                                etThread.newF( tin0P , LF ,             pcBitsShiftLeftHeInMine , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftHeInMine ) ;
                                etThread.newF( tin0P , LF ,             pcBitsShiftLeftMeInHis  , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftMeInHis  ) ;
                                etThread.newF( tin0P , LF , *(countT**)&ppIdResultHeInMine      , cInnerImagesToInspect ) ; ___( ppIdResultHeInMine      ) ;
                                etThread.newF( tin0P , LF , *(countT**)&ppIdResultMeInHis       , cInnerImagesToInspect ) ; ___( ppIdResultMeInHis       ) ;
                                etThread.newF( tin0P , LF ,             pcbwInner               , cInnerImagesToInspect ) ; ___( pcbwInner               ) ;
                                etThread.newF( tin0P , LF , *(countT**)&ppbwInner               , cInnerImagesToInspect ) ; ___( ppbwInner               ) ;
                            {
                            if( idPass == 3 && cInnerImagesToInspect )
                        {
                        for( countT idPass = 1 ; !ether && idPass <= 3 ; idPass ++ )
                        ZE( countT   , offResult               ) ;
                        ZE( countT*  , pcBitsShiftLeftHeInMine ) ;
                        ZE( countT*  , pcBitsShiftLeftMeInHis  ) ;
                        ZE( countT** , ppIdResultHeInMine      ) ;
                        ZE( countT** , ppIdResultMeInHis       ) ;
                        ZE( countT*  , pcbwInner               ) ;
                        ZE( byteT**  , ppbwInner               ) ;
                        ZE( countT   , cInnerImagesToInspect   ) ;
                        stackC stLongInner( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

                        //pfmOuter->traceF( tin0P , stPathToYear , T("outer: ") ) ;
                        //etThread.traceF( tin0P , T("[tLongOuter]:    ")+tLongOuter ) ;
                        TN( tLongOuter , "" ) ; tLongOuter = T((strokeS*)stPathToYear[pfmOuter->idSlotPathToYear])+tShort ;

                        //picOuter->traceF( tin0P , T("outer :    ") ) ;
                        fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + cResultStructsNeeded ) ;
                        imageCompareS* picOuter  = (imageCompareS*)&pSwsMetaByShort->downF( tin0P , hSwsOuter ) ;

                        // *********************************************************************************************************************************************************************************************************
                        // ****                                      ***************************************************************************************************************************************************************
                        // ****  BEGIN:  FOR EACH COPY OF THIS FILE  ***************************************************************************************************************************************************************
                        // ****                                      ***************************************************************************************************************************************************************
                        // *********************************************************************************************************************************************************************************************************
                    {
                    do
                    handleC hSwsOuter( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    // SET ALL COMPARE META ELEMENTS FOR EACH FILE'S IMAGE COMPARE META ARRAY

                    etThread.traceF( tin0P , T("processing [tShort             ]:    ")+tShort ) ;

                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // ****                                                                                                                                  *******************************************************************
                    // ****  BEGIN:  COMPARE ALL COPIES OF THIS SHORT FILE NAME.  THIS IS RETRIED UNTIL ALL COMPARISONS COMPLETE WITHOUT AN EXCEPTION EVENT  *******************************************************************
                    // ****                                                                                                                                  *******************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                {
                do
                ZE( countT , cCompareFail ) ;
                ZE( boolT  , bCompareFail ) ;

                //if( idf <= 4 ) // FOR TESTING.  IN PRODUCTION, COMMENT OUT THIS LINE

                }
                    etThread.traceF( tin0P , T("!tShort.csF() [cShortFileNames,idf]:    ")+TF2(cShortFileNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( !tShort.csF( tin0P ) )

                TN( tShort , postzShort ) ;

                countT cCopies = *pSwsMetaByShort ;
                postzShort = (osTextT*)pSwsMetaByShort->leverF( tin0P , idf ) ;

                }
                    etThread.traceF( tin0P , T("[cFiles,perTuck,idf]:    ")+TF2(cShortFileNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF3(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2)+tb+tPerTuck+tb4+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT perTuck = ( idf << 8 ) / cShortFileNames ;
                {
                if( !( idf % ( TUCK >> 4 ) ) )
            {
            for( countT idf = 1 ; !ether && idf <= cShortFileNames ; idf ++ )
            etThread.traceF( tin0P , T("inspecting metadata and comparing images for each copy of each file") ) ;

            const countT cShortFileNames = pSwsMetaByShort->cFlavorsF( tin0P ) ;

            pSwsMetaByShort->grabF( tin0P , TAG( TAGiDnULL ) ) ;      //SHOULD NOT BE NEEDED SINCE ALL KIDS ARE GONE OR PAUSED

            // *pSwsMetaByShort NOW CONTAINS META (FILE META AND INITIALIZED ACCUMULATORS FOR COMPARE META)

            //etThread.tracePoolTalliesF( tin0P ) ;
            //etThread.traceF( tin0P , T("calling tracePoolTalliesF / file meta is loaded") ) ;

            etThread.delF( tin0P , postShortCutoff ) ;
            }
                THREADmODE1rESTORE
                }
                    if( cPausedAtCutoff == cWorkers ) break ;
                    thirdC::dosSleepWinkIF( tin0P ) ;
                {
                for(;;)
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            {
            etThread.traceF( tin0P , T("waiting for all workers to pause or die") ) ;

            //U::while( cWaiting ) sgnGo.giveF( tin0P ) ;       //cWaiting IS USED TO AVOID A RACE CONDITION: A THREAD THAT HAS INCREMENTED cCutoffUpdates BUT HAS NOT YET CALLED waitF WILL NOT SEE THIS SIGN
            sgnGo.giveF( tin0P ) ;
            thirdC::dosSleepWinkIF( tin0P ) ; // TO AVOID RACE
            cCutoffUpdates = 0 ;
            etThread.traceF( tin0P , T("final cutoff [postShortCutoff]:    ")+T(postShortCutoff) ) ;
            }
                THREADmODE1rESTORE
                while( cCutoffUpdates < cWorkers ) thirdC::dosSleepWinkIF( tin0P ) ;
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
            {
            //etThread.traceF( tin0P , T("waiting for all workers to update postShortCutoff") ) ;
        {
        while( !bAbortP && cWorkers )

        }
            if( idPass == 1 ) stPathToYear.lockIfF( tin0P ) ;

            while( !bAbortP && ~hSwsPathToArchives ) ;
            }
                etThread.delF( tin0P , pstt1PathToYear ) ;
                }
                    }
                        etThread.osThreadF( TaRG3fLAGScBtLS( tmCollectFileMetaF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cWorkers , (countT)&stPathToYear , idSlotPathToYear , (countT)&postzShort , (countT)pSwsMetaByShort , (countT)&grabCutoff , (countT)&postShortCutoff , (countT)&cCutoffUpdates , (countT)&sgnGo , (countT)&cPausedAtCutoff , (countT)&cWaiting , (countT)&bAbortP ) ;
                        inc02AM( cWorkers ) ;
                        countT idSlotPathToYear = stPathToYear( psttc1 ) ;
                    {
                    else
                    }
                        }
                            break ;
                            bAbortP = 1 ;
                            etThread.traceF( tin0P , T("exception: idSlotPathToYear is null") ) ;
                            etThread.delF( tin0P , psttPathToYear ) ;
                        {
                        if( !idSlotPathToYear ) //SHOULD BE IMPOSSIBLE
                        stPathToYear.sinkF( tin0P , idSlotPathToYear , psttPathToYear , flSTACKsINK_UNIQUE ) ;
                        ZE( countT , idSlotPathToYear ) ;

                        etThread.strMakeF( tin0P , LF , psttPathToYear , psttc1 ) ; ___( psttPathToYear ) ;
                        ZE( strokeS* , psttPathToYear ) ;
                    {
                    if( idPass == 1 )
                {
                FORsTRINGSiN1( pstt1PathToYear )

                //etThread.traceF( tin0P , T("[pstt1PathToYear]:    ")+T(pstt1PathToYear) ) ;
                etThread.strConvertToLowerCaseF( tin0P , pstt1PathToYear ) ;
                etThread.diskFindFileOrDirF( tin0P , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                patternC pat( tin0P , etThread , tYearSlash , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                ZE( strokeS* , pstt1PathToYear ) ;

                //etThread.traceF( tin0P , T("[tPathToArchive]:    ")+tPathToArchive ) ;
                TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchiveP)+tSlash ;
                strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveNameP.downF( tin0P , hSwsPathToArchives ) ;
            {
            do
            handleC hSwsPathToArchives( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

            }
                pSwsMetaByShort = new( 0 , tin0P , LF ) switchStackC( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_SINKrEVERSE | flSTACKc_SINKiGNOREtABS , &postzShort , flSTACKc_BLOB | flSTACKc_ALLOWzE , cResultStructsNeeded * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ; ___( pSwsMetaByShort ) ;
                cResultStructsNeeded = 1 + cSlotsPathToYear / cResultsPerStruct ;
                cSlotsPathToYear = stPathToYear ;
            {
            if( idPass == 2 )
        {
        for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
        ZE( countT , cWaiting ) ;
        ZE( countT , cPausedAtCutoff ) ;
        signC sgnGo( tin0P , TAG( TAGiDnULL ) ) ;
        ZE( countT   , cCutoffUpdates ) ;
        ZE( osTextT* , postShortCutoff ) ;
        grabC grabCutoff( tin0P , TAG( TAGiDnULL ) ) ;
        ZE( countT , cWorkers ) ;
        stackC stPathToYear( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
        ZE( switchStackC* , pSwsMetaByShort ) ;       // cbData IS NOT KNOWN UNTIL PASS 1 COMPLETES ; WILL BE CT'D IN PASS 2 USING THE THEN KNOWN NUMBER OF PATHS FOR THIS ARCHIVE NAME
        ZE( osTextT* , postzShort  ) ;
        ZE( countT   , cResultStructsNeeded ) ;
        ZE( countT   , cSlotsPathToYear     ) ;     //U:: THIS IS CALCULATED INCORRECTLY EXCEPT WHEN THERE IS ONLY WO YEAR.  RATHER THAN FIX IT, REDESIGN CODE TO PROCESS WO YEAR AT A TIME (OR USE A SEPARATE SWS FOR EACH YEAR AND DO IT IN PARALLEL).  SUCH A REDESIGN WILL ALSO MAKE IT EASIER TO THROTTLE PUSHING TO LIMIT THE NUMBER OF FLAVORS IN THE SWS, WHICH IS NECEWSSARY TO AVOID EXHAUSTING MEMORY SPACE
        ZE( boolT    , bAbortP ) ;

        etThread.traceF( tin0P , T("executive [pattern]:    ")+tYearSlash ) ;
        etThread.delF( tin0P , psttYearP ) ;
        TN( tYearSlash , "" ) ; tYearSlash = T(psttYearP)+T("/") ;

        TN( tPatRejects  , "/ipdos.archives.rejects/" ) ;
        TN( tPatArchives , "/ipdos.archives/" ) ;
        //CS:CODEsYNC: 2 2

        TN( tPerTuck , "%" ) ;
        TN( tSlash , "/" ) ;
        TN( tb4    , "    " ) ;
        TN( tb , " " ) ;
    {

    boolT&        bAbortP                         =        *(boolT*)pTaskP->c5 ;
    switchStackC& swsPathToArchivesByArchiveNameP = *(switchStackC*)pTaskP->c4 ;
    strokeS*&     psttzArchiveP                   =     *(strokeS**)pTaskP->c3 ;
    strokeS*      psttYearP                       =       (strokeS*)pTaskP->c2 ;
    countT&       cExecutiveHealYearP             =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmExecutiveHealYearF )

DONE( tmCopyFileF )
}
    etThread.delF( tin0P , psttFromP ) ;
    etThread.delF( tin0P , psttToP   ) ;

    }
        }
            }
                }
                    }
                        bAbortP = 1 ;
                        etThread.traceF( tin0P , T("diskCopyFileF failed too many times.  will not retry [to,from]:    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
                    {
                    if( !bOk )
                    }
                        }
                            thirdC::dosSleepWinkIF( tin0P , 2 ) ;
                            etThread.traceF( tin0P , T("diskCopyFileF failed.  will retry [cRetries,to,from]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
                            POOPR
                        {
                        else
                        }
                            break ;
                            bOk = 1 ;
                        {
                        if( !POOP )
                        ((tin123S&)tin0P).pEtScratch->diskCopyFileF( tin0P , psttToP , psttFromP , 1 ) ;
                    {
                    while( cTries && cTries -- )
                    ZE( boolT , bOk ) ;

                    cTries = 8 ;

                    etThread.traceF( tin0P , T("copying [to,from]:    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
                {
                else
                }
                    bAbortP = 1 ;
                    etThread.traceF( tin0P , T("bizarre!  there is still a file in the way, so not copying [to,from]:    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
                {
                else if( bExists )
                }
                    bAbortP = 1 ;
                    etThread.traceF( tin0P , T("after rejecting a file out of the way, not copying because could not obtain bExists (probable drive failure) [to,from]:    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
                {
                if( !bOk    )

                }
                    }
                        thirdC::dosSleepWinkIF( tin0P , 2 ) ;
                        etThread.traceF( tin0P , T("diskFileExistsF failed.  will retry [cRetries,to,from]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
                        POOPR
                    {
                    else
                    }
                        break ;
                        bOk = 1 ;
                    {
                    if( !POOP )
                    bExists = ((tin123S&)tin0P).pEtScratch->diskFileExistsF( tin0P , psttToP ) ;
                {
                while( cTries && cTries -- )
                cTries = 8 ;
                bOk = bExists = 0 ;

                countT cTries = 8 ;
            {
            if( !bAbortP )

            }
                etThread.delF( tin0P , psttLongInRejects ) ;
                etThread.delF( tin0P , psttRejected ) ;

                if( !bAbortP ) etThread.traceF( tin0P , T("rejected  file from archive because would have been overwritten [reject,from]:    ")+T(psttRejected)+T("    ")+T(psttToP) ) ;
                }
                    }
                        bAbortP = 1 ;
                        etThread.traceF( tin0P , T("exception:  diskMoveFileOrDirUniqueF 2 [reject,from]:    ")+T(psttRejected)+T("    ")+T(psttToP) ) ;
                        POOPR
                    {
                    if( POOP )
                    RETRY( 8 , ( psttRejected = 0 , ((tin123S&)tin0P).pEtScratch->diskMoveFileOrDirUniqueF( tin0P , psttRejected , psttToP , psttLongInRejects ) ) ) ; ___( psttRejected ) ;
                    SCOOPS
                {
                IFsCRATCH
                ZE( strokeS* , psttRejected ) ;

                etThread.strReplaceF( tin0P , psttLongInRejects , psttToP , tPatArchives , tPatRejects ) ; ___( psttLongInRejects ) ;
                ZE( strokeS* , psttLongInRejects ) ;
            {
            if( bExists )
        {
        else
        }
            bAbortP = 1 ;
            etThread.traceF( tin0P , T("not copying because could not obtain bExists (probable drive failure) [to,from]:    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
        {
        if( !bOk )

        }
            }
                thirdC::dosSleepWinkIF( tin0P , 2 ) ;
                etThread.traceF( tin0P , T("diskFileExistsF failed.  will retry [cRetries,to,from]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
                POOPR
            {
            else
            }
                break ;
                bOk = 1 ;
            {
            if( !POOP )
            bExists = ((tin123S&)tin0P).pEtScratch->diskFileExistsF( tin0P , psttToP ) ;
        {
        while( cTries && cTries -- )
        ZE( boolT , bOk ) ;
        ZE( boolT , bExists ) ;

        countT cTries = 8 ;

        SCOOPS
    {
    IFsCRATCH

    TN( tPatRejects  , "/ipdos.archives.rejects/" ) ;
    TN( tPatArchives , "/ipdos.archives/" ) ;
    //CS:CODEsYNC: 2 2

    boolT&   bAbortP   =  *(boolT*)pTaskP->c3 ;
    strokeS* psttFromP = (strokeS*)pTaskP->c2 ;
    strokeS* psttToP   = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmCopyFileF )

DONE( tmMoveFileToUniqueF )
}
    etThread.delF( tin0P , psttFromP ) ;
    etThread.delF( tin0P , psttToP   ) ;
    etThread.delF( tin0P , psttUnique ) ;

    etThread.traceF( tin0P , T("moved [to,from]:    ")+T(psttUnique)+T("    ")+T(psttFromP) ) ;
    }
        }
            bAbortP = 1 ;
            etThread.traceF( tin0P , T("exception:  diskMoveFileOrDirUniqueF 1 [to,from]:    ")+T(psttUnique)+T("    ")+T(psttFromP) ) ;
            POOPR
        {
        if( POOP )
        RETRY( 8 , ( psttUnique = 0 , ((tin123S&)tin0P).pEtScratch->diskMoveFileOrDirUniqueF( tin0P , psttUnique , psttFromP , psttToP ) ) ) ; ___( psttUnique ) ;
        SCOOPS
    {
    IFsCRATCH
    ZE( strokeS* , psttUnique ) ;

    boolT&   bAbortP   =  *(boolT*)pTaskP->c3 ;
    strokeS* psttFromP = (strokeS*)pTaskP->c2 ;
    strokeS* psttToP   = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmMoveFileToUniqueF )

DONE( tmCollectFileMetaF )
}
    dec02AM( cWorkersP ) ;

    }
        }
            }
                }
                    etThread.traceF( tin0P , T("ended archive pathToYear:    ")+tPathToYearP ) ;
                    }
                        while( ~hWalk ) ;
                        }
                            DEL( pInfoFile ) ;
                            }
                                swsMetaByShortP.ungrabF( tin0P ) ;
                                //etThread.traceF( tin0P , T("after pushing meta for a file [cFlavors]:    ")+TF2(swsMetaByShortP.cFlavorsF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                new( 0 , tin0P , (byteT*)pCursor , sizeof( fileMetaS ) ) fileMetaS( tin0P , bAbortP , idSlotPathToYearP , time1Mod , time2Mod , cbUsed ) ;

                                pCursor += cResultStructsNeeded ;
                                for( countT offs = 0 ; offs < cResultStructsNeeded ; offs ++ ) new( 0 , tin0P , (byteT*)( pCursor + offs ) , sizeof( imageCompareS ) ) imageCompareS ;
                                countT cResultStructsNeeded = 1 + cSlotsPathToYear / cResultsPerStruct ;
                                imageCompareS* pCursor = (imageCompareS*)&swsMetaByShortP[ 1 ] ;

                                swsMetaByShortP << (byteT*)0 ;

                                //etThread.traceF( tin0P , T("[idFile,postzShortP]:    ")+TF2(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+T(postzShortP) ) ;
                                postzShortP = tShort ;
                                swsMetaByShortP.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                                count04T cbUsed = pInfoFile->cbUsedHigh << sizeof( count02T ) * SB | pInfoFile->cbUsed ;

                                sCountT time2Mod = pInfoFile->timeWritten2 ;
                                countT  time1Mod = pInfoFile->timeWritten1 ;

                                }
                                    etThread.traceF( tin0P , T("[perTuck,idFile]:    ")+TF3(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2)+tb+tPerTuck+tb4+TF2(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    countT perTuck = ( idFile << 8 ) / cFiles ;
                                {
                                if( !( idFile % ( TUCK << 2 ) ) )

                                ++ idFile ;
                                                                           
                                }
                                    etThread.delF( tin0P , psttYearSlashShort ) ;
                                    etThread.delF( tin0P , psttPath ) ;
                                    tYearSlashShort = T(psttYearSlashShort) ;
                                    tPath  = T(psttPath) ;
                                    etThread.strBisectF( tin0P , psttPath , psttYearSlashShort , tFileName , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttYearSlashShort ) ;
                                    ZE( strokeS* , psttYearSlashShort ) ;
                                    ZE( strokeS* , psttPath ) ;
                                {
                                TN( tYearSlashShort , "" ) ;
                                TN( tPath  , "" ) ;

                                TN( tFileName , pInfoFile->psttIfoName ) ;
                            {
                            if( pInfoFile )

                            }
                                }
                                    break ;
                                    DEL( pInfoFile ) ;
                                    bAbortP = 1 ;
                                    etThread.traceF( tin0P , T("exception:  diskFileQueryF") ) ;
                                    POOPR
                                {
                                if( POOP )
                                RETRYsCR( 8 , diskFileQueryF( tin0P , pInfoFile , fi ) ) ; ___( pInfoFile ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            fileC fi( tin0P , (strokeS*)tLong , ifcOPENaCCESS_R ) ;
                            ZE( infoFileS* , pInfoFile ) ;

                            TN( tLong , "" ) ; tLong = tPathToYearP+tShort ;

                            }
                                //etThread.traceF( tin0P , T("resumed collecting file meta into sws, using stIdJot") ) ;

                                //etThread.traceF( tin0P , T("waited  for sgnGo") ) ;
                                dec02AM( cWaitingP ) ;
                                sgnGoP.waitF( tin0P ) ;
                                inc02AM( cCutoffUpdatesP ) ;
                                inc02AM( cWaitingP ) ;
                                //etThread.traceF( tin0P , T("waiting for sgnGo") ) ;

                                }
                                    }
                                        }
                                            break ;
                                            bAbortP = 1 ;
                                            etThread.traceF( tin0P , T("exception: could not obtain a pageC instance containing a short file name 3") ) ;
                                        {
                                        else
                                        }
                                            grabCutoffP.ungrabF( tin0P ) ;

                                            }
                                                etThread.strMakeF( tin0P , LF , postShortCutoffP , tShortCutoff ) ; ___( postShortCutoffP ) ;
                                                etThread.delF( tin0P , postShortCutoffP ) ;
                                            {
                                            if( !postShortCutoffP || 0 < thirdC::c_strcmpIF( tin0P , postShortCutoffP , tShortCutoff ) )

                                            grabCutoffP.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                                            }
                                                break ;
                                                bAbortP = 1 ;
                                                etThread.traceF( tin0P , T("exception: short cutoff is null length 3") ) ;
                                            {
                                            if( !tShortCutoff.csF( tin0P ) )      //SHOULD BE IMPOSSIBLE
                                            //etThread.traceF( tin0P , T("proposed [tShortCutoff]:    ")+tShortCutoff ) ;
                                            TN( tShortCutoff , (const byteT*)page ) ;
                                        {
                                        if( ~page )

                                        pageC page = jotShortFileNames[ idjCutoff ] ;
                                    {
                                    if( idjCutoff )
                                    countT idjCutoff = stIdJot[ (sCountT)( 0 - idPlateCutoffWanted ) ] ;
                                {
                                if( stIdJot > idPlateCutoffWanted )
                                countT idPlateCutoffWanted = idPlate - 1 + BATCHsIZE ;
                                //CS:CODEsYNCH: PSEUDODUPLICATE 1
                                //etThread.traceF( tin0P , T("calculating the next proposed cutoff value") ) ;

                                //etThread.traceF( tin0P , T("waited  for sgnGo") ) ;
                                dec02AM( cPausedAtCutoffP ) ;
                                dec02AM( cWaitingP ) ;
                                sgnGoP.waitF( tin0P ) ;
                                inc02AM( cPausedAtCutoffP ) ;
                                inc02AM( cWaitingP ) ;
                                //etThread.traceF( tin0P , T("waiting for sgnGo (the short name that i would now process is beyond the cutoff)") ) ;
                            {
                            if( postShortCutoffP && 0 < thirdC::c_strcmpIF( tin0P , tShort , postShortCutoffP ) )

                            }
                                break ;
                                bAbortP = 1 ;
                                etThread.traceF( tin0P , T("exception: short file name is null length") ) ;
                            {
                            if( !tShort.csF( tin0P ) )     //SHOULD BE IMPOSSIBLE

                            //etThread.traceF( tin0P , tShort ) ;
                            }
                                }
                                    break ;
                                    bAbortP = 1 ;
                                    etThread.traceF( tin0P , T("exception: could not obtain a pageC instance containing a short file name 2") ) ;
                                {
                                else
                                if( ~page ) tShort = T((const byteT*)page) ;
                                pageC page = jotShortFileNames[ idj ] ;
                            {
                            TN( tShort , "" ) ;

                            countT idj = stIdJot.upF( tin0P , hWalk ) ;

                            idPlate ++ ; //SINCE I AM GOING UP, THIS IS NOT THE idPlate ASSOCIATED WITH stackC MEMBER FUNCTIONS, FOR WHICH THE TOP PLATE IS idPlate 1
                        {
                        do
                        handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        ZE( countT , idFile ) ;
                        ZE( countT , idPlate ) ;
                    {
                    if( stIdJot )
                    etThread.traceF( tin0P , T("collecting file meta into sws, using stIdJot") ) ;

                    //etThread.traceF( tin0P , T("waited  for sgnGo") ) ;
                    dec02AM( cWaitingP ) ;
                    sgnGoP.waitF( tin0P ) ;
                    inc02AM( cCutoffUpdatesP ) ;
                    inc02AM( cWaitingP ) ;
                    //etThread.traceF( tin0P , T("waiting for sgnGo") ) ;
                {
                if( !bAbortP )

                }
                    }
                        }
                            bAbortP = 1 ;
                            etThread.traceF( tin0P , T("exception: could not obtain the pageC instance containing a short file name") ) ;
                        {
                        else
                        }
                            grabCutoffP.ungrabF( tin0P ) ;

                            }
                                etThread.strMakeF( tin0P , LF , postShortCutoffP , tShortCutoff ) ; ___( postShortCutoffP ) ;
                                etThread.delF( tin0P , postShortCutoffP ) ;
                            {
                            if( !postShortCutoffP || 0 < thirdC::c_strcmpIF( tin0P , postShortCutoffP , tShortCutoff ) )

                            grabCutoffP.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                            }
                                bAbortP = 1 ;
                                etThread.traceF( tin0P , T("exception: short cutoff is null length") ) ;
                            {
                            if( !tShortCutoff.csF( tin0P ) )   //SHOULD BE IMPOSSIBLE
                            //etThread.traceF( tin0P , T("proposed [tShortCutoff]:             ")+tShortCutoff ) ;
                            TN( tShortCutoff , (const byteT*)page ) ;
                        {
                        if( ~page )

                        pageC page = jotShortFileNames[ idjCutoff ] ;
                    {
                    if( idjCutoff )
                    countT idjCutoff = stIdJot[ (sCountT)( 0 - BATCHsIZE ) ] ;
                {
                if( stIdJot > BATCHsIZE )
                //CS:CODEsYNCH: PSEUDODUPLICATE 1
                //etThread.traceF( tin0P , T("calculating a proposed cutoff value") ) ;

                //}
                //    while( ~hWalk ) ;
                //    }
                //        else        { BL AMMO ; } //SHOULD BE IMPOSSIBLE
                //        if( ~page ) etThread.traceF( tin0P , T((const byteT*)page) ) ;
                //
                //        pageC page = jotShortFileNames[ idj ] ;
                //
                //        countT idj = stIdJot.upF( tin0P , hWalk ) ;
                //    {
                //    do
                //    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                //{
                //if( stIdJot )
                //etThread.traceF( tin0P , T("reading in sorted order, using stIdJot") ) ;
            {
            if( !bAbortP )

            etThread.traceF( tin0P , T("counted files [cFiles,stIdJot]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)stIdJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            }
                while( !ether && !bAbortP && ~hFindFile && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        }
                            stIdJot.sinkF( tin0P , countTC() , idJot , flSTACKsINK_null , subtractJottedOsTextF , (countT)&bAbortP ) ;
                            countT idJot = jotShortFileNames.writeF( tin0P , tShort , tShort.csF( tin0P ) + 1 ) ;
                        {
                        if( tShort.csF( tin0P ) )        // IF NOT A DIRECTORY
                                                                   
                        }
                            etThread.delF( tin0P , psttShort ) ;
                            etThread.delF( tin0P , psttnu ) ;
                            tShort  = T(psttShort) ;
                            etThread.strBisectF( tin0P , psttnu , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShort , "" ) ;
                        cFiles ++ ;
                    {
                    else
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( bAbortP || !pInfoFile || !pInfoFile->psttIfoName )

                    }
                        }
                            bAbortP = 1 ;
                            etThread.traceF( tin0P , T("exception:  diskFindFileOrDirF") ) ;
                            POOPR
                        {
                        if( POOP )
                        RETRYsCR( 8 , diskFindFileOrDirF( tin0P , pInfoFile , hFindFile , tPathToYearP ) )
                        SCOOPS
                    {
                    IFsCRATCH
                    ZE( infoFileS* , pInfoFile ) ;

                    }
                        etThread.traceF( tin0P , T("[cFiles,volume,pathToYear]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tVolumeName+tb4+tPathToYearP ) ;
                    {
                    if( cFiles && !( cFiles % ( TUCK << 4 ) ) )
                {
                do
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                handleC hFindFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {
            
            ZE( countT , cFiles ) ;
            stackC stIdJot( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKiGNOREtABS | flSTACKc_SINKrEVERSE ) ;
            jotC jotShortFileNames( tin0P , "short.file.names" , flJOTc_WRITE | flJOTc_PRIVATE | flJOTc_DELETE | flJOTc_PURGEoNcT , 1 ) ;            //U:: 1 IS ARBITRARY AND WILL BE INSUFFICIENT WHEN SORTING MUST REACH BEYOND THE PRIOR BOOK.  ENHANCE jotC TO SUPPORT A REASONABLE DEFAULT NUMBER OF INACTIVE
            etThread.traceF( tin0P , T("counting files") ) ;

            etThread.traceF( tin0P , T("this thread's job: [volume,pathToYear]:    ")+tVolumeName+tb4+tPathToYearP ) ;

            //}
            //    etThread.delF( tin0P , pstt1Words ) ;
            //    }
            //        else if( bArm                                               ) bArm -- ;
            //        else if( !etThread.strCompareF( tin0P , psttc1 , tArchives ) ) bArm = 2 ;
            //             if( bArm == 1                                          ) tYear = T(psttc1) ;
            //    {
            //    FORsTRINGSiN1( pstt1Words )
            //    TN( tArchives , "ipdos.archives" ) ;
            //    ZE( boolT , bArm ) ;
            //    etThread.strWordsF( tin0P , pstt1Words , tPathToYearP , sttq , T("/") ) ; ___( pstt1Words ) ;
            //    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            //    ZE( strokeS* , pstt1Words ) ;
            //{
            //TN( tYear , "" ) ;
        {
        if( !bAbortP )

        }
            DEL( pInfoDisk ) ;
            tVolumeName = T(pInfoDisk->psttVolumeName) ;
            etThread.strConvertToLowerCaseF( tin0P , pInfoDisk->psttVolumeName ) ;
            etThread.delF( tin0P , psttDisk ) ;
            }
                }
                    bAbortP = 1 ;
                    etThread.traceF( tin0P , T("exception:  diskInfoF: could not obtain volume name") ) ;
                    POOPR
                {
                if( POOP )
                RETRYsCR( 8 , diskInfoF( tin0P , pInfoDisk , psttDisk ) ) ; ___( pInfoDisk ) ;
                SCOOPS
            {
            IFsCRATCH
            ZE( infoDiskS* , pInfoDisk ) ;

            etThread.strSubstringF( tin0P , psttDisk , idf , idl , tPathToYearP ) ; ___( psttDisk ) ;
            countT idl = 5 ;
            countT idf = 1 ;
            ZE( strokeS* , psttDisk ) ;
        {
        TN( tVolumeName , "" ) ;

        TN( tPathToYearP , (strokeS*)stPathToYearP[ idSlotPathToYearP ] ) ;
        TN( tPerTuck , "%" ) ;
        TN( tDot , "." ) ;
        TN( tb4 , "    " ) ;
        TN( tb , " " ) ;
        const countT  cSlotsPathToYear = stPathToYearP ;
    {

    boolT&        bAbortP                  =        *(boolT*)pTaskP->cc ;
    countT&       cWaitingP                =       *(countT*)pTaskP->cb ;
    countT&       cPausedAtCutoffP         =       *(countT*)pTaskP->ca ;
    signC&        sgnGoP                   =        *(signC*)pTaskP->c9 ;
    countT&       cCutoffUpdatesP          =       *(countT*)pTaskP->c8 ;
    osTextT*&     postShortCutoffP         =     *(osTextT**)pTaskP->c7 ;
    grabC&        grabCutoffP              =        *(grabC*)pTaskP->c6 ;
    switchStackC& swsMetaByShortP          = *(switchStackC*)pTaskP->c5 ;
    osTextT*&     postzShortP              =     *(osTextT**)pTaskP->c4 ;
    countT        idSlotPathToYearP        =                 pTaskP->c3 ;
    stackC&       stPathToYearP            =       *(stackC*)pTaskP->c2 ;
    countT&       cWorkersP                =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 && pTaskP->c8 && pTaskP->c9 && pTaskP->ca && pTaskP->cb )
TASK( tmCollectFileMetaF )

#endif
}

{
//CODEmINE:
#if defined( NEVERdEFINED )

}
    return sgn ;

    }
        ether.delF( tin0P , post1Copy ) ;

        sgn = bAbortP ? 0 : thirdC::c_strcmpIF( tin0P , post1Copy , post2 ) ; ;
        //ether.traceF( tin0P , T("subtract [post1,post2]:    ")+T(post1Copy)+T("    ")+T(post2) ) ;

        }
            bAbortP = 1 ;
            ether.traceF( tin0P , T("subtractJottedOsTextF / could not obtain text [idJot]:    ")+TF2(c2P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        if( !post2 )

        }
            bAbortP = 1 ;
            ether.traceF( tin0P , T("subtractJottedOsTextF / could not obtain text [idJot]:    ")+TF2(c1P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        if( !post1Copy )

        const osTextT* post2 = page2 ;
        pageC page2 = jotC::readIF( tin0P , c2P ) ;

        }
            thirdC::c_memcpyIF( tin0P , post1Copy , post1 , cost1 ) ;    
            ether.newF( tin0P , LF , post1Copy , cost1 ) ; ___( post1Copy ) ;
            countT         cost1 = page1 ;
            const osTextT* post1 = page1 ;
            pageC page1 = jotC::readIF( tin0P , c1P ) ;
        {
        ZE( osTextT* , post1Copy ) ;

        boolT&  bAbortP = *(boolT*)c3P ;
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther && c3P )
    ZE( sCountT , sgn ) ;

    }
    {
    IFbEcAREFUL
{
/*1*/countT subtractJottedOsTextF( tin0S& tin0P , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    return *pfr1 - *pfr2 ;

    fileMetaS* pfr2 = (fileMetaS*)c2P ;
    fileMetaS* pfr1 = (fileMetaS*)c1P ;
{
/*1*/countT subtractFileMetaF( tin0S& tin0P , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    ((tin123S&)tin0P).pEther->traceF( tin0P , T(psttP)+T(" [bitsResult]:    ")+TF4(bitsResult,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
{
voidT imageCompareS::traceF( tin0S& tin0P , const strokeS* const psttP )

}
    //traceF( tin0P , T("ct      :    ") ) ;
    TINSL
{
bitsResult( BITSrESULT_UNKNOWN )
imageCompareS::imageCompareS( voidT ) :

NEWdELcLASS( 2 , imageCompareS ) ;

}
    return ((tin123S&)tin0P).pEther->memCompareF( tin0P , (byteT*)this , (byteT*)&frP , sizeof( countT ) + sizeof( count04T ) ) ;    //CS:CODEsYNC 1 1
    TINSL
{
sCountT fileMetaS::operator -( const fileMetaS& frP ) const

}
    ((tin123S&)tin0P).pEther->traceF( tin0P , T(psttP)+T(" [timeModRounded,timeMod,cbUsed,cVotes,idSlotPathToYear,path]:    ")+TF3(timeModRounded,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T("    ")+TT(time1Mod,time2Mod)+T("    ")+TT(((countT*)&cbUsed)[0],((countT*)&cbUsed)[1])+T("    ")+TF2(cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idSlotPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((strokeS*)stPathToYearP[idSlotPathToYear]) ) ;
{
voidT fileMetaS::traceF( tin0S& tin0P , stackC& stPathToYearP , const strokeS* const psttP )

}
    timeModRounded = *(countT*)( (byteT*)pc2 + 3 ) + bRoundUp ;
    countT pc2[ 2 ] = { time1Mod , time2Mod } ;

    boolT bRoundUp = !!( ( time1Mod & 0xffffff ) > 0x800000 ) ;

    }
        bAbortP = 1 ;
        ((tin123S&)tin0P).pEther->traceF( tin0P , T("fileMetaS::fileMetaS / exception: idSlotPathToYear is null") ) ;
    {
    if( !idSlotPathToYear )
{
idSlotPathToYear( idSlotPathToYearP )
cVotes( 0 ) ,
time2Mod( time2ModP ) ,
time1Mod( time1ModP ) ,
cbUsed( cbUsedP ) ,
timeModRounded( 0 ) ,
fileMetaS::fileMetaS( tin0S& tin0P , boolT& bAbortP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) :

NEWdELcLASS( 1 , fileMetaS ) ;

osTextT* postDebugLever ;

const countT cResultsPerStruct = sizeof( countT ) * SB / 2 ;     // 2 BITS ARE USED TO STORE A RESULT, SO 4 RESULTS FIT INTO A BYTE AND 01 RESULTS FIT INTO A count02T ; MY CODE SHOULD BE WRITTEN WITHOUT ASSUMING countT IS count02T

;
}
    voidT traceF( tin0S& tin0P , const strokeS* const psttP = 0 ) ;
    inline sCountT operator -( imageCompareS& picP ) { return bitsResult - picP.bitsResult ; }
    imageCompareS( voidT ) ;
    NEWdELcLASSpROTOS

    countT bitsResult ;
{
struct imageCompareS

;
}
    sCountT operator -( const fileMetaS& frP ) const ;
    voidT traceF( tin0S& tin0P , stackC& stPathToYearP , const strokeS* const psttP = 0 ) ;
    fileMetaS( tin0S& tin0P , boolT& bAbortP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) ;
    NEWdELcLASSpROTOS

    countT   idSlotPathToYear ;
    countT   cVotes ;
    sCountT  time2Mod ;
    countT   time1Mod ;
    count04T cbUsed ;
    countT   timeModRounded ;   //CS:CODEsYNC 1 1
{
struct fileMetaS

#define CyEARSiNpARALLEL  2
//20221210@2201: 4 IS TOO MANY.  THREAD LAUNCH FAILED.
//U:: 1 FOR TESTING; PERHAPS 4 FOR PROD

#define BATCHsIZE  ( TUCK >> 0 )

#define BITSrESULT_ALLbITS        3
#define BITSrESULT_EQUAL          2
#define BITSrESULT_NOTeQUAL       1
#define BITSrESULT_UNKNOWN        0

//OBSOLETES 7e3
//OBSOLETED BY 6 (7e5?)

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_HEALaRCHIVES" )/*1*/
/**/
*/
all BLAMMO's have been removed, but fails due to thread launch failure
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
