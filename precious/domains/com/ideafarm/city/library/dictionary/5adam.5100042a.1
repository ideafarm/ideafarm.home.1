
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

while( stPhrasesLog || ((tinFullS&)tinBaseP).cKidThreads ) etThread.osSleepF( tinBaseP , TOCK ) ;
}
    etThread.delF( tinBaseP , psttr ) ;
    etThread.boxPutF( tinBaseP , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM) , postr , costr ) ;
    countT costr = etThread.strMakeF( tinBaseP , LF , postr , tr ) ; ___( postr ) ;
    ZE( osTextT* , postr ) ;

    tr = tr1+tr2 ;
    tr2 = T(psttr) ;
    tr1 = T("Subject: wiretap report\r\n\r\n") ;
    TN( tr2 , "" ) ;
    TN( tr1 , "" ) ;
    TN( tr , "" ) ;

    etThread.strConcatenateF( tinBaseP , psttr , stPhrases ) ; ___( psttr ) ;
    ZE( strokeS* , psttr ) ;
{

etThread.ifcDrivenServerF( tinBaseP , i1 , i2 ) ;
serverInfo2S i2( 0x1f40 , flSOCKETc_null , TF2(thirdC::third_idAdamRootI_IF( tinBaseP ),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) , 0 , (countT)&c8p , 0 , - 1 , 1 , sizeof( stateS ) , translateStateF ) ;
serverInfo1S i1( &pbdVarying , b_pbdVarying , bHandedOff , sgnIdPortReplaced , tmcF , countTC() , ether ) ;
etThread.ifcChatF( tinBaseP , cArg , DDNUMB , chatHandlerF ) ;
etThread.osThreadF(  tinBaseP , countTC() , tmLogF  , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , cArg ) ;

countT cArg = (countT)&c8p ;
c8p.c5 = (countT)&((tinFullS&)tinBaseP).cKidThreads ;
c8p.c4 = (countT)&stPhrasesLog ;
c8p.c3 = (countT)&stPhrases ;
c8p.c2 = (countT)&b_pbdVarying ;
c8p.c1 = (countT)&pbdVarying ;
count8S c8p ;

stackC stPhrasesLog( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
stackC stPhrases(    tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
ZE( boolT , bHandedOff ) ;
batonC b_pbdVarying( tinBaseP , TAG( TAGiDnULL ) ) ;
ZE( byteT* , pbdVarying ) ;
signC sgnIdPortReplaced( tinBaseP , TAG( TAGiDnULL ) ) ;

etThread.boxPutF( tinBaseP , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM) , "Subject: wiretapper reporting for duty\r\n\r\na new wiretapper is now on duty.\r\nwhen i am dismissed, i will report the results of my shift to you\r\n" ) ; //U::

TODO

}
    if( cArgP && idAdamHandlingP && idChatSessionP ) ;

    }
        }
            }
                }
                    break ;
                    bBye = 1 ;
                {
                default :
                case ifcIDcMDsESSION_BYE :
                }
                    break ;
                    psoP->writeF( tinBaseP , sInP ) ;
                {
                case ifcIDcMDsESSION_ECHO :
            {
            switch( sInP.cFieldF( tinBaseP ) )
        {
        if( !etThread && !*((tinFullS&)tinBaseP).zEtScratch )
        psoP->readF( tinBaseP , sInP ) ;
        soulC sInP( tinBaseP , TAG( TAGiDnULL ) ) ;
    {
    while( !ether && !etThread && !*((tinFullS&)tinBaseP).zEtScratch && !bBye )
    ZE( boolT , bBye ) ;
{
voidT chatHandlerF( tinBaseS& tinBaseP , etherC& ether , etherC& etThread , socketC*& psoP , const countT idChatSessionP , countT cArgP , const countT idAdamHandlingP )

DONE( tmLogF )

}
    }
        ether.osSleepF( tinBaseP , TOCK ) ;
        }
            etThread.delF( tinBaseP , psttp ) ;
            }
                etThread.delF( tinBaseP , postp ) ;
                thirdC::logIF( tinBaseP , "\\log.ifc.c240104" , 0 , 0 , 0 , (countT)postp , 0 , costp ) ;
                countT costp = etThread.strMakeF( tinBaseP , LF , postp , psttp ) ; ___( postp ) ;
                ZE( osTextT* , postp ) ;
            {
            if( psttp )
            stPhrasesLog >> psttp ;
            ZE( strokeS* , psttp ) ;
        {
        while( stPhrasesLog )
    {
    while( !etThread && ( !ether || cKidThreads > 1 ) )

    countT&      cKidThreads   =      *(countT*)c8p.c5 ;
    stackC&      stPhrasesLog  =      *(stackC*)c8p.c4 ;
    stackC&      stPhrases     =      *(stackC*)c8p.c3 ;
    batonC&      b_pbdVarying  =      *(batonC*)c8p.c2 ;
    byteT*&      pbdVarying    =      *(byteT**)c8p.c1 ;
    count8S&     c8p           = *(count8S*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmLogF )

DONEdRIVENsERVER( tmcF )
}
    while( !bQuit ) bQuit = woRequestF( tinBaseP , etThread , *((tinFullS&)tinBaseP).zEtScratch , *pso , stPhrases , stPhrasesLog ) ;
    ZE( boolT , bQuit ) ;

    b_pbdVarying.ungrabF( tinBaseP ) ;
    }
        TN( t_cHamburgers , "" ) ; t_cHamburgers = TF3(++state.cHamburgers,0,8) ;
        TN( t_idMe        , "" ) ; t_idMe        = TF3(state.idMe,0,8) ;
        stateS& state = *(stateS*)pbdVarying ;
    {
    if( pbdVarying )
    b_pbdVarying.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;


    countT&      cKidThreads   =      *(countT*)c8p.c5 ;
    stackC&      stPhrasesLog  =      *(stackC*)c8p.c4 ;
    stackC&      stPhrases     =      *(stackC*)c8p.c3 ;
    batonC&      b_pbdVarying  =      *(batonC*)c8p.c2 ;
    byteT*&      pbdVarying    =      *(byteT**)c8p.c1 ;
    count8S&     c8p           =     *(count8S*)cArg ;
{
if( cArg )
TASKdRIVENsERVER( tmcF )

TRANSLATEsTATEdRIVENsERVER_END
    state.idMe ++ ;
TRANSLATEsTATEdRIVENsERVER_MIDDLE
    case 1 : { state.idMe        = stateOther.idMe        ; }
    case 2 : { state.cHamburgers = stateOther.cHamburgers ; }
TRANSLATEsTATEdRIVENsERVER_BEGIN( stateS , 2 )

}
    return 1 ;
    stPhrasesP.ungrabF( tinBaseP ) ;

    }
        sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_9) ) ;
        }
            etThread.delF( tinBaseP , postBody ) ;
            }
                sClientP.writeF( tinBaseP , postBody , costBody ) ;
                sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_4C) ) ;
                else               sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postBody) ) ;
                if( bEncodedBody ) sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , tEncoded    ) ;
                sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_4B) ) ;
            {
            if( postBody && costBody )
        {
        if( !*((tinFullS&)tinBaseP).zEtScratch )
        sClientP.writeF( tinBaseP , "\r\n" , 2 ) ;
        }
            etThread.delF( tinBaseP , postl ) ;
            sClientP.writeF( tinBaseP , "\r\n" , 2 ) ;
            sClientP.writeF( tinBaseP , postl , costl ) ;
            sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postl)+tCRLF ) ;
            etThread.delF( tinBaseP , psttl ) ;
            countT costl = etThread.strMakeF( tinBaseP , LF , postl , psttl ) ; ___( postl ) ;
            ZE( osTextT* , postl ) ;
            stHeaderLines >> psttl ;
            ZE( strokeS* , psttl ) ;
        {
        while( stHeaderLines )
        sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_4A) ) ;
        // WRITE REPLY TO CLIENT

        sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_3C) ) ;
        }
            else               sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postBody) ) ;
            if( bEncodedBody ) sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , tEncoded    ) ;
            if( postBody ) postBody[ costBody ] = 0 ;
            sServer.readF( tinBaseP , postBody , costBody ) ;
            etThread.newF( tinBaseP , LF , postBody , costBody + 1 ) ; ___( postBody ) ;
            sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_3B) ) ;
        {
        if( costBody )
        { ZE( strokeS* , psttHost ) ; bEncodedBody = 0 ; readHeaderLinesF( tinBaseP , etThread , etThread , sServer , stPhrasesP , stPhrasesLogP , stHeaderLines , costBody , bEncodedBody , psttHost , 1 ) ; etThread.delF( tinBaseP , psttHost ) ; }
        sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_3A) ) ;
        ZE( countT , costBody ) ;
        ZE( osTextT* , postBody ) ;
        // READ REPLY FROM SERVER

        etThread.delF( tinBaseP , psttBody ) ;
        sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_2C) ) ;
        }
            etThread.delF( tinBaseP , postBody ) ;
            sServer.writeF( tinBaseP , postBody , costBody ) ;
            else               sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , psttBody ) ;
            if( bEncodedBody ) sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , tEncoded    ) ;
            countT costBody = etThread.strMakeF( tinBaseP , LF , postBody , psttBody ) ; ___( postBody ) ;
            ZE( osTextT* , postBody ) ;
            sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_2B) ) ;
        {
        if( psttBody && psttBody->idAdam )
        sServer.writeF( tinBaseP , "\r\n" , 2 ) ;
        }
            etThread.delF( tinBaseP , postl ) ;
            sServer.writeF( tinBaseP , "\r\n" , 2 ) ;
            sServer.writeF( tinBaseP , postl , costl ) ;
            sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postl)+tCRLF ) ;
            etThread.delF( tinBaseP , psttl ) ;
            countT costl = etThread.strMakeF( tinBaseP , LF , postl , psttl ) ; ___( postl ) ;
            ZE( osTextT* , postl ) ;
            stHeaderLines >> psttl ;
            ZE( strokeS* , psttl ) ;
        {
        while( stHeaderLines )
        sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_2A) ) ;
        etThread.delF( tinBaseP , psttHost ) ;
        sServer.connectF( tinBaseP , 0x50 , socketC::nicNameIF( tinBaseP , etThread , psttHost ) ) ;
        socketC sServer( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
        // WRITE REQUEST TO SERVER
    {
    if( !*((tinFullS&)tinBaseP).zEtScratch && stHeaderLines ) // DO NOT KNOW WHY THIS HAPPENS WITH IE5.5: CONJ: WHEN I AM RUN ON IFC21, I AM SO SLOW THAT IE5.5 ABANDONS THE REQUEST

    sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T("psttHost: \"")+T(psttHost)+T("\"\r\n") ) ;

    }
        sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_1C) ) ;
        }
            }
                else               sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , psttBody ) ;
                if( bEncodedBody ) sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , tEncoded ) ;
                etThread.delF( tinBaseP , postBody ) ;
                etThread.strMakeF( tinBaseP , LF , psttBody , T(postBody) ) ; ___( psttBody ) ;
                if( postBody ) postBody[ costBody ] = 0 ;
            {
            if( !*((tinFullS&)tinBaseP).zEtScratch )
            sClientP.readF( tinBaseP , postBody , costBody ) ;
            etThread.newF( tinBaseP , LF , postBody , costBody + 1 ) ; ___( postBody ) ;
            ZE( osTextT* , postBody ) ;
            sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_1B) ) ;
        {
        if( !*((tinFullS&)tinBaseP).zEtScratch && costBody )

        readHeaderLinesF( tinBaseP , etThread , *((tinFullS&)tinBaseP).zEtScratch , sClientP , stPhrasesP , stPhrasesLogP , stHeaderLines , costBody , bEncodedBody , psttHost ) ;
        bEncodedBody = 0 ;
        sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_1A) ) ;
        ZE( countT , costBody ) ;
    {
    stackC stHeaderLines( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    ZE( boolT , bEncodedBody ) ;
    ZE( strokeS* , psttBody ) ;
    ZE( strokeS* , psttHost ) ;
    // READ REQUEST FROM CLIENT
    sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(postSEPARATOR_0) ) ;
    TN( tEncoded , "[encoded]\r\n" ) ;
    TN( tCRLF , "\r\n" ) ;

    stPhrasesP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
{
boolT woRequestF( tinBaseS& tinBaseP , etherC& etThread , socketC& sClientP , stackC& stPhrasesP , stackC& stPhrasesLogP )
*/
/*

}
    etThread.delF( tinBaseP , psttPVersion ) ;
    etThread.delF( tinBaseP , psttProtocol ) ;
    etThread.delF( tinBaseP , psttUrl ) ;
    etThread.delF( tinBaseP , psttAction ) ;

    }
        etThread.delF( tinBaseP , psttl ) ;
        }
            break ;
            etThread.delF( tinBaseP , psttl ) ;
        {
        else
        }
            }
                etThread.delF( tinBaseP , psttValue ) ;
                etThread.delF( tinBaseP , psttKey ) ;
                }
                    bEncodedBodyP = 1 == etThread.strIdF( tinBaseP , idf , sttq , tImage , psttValue ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf = 1 ;
                    etThread.strConvertToLowerCaseF( tinBaseP , psttValue ) ; ___( psttValue ) ;
                {
                else if( !etThread.strCompareF( tinBaseP , psttKey , tContentType   ) )
                     if( !etThread.strCompareF( tinBaseP , psttKey , tContentLength ) ) costBodyP = etThread.strDigitsToSCountF( tinBaseP , psttValue , 0xa , 1 ) ;
                etThread.strSubstringF( tinBaseP , psttValue , idf , idl , psttl ) ; ___( psttValue ) ;
                ZE( countT , idl ) ;
                etThread.strConvertToLowerCaseF( tinBaseP , psttKey ) ; ___( psttKey ) ;
                etThread.strSubstringF( tinBaseP , psttKey , idf , sttq , tColonWhite , psttl , 1 ) ; ___( psttKey ) ;
                countT idf = 1 ;
                ZE( strokeS* , psttValue ) ;
                ZE( strokeS* , psttKey ) ;
            {
            else
            }
                sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T("psttHostP:    \"")+T(psttHostP)+tEQCRLF ) ;
                sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T("psttPVersion: \"")+T(psttPVersion)+tEQCRLF ) ;
                sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T("psttProtocol: \"")+T(psttProtocol)+tEQCRLF ) ;
                sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T("psttUrl:      \"")+T(psttUrl)+tEQCRLF ) ;
                sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T("psttAction:   \"")+T(psttAction)+tEQCRLF ) ;

                else __1
                }
                    etThread.strSubstringF( tinBaseP , psttHostP , idf , sttq , tSlash , psttUrl ) ; ___( psttPVersion ) ;
                {
                if( 1 == etThread.strIdF( tinBaseP , idf , sttq , tHttpColonSS , psttUrl ) )
                idf = 1 ; /*sttq = ze ;*/

                etThread.delF( tinBaseP , psttw ) ;
                etThread.strSubstringF( tinBaseP , psttPVersion , idf , sttq , tSlash , psttw ) ; ___( psttPVersion ) ;
                etThread.strSubstringF( tinBaseP , psttProtocol , idf , sttq , tSlash , psttw ) ; ___( psttProtocol ) ;
                idf = 1 ; /*sttq = ze ;*/
                etThread.strConvertToLowerCaseF( tinBaseP , psttw ) ; ___( psttw ) ;
                etThread.strSubstringF( tinBaseP , psttw , idf , sttq , tBlank , psttl , 1 ) ; ___( psttw ) ;
                ZE( strokeS* , psttw ) ;

                etThread.strSubstringF( tinBaseP , psttUrl , idf , sttq , tBlank , psttl , 1 ) ; ___( psttUrl ) ;

                etThread.strConvertToLowerCaseF( tinBaseP , psttAction ) ; ___( psttAction ) ;
                etThread.strSubstringF( tinBaseP , psttAction , idf , sttq , tBlank , psttl , 1 ) ; ___( psttAction ) ;

                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                countT idf = 1 ;

                TN( tEQCRLF      , "\"\r\n"  ) ;
                TN( tHttpColonSS , "http://" ) ;
                TN( tColon       , ":"       ) ;
                TN( tSlash       , "/"       ) ;
                TN( tBlank       , " "       ) ;
            {
            if( !bReplyP && !psttAction )
            sayF( tinBaseP , etThread , stPhrasesP , stPhrasesLogP , T(psttl)+tCRLF ) ;

            stP << psttOldC( tinBaseP , etThread , psttl ) ;
        {
        if( !*((tinFullS&)tinBaseP).zEtScratch && psttl && psttl->idAdam )
        sInP.readWoLineF( tinBaseP , psttl , 0x200 ) ; ___( psttl ) ;
        ZE( strokeS* , psttl ) ;
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    {
    while( !*((tinFullS&)tinBaseP).zEtScratch && !etThread )

    ZE( strokeS* , psttPVersion ) ;
    ZE( strokeS* , psttProtocol ) ;
    ZE( strokeS* , psttUrl ) ;
    ZE( strokeS* , psttAction ) ;

    TN( tImage         , "image/" ) ;
    TN( tContentType   , "content-type" ) ;
    TN( tContentLength , "content-length" ) ;
    TN( tColonWhite , ": " ) ;
    TN( tCRLF , "\r\n" ) ;
{
voidT readHeaderLinesF( tinBaseS& tinBaseP , etherC& etThread , socketC& sInP , stackC& stPhrasesP , stackC& stPhrasesLogP , stackC& stP , countT& costBodyP , boolT& bEncodedBodyP , strokeS*& psttHostP , const boolT bReplyP = 0 )

}
    stPhrasesLogP << psttOldC( tinBaseP , etThread , psttP ) ;
    stPhrasesP    << psttOldC( tinBaseP , etThread , psttP ) ;
{
voidT sayF( tinBaseS& tinBaseP , etherC& etThread , stackC& stPhrasesP , stackC& stPhrasesLogP , const strokeS* const psttP )

;
}
    countT cHamburgers ;
    countT idMe ;
    countT idVersion ;
{
struct stateS

#define postSEPARATOR_9  "\r\n---< E N D >----< E N D >----< E N D >----< E N D >----< E N D >----< E N D >----< E N D >----< E N D >----< E N D >----< E N D >---\r\n\r\n"
#define postSEPARATOR_4C     "---- 4 4 4 4 :   END ---------------------------------------------------------------------------------------------------------------\r\n\r\n"
#define postSEPARATOR_4B     "---- 4 4 4 4 :   BODY OUT TO CLIENT ------------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_4A "\r\n---- 4 4 4 4 :   HEADERS OUT TO CLIENT ---------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_3C     "---- 3 3 3 3 :   END ---------------------------------------------------------------------------------------------------------------\r\n\r\n"
#define postSEPARATOR_3B     "---- 3 3 3 3 :   BODY IN FROM SERVER -----------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_3A "\r\n---- 3 3 3 3 :   HEADERS IN FROM SERVER --------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_2C     "---- 2 2 2 2 :   END ---------------------------------------------------------------------------------------------------------------\r\n\r\n"
#define postSEPARATOR_2B     "---- 2 2 2 2 :   BODY OUT TO SERVER ------------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_2A "\r\n---- 2 2 2 2 :   HEADERS OUT TO SERVER ---------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_1C     "---- 1 1 1 1 :   END ---------------------------------------------------------------------------------------------------------------\r\n\r\n"
#define postSEPARATOR_1B     "---- 1 1 1 1 :   BODY IN FROM CLIENT -----------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_1A "\r\n---- 1 1 1 1 :   HEADERS IN FROM CLIENT --------------------------------------------------------------------------------------------\r\n"
#define postSEPARATOR_0  "\r\n-< B E G I N >< B E G I N >< B E G I N >< B E G I N >< B E G I N >< B E G I N >< B E G I N >< B E G I N >< B E G I N >< B E G I N >-\r\n\r\n"


/*1*/WAKEhIDE( "ifc.port.05.wiretap" )/*1*/
/**/
*/
  as of this writing, the only way to fire me is to hire me again or to reboot
 to stop recording, fire me
 as you use your browser, i will collect data
 press enter to make the wo'th request
 hire me on the tap host
 type in the url (but do not press enter) of the wo'th request that you want me to collect data for
 set your browser's proxy setting to point to the tap host and to use port 8000_9
 browser host: the host on which you will use your browser
 tap host: the host on which i am hired
instructions
i relay port 05 connections and collect data from the data stream
obsoleted by 2440104
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

