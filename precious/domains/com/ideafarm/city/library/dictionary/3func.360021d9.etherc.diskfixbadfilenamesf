
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#endif

}
    return cBadOrCapFound ;

    delF( tinBaseP , psttFolderMapped ) ;
    while( ~hFind && ( !etPrime || bIgnoreEtPrime ) ) ;
    }
        DEL( pInfo ) ;
        }
            }
                }
                    }
                        }
                            delF( tinBaseP , postOsLongNew  ) ;
                            delF( tinBaseP , postOsLongLike ) ;

                            }
                                while( ~hFind2 ) ;
                                }
                                    DEL( pInfo2 ) ;
                                    }
                                        }
                                            delF( tinBaseP , postLongNew ) ;
                                            delF( tinBaseP , postLongWas ) ;
                                            }
                                                if( POOP ) POOPR

                                                if( !bDone ) traceF( tinBaseP , T("could not rename file: ")+T(pInfo->postOsName) ) ;
                                                
                                                }
                                                    }
                                                        thirdC::c_strcatIF( tinBaseP , postLongNew , tSuffix ) ;
                                                        TN( tSuffix , "." ) ; tSuffix += TF3(++idDupLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;
                                                        postLongNew[ costLongNew ] = 0 ;
                                                        POOPR
                                                    {
                                                    else
                                                    }
                                                        break ;
                                                        bDone = 1 ;
                                                    {
                                                    if( !POOP )
                                                    thScratch.dosMoveF( tinBaseP , postLongNew , postLongWas , 1 ) ;
                                                {
                                                while( cTry -- )
                                                countT cTry = TUCK ;
                                                ZE( boolT , bDone ) ;
                                                ZE( countT , idDupLath ) ;

                                                thirdC& thScratch = *((tinNormalS&)tinBaseP).pEtScratch ;

                                                SCOOPS
                                            {
                                            IFsCRATCH

                                            // COLLISIONS ARE HANDLED BY UNIQUIFYING postLongNew BY APPENDING AN INTEGER
                                            // ONLY THE WOTH MATCHING FILE CAN BE RENAMED TO postLongNew

                                            const countT costLongNew = strMakeF( tinBaseP , LF , postLongNew , T(postOsLongNew) , 9 ) ; ___( postLongNew ) ; // EXTRA IS ALLOCATED TO ACCOMMODATE tSuffix
                                                                       strMakeF( tinBaseP , LF , postLongWas , T(pInfo2->postOsNameAlt?pInfo2->postOsNameAlt:pInfo2->postOsName) ) ; ___( postLongWas ) ;
                                            ZE( osTextT* , postLongNew ) ;
                                            ZE( osTextT* , postLongWas ) ;
                                        {
                                        if( bBadOrCapF( tinBaseP , pInfo2->postOsName ) )
                                    {
                                    if( pInfo2 )
                                    diskFindFileOrDirF( tinBaseP , pInfo2 , hFind2 , fnLike.pathF() , &pat ) ;
                                    ZE( infoFileS* , pInfo2 ) ;
                                {
                                do
                                handleC hFind2( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                
                                patternC pat( tinBaseP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                                fileNameC fnLike( tinBaseP , *this , T(ifFileNameC(tinBaseP,third,postOsLongLike)) ) ;

                            {                
                            traceF( tinBaseP , T(" [new]: ")+T(postOsLongNew)     ) ;
                            traceF( tinBaseP , T("[like]: ")+T(postOsLongLike)    ) ;
                            traceF( tinBaseP , T(" [bad]: ")+T(pInfo->postOsName) ) ;

                            }
                                }
                                    postOsLongNew[  offr ] = '.' ;
                                    postOsLongLike[ offr ] = '?' ;
                                {
                                else if( bBad )
                                if( bCap ) postOsLongNew[ offr ] = (osTextT)( postOsLongNew[ offr ] + 'a' - 'A' ) ;

                                }
                                    }
                                        break ;
                                        bBad = 1 ;
                                    {
                                    BADcASEScHARiNfILEnAME
                                    //CS:CODEsYNC: 360021d9 360021d9
                                {
                                else switch( postOsLongLike[ offr ] )
                                else if( 0x20 > postOsLongLike[ offr ] || postOsLongLike[ offr ] > 0x7f ) bBad = 1 ;
                                     if( 'A' <= postOsLongLike[ offr ] && postOsLongLike[ offr ] <= 'Z' ) bCap = 1 ;
                                ZE( boolT , bCap ) ;
                                ZE( boolT , bBad ) ;
                            {
                            for( ; postOsLongLike[ offr ] ; offr ++ )
                            countT offr = offShort ;

                            thirdC::c_strcpyIF( tinBaseP , postOsLongNew  , pInfo->postOsName ) ;
                            thirdC::c_strcpyIF( tinBaseP , postOsLongLike , pInfo->postOsName ) ;
                            }
                                newF( tinBaseP , LF , postOsLongNew  , costa ) ; ___( postOsLongNew  ) ;
                                newF( tinBaseP , LF , postOsLongLike , costa ) ; ___( postOsLongLike ) ;
                                countT costa = thirdC::c_strlenIF( tinBaseP , pInfo->postOsName ) + 1 ;
                            {
                        {
                        ZE( osTextT* , postOsLongNew  ) ; // MADE FROM INVALID FILE NAME, WITH INVALID CHARACTERS REPLACED WITH '.'
                        ZE( osTextT* , postOsLongLike ) ; // MADE FROM INVALID FILE NAME, WITH INVALID CHARACTERS REPLACED WITH '?'

                        //20150204@1508: UPPER CASE CHARACTERS ARE "PSEUDO-BAD" IN THAT AS POLICY THEY ARE CONVERTED TO LOWER CASE

                        traceF( tinBaseP , T("invalid character found in file name.  repairing...") ) ;
                        cBadOrCapFound ++ ;
                    {
                    if( bBadOrCapF( tinBaseP , postOsShort ) )

                    countT offShort = postOsShort - pInfo->postOsName ;
                    postOsShort ++ ;
                {
                if( postOsShort )
                const osTextT* postOsShort = thirdC::c_strrchrIF( tinBaseP , pInfo->postOsName , '\\' ) ;
            {
            else if( !( F(flagsP) & flETHERfIXnAMES_FOLDERSoNLY ) )
            }
                if( F(flagsP) & flETHERfIXnAMES_RECURSE && !strIdF( tinBaseP , tSDS , pInfo->psttIfoName ) && !strIdF( tinBaseP , tSDDS , pInfo->psttIfoName ) ) cBadOrCapFound += disk FixBadFileNamesF( tinBaseP , pInfo->psttIfoName , flagsP ) ;
            {
            if( pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' )
        {
        if( pInfo && pInfo->psttIfoName )
        diskFindFileOrDirF( tinBaseP , pInfo , hFind , T(psttFolderMapped) ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    TN( tOsLikePath , osFileNameC( tinBaseP , third , T(psttFolderMapped) ) ) ;
    TN( tSDDS , "/../" ) ;
    TN( tSDS , "/./" ) ;

    //THE JOB IS DONE FOR THE CURRENT FOLDER, EXCEPT FOR RECURSION

    if( !( F(flagsP) & flETHERfIXnAMES_SYSTEMpREwASH ) ) cBadOrCapFound = disk FixBadFileNamesF( tinBaseP , psttFolderMapped , ( flagsP & ~( F(flETHERfIXnAMES_RECURSE) ) ) | flETHERfIXnAMES_FOLDERSoNLY | flETHERfIXnAMES_SYSTEMpREwASH ) ; // THIS CLEANS UP THE DIRECTORY NAMES THAT MUST BE CLEAN WHEN I RECURSE INTO THEM
    ZE( countT , cBadOrCapFound ) ;

    diskMapFileNameF( tinBaseP , psttFolderMapped , psttFolderP ) ; ___( psttFolderMapped ) ;
    ZE( strokeS* , psttFolderMapped ) ;

    etherC& etPrime = etPrimeIF( tinBaseP ) ;
    const boolT bIgnoreEtPrime = F(flagsP) & flETHERfIXnAMES_KEEPwORKINGiFfIRED ;

    _IO_

    }
        if( POOP ) return 0 ;
        FV(flETHERfIXnAMES,flagsP) ;
        __Z( psttFolderP[ CSpREFIX - 1 + psttFolderP->idAdam ].idAdam == '/' ) ;
        if( POOP ) return 0 ;
        __Z( psttFolderP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/countT etherC::disk FixBadFileNamesF( tinBaseS& tinBaseP , const strokeS* const psttFolderP , const flagsT flagsP )/*1*/

#if defined( NEVERdEFINED )
//20170413@1406: THIS IS OBSOLETE NOW THAT FILESETS ARE USED FOR CLOUD ARCHIVAL; DISABLING THIS TO ENSURE THAT IT IS NOT USED TO MODIFY FILE NAMES; IT WORKS BUT SHOULD REMAIN DISABLED UNLESS A NEW NEED ARISES

}
    return bBadOrCap ;

    }
        }
            }
                break ;
                bBadOrCap = 1 ;
            {
            BADcASEScHARiNfILEnAME\
        {
        else switch( *postP )
        }
            break ;
            bBadOrCap = 1 ;
        {
        )
            ( 'A' <= *postP && *postP <= 'Z' )
            ||
            *postP > 0x7f
            ||
            *postP < 0x20
        (
        if
    {
    for( ; *postP ; postP ++ )
    ZE( boolT , bBadOrCap ) ;
{
boolT bBadOrCapF( tinBaseS& tinBaseP , const osTextT* postP )

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

