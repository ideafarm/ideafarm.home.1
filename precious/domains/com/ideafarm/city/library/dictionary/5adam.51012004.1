
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        sThrow.writeF( tinBaseP , idPortCatch , socketC::nicNameIF( tinBaseP , etThread , T("2600:381:9f04:ed6e:58a8:5006:7e65:73fb") ) , postSay , sizeof postSay - 1 ) ;
        //G:sThrow.writeF( tinBaseP , idPortCatch , socketC::nicNameIF( tinBaseP , etThread , T("2600:381:9f04:ed6e:58a8:5006:7e65:73fb") ) , postSay , sizeof postSay - 1 ) ;
        //G:sThrow.writeF( tinBaseP , idPortCatch , socketC::nicNameIF( tinBaseP , etThread , T("192.168.192.136") ) , postSay , sizeof postSay - 1 ) ;
        //B:sThrow.writeF( tinBaseP , idPortCatch , socketC::nicNameIF( tinBaseP , etThread , T("10.1.1.1") ) , postSay , sizeof postSay - 1 ) ;
        etThread.traceF( tinBaseP , T("++++") ) ;
    {
    if( idPortCatch )
    ++ s ; ether.osSleepF( tinBaseP , TOCK >> 4 ) ;
{
while( !ether )
sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

osTextT postSay[] = "Thank you, Jesus!" ;

etThread.osThreadF( TaRG1( tmCatchF ) ) ;
sThrow.bindF( tinBaseP ) ;
socketC sThrow( tinBaseP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

TODO

DONE( tmCatchF )
}
    }
        etThread.delF( tinBaseP , pbi ) ;
        etThread.traceF( tinBaseP , T(nicNameHe)+tb4+TF2(idPortHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(pbi) ) ;
        sCatch.readF( tinBaseP , pbi , cbi , idPortHe , nicNameHe ) ; ___( pbi ) ;
        nicNameC nicNameHe ;
        ZE( countT , idPortHe ) ;
        ZE( countT , cbi ) ;
        ZE( byteT* , pbi ) ;
    {
    while( !ether && !etThread )

    TN( tb4 , "    " ) ;

    etThread.traceF( tinBaseP , T("[idPortCatch]:    ")+TF4(idPortCatch,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;

    idPortCatch = sCatch.bindF( tinBaseP , 80 ) ;
    socketC sCatch( tinBaseP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
{
if( pTaskP )
TASK( tmCatchF )

countT idPortCatch ;

/*1*/WAKEsHOWtEXT( "doodle.secure.udp.handshake" )/*1*/
/**/
*/
 "identity" simply refers to a socket, not to any identification or validation of an IPDOS (tm) home
 any oo IPDOS (tm) homes can establish a udp "connection", even if wo is rogue
 the goal is to quickly detect rogue incoming packets and ignore them
secure udp refers to peer identity verification, not to whether payload is hushed
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

