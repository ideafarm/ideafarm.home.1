
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tin0P , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    etThread.delF( tin0P , pbd ) ;
    byteT* pbd = (byteT*)cpbd ;
    stStringsOfBytesToDelete >> cpbd ;
    ZE( countT , cpbd ) ;
{
while( stStringsOfBytesToDelete )

}
    DEL( ptbld ) ;
    tableC* ptbld = (tableC*)cptbld ;
    stTablesToDelete >> cptbld ;
    ZE( countT , cptbld ) ;
{
while( stTablesToDelete )

}
    DEL( pstd ) ;
    stackC* pstd = (stackC*)cpstd ;
    stStacksToDelete >> cpstd ;
    ZE( countT , cpstd ) ;
{
while( stStacksToDelete )

reportF( tin0P , etThread , bLever , lever , swNickname , swExtEmail ) ;

loadDataF( tin0P , etThread , stStringsOfBytesToDelete , stTablesToDelete , stStacksToDelete , tNickname , tExtEmail , bLever , lever , swNickname , swExtEmail ) ;
TN( tExtEmail   , "///ideafarm/ephemeral/city/data/base/be30104.extEmail"   ) ;
TN( tNickname   , "///ideafarm/ephemeral/city/data/base/be30104.nickname"   ) ;

stackC stStacksToDelete( tin0P , etThread , TAG( TAGiDnULL ) ) ;
stackC stTablesToDelete( tin0P , etThread , TAG( TAGiDnULL ) ) ;
stackC stStringsOfBytesToDelete( tin0P , etThread , TAG( TAGiDnULL ) ) ;

switchC      swExtEmail( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever ) ;
switchC      swNickname( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever ) ;
batonC       bLever( tin0P , TAG( TAGiDnULL ) ) ;
ZE( countT , lever ) ;

TODO

}
    bLeverP.ungrabF( tin0P ) ;

    }
        !tbl ;

        }
            }
                tbl.newObjectF( tin0P , psttn ) ;
                tbl.newObjectF( tin0P , leverP ) ;
                tbl.newEventF( tin0P ) ;
            {
            if( psttn )
            strokeS* psttn = (strokeS*)(countT)swExtEmailP ;
            leverP = swExtEmailP.leverF( tin0P , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )

        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tableC tbl( tin0P , etThread ) ;

        const countT cLevers = swExtEmailP.cFlavorsF( tin0P ) ;
    {

    }
        !tbl ;

        }
            }
                tbl.newObjectF( tin0P , psttn ) ;
                tbl.newObjectF( tin0P , leverP ) ;
                tbl.newEventF( tin0P ) ;
            {
            if( psttn )
            strokeS* psttn = (strokeS*)(countT)swNicknameP ;
            leverP = swNicknameP.leverF( tin0P , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )

        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tableC tbl( tin0P , etThread ) ;

        const countT cLevers = swNicknameP.cFlavorsF( tin0P ) ;
    {

    bLeverP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
{
voidT reportF( tin0S& tin0P , etherC& etThread , batonC& bLeverP , countT& leverP , switchC& swNicknameP , switchC& swExtEmailP )

}
    bLeverP.ungrabF( tin0P ) ;

    }
        }
            swExtEmailP = (countT)tbl._CT1_07F( idr , 2 ) ;
            leverP   =            tbl._CT1_04F( idr , 1 ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tin0P ) ;

        tbl.readF( tin0P , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttExtEmailP ) ;
        tableC tbl( tin0P , etThread ) ;
    {
    if( etThread.diskFileExistsF( tin0P , psttExtEmailP ) )

    }
        }
            swNicknameP = (countT)tbl._CT1_07F( idr , 2 ) ;
            leverP   =            tbl._CT1_04F( idr , 1 ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tin0P ) ;

        tbl.readF( tin0P , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttNicknameP ) ;
        tableC tbl( tin0P , etThread ) ;
    {
    if( etThread.diskFileExistsF( tin0P , psttNicknameP ) )

    bLeverP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
{
voidT loadDataF( tin0S& tin0P , etherC& etThread , stackC& stStringsOfBytesToDeleteP , stackC& stTablesToDeleteP , stackC& stStacksToDeleteP , const strokeS* const psttNicknameP , const strokeS* const psttExtEmailP , batonC& bLeverP , countT& leverP , switchC& swNicknameP  , switchC& swExtEmailP )

/*1*/WAKEhIDE( "listCitizens" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

