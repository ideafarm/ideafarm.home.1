
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinBaseP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    etThread.delF( tinBaseP , pbd ) ;
    byteT* pbd = (byteT*)cpbd ;
    stStringsOfBytesToDelete >> cpbd ;
    ZE( countT , cpbd ) ;
{
while( stStringsOfBytesToDelete )

}
    DEL( ptbld ) ;
    tableC* ptbld = (tableC*)cptbld ;
    stTablesToDelete >> cptbld ;
    ZE( countT , cptbld ) ;
{
while( stTablesToDelete )

}
    DEL( pstd ) ;
    stackC* pstd = (stackC*)cpstd ;
    stStacksToDelete >> cpstd ;
    ZE( countT , cpstd ) ;
{
while( stStacksToDelete )

reportF( tinBaseP , etThread , bLever , lever , swNickname , swExtEmail ) ;

loadDataF( tinBaseP , etThread , stStringsOfBytesToDelete , stTablesToDelete , stStacksToDelete , tNickname , tExtEmail , bLever , lever , swNickname , swExtEmail ) ;
TN( tExtEmail   , "///ideafarm/ephemeral/domains/com/ideafarm/city/data/base/be30104.extEmail"   ) ;
TN( tNickname   , "///ideafarm/ephemeral/domains/com/ideafarm/city/data/base/be30104.nickname"   ) ;

stackC stStacksToDelete( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
stackC stTablesToDelete( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
stackC stStringsOfBytesToDelete( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;

switchC      swExtEmail( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever ) ;
switchC      swNickname( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever ) ;
batonC       bLever( tinBaseP , TAG( TAGiDnULL ) ) ;
ZE( countT , lever ) ;

TODO

}
    bLeverP.ungrabF( tinBaseP ) ;

    }
        !tbl ;

        }
            }
                tbl.newObjectF( tinBaseP , psttn ) ;
                tbl.newObjectF( tinBaseP , leverP ) ;
                tbl.newEventF( tinBaseP ) ;
            {
            if( psttn )
            strokeS* psttn = (strokeS*)(countT)swExtEmailP ;
            leverP = swExtEmailP.leverF( tinBaseP , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )

        tbl.newColF( tinBaseP ) ;
        tbl.newColF( tinBaseP ) ;
        tableC tbl( tinBaseP , etThread ) ;

        const countT cLevers = swExtEmailP.cFlavorsF( tinBaseP ) ;
    {

    }
        !tbl ;

        }
            }
                tbl.newObjectF( tinBaseP , psttn ) ;
                tbl.newObjectF( tinBaseP , leverP ) ;
                tbl.newEventF( tinBaseP ) ;
            {
            if( psttn )
            strokeS* psttn = (strokeS*)(countT)swNicknameP ;
            leverP = swNicknameP.leverF( tinBaseP , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )

        tbl.newColF( tinBaseP ) ;
        tbl.newColF( tinBaseP ) ;
        tableC tbl( tinBaseP , etThread ) ;

        const countT cLevers = swNicknameP.cFlavorsF( tinBaseP ) ;
    {

    bLeverP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
{
voidT reportF( tin0S& tinBaseP , etherC& etThread , batonC& bLeverP , countT& leverP , switchC& swNicknameP , switchC& swExtEmailP )

}
    bLeverP.ungrabF( tinBaseP ) ;

    }
        }
            swExtEmailP = (countT)tbl._CT1_07F( idr , 2 ) ;
            leverP   =            tbl._CT1_04F( idr , 1 ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tinBaseP ) ;

        tbl.readF( tinBaseP , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttExtEmailP ) ;
        tableC tbl( tinBaseP , etThread ) ;
    {
    if( etThread.diskFileExistsF( tinBaseP , psttExtEmailP ) )

    }
        }
            swNicknameP = (countT)tbl._CT1_07F( idr , 2 ) ;
            leverP   =            tbl._CT1_04F( idr , 1 ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tinBaseP ) ;

        tbl.readF( tinBaseP , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttNicknameP ) ;
        tableC tbl( tinBaseP , etThread ) ;
    {
    if( etThread.diskFileExistsF( tinBaseP , psttNicknameP ) )

    bLeverP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
{
voidT loadDataF( tin0S& tinBaseP , etherC& etThread , stackC& stStringsOfBytesToDeleteP , stackC& stTablesToDeleteP , stackC& stStacksToDeleteP , const strokeS* const psttNicknameP , const strokeS* const psttExtEmailP , batonC& bLeverP , countT& leverP , switchC& swNicknameP  , switchC& swExtEmailP )

/*1*/WAKEhIDE( "listCitizens" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

