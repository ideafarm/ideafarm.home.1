
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;

//BOSpOOP
//BOS( WHATgbo , BOSoK , TextOut( oshdc , 0x100 , 0x100 , bOk ? "done" : "fail" , 4 ) )

// #endif
// 
//     #endif
//     
//         #endif
//             LOGrAW9( "SMALL SIMPLE  [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;
//         #else
//             LOGrAW9( "SMALL COMPLEX [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;
//         #if defined( COMPLEX )
//     
//     #else
//     
//         #endif
//             LOGrAW9( "BIG   SIMPLE  [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;
//         #else
//             LOGrAW9( "BIG   COMPLEX [cSize,cLines,timeE1,cLines/timeE1]: " , cSize , " " , cLines , " " , timeE1 , " " , (measureT)cLines / (measureT)timeE1 , "\r\n" ) ;
//         #if defined( COMPLEX )
//     
//     #if defined( BIG )
//     
//     const countT cLines = ( cSize - 1 ) * cGlyph ;
// 
// #if defined( NEVERdEFINED )
// 
// ((tin9S&)tin0P).pEther->osTimeSubtractF( tin0P , timeE1 , timeE2 , timeS1 , timeS2 ) ;
// ((tin9S&)tin0P).pEther->osTimeNowF( tin0P , timeE1 , timeE2 ) ;
// ZE( sCountT , timeE2 ) ;
// ZE( countT , timeE1 ) ;
// 
// //bOk = ((tin9S&)tin0P).brcRaw ;
// //BOSpOOP
// //BOS( WHATgbo , BOSoK , PolyPolyline( oshdc , ppt , (DWORD*)pcSize , 1 ) )
// bOk = ((tin9S&)tin0P).brcRaw ;
//BOSpOOP
//BOS( WHATgbo , BOSoK , Polyline( oshdc , ppt , 5 ) )

OSsLEEPf( 1000 * 8 ) ;

BOSpOOP
BOS( WHATgbo , BOSoK , TextOut( oshdc , 0x40 , 0x40 , "test" , 4 ) )

LOGrAW3( "003 drawing directly to window [oshdc]: " , oshdc , "\r\n" ) ; //U::TO FIND A BUG

//BOSpOOP
//BOS( WHATgbo , BOSoK , Rectangle( oshdc , rectClient.left , rectClient.top , rectClient.right , rectClient.bottom ) )

BOSpOOP
BOS( WHATgbo , BOSoK , SetROP2( oshdc , R2_XORPEN ) )

BOSdOnOTtEST( WHATgbo , SelectObject( oshdc , oshp ) )
BOSdOnOTtEST( WHATgbo , SelectObject( oshdc , oshb ) )

ZE( boolT , bOk ) ;

HPEN   oshp = (HPEN)((tin9S&)tin0P).brcRaw ;
BOSpOOP
BOS( WHATgbo , BOSoK , CreatePen( PS_SOLID , 1 , 0xffffff ) )
HBRUSH oshb = (HBRUSH)((tin9S&)tin0P).brcRaw ;
BOSpOOP
BOS( WHATgbo , BOSoK , CreateSolidBrush( 0 ) )

}
    }
        case 3 : { ppt[ offp ] = p01 ; break ; }
        case 2 : { ppt[ offp ] = p11 ; break ; }
        case 1 : { ppt[ offp ] = p10 ; break ; }

        }
            break ;

            ppt[ offp ] = p00 ;

            p01.x -= 2 ; p01.y += 2 ;
            p11.x += 2 ; p11.y += 2 ;
            p10.x += 2 ; p10.y -= 2 ;
            p00.x -= 2 ; p00.y -= 2 ;
        {
        case 0 :
    {
    switch( offp % 4 )
{
for( countT offp = 0 ; offp < MAXpOINTS ; offp ++ )

POINT p11 = p00 ;
POINT p01 = p00 ;
POINT p10 = p00 ;
POINT p00 = { rectClient.right - rectClient.left , rectClient.bottom - rectClient.top } ;

((tin9S&)tin0P).pEther->osTimeNowF( tin0P , timeS1 , timeS2 ) ;
ZE( sCountT , timeS2 ) ;
ZE( countT , timeS1 ) ;

}
    }
        pRootI->letRefF() ;
        BOSpOOP
        BOS( WHATgbo , BOSoK , GetClientRect( (HWND)((const handleC&)*pRootI).osF( ifcIDtYPEhANDLE_WINDOW ) , &rectClient ) )
        oshdc = (HDC)hDraw.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) ;
        handleC& hDraw = pRootI->hDrawWindowF() ;
    {
    if( pRootI )
    windowOldC* pRootI = windowOldC::getRefIF( tin0P ) ;
{
RECT  rectClient ;
ZE( HDC , oshdc ) ;

etThread.strokeF( tin0P , T("")+S2(0,scOld_WRAPoFF)+T(" Hello, Jesus!\r\n") ) ;

TODO

countT pcSize[ 1 ] = { MAXpOINTS } ;
POINT ppt[ MAXpOINTS ] ;

//#define MAXpOINTS 5120000
#define MAXpOINTS 16

//#define COMPLEX
//#define BIG

/*1*/WAKEsHOW( "abandoned.tool.benchmark.glyph.drawing.speed.with.transforms" )/*1*/
/**/
*/
 | 
 | BIG   COMPLEX [cSize,cLines,timeE1,cLines/timeE1]: 001 0e1dd4 a477d 5
 | BIG   SIMPLE  [cSize,cLines,timeE1,cLines/timeE1]: 01 00e394 eb2ec 5
 | SMALL COMPLEX [cSize,cLines,timeE1,cLines/timeE1]: 001 0e1dd4 aa154 21
 | SMALL SIMPLE  [cSize,cLines,timeE1,cLines/timeE1]: 01 00e394 b5d24 11
 | 
output
when the lines are long, they take 3x time to draw
i use "raw" win32 calls, and can draw 11 (17_9) short lines per time (per 1/50,000 sec)
i have oo modes, selected by defining or leaving undefined BIG COMPLEX
i can be used to measure the speed of drawing lines in a glyph
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

