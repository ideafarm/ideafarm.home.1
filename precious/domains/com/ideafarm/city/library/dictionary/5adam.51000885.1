
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

}
    }
        }
                                                  oshSocket = 0 ;
            hDoomed.osF( ifcIDtYPEhANDLE_SOCKET , oshSocket ) ;
            handleC hDoomed( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_SOCKET ) ;

            countT& oshSocket = pFifo[ offSlot ].oshSocket ;
            countT  offSlot = offi % CsLOTS ;
        {
        for( countT offi = cFifoPulled ; offi < cFifoPushed ; offi ++ )    // CLOSE THE OS HANDLES THAT REMAIN IN THE CIRCULAR FIFO BUFFER ; THINK OF THIS LOOP AS PULLING THE SLOTS THAT HAVE BEEN PUSHED BUT NOT YET PULLED
    {
    if( cFifoPushed > cFifoPulled )

    sDone.waitF( tin0P ) ;
    }
        }
            DEL( pso ) ;
            }
                }
                    etThread.traceF( tin0P , T("!exception / writeF failed [POOP]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                {
                if( POOP )
                pso->writeF( tin0P , (byteT*)&vvLathOut , sizeof vvLathOut ) ;
                vvLathOut ++ ;
            {
            else
            }
                etThread.traceF( tin0P , T("!exception / acceptF failed [POOP]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )
            __Z( pso ) ;
            sockServer.acceptF( tin0P , pso , idPortPeer , nnPeer , countTC() , &pp ) ; ___( pso ) ;
            ZE( socketC* , pso ) ;
        {
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
    {
    while( !ether )
    ZE( countT , vvLathOut ) ;

    etThread.osThreadF( TaRG2sGNdONE( tmConnectionAcceptorF , sDone ) , (countT)&(const boolT&)ether , (countT)&pp ) ;
    signC sDone( tin0P , TAG( TAGiDnULL ) ) ;

    s_acceptF_parametersS pp( cFifoPushed , pFifo , CsLOTS , cFifoPulled , sockServer.handleF( tin0P ) ) ;

    while( cDo -- ) etThread.osThreadF( TaRG2cBsTACK( tmPullNumbersF , CBsTACKmIN << 1 ) , idPort ) ;
    countT cDo = TUCK >> 4 ;

    etThread.osThreadF( TaRG2cBsTACK( tmQuitF , CBsTACKmIN << 1 ) , idPort ) ;

    sockServer.listenF( tin0P ) ;
    countT idPort = sockServer.bindF( tin0P ) ;
    socketC sockServer( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;

    SCOOPS
{
IFsCRATCHoK

TODO

oshSocketAcceptedS pFifo[ CsLOTS ] ;

countT             cFifoPulled ;
countT             cFifoPushed ;

#define CsLOTS ( TUCK )

DONE( tmQuitF )
}
    }
        }
            etThread.traceF( tin0P , T("!exception / connectF failed [POOP]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            POOPRqUIET
            countT rc = POOP ;
        {
        if( POOP )
        sock.connectF( tin0P , idPortP , ((tin1S&)tin0P).pEtScratch->sockNicNameF( tin0P ) ) ;
        socketC sock( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_DOnOTrEGISTERqUITTER ) ;

        SCOOPS
    {
    IFsCRATCHoK
    etherC::loafIF( tin0P ) ;

    countT idPortP = pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmQuitF )

DONE( tmPullNumbersF )
}
    }
        }
            }
                etThread.traceF( tin0P , T("!exception / connectF failed [POOP]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )
            sock.readF( tin0P , (byteT*)&vvIn , sizeof vvIn ) ;
            sock.connectF( tin0P , idPortP , ((tin1S&)tin0P).pEtScratch->sockNicNameF( tin0P ) ) ;
            socketC sock( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;

            SCOOPS
        {
        IFsCRATCHoK
        etThread.traceF( tin0P , T("received [vvIn]:    ")+TF2(vvIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( !ether )
    ZE( countT , vvIn ) ;

    countT idPortP = pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmPullNumbersF )

//BASELINE: adam 01a_

/*1*/WAKEhIDE( "example.simplest.communication.using.a.socket.with.burst.connection.support" )/*1*/
/**/
*/
 this overload accepts from the listening socket and pushes accepted socket handles to the circular fifo buffer
 the application code is responsible for launching a thread that calls a particular overload of thirdC::s_socketF()
 instead,the system code pulls from a circular fifo buffer that the application code provides and pushes to
 when this parameter is specified, system code does not actually call accept()
 all of the socket accept api's (thirdC etherC socketC) take an optional parameeter
i demonstrate asynchronous socket accept, which handles bursts of client connections
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

