
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    while( !ether && ~hFind1 && !POOP ) ;
    }
        DEL( pInfo1 ) ;
        }
            }
                //etThread.traceF( tin0P , T("0") ) ;
                }
                    //etThread.traceF( tin0P , T("1") ) ;
                    }
                        while( !ether && ~hFind2 && !POOP ) ;
                        }
                            //etThread.traceF( tin0P , T("2") ) ;
                            DEL( pInfo2 ) ;
                            }
                                }
                                    //etThread.traceF( tin0P , T("3") ) ;
                                    etThread.boxZapF( tin0P , tIfoName2 ) ;
                                    //etThread.traceF( tin0P , T("4") ) ;
                                {
                                if( !bDir )

                                const boolT bDir = pInfo2->psttIfoName[ CSpREFIX - 1 + pInfo2->psttIfoName->idAdam ].idAdam == '/' ;

                                TN( tIfoName2 , pInfo2->psttIfoName ) ;

                                ++ cMeta ;
                            {
                            else
                            }
                                break ;
                                if( !cMeta ) etThread.traceF( tin0P , T("no meta files found for: ")+tIfoName1 ) ;
                                DEL( pInfo2 ) ;
                            {
                            if( !pInfo2 || !pInfo2->psttIfoName )

                            etThread.diskFindFileOrDirF( tin0P , pInfo2 , hFind2 , tPath , &pat2 ) ;
                            ZE( infoFileS* , pInfo2 ) ;
                            //etThread.traceF( tin0P , T("5") ) ;
                        {
                        do
                        handleC hFind2( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                        ZE( countT , cMeta ) ;

                        patternC pat2( tin0P , etThread , tShorter+tDotMetaDotStar , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;

                        //etThread.traceF( tin0P , T("6") ) ;
                        etThread.diskMoveFileOrDirF( tin0P , tToFolder+tName+tSuffix , tIfoName1 ) ;
                        //etThread.traceF( tin0P , T("7") ) ;
                        //etThread.traceF( tin0P , tName ) ;

                        }
                            tSuffix = tDot+TF2(++idSuffix,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;
                        {
                        while( etThread.diskFileExistsF( tin0P , tToFolder+tName+tSuffix ) )
                        TN( tSuffix , "" ) ;
                        ZE( countT , idSuffix ) ;
                    {
                    else
                    if( !tName.csF( tin0P ) ) etThread.traceF( tin0P , T("null currentname: ")+tIfoName1 ) ;
                    //etThread.traceF( tin0P , T("8") ) ;

                    }
                        etThread.delF( tin0P , posti ) ;
                        else       tName = T(posti) ;
                        if( POOP ) { POOPR }
                        //etThread.traceF( tin0P , T("9") ) ;
                        ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , tLongFileCurrentname , 1 ) ; ___( posti ) ;
                        //etThread.traceF( tin0P , T("a") ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;

                        SCOOPS
                    {
                    IFsCRATCHoK
                    TN( tName , "" ) ;
                    //etThread.traceF( tin0P , T("b") ) ;

                    TN( tLongFileCurrentname , "" ) ; tLongFileCurrentname = tPath + tShorter + tDotMetaCurrentname ;

                    }
                        etThread.delF( tin0P , psttShorter ) ;
                        tShorter = T(psttShorter) ;
                        etThread.delF( tin0P , psttnu ) ;
                        etThread.strBisectF( tin0P , psttShorter , psttnu , tShort , tDot , - 2 ) ; ___( psttShorter ) ; ___( psttnu ) ;
                        ZE( strokeS* , psttnu ) ;
                        ZE( strokeS* , psttShorter ) ;
                    {
                    TN( tShorter , "" ) ;

                    }
                        etThread.delF( tin0P , psttShort ) ;
                        etThread.delF( tin0P , psttPath ) ;
                        tShort = T(psttShort) ;
                        tPath  = T(psttPath) ;
                        etThread.strBisectF( tin0P , psttPath , psttShort , pInfo1->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttPath ) ;
                    {
                    TN( tShort , "" ) ;
                    TN( tPath , "" ) ;
                    //etThread.traceF( tin0P , T("c") ) ;
                {
                if( !bDir )

                const boolT bDir = pInfo1->psttIfoName[ CSpREFIX - 1 + pInfo1->psttIfoName->idAdam ].idAdam == '/' ;

                //etThread.traceF( tin0P , tIfoName1 ) ;
                TN( tIfoName1 , pInfo1->psttIfoName ) ;
            {
            if( 1 == etThread.strIdOptimizedClosureF( tin0P , 0 , flSTRmATCH_null , countTC( 1 ) , sttq , patternC( tin0P , etThread , T("*.data.*") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) , pInfo1->psttIfoName ) )
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        {
        else
        }
            break ;
            DEL( pInfo1 ) ;
        {
        if( !pInfo1 || !pInfo1->psttIfoName )

        etThread.diskFindFileOrDirF( tin0P , pInfo1 , hFind1 , tPath1 ) ;
        ZE( infoFileS* , pInfo1 ) ;
    {
    do
    handleC hFind1( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

    TN( tToFolder , "///d/tmp/unarchive.to1/" ) ;
    //TN( tToFolder , "///d/tmp/unarchived/" ) ;
    //TN( tToFolder , "///d/tmp/desk/extracted.from.archive/" ) ;
    TN( tDotMetaDotStar     , ".meta.*" ) ;
    TN( tDotMetaCurrentname , ".meta.currentname" ) ;
    TN( tb4 , "    " ) ;
    TN( tDot , "." ) ;
    TN( tSlash , "/" ) ;
    TN( tPath1 , "" ) ; tPath1 = T("///d/tmp/unarchive.from1/") ;
    //TN( tPath1 , "" ) ; tPath1 = T("///d/tmp/unarchive/") ;
    //TN( tPath1 , "" ) ; tPath1 = T("///d/tmp/desk/20191112@0952.archive.20190121.caltrain.incident/*") ;
{

TODO

/*1*/WAKEhIDE( "tool.extract.from.archive" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
