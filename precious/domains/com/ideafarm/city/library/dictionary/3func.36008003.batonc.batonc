
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
        //20240823@1556: SUPPRESSED THIS SO CAN SUPPORT flSIGNc_FAILiFnAPKINnOTeXIST flBATONc_FAILiFnAPKINnOTeXIST :  if( POOP ) BLAMMO ;

        }
            }
                pGrabA->grabNotes.cDetach = 0 ;
                pGrabA->grabNotes.cAttach = 0 ;
                pGrabA->grabNotes.flags   = bIsSign ? flGRABnOTES_CTaSsIGNc : flGRABnOTES_CTaSbATONc ;
                pGrabA->grabNotes.idCt    = grabNotesS::idNextF( tinBaseP ) ;
                pGrabA->grabNotes.osPidCt = osPidIF( tinBaseP ) ;
                pGrabA->grabNotes.osTidCt = osTidIF() ;
    
                pGrabA->formatF( tinBaseP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , flagsGrab , idGrabLayerP ) ;
            {
            if( F(pGrabA->flagsF()) & flGRABc_DISABLED )
            pGrabA = &grabA ;
        {
        if( F(pGrabA->flagsF()) & flGRABc_DISABLED )

        }
            countT foo = 2 ;
            BLAMMO ;
        {
        if( F(pGrabA->flagsF()) & flGRABc_DISABLED && pGrabA != &grabA )
        //U::REWRITE THIS UGLYASS DEFINITION!
    
        }
            pGrabA->grabNotes.cDetach = 0 ;
            pGrabA->grabNotes.cAttach = 0 ;
            pGrabA->grabNotes.flags   = bIsSign ? flGRABnOTES_CTaSsIGNc : flGRABnOTES_CTaSbATONc ;
            pGrabA->grabNotes.idCt    = grabNotesS::idNextF( tinBaseP ) ;
            pGrabA->grabNotes.osPidCt = osPidIF( tinBaseP ) ;
            pGrabA->grabNotes.osTidCt = osTidIF() ;
    
            else                    grabA.formatF( tinBaseP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , flagsGrab , idGrabLayerP ) ;
            if( pGrabInPoolOrHeap ) pGrabA = pGrabInPoolOrHeap ;
    
            }
                pGrabInPoolOrHeap = new( 0 , tinBaseP , pbGrabInHeap , cba ) grabAnnotatedS( tinBaseP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , flagsGrab , idGrabLayerP ) ;
                if( !pbGrabInHeap ) { BLAMMO ; }
                byteT* pbGrabInHeap = processGlobal4I.heap.newF( tinBaseP , LF , cba ) ;
                countT cba = sizeof( grabAnnotatedS ) ;
            {
            else
            if( ((tin9S&)tinBaseP).pag1->pPoolAdamTemp ) { pGrabInPoolOrHeap = new( 0 , tinBaseP , LF ) grabAnnotatedS( tinBaseP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , flagsGrab , idGrabLayerP ) ; ___( pGrabInPoolOrHeap ) ; }
            ZE( grabAnnotatedS* , pGrabInPoolOrHeap ) ;
        {
        else
        }
            if( bResetPendingFlag ) pGrabA->grabNotes.flags &= ~( F(flGRABnOTES_FORMATTINGiSrEALLYsTILLpENDING) ) ;

            if( F(flagsGrab) & flGRABc_GRABBED /*&& !bIsSign*/ ) pGrabA->grabF( tinBaseP , idLineCtP , idiFileCtP , pbBitsCtP ) ; // ASSUME: THE CALLING CODE WILL UNGRAB ME ; 20240823@2100: DO IT WITHOUT REGARD TO bIsSign

            }
                }
                    ++ s ; thirdC::dosSleepRawIF( tinBaseP , TOCK >> 3 ) ;
                {
                while( F(pGrabA->grabNotes.flags) & flGRABnOTES_FORMATTINGiSrEALLYsTILLpENDING )    //DON'T CONTINUE UNTIL THE CREATOR HAS REALLY FINISHED FORMATTING, MEANING THAT IT HAS CALLED grabF ; CALLING grabF CANNNOT BE DONE WHILE THE MEMORY SPACE IS GRABBED BECAUSE THAT WOULD BE A NONMONOTONIC GRAB
                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

                if( !( F(pNapkin->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYoPEN ) ) pGrabA->grabNotes.cAttach ++ ;
                                                                                                pGrabA->grabNotes.flags   |= bIsSign ? flGRABnOTES_ATTACHEDaSsIGNc : flGRABnOTES_ATTACHEDaSbATONc ;
            {
            else
            }
                pNapkin->formattingIsDoneF( tinBaseP ) ;
                                                                                                pGrabA->grabNotes.cDetach  = 0                                                         ;
                                                                                                pGrabA->grabNotes.cAttach  = 0                                                         ;
                if( F(flagsGrab) & flGRABc_GRABBED )                                          { pGrabA->grabNotes.flags   |= flGRABnOTES_FORMATTINGiSrEALLYsTILLpENDING                ; bResetPendingFlag = 1 ; }
                                                                                                pGrabA->grabNotes.flags    = bIsSign ? flGRABnOTES_CTaSsIGNc : flGRABnOTES_CTaSbATONc  ;
                                                                                                pGrabA->grabNotes.idCt     = grabNotesS::idNextF( tinBaseP )                               ;
                                                                                                pGrabA->grabNotes.osPidCt  = osPidIF( tinBaseP )                                           ;
                                                                                                pGrabA->grabNotes.osTidCt  = osTidIF()                                                 ;
    
                pGrabA->formatF( tinBaseP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , flagsGrab & ~( F(flGRABc_GRABBED) ) , idGrabLayerP ) ;
            {
            if( !( F(pNapkin->flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
            ZE( boolT , bResetPendingFlag ) ;
            pGrabA = pGrabInNapkin ;

            if( POOP ) BLAMMO
            __Z( pGrabInNapkin ) ;
            grabAnnotatedS* pGrabInNapkin = (grabAnnotatedS*)(byteT*)*pNapkin ;
            __( *pNapkin < sizeof( grabAnnotatedS ) ) ;
            __( !(byteT*)*pNapkin ) ; // THIS IS REDUNDANT; THE napkinC CONSTRUCTOR WILL HAVE BLAMMO'D
            __Z( pNapkin ) ;

            }
                THREADmODE2rESTORE

                else                                      { pNapkin = new( 0 , tinBaseP , LF                            ) napkinC( tinBaseP , idLineCtP , idiFileCtP , 0/*bits*/ , ostoNapkinName , 0 , sizeof( grabAnnotatedS ) , how , flagsNapkin ) ; ___( pNapkin ) ; }
                if( F(flagsCt) & flBATONcT_NAPKINiSzOMBIE ) pNapkin = new( 0 , tinBaseP , pbZombieP , sizeof( napkinC ) ) napkinC( tinBaseP , idLineCtP , idiFileCtP , 0/*bits*/ , ostoNapkinName , 0 , sizeof( grabAnnotatedS ) , how , flagsNapkin ) ;
                //bitsC bits( tinBaseP , CbITSlIFI , pbBitsCtP , 1 ) ;

                ;
                    : ifcOPENsHAREDmEMORYhOW_nCeO
                    ? ifcOPENsHAREDmEMORYhOW_nFeO
                countT how = F(flagsP) & flBATONc_FAILiFnAPKINnOTeXIST

                flagsT flagsNapkin = F(flagsP) & flBATONc_DOnOTsERIALIZEnAPKIN ? flNAPKINc_DOnOTsERIALIZEcT : flNAPKINc_null ;

                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
            {

            if( POOP ) BLAMMO ;
            OStEXTA(  ostoNapkinName , postP ) ;
            OStEXTA(  ostoNapkinName , ostoPrefix ) ;
            OStEXT(   ostoNapkinName , COSTnAPKINnAMEmAX + 1      )

            //U::__(  pbZombieP && cbZombieP < sizeof( napkinC ) ) ;

            }
                LOGrAW5( "napkinC [cbZombie,sizeofNapkinC]: " , cbZombieP , " " , sizeof( napkinC ) , "\r\n" ) ;
            {
            if( pbZombieP && cbZombieP < sizeof( napkinC ) )
        {
        if( postP )

        ;    

            (             F(flagsP) & flBATONc_SHARElAYER             ? flGRABc_SHARElAYER                                                     : flGRABc_null                 )
            (             F(flagsP) & flBATONc_SNEAKYlOVER            ? flGRABc_SNEAKYlOVER                                                    : flGRABc_null                 ) |
            (             F(flagsP) & flBATONc_NOTjEALOUS             ? flGRABc_NOTjEALOUS                                                     : flGRABc_null                 ) |
            (             F(flagsP) & flBATONc_GRABBEDnEVERtID        ? flGRABc_GRABBEDnEVERtID                                                : flGRABc_null                 ) |
            (             F(flagsP) & flBATONc_GRABBED                ? flGRABc_GRABBED                                                        : flGRABc_null                 ) |
            (             F(flagsP) & flBATONc_DOnOTrEGISTERiNtIN     ? flGRABc_DOnOTrEGISTERiNtIN                                             : flGRABc_null                 ) |
            ( postP                                                   ? flGRABc_INTERpROCESS                                                   : flGRABc_null                 ) |
            ( bIsSign                                                 ? flGRABc_ISsIGN | flGRABc_DOnOTrEGISTERiNtIN | flGRABc_DISABLErECURSION : flGRABc_null                 ) |
        flagsT flagsGrab =

        const boolT bIsSign = !!( F(flags) & flBATONc_ISsIGN ) ;

        else            thirdC::c_memsetIF( tinBaseP , (byteT*)pbBitsCt , sizeof pbBitsCt ) ;
        if( pbBitsCtP ) thirdC::c_memcpyIF( tinBaseP , (byteT*)pbBitsCt , (byteT*)pbBitsCtP , sizeof pbBitsCt ) ;
    
        }
            if( POOP ) BLAMMO ;
            __( idMemorySpaceP && !( F(((tin9S&)tinBaseP).flagsThreadMode4) & flTHREADmODE4_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tinBaseP ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tinBaseP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
            }
                __( !!pbZombieP && !cbZombieP ) ;
                FV( flBATONc , flagsP ) ;
                __( thirdC::c_strlenIF( tinBaseP , postP ) > COSTnAPKINnAMEmAX - ostoPrefix.costF() ) ;
                __( !postP[ 0 ] ) ;
            {
            if( postP )
            if( POOP ) BLAMMO ;
        {
        IFbEcAREFUL

        OStEXTV( ostoPrefix , "batonC/" )

        //U::_IO_
    {
    SCOOP
{
flagsCt( pbZombieP ? flBATONcT_NAPKINiSzOMBIE : flBATONcT_null )
flags( flagsP ) ,
pNapkin( 0 ) ,
pGrabA( &grabA ) ,
grabA( tinBaseP , TAGoR( TAGiDnULL , idLineCtP , idiFileCtP , pbBitsCtP ) , flGRABc_DISABLED , idGrabLayerP ) ,
cFunctionsPending( 1 ) ,
poop( flPOOP_SMELLY ) ,
idiFileCt( idiFileCtP ) ,
idLineCt( idLineCtP ) ,
/*1*/batonC::batonC( tin0S& tinBaseP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postP , const countT idGrabLayerP , const flagsT flagsP , byteT* const pbZombieP , const countT cbZombieP , const countT idMemorySpaceP )/*1*/ :

/**/
*/
  i am intended for use only by system code that needs to construct a napkinC when no poolC object exists
   i will layout pbZombieP as: PAD napkinC
  if not 0 then must be the address of CBzOMBIEbATONc bytes that i can use to construct a napkin in
  it is illegal to specify a nonze value in the definition of an adam
  can be 0
 pbZombieP
 postP
arguments
 this can be used to prevent multiple citizens of a class from being hired on the same computer
fFailIfExistsP: if set, then POOP will become impotent if a baton with the same name already exists
  replace "com/domain" with your domain name (e.g. "com/chevrolet" or "edu/uchicago")
  U::conj; this comment is incorrect; the name must be a napkinC name
 if not 0, must be of the form T("any.name/with.slashes.and.dots")
 can be 0
postP: a name for this batonC object
works even if impotent
 it should work for application code, but it is illegal for application code to construct static global objects
 this usage is reserved for system code
it is illegal to construct me as a static global
  \<A HREF=\"5.3a00104.1.1.0.html\"\>3a00104:  WAKEsHOW( "example.simplest.func.10a0001.batonC.batonC" )\</A\>
 simplest
examples
\<A HREF=\"5.10a0001.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

