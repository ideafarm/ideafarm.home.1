
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    #endif

        THREADmODE2rESTORE
        __Z( bDone ) ;
        __( idImpotence ) ;
        THREADmODE2oN( flTHREADmODE2_QUIETiMPOTENCE )

        }
            if( POOP ) POOPR

            }
                }
                    ++ s ; dosSleepIF( tinP , TOCK >> 2 ) ;
                    POOPRqUIET
                {
                else if( bForever || cTriesP )
                }
                    break ;
                    bDone = 1 ;
                {
                if( !idImpotence && !POOP )

                }
                    }
                        }
                            if( bLocal ) pInfoDisk1P->flags |= flINFOdISK1s_LOCAL ;

                            else       bLocal = ((tinNormalS&)tinP).brcRaw == DRIVE_FIXED || ((tinNormalS&)tinP).brcRaw == DRIVE_RAMDISK /*|| ((tinNormalS&)tinP).brcRaw == DRIVE_REMOVABLE || ((tinNormalS&)tinP).brcRaw == DRIVE_CDROM*/ ;
                            if( POOP ) { if( !bQuiet ) { LOGrAW3( "dosQueryFSInfoF / GetDriveType [brcQuery]: " , ((tinNormalS&)tinP).brcQuery , "\r\n" ) ; } }
                            ZE( boolT , bLocal ) ;

                            BOSpOOP
                            BOS( WHATsfr , BOSoK , GetDriveType( postDriveNameUse ) )

                            if( osFlags & FILE_READ_ONLY_VOLUME ) pInfoDisk1P->flags |= flINFOdISK1s_READoNLY ;

                            c_strncpyIF( tinP , pInfoDisk1P->postVolumeName , postVolumeName , sizeof pInfoDisk1P->postVolumeName ) ;
                            pInfoDisk1P->idVolume = cSerial ;
                            pInfoDisk1P->cUnusedUnits = cFreeClusters ;
                            pInfoDisk1P->cAllocationUnits = cClusters ;
                            pInfoDisk1P->cSectorsPerAllocationUnit = cSectorsPerCluster ;
                            pInfoDisk1P->cBytesPerSector = (count01T)cBytesPerSector ;
                        {
                        else
                        if( POOP ) { if( !bQuiet ) { LOGrAW( "dosQueryFSInfoF / new failed\r\n" ) ; } }

                        __Z( pInfoDisk1P ) ;
                        pInfoDisk1P = new( 0 , tinP , LF ) infoDisk1S( tinP , *this ) ; ___( pInfoDisk1P ) ;
                    {
                    else
                    if( POOP ) { if( !bQuiet ) { LOGrAW3( "dosQueryFSInfoF / GetVolumeInformation [brcQuery]: " , ((tinNormalS&)tinP).brcQuery , "\r\n" ) ; } }

                    BOSpOOP
                    BOS( WHATsfr , BOSoK , GetVolumeInformation( postDriveNameUse , postVolumeName , sizeof postVolumeName , &cSerial , &cnu1 , &osFlags , 0 , 0 ) )
                    BOSnOvALUE( WHATgbo , SetLastError( 0 ) )
                    ZE( DWORD , osFlags ) ;
                    ZE( DWORD , cnu1 ) ;

                    osTextT postVolumeName[ MAX_PATH + 1 ] ;
                {
                else
                }
                    }
                        //LOGrAW( "\r\n" ) ;
                        //LOGrAW( postDriveNameUse ) ;
                        //LOGrAW3( "dosQueryFSInfoF / GetDiskFreeSpace [brcQuery]: " , ((tinNormalS&)tinP).brcQuery , "\r\n" ) ;
                    {
                    if( !bQuiet )
                {
                if( idImpotence )

                BOSpOOPsET( idImpotence )
                BOS( WHATsfr , BOSoK , GetDiskFreeSpace( postDriveNameUse , &cSectorsPerCluster , &cBytesPerSector , &cFreeClusters , &cClusters ) )
                BOSnOvALUE( WHATgbo , SetLastError( 0 ) )

                //LOGrAW( "\r\n" ) ;
                //LOGrAW( postDriveNameUse ) ;
                //LOGrAW( "dosQueryFSInfoF / GetDiskFreeSpace [postDriveNameUse]: " ) ;

                ZE( DWORD , cSerial ) ;
                ZE( DWORD , cClusters ) ;
                ZE( DWORD , cFreeClusters ) ;
                ZE( DWORD , cBytesPerSector ) ;
                ZE( DWORD , cSectorsPerCluster ) ;
            {
            while( bForever || cTriesP -- )
            const boolT bQuiet   = cTriesP == 1 ;
            const boolT bForever = !cTriesP ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;

            SCOOPS
        {
        IFsCRATCH
        ZE( countT , idImpotence ) ;
        ZE( boolT , bDone ) ;

        ;
            : postRoot
            ? postDriveNameP
        const osTextT* postDriveNameUse = postDriveNameP[ 1 ] == ':'

        }
            ((osTextT*)postRoot)[ 2 ] = '\\' ;
            ((osTextT*)postRoot)[ 1 ] = ':' ;
            ((osTextT*)postRoot)[ 0 ] = postDriveNameP[ 3 ] ;
        {
        if( postDriveNameP[ 1 ] != ':' )
        const osTextT postRoot[] = { 0 , 0 , 0 , 0 } ;

    #elif defined( __NT__ )

        }
            if( hfi ) { BOSdOnOTtEST( WHATgbo , DosClose( hfi ) ) }
            }
                if( !POOP ) pInfoDisk1P->b Local = !( type >> 15 & 1 ) ;
                BOSpOOP
                BOSI( WHATgbo , BOSfAIL , DosQueryHType( hfi , &type , &flags ) )
                ZE( ULONG , flags ) ;
                ZE( ULONG , type ) ;
            {
            if( !*this && hfi )
            BOSpOOP
            }
                pInfoDisk1P->b Local = 0 ;
                ((tinNormalS&)tinP).bosFail = 0 ;
            {
            if( ((tinNormalS&)tinP).brcRaw == ERROR_ACCESS_DENIED )
            BOSI( WHATsfr , BOSfAIL , DosOpen( postRoot , &hfi , &action , 0 , 0 , OPEN_ACTION_OPEN_IF_EXISTS , OPEN_FLAGS_DASD|OPEN_SHARE_DENYNONE , 0 ) )
            const osTextT postRoot[] = { postDriveNameP[ 3 ] , ':' , 0 } ;
            ZE( ULONG , action ) ;
            ZE( HFILE , hfi ) ;
            pInfoDisk1P->b Local = 1 ;
        {
        if( !*this && pInfoDisk1P )
        if( !*this && pInfoDisk1P ) *pInfoDisk1P << infoDisk1a << infoDisk1b ;
        }
            __Z( pInfoDisk1P ) ;
            pInfoDisk1P = new( 0 , tinP , LF ) infoDisk1S( tinP , *this ) ; ___( pInfoDisk1P ) ;
        {
        if( !*this && cFound == 2 )
        }
            BOSpOOP
            if( ((tinNormalS&)tinP).bosFail && ( ((tinNormalS&)tinP).brcRaw == ERROR_INVALID_DRIVE /*|| ((tinNormalS&)tinP).brcRaw == ERROR_ NOT_READY*/ ) ) ((tinNormalS&)tinP).bosFail = 0 ;
            cFound += !((tinNormalS&)tinP).bosFail ;
            BOSI( WHATsfr , BOSfAIL , DosQueryFSInfo( idDrive , FSIL_VOLSER , &infoDisk1b , sizeof infoDisk1b ) )

            BOSpOOP
            if( ((tinNormalS&)tinP).bosFail && ( ((tinNormalS&)tinP).brcRaw == ERROR_INVALID_DRIVE /*|| ((tinNormalS&)tinP).brcRaw == ERROR_ NOT_READY*/ ) ) ((tinNormalS&)tinP).bosFail = 0 ;
            cFound += !((tinNormalS&)tinP).bosFail ;
            BOSI( WHATsfr , BOSfAIL , DosQueryFSInfo( idDrive , FSIL_ALLOC , &infoDisk1a , sizeof infoDisk1a ) )
        {
        if( !POOP )
        ZE( countT , cFound ) ;
        else __( idDrive ) ;
        if( idDrive >= 'a' && idDrive <= 'z' ) idDrive -= 'a' - 1 ;
        countT idDrive = postDriveNameP[ 3 ] ;
        infoDisk1bS infoDisk1b ;
        infoDisk1aS infoDisk1a ;

    #ifdef __OS2__
    _IO_

    }
        if( POOP ) return ;
        }
            if( postDriveNameP[ 3 ] < 'a' || postDriveNameP[ 3 ] > 'z' ) { __( postDriveNameP[ 3          ] ) ; __1 }
            if( postDriveNameP[ 2 ] != '/'                             ) { __( postDriveNameP[ 2          ] ) ;     }
            if( postDriveNameP[ 1 ] != '/'                             ) { __( postDriveNameP[ 1          ] ) ;     }
            if( postDriveNameP[ 0 ] != '/'                             ) { __( postDriveNameP[ 0          ] ) ;     }
        {
        else
        }
            if( postDriveNameP[ 2 ] != '\\'                            ) { __( postDriveNameP[ 2          ] ) ;     }
            if( postDriveNameP[ 0 ] < 'a' || postDriveNameP[ 0 ] > 'z' ) { __( postDriveNameP[ 0          ] ) ;     }
            if( postDriveNameP[ costdn - 1 ] != '\\'                   ) { __( postDriveNameP[ costdn - 1 ] ) ;     }
            countT costdn = c_strlenIF( tinP , postDriveNameP ) ;
        {
        if( postDriveNameP[ 1 ] == ':' )
        if( POOP ) return ;
        __Z( postDriveNameP[ 2 ] ) ;
        if( POOP ) return ;
        __Z( postDriveNameP[ 1 ] ) ;
        if( POOP ) return ;
        __Z( postDriveNameP[ 0 ] ) ;
        if( POOP ) return ;
        #endif
            __( sizeof( countT ) != sizeof( DWORD ) || fnu ) ;
        #elif defined( __NT__ )
            __( sizeof( count01T ) != sizeof( USHORT ) || fnu ) ;
            __( sizeof( countT ) != sizeof( ULONG ) || fnu ) ;
        #ifdef __OS2__
        ZE( boolT , fnu ) ;
        __Z( postDriveNameP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
    SCOOP
{
/*1*/voidT thirdC::dosQueryFSInfoF( tinBaseS& tinP , infoDisk1S*& pInfoDisk1P , const osTextT* const postDriveNameP , countT cTriesP )/*1*/

//U:: MIGRATE ALL CODE AWAY FROM USING THE "///d" FORM OF INPUT AND REMOVE SUPPORT FOR IT

//20231217@1555: EDIT TO ACCEPT STANDARD WINDOWS FULLY QUALIFIED PATHS IN ADDITION TO THE "///d" FORM
//U: CONJ: THIS API SHOULD USE "?:\\" FORMAT RATHER THAN "///?" (OR "///?/")

// 20121001: APPARENTLY VERY OLD CODE (WIN98 VINTAGE) THAT IGNORED A VARIETY OF SPURIOUS ERRORS WAS REWRITTEN TO NOT IGNORE ANY ERRORS AND TO ENSURE THAT OUTPUT STRUCTURE IS COMPLETELY DEFINED
//
//MODIFICATION HISTORY

/**/
*/
    note: the trailing backslash is required
   example: "d:\\ideafarm.home.1\\devices\\fannypack\\"     (for a device that is mounted to a folder (an ntfs junction)
   example: "d:\\"                                          (for a device that is mounted to a drive letter)
  these examples are for new code
   example: "///c" "/this.part/is/ignored/bla/bla.bla"
   example: "///c"
  these examples are obsolete and should not be used for new code
 postDriveNameP
 pInfoDisk1P
arguments
  \<A HREF=\"5.dd00104.1.1.0.html\"\>dd00104:  WAKEsHOW( "example.simplest.func.1020026.thirdC.dosQueryFSInfoF" )\</A\>
 simplest
examples
\<A HREF=\"5.1020026.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosQueryFSInfoF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

