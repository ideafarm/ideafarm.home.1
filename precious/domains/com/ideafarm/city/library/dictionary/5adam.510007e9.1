
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

}
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;

    }
        }
            ++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
        {
        while( cWorkersMemCompare )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {

    swJotSortedShortByArchiveYear.ungrabF( tinP ) ;
    }
        DEL( pDoomed ) ;                                                                        //20230306@1825: U:: jotC DT/OR FAILS COMPLAINING THAT pEtScratch IS IMPOTENT ; HOW: CTRL-C OR FIRE SERVICE
        jotC*& pDoomed = (jotC*&)(countT&)swJotSortedShortByArchiveYear ;
        psttzArchiveSlashYear = (strokeS*)swJotSortedShortByArchiveYear.leverF( tinP , idf ) ;
        _IO_
    {
    for( countT idf = 1 ; idf < cFlavors ; idf ++ )
    countT cFlavors = swJotSortedShortByArchiveYear.cFlavorsF( tinP ) ;
    swJotSortedShortByArchiveYear.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        }
            }
                }
                    etThread.traceF( tinP , T("fired  base operating system (hibernate)") ) ;
                    etThread.osSuspendF( tinP ) ;
                    etThread.traceF( tinP , T("firing base operating system (hibernate)") ) ;
                {
                if( bFireOs )

                etThread.traceF( tinP , T("cycle ended aok [time]:    ")+TT(time1AOK,time2AOK) ) ;
                etThread.osTimeNowF( tinP , time1AOK , time2AOK ) ;
                time2AOK = time1AOK = 0 ;
            {
            else
            }
                time2AOK = time1AOK = 0 ;      // THIS WILL CAUSE THE NEXT ITERATION TO PROCEED AFTER ONLY NAPPING WO TICK
                bGetNamesOnly = 0 ;
            {
            else if( bGetNamesOnly )
            }
                time2AOK = time1AOK = 0 ;      // THIS WILL CAUSE THE NEXT ITERATION TO PROCEED AFTER ONLY NAPPING WO TICK
                etThread.traceF( tinP , T("this cycle was aborted") ) ;
                // /*if( cYearsInParallel > 1 && 1 == decv02AM( cYearsInParallel ) )*/ cYearsInParallel = 1 ;  // REDUCE cYearsInParallel BUT NOT BELOW 1
                //20230106@1137: NAWWH; ABORT IS NOW DONE ROUTINELY BY PAUSE/RESUME, SO DOES NOT IMPLY FAILURE
                //20221229@1435: IF ABORT THEN ON NEXT ITERATION PROCESS YEARS SERIALLY
            {
            if( bAbort )

            }
                }
                    //etThread.osSuspendF( tinP ) ;
                    //etThread.traceF( tinP , T("ok.  hibernating") ) ;

                    }
                        }
                            if( cExecutiveHealYearPaused ) { BLAMMO ; }

                            THREADmODE2rESTORE
                            while( cExecutiveHealYear ) thirdC::dosSleepWinkIF( tinP ) ;
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                            _IO_
                        {

                        }
                            while( !bAbort && ~hStYearToHeal ) ;
                            }
                                }
                                    }
                                        }
                                            break ;
                                            bAbort = 1 ;
                                            etThread.traceF( tinP , T("!exception: could not launch thread tmExecutiveHealYearF") ) ;
                                            dec02AM( cExecutiveHealYear ) ;
                                            POOPRqUIET
                                        {
                                        if( POOP )
                                        tinP.pEtScratch->osThreadF( TaRG3fLAGScBtLS( tmExecutiveHealYearF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cPause , (countT)&stJobHealFile , (countT)&stJobCompare , (countT)&cYearsHealing , (countT)bKeepNames , (countT)bStrict , (countT)&cExecutiveHealYear , (countT)&cExecutiveHealYearPaused , (countT)&tUnique , (countT)psttYear , (countT)&psttzArchive , (countT)&swsPathToArchivesByArchiveName , (countT)&bAbort , (countT)&psttzArchiveSlashYear , (countT)&swJotSortedShortByArchiveYear , (countT)&cPathsToYearHealing , bGetNamesOnly , (countT)&grabLathFileHealedFiles ) ;
                                        SCOOPS
                                        _IO_
                                    {
                                    IFsCRATCH
                                    inc02AM( cExecutiveHealYear ) ;

                                    etThread.strMakeF( tinP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                                    ZE( strokeS* , psttYear ) ;

                                    etThread.traceF( tinP , T("year to heal:    ")+T(psttzYear) ) ;
                                    strokeS* psttzYear = (strokeS*)stYearToHeal.upF( tinP , hStYearToHeal ) ;       //PROCESSES YEARS BEGINNING WITH MOST RECENT  (A:ASSUME: CURRENT YEARS ARE IN MOST NEED OF HEALING SINCE FILES ARE ADDED AND MODIFIED)
                                {
                                if( !bAbort )

                                }
                                    THREADmODE2rESTORE
                                    while( cYearsInParallel == cExecutiveHealYear ) thirdC::dosSleepWinkIF( tinP ) ;
                                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                                    _IO_
                                {
                                _IO_
                            {
                            do
                            handleC hStYearToHeal( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            _IO_
                        {
                        if( !bAbort && stYearToHeal )

                        }
                            }
                                }
                                    }
                                        }
                                            break ;
                                            bAbort = 1 ;
                                            etThread.delF( tinP , psttYear ) ;
                                            etThread.traceF( tinP , T("!exception: duplicate year [psttYear]:    ")+T(psttYear) ) ;                        
                                        {
                                        if( !idSlot ) //SHOULD BE IMPOSSIBLE
                                        stYearToHeal.sinkF( tinP , idSlot , psttYear , flSTACKsINK_UNIQUE ) ;
                                        ZE( countT , idSlot ) ;
                                        etThread.strMakeF( tinP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                                        ZE( strokeS* , psttYear ) ;
                                        _IO_
                                    {
                                    if( tally > 1 )
                                    countT tally = swTallyByYear ;
                                    psttzYear = (strokeS*)swTallyByYear.leverF( tinP , idf ) ;
                                    _IO_
                                {
                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                countT cFlavors = swTallyByYear.cFlavorsF( tinP ) ;
                                _IO_
                            {
                            if( !bAbort )

                            while( ~hSwsPathToArchives ) ;
                            }
                                etThread.delF( tinP , pstt1PathToYear ) ;
                                }
                                    //etThread.traceF( tinP , T("[tYear,tally]:    ")+tYear+tb4+TF2((countT)swTallyByYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    swTallyByYear ++ ;
                                    psttzYear = tYear ;

                                    }
                                        etThread.delF( tinP , psttYear ) ;
                                        tYear = T(psttYear) ;
                                        etThread.strWordF( tinP , psttYear , psttc1 , sttq , sttSlash , - 2 ) ; ___( psttYear ) ;
                                        ZE( strokeS* , psttYear ) ;
                                    {
                                    TN( tYear , "" ) ;
                                    _IO_
                                {
                                FORsTRINGSiN1( pstt1PathToYear )
                                etThread.strConvertToLowerCaseF( tinP , pstt1PathToYear ) ;
                                }
                                    }
                                        break ;
                                        bAbort = 1 ;
                                        etThread.delF( tinP , pstt1PathToYear ) ;
                                        etThread.traceF( tinP , T("!exception: diskFindFileOrDirF failed [tPathToArchive]:    ")+tPathToArchive ) ;
                                        POOPRqUIET
                                    {
                                    if( POOP )
                                    tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                                    SCOOPS
                                    _IO_
                                {
                                IFsCRATCH
                                patternC pat( tinP , etThread , tYearPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                                ZE( strokeS* , pstt1PathToYear ) ;

                                etThread.traceF( tinP , T("[tPathToArchive]:    ")+tPathToArchive ) ;
                                TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchive)+tSlash ;
                                strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveName.downF( tinP , hSwsPathToArchives ) ;
                                _IO_
                            {
                            do
                            handleC hSwsPathToArchives( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            strokeS sttSlash( '/' ) ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

                            switchC swTallyByYear( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzYear ) ;
                            ZE( strokeS* , psttzYear ) ;
                            _IO_
                        {
                        stackC stYearToHeal( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

                        // FOR EACH YEAR FOLDER (ALL YEARS FOR THIS ARCHIVE NAME (EXAMPLE: ALL YEAR PATHS FOR EVERY YEAR FOR "wo.ideafarm"), LAUNCH A FILE RECORD COLLECTION THREAD
                        _IO_
                    {
                    if( cArchivesWithThisName > 1 )
                    etThread.traceF( tinP , T("[cArchivesWithThisName,archive]:    ")+TF2(cArchivesWithThisName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzArchive) ) ;
                    swsPathToArchivesByArchiveName.ungrabF( tinP ) ;
                    countT cArchivesWithThisName = swsPathToArchivesByArchiveName ;
                    psttzArchive = (strokeS*)swsPathToArchivesByArchiveName.leverF( tinP , idf ) ;
                    swsPathToArchivesByArchiveName.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    _IO_
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )    // FOR EACH ARCHIVE NAME (EXAMPLE: "wo.ideafarm")
                swsPathToArchivesByArchiveName.ungrabF( tinP ) ;
                countT cFlavors = swsPathToArchivesByArchiveName.cFlavorsF( tinP ) ;
                swsPathToArchivesByArchiveName.grabF( tinP , TAG( TAGiDnULL ) ) ;
                TN( tYearPattern , "?" "?" "?" "?" "/" ) ;                                                              //20221118@1747: "????/" PROUCES A SPURIOUS COMPILER ERROR INVOLVING TRIGRAPH
                //TN( tYearPattern , "2099/" ) ;          // THE YEAR WITH THE LARGEST FILE, ALSO WITH THE FILE OF SIZE 1,004,306,432
                //TN( tYearPattern , "2013/" ) ;          // 10,000,635 BYTE FILE
                //TN( tYearPattern , "2014/" ) ;          // THE YEAR WITH THE MOST SHORT NAME VALUES
                //TN( tYearPattern , "2023/" ) ;
                //TN( tYearPattern , "1999/" ) ;
                //TN( tYearPattern , "1234/" ) ;
                _IO_
            {
            if( !bAbort )

            }
                etThread.delF( tinP , psttu ) ;
                tUnique = T(psttu) ;
                etThread.strUniqueF( tinP , psttu ) ; ___( psttu ) ;
                ZE( strokeS* , psttu ) ;
            {
            TN( tUnique , "" ) ;

            swsPathToArchivesByArchiveName.lockIfF( tinP ) ;

            etThread.delF( tinP , pstt1ArchivesAllLag ) ;
            }
                if( bAbort ) { ++ s ; ether.osSleepF( tinP , TOCK << 2 ) ; }

                }
                    break ;
                    etThread.delF( tinP , pstt1ArchivesAll ) ;
                    }
                        swsPathToArchivesByArchiveName.sinkF( tinP , countTC() , psttPathArchives ) ;                           // EXAMPLE: "///c/ipdos.arhives/"

                        psttzArchive = tArchive ;

                        //etThread.traceF( tinP , T("    [tPathArchives,tArchive]:    ")+T(psttPathArchives)+tb4+tArchive ) ;

                        }
                            etThread.delF( tinP , psttShorter ) ;
                            tArchive = T(psttShorter) ;
                            etThread.strSubstringF( tinP , psttShorter , idf , idl , tArchiveSlash ) ; ___( psttShorter ) ;
                            ZE( strokeS* , psttShorter ) ;
                        {
                        if( idl )
                        countT idl = tArchiveSlash.csF( tinP ) ? tArchiveSlash.csF( tinP ) - 1 : 0 ;
                        countT idf = 1 ;
                        TN( tArchive , "" ) ;                                                                                   // EXAMPLE: "wo.ideafarm"

                        }
                            etThread.delF( tinP , psttArchiveSlash ) ;
                            tArchiveSlash = T(psttArchiveSlash) ;
                            etThread.strBisectF( tinP , psttPathArchives , psttArchiveSlash , psttc3 , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathArchives ) ; ___( psttArchiveSlash ) ;
                            ZE( strokeS* , psttArchiveSlash ) ;
                        {
                        TN( tArchiveSlash , "" ) ;                                                                              // EXAMPLE: "wo.ideafarm/"
                        ZE( strokeS* , psttPathArchives ) ;                                                                     // EXAMPLE: "///c/ipdos.arhives/"

                        //etThread.traceF( tinP , T("processing archive ")+T(psttc3) ) ;                                          // EXAMPLE: "///c/ipdos.arhives/wo.ideafarm/"
                        _IO_
                    {
                    FORsTRINGSiN3( pstt1ArchivesAll )

                    }
                        continue ;
                        pstt1ArchivesAllLag = pstt1ArchivesAll ; pstt1ArchivesAll = 0 ;
                        etThread.delF( tinP , pstt1ArchivesAllLag ) ;
                        ++ s ; ether.osSleepF( tinP , TICK >> 4 ) ;
                        if( bTest3 ) etThread.traceF( tinP , T("napping for a minute [reason]:    my list of visible archives changed") ) ;
                        if( bTest2 ) etThread.traceF( tinP , T("napping for a minute [reason]:    waiting to give time for all archives to become visible") ) ;
                        if( bTest1 ) etThread.traceF( tinP , T("napping for a minute [reason]:    less than oo archives found") ) ;
                    {
                    if( bTest1 /*|| bTest2*/ || bTest3 )
                    boolT bTest3 = !pstt1ArchivesAllLag ? 0 : etThread.strCompareF( tinP , pstt1ArchivesAllLag , pstt1ArchivesAll ) ;
                    boolT bTest2 = !pstt1ArchivesAllLag ;
                    boolT bTest1 =  cArchive < 2 ;
                    _IO_
                {
                if( !bAbort )

                }
                    while( ~hWalk ) ;
                    }
                        etThread.strFuseSeparateF( tinP , pstt1ArchivesAll , psttzArchive ) ;
                        strokeS* psttzArchive = (strokeS*)stArchive.downF( tinP , hWalk ) ;
                    {
                    do

                    etThread.strMakeF( tinP , LF , pstt1ArchivesAll , 0 , cArchive * CSpREFIX + csttArchive ) ; ___( pstt1ArchivesAll ) ;

                    while( ~hWalk ) ;
                    }
                        csttArchive += psttzArchive->idAdam ;
                        cArchive ++ ;
                        strokeS* psttzArchive = (strokeS*)stArchive.downF( tinP , hWalk ) ;
                    {
                    do
                    ZE( countT , csttArchive ) ;

                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    _IO_
                {
                if( !bAbort && stArchive )
                ZE( strokeS* , pstt1ArchivesAll ) ;
                ZE( countT , cArchive ) ;

                }
                    etThread.delF( tinP , pstt1PseudoVolumes ) ;
                    }
                        }
                            if( bAbort ) break ;
                            }
                                }
                                    etThread.delF( tinP , pstt1Archives2 ) ;
                                    }
                                        }
                                            }
                                                bAbort = 1 ;                                                    
                                                etThread.traceF( tinP , T("!exception: duplicate archive long name") ) ;
                                                etThread.delF( tinP , psttArchive ) ;
                                            {
                                            if( !ids ) //SHOULD BE IMPOSSIBLE
                                            stArchive.sinkF( tinP , ids , psttArchive , flSTACKsINK_UNIQUE ) ;
                                            ZE( countT , ids ) ;
                                            //etThread.traceF( tinP , T("sinking archive ")+T(psttArchive) ) ;
            
                                            etThread.strMakeF( tinP , LF , psttArchive , psttc1 ) ; ___( psttArchive ) ;
                                            ZE( strokeS* , psttArchive ) ;
            
                                            etThread.traceF( tinP , T("on mounted device [idArchive1,archive]:    ")+TF2(++cArchives,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttc1) ) ;
                                        {
                                        FORsTRINGSiN1( pstt1Archives2 )
                                        ZE( countT , cArchives ) ;
                                    {
                                    else
                                    if( bAbort ) break ;

                                    }
                                        }
                                            bAbort = 1 ;
                                            etThread.traceF( tinP , T("!exception:  diskFindFileOrDirF [psttc1,tDiskCulprit]:    ")+T(psttc1)+tb4+tDiskCulprit ) ;
                                            POOPRqUIET

                                            }
                                                tDiskCulprit = T(postCulprit) ;
                                                postCulprit[ 3 ] = ostCulprit ;
                                                osTextT postCulprit[] = "///?/" ;
                                            {
                                            if( ostCulprit >= 'a' && ostCulprit <= 'z' ) 
                                            osTextT ostCulprit = (osTextT)( POOP >> 0x18 ) ;
                                            TN( tDiskCulprit , "" ) ;
                                        {
                                        if( POOP )
                                        tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1Archives2 , psttc1 ) ; ___( pstt1Archives2 ) ;
                                        SCOOPS
                                        _IO_
                                    {
                                    IFsCRATCH
                                    ZE( strokeS* , pstt1Archives2 ) ;

                                    etThread.traceF( tinP , T("[archives found on pseudoVolume]:    ")+T(psttc1) ) ;

                                    if( idLoop ++ ) { BLAMMO ; }
                                {
                                FORsTRINGSiN1( pstt1Archives )
                                ZE( countT , idLoop ) ;
                            {
                            else
                            if( bAbort ) break ;

                            }
                                }
                                    break ;
                                    bAbort = 1 ;
                                    etThread.traceF( tinP , T("!exception:  diskFindFileOrDirF ; aborting [pseudoVolume]:    ")+T(psttc1) ) ;
                                    POOPRqUIET
                                {
                                if( POOP )
                                tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1Archives , psttc1 , &pat ) ; ___( pstt1Archives ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            patternC pat( tinP , etThread , T("ideafarm.archives/") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                            ZE( strokeS* , pstt1Archives ) ;

                            etThread.traceF( tinP , T("[pseudoVolume]:    ")+T(psttc1) ) ;
                        {
                        FORsTRINGSiN1( pstt1PseudoVolumes )
                    {
                    if( !bAbort )

                    }
                        }
                            bAbort = 1 ;
                            etThread.traceF( tinP , T("!exception:  diskFindFileOrDirF [tLikePseudoVolumes,tDiskCulprit]:    ")+tLikePseudoVolumes+tb4+tDiskCulprit ) ;
                            POOPRqUIET

                            }
                                tDiskCulprit = T(postCulprit) ;
                                postCulprit[ 3 ] = ostCulprit ;
                                osTextT postCulprit[] = "///?/" ;
                            {
                            if( ostCulprit >= 'a' && ostCulprit <= 'z' ) 
                            osTextT ostCulprit = (osTextT)( POOP >> 0x18 ) ;
                            TN( tDiskCulprit , "" ) ;
                        {
                        if( POOP )
                        tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1PseudoVolumes , tLikePseudoVolumes ) ; ___( pstt1PseudoVolumes ) ;
                        SCOOPS
                        _IO_
                    {
                    IFsCRATCH
                    ZE( strokeS* , pstt1PseudoVolumes ) ;
                    _IO_
                {
                if( !bAbort )
                etThread.traceF( tinP , T("accumulating archives mounted in ///ideafarm/devices/") ) ;

                }
                    etThread.delF( tinP , pstt1Archives1 ) ;
                    }
                        }
                            }
                                bAbort = 1 ;                                                    
                                etThread.traceF( tinP , T("!exception: duplicate archive long name") ) ;
                                etThread.delF( tinP , psttArchive ) ;
                            {
                            if( !ids ) //SHOULD BE IMPOSSIBLE
                            stArchive.sinkF( tinP , ids , psttArchive , flSTACKsINK_UNIQUE ) ;
                            ZE( countT , ids ) ;
                            //etThread.traceF( tinP , T("sinking archive ")+T(psttArchive) ) ;

                            etThread.strMakeF( tinP , LF , psttArchive , psttc1 ) ; ___( psttArchive ) ;
                            ZE( strokeS* , psttArchive ) ;

                            //etThread.traceF( tinP , T("on lettered device [idArchive1,archive]:    ")+TF2(++cArchives,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttc1) ) ;
                        {
                        FORsTRINGSiN1( pstt1Archives1 )
                        ZE( countT , cArchives ) ;
                    {
                    if( !bAbort )

                    }
                        }
                            bAbort = 1 ;
                            etThread.traceF( tinP , T("!exception:  diskFindFileOrDirF [tLikeArchives1,tDiskCulprit]:    ")+tLikeArchives1+tb4+tDiskCulprit ) ;
                            POOPRqUIET

                            }
                                tDiskCulprit = T(postCulprit) ;
                                postCulprit[ 3 ] = ostCulprit ;
                                osTextT postCulprit[] = "///?/" ;
                            {
                            if( ostCulprit >= 'a' && ostCulprit <= 'z' ) 
                            osTextT ostCulprit = (osTextT)( POOP >> 0x18 ) ;
                            TN( tDiskCulprit , "" ) ;
                        {
                        if( POOP )
                        tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1Archives1 , tLikeArchives1 ) ; ___( pstt1Archives1 ) ;
                        SCOOPS
                        _IO_
                    {
                    IFsCRATCH
                    ZE( strokeS* , pstt1Archives1 ) ;
                    _IO_
                {
                etThread.traceF( tinP , T("accumulating archives on lettered devices") ) ;

                stackC stArchive( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                bAbort = 0 ;
                _IO_
            {
            while( !ether )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
              TN( tLikePseudoVolumes , "///ideafarm/devices/"            ) ; //PROD
            //TN( tLikePseudoVolumes , "///d/ideafarm.home.101/devices/" ) ; //FOR TESTING
            TN( tLikeArchives1 , "///?/ideafarm.archives/" ) ;
            ZE( strokeS* , pstt1ArchivesAllLag ) ;

            switchStackC swsPathToArchivesByArchiveName( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzArchive , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
            ZE( strokeS* , psttzArchive ) ;
            // LOAD swsPathToArchivesByArchiveName WITH VALUES LIKE "///c/ideafarm.arhives/" OR "///ideafarm/devices/mydevname/ideafarm.archives/" SWITCHED ON VALUES LIKE "wo.ideafarm"
            _IO_
        {
        if( !ether )

        }
            }
                if( !bWaitWoDay ) etThread.traceF( tinP , T("napped  for a minute") ) ;
                ++ s ; ether.osSleepF( tinP , TICK >> 6 ) ;
                cNaps ++ ;
                if( !cNaps ) etThread.traceF( tinP , T(bWaitWoDay?"napping for a day":"napping for a quarter minute") ) ;
                _IO_
            {
            else
            }
                break ;
                if( bWaitWoDay ) etThread.traceF( tinP , T("napped  for a day") ) ;
            {
            )
                (  bWaitWoDay && time2E )            // A DAY'S NAP IS     REQUIRED AND I'VE NAPPED FOR A DAY
                ||
                ( !bWaitWoDay && cNaps  )            // A DAY'S NAP IS NOT REQUIRED AND I'VE NAPPED WO TIME
            (
            if

            etThread.osTimeSubtractF( tinP , time1E , time2E , time1AOK , time2AOK ) ;
            etThread.osTimeNowF( tinP , time1E , time2E ) ;
            ZE( sCountT , time2E ) ;
            ZE( countT  , time1E ) ;

            boolT bWaitWoDay = !!time2AOK ;
            _IO_
        {
        while( !ether )
        ZE( countT , cNaps ) ;
        _IO_
    {
    while( !ether && !POOP )
    switchC swJotSortedShortByArchiveYear( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzArchiveSlashYear ) ;
    ZE( strokeS* , psttzArchiveSlashYear ) ;
    ZE( sCountT , time2AOK ) ;
    ZE( countT  , time1AOK ) ;

    //etThread.traceF( tinP , T("napped  for a half tick so you can plug in devices to heal") ) ;
    //++ s ; ether.osSleepF( tinP , TICK >> 1 ) ;
    //etThread.traceF( tinP , T("napping for a half tick so you can plug in devices to heal") ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    }
        etThread.osThreadF( TaRG3fLAGScBtLS( tmWorkerMemCompareF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&bAbort , (countT)&cPause , (countT)&stJobCompare  , bStrict , (countT)&cYearsHealing ) ;
        inc02AM( cWorkersMemCompare ) ;
    {
    while( cDoCompare -- )
    while( cDoHeal    -- ) etThread.osThreadF( TaRG3fLAGScBtLS( tmWorkerHealFileF   , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&bAbort , (countT)&cPause , (countT)&stJobHealFile , bStrict , (countT)&cYearsHealing ) ;
    ZE( countT  , cYearsHealing ) ;

    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , cDoHeal ) ;

    etThread.traceF( tinP , T("HEALaRCHIVES: [bKeepNames,bFireOs,bStrict,cProcessors,cWorkersHeal,cWorkersCompare]:    ")+TF2(bKeepNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bFireOs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bStrict,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cDoHeal,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cDoCompare,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    countT cDoCompare = cProcessors << 1 ; //PRODUCTION
    //countT cDoCompare = cProcessors << 1 ;
    //countT cDoCompare = cProcessors >> 1 ; // BEST BEFORE OPTIMIZATION
    //countT cDoCompare = 1 ; // VERY SLOW
    //countT cDoCompare = cProcessors << 3 ; //VERY SLOW
    //cDoHeal = 1 ; //FOR TESTING
    countT cDoHeal    = cProcessors << 1 ;  //PRODUCTION:  ">> 1" "<< 0" TOO LITTLE JOB PUSHING
    const countT cProcessors = thirdC::osProcessorsIF( tinP ) ;

    }
        etThread.delF( tinP , psttHealStrict ) ;
        bStrict = psttHealStrict && !etThread.strCompareF( tinP , psttHealStrict , T("yes") ) ;
        ZE( strokeS* , psttHealStrict ) ; etThread.querySettingF( tinP , psttHealStrict , T("!ipdos.healstrict")  ) ; ___( psttHealStrict ) ;
    {
    ZE( boolT , bStrict ) ;

    //bFireOs = 0 ; //FOR TESTING
    }
        etThread.delF( tinP , psttHealFireOs ) ;
        bFireOs = !psttHealFireOs || etThread.strCompareF( tinP , psttHealFireOs , T("no") ) ;
        ZE( strokeS* , psttHealFireOs ) ; etThread.querySettingF( tinP , psttHealFireOs , T("!ipdos.healfireos")  ) ; ___( psttHealFireOs ) ;
    {
    ZE( boolT , bFireOs ) ;

    //bKeepNames = 1 ; //FOR TESTING
    }
        etThread.delF( tinP , psttHealKeepNames ) ;
        bKeepNames = psttHealKeepNames && !etThread.strCompareF( tinP , psttHealKeepNames , T("yes") ) ;
        ZE( strokeS* , psttHealKeepNames ) ; etThread.querySettingF( tinP , psttHealKeepNames , T("!ipdos.healkeepnames")  ) ; ___( psttHealKeepNames ) ;
    {
    ZE( boolT , bKeepNames ) ;

    stackC stJobCompare(  tinP , etThread , TAG( TAGiDnULL ) ) ;
    stackC stJobHealFile( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_BLOB | flSTACKc_ALLOWzE , sizeof( jobHealFileS        ) ) ;

    etThread.osThreadF( TaRG3fLAGScBtLS( tmObeyPauseSemaphoreFileF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&bAbort , (countT)&cPause , (countT)&cExecutiveHealYear , (countT)&cExecutiveHealYearPaused ) ;
    ZE( countT , cPathsToYearHealing      ) ;
    ZE( countT , cExecutiveHealYearPaused ) ;
    ZE( countT , cExecutiveHealYear       ) ;
    ZE( countT , cPause                   ) ;
    ZE( boolT  , bAbort                   ) ;
    boolT bGetNamesOnly = 1 ;

    etThread.osThreadF( TaRG3fLAGScBtLS( tmReportF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&grabLathFileHealedFiles ) ;
    grabC grabLathFileHealedFiles( tinP , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS ) ;

    TN( tSlash , "/" ) ;
    TN( tb4    , "    " ) ;
    _IO_
{
TODO

DONE( tmReportF )
}
    }
        ++ s ; ether.osSleepF( tinP , TICK >> 2 ) ;

        etThread.boxPutF( tinP , tFileReport , tReport , tReport.csF( tinP ) ) ;

        }
            tReport += tcrlf+tcrlf+tcrlf+T("(end of report)\r\n") ;

            }
                while( !ether && ~hFindFile && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        }
                            etThread.delF( tinP , posti ) ;
                            }
                                }
                                    }
                                        }
                                            postc = postHitEnd + 2 ; // SKIPS CRLF
                                            tReport += T(postHit)+tcrlf ;
                                            *postHitEnd = 0 ;
                                        {
                                        else
                                        if( !postHitEnd ) break ;
                                        osTextT* postHitEnd = thirdC::c_strstrIF( tinP , postHit , "\r\n" ) ;
                                    {
                                    else
                                    if( !postHit ) break ;
                                    osTextT* postHit = thirdC::c_strstrIF( tinP , postc , "!exception" ) ;

                                {
                                while( postc < poste )

                                postc = posti ;

                                }
                                    postc ++ ;
                                    if( !*postc ) *postc = 0xff ;
                                {
                                while( postc < poste )  // SMUDGE NULL CHAR (THESE FILES ARE BINARY FILES) SO CAN USE STRING HANDLING

                                osTextT* poste = posti + costi ;
                                osTextT* postc = posti ;
                            {
                            else
                            if( !posti ) etThread.traceF( tinP , T("null length file:    ")+tShort ) ;

                            etThread.boxGetShadowF( tinP , posti , costi , tFolder+tShort ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;
                        {
                        if( tShort.csF( tinP ) )        // IF NOT A DIRECTORY

                        }
                            etThread.delF( tinP , psttShort ) ;
                            etThread.delF( tinP , psttFolder ) ;
                            tShort  = T(psttShort) ;
                            tFolder = T(psttFolder) ;
                            etThread.strBisectF( tinP , psttFolder , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttFolder ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttFolder ) ;
                        {
                        TN( tShort , "" ) ;
                        TN( tFolder , "" ) ;
                    {
                    else
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( !pInfoFile || !pInfoFile->psttIfoName )

                    etThread.diskFindFileOrDirF( tinP , pInfoFile , hFindFile , tTraceFolder , &pat2 ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                handleC hFindFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {

            tReport += tcrlf+tcrlf+T("exceptions\r\n\r\n") ;

            THREADmODE2rESTORE
            grabLathFileHealedFilesP.ungrabF( tinP ) ;
            }
                while( !ether && ~hFindFile && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        }
                            etThread.delF( tinP , posti ) ;
                            etThread.delF( tinP , psttYear ) ;

                            tReport += T(psttYear)+tb4+T(posti)+tcrlf ;

                            etThread.strSubstringF( tinP , psttYear , idf , idl , tShort ) ; ___( psttYear ) ;
                            countT idl = 0x17 ;
                            countT idf = 0x14 ;
                            ZE( strokeS* , psttYear ) ;

                            etThread.boxGetShadowF( tinP , posti , costi , tFolder+tShort ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;

                            //etThread.traceF( tinP , tShort ) ;
                        {
                        if( tShort.csF( tinP ) && !etThread.strIdF( tinP , tDotHeyWritingDot , tShort ) )        // IF NOT A DIRECTORY

                        }
                            etThread.delF( tinP , psttShort ) ;
                            etThread.delF( tinP , psttFolder ) ;
                            tShort  = T(psttShort) ;
                            tFolder = T(psttFolder) ;
                            etThread.strBisectF( tinP , psttFolder , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttFolder ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttFolder ) ;
                        {
                        TN( tShort , "" ) ;
                        TN( tFolder , "" ) ;
                    {
                    else
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( !pInfoFile || !pInfoFile->psttIfoName )

                    etThread.diskFindFileOrDirF( tinP , pInfoFile , hFindFile , tStateFolder , &pat1 ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                handleC hFindFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {
            grabLathFileHealedFilesP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        {

        TN( tReport , "" ) ; tReport = T("IdeaFarm (tm) Archive Healer - Minute Report #")+TF2(++idReport,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n\r\n\r\nyear    lathFileHealed\r\n\r\n" ) ;
    {
    while( !ether && !POOP )
    ZE( countT , idReport ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    patternC pat2( tinP , etThread , tPatternTraceFile         , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
    patternC pat1( tinP , etThread , tPatternLathFileCompleted , ifcIDtYPEpATTERN_LITERAL               ) ;
    TN( tFileReport  , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/rpt.minute.ttt" ) ;
    TN( tStateFolder , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/" ) ;
    TN( tDotHeyWritingDot , ".!writing." ) ;

    TN( tTraceFolder , "" ) ; tTraceFolder = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/")+tUser+T("/00000100/stateSpaces/ffffefff/") ;

    TN( tUser , thirdC::postUserNameIF() ) ;

    TN( tPatternTraceFile , "bksTrace.booksC.*" ) ;

    ;

        +S2(sa_SSSaNDeND,sc_ccSSS)
        +T(".lath.file.completed.ttt")
        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("12")
        +S2(sa_SSSoR,sc_ccSSS)
        +T("status.wo.ideafarm.")
        +S2(sa_SSSaND,sc_ccSSS)
        T("")

    TN( tPatternLathFileCompleted , "" ) ; tPatternLathFileCompleted =

    // "status.wo.ideafarm.yyyy.lath.file.completed.ttt"
    //  123456789abcdef0123456789abcdef0123456789abcdef0
    //  0              1               2               3

    TN( tcrlf , "\r\n" ) ;
    TN( tb4   , "    " ) ;

    grabC& grabLathFileHealedFilesP = *(grabC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmReportF )

DONE( tmObeyPauseSemaphoreFileF )
}
    }
        }
            if( POOP ) POOPRqUIET
            tinP.pEtScratch->boxZapF( tinP , tFilePause , 1 ) ;
            SCOOPS
        {
        IFsCRATCH
        etThread.traceF( tinP , T("deleting the pause semaphore file and decremented cPauseP [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        countT was = decv02AM( cPauseP ) ;
    {
    if( etThread.diskFileExistsF( tinP , tFilePause ) )

    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;

        bFileExistsLag = bFileExists ;

        }
            }
                if( POOP ) POOPRqUIET
                tinP.pEtScratch->boxZapF( tinP , tFilePaused , 1 ) ;
                SCOOPS
            {
            IFsCRATCH
        {
        else if( !bFileExists && bFileExistsLag )
        }
            etThread.boxPutF( tinP , tFilePaused , tSay , tSay.csF( tinP ) + 1 ) ;
            TN( tSay , "If this file exists then IdeaFarm (tm) Archive Heal is paused due to a user request (a pause semaphore file)." ) ;
        {
        if( bFileExists && !bFileExistsLag && cExecutiveHealYearPausedP == cExecutiveHealYearP )

        }
            }
                etThread.traceF( tinP , T("decremented cPause on request [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                countT was = decv02AM( cPauseP ) ;
                bFileExists = 0 ;
            {
            if( bFileExists )
        {
        else
        }
            }
                etThread.traceF( tinP , T("incremented cPause on request [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                countT was = incv02AM( cPauseP ) ;
                bFileExists = 1 ;
            {
            if( !bFileExists )
        {
        if( etThread.diskFileExistsF( tinP , tFilePause ) )
    {
    while( !ether )
    ZE( boolT  , bFileExistsLag ) ;
    ZE( boolT  , bFileExists ) ;

    }
        if( POOP ) POOPRqUIET
        tinP.pEtScratch->boxZapF( tinP , tFilePause , 1 ) ;

        if( POOP ) POOPRqUIET
        tinP.pEtScratch->boxZapF( tinP , tFilePaused , 1 ) ;

        SCOOPS
    {
    IFsCRATCH

    etThread.diskMakeDirIfNeededF( tinP , tFilePause ) ;
    TN( tFilePaused , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/control/paused" ) ;
    TN( tFilePause  , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/control/pause"  ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    countT& cExecutiveHealYearPausedP = *(countT*)pTaskP->c4 ;
    countT& cExecutiveHealYearP       = *(countT*)pTaskP->c3 ;
    countT& cPauseP                   = *(countT*)pTaskP->c2 ;
    boolT&  bAbortP                   =  *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmObeyPauseSemaphoreFileF )

DONE( tmExecutiveHealYearF )
}
    dec02AM( cExecutiveHealYearP ) ;
    }
        }
            etThread.traceF( tinP , T("done for archive [bAbort,archive,year]:    ")+TF2(bAbortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzArchiveP)+tb4+tYear ) ;

            }
                }
                    grabLathFileHealedFilesP.ungrabF( tinP ) ;
                    THREADmODE2rESTORE
                    }
                        if( POOP ) POOPRqUIET
                        tinP.pEtScratch->boxZapF( tinP , tLong , 1 ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                    grabLathFileHealedFilesP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    //etThread.traceF( tinP , T("deleting [file]:    ")+tLong ) ;
                    tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".lath.file.completed.ttt") ;

                    etThread.boxPutF( tinP , tLong , tBody , tBody.csF( tinP ) ) ;
                    TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".completed.ttt") ;

                    TN( tBody , "" ) ; tBody = TT(time1N,time2N) + T("\r\nIPDOS (tm) Archive Healer\r\nDelete this file to cause Healer to not wait to heal this year.\r\n") ;
                    etThread.osTimeNowF( tinP , time1N , time2N ) ;
                    ZE( sCountT , time2N ) ;
                    ZE( countT  , time1N ) ;

                    DEL( pJotSortedShort ) ;

                    if( pJotSortedShort && !bKeepNamesP ) pJotSortedShort->flagsCtF() |= flJOTc_PATCHbOOKSfLAGStOpURGEoNdT ;
                    _IO_
                {
                if( !bAbortP && !bGetNamesOnlyP )

                etThread.delF( tinP , *(byteT**)&ppsttzPathToYear ) ;
                }
                    }
                        while( cDo -- ) dec02AM( cPathsToYearHealingP ) ;
                        countT cDo = cPathsToYear ;
                    {

                    }
                        DEL( pJob ) ;
                        st_pJobHealFileDone >> *(countT*)&pJob ;
                        ZE( jobHealFileS* , pJob ) ;
                    {
                    while( st_pJobHealFileDone )        //THIS MIGHT HAPPEN DUE TO RACE CONDITION, BUT IT (UPDATING THE "LATH FILE HEALED" FILE) DOESN'T MATTER 'CAUSE WE'RE DONE

                    if( bWorking ) dec02AM( cYearsHealingP ) ;

                    }
                        }
                            }
                                grabLathFileHealedFilesP.ungrabF( tinP ) ;
                                THREADmODE2rESTORE
                                etThread.boxPutF( tinP , tLong , tShortLathDone , tShortLathDone.csF( tinP ) ) ;
                                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                                grabLathFileHealedFilesP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".lath.file.completed.ttt") ;

                                //etThread.traceF( tinP , T("lath done [tShort]:    ")+tShortLathDone ) ;
                            {
                            if( tShortLathDone.csF( tinP ) )

                            st_pJobHealFileDone.ungrabF( tinP ) ;
                            }
                                while( ~hStk ) ;
                                }
                                    }
                                        DEL( pJob ) ;
                                        idNameLathDoneInSequence = pJob->idName ;
                                        tShortLathDone = T(pJob->psttShort) ;
                                        st_pJobHealFileDone.extractF( 0 , tinP ) ;
                                    {
                                    if( idNameLathDoneInSequence + 1 == pJob->idName )

                                    //etThread.traceF( tinP , T("walking stack of done jobs [idName,short]:    ")+TF3(pJob->idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+T(pJob->psttShort) ) ;
                                    jobHealFileS* pJob = (jobHealFileS*)st_pJobHealFileDone.downF( tinP , hStk ) ;
                                {
                                do
                                handleC hStk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( st_pJobHealFileDone )
                            st_pJobHealFileDone.grabF( tinP , TAG( TAGiDnULL ) ) ;
                            TN( tShortLathDone , "" ) ;
                        {
                        //DC:DUPLICATEcODE: 510007e9 510007e9

                        ++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
                        _IO_
                    {
                    while( cJobsPendingHeal )
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                    }
                        }
                            }
                                }
                                    }
                                        grabLathFileHealedFilesP.ungrabF( tinP ) ;
                                        THREADmODE2rESTORE
                                        etThread.boxPutF( tinP , tLong , tShortLathDone , tShortLathDone.csF( tinP ) ) ;
                                        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                                        grabLathFileHealedFilesP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                        TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".lath.file.completed.ttt") ;

                                        //etThread.traceF( tinP , T("lath done [tShort]:    ")+tShortLathDone ) ;
                                    {
                                    if( tShortLathDone.csF( tinP ) )

                                    st_pJobHealFileDone.ungrabF( tinP ) ;
                                    }
                                        while( ~hStk ) ;
                                        }
                                            }
                                                DEL( pJob ) ;
                                                idNameLathDoneInSequence = pJob->idName ;
                                                tShortLathDone = T(pJob->psttShort) ;
                                                st_pJobHealFileDone.extractF( 0 , tinP ) ;
                                            {
                                            if( idNameLathDoneInSequence + 1 == pJob->idName )

                                            //etThread.traceF( tinP , T("walking stack of done jobs [idName,short]:    ")+TF3(pJob->idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+T(pJob->psttShort) ) ;
                                            jobHealFileS* pJob = (jobHealFileS*)st_pJobHealFileDone.downF( tinP , hStk ) ;
                                        {
                                        do
                                        handleC hStk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    if( st_pJobHealFileDone )
                                    st_pJobHealFileDone.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                    TN( tShortLathDone , "" ) ;
                                {
                                //DC:DUPLICATEcODE: 510007e9 510007e9

                                stJobHealFileP.ungrabF( tinP ) ;
                                new( 0 , tinP , (byteT*)pJob , sizeof( jobHealFileS ) ) jobHealFileS( tinP , etThread , cJobsPendingHeal , infoYear , tShort , idName ) ;
                                jobHealFileS* pJob = (jobHealFileS*)&stJobHealFileP[ - 1 ] ;
                                stJobHealFileP << (byteT*)0 ;
                                stJobHealFileP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                //etThread.traceF( tinP , T("pushing a heal job [cPlates,tShort]:    ")+TF2(stJobHealFileP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;

                                }
                                    ++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
                                    //etThread.traceF( tinP , T("stJobHealFile is full [cPlates]:    ")+TF2(stJobHealFileP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                {
                                while( stJobHealFileP > cMaxBacklog )
                                sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                                }
                                    //etThread.traceF( tinP , T("healing [archive,year,cShortNames,idName,perTuck,tShort]:    ")+tArchive+tb4+tYear+tb4+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tPerTuck+tb4+tShort ) ;
                                    //countT perTuck = ( idName << 8 ) / cShortNames ;
                                {
                                //++ idName ;
                                if( !( ++ idName % ( TUCK >> 0 ) ) )

                                }
                                    inc02AM( cYearsHealingP ) ;
                                    bWorking = 1 ;
                                {
                                if( !bWorking )
                            {
                            else
                            if( bSkipThisFile ) ; // etThread.traceF( tinP , T("skipping [tShortSkipBeyond,tShort]:    ")+tShortSkipBeyond+tb4+tShort ) ;

                            boolT bSkipThisFile = tShortSkipBeyond.csF( tinP ) && 0 >= etThread.strCompareF( tinP , tShort , tShortSkipBeyond ) ;

                            }
                                break ;
                                bAbortP = 1 ;
                            {
                            if( ether )

                            //etThread.traceF( tinP , T("sorted [idJotIn,tShort]:    ")+TF2(idJotIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
                            //etThread.traceF( tinP , T("healing [archive,year,short]:    ")+tArchive+tb4+tYear+tb4+tShort ) ;
                            countT idJotIn = pJotSortedShort->idLathReadF() ;
                            _IO_
                        {
                        else
                        if( !tShort.csF( tinP ) ) ether.traceF( tinP , T("TODO / !exception: tShort is null length so ignoring this page") ) ;

                        //etThread.traceF( tinP , T("[pbIn,cbIn]:    ")+tShort+tb4+TF2(tShort.csF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        }
                            else        tShort = T(pbIn) ;
                            if( !pbIn ) ether.traceF( tinP , T("TODO / !exception: could not obtain blob so ignoring this page") ) ;
                            const byteT* pbIn = pageIn ;
                            pageC pageIn = *pJotSortedShort ;
                        {
                        TN( tShort , "" ) ;

                        if( bAbortP ) break ;
                        pauseIfF( tinP , bAbortP , cExecutiveHealYearPausedP , cPauseP ) ;
                        _IO_
                    {
                    while( !bAbortP && cDo -- )
                    ZE( boolT , bWorking ) ;
                    const countT cMaxBacklog = infoYear.cProcessors << 2 ;
                    ZE( countT , cJobsPendingHeal ) ;
                    countT cDo = cShortNames ;
                    ZE( countT , idNameLathDoneInSequence ) ;
                    ZE( countT , idName ) ;

                    paramHealFileS infoYear( tinP , etThread , bAbortP , cPauseP , tYear , tArchive , tUniqueP , cExecutiveHealYearPausedP , stJobCompareP , cPathsToYear , cResultStructsNeeded , ppsttzPathToYear , stPathToYear , st_pJobHealFileDone ) ;
                    stackC st_pJobHealFileDone( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_countT ) ;

                    etThread.traceF( tinP , T("[archive,year,cShortNames]:    ")+tArchive+tb4+tYear+tb4+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    const countT cShortNames = pJotSortedShort->cElementsF() ;
                    pJotSortedShort->resetLathReadF() ;

                    }
                        ++ s ; ether.osSleepF( tinP , ( TICK >> 4 ) ) ;     //GIVE OTHER NEWLY LAUNCHED YEAR THREADS SOME TIME TO ALSO ACCUMULATE INTO cPathsToYearHealingP BEFORE I PROCEED
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;               //THE IDEA HERE IS TO PREVENT AN EARLY YEAR THREAD FROM RACING AHEAD AND CALCULATING A HUGE FILE WINDOW SIZE FOR ITSELF JUST AHEAD OF OTHER NEWLY LAUNCHED YEAR THREADS

                        while( cDo -- ) inc02AM( cPathsToYearHealingP ) ;
                        countT cDo = cPathsToYear ;
                    {

                    _IO_
                {
                if( !bAbortP && !POOP && !bGetNamesOnlyP )

                }
                    }
                        }
                            }
                                etThread.traceF( tinP , T("decremented cPause after nap after exception [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                was = decv02AM( cPauseP ) ;
                                ++ s ; etThread.osSleepF( tinP , TIMEpAUSEoNfAIL ) ;
                                etThread.traceF( tinP , T("incremented cPause on exception [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                countT was = incv02AM( cPauseP ) ;
                            {
                            else
                            if( !cTries ) bAbortP = 1 ;
                        {
                        if( bAbortLocal )

                        }
                            etThread.delF( tinP , psttName ) ;
                            etThread.traceF( tinP , T("sorted jotC fileset [archive,year,short]:    ")+tArchive+tb4+tYear+tb4+T(psttName) ) ;
                            sortF( tinP , etThread , pJotSortedShort , jotShortFileNames , psttName , T("healarchive.sorted.short.filenames.")+tArchive+tDot+tYear , CBdATAbOOKsHORTfILEnAMES , TUCK << 0 , flSORTERc_SILENTLYsUPPRESSdUPLICATES , flJOTc_null , cNamesEstimate ) ;
                            ZE( strokeS* , psttName ) ;

                            countT cNamesEstimate = cFiles ;    // ACCURATE IF I HAVE ELIMINATED ALL DUPLICATES
                            cTries = 0 ; // IF GET HERE THEN READING FILE NAMES DID NOT FAIL SO WILL BE DONE
                        {
                        if( !bAbortP && !bAbortLocal )

                        if( ether ) bAbortP = 1 ;

                        if( !bAbortP ) pauseIfF( tinP , bAbortP , cExecutiveHealYearPausedP , cPauseP ) ;

                        etThread.delF( tinP , *(byteT**)&ppsttShort ) ;
                        etThread.delF( tinP , *(byteT**)&pphff ) ;
                        etThread.delF( tinP , *(byteT**)&ppif  ) ;
                        }
                            while( !ether && !bAbortP && !POOP && cPathsDone < cPathsToYear ) ;
                            }
                                //if( tShortToTest.csF( tinP ) ) break ;

                                }
                                    if( !( ++ cFiles % ( TUCK << 4 ) ) ) etThread.traceF( tinP , T("wrote to unsorted [archive,year,idFile,idJot,tShort]:    ")+tArchive+tb4+tYear+tb4+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
                                    countT idJot = jotShortFileNames.writeF( tinP , tShort , tShort.csF( tinP ) + 1 ) ;
                                    etThread.delF( tinP , ppsttShort[ offhMin ] ) ;
                                    //etThread.traceF( tinP , T("jotting [tShort]:    ")+tShort ) ;
                                    TN( tShort , ppsttShort[ offhMin ] ) ;
                                {
                                if( offhMin != - 1 )
                                // WRITE THE MINIMUM SHORT NAME TO JOT AND THEN DELETE IT SO THAT THE NEXT NAME WILL BE LOADED ON THE NEXT ITERATION

                                }
                                    }
                                        else if(    !sgn ) etThread.delF( tinP , ppsttShort[ offh ] ) ;
                                             if( 0 > sgn ) offhMin = offh ;

                                        sCountT sgn = offhMin == - 1 ? - 1 : etThread.strCompareF( tinP , ppsttShort[ offh ] , ppsttShort[ offhMin ] ) ;
                                    {
                                    if( ppsttShort[ offh ] )
                                {
                                for( countT offh = 0 ; !bAbortP && offh < cPathsToYear ; offh ++ )
                                countT offhMin = - 1 ;
                                // SET offhMin TO THE offh OF THE MINIMUM SHORT NAME ; SUPPRESS DUPLICATES

                                if( bAbortP || bAbortLocal ) break ;

                                }
                                    }
                                        if( bRetry ) offh -- ;   // TRY AGAIN TO LOAD A NAME FROM THIS VOLUME

                                        DEL( ppif[ offh ] ) ;
                                        }
                                            //}
                                            //    etThread.traceF( tinP , T("got [offh,psttShort]:    ")+TF2(offh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(ppsttShort[offh]) ) ;
                                            //{
                                            //else
                                            }
                                                bRetry = 1 ;
                                                etThread.delF( tinP , psttFolder ) ;
                                                etThread.traceF( tinP , T("folder ignored [tFolder]:    ")+T(psttFolder) ) ;
                                                etThread.delF( tinP , psttnu ) ;
                                                etThread.strBisectF( tinP , psttnu , psttFolder , ppif[ offh ]->psttIfoName , T("/") , - 2 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttFolder ) ;
                                                ZE( strokeS* , psttFolder ) ;
                                                ZE( strokeS* , psttnu ) ;

                                                etThread.delF( tinP , ppsttShort[ offh ] ) ;
                                            {                                                                               
                                            else if( !ppsttShort[ offh ]->idAdam )          //IT'S A DIRECTORY
                                            if( !ppsttShort[ offh ] ) bRetry = 1 ;

                                            etThread.delF( tinP , psttnu ) ;
                                            etThread.strBisectF( tinP , psttnu , ppsttShort[ offh ] , ppif[ offh ]->psttIfoName , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( ppsttShort[ offh ] ) ;
                                            ZE( strokeS* , psttnu ) ;
                                        {
                                        else
                                        }
                                            continue ;
                                            cPathsDone ++ ;
                                            DEL( pphff[ offh ] ) ;
                                            DEL( ppif[ offh ] ) ;
                                        {
                                        else if( !ppif[ offh ] || !ppif[ offh ]->psttIfoName )
                                        if( bAbortP || bAbortLocal ) break ;
                                        ZE( boolT , bRetry ) ;

                                        }
                                            }
                                                break ;
                                                DEL( ppif[ offh ] ) ;
                                                else          bAbortLocal = 1 ;
                                                if( !cTries ) bAbortP = 1 ;
                                                etThread.traceF( tinP , T("!exception:  diskFindFileOrDirF ; aborting [path]:    ")+T(ppsttzPathToYear[offh]) ) ;
                                                POOPRqUIET
                                            {
                                            if( POOP )

                                              tinP.pEtScratch->diskFindFileOrDirF( tinP , ppif[ offh ] , *pphff[ offh ] , ppsttzPathToYear[ offh ]        ) ; ___( ppif[ offh ] ) ;
                                            //tinP.pEtScratch->diskFindFileOrDirF( tinP , ppif[ offh ] , *pphff[ offh ] , ppsttzPathToYear[ offh ] , &pat ) ; ___( ppif[ offh ] ) ; //FOR TESTING

                                            //patternC pat( tinP , etThread , T("!ideafarm.9.2.00000000.00000001.20990007@0000.20220225@1343.ab155b6a3666b3c92434e1d1d650e2cf.001.data.zip") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; //LARGEST FILE IN THE ARCHIVE
                                            //patternC pat( tinP , etThread , T("!ideafarm.9.2.00000000.00000001.20990013@0000.20210119@0000.014c4e4d37bea606de6c6ac99d8d50c2.001.data.iso") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; // 1,004,306,432 BYTES
                                            //patternC pat( tinP , etThread , T("!ideafarm.9.2.00000000.00000001.20131226@1827.20170306@1754.8e00e6d01d529344e90f3e984315b7ce.001.data.mp3") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; //    10,000,635 BYTES
                                            // FOR TESTING

                                            SCOOPS
                                        {
                                        IFsCRATCH

                                        //}
                                        //    continue ;
                                        //    etThread.strMakeF( tinP , LF , ppsttShort[ offh ] , tShortToTest ) ; ___( ppsttShort[ offh ] ) ;
                                        //{
                                        //if( tShortToTest.csF( tinP ) )
                                    {
                                    if( pphff[ offh ] && !ppsttShort[ offh ] )
                                    _IO_
                                {
                                for( countT offh = 0 ; !bAbortP && offh < cPathsToYear ; offh ++ )

                                if( bAbortP ) break ;
                                pauseIfF( tinP , bAbortP , cExecutiveHealYearPausedP , cPauseP ) ;

                                //   LOAD A NONDIRECTORY SHORT NAME FROM EACH VOLUME FOR WHICH THERE IS NOT WO LOADED

                                //
                                //   SELECT THE MINIMUM SHORT NAME, WRITE IT TO JOT, AND DELETE IT
                                //   LOAD A NONDIRECTORY SHORT NAME FROM EACH VOLUME IF NOT ALREADY LOADED
                                //  EACH ITERATION
                                //
                                // RECIPE

                                // LOAD jotShortFileNames (WILL CONTAIN A PAGE FOR EACH VOLUME FOR EACH FILE, SO SHORT NAMES WILL BE DUPLICATED)

                                //  IF I DO THIS, THEN THE ONLY THING THAT SORTER WILL NEED TO CLEAN UP IS VOLUMES THAT PRESENT NAMES OUT OF ORDER, AND THIS WILL BE RARE FOR NTFS VOLUMES
                                // OBJECTIVE: IF EACH VOLUME PRESENTS ITS NAMES IN ASCENDING ORDER THEN, EVEN IF NOT ALL FILES ARE IN ALL VOLUMES, THE NAMES THAT I WRITE WILL BE IN ASCENDING ORDER
                                //  REPEAT
                                //  SELECT THE LOWEST NAME, WRITE IT TO JOT, AND GET THE NEXT NAME FROM THAT VOLUME
                                //  LOAD A SHORT NAME FROM EACH VOLUME
                                // RECIPE
                                _IO_
                            {
                            do
                            ZE( countT , cPathsDone ) ;
                            //TN( tShortToTest , "!ideafarm.9.2.00000000.00000001.20990004@0001.20170124@1441.46c264d2bf71383d11f319c316c3c001.001.data.ISO" ) ;

                            for( countT offh = 0 ; offh < cPathsToYear ; offh ++ ) pphff[ offh ] = new( 0 , tinP , LF ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                            etThread.memSetF( tinP , (byteT*)ppsttShort , cPathsToYear * sizeof( strokeS*   ) ) ;
                            etThread.memSetF( tinP , (byteT*)ppif       , cPathsToYear * sizeof( infoFileS* ) ) ;
                            etThread.memSetF( tinP , (byteT*)pphff      , cPathsToYear * sizeof( handleC*   ) ) ;

                            _IO_
                        {
                        else
                        if( POOP || ether ) bAbortP = 1 ;
                        ZE( countT , cFiles ) ;

                        etThread.newF( tinP , LF , *(byteT**)&ppsttShort , cPathsToYear * sizeof( strokeS* ) ) ; ___( ppsttShort ) ;
                        ZE( strokeS** , ppsttShort ) ;

                        etThread.newF( tinP , LF , *(byteT**)&ppif , cPathsToYear * sizeof( infoFileS* ) ) ; ___( ppif ) ;
                        ZE( infoFileS** , ppif ) ;

                        etThread.newF( tinP , LF , *(byteT**)&pphff , cPathsToYear * sizeof( handleC* ) ) ; ___( pphff ) ;
                        ZE( handleC** , pphff ) ;

                        jotC jotShortFileNames( tinP , "short.file.names" , flJOTc_WRITE | flJOTc_PRIVATE | flJOTc_DELETE | flJOTc_PURGEoNcT , 1 , CBdATAbOOKsHORTfILEnAMES ) ;
                        etThread.traceF( tinP , T("reading short names from volumes [archive,year]    ")+tArchive+tb4+tYear ) ;

                        ZE( boolT , bAbortLocal ) ;

                        _IO_
                    {
                    while( !ether && cTries -- )
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    countT cTries = bStrictP ? 1 : TUCK >> 4 ;
                {
                else
                else if( pJotSortedShort ) etThread.traceF( tinP , T("reusing a sorted list of short names") ) ;
                if( bAbortP ) ;

                //for( countT offh = 0 ; offh < cPathsToYear ; offh ++ ) etThread.traceF( tinP , T("cache [cPaths,off,pstt]:    ")+TF2(cPathsToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(ppsttzPathToYear[offh]) ) ;

                }
                    if( !bMatch && !bAbortP ) etThread.boxPutF( tinP , tLongBox , twl , twl.csF( tinP ) ) ;

                    }
                        }
                            bAbortP = 1 ;
                            etThread.boxPutF( tinP , tLongBoxSee , twl , twl.csF( tinP ) ) ;
                            etThread.traceF( tinP , T("!exception: volume list that I see differs from list in volumes file ; aborting") ) ;
                        {
                        else
                        if( !etThread.strCompareF( tinP , twl , twlLag ) ) bMatch = 1 ;

                        etThread.delF( tinP , posti ) ;
                        TN( twlLag , posti ) ;

                        etThread.boxGetShadowF( tinP , posti , costi , tLongBox ) ; ___( posti ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;
                    {
                    if( etThread.diskFileExistsF( tinP , tLongBox ) )
                    ZE( boolT , bMatch ) ;

                    TN( tLongBoxSee , "" ) ; tLongBoxSee = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/volumes.")+tArchive+tDot+tYear+T(".see.ttt") ;
                    TN( tLongBox    , "" ) ; tLongBox    = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/volumes.")+tArchive+tDot+tYear+T(".ttt") ;

                    etThread.delF( tinP , psttWorkList ) ;
                    TN( twl , psttWorkList ) ;

                    }
                        etThread.delF( tinP , psttv ) ;
                        etThread.strFuseF( tinP , psttWorkList , tcr   ) ;
                        etThread.strFuseF( tinP , psttWorkList , psttv ) ;
                        stVolume >> psttv ;
                        ZE( strokeS* , psttv ) ;
                    {
                    while( stVolume )

                    etThread.strMakeF( tinP , LF , psttWorkList , 0 , stVolume * 2 + csttVolume ) ; ___( psttWorkList ) ;
                    ZE( strokeS* , psttWorkList ) ;

                    }
                        }
                            stVolume.sinkF( tinP , countTC() , psttv , flSTACKsINK_null ) ;     //INTENTIONALLY ALLOWS DUPLICATES SO WILL FUNCTION CORRECTLY IF MULTIPLE DEVICES HAVE THE SAME VOLUME NAME (WHICH IS BAD PRACTICE AND MIGHT NOT BE SUPPORTED IN THE FUTURE)
                            csttVolume += tVolumeName.csF( tinP ) ;

                            etThread.strMakeF( tinP , LF , psttv , tVolumeName ) ; ___( psttv ) ;
                            ZE( strokeS* , psttv ) ;

                            etThread.traceF( tinP , T("[volume,pathToYear]:    ")+tVolumeName+tb4+T(ppsttzPathToYear[offh]) ) ;
                        {
                        if( !bAbortP )

                        }
                            if( tPseudoVolume.csF( tinP ) ) tVolumeName = tVolumeName+tDot+tPseudoVolume ;

                            DEL( pInfoDisk ) ;
                            }
                                tVolumeName = T(pInfoDisk->psttVolumeName) ;
                                etThread.strConvertToLowerCaseF( tinP , pInfoDisk->psttVolumeName ) ;
                                etThread.delF( tinP , psttDisk ) ;
                            {
                            if( !bAbortP )

                            }
                                }
                                    bAbortP = 1 ;
                                    etThread.traceF( tinP , T("!exception:  diskInfoF: could not obtain volume name [psttDisk]:    ")+T(psttDisk) ) ;
                                    POOPRqUIET
                                {
                                if( POOP )
                                tinP.pEtScratch->diskInfoF( tinP , pInfoDisk , psttDisk , 1 ) ; ___( pInfoDisk ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            ZE( infoDiskS* , pInfoDisk ) ;

                            etThread.strSubstringF( tinP , psttDisk , idf , idl , ppsttzPathToYear[ offh ] ) ; ___( psttDisk ) ;
                            countT idl = 5 ;
                            countT idf = 1 ;
                            ZE( strokeS* , psttDisk ) ;
                        {
                        TN( tVolumeName , "" ) ;

                        }
                            etThread.delF( tinP , pstt1w ) ;
                            }
                                }
                                    break ;
                                    tPseudoVolume = T(psttc1) ;
                                {
                                else if( bArm )
                                if( !etThread.strCompareF( tinP , psttc1 , tDevices ) ) bArm = 1 ;
                            {
                            FORsTRINGSiN1( pstt1w )
                            ZE( boolT , bArm ) ;
                            etThread.strWordsF( tinP , pstt1w , ppsttzPathToYear[offh] , sttq , tSlash ) ;
                            ZE( strokeS* , pstt1w ) ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        {
                        if( 1 == etThread.strIdF( tinP , tPathDevices , ppsttzPathToYear[offh] ) )
                        TN( tPseudoVolume , "" ) ;

                        etThread.traceF( tinP , T("pathToYear:    ")+T(ppsttzPathToYear[offh]) ) ;

                        ppsttzPathToYear[ offh ] = (strokeS*)stPathToYear[ 1 + offh ] ;
                    {
                    for( countT offh = 0 ; !bAbortP && offh < cPathsToYear ; offh ++ )
                    TN( tDevices , "devices" ) ;
                    TN( tSlash , "/" ) ;
                    ZE( countT , csttVolume ) ;
                    stackC stVolume( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

                    }
                        etThread.delF( tinP , psttd ) ;
                        tPathDevices = T(psttd) ;
                        etThread.diskMapFileNameF( tinP , psttd , T("///ideafarm/devices/")              ) ; ___( psttd ) ; //PROD
                        //etThread.diskMapFileNameF( tinP , psttd , T("///d/ideafarm.home.101/devices/") ) ; ___( psttd ) ; //FOR TESTING
                        ZE( strokeS* , psttd ) ;
                    {
                    TN( tPathDevices , "" ) ;

                    _IO_
                {

                etThread.newF( tinP , LF , *(byteT**)&ppsttzPathToYear , cPathsToYear * sizeof( strokeS* ) ) ; ___( ppsttzPathToYear ) ;
                ZE( const strokeS** , ppsttzPathToYear ) ;                // OPTIMIZATION TO AVOID MANY CALLS TO stackC::operator []

                ZE( countT , idName ) ;
                TN( tPathLonely   , "/ideafarm.archives.lonely/"  ) ; tPathLonely  += tUniqueP+tSlash ;
                TN( tPathRejects  , "/ideafarm.archives.rejects/" ) ; tPathRejects += tUniqueP+tSlash ;
                TN( tPathArchives , "/ideafarm.archives/"         ) ;

                _IO_
            {
            if( cPathsToYear > 1 )

            }
                if( idPass == 1 ) stPathToYear.lockIfF( tinP ) ;

                if( bAbortP ) break ;

                while( !bAbortP && ~hSwsPathToArchives ) ;
                }
                    etThread.delF( tinP , pstt1PathToYear ) ;
                    }
                        }
                            //etThread.traceF( tinP , T("stPathToYear [cPlates,ids,psttc1]:    ")+TF2(stPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idSlotPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttc1) ) ;
                            countT idSlotPathToYear = stPathToYear( psttc1 ) ;
                        {
                        else
                        }
                            }
                                break ;
                                bAbortP = 1 ;
                                etThread.traceF( tinP , T("!exception: idSlotPathToYear is null") ) ;
                                etThread.delF( tinP , psttPathToYear ) ;
                            {
                            if( !idSlotPathToYear ) //SHOULD BE IMPOSSIBLE
                            //etThread.traceF( tinP , T("maybe sunk into stPathToYear [now,psttPathToYear]:    ")+TF2(stPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttPathToYear) ) ;
                            stPathToYear.sinkF( tinP , idSlotPathToYear , psttPathToYear , flSTACKsINK_UNIQUE ) ;
                            ZE( countT , idSlotPathToYear ) ;

                            etThread.strMakeF( tinP , LF , psttPathToYear , psttc1 ) ; ___( psttPathToYear ) ;
                            ZE( strokeS* , psttPathToYear ) ;
                        {
                        if( idPass == 1 )
                    {
                    FORsTRINGSiN1( pstt1PathToYear )

                    //etThread.traceF( tinP , T("[pstt1PathToYear]:    ")+T(pstt1PathToYear) ) ;
                    etThread.strConvertToLowerCaseF( tinP , pstt1PathToYear ) ;

                    }
                        }
                            break ;
                            bAbortP = 1 ;
                            etThread.traceF( tinP , T("!exception:  diskFindFileOrDirF ; aborting [tPathToArchive]:    ")+tPathToArchive ) ;
                            POOPRqUIET
                        {
                        if( POOP )
                        tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    patternC pat( tinP , etThread , tYearSlash , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                    ZE( strokeS* , pstt1PathToYear ) ;

                    //if( idPass == 1 ) etThread.traceF( tinP , T("flavor [tPathToArchive]:    ")+tPathToArchive ) ;
                    TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchiveP)+tSlash ;
                    strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveNameP.downF( tinP , hSwsPathToArchives ) ;
                {
                do
                handleC hSwsPathToArchives( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                }
                    cResultStructsNeeded = 1 + cPathsToYear / cResultsPerStruct ;
                    cPathsToYear = stPathToYear ;
                {
                if( idPass == 2 )
                _IO_
            {
            for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
            stackC stPathToYear( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
            ZE( countT   , cResultStructsNeeded ) ;
            ZE( countT   , cPathsToYear         ) ;

            }
                ++ s ; ether.osSleepF( tinP , TOCK ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                }
                    }
                        etThread.delF( tinP , posti ) ;
                        }
                            etThread.traceF( tinP , T("i will skip files recently healed [archive,year,tShortSkipBeyond]:    ")+tArchive+tb4+tYear+tb4+tShortSkipBeyond ) ;
                            tShortSkipBeyond = T(posti) ;
                        {
                        else if( posti && costi && *posti )
                        if( POOP ) POOPRqUIET
                        tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , tLong , 1 ) ; ___( posti ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".lath.file.completed.ttt") ;
                {
                if( !bAbortP )
            {
            TN( tShortSkipBeyond , "" ) ;

            }
                }
                    pJotSortedShort = new( 0 , tinP , LF ) jotC( tinP , tPart2 , flJOTc_DOnOTrEGISTER , 1 , CBdATAbOOKsHORTfILEnAMES ) ;        //flJOTc_DOnOTrEGISTER BECAUSE WILL BE DELETED ON ANOTHER THREAD
                    etThread.traceF( tinP , T("reusing existing jot of sorted short file names [file]:    ")+tPart2 ) ;
                {
                else
                if( !etThread.diskFileExistsF( tinP , tLongLikeIndex ) || !etThread.diskFileExistsF( tinP , tLongLikeData ) ) etThread.traceF( tinP , T("could not find existing jot of sorted short file names [file]:    ")+tPart2 ) ;

                //if( !etThread.diskFileExistsF( tinP , tLongLikeData  ) ) etThread.traceF( tinP , T("not found [pattern]:    ")+tLongLikeData  ) ;
                //if( !etThread.diskFileExistsF( tinP , tLongLikeIndex ) ) etThread.traceF( tinP , T("not found [pattern]:    ")+tLongLikeIndex ) ;
                //etThread.traceF( tinP , T("looking for [pattern]:    ")+tLongLikeData ) ;
                //etThread.traceF( tinP , T("looking for [pattern]:    ")+tLongLikeIndex ) ;

                TN( tLongLikeData  , "" ) ; tLongLikeData  = tPart1+tPart2+tPart3+tPart4b ;
                TN( tLongLikeIndex , "" ) ; tLongLikeIndex = tPart1+tPart2+tPart3+tPart4a ;
                TN( tPart4b , "" ) ; tPart4b = T("data.booksC.*.bookC" ) ;
                TN( tPart4a , "" ) ; tPart4a = T("index.booksC.*.bookC" ) ;
                TN( tPart3  , "" ) ; tPart3  = T(".jotC." ) ;
                TN( tPart2  , "" ) ; tPart2  = T("healarchive.sorted.short.filenames")+tDot+tArchive+tDot+tYear ;
                TN( tPart1  , "" ) ; tPart1  = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/")+tUser+T("/")+TF3(ifcIDmEMORYsPACE_APPLICATION,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T("/stateSpaces/")+TF3(ifcIDsTATEsPACE_MULTIPLEaDAMS,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tSlash ;

                TN( tUser , thirdC::postUserNameIF() ) ;
            {
            if( !pJotSortedShort )

            jotC*& pJotSortedShort = *ppJotSortedShort ;
            }
                swJotSortedShortByArchiveYearP.ungrabF( tinP ) ;
                ppJotSortedShort = (jotC**)&(countT&)swJotSortedShortByArchiveYearP ;
                psttzArchiveSlashYearP = tLever ;
                swJotSortedShortByArchiveYearP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                TN( tLever , "" ) ; tLever = tArchive+tSlash+tYear ;
            {
            ZE( jotC** , ppJotSortedShort ) ;
            _IO_
        {
        else
        if( !bDoThisYear ) etThread.traceF( tinP , T("skipping this year because it was recently healed AOK [archive,year]:    ")+tArchive+tb4+tYear ) ;

        }
            etThread.delF( tinP , posti ) ;
            }
                }
                    if( time2E < 0x40 ) bDoThisYear = 0 ;
                    etThread.osTimeSubtractF( tinP , time1E , time2E , time1AOK , time2AOK ) ;

                    }
                        etThread.delF( tinP , pstt1w ) ;
                        }
                            if( cDone == 2 ) break ;
                            *( cDone ++ ? &time2AOK : (sCountT*)&time1AOK ) = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
                            //etThread.traceF( tinP , T("time word:    ")+T(psttc1) ) ;
                        {
                        FORsTRINGSiN1( pstt1w )
                        ZE( countT  , cDone ) ;
                        etThread.strWordsF( tinP , pstt1w , tTimeAOK , sttq , tDot ) ; ___( pstt1w ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        ZE( strokeS* , pstt1w ) ;

                        etThread.traceF( tinP , T("[archive,year,timeAOK]:    ")+tArchive+tb4+tYear+tb4+tTimeAOK ) ;
                        TN( tTimeAOK , posti ) ;
                        *postc = 0 ;
                    {
                    ZE( sCountT , time2AOK ) ;
                    ZE( countT  , time1AOK ) ;

                    etThread.osTimeNowF( tinP , time1E , time2E ) ;
                    ZE( sCountT , time2E ) ;
                    ZE( countT  , time1E ) ;
                {
                if( postc )
                osTextT* postc = thirdC::c_strstrIF( tinP , posti , "\r\n" ) ;
            {
            else
            if( POOP ) POOPRqUIET
            tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , tLong , 1 ) ; ___( posti ) ;
            TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".completed.ttt") ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCH
        boolT bDoThisYear = 1 ;

        etThread.traceF( tinP , T("[archive,year]:    ")+tArchive+tb4+tYear ) ;
        TN( tYearSlash , "" ) ; tYearSlash = tYear+T("/") ;
        etThread.delF( tinP , psttYearP ) ;
        TN( tYear , "" ) ; tYear = T(psttYearP) ;

        TN( tArchive , psttzArchiveP ) ;

        TN( tIndent3 , "|           " ) ;
        TN( tIndent2 , "|       " ) ;
        TN( tIndent1 , "|   " ) ;
        TN( tPerTuck , "%" ) ;
        TN( tDot     , "." ) ;
        TN( tcr      , "\r\n" ) ;
        TN( tSlash   , "/" ) ;
        TN( tb4      , "    " ) ;
        TN( tb       , " " ) ;
        _IO_
    {
    if( !POOP )

    const countT cProcessors = thirdC::osProcessorsIF( tinP ) ;

    __Z( psttzArchiveP->idAdam ) ;
    __Z( psttYearP->idAdam ) ;
    _IO_

    grabC&        grabLathFileHealedFilesP        =        *(grabC*)pTaskP->c21 ;
    boolT         bGetNamesOnlyP                  =                 pTaskP->c11 ;
    countT&       cPathsToYearHealingP            =       *(countT*)pTaskP->c01 ;
    switchC&      swJotSortedShortByArchiveYearP  =      *(switchC*)pTaskP->cf  ;
    strokeS*&     psttzArchiveSlashYearP          =     *(strokeS**)pTaskP->ce  ;
    boolT&        bAbortP                         =        *(boolT*)pTaskP->cd  ;
    switchStackC& swsPathToArchivesByArchiveNameP = *(switchStackC*)pTaskP->cc  ;
    strokeS*&     psttzArchiveP                   =     *(strokeS**)pTaskP->cb  ;
    strokeS*      psttYearP                       =       (strokeS*)pTaskP->ca  ;
    textC&        tUniqueP                        =        *(textC*)pTaskP->c9  ;
    countT&       cExecutiveHealYearPausedP       =       *(countT*)pTaskP->c8  ;
    countT&       cExecutiveHealYearP             =       *(countT*)pTaskP->c7  ;
    boolT         bStrictP                        =          (boolT)pTaskP->c6  ;
    boolT         bKeepNamesP                     =          (boolT)pTaskP->c5  ;
    countT&       cYearsHealingP                  =       *(countT*)pTaskP->c4  ;
    stackC&       stJobCompareP                =       *(stackC*)pTaskP->c3  ;
    stackC&       stJobHealFileP                  =       *(stackC*)pTaskP->c2  ;
    countT&       cPauseP                         =       *(countT*)pTaskP->c1  ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c7 && pTaskP->c8 && pTaskP->c9 && pTaskP->ca && pTaskP->cb && pTaskP->cc && pTaskP->cd && pTaskP->ce && pTaskP->cf && pTaskP->c01 )
TASK( tmExecutiveHealYearF )

DONE( tmWorkerMemCompareF )
}
    dec02AM( cWorkersMemCompare ) ;
    stJobCompareP.ungrabF( tinP ) ;
    }
        stJobCompareP >> pbz_woJob ;
        byteT* pbz_woJob = (byteT*)&woJob ;
        jobCompareOoImagesS woJob ;
    {
    while( stJobCompareP )
    stJobCompareP.grabF( tinP , TAG( TAGiDnULL ) ) ;

    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
    }
        stJobCompareP.ungrabF( tinP ) ;

        }
            stJobCompareP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            ++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
            if( cYearsHealingP && !( ++ cIdle % TUCK ) ) etThread.traceF( tinP , T("years are healing but i have nothing to do (no memory compare jobs) [cIdle]:    ")+TF2(cIdle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            stJobCompareP.ungrabF( tinP ) ;
        {
        if( !cDone )

        //}
        //    etThread.traceF( tinP , T("---- watch") ) ;
        //    etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
        //    bWatching = 0 ;
        //{
        //if( bWatching )

        }
            stJobCompareP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            cDone ++ ;
            DEL( pJob ) ;
            }
                //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
                compareOoImagesF( tinP , etThread , bAbortP , cPauseP , pJob->bEqual , bStrictP , pJob->pbwOuter , pJob->pbwInner , pJob->cbwOuter /*, T(pJob->psttLongOuter) , T(pJob->psttLongInner) , tIndent3*/ ) ; // bEqual MIGHT BE RESET DUE TO A PREVIOUS JOB ; THIS CAN HAPPEN DUE TO RACE BETWEEN ME AND THE THREAD THAT PUSHES JOBS ; SOMETIMES compareOoImagesF WILL BE CALLED UNNECESSARILY BUT THIS IS HARMLESS
                //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
                _IO_
            {
            if( pJob->bEqual )
            stJobCompareP.ungrabF( tinP ) ;

            stJobCompareP >> *(countT*)&pJob ;
            ZE( jobCompareOoImagesS* , pJob ) ;

            //}
            //    etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
            //    etThread.traceF( tinP , T("++++ watch") ) ;
            //    bWatching = 1 ;
            //{
            //if( !bWatching )
        {
        while( stJobCompareP )
        //ZE( boolT , bWatching ) ;
        ZE( countT , cDone ) ;
        stJobCompareP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    while( !ether )
    ZE( countT , cIdle ) ;
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    TN( tIndent3 , "|           " ) ;

    countT&       cYearsHealingP                  =       *(countT*)pTaskP->c5 ;
    boolT         bStrictP                        =                 pTaskP->c4 ;
    stackC&       stJobCompareP                =       *(stackC*)pTaskP->c3 ;
    countT&       cPauseP                         =       *(countT*)pTaskP->c2 ;
    boolT&        bAbortP                         =        *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c5 )
TASK( tmWorkerMemCompareF )

countT cWorkersMemCompare ; //U:: WORKAROUND TO DESIGN DEFECT OF etherWhereF

DONE( tmWorkerHealFileF )
}
    stJobHealFileP.ungrabF( tinP ) ;
    }
        stJobHealFileP >> pbz_woJob ;
        byteT* pbz_woJob = (byteT*)&woJob ;
        jobHealFileS woJob ;
    {
    while( stJobHealFileP )
    stJobHealFileP.grabF( tinP , TAG( TAGiDnULL ) ) ;

    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
    }
        stJobHealFileP.ungrabF( tinP ) ;

        }
            stJobHealFileP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            ++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
            if( cYearsHealingP && !( ++ cIdle % ( TUCK >> 4 ) ) ) etThread.traceF( tinP , T("years are healing but i have nothing to do (no heal jobs) [cIdle]:    ")+TF2(cIdle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            stJobHealFileP.ungrabF( tinP ) ;
        {
        if( !cDone )

        //}
        //    etThread.traceF( tinP , T("---- watch") ) ;
        //    etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
        //    bWatching = 0 ;
        //{
        //if( bWatching )

        }
            cDone ++ ;

            stJobHealFileP.grabF( tinP , TAG( TAGiDnULL ) ) ;

            pJob->info.st_pJobHealFileDone.sinkF( tinP , ids , (countT)pJob , flSTACKsINK_UNIQUE , subtractHealFileJobF ) ;
            ZE( countT , ids ) ;

            healFileF( tinP , pJob->info , tShort , bStrictP ) ;
            TN( tShort , pJob->psttShort ) ;

            stJobHealFileP.ungrabF( tinP ) ;

            stJobHealFileP >> pbzJob ;
            byteT* pbzJob = (byteT*)pJob ;

            __Z( pJob ) ;
            etThread.newF( tinP , LF , *(byteT**)&pJob , sizeof( jobHealFileS ) ) ; ___( pJob ) ;
            ZE( jobHealFileS* , pJob ) ;

            //}
            //    etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
            //    etThread.traceF( tinP , T("++++ watch") ) ;
            //    bWatching = 1 ;
            //{
            //if( !bWatching )
        {
        while( stJobHealFileP )
        //ZE( boolT , bWatching ) ;
        ZE( countT , cDone ) ;
        stJobHealFileP.grabF( tinP , TAG( TAGiDnULL ) ) ;
    {
    while( !ether )
    ZE( countT , cIdle ) ;
    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
    ZE( countT , cDoneTotal ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    TN( tIndent3 , "|           " ) ;

    countT&       cYearsHealingP                  =       *(countT*)pTaskP->c5 ;
    boolT         bStrictP                        =                 pTaskP->c4 ;
    stackC&       stJobHealFileP                  =       *(stackC*)pTaskP->c3 ;
    countT&       cPauseP                         =       *(countT*)pTaskP->c2 ;
    boolT&        bAbortP                         =        *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c5 )
TASK( tmWorkerHealFileF )

}
    return pJob1->idName - pJob2->idName ;

    jobHealFileS* pJob2 = (jobHealFileS*)c2P ;
    jobHealFileS* pJob1 = (jobHealFileS*)c1P ;
{
countT _export subtractHealFileJobF( tinNormalS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    //if( !pP.bAbort ) pP.ether.traceF( tinP , T("---- healed  [tShort]:    ")+tShortP ) ;

    }
        //pP.ether.traceF( tinP , T("healing / 00") ) ;
        }
            THREADmODE2rESTORE
            //pP.ether.traceF( tinP , T("healing / 10") ) ;
            }
                //pP.ether.traceF( tinP , T("healing / 20") ) ;
                }
                    }
                        pP.ether.traceF( tinP , T("healed [timeE1,cbUsedMax,cbUsedHighMax,tShort]:    ")+TF3(timeE1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF3(cbUsedMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb+TF3(cbUsedHighMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+tShortP ) ;
                        pP.ether.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO HEAL THIS SHORT NAME
                        pP.ether.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                        ZE( sCountT , timeE2 ) ;
                        ZE( countT  , timeE1 ) ;
                    {
                    if( !pP.bAbort && ( cbUsedHighMax || cbUsedMax > TOCK ) )

                    //pP.ether.traceF( tinP , T("healing / 30") ) ;
                    }
                        //pP.ether.traceF( tinP , T("healing / 40") ) ;
                        }
                            //pP.ether.traceF( tinP , T("healing / 50") ) ;
                            }
                                while( ~hStkMeta ) ;
                                }
                                    DELzOMBIE( pfmOuter ) ;

                                    }
                                        DELzOMBIE( pd ) ;
                                        imageCompareS* pd = picOuter + offd ;
                                    {
                                    for( countT offd = 0 ; offd < pP.cResultStructsNeeded ; offd ++ )

                                    fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + pP.cResultStructsNeeded ) ;
                                    imageCompareS* picOuter  = (imageCompareS*)&stMeta.upF( tinP , hStkMeta ) ;
                                {
                                do
                                handleC hStkMeta( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( stMeta )
                            //pP.ether.traceF( tinP , T("healing / 60") ) ;
                            //pP.ether.traceF( tinP , T("deleting metadata [cPlates]:    ")+TF2(stMeta,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            //pP.ether.traceF( tinP , T("healed  [result,tArchive,tYear,tShort]:    ")+T(pP.bAbort?"aborted    ":"aok    ")+pP.tArchive+tb4+pP.tYear+tb4+tShortP ) ;

                            //pP.ether.traceF( tinP , T("processed  [tShort]:    ")+tShortP ) ;

                            // *********************************************************************************************************************************************************************************************************
                            // *********************************************************************************************************************************************************************************************************
                            // *********************************************************************************************************************************************************************************************************
                            // ****                                                                                                                                  *******************************************************************
                            // ****  END:    COMPARE ALL COPIES OF THIS SHORT FILE NAME.  THIS IS RETRIED UNTIL ALL COMPARISONS COMPLETE WITHOUT AN EXCEPTION EVENT  *******************************************************************
                            // ****                                                                                                                                  *******************************************************************
                            // *********************************************************************************************************************************************************************************************************
                            // *********************************************************************************************************************************************************************************************************
                            // *********************************************************************************************************************************************************************************************************
                        {
                        if( !pP.bAbort )

                        //pP.ether.traceF( tinP , T("healing / 70") ) ;
                        }
                            //pP.ether.traceF( tinP , T("healing / 80") ) ;
                            }
                                // *********************************************************************************************************************************************************************************************************
                                // ****                *************************************************************************************************************************************************************************************
                                // ****  END:    HEAL  *************************************************************************************************************************************************************************************
                                // ****                *************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************

                                //pP.ether.traceF( tinP , T("healing / 90") ) ;
                                }
                                    //pP.ether.traceF( tinP , T("healing / a0") ) ;
                                    }
                                        //pP.ether.traceF( tinP , T("healing / b0") ) ;
                                        }
                                            //pP.ether.traceF( tinP , T("healing / c0") ) ;
                                            }
                                                }
                                                    pP.ether.delF( tinP , psttFrom ) ;
                                                    pP.ether.delF( tinP , psttTo   ) ;

                                                    }
                                                        }
                                                            //if( !pP.bAbort ) pP.ether.traceF( tinP , T("copied [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;

                                                            }
                                                                }
                                                                    }
                                                                        break ;
                                                                        pP.bAbort = 1 ;
                                                                        pP.ether.traceF( tinP , T("!exception:  unexpected impotence copy [POOP,to,from]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                        POOPRqUIET
                                                                    {
                                                                    else
                                                                    }
                                                                        thirdC::dosSleepWinkIF( tinP , 2 ) ;
                                                                        pP.ether.traceF( tinP , T("!exception:  could not copy file ; will retry until fired [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                        POOPRqUIET
                                                                    {
                                                                    else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_ACCESSdENIED )
                                                                    if( !POOP ) break ;
                                                                    tinP.pEtScratch->diskCopyFileF( tinP , psttTo , psttFrom , 1 ) ;
                                                                    SCOOPS
                                                                {
                                                                IFsCRATCH
                                                            {
                                                            while( !etPrime )

                                                            //pP.ether.traceF( tinP , T("copying [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                        {
                                                        else
                                                        }
                                                            pP.ether.traceF( tinP , T("!exception: bizarre!  there is still a file in the way, so not copying [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                            pP.bAbort = 1 ;
                                                        {
                                                        else if( bExists )
                                                        if( pP.bAbort ) pP.ether.traceF( tinP , T("!exception: after rejecting a file out of the way, not copying because could not obtain bExists (probable drive failure) [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;

                                                        }
                                                            }
                                                                pP.bAbort = 1 ;
                                                                pP.ether.traceF( tinP , T("!exception: diskFileExistsF failed FOR psttTol 2 [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                POOPRqUIET
                                                            {
                                                            if( POOP )
                                                            bExists = tinP.pEtScratch->diskFileExistsF( tinP , psttTo ) ;

                                                            SCOOPS
                                                        {
                                                        IFsCRATCH

                                                        // *********************************************************************************************************************************************************************************************************
                                                        // ****                                                  ***************************************************************************************************************************************************
                                                        // ****  COPY AUTHORITATIVE FILE TO WO RECIPIENT VOLUME  ***************************************************************************************************************************************************
                                                        // ****                                                  ***************************************************************************************************************************************************
                                                        // *********************************************************************************************************************************************************************************************************

                                                        }
                                                            pP.ether.delF( tinP , psttLongInRejects ) ;

                                                            else        pP.bAbort = 1 ;
                                                            if( bDone ) pP.ether.traceF( tinP , T("moved [toInRejects,to]:    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;

                                                            }
                                                                }
                                                                    }
                                                                        break ;
                                                                        pP.bAbort = 1 ;
                                                                        pP.ether.traceF( tinP , T("!exception:  unexpected impotence [POOP,toInRejects,to]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;
                                                                        POOPRqUIET
                                                                    {
                                                                    else
                                                                    }
                                                                        thirdC::dosSleepWinkIF( tinP , 2 ) ;
                                                                        pP.ether.traceF( tinP , T("!exception:  could not move file ; will retry until fired [toInRejects,to]:    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;
                                                                        POOPRqUIET
                                                                    {
                                                                    else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_ACCESSdENIED )
                                                                    }
                                                                        break ;
                                                                        bDone = 1 ;
                                                                    {
                                                                    if( !POOP )
                                                                    tinP.pEtScratch->diskMoveFileOrDirF( tinP , psttLongInRejects , psttTo , 1 ) ;
                                                                    SCOOPS
                                                                {
                                                                IFsCRATCH
                                                            {
                                                            while( !etPrime )
                                                            ZE( boolT , bDone ) ;

                                                            pP.ether.strReplaceF( tinP , psttLongInRejects , psttTo , pP.tPathArchives , pP.tPathRejects ) ; ___( psttLongInRejects ) ;
                                                            ZE( strokeS* , psttLongInRejects ) ;
                                                        {
                                                        if( bExists )
                                                    {
                                                    if( !pP.bAbort )

                                                    }
                                                        }
                                                            pP.bAbort = 1 ;
                                                            pP.ether.traceF( tinP , T("!exception: diskFileExistsF failed FOR psttTo [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                            POOPRqUIET
                                                        {
                                                        if( POOP )
                                                        bExists = tinP.pEtScratch->diskFileExistsF( tinP , psttTo ) ;

                                                        SCOOPS
                                                    {
                                                    IFsCRATCH
                                                    ZE( boolT , bExists ) ;

                                                    // *********************************************************************************************************************************************************************************************************
                                                    // ****                                   ******************************************************************************************************************************************************************
                                                    // ****  MOVE TARGET FILE OUT OF THE WAY  ******************************************************************************************************************************************************************
                                                    // ****                                   ******************************************************************************************************************************************************************
                                                    // *********************************************************************************************************************************************************************************************************

                                                    //pP.ether.traceF( tinP , T("new      [psttTo,psttFrom]:    ")+TF2((countT)psttTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)psttFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                                    //pP.ether.traceF( tinP , T("copying [idFrom,to,from]:    ")+TF2(idFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttTo)+tb4+T(psttFrom) ) ;

                                                    pP.ether.strMakeF( tinP , LF , psttFrom , (strokeS*)stFrom[ idFrom ] ) ; ___( psttFrom ) ;
                                                    ZE( strokeS* , psttFrom ) ;

                                                    countT idFrom = 1 + ( cDone ++ % cFrom ) ;

                                                    stTo >> psttTo ;
                                                    ZE( strokeS* , psttTo ) ;
                                                {
                                                while( !pP.bAbort && stTo )
                                                ZE( countT , cDone ) ;
                                                countT cFrom = stFrom ;

                                                // *********************************************************************************************************************************************************************************************************
                                                // ****                                              *******************************************************************************************************************************************************
                                                // ****  COPY AUTHORITATIVE FILES TO TARGET VOLUMES  *******************************************************************************************************************************************************
                                                // ****                                              *******************************************************************************************************************************************************
                                                // *********************************************************************************************************************************************************************************************************
                                            {
                                            if( !pP.bAbort )
                                            pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                            //pP.ether.traceF( tinP , T("healing / d0") ) ;

                                            while( !pP.bAbort && ~hStPathToYear ) ;
                                            }
                                                }
                                                    if( !idSlot ) pP.ether.delF( tinP , psttLong ) ;
                                                    stTo.sinkF( tinP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ;
                                                    ZE( countT , idSlot ) ;
                                                    //pP.ether.traceF( tinP , T("sinking to stTo 2 [long]:    ")+T(psttLong) ) ;
                                                {
                                                else
                                                if( stFrom( psttLong ) ) pP.ether.delF( tinP , psttLong ) ;

                                                pP.ether.strMakeF( tinP , LF , psttLong , T(psttPathToYear)+tShortP ) ; ___( psttLong ) ;
                                                ZE( strokeS* , psttLong ) ;

                                                strokeS* psttPathToYear = (strokeS*)pP.stPathToYear.downF( tinP , hStPathToYear ) ;
                                            {
                                            do
                                            handleC hStPathToYear( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            //pP.ether.traceF( tinP , T("healing / e0") ) ;

                                            // *********************************************************************************************************************************************************************************************************
                                            // ****                                            *********************************************************************************************************************************************************
                                            // ****  LOAD stTo WITH LONG FILE NAMES NOT FOUND  *********************************************************************************************************************************************************
                                            // ****                                            *********************************************************************************************************************************************************
                                            // *********************************************************************************************************************************************************************************************************

                                            while( !pP.bAbort && ~hStUnique ) ;
                                            }
                                                }
                                                    while( ~hStkInner ) ;
                                                    }
                                                        }
                                                            if( !idSlot ) pP.ether.delF( tinP , psttLong ) ;
                                                            }
                                                                stTo.sinkF( tinP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                                //pP.ether.traceF( tinP , pP.tIndent3+T("sunk into stTo [cPlatesBefore,long]:    ")+TF2(stTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                            {
                                                            else
                                                            }
                                                                stFrom.sinkF( tinP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                                //pP.ether.traceF( tinP , pP.tIndent3+T("sunk into stFrom [cPlatesBefore,long]:    ")+TF2(stFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                            {
                                                            if( bYoungestNotAlone && bWinner )
                                                            ZE( countT , idSlot ) ;

                                                            pP.ether.strMakeF( tinP , LF , psttLong , T((strokeS*)pP.stPathToYear[pfmInner->idSlotPathToYear])+tShortP ) ; ___( psttLong ) ;
                                                            ZE( strokeS* , psttLong ) ;
                                                        {
                                                        if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) )

                                                        }
                                                            }
                                                                break ;
                                                                bMatchImage = 0 ;
                                                            {
                                                            if( picUnique[ offc ] - picInner[ offc ] )
                                                        {
                                                        for( countT offc = 0 ; offc < pP.cResultStructsNeeded ; offc ++ )
                                                        boolT bMatchImage = 1 ;

                                                        //picInner->traceF( tinP , pP.tIndent3+T("inner :    ") ) ;
                                                        fileMetaS*     pfmInner = (fileMetaS*)( picInner + pP.cResultStructsNeeded ) ;
                                                        imageCompareS* picInner  = (imageCompareS*)&stMeta.upF( tinP , hStkInner ) ;
                                                    {
                                                    do
                                                    handleC hStkInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                {

                                                //pfmUnique->traceF( tinP , pP.stPathToYear , T(bYoungestNotAlone?"reporting tallies (youngestNotAlone):    ":"reporting tallies            (other):    ") ) ;

                                                //pP.ether.traceF( tinP , pP.tIndent2+T("[bYoungestNotAlone,bWinner,cVotes]:    ")+TF2(bYoungestNotAlone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bWinner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pfmUnique->cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                boolT bWinner           = pfmUnique->cVotes         == cVotesMaxYoungestNotAlone      ;
                                                boolT bYoungestNotAlone = pfmUnique->timeModRounded == timeModRoundedYoungestNotAlone ;

                                                //for( countT offc = 0 ; offc < pP.cResultStructsNeeded ; offc ++ ) picUnique[ offc ].traceF( tinP , pP.tIndent3+T("reporting tallies:    ") ) ;

                                                //picUnique->traceF( tinP , pP.tIndent2+T("unique:    ") ) ;
                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hStUnique ) ;
                                            {
                                            do
                                            handleC hStUnique( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            stackC stTo(     tinP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                                            stackC stFrom(   tinP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

                                            // *********************************************************************************************************************************************************************************************************
                                            // ****                                               ******************************************************************************************************************************************************
                                            // ****  LOAD stTo stFrom WITH LONG FILE NAMES FOUND  ******************************************************************************************************************************************************
                                            // ****                                               ******************************************************************************************************************************************************
                                            // *********************************************************************************************************************************************************************************************************
                                            //pP.ether.traceF( tinP , T("healing / f0") ) ;
                                        {
                                        else
                                        }
                                            //pP.ether.traceF( tinP , T("healing / 01") ) ;
                                            while( !pP.bAbort && ~hStkInner ) ;
                                            }
                                                pP.ether.delF( tinP , psttLongFrom ) ;
                                                pP.ether.delF( tinP , psttLongTo   ) ;

                                                }
                                                    }
                                                        if( !etPrime ) pP.bAbort = 1 ;
                                                        pP.ether.traceF( tinP , pP.tIndent3+T("!exception:  i never could move file and either i am now fired or i encountered an unexpected impotence, so will purge the pending jobs and fire myself [to,from]:    ")+T(psttLongTo)+T("    ")+T(psttLongFrom) ) ;
                                                    {
                                                    else
                                                    if( bDone ) pP.ether.traceF( tinP , T("moved [to,from]:    ")+T(psttLongTo)+T("    ")+T(psttLongFrom) ) ;

                                                    }

                                                        }
                                                            }
                                                                break ;
                                                                pP.ether.traceF( tinP , pP.tIndent3+T("!exception:  unexpected impotence [POOP,to,from]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttLongTo)+T("    ")+T(psttLongFrom) ) ;
                                                                POOPRqUIET
                                                            {
                                                            else
                                                            }
                                                                thirdC::dosSleepWinkIF( tinP , 2 ) ;
                                                                pP.ether.traceF( tinP , pP.tIndent3+T("!exception:  could not move file ; will retry until fired [to,from]:    ")+T(psttLongTo)+T("    ")+T(psttLongFrom) ) ;
                                                                POOPRqUIET
                                                            {
                                                            else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_ACCESSdENIED )
                                                            }
                                                                break ;
                                                                bDone = 1 ;
                                                            {
                                                            if( !POOP )
                                                            tinP.pEtScratch->diskMoveFileOrDirF( tinP , psttLongTo , psttLongFrom , 1 ) ;
                                                            SCOOPS
                                                        {
                                                        IFsCRATCH
                                                    {
                                                    while( !etPrime )
                                                    ZE( boolT , bDone ) ;
                                                {

                                                pP.ether.strReplaceF( tinP , psttLongTo , psttLongFrom , pP.tPathArchives , !bLonely ? pP.tPathRejects : pP.tPathLonely ) ; ___( psttLongTo ) ;
                                                ZE( strokeS* , psttLongTo ) ;
                                                //P:PERSONALITY: LONELY FILES (ONLY 1 COPY) ARE MOVED OUT OF ARCHIVE INTO A "LONELY" DIRECTORY

                                                pP.ether.strMakeF( tinP , LF , psttLongFrom , T((strokeS*)pP.stPathToYear[pfmInner->idSlotPathToYear])+tShortP ) ; ___( psttLongFrom ) ;
                                                ZE( strokeS* , psttLongFrom ) ;

                                                fileMetaS*     pfmInner = (fileMetaS*)( picInner + pP.cResultStructsNeeded ) ;
                                                imageCompareS* picInner  = (imageCompareS*)&stMeta.upF( tinP , hStkInner ) ;
                                            {
                                            do
                                            handleC hStkInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                            pP.ether.traceF( tinP , pP.tIndent1+T("no, or too many (more than 1), winners (authoritative copies) so i will move all copies [bLonely,file]:    ")+TF2(bLonely,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;
                                            boolT bLonely = cCopies <= 1 ;
                                            //pP.ether.traceF( tinP , T("healing / 11") ) ;

                                            // *********************************************************************************************************************************************************************************************************
                                            // ****                                         ************************************************************************************************************************************************************
                                            // ****  NO UNIQUE WINNER SO REJECT ALL COPIES  ************************************************************************************************************************************************************
                                            // ****                                         ************************************************************************************************************************************************************
                                            // *********************************************************************************************************************************************************************************************************
                                        {
                                        if( !cWinners || cWinners > 1 )
                                    {
                                    if( !pP.bAbort )
                                    pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                    //pP.ether.traceF( tinP , T("healing / 21") ) ;

                                    }
                                        while( !pP.bAbort && ~hSt ) ;
                                        }
                                            cWinners ++ ;
                                            )
                                                pfmUnique->cVotes == cVotesMaxYoungestNotAlone
                                                &&
                                                timeModRoundedYoungestNotAlone == pfmUnique->timeModRounded
                                            (
                                            if

                                            //picUnique->traceF( tinP , pP.tIndent2+T("unique:    ") ) ;
                                            fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                            imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                                        {
                                        do
                                        handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    if( !pP.bAbort && cVotesMaxYoungestNotAlone )        // IF ALL ARE ALONE THEN THERE WILL BE NO WINNER
                                    ZE( countT , cWinners ) ;
                                    //pP.ether.traceF( tinP , T("healing / 31") ) ;

                                    // RULE; TO WIN, A SLOT MUST HAVE A "YOUNGEST NOT ALONE" AGE AND BE "NOT ALONE" AND HAVE THE MAXIMUM VOTES FOR SLOTS YOUNGEST AND NOT ALONE
                                    //P:PERSONALITY: RULES FOR "WINNING": A stRecUnique SLOT "WINNING" MEANS THAT THE SLOT IS DEEMED TO BE AN AUTHORITATIVE IMAGE FOR THE FILE

                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                  ***********************************************************************************************************************************************************************************
                                    // ****  TALLY cWinners  ***********************************************************************************************************************************************************************************
                                    // ****                  ***********************************************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************

                                    }
                                        while( !pP.bAbort && ~hSt ) ;
                                        }
                                            }
                                                if( pfmUnique->cVotes > 1 && cVotesMaxYoungestNotAlone < pfmUnique->cVotes ) cVotesMaxYoungestNotAlone = pfmUnique->cVotes ;
                                            {
                                            if( timeModRoundedYoungestNotAlone == pfmUnique->timeModRounded )

                                            }
                                                if(                          cVotesMaxYoungest         < pfmUnique->cVotes ) cVotesMaxYoungest         = pfmUnique->cVotes ;
                                            {
                                            if( timeModRoundedYoungest == pfmUnique->timeModRounded )

                                            //picUnique->traceF( tinP , pP.tIndent2+T("unique:    ") ) ;
                                            fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                            imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                                        {
                                        do
                                        handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    if( !pP.bAbort && timeModRoundedYoungestNotAlone )        // IF ALL ARE ALONE THEN THERE WILL BE NO WINNER
                                    ZE( countT , cVotesMaxYoungestNotAlone ) ;
                                    ZE( countT , cVotesMaxYoungest ) ;
                                    //pP.ether.traceF( tinP , T("healing / 41") ) ;

                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                                                          *******************************************************************************************************************************************
                                    // ****  ACCUMULATE cVotesMaxYoungest cVotesMaxYoungestNotAlone  *******************************************************************************************************************************************
                                    // ****                                                          *******************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************

                                    }
                                        while( !pP.bAbort && ~hSt ) ;
                                        }
                                            if( pfmUnique->cVotes > 1 && timeModRoundedYoungestNotAlone < pfmUnique->timeModRounded ) timeModRoundedYoungestNotAlone = pfmUnique->timeModRounded ;

                                            fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                            imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                                        {
                                        do
                                        handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    if( !pP.bAbort )
                                    ZE( countT , timeModRoundedYoungestNotAlone ) ;
                                    // SET timeModRoundedYoungestNotAlone

                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                                             ********************************************************************************************************************************************************
                                    // ****  ACCUMULATE timeModRoundedYoungestNotAlone  ********************************************************************************************************************************************************
                                    // ****                                             ********************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************
                                    //pP.ether.traceF( tinP , T("healing / 51") ) ;

                                    }
                                        while( !pP.bAbort && ~hSt ) ;
                                        }
                                            while( ~hStkInner ) ;
                                            }
                                                }
                                                    //pP.ether.traceF( tinP , pP.tIndent3+T("    [cVotes.after]:    ")+TF2(pfmUnique->cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    pfmUnique->cVotes ++ ;
                                                {
                                                if( bMatchImage && !bFileMetaDiffer )

                                                //pP.ether.traceF( tinP , pP.tIndent3+T(bFileMetaDiffer?"    file meta differ":"    file meta are the same") ) ;
                                                boolT bFileMetaDiffer = *pfmUnique - *(fileMetaS*)pfmInner ;

                                                //pP.ether.traceF( tinP , pP.tIndent3+T(bMatchImage?"    image matches":"    image does not match") ) ;
                                                }
                                                    }
                                                        break ;
                                                        bMatchImage = 0 ;
                                                    {
                                                    if( picUnique[ offc ] - picInner[ offc ] )
                                                {
                                                for( countT offc = 0 ; offc < pP.cResultStructsNeeded ; offc ++ )
                                                boolT bMatchImage = 1 ;

                                                //}
                                                //    pfmInner->traceF( tinP , pP.stPathToYear , pP.tIndent3+T("inner : ") ) ;
                                                //    picInner->traceF( tinP , pP.tIndent3+T("inner :    ") ) ;
                                                //{
                                                //if( bChatter )
                                                fileMetaS*     pfmInner = (fileMetaS*)( picInner + pP.cResultStructsNeeded ) ;
                                                imageCompareS* picInner  = (imageCompareS*)&stMeta.upF( tinP , hStkInner ) ;
                                            {
                                            do
                                            handleC hStkInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                            if( timeModRoundedYoungest < pfmUnique->timeModRounded ) timeModRoundedYoungest = pfmUnique->timeModRounded ;

                                            //}
                                            //    pfmUnique->traceF( tinP , pP.stPathToYear , pP.tIndent2+T("unique: ") ) ;
                                            //    picUnique->traceF( tinP , pP.tIndent2+T("unique:    ") ) ;
                                            //{
                                            //if( bChatter )
                                            fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                            imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                                            //pP.ether.traceF( tinP , pP.tIndent2+T("tallying votes for a particular image") ) ;
                                        {
                                        do
                                        handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    ZE( countT , timeModRoundedYoungest ) ;
                                    // TALLY cVotes AND SET timeModRoundedYoungest

                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                                                   **************************************************************************************************************************************************
                                    // ****  ACCUMULATE timeModRoundedYoungest ; TALLY VOTES  **************************************************************************************************************************************************
                                    // ****                                                   **************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************
                                    //pP.ether.traceF( tinP , T("healing / 61") ) ;

                                    }
                                        bChatter = 1 ;
                                        pP.ether.traceF( tinP , pP.tIndent1+T("lengths or times or images differ [tShort]:    ")+tShortP ) ;
                                    {
                                    if( stRecUnique > 1 )
                                    ZE( boolT , bChatter ) ;
                                {
                                else                            // EVEN IF THERE IS ONLY WO PLATE, THERE IS STILL WORK TO DO BECAUSE THE FILE MIGHT NEED TO BE COPIED TO DESTINATIONS THAT DON'T HAVE IT
                                }
                                    pP.bAbort = 1 ;
                                    pP.ether.traceF( tinP , T("!exception: stRecUnique is empty") ) ;
                                {
                                if( !stRecUnique ) //SHOULD  BE IMPOSSIBLE

                                while( ~hStkOuter ) ;
                                do stRecUnique.sinkF( tinP , countTC() , (byteT*)&stMeta.upF( tinP , hStkOuter ) , flSTACKsINK_UNIQUE , subtractFileMetaF ) ;
                                stackC stRecUnique( tinP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , pP.stPathToYear * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ;
                                handleC hStkOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                // *********************************************************************************************************************************************************************************************************
                                // ****                *************************************************************************************************************************************************************************************
                                // ****  BEGIN:  HEAL  *************************************************************************************************************************************************************************************
                                // ****                *************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                //pP.ether.traceF( tinP , T("healing / 71") ) ;
                            {
                            if( !pP.bAbort )
                            pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                            //pP.ether.traceF( tinP , T("healing / 81") ) ;
                        {
                        if( !etPrime && cCopies )
                        //pP.ether.traceF( tinP , pP.tIndent1+T("[cFound,file]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postzShort) ) ;

                        // PHASE 4: COPY TO ALL ARCHIVE CONTAINERS THAT DO NOT HAVE A COPY OF THIS FILE NAME
                        // PHASE 3: OVERWRITE ALL COPIES THAT DO NOT MATCH THIS UNIQUE META
                        // PHASE 2: IS THIS UNIQUE META VERIFIED (cVotes > 1)?
                        // PHASE 1: IDENTIFY THE UNIQUE META WITH THE LATEST FILE DATE
                        // HEALING ACTION HAS PHASES
                        // COMPARE AND FILE META FOR THIS FILE ARE SET AND READY FOR ANALYSIS AND HEALING ACTION
                        // THESE COMMENTS ARE OBSOLETED BY ACTUAL CODE WHICH CONTRADICTS THEM
                    {
                    if( !pP.bAbort )

                    while( !etPrime && !pP.bAbort && ~hStkOuter ) ;
                    }
                        //pP.ether.traceF( tinP , T("healing / 91") ) ;
                        // *********************************************************************************************************************************************************************************************************
                        // ****                                      ***************************************************************************************************************************************************************
                        // ****  END:    FOR EACH COPY OF THIS FILE  ***************************************************************************************************************************************************************
                        // ****                                      ***************************************************************************************************************************************************************
                        // *********************************************************************************************************************************************************************************************************

                        pP.ether.delF( tinP ,            pcBitsShiftLeftHeInMine ) ;
                        pP.ether.delF( tinP ,            pcBitsShiftLeftMeInHis  ) ;
                        pP.ether.delF( tinP , *(byteT**)&ppIdResultHeInMine      ) ;
                        pP.ether.delF( tinP , *(byteT**)&ppIdResultMeInHis       ) ;
                        pP.ether.delF( tinP ,            pcbwInner               ) ;
                        pP.ether.delF( tinP , *(byteT**)&ppbwInner               ) ;

                        }
                            //pP.ether.traceF( tinP , T("healing / a1") ) ;
                            deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                            //pP.ether.traceF( tinP , T("healing / b1") ) ;

                            }
                                //pP.ether.traceF( tinP , T("healing / c1") ) ;
                                }
                                    }
                                        while( ~hStkEqual ) ;
                                        }
                                            //picHe->traceF( tinP , pP.tIndent3+T("he is equal (after) :") ) ;
                                            pP.ether.memCopyF( tinP , (byteT*)picHe , (byteT*)picOuter , sizeof( imageCompareS ) * pP.cResultStructsNeeded ) ;
                                            //picHe->traceF( tinP , pP.tIndent3+T("he is equal (before):") ) ;
                                            imageCompareS* picHe = (imageCompareS*)&stMeta[ cMeta - idHeIsEqual + 1 ] ;

                                            //pP.ether.traceF( tinP , pP.tIndent3+T("[heIsEqual]:    ")+TF2(idHeIsEqual,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            countT idHeIsEqual = stHeIsEqual.downF( tinP , hStkEqual ) ;
                                        {
                                        do
                                        handleC hStkEqual( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    if( !pP.bAbort )

                                    }
                                        //pP.ether.traceF( tinP , pP.tIndent3+T("[idInner,resultHeInMine]:    ")+TF2(1+offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tResultHeInMine ) ;
                                    
                                        //}
                                        //    case BITSrESULT_ALLbITS  : { tResultHeInMine = T("allBits")  ; break ; }
                                        //    case BITSrESULT_EQUAL    : { tResultHeInMine = T("equal")    ; break ; }
                                        //    case BITSrESULT_NOTeQUAL : { tResultHeInMine = T("notEqual") ; break ; }
                                        //    case BITSrESULT_UNKNOWN  : { tResultHeInMine = T("unknown")  ; break ; }
                                        //{
                                        //switch( resultHeInMine )
                                        //TN( tResultHeInMine , "" ) ;

                                        }
                                    
                                            if( !ids ) { BLAMMO }
                                            stHeIsEqual.sinkF( tinP , ids , 1 + offi , flSTACKsINK_UNIQUE ) ;
                                            ZE( countT , ids ) ;
                                        {
                                        if( resultHeInMine == BITSrESULT_EQUAL )
                                    
                                        countT  resultHeInMine         = ( bitsResultHeInMine & maskHeInMine ) >> cBitsShiftLeftHeInMine ;
                                        countT  maskHeInMine           = BITSrESULT_ALLbITS << cBitsShiftLeftHeInMine ;
                                        countT  cBitsShiftLeftHeInMine =         ( offi % cResultsPerStruct ) << 1 ;
                                        countT& bitsResultHeInMine     = picOuter[ offi / cResultsPerStruct ].bitsResult ;
                                    {
                                    for( countT offi = 0 ; !pP.bAbort && offi < cMeta ; offi ++ )
                                    countT cMeta = stMeta ;
                                    stackC stHeIsEqual( tinP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE ) ;

                                    //picOuter->traceF( tinP , pP.tIndent2+T("outer (mine):") ) ;

                                    //pP.ether.traceF( tinP , pP.tIndent2+T("transitivity: copying my results to other rows [idSlotPathToYearOuter]:    ")+TF2(idSlotPathToYearOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                {
                                if( !pP.bAbort )
                                //SET OTHER RESULTS TO EXPLOIT TRANSITIVITY (A COPY THAT IS EQUAL TO ME RECEIVES ALL OF MY RESULTS)
                                //pP.ether.traceF( tinP , T("healing / d1") ) ;

                                //while( ~hStkInner ) ;
                                //}
                                //    picInner->traceF( tinP , T("after comparing inners with [tLongOuter]:    ")+tLongOuter ) ;
                                //    imageCompareS* picInner = (imageCompareS*)&stMeta.upF( tinP , hStkInner ) ;
                                //{
                                //do
                                //handleC hStkInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                }
                                    //pP.ether.traceF( tinP , pP.tIndent3+T(pEqual[offo]?"        set other and myself to BITSrESULT_EQUAL because images match [offo]:    ":"        set other and myself to BITSrESULT_NOTeQUAL because images differ [offo]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    }
                                        //pP.ether.traceF( tinP , pP.tIndent3+T("after  [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                        *ppIdResultMeInHis[  offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftMeInHis[  offo ] ;
                                        *ppIdResultHeInMine[ offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftHeInMine[ offo ] ;
                                        //pP.ether.traceF( tinP , pP.tIndent3+T("before [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                    {
                                    else
                                    }
                                        *ppIdResultMeInHis[  offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftMeInHis[  offo ] ;
                                        *ppIdResultHeInMine[ offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftHeInMine[ offo ] ;
                                    {
                                    if( pEqual[ offo ] )
                                {
                                for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ )
                                //pP.ether.traceF( tinP , T("healing / e1") ) ;
                            {
                            if( !pP.bAbort )

                            //if( pcz_bUseWorkers ) *pcz_bUseWorkers = 0 ;

                            THREADmODE2rESTORE
                            }
                                //pP.ether.traceF( tinP , T("healing / f1") ) ;
                                //pP.ether.delF( tinP , *(byteT**)&pfwsOuter ) ;
                                //pP.ether.traceF( tinP , pP.tIndent2+T("del [pfwsOuter]:    ")+TF3((countT)pfwsOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;

                                }
                                    }
                                        break ;
                                        deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                        pP.bAbort = 1 ;
                                        pP.ether.traceF( tinP , pP.tIndent2+T("!exception: could not dt pfwsOuter [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                                        POOPRqUIET
                                    {
                                    if( POOP )
                                    DEL( pfwsOuter ) ;
                                    SCOOPS
                                {

                                }
                                    break ;
                                    deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                    pP.bAbort = 1 ;
                                    pP.ether.traceF( tinP , pP.tIndent2+T("!exception [cbUsed,cbDone]:    ")+TT(pcbUsed[0],pcbUsed[1])+tb4+TT(pcbDone[0],pcbDone[1])+tb4+tLongOuter ) ;
                                    countT* pcbDone = (countT*)&cbDone ;
                                    countT* pcbUsed = (countT*)&pfmOuter->cbUsed ;
                                {
                                if( cbDone != pfmOuter->cbUsed ) //SHOULD BE IMPOSSIBLE

                                if( pP.bAbort ) break ;
                                if( etPrime   ) pP.bAbort = 1 ;
                                //pP.ether.traceF( tinP , T("healing / 02") ) ;

                                }
                                    //pP.ether.traceF( tinP , T("healing / 12") ) ;
                                    cbDone += cbwOuter ;

                                    if( pP.bAbort ) break ;

                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>

                                    //pP.ether.traceF( tinP , T("healing / 22") ) ;
                                    }
                                        //U::USE THIS AFTER ADDING A FLAG TO DISABLE SPINLOCK TEST: thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) , 0 ) ;
                                        Sleep( 0 ) ; //U::
                                        //++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
                                        //pP.ether.traceF( tinP , T("waiting for pending jobs [cJobsPendingCompare]:    ")+TF2(cJobsPendingCompare,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    {
                                    while( cJobsPendingCompare )
                                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                                    //pP.ether.traceF( tinP , T("healing / 32") ) ;

                                    }
                                        }
                                            //pP.ether.traceF( tinP , T("healing / 42") ) ;
                                            //pcbwInner[ offi ] = 0 ;  // TELLS TO GET ANOTHER WINDOW
                                            //ppbwInner[ offi ] = 0 ;
                                            //20230623@0922: CONJ: THIS CODE IS OBSOLETE AND HAS NO EFFECT

                                            }
                                                break ;
                                                deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                            {
                                            if( pP.bAbort )

                                            }
                                                }
                                                    pP.stJobCompare.sinkF( tinP , countTC() , (countT)pJob , flSTACKsINK_null , subtract_jobCompareOoImagesS_F , 0 ) ;                                                    
                                                    jobCompareOoImagesS* pJob = new( 0 , tinP , LF ) jobCompareOoImagesS( tinP , pP.ether , cJobsPendingCompare , pEqual[ offi ] , pbwOuter , ppbwInner[ offi ] , cbwOuter , tLongOuter , T(pfwsInner[offi]) , cbUsedMax04 ) ; ___( pJob ) ;

                                                    }
                                                        }
                                                            }
                                                                ++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
                                                                pP.ether.traceF( tinP , T("napping: a large file is being processed and i am even larger [cbUsedMax04,cbPendingMax04]:    ")+TF3((countT)cbUsedMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tDot+TF3(((countT*)&cbUsedMax04)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF3((countT)cbPendingMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tDot+TF3(((countT*)&cbPendingMax04)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                                                                if( !bNapped ) bNapped = 1 ;
                                                            {
                                                            else
                                                            }
                                                                break ;
                                                                if( bNapped ) pP.ether.traceF( tinP , T("no longer napping: a large file was being processed and i was even larger [cbUsedMax04,cbPendingMax04]:    ")+TF3((countT)cbUsedMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tDot+TF3(((countT*)&cbUsedMax04)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF3((countT)cbPendingMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tDot+TF3(((countT*)&cbPendingMax04)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                                                            {
                                                            if( !cbPendingMax04 || cbPendingMax04 > cbUsedMax04 )

                                                            pP.stJobCompare.ungrabF( tinP ) ;
                                                            }
                                                                cbPendingMax04 = topJob.cbUsedMax04 ;
                                                                jobCompareOoImagesS& topJob = *(jobCompareOoImagesS*)pP.stJobCompare[ 1 ] ;
                                                            {
                                                            if( pP.stJobCompare )
                                                            pP.stJobCompare.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                                            ZE( count04T , cbPendingMax04 ) ;
                                                        {
                                                        while( pP.stJobCompare )
                                                        ZE( boolT , bNapped ) ;
                                                    {
                                                    // IF A VERY LARGE FILE IS BEING PROCESSED AND I AM EVEN LARGER, WAIT BEFORE PUSHING
                                                {
                                                else
                                                }
                                                    compareOoImagesF( tinP , pP.ether , pP.bAbort , pP.cPause , pEqual[ offi ] , bStrictP , pbwOuter , ppbwInner[ offi ] , cbwOuter /*U::, tLongOuter , T(pfwsInner[offi]) , pP.tIndent3*/ ) ;
                                                    if( !pEqual[ offi ] ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE BECAUSE THIS FILE IS BEING COMPARED SYNCHRONOUSLY
                                                {
                                                if( !bLargeFile )

                                                }
                                                    //pP.ether.traceF( tinP , pP.tIndent3+T("comparing oo images [cWindows,idWindow,perTuck,offi]:    ")+TF2((countT)cWindows,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tPerTuck+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    //countT perTuck = (countT)( ( idWindow << 8 ) / cWindows ) ;
                                                {
                                                if( bChatter )
                                            {
                                            if( pEqual[ offi ] )    // DON'T COMPARE BYTES IF ALREADY KNOW THAT A PREVIOUS WINDOW DIDN'T MATCH

                                            }
                                                break ;
                                                deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                            {
                                            if( pP.bAbort )
                                            pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;

                                            // *********************************************************************************************************************************************************************************************************
                                            // ****                                                      ***********************************************************************************************************************************************
                                            // ****  COMPARE WINDOWS BYTE BY BYTE TO SET pEqual[ offi ]  ***********************************************************************************************************************************************
                                            // ****                                                      ***********************************************************************************************************************************************
                                            // *********************************************************************************************************************************************************************************************************
                                            //pP.ether.traceF( tinP , T("healing / 52") ) ;
                                        {
                                        else
                                        }
                                            }
                                                break ;
                                                //pP.ether.traceF( tinP , pP.tIndent3+T("done inspecting images [cInnerImagesToInspect,cImagesInspected,cWindows,idWindow]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cImagesInspected,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)cWindows,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            if( ++ cImagesInspected == cInnerImagesToInspect )
                                        {
                                        if( !pbwOuter || !cbwOuter )

                                        }
                                            break ;
                                            deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                            pP.bAbort = 1 ;
                                            pP.ether.traceF( tinP , pP.tIndent3+T("!exception: preliminary checks (before byte by byte comparison) failed ; aborting [tLongOuter,tLongInner]:    ")+tLongOuter+tb4+T(pfwsInner[offi]) ) ;
                                        {
                                        )
                                              cbwOuter !=   pcbwInner[ offi ]
                                            ||
                                            !!cbwOuter != !!pcbwInner[ offi ]
                                            ||
                                            !!pbwOuter != !!ppbwInner[ offi ]
                                        (
                                        if

                                        //pP.ether.traceF( tinP , pP.tIndent3+T("fed this [(countT)ppbwInner[offi],ppbwInner[offi]]:    ")+TF3((countT)ppbwInner[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+T(ppbwInner[offi]) ) ;

                                        // *********************************************************************************************************************************************************************************************************
                                        // ****                            *************************************************************************************************************************************************************************
                                        // ****  ABORT IF LENGTH MISMATCH  *************************************************************************************************************************************************************************
                                        // ****                            *************************************************************************************************************************************************************************
                                        // *********************************************************************************************************************************************************************************************************
                                        //pP.ether.traceF( tinP , T("healing / 62") ) ;

                                        }
                                            }
                                                break ;
                                                deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;

                                                }
                                                    etRock.traceF( tinP , pP.tIndent3+T("!exception: could not get inner file window (not enough memory) ; traced  pool tallies and memory grain report") ) ;
                                                    etRock.traceMemoryGrainRptF( tinP ) ;
                                                    etRock.tracePoolTalliesF( tinP ) ;
                                                    etRock.traceF( tinP , pP.tIndent3+T("!exception: could not get inner file window (not enough memory) ; tracing pool tallies and memory grain report") ) ;
                                                    etherC& etRock = etherC::etRockIF( tinP ) ;
                                                {
                                                if( save == ifcIDiMPOTENCEbASEeRRORcODE_NOTeNOUGHmEMORY )

                                                pP.bAbort = 1 ;
                                                pP.ether.traceF( tinP , pP.tIndent3+T("!exception:  pfwsInner[ offi ].getF ; aborting [idInner,tLongInner]:    ")+TF2(offi+1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(pfwsInner[offi]) ) ;

                                                POOPRqUIET
                                                countT save = POOP ;
                                            {
                                            if( POOP )

                                            pfwsInner[ offi ].getF( tinP , ppbwInner[ offi ] , pcbwInner[ offi ] , cbFileWindow ) ;
                                            pcbwInner[ offi ] = 0 ;
                                            ppbwInner[ offi ] = 0 ;

                                            SCOOPS
                                        {
                                        IFsCRATCH
                                        //pP.ether.traceF( tinP , T("healing / 72") ) ;

                                        //pP.ether.traceF( tinP , pP.tIndent3+T("     inner [idWindow,tLongInner]:    ")+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE)+tb4+T(pfwsInner[offi]) ) ;

                                        // *********************************************************************************************************************************************************************************************************
                                        // ****                       ******************************************************************************************************************************************************************************
                                        // ****  GET AN INNER WINDOW  ******************************************************************************************************************************************************************************
                                        // ****                       ******************************************************************************************************************************************************************************
                                        // *********************************************************************************************************************************************************************************************************
                                    {
                                    for( countT offi = 0 ; !pP.bAbort && offi < cInnerImagesToInspect ; offi ++ )
                                    ZE( countT , cJobsPendingCompare ) ;
                                    //pP.ether.traceF( tinP , T("healing / 82") ) ;

                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                    // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>

                                    }
                                        }
                                            break ;
                                            deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;

                                            }
                                                etRock.traceF( tinP , pP.tIndent2+T("!exception: could not get outer file window (not enough memory) ; traced  pool tallies and memory grain report") ) ;
                                                etRock.traceMemoryGrainRptF( tinP ) ;
                                                etRock.tracePoolTalliesF( tinP ) ;
                                                etRock.traceF( tinP , pP.tIndent2+T("!exception: could not get outer file window (not enough memory) ; tracing pool tallies and memory grain report") ) ;
                                                etherC& etRock = etherC::etRockIF( tinP ) ;
                                            {
                                            if( save == ifcIDiMPOTENCEbASEeRRORcODE_NOTeNOUGHmEMORY )

                                            pP.bAbort = 1 ;
                                            pP.ether.traceF( tinP , pP.tIndent2+T("!exception:  pfwsOuter->getF ; aborting [tLongOuter]:    ")+T(*pfwsOuter) ) ;

                                            POOPRqUIET
                                            countT save = POOP ;
                                        {
                                        if( POOP )
                                        pfwsOuter->getF( tinP , pbwOuter , cbwOuter , cbFileWindow ) ;
                                        SCOOPS
                                    {
                                    IFsCRATCH
                                    ZE( countT , cbwOuter ) ;
                                    ZE( byteT* , pbwOuter ) ;

                                    //TN( tLikeInner , "///ideafarm/tmp/debug.inner." ) ; tLikeInner += TF3((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot ;
                                    //TN( tLikeOuter , "///ideafarm/tmp/debug.outer." ) ; tLikeOuter += TF3((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;

                                    //pP.ether.traceF( tinP , pP.tIndent2+T("outer      [idWindow,tLongOuter]:    ")+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE)+tb4+T(*pfwsOuter) ) ;

                                    }
                                        }
                                            }
                                                ++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
                                                if( !( idIn % TUCK ) ) pP.ether.traceF( tinP , T("napping: too many pending job bytes [idIn]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                countT idIn = 1 + incv02AM( idInLath ) ;
                                            {
                                            else
                                            if( cbAll < cProcessors * ( CBfILEwINDOW << 2 ) ) break ;       // EACH JOB WILL OCCUPY UP TO ( CBfILEwINDOW << 1 ), SO THE THRESHOLD HERE IS 2 JOBS PER PROCESSOR ; IF NECESSARY, REDUCE CBfILEwINDOW ; GOAL IS TO PEG CPU
                                            static countT idInLath ;

                                            //pP.ether.traceF( tinP , T("pending jobs [cbAll,cPlates]:    ")+TF2(cbAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)pP.stJobCompare,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            //pP.stJobCompare.ungrabF( tinP ) ;
                                            //}
                                            //    while( ~hStk ) ;
                                            //    }
                                            //        cbAll += woJob ;
                                            //        jobCompareOoImagesS& woJob = *(jobCompareOoImagesS*)pP.stJobCompare.upF( tinP , hStk ) ;
                                            //    {
                                            //    do
                                            //    handleC hStk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            //{
                                            //if( pP.stJobCompare )
                                            //pP.stJobCompare.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                            //ZE( countT , cbAll ) ;
                                            //COMMENTED OUT TO AVOID COST

                                            countT cbAll = pP.stJobCompare * ( CBfILEwINDOW << 1 ) ;
                                        {
                                        while( pP.stJobCompare )
                                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                                    {

                                    //if( cWindowsMax > 1/*( TUCK >> 4 )*/ ) pP.ether.traceF( tinP , T("processing window of large file [cWindowsMax,idWindow,tShortP]:  ")+TF2(cWindowsMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;

                                    }
                                        pP.ether.traceF( tinP , T("processing window [cInnerImagesToInspect,cImagesInspected,cWindowsMax,idWindow,%,tShort]:  ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cImagesInspected,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cWindowsMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tPerTuck+tb4+tShortP ) ;
                                        countT perTuck = (countT)( ( idWindow << 8 ) / cWindowsMax ) ;
                                    {            
                                    if( !( idWindow % ( TUCK >> 4 ) ) )


                                    idWindow ++ ;

                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                       ******************************************************************************************************************************************************************************
                                    // ****  GET AN OUTER WINDOW  ******************************************************************************************************************************************************************************
                                    // ****                       ******************************************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************
                                    //pP.ether.traceF( tinP , T("healing / 92") ) ;

                                    }
                                        break ;
                                        deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                    {
                                    if( pP.bAbort )
                                    pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                {
                                while( !etPrime && cImagesInspected < cInnerImagesToInspect )
                                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                                ZE( count04T , idWindow ) ;
                                ZE( boolT , cImagesInspected ) ;
                                ZE( count04T , cbDone ) ;
                                const count04T cWindows = 1 + pfmOuter->cbUsed / cbFileWindow ;
                                const boolT    bChatter =     pfmOuter->cbUsed > cbFileWindow ;

                                //pP.ether.traceF( tinP , pP.tIndent2+T("inspecting images [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;

                                }
                                    }
                                        break ;
                                        pP.bAbort = 1 ;
                                        deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                        DEL( pfwsOuter ) ;
                                        pP.ether.traceF( tinP , pP.tIndent2+T("!exception: could not ct pfwsOuter [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                                        POOPRqUIET
                                    {
                                    if( POOP )
                                    new( 0 , tinP , (byteT*)pfwsOuter , sizeof( fileWindowsC ) ) fileWindowsC( tinP , *tinP.pEtScratch , tLongOuter ) ;
                                    SCOOPS
                                {

                                //pP.ether.traceF( tinP , pP.tIndent2+T("new [pfwsOuter]:    ")+TF3((countT)pfwsOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                                pP.ether.newF( tinP , LF , *(byteT**)&pfwsOuter , sizeof( fileWindowsC ) ) ; ___( pfwsOuter ) ;
                                ZE( fileWindowsC* , pfwsOuter ) ;

                                // *********************************************************************************************************************************************************************************************************
                                // ****                                  *******************************************************************************************************************************************************************
                                // ****  CT OUTER fileWindowsC INSTANCE  *******************************************************************************************************************************************************************
                                // ****                                  *******************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                            {
                            IFsCRATCH
                            //pP.ether.traceF( tinP , T("healing / a2") ) ;

                            }
                                if( pP.bAbort ) break ;

                                }
                                    pP.ether.delF( tinP , psttLongInner ) ;

                                    }
                                        }
                                            break ;
                                            pP.bAbort = 1 ;
                                            deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                            DELzOMBIE( pDoomed ) ;
                                            fileWindowsC* pDoomed = &pfwsInner[ offi ] ;
                                            pP.ether.traceF( tinP , pP.tIndent3+T("!exception: could not ct a fileWindowsC instance ; aborting [tLongInner]:    ")+T(psttLongInner) ) ;
                                            POOPRqUIET
                                        {
                                        if( POOP )
                                        new( 0 , tinP , (byteT*)( pfwsInner + offi ) , sizeof( fileWindowsC ) ) fileWindowsC( tinP , *tinP.pEtScratch , psttLongInner ) ;
                                        SCOOPS
                                    {
                                    IFsCRATCH

                                    //pP.ether.traceF( tinP , pP.tIndent3+T("[cInnerImagesToInspect,idInner,tLongInner]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi+1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLongInner) ) ;
                                    stLongInner >> psttLongInner ;
                                    ZE( strokeS* , psttLongInner ) ;
                                {
                                for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )
                            {
                            if( pfwsInner )
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                            for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ ) pEqual[ offi ] = 1 ;
                            pP.ether.newF( tinP , LF , pEqual , cInnerImagesToInspect ) ; ___( pEqual ) ;
                            ZE( boolT* , pEqual ) ;

                            pP.ether.newF( tinP , LF , *(byteT**)&pfwsInner , cInnerImagesToInspect * sizeof( fileWindowsC ) ) ; ___( pfwsInner ) ;
                            ZE( fileWindowsC* , pfwsInner ) ;

                            }
                                break ;
                                pP.bAbort = 1 ;                                
                                pP.ether.traceF( tinP , pP.tIndent3+T("!exception [cInnerImagesToInspect,stLongInner]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+TF2(stLongInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            if( stLongInner != cInnerImagesToInspect ) //SHOULD BE IMPOSSIBLE

                            // *********************************************************************************************************************************************************************************************************
                            // ****                                                             ****************************************************************************************************************************************
                            // ****  CT INNER fileWindowsC INSTANCES ; INITIALIZE pEqual ARRAY  ****************************************************************************************************************************************
                            // ****                                                             ****************************************************************************************************************************************
                            // *********************************************************************************************************************************************************************************************************

                            //}
                            //    }
                            //        }
                            //            break ;
                            //            pcz_bUseWorkers = &bOk[ offs ] ;
                            //        {
                            //        if( !setIfZeAM( bOk[ offs ] , 1 ) )
                            //    {
                            //    for( countT offs = 0  ; offs < sizeof bOk / sizeof bOk[ 0 ] ; offs ++ )
                            //    static boolT bOk[ 4 ] ;        // ARRAY SIZE IS HARDCODED NUMBER OF YEARS TO ALLOW TO USE WORKERS SIMULTANEOUSLY
                            //{
                            //if( bLargeFile )
                            //ZE( countT* , pcz_bUseWorkers ) ;         // WILL BE SET TO &bOk[ offs ]
                            //20230807@1408: pcz_bUseWorkers IS NOT USED ; CONJ: THIS CODE IS LEFT OVER FROM A CRAFTWORK IDEA THAT I BEGAN TO CODE BUT THEN DID NOT COMPLETE

                            countT cbFileWindow = CBfILEwINDOW ;
                            //countT cbFileWindow = CB aLLfILEwINDOWS / cPathsToYearHealingP ;     // INTENTION IS TO PEG CPU WHEN FEW WINDOWS WHILE PREVENTING ADDRESS SPACE EXHAUSTION WHEN MANY WINDOWS
                            //pP.ether.traceF( tinP , T("healing / b2") ) ;
                        {
                        if( !etPrime && !pP.bAbort && cInnerImagesToInspect )

                        }
                            if( pP.bAbort ) break ;

                            }
                                while( !etPrime && !pP.bAbort && ~hStkInner ) ;
                                }
                                    //pP.ether.traceF( tinP , T("healing / c2") ) ;
                                    }
                                        }
                                            break ;

                                            }
                                                }
                                                    pP.bAbort = 1 ;                                                    
                                                    pP.ether.traceF( tinP , pP.tIndent3+T("!exception: iSlotLongInnr is null") ) ;
                                                    pP.ether.delF( tinP , psttLongInner ) ;
                                                {
                                                if( !idSlotLongInner ) //SHOULD BE IMPOSSIBLE
                                                stLongInner.sinkF( tinP , idSlotLongInner , psttLongInner , flSTACKsINK_UNIQUE ) ;
                                                ZE( countT , idSlotLongInner ) ;

                                                pP.ether.strMakeF( tinP , LF , psttLongInner , tLongInner ) ; ___( psttLongInner ) ;
                                                ZE( strokeS* , psttLongInner ) ;

                                                offResult ++ ;

                                                pcBitsShiftLeftHeInMine[ offResult ] = cBitsShiftLeftHeInMine ;
                                                pcBitsShiftLeftMeInHis[  offResult ] = cBitsShiftLeftMeInHis  ;
                                                ppIdResultHeInMine[      offResult ] = &bitsResultHeInMine    ;
                                                ppIdResultMeInHis[       offResult ] = &bitsResultMeInHis     ;
                                            {
                                            if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                        {
                                        case 3 :
                                        }
                                            break ;

                                            }
                                                cInnerImagesToInspect ++ ;
                                                //pP.ether.traceF( tinP , pP.tIndent3+T("incrementing") ) ;
                                            {
                                            if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )

                                            //pP.ether.traceF( tinP , pP.tIndent3+T("        maybe incrementing cInnerImagesToInspect [bitsResultHeInMine,maskHeInMine,masked,cBitsShiftLeftHeInMine,inner]:    ")+TF2(bitsResultHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(maskHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((bitsResultHeInMine&maskHeInMine),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                        {
                                        case 2 :    // COUNT THE NUMBER OF INNER FILES FOR WHICH I MUST INSPECT THE IMAGE (I SET cInnerImagesToInspect HERE)
                                        }
                                            break ;

                                            }
                                                }
                                                    bitsResultHeInMine |= BITSrESULT_NOTeQUAL << cBitsShiftLeftHeInMine ;
                                                    bitsResultMeInHis  |= BITSrESULT_NOTeQUAL << cBitsShiftLeftMeInHis  ;
                                                    //pP.ether.traceF( tinP , pP.tIndent3+T("        set other and myself to BITSrESULT_NOTeQUAL because cbUsed differs") ) ;
                                                {
                                                if( pfmOuter->cbUsed != pfmInner->cbUsed )
                                            {
                                            else if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                            }
                                                //pP.ether.traceF( tinP , pP.tIndent3+T("        setted  myself to BITSrESULT_EQUAL [bitsResultMeInHis]:    ")+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                bitsResultMeInHis |= BITSrESULT_EQUAL << cBitsShiftLeftMeInHis ;
                                                //pP.ether.traceF( tinP , pP.tIndent3+T("        setting myself to BITSrESULT_EQUAL [&bitsResultMeInHis,bitsResultMeInHis,&cBitsShiftLeftMeInHis,cBitsShiftLeftMeInHis]:    ")+TF2(&bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(&cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            if( pfmInner == pfmOuter )
                                        {
                                        case 1 :    // SET bitsResult WITHOUT COMPARING FILE IMAGES
                                    {
                                    switch( idPass )

                                    // /*if( idPass == 3 )*/ pP.ether.traceF( tinP , pP.tIndent3+T("    [idPass,idInner,tLongInner]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(++idInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                    TN( tLongInner , "" ) ; tLongInner = T((strokeS*)pP.stPathToYear[pfmInner->idSlotPathToYear])+tShortP ;

                                    countT maskHeInMine = BITSrESULT_ALLbITS << cBitsShiftLeftHeInMine ;
                                    countT maskMeInHis  = BITSrESULT_ALLbITS << cBitsShiftLeftMeInHis  ;

                                    countT  cBitsShiftLeftHeInMine =           ( ( pfmInner->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;
                                    countT  cBitsShiftLeftMeInHis  =           ( ( pfmOuter->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;
                                    countT& bitsResultHeInMine     = picOuter[ ( pfmInner->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;
                                    countT& bitsResultMeInHis      = picInner[ ( pfmOuter->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;

                                    }
                                        break ;
                                        pP.bAbort = 1 ;
                                        pP.ether.traceF( tinP , pP.tIndent3+T("!exception / !pfmInner->idSlotPathToYear [tShort]:    ")+tShortP ) ;
                                    {
                                    if( !pfmInner->idSlotPathToYear )

                                    //picInner->traceF( tinP , pP.tIndent3+T("    inner :    ") ) ;
                                    //pfmInner->traceF( tinP , pP.stPathToYear , pP.tIndent3+T("    inner: ") ) ;
                                    fileMetaS*     pfmInner = (fileMetaS*)( picInner + pP.cResultStructsNeeded ) ;

                                    //pP.ether.traceF( tinP , pP.tIndent3+T("    [picInner]:    ")+TF2((countT)picInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    imageCompareS* picInner = (imageCompareS*)&stMeta.upF( tinP , hStkInner ) ;

                                    if( pP.bAbort ) break ;
                                    pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                    //pP.ether.traceF( tinP , T("healing / d2") ) ;
                                {
                                do
                                handleC hStkInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                ZE( countT , idInner ) ;
                            {
                            if( idPass != 3 || cInnerImagesToInspect )

                            }
                                pP.ether.memSetF( tinP , (byteT*)pcBitsShiftLeftHeInMine , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                pP.ether.memSetF( tinP , (byteT*)pcBitsShiftLeftMeInHis  , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                pP.ether.memSetF( tinP , (byteT*)ppIdResultHeInMine      , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                pP.ether.memSetF( tinP , (byteT*)ppIdResultMeInHis       , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                pP.ether.memSetF( tinP , (byteT*)pcbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                pP.ether.memSetF( tinP , (byteT*)ppbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;

                                pP.ether.newF( tinP , LF ,             pcBitsShiftLeftHeInMine , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftHeInMine ) ;
                                pP.ether.newF( tinP , LF ,             pcBitsShiftLeftMeInHis  , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftMeInHis  ) ;
                                pP.ether.newF( tinP , LF , *(countT**)&ppIdResultHeInMine      , cInnerImagesToInspect ) ; ___( ppIdResultHeInMine      ) ;
                                pP.ether.newF( tinP , LF , *(countT**)&ppIdResultMeInHis       , cInnerImagesToInspect ) ; ___( ppIdResultMeInHis       ) ;
                                pP.ether.newF( tinP , LF ,             pcbwInner               , cInnerImagesToInspect ) ; ___( pcbwInner               ) ;
                                pP.ether.newF( tinP , LF , *(countT**)&ppbwInner               , cInnerImagesToInspect ) ; ___( ppbwInner               ) ;
                            {
                            if( idPass == 3 && cInnerImagesToInspect )
                        {
                        for( countT idPass = 1 ; !etPrime && !pP.bAbort && idPass <= 3 ; idPass ++ )
                        ZE( countT   , offResult               ) ;
                        ZE( countT*  , pcBitsShiftLeftHeInMine ) ;
                        ZE( countT*  , pcBitsShiftLeftMeInHis  ) ;
                        ZE( countT** , ppIdResultHeInMine      ) ;
                        ZE( countT** , ppIdResultMeInHis       ) ;
                        ZE( countT*  , pcbwInner               ) ;
                        ZE( byteT**  , ppbwInner               ) ;
                        ZE( countT   , cInnerImagesToInspect   ) ;
                        stackC stLongInner( tinP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

                        // *********************************************************************************************************************************************************************************************************
                        // ****                                                *****************************************************************************************************************************************************
                        // ****  LOAD stLongInner AND INITIALIZE ACCUMULATORS  *****************************************************************************************************************************************************
                        // ****                                                *****************************************************************************************************************************************************
                        // *********************************************************************************************************************************************************************************************************

                        //pfmOuter->traceF( tinP , pP.stPathToYear , pP.tIndent2+T("outer: ") ) ;
                        //pP.ether.traceF( tinP , pP.tIndent2+T("[tLongOuter]:    ")+tLongOuter ) ;
                        TN( tLongOuter , "" ) ; tLongOuter = T((strokeS*)pP.stPathToYear[idSlotPathToYearOuter])+tShortP ;
                        countT idSlotPathToYearOuter = pfmOuter->idSlotPathToYear ;

                        }
                            break ;
                            pP.bAbort = 1 ;
                            pP.ether.traceF( tinP , pP.tIndent2+T("!exception / !pfmOuter->idSlotPathToYear [tShort]:    ")+tShortP ) ;
                        {
                        if( !pfmOuter->idSlotPathToYear )

                        //picOuter->traceF( tinP , pP.tIndent2+T("outer :    ") ) ;
                        fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + pP.cResultStructsNeeded ) ;
                        imageCompareS* picOuter  = (imageCompareS*)&stMeta.upF( tinP , hStkOuter ) ;

                        if( pP.bAbort ) break ;
                        pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;

                        // *********************************************************************************************************************************************************************************************************
                        // ****                                      ***************************************************************************************************************************************************************
                        // ****  BEGIN:  FOR EACH COPY OF THIS FILE  ***************************************************************************************************************************************************************
                        // ****                                      ***************************************************************************************************************************************************************
                        // *********************************************************************************************************************************************************************************************************
                        //pP.ether.traceF( tinP , T("healing / e2") ) ;
                    {
                    do
                    handleC hStkOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    // SET ALL COMPARE META ELEMENTS FOR EACH FILE'S IMAGE COMPARE META ARRAY

                    if( !pP.bAbort && ( cbUsedHighMax || cbUsedMax > TOCK ) ) pP.ether.osTimeNowF( tinP , timeA1 , timeA2 ) ;
                    ZE( sCountT , timeA2 ) ;
                    ZE( countT  , timeA1 ) ;

                    //pP.ether.traceF( tinP , T("[cbUsedMax04,cWindowsMax]:    ")+TF2((countT)cbUsedMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cWindowsMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT cWindowsMax = (countT)( 1 + cbUsedMax04 / CBfILEwINDOW ) ;
                    count04T cbUsedMax04 = ( (count04T)cbUsedHighMax << 0x20 ) | (count04T)cbUsedMax ;      //A:ASSUME: sizeof( countT) IS 0x20

                    bLargeFile = 1 ; //TO EXPLORE OPTIMIZATION TO KEEP CPU PEGGED WITH MEMORY COMPARISON ACTIVITY
                    if( cbUsedHighMax || cbUsedMax > TOCK ) bLargeFile = 1 ;    //20230918@1130: TOCK <-- TUCK
                    ZE( boolT  , bLargeFile ) ;

                    //pP.ether.traceF( tinP , T("processing [tShort]:    ")+tShortP ) ;
                {
                if( !pP.bAbort )
                pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;

                // *********************************************************************************************************************************************************************************************************
                // *********************************************************************************************************************************************************************************************************
                // *********************************************************************************************************************************************************************************************************
                // ****                                                                                                                                  *******************************************************************
                // ****  BEGIN:  COMPARE ALL COPIES OF THIS SHORT FILE NAME.  THIS IS RETRIED UNTIL ALL COMPARISONS COMPLETE WITHOUT AN EXCEPTION EVENT  *******************************************************************
                // ****                                                                                                                                  *******************************************************************
                // *********************************************************************************************************************************************************************************************************
                // *********************************************************************************************************************************************************************************************************
                // *********************************************************************************************************************************************************************************************************
            {
            else
            if( !cCopies ) pP.ether.traceF( tinP , T("!exception: i found 0 copies of this listed file [tShort]:    ")+tShortP ) ;
            ////pP.ether.traceF( tinP , T("healing / f2") ) ;

            //pP.ether.traceF( tinP , T("[cCopies,tShort]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;

            countT cCopies = stMeta ;
        {
        if( !pP.bAbort )
        ////pP.ether.traceF( tinP , T("healing / 03") ) ;

        }
            ////pP.ether.traceF( tinP , T("healing / 13 / 0") ) ;
            DEL( pInfoFile ) ;
            }
                ////pP.ether.traceF( tinP , T("healing / 13 / ") ) ;
                new( 0 , tinP , (byteT*)pCursor , sizeof( fileMetaS ) ) fileMetaS( tinP , pP.bAbort , offh + 1 , time1Mod , time2Mod , cbUsed ) ;
                ////pP.ether.traceF( tinP , T("healing / 13 / 1") ) ;

                pCursor += pP.cResultStructsNeeded ;

                bitsResultMeInMine = BITSrESULT_EQUAL << cBitsShiftLeftMeInMine ;   // INITIALIZE RESULT TO SAY THAT I MATCH MYSELF

                countT  cBitsShiftLeftMeInMine =        ( offh % cResultsPerStruct ) << 1 ;
                countT& bitsResultMeInMine     = pCursor[ offh / cResultsPerStruct ].bitsResult ;
                ////pP.ether.traceF( tinP , T("healing / 13 / 2") ) ;

                for( countT offs = 0 ; offs < pP.cResultStructsNeeded ; offs ++ ) new( 0 , tinP , (byteT*)( pCursor + offs ) , sizeof( imageCompareS ) ) imageCompareS ;
                imageCompareS* pCursor = (imageCompareS*)&(stMeta)[ 1 ] ;
                ////pP.ether.traceF( tinP , T("healing / 13 / 3") ) ;

                stMeta << (byteT*)0 ;

                count04T cbUsed = (count04T)pInfoFile->cbUsedHigh << sizeof( count02T ) * SB | pInfoFile->cbUsed ;

                sCountT time2Mod = pInfoFile->timeWritten2 ;
                countT  time1Mod = pInfoFile->timeWritten1 ;

                }
                    cbUsedHighMax = pInfoFile->cbUsedHigh ;
                    cbUsedMax     = pInfoFile->cbUsed     ;
                {
                if( cbUsedHighMax < pInfoFile->cbUsedHigh || ( cbUsedHighMax == pInfoFile->cbUsedHigh && cbUsedMax < pInfoFile->cbUsed ) )
                ////pP.ether.traceF( tinP , T("healing / 13 / 4") ) ;
            {
            if( pInfoFile )
            ////pP.ether.traceF( tinP , T("healing / 13 / 5") ) ;

            }
                }
                    }
                        break ;
                        DEL( pInfoFile ) ;
                        pP.bAbort = 1 ;
                        pP.ether.traceF( tinP , T("!exception:  diskFileQueryF [tLong]:    ")+tLong ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    ////pP.ether.traceF( tinP , T("healing / 13 / 6") ) ;
                    tinP.pEtScratch->diskFileQueryF( tinP , pInfoFile , fi ) ; ___( pInfoFile ) ;
                    ////pP.ether.traceF( tinP , T("healing / 13 / 7") ) ;
                {
                else if( bFound )
                }
                    break ;
                    pP.bAbort = 1 ;
                    pP.ether.traceF( tinP , T("!exception:  fileC::fileC [tLong]:    ")+tLong ) ;
                    POOPRqUIET
                {
                if( POOP )

                }
                    bFound = 0 ;
                    //pP.ether.traceF( tinP , T("warning: listed file not found [tLong]:    ")+tLong ) ;
                    POOPRqUIET
                {
                if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_FILEnOTfOUND )
                boolT bFound = 1 ;
                ////pP.ether.traceF( tinP , T("healing / 13 / 8") ) ;

                fileC fi( tinP , (strokeS*)tLong , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 ) ;
                ////pP.ether.traceF( tinP , T("healing / 13 / 9") ) ;
                SCOOPS
            {
            IFsCRATCH
            ZE( infoFileS* , pInfoFile ) ;

            //pP.ether.traceF( tinP , T("fileC::fileC [tLong]:    ")+tLong ) ;
            TN( tLong , "" ) ; tLong = T(pP.ppsttzPathToYear[offh])+tShortP ;
            ////pP.ether.traceF( tinP , T("healing / 13 / a") ) ;
        {
        for( countT offh = 0 ; !pP.bAbort && offh < pP.cPathsToYear ; offh ++ )
        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        ZE( countT , cbUsedHighMax ) ;
        ZE( countT , cbUsedMax ) ;
        ////pP.ether.traceF( tinP , T("healing / 13") ) ;
    {
    if( !pP.bAbort )
    pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;

    stackC stMeta( tinP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB | flSTACKc_ALLOWzE , pP.cResultStructsNeeded * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ;

    //pP.ether.traceF( tinP , T("++++ healing [tShort]:    ")+tShortP ) ;

    const countT cProcessors = thirdC::osProcessorsIF( tinP ) ;
    etherC& etPrime = etherC::etPrimeIF() ;
    TN( tPerTuck , " %" ) ;
    TN( tDot , "." ) ;
    TN( tb4  , "    " ) ;
    TN( tb   , " " ) ;
{
voidT healFileF( tinNormalS& tinP , paramHealFileS& pP , textC& tShortP , const boolT bStrictP )

}
    }
        }
            //if( !( idIn % ( TUCK << 4 ) ) ) etherP.traceF( tinP , T("images match [idIn]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        else
        }
            //etherP.delF( tinP , psttGen ) ;
            //etherP.traceF( tinP , tIndent3P+T("wrote inner [gen]:    ")+T(psttGen) ) ;
            //etherP.boxPutGenerationF( tinP , psttGen , tLikeInner+TF3(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) , TUCK , ppbwInner[ offi ] , cbwOuter ) ; ___( psttGen ) ;
    
            //etherP.delF( tinP , psttGen ) ;
            //etherP.traceF( tinP , tIndent3P+T("wrote outer [gen]:    ")+T(psttGen) ) ;
            //etherP.boxPutGenerationF( tinP , psttGen , tLikeOuter , TUCK , pbwOuter , cbwOuter ) ; ___( psttGen ) ;
            //ZE( strokeS* , psttGen ) ;
    
            //etherP.traceF( tinP , tIndent3P+T("difference detected between unique and inner [idWindow,offi]:    ")+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    
            bEqualP = 0 ;
        {
        if( sgn )
    {
    if( !bAbortP )
    
    //countT idIn = 1 + incv02AM( idInLath ) ;
    //static countT idInLath ;
    
    }
        }
            }
                }
                    etherP.traceF( tinP , T("decremented cPause after nap after exception [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    was = decv02AM( cPauseP ) ;
                    ++ s ; etherP.osSleepF( tinP , TIMEpAUSEoNfAIL ) ;
                    etherP.traceF( tinP , T("incremented cPause on exception [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT was = incv02AM( cPauseP ) ;
                {
                else
                }
                    break ;
                    bAbortP = 1 ;
                {
                if( !cTries )
                //etherP.traceF( tinP , tIndent3P+T("!exception / memCompareF impotence ; aborting if !cTries [cTries,idCulprit,tLongOuter,tLongInner]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idCulprit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuterP+tb4+tLongInnerP ) ;
                POOPRqUIET
    
                }
                    default                             : { etherP.traceF( tinP , T("!exception: software error: unknown impotence code (ifcIDiMPOTENCEmEMcMP)") ) ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_COMPARE2  : { idCulprit = 2 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_COMPARE1  : { idCulprit = 1 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_COMPARE0  : {                 break ; }
                    case ifcIDiMPOTENCEmEMcMP_LATHbYTE2 : { idCulprit = 2 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_WOTHbYTE2 : { idCulprit = 2 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_LATHbYTE1 : { idCulprit = 1 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_WOTHbYTE1 : { idCulprit = 1 ; break ; }
                    //CS:CODEsYNC: 510007e9 112005be
                {
                switch( POOP )
                ZE( countT , idCulprit ) ;
            {
            if( POOP )
            //etherP.traceF( tinP , T("called  memCompareF [cb]:    ")+TF2(cbwOuterP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            sgn = tinP.pEtScratch->memCompareF( tinP , pbwOuterP , pbwInnerP , cbwOuterP ) ;
            //etherP.traceF( tinP , T("calling memCompareF [cb]:    ")+TF2(cbwOuterP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        while( bEqualP && cTries -- )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        countT cTries = bStrictP ? 1 : TUCK >> 4 ;
    
        SCOOPS
    {
    IFsCRATCH
    //TN( tb4 , "    " ) ;
    ZE( sCountT , sgn ) ;
{
voidT compareOoImagesF( tinNormalS& tinP , etherC& etherP , boolT& bAbortP , countT& cPauseP , boolT& bEqualP , const boolT bStrictP , const byteT* pbwOuterP , const byteT* pbwInnerP , countT cbwOuterP /*U::, const textC& tLongOuterP , const textC& tLongInnerP , textC& tIndent3P*/ )

}
    etherP.delF( tinP , *(byteT**)&pfwsInnerP ) ;
    etherP.delF( tinP , pEqualP ) ;

    }
        DELzOMBIE( pDoomed ) ;
        fileWindowsC* pDoomed = pfwsInnerP + offi ;
    {
    for( countT offi = 0 ; offi < cInnerImagesToInspectP ; offi ++ )
{
voidT deleteEqualArrayFwsInnerArrayF( tinNormalS& tinP , etherC& etherP , boolT*& pEqualP , fileWindowsC*& pfwsInnerP , countT cInnerImagesToInspectP )

}
    if( ether ) bAbortP = 1 ;

    }
        dec02AM( cExecutiveHealYearPausedP ) ;
        }
            ++ s ; ether.osSleepF( tinP , TOCK ) ;
        {
        while( cPauseP )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        inc02AM( cExecutiveHealYearPausedP ) ;
    {
    if( cPauseP && !bAbortP )
    etherC& ether = etherC::etPrimeIF( tinP ) ;
{
voidT pauseIfF( tinNormalS& tinP , boolT& bAbortP , countT& cExecutiveHealYearPausedP , countT& cPauseP )

}
    return *pfr1 - *pfr2 ;

    fileMetaS* pfr2 = (fileMetaS*)c2P ;
    fileMetaS* pfr1 = (fileMetaS*)c1P ;
{
/*1*/countT subtractFileMetaF( tinNormalS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    return - sgn ;                          //SORT IN DECREASING ORDER OF SIZE SO THAT THE LARGEST FILES ARE PROCESSED WOTH
    sCountT sgn = *pJob1 - *pJob2 ;

    jobCompareOoImagesS* pJob2 = (jobCompareOoImagesS*)c2P ;
    jobCompareOoImagesS* pJob1 = (jobCompareOoImagesS*)c1P ;
{
/*1*/countT subtract_jobCompareOoImagesS_F( tinNormalS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    tPathLonely  += tUniqueP+tSlash ;
    tPathRejects += tUniqueP+tSlash ;
{
st_pJobHealFileDone( st_pJobHealFileDoneP )
stPathToYear( stPathToYearP ) ,
ppsttzPathToYear( ppsttzPathToYearP ) ,
cResultStructsNeeded( cResultStructsNeededP ) ,
cPathsToYear( cPathsToYearP ) ,
stJobCompare( stJobCompareP ) ,
cExecutiveHealYearPaused( cExecutiveHealYearPausedP ) ,
cProcessors( thirdC::osProcessorsIF( tinP ) ) ,
tArchive( tArchiveP ) ,
tYear( tYearP ) ,
tPathLonely(    tinP , TAG( TAGiDnULL ) , flTEXTc_null , "/ideafarm.archives.lonely/" ) ,
tPathRejects(   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "/ideafarm.archives.rejects/" ) ,
tPathArchives(  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "/ideafarm.archives/" ) ,
tIndent3(  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "|           " ) ,
tIndent2(  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "|       " ) ,
tIndent1(  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "|   " ) ,
tSlash( tinP , TAG( TAGiDnULL ) , flTEXTc_null , "/" ) ,
tDot( tinP , TAG( TAGiDnULL ) , flTEXTc_null , "." ) ,
tb4( tinP , TAG( TAGiDnULL ) , flTEXTc_null , "    " ) ,
cPause( cPauseP ) ,
bAbort( bAbortP ) ,
etPrime( etherC::etPrimeIF() ) ,
ether( etherP ) ,
paramHealFileS::paramHealFileS( tinNormalS& tinP , etherC& etherP , boolT& bAbortP , countT& cPauseP , textC& tYearP , textC& tArchiveP , textC& tUniqueP , countT& cExecutiveHealYearPausedP , stackC& stJobCompareP , const countT cPathsToYearP , const countT cResultStructsNeededP , const strokeS** const ppsttzPathToYearP , stackC& stPathToYearP , stackC& st_pJobHealFileDoneP ) :

}
    tinP.pEther->traceF( tinP , T(psttP)+T(" [bitsResult]:    ")+TF4(bitsResult,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
{
voidT imageCompareS::traceF( tinNormalS& tinP , const strokeS* const psttP )

}
    //traceF( tinP , T("ct      :    ") ) ;
    TINSL
{
bitsResult( BITSrESULT_UNKNOWN )
imageCompareS::imageCompareS( voidT ) :

NEWdELcLASS( 4 , imageCompareS ) ;

}
    return tinP.pEther->memCompareF( tinP , (byteT*)this , (byteT*)&frP , sizeof( countT ) + sizeof( count04T ) ) ;    //CS:CODEsYNC 1 1
    TINSL
{
sCountT fileMetaS::operator -( const fileMetaS& frP ) const

}
    tinP.pEther->traceF( tinP , T(psttP)+T(" [timeModRounded,timeMod,cbUsed,cVotes,idSlotPathToYear,path]:    ")+TF3(timeModRounded,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T("    ")+TT(time1Mod,time2Mod)+T("    ")+TT(((countT*)&cbUsed)[0],((countT*)&cbUsed)[1])+T("    ")+TF2(cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idSlotPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((strokeS*)stPathToYearP[idSlotPathToYear]) ) ;
{
voidT fileMetaS::traceF( tinNormalS& tinP , stackC& stPathToYearP , const strokeS* const psttP )

}
    timeModRounded = *(countT*)( (byteT*)pc2 + 3 ) + bRoundUp ;
    countT pc2[ 2 ] = { time1Mod , time2Mod } ;

    boolT bRoundUp = !!( ( time1Mod & 0xffffff ) > 0x800000 ) ;

    }
        bAbortP = 1 ;
        tinP.pEther->traceF( tinP , T("fileMetaS::fileMetaS / !exception: idSlotPathToYear is null") ) ;
    {
    if( !idSlotPathToYear )
{
idSlotPathToYear( idSlotPathToYearP )
cVotes( 0 ) ,
time2Mod( time2ModP ) ,
time1Mod( time1ModP ) ,
cbUsed( cbUsedP ) ,
timeModRounded( 0 ) ,
fileMetaS::fileMetaS( tinNormalS& tinP , boolT& bAbortP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) :

NEWdELcLASS( 3 , fileMetaS ) ;

}
{
idName( 0 )
psttShort( 0 ) ,
info( *(paramHealFileS*)0 ) ,
cJobsPendingHeal( *(countT*)0 ) ,
ether( *(etherC*)0 ) ,
jobHealFileS::jobHealFileS( voidT ) :

}
    //ether.traceF( tinP , T("++++ [cJobsPendingHeal,idName,short]:    ")+TF3(cJobsPendingHeal,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(psttShort) ) ;
    ether.strMakeF( tinP , LF , psttShort , psttShortP ) ; ___( psttShort ) ;

    inc02AM( cJobsPendingHeal ) ;
{
idName( idNameP )
psttShort( 0 ) ,
info( infoP ) ,
cJobsPendingHeal( cJobsPendingHealP ) ,
ether( etherP ) ,
jobHealFileS::jobHealFileS( tinNormalS& tinP , etherC& etherP , countT& cJobsPendingHealP , paramHealFileS& infoP , const strokeS* const psttShortP , const countT idNameP ) :

}
    dec02AM( cJobsPendingHeal ) ;
    ether.delF( tinP , psttShort ) ;
    //ether.traceF( tinP , T("---- [cJobsPendingHeal,idName,short]:    ")+TF3(cJobsPendingHeal,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(psttShort) ) ;
    if( !pEther ) { BLAMMO ; }              // IT IS ILLEGAL TO CT USING THE DEFAULT CT'OR WITHOUT IMMEDIATELY OVERWRITING THE IMAGE TO MAKE IT VALID
    etherC* pEther = &ether ;
    TINSL
{
jobHealFileS::~jobHealFileS( voidT )

NEWdELcLASS( 2 , jobHealFileS ) ;

}
{
psttLongInner( 0 )
psttLongOuter( 0 ) ,
cbwOuter( 0 ) ,
pbwInner( 0 ) ,
pbwOuter( 0 ) ,
bEqual( *(boolT*)0 ) ,
cJobsPendingCompare( *(countT*)0 ) ,
ether( *(etherC*)0 ) ,
jobCompareOoImagesS::jobCompareOoImagesS( voidT ) :

}
    ether.strMakeF( tinP , LF , psttLongInner , psttLongInnerP ) ; ___( psttLongInner ) ;
    ether.strMakeF( tinP , LF , psttLongOuter , psttLongOuterP ) ; ___( psttLongOuter ) ;

    inc02AM( cJobsPendingCompare ) ;
{
psttLongInner( 0 )
psttLongOuter( 0 ) ,
cbwOuter( cbwOuterP ) ,
pbwInner( pbwInnerP ) ,
pbwOuter( pbwOuterP ) ,
bEqual( bEqualP ) ,
cJobsPendingCompare( cJobsPendingCompareP ) ,
ether( etherP ) ,
jobCompareOoImagesS::jobCompareOoImagesS( tinNormalS& tinP , etherC& etherP , countT& cJobsPendingCompareP , boolT& bEqualP , const byteT* pbwOuterP , const byteT* pbwInnerP , countT cbwOuterP , const strokeS* const psttLongOuterP , const strokeS* const psttLongInnerP , count04T cbUsedMax04P ) :

}
    dec02AM( cJobsPendingCompare ) ;
    ether.delF( tinP , psttLongInner ) ;
    ether.delF( tinP , psttLongOuter ) ;
    if( !pEther ) { BLAMMO ; }              // IT IS ILLEGAL TO CT USING THE DEFAULT CT'OR WITHOUT IMMEDIATELY OVERWRITING THE IMAGE TO MAKE IT VALID
    etherC* pEther = &ether ;
    TINSL
{
jobCompareOoImagesS::~jobCompareOoImagesS( voidT )

NEWdELcLASS( 1 , jobCompareOoImagesS ) ;

osTextT* postDebugLever ;

countT cYearsInParallel = CyEARSiNpARALLEL ;
const countT cResultsPerStruct = sizeof( countT ) * SB / 2 ;     // 2 BITS ARE USED TO STORE A RESULT, SO 4 RESULTS FIT INTO A BYTE AND 01 RESULTS FIT INTO A count02T ; MY CODE SHOULD BE WRITTEN WITHOUT ASSUMING countT IS count02T

;
}
    voidT traceF( tinNormalS& tinP , const strokeS* const psttP = 0 ) ;
    inline sCountT operator -( imageCompareS& picP ) { return bitsResult - picP.bitsResult ; }
    imageCompareS( voidT ) ;
    NEWdELcLASSpROTOS

    countT bitsResult ;
{
struct imageCompareS

;
}
    sCountT operator -( const fileMetaS& frP ) const ;
    voidT traceF( tinNormalS& tinP , stackC& stPathToYearP , const strokeS* const psttP = 0 ) ;
    fileMetaS( tinNormalS& tinP , boolT& bAbortP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) ;
    NEWdELcLASSpROTOS

    countT   idSlotPathToYear ;
    countT   cVotes ;
    sCountT  time2Mod ;
    countT   time1Mod ;
    count04T cbUsed ;
    countT   timeModRounded ;   //CS:CODEsYNC 1 1
{
struct fileMetaS

;
}
    }
        ;
                : 0
                ? - 1
            : cbUsedMax04 < heP.cbUsedMax04
            ? 1
        return cbUsedMax04 > heP.cbUsedMax04
    {
    inline sCountT operator -( jobCompareOoImagesS& heP ) const
    inline operator countT( voidT ) const { return cbwOuter << 1 ; }

    jobCompareOoImagesS( voidT ) ;
    jobCompareOoImagesS( tinNormalS& tinP , etherC& etherP , countT& cJobsPendingCompareP , boolT& bEqualP , const byteT* pbwOuterP , const byteT* pbwInnerP , countT cbwOuterP , const strokeS* const psttLongOuterP , const strokeS* const psttLongInnerP , count04T cbUsedMax04P ) ;
    ~jobCompareOoImagesS( voidT ) ;
    NEWdELcLASSpROTOS


    count04T     cbUsedMax04         ;
    strokeS*     psttLongInner       ;
    strokeS*     psttLongOuter       ;
    countT       cbwOuter            ;
    const byteT* pbwInner            ;
    const byteT* pbwOuter            ;
    boolT&       bEqual              ;
    countT&      cJobsPendingCompare ;
    etherC&      ether               ;
{
struct jobCompareOoImagesS

;
}
    jobHealFileS( voidT ) ;
    jobHealFileS( tinNormalS& tinP , etherC& etherP , countT& cJobsPendingHealP , paramHealFileS& infoP , const strokeS* const psttShortP , const countT idNameP ) ;
    ~jobHealFileS( voidT ) ;
    NEWdELcLASSpROTOS

    const countT        idName           ;
    strokeS*            psttShort        ;
    paramHealFileS&     info             ;
    countT&             cJobsPendingHeal ;
    etherC&             ether            ;
{
struct jobHealFileS

;
}
    paramHealFileS( tinNormalS& tinP , etherC& etherP , boolT& bAbortP , countT& cPauseP , textC& tYearP , textC& tArchiveP , textC& tUniqueP , countT& cExecutiveHealYearPausedP , stackC& stJobCompareP , const countT cPathsToYearP , const countT cResultStructsNeededP , const strokeS** const ppsttzPathToYearP , stackC& stPathToYearP , stackC& st_pJobHealFileDoneP ) ;

    stackC&                 st_pJobHealFileDone  ;
    stackC&                 stPathToYear ;
    const strokeS** const   ppsttzPathToYear ;
    const countT            cResultStructsNeeded ;
    const countT            cPathsToYear ;
    stackC&                 stJobCompare ;
    countT&                 cExecutiveHealYearPaused ;
    const countT            cProcessors ;

    textC&                  tArchive ;
    textC&                  tYear ;

    textC                   tPathLonely ;
    textC                   tPathRejects ;
    textC                   tPathArchives ;
    textC                   tIndent3 ;
    textC                   tIndent2 ;
    textC                   tIndent1 ;
    textC                   tSlash ;
    textC                   tDot ;
    textC                   tb4 ;

    countT&                 cPause ;
    boolT&                  bAbort ;
    etherC&                 etPrime ;
    etherC&                 ether ;
{
struct paramHealFileS

#define IDtYPEjOB_COPY       0x3
#define IDtYPEjOB_MOVEuNIQUE 0x2
#define IDtYPEjOB_NULL       0x1

//#define CyEARSiNpARALLEL  0x1
//B:#define CyEARSiNpARALLEL  0x2
//B:#define CyEARSiNpARALLEL  0x4
//G:#define CyEARSiNpARALLEL  0x1
//U:: TO TEST WITH 32_9 DEVICES WITH SUSPECTED INADEQUATE POWER

#define CyEARSiNpARALLEL  0x1
//20230922@0852: STUDY DOING 1 YEAR AT A TIME WITH ALL FILES PROCESSED ASYNCHRONOUSLY (BY PUSHING TO JOB stackC's)

//#define CyEARSiNpARALLEL  0x8
//B: cpu only 1/3 used:#define CyEARSiNpARALLEL  0x8

//NO IMPROVEMENT IN SWAPPING AND NOT PEGGED: #define CyEARSiNpARALLEL  0x2
//OK BUT LOTS OF SWAPPING: #define CyEARSiNpARALLEL  0x4
//B:"!exception: napping: too many pending job bytes: #define CyEARSiNpARALLEL  0x8

//BAD:20230709@1002: #define CyEARSiNpARALLEL  0x10
//BAD:#define CyEARSiNpARALLEL  0x20
//AOK:#define CyEARSiNpARALLEL  0x1
//AOK:#define CyEARSiNpARALLEL  0x4
//AOK:#define CyEARSiNpARALLEL  0x8
//AOK:#define CyEARSiNpARALLEL  0x10
//U::TO FIND A BUG

#define CeXTRAcYCLESiFpAUSE 1

#define CBdATAbOOKsHORTfILEnAMES TICK

#define CwORKERStHRESHOLDdOnOTlAUNCHmORE   ( TUCK >> 4 )

#define TIMEpAUSEoNfAIL ( TOCK << 4 )

#define CBfILEwINDOW   ( TICK >> 4 )
//20230819@1143: MEMORY EXHAUSTED WITH 5 YEARS AND f DEVICES PER YEAR: #define CBfILEwINDOW   ( TICK >> 2 )
//20230708@0837: MEMORY EXHAUSTED WITH a YEARS AND 6 DEVICES PER YEAR: #define CBfILEwINDOW   ( TICK >> 1 )

//#define CBaLLfILEwINDOWS ( TICK << 2 )
//G:#define CBaLLfILEwINDOWS ( TICK << 0 )
//B:#define CBaLLfILEwINDOWS ( TICK << 5 )

//#define CBaLLfILEwINDOWS 1
//TO FIND A BUG

#define BITSrESULT_ALLbITS        3
#define BITSrESULT_EQUAL          2
#define BITSrESULT_NOTeQUAL       1
#define BITSrESULT_UNKNOWN        0

//OBSOLETES 7e6

/*1*/WAKEhIDE( "ifcIDaDAM_HEALaRCHIVES" )/*1*/
/**/
*/
i look for ///?/ideafarm.archives/ folders and, if found, i heal them
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
