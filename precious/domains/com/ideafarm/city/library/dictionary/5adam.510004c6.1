
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

ether.osSleepF( tin0P , TOCK * 4 ) ;

while( cTries -- ) sockd.writeF( tin0P , ifcPORToLD2_TIMErEMAINING , nicNameC() , pbq , sizeof pbq ) ;
countT cTries = 8 ;

etThread.osThreadF( tin0P , countTC() , tmCatchF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&sockd ) ;

sockd.bindF( tin0P ) ;
socketC sockd( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

etThread.memCopyF( tin0P , pbq + sizeof( countT ) , (byteT*)&qq , sizeof qq ) ;
*(countT*)pbq = 1 ;
byteT pbq[ sizeof( countT ) + sizeof qq ] ;

}
        etThread.ifcJobF( tin0P , stCourses , 0x4010120 , sOrder , stOrders , T("!addTime") ) ;
        stOrders << new( 0 , tin0P , LF ) soulC( tin0P , etThread , TAG( TAGiDnULL ) ) ;
        stackC stOrders(  tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
        stackC stCourses( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;

        sOrder << (countT)0 ;
        sOrder << (countT)( TICK * 0x80 ) ;
        sOrder << qq.idType ;
        sOrder << qq.idComputer ;
        sOrder << (strokeS*)T("!addTime") ;
        sOrder << ifcIDcMDjOBoRDER_NAMED ;
        soulC sOrder( tin0P , etThread , TAG( TAGiDnULL ) ) ;
{

qq.idType = 1 ;
qq.idComputer = etThread.diskIdF( tin0P , T("///d/") ) ;
queryTimeRemainingS qq ;

TODO

DONE( tmCatchF )
}
    }
        etThread.delF( tin0P , pbr ) ;

        }
            }
                }
                    break ;
                    }
                        etThread.strokeF( tin0P , TF3(idType,flFORMAT_UNSIGNED,9)+TT(timeRemaining.time1,timeRemaining.time2)+T("\r\n") ) ;
                        timeS timeRemaining = *(timeS*)( pbr + sizeof( countT ) ) ;
                    {
                    if( cbr == sizeof( countT ) + sizeof( timeS ) )
                {
                case 1 :
            {
            switch( idType )
            countT& idType = *(countT*)pbr ;
        {
        if( pbr && cbr >= sizeof( countT ) )
    
        sockd.readF( tin0P , pbr , cbr , idp , nnPeer ) ; ___( pbr ) ;
        nicNameC nnPeer ;
        ZE( countT , idp ) ;
        ZE( countT , cbr ) ;
        ZE( byteT* , pbr ) ;
    {
    while( !ether && !sockd.etherF( tin0P ) )

    socketC& sockd = *(socketC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmCatchF )

/*1*/WAKEhIDE( "gorilla.timeRemaining" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

