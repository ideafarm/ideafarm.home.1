
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
//etThread.ifcSayF( tin0P , T("final aok\r\n") , flSAY_APPEND | flSAY_LOG ) ;

}
    DEL( pLake ) ;
    etUsesPoolPrime.delF( tin0P , pbPackLag ) ;
    TELL( "cleaning up" ) ;
    }
        if( bWoPass ) break ;
        //etThread.ifcSayF( tin0P , TF1(DDNUMB)+T(" cycle ")+tIdCycle+T(" this cycle has ended\r\n") , flSAY_APPEND | flSAY_LOG ) ;
        TELL( "ending a cycle" ) ;

        }
            HIRE( T("city.publisher.load") , 0x401043a , 0x1000000 , 0x401043a , 0x1000000 )
            TELL( "hiring a34" )
        {
        if( idCycle == 1 )

        //etThread.ifcSayF( tin0P , TF1(DDNUMB)+T(" cycle ")+tIdCycle+T(" the current pack file is loaded\r\n") , flSAY_APPEND | flSAY_LOG ) ;
        loadPackF( tin0P , ether , etThread , etUsesPoolPrime , pLake , pbPackLag ) ;
        //etThread.ifcSayF( tin0P , TF1(DDNUMB)+T(" cycle ")+tIdCycle+T(" beginning to load the current pack file\r\n") , flSAY_APPEND | flSAY_LOG ) ;
        TELL( "loading a pack of fish into the lake" ) ;

        TN( tIdCycle , "" ) ; tIdCycle = TF1(++idCycle) ;
        TELL( "beginning a cycle" ) ;
    {
    while( !ether && !etThread )
    ZE( lakeC* , pLake ) ;
    ZE( countT , idCycle ) ;
    ZE( byteT* , pbPackLag ) ;
    etherC etUsesPoolPrime( tin0P , TAG( TAGiDnULL ) ) ;

    }
        if( etThread.diskFileExistsF( tin0P , tPackLoaded  ) ) etThread.boxZapF( tin0P , tPackLoaded ) ;
        if( etThread.diskFileExistsF( tin0P , tPackNoticed ) ) etThread.boxZapF( tin0P , tPackNoticed ) ;
        TN( tPackLoaded  , "///ideafarm/ephemeral/gen/lake/pack.loaded."  ) ; tPackLoaded  += TF1(etThread.diskIdF(tin0P,T("///c"))) ;
        TN( tPackNoticed , "///ideafarm/ephemeral/gen/lake/pack.noticed." ) ; tPackNoticed += TF1(etThread.diskIdF(tin0P,T("///c"))) ;
    {

    stateS state( tin0P , etThread ) ;
{

//U:etThread.flagsMode |= flTHIRDmODE_CHECKpOOLoLD ;

const boolT bTest   = etThread.etherParameterF( tin0P , T("!test")   ) ;
const boolT bWoPass = etThread.etherParameterF( tin0P , T("!woPass") ) ; //U: THESE ARE OBSOLETE NOW THAT I CYCLE CONTINUOUSLY AS PART OF ifc11 SYSTEM

//etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIEST ) ; // I ALSO TAKE NAPS FREQUENTLY TO MAKE EXTRA SURE THAT I DO NOT INTERFERE WITH HTTP SERVICE
((thirdC&)etThread).third_bWatchful_F( tin0P ) = 0 ;
TELL( "preparing for work" ) ;
TODO

}
    }
        }
            //etThread.ifcSayF( tin0P , TF1(DDNUMB)+T(" the loaded file was written\r\n") , flSAY_APPEND | flSAY_LOG ) ;
            }
                etThread.boxPutF( tin0P , tPackLoaded , (byteT*)&c2l , sizeof c2l ) ;
                etThread.osTimeNowF( tin0P , c2l.c1 , (sCountT&)c2l.c2 ) ;
                count2S c2l ;
            {
            //etThread.ifcSayF( tin0P , TF1(DDNUMB)+T(" writing the loaded file\r\n") , flSAY_APPEND | flSAY_LOG ) ;
    
            }
                }
                    __( !poolC::poolOldRootIF( tin0P ).offNewMinF( tin0P ) ) ;
                    }
                        poolC::poolOldRootIF( tin0P ).poolOldDelIF( tin0P , (voidT*)pbPad ) ; pbPad = 0 ;
                        poolC::poolOldRootIF( tin0P ).flagsBackF( tin0P ) &= ~( F(flPOOLoLDbACK_NOcURSORrESET) ) ;
                        poolC::poolOldRootIF( tin0P ).setPoolNewMinF( tin0P ) ;
                        }
                            db.cbUsedReally = cba ;
                            db.idType       = ifcIDtYPEdROPnOTE_byteT ;
                            //DROPnOTErEF( pbPad ) ;
                        {
                        if( pbPad )
                        byteT* pbPad = (byteT*)poolC::poolOldRootIF( tin0P ).poolNewF( tin0P , LF , cba ) ; ___( pbPad ) ;
                        countT cba = cbSoFar * 2 ;
                    {
                    __( !!poolC::poolOldRootIF( tin0P ).offNewMinF( tin0P ) ) ;
    
                    }
                        poolC::poolOldRootIF( tin0P ).poolOldDelIF( tin0P , (voidT*)pbAt ) ; pbAt = 0 ;
                        cbSoFar = ap_artmentOldC( tin0P , pbAt ) ;
                        }
                            db.cbUsedReally = 0 ;
                            db.idType       = ifcIDtYPEdROPnOTE_byteT ;
                            //DROPnOTErEF( pbAt ) ;
                        {
                        if( pbAt )
                        byteT* pbAt = (byteT*)poolC::poolOldRootIF( tin0P ).poolNewF( tin0P , LF , 0 ) ; ___( pbAt ) ;
                    {
                    ZE( countT , cbSoFar ) ;
                {
                if( !bNewMinIsSet )

                etThread.osThreadF( tin0P , countTC() , tmFreshCalendarF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&lake , (countT)&bNewMinIsSet ) ;
                }
                    stockOneImageFishF( tin0P , etThread , lake , pcNameWo       , T("///d/ideafarm.work/backed.up.daily/images/jpeg/wo.jpg"         ) , T("image/jpeg") , bNewMinIsSet ) ;
                    stockOneImageFishF( tin0P , etThread , lake , pcNameMural    , T("///d/ideafarm.work/backed.up.daily/images/jpeg/mural.jpg"      ) , T("image/jpeg") , bNewMinIsSet ) ;
                    stockOneImageFishF( tin0P , etThread , lake , pcNameFlag     , T("///d/ideafarm.work/backed.up.daily/images/gif/flag.100x50.gif" ) , T("image/gif" ) , bNewMinIsSet ) ;
                    countT pcNameWo[]       = { 2 , 3 , 0 } ;
                    countT pcNameMural[]    = { 2 , 2 , 0 } ;
                    countT pcNameFlag[]     = { 2 , 1 , 0 } ;
                {
    
                //etThread.ifcSayF( tin0P , T("time to load ")+TF1(cPacks)+T(" packs containing ")+T(cFish)+T(" fish into the lake: ")+TT(time1b,time2b)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                etThread.osTimeSubtractF( tin0P , time1b , time2b , time1as , time2as ) ;
                etThread.osTimeNowF( tin0P , time1b , time2b ) ;
                ZE( sCountT , time2b ) ;
                ZE( countT , time1b ) ;
            {
            if( !ether && !etThread )
    
            time2a = time2bs ;
            time1a = time1bs ;
            etThread.osTimeSubtractF( tin0P , time1b , time2b , time1a , time2a ) ;
            sCountT time2bs = time2b ;
            countT time1bs = time1b ;
            etThread.osTimeNowF( tin0P , time1b , time2b ) ;
            ZE( sCountT , time2b ) ;
            ZE( countT , time1b ) ;
    
                                              //WO APPROACH: USE THE WO'TH NAME VALUE AS A SERIAL NUMBER AND PASS THROUGH THE ENTIRE LAKE DELETING SERIAL NUMBERS BELOW OR AT THE BACKING PACK THAT IS ABOUT TO BE DELETED
                                              //U: IF A FISH BECOMES OBSOLETE WITHOUT BEING REPLACED, IT WILL REMAIN IN THE LAKE EVEN THOUGH THE pbPack THAT IT POINTS TO HAS BEEN DELETED
            pbPackLagP = pbPack ; pbPack = 0 ; //pbPack CANNOT BE DELETED UNTIL AFTER ALL FISH THAT REFER TO IT ARE DELETED
            etUsesPoolPrime.delF( tin0P , pbPackLagP ) ;
            etThread.lakeFishFromPackF( tin0P , lake , pbPack , cbPack , bNewMinIsSet ) ;

            }
                etThread.boxPutF( tin0P , tPackNoticed , (byteT*)&c2l , sizeof c2l ) ;
                etThread.osTimeNowF( tin0P , c2l.c1 , (sCountT&)c2l.c2 ) ;
                count2S c2l ;
            {
    
            __( etUsesPoolPrime ) ;
            etUsesPoolPrime.boxGetShadowF( tin0P , pbPack , cbPack , tPack ) ; ___( pbPack ) ;
            TELL( "loading a pack/reading the pack file" ) ;
            ZE( countT , cbPack ) ;
            ZE( byteT* , pbPack ) ;
        {
        if( !ether )

        //etThread.ifcSayF( tin0P , TF1(DDNUMB)+T(" the noticed file is gone; loading the pack file\r\n") , flSAY_APPEND | flSAY_LOG ) ;
        }
            while( !ether && etThread.diskFileExistsF( tin0P , tPackNoticed ) ) { ++ s ; ether.osSleepF( tin0P , TOCK * 0x10 ) ; }
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        {
        TELL( "loading a pack/waiting for the \"loaded\" baton file to disappear" ) ;
        //etThread.ifcSayF( tin0P , TF1(DDNUMB)+T(" waiting for the noticed file to disappear\r\n") , flSAY_APPEND | flSAY_LOG ) ;

        if( !bNewMinIsSet ) poolC::poolOldRootIF( tin0P ).flagsBackF( tin0P ) |= flPOOLoLDbACK_NOcURSORrESET ;
        const boolT bNewMinIsSet = !!poolC::poolOldRootIF( tin0P ).offNewMinF( tin0P ) ;
        ZE( countT , cFish ) ;
        ZE( countT , cPacks ) ;
        TELL( "loading a pack/setting up" ) ;

        sCountT time2as = time2a ;
        countT time1as = time1a ;
        etThread.osTimeNowF( tin0P , time1a , time2a ) ;
        ZE( sCountT , time2a ) ;
        ZE( countT , time1a ) ;

        TN( tPackLoaded  , "///ideafarm/ephemeral/gen/lake/pack.loaded."  ) ; tPackLoaded  += TF1(etThread.diskIdF(tin0P,T("///c"))) ;
        TN( tPackNoticed , "///ideafarm/ephemeral/gen/lake/pack.noticed." ) ; tPackNoticed += TF1(etThread.diskIdF(tin0P,T("///c"))) ;
        TN( tPack        , "///ideafarm/ephemeral/gen/lake/pack" ) ;

        lakeC& lake = *pLakeP ;
    {
    if( pLakeP )
    TN( tLog , "///d/ideafarm.log.html" ) ;

    if( !pLakeP ) pLakeP = new( 0 , tin0P , LF ) lakeC( tin0P , etThread ) ;
{
voidT loadPackF( tin0S& tin0P , etherC& ether , etherC& etThread , etherC& etUsesPoolPrime , lakeC*& pLakeP , byteT*& pbPackLagP )
*/
  write the 2 image fish
    writes the blob to the lake, using name pcName
     if the '.' word begins with '$', the remaining substring is queried in the dictionary
    set pcName using the '.' words in the last '/' word in name
    get psttName cbBlob pbBlob
   for each fish
   initialize offset to sizeof( countT )
   read the pack box 
  for each pack file (no wildcard is used, so always just processes -the- pack file
 while not fired
pseudocode
/*

DONE( tmFreshCalendarF )
}
    }
        }
            dayDone = today ;
            stockCalendarFishF( tin0P , etThread , lake , pcNameCalendar , bNewMinIsSet ) ;

            }
                continue ;
                }
                    ++ s ; etThread.osSleepF( tin0P , TOCK * 0x10 , TOCK ) ;
                    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                {
            {
            else if( today == dayDone )
            if( bWoth ) bWoth = 0 ;

            etThread.osTimeNowF( tin0P , countTC() , today ) ;
            ZE( sCountT , today ) ;
        {
        while( !ether && !etThread )
        ZE( countT , dayDone ) ;

        boolT bWoth = 1 ;
        countT pcNameCalendar[] = { 3 , 1 , 0 } ;
    {
    if( !( cIn ++ ) )
    static countT cIn ;

    boolT& bNewMinIsSet = *(boolT*)pTaskP->c2 ;
    lakeC& lake         = *(lakeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmFreshCalendarF )

}
    //etThread.ifcSayF( tin0P , T("stockOneImageFishF: ")+TF1(pcP)+T("  \"")+T(psttP)+T("\"\r\n") , flSAY_APPEND | flSAY_LOG ) ;
    etThread.delF( tin0P , pbBlob ) ;
    }
        THREADmODE1rESTORE
        lakeP.writeF( tin0P , pcP , pbBlob , cbBlob , 1 ) ;
        THREADmODE1oN( flTHREADmODE1_POOLoLDsECTION1 ) ;
    {
    else
    if( !bNewMinIsSetP ) lakeP.writeF( tin0P , pcP , pbBlob , cbBlob , 1 ) ;

    etThread.delF( tin0P , pbi ) ;
    etThread.memCopyF( tin0P , pbBlob + cb0 , pbi , cbi ) ;
    etThread.memCopyF( tin0P , pbBlob       , t0  , cb0 ) ;
    etThread.newF( tin0P , LF , pbBlob , cbBlob ) ; ___( pbBlob ) ;
    cbBlob = cb0 + cbi ;
    countT cb0 = t0.csF( tin0P ) ;

    textC t0 = T("HTTP/1.0 200 OK\r\nContent-Type: ")+T(psttTypeP)+T("\r\nContent-Length: ")+TF4(cbi,flFORMAT_FILLzE|flFORMAT_NObASE|flFORMAT_FOREIGN,8,0xa)+T("\r\n\r\n") ;

    etThread.boxGetShadowF( tin0P , pbi , cbi , psttP ) ; ___( pbi ) ;
    ZE( countT , cbi ) ;
    ZE( byteT* , pbi ) ;
    ZE( countT   , cbBlob ) ;
    ZE( osTextT* , pbBlob ) ;
    TN( tLog , "///d/ideafarm.log.html" ) ;
{
voidT stockOneImageFishF( tin0S& tin0P , etherC& etThread , lakeC& lakeP , const countT* const pcP , const strokeS* const psttP , const strokeS* const psttTypeP , const boolT bNewMinIsSetP )
*/
 writes reply blob to lake using name pcP
 makes reply blob by concatenating reply header with blob
 reads blob from box psttP
pseudocode
/*

}
    etThread.delF( tin0P , postf ) ;
    }
        THREADmODE1rESTORE
        lakeP.writeF( tin0P , pcP , postf , costf , 1 ) ;
        THREADmODE1oN( flTHREADmODE1_POOLoLDsECTION1 ) ;
    {
    else
    if( !bNewMinIsSetP ) lakeP.writeF( tin0P , pcP , postf , costf , 1 ) ;

    etThread.delF( tin0P , psttf ) ;
    countT costf = etThread.strMakeF( tin0P , LF , postf , psttf ) ; ___( postf ) ;
    ZE( osTextT* , postf ) ;
    etThread.strCalendarF( tin0P , psttf , timeN2 ) ; ___( psttf ) ;
    ZE( strokeS* , psttf ) ;

    etThread.osTimeNowF( tin0P , countTC() , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
{
voidT stockCalendarFishF( tin0S& tin0P , etherC& etThread , lakeC& lakeP , const countT* const pcP , const boolT bNewMinIsSetP )
*/
 writes reply blob to lake using name pcP
 makes reply blob by concatenating reply header with blob
 reads blob from box psttP
pseudocode
/*

#define CCiDnAMEmAX 0x10

}
{
stateC( tin0P , etherP , sizeof *this , 0 , translateStateF )
stateS::stateS( tin0S& tin0P , etherC& etherP ) :

TRANSLATEsTATE_END
    state.idMe ++ ;
TRANSLATEsTATE_MIDDLE
    case 1 : { state.idMe = stateOther.idMe ; state.idPass = stateOther.idPass ; state.idStep = stateOther.idStep ; }
TRANSLATEsTATE_BEGIN( stateS , 1 )

;
}
    stateS( tin0S& tin0P , etherC& etherP ) ;

    countT idStep ;
    countT idPass ;
    countT idMe ;
    countT idVersion ;
{
struct stateS : public stateC

/*1*/WAKEhIDE( "city.publisher.load" )/*1*/
/**/
*/
  if specified, then a small lake pack is made that focuses on func.1330004.busC.cSubscribersF
 !test
command line parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

