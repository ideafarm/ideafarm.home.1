
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    header.swabF() ;
    }
        }
            }
                rMiddle.swabF() ;
                pbc += rMiddle.cbData ;
                stsRepliesP << pSoul ;
                }
                    }
                        break ;
                        ifcSayIF( T("unrecognized rMiddle.idType: ")+TF1(rMiddle.idType) , flSAY_APPEND | flSAY_LOG ) ;
                    {
                    default :
                    }
                        break ;

                        }
                            if( 5 < rMiddle.cbData ) soul.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_byteTptr , pbData , rMiddle.cbData - 5 ) ;           // BIT MAP
                            soul << (countT)*pbData ; pbData += 1 ;                                                                                 // PROTOCOL
                            nn >> soul ;
                            nicNameC nn( SWABnET4( *(count02T*)pbData ) ) ; pbData += sizeof( count02T ) ;                                          // ADDRESS
                        {
                        if( !POOP )

                        __( rMiddle.cbData < 5 ) ;
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_WKS :
                    }
                        break ;

                        }
                            }
                                time2 = time1 = 0 ;
                                soul << (countT&)time2 ;
                                soul << time1 ;
                                third.timeFromSecondsIF( tin0P , time1 , time2 , SWABnET4( *(count02T*)pbData ) ) ; pbData += sizeof( count02T ) ;
                            {
                            while( cTries -- )
                            countT cTries = 4 ; // REFRESH RETRY EXPIRE MINIMUM
                            ZE( sCountT , time2 ) ;
                            ZE( countT  , time1 ) ;

                            soul << (countT)SWABnET4( *(count02T*)pbData ) ; pbData += sizeof( count02T ) ; // SERIAL
                            _IO_
                        {
                        if( !POOP )

                        __( pbe - pbData < 5 * sizeof( count02T ) )

                        delF( tin0P , psttName ) ;
                        soul << psttName ;
                        header.nameF( tin0P , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;

                        delF( tin0P , psttName ) ;
                        soul << psttName ;
                        header.nameF( tin0P , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                        ZE( strokeS* , psttName ) ;
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_SOA :
                    }
                        break ;
                        soul.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_byteTptr , pbData , rMiddle.cbData ) ;
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_OPTION :
                    case ifcIDtYPEdNSqUERY_NULL :
                    }
                        break ;

                        }
                            delF( tin0P , psttName ) ;
                            soul << psttName ;
                            header.nameF( tin0P , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                            ZE( strokeS* , psttName ) ;

                            pbData += sizeof( count01T ) ;
                            soul << (countT)*(count01T*)pbData ; // cRank
                            _IO_
                        {
                        if( !POOP )

                        __( rMiddle.cbData < sizeof( count01T ) )
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_MX :
                    }
                        break ;

                        __( cText ) ;
                        }
                            pbData += 1 + *pbData ;
                            soul << (strokeS*)td ;
                            TN( td , postb ) ;
                            postb[ *pbData ] = 0 ;
                            memCopyF( tin0P , postb , pbData + 1 , *pbData ) ;
                            byteT  postb[ 0x100 ] ;
                            cText -- ;
                            _IO_
                        {
                        while( pbData < pbc + rMiddle.cbData )

                        }
                            soul << cText ;
                            pbData = pbdSave ;
                            }
                                pbData += 1 + *pbData ;
                                cText ++ ;
                            {
                            while( pbData < pbc + rMiddle.cbData )
                            const byteT* pbdSave = pbData ;
                        {
                        ZE( countT , cText ) ;
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_TXT :
                    case ifcIDtYPEdNSqUERY_HINFO :
                    }
                        break ;
                        delF( tin0P , psttName ) ;
                        soul << psttName ;
                        header.nameF( tin0P , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                        ZE( strokeS* , psttName ) ;
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_PTR :
                    case ifcIDtYPEdNSqUERY_MR :
                    case ifcIDtYPEdNSqUERY_MG :
                    case ifcIDtYPEdNSqUERY_MB :
                    case ifcIDtYPEdNSqUERY_CNAME :
                    case ifcIDtYPEdNSqUERY_NS :
                    }
                        delF( tin0P , psttName ) ; // INTENTIONAL FALLTHROUGH
                        soul << psttName ;
                        header.nameF( tin0P , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                        ZE( strokeS* , psttName ) ;
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_MINFO :
                    }
                        break ;

                        }
                            nn >> soul ;
                            nicNameC nn( SWABnET4( *(countT*)pbData ) ) ;
                        {
                        if( !POOP )

                        __( rMiddle.cbData < sizeof( countT ) )
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_A :
                {
                switch( rMiddle.idType )
                const byteT* pbData = pbc ; // TO AVOID SIDE EFFECTS THAT WOULD CHANGE pbc

                }
                    break ;
                    __1
                {
                if( pbc + rMiddle.cbData > pbe )

                }
                    pbc += sizeof rMiddle ;

                    }
                        time2 = time1 = 0 ;
                        soul << (countT&)time2 ;
                        soul << time1 ;
                        third.timeFromSecondsIF( tin0P , time1 , time2 , rMiddle.secondsToLive ) ;
                        ZE( sCountT , time2 ) ;
                        ZE( countT  , time1 ) ;
                        _IO_
                    {
                    soul << (countT)rMiddle.idClass ;
                    soul << (countT)rMiddle.idType ;
                    rMiddle.swabF() ;
                    _IO_
                {
                else
                }
                    break ;
                    __1
                    DEL( pSoul ) ;
                    _IO_
                {
                if( pbe - pbc < sizeof rMiddle )
                dnsResourceMiddleS& rMiddle = *(dnsResourceMiddleS*)pbc ;

                }
                    delF( tin0P , psttName ) ;
                    soul << psttName ;
                    header.nameF( tin0P , *this , psttName , pbc , pbe - pbc ) ; ___( psttName ) ;
                    ZE( strokeS* , psttName ) ;
                    _IO_
                {
                soulC& soul = *pSoul ;
                _IO_
            {
            if( pSoul )
            soulC* pSoul = new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) , flSOUL_null , idTypeAnswer ) ; ___( pSoul ) ;

            else                         __1
            else if( cNote && cNote -- ) idTypeAnswer = ifcIDsECTIONdNSrEPLY_NOTE ;
            else if( cAuth && cAuth -- ) idTypeAnswer = ifcIDsECTIONdNSrEPLY_AUTHORITY ;
                 if( cAnsw && cAnsw -- ) idTypeAnswer = ifcIDsECTIONdNSrEPLY_ANSWER ;
            ZE( countT , idTypeAnswer ) ;
            _IO_
        {
        while( pbc < pbe && cResources -- && !POOP )

        countT cNote = header.cNotes       ;
        countT cAuth = header.cAuthorities ;
        countT cAnsw = header.cAnswers     ;
        countT cResources = header.cAnswers + header.cAuthorities + header.cNotes ;

        memCopyF( tin0P , pbHeaderAndQueriesP , pbReplyP , cbHeaderAndQueriesP ) ;
        newF( tin0P , LF , pbHeaderAndQueriesP , cbHeaderAndQueriesP ) ; ___( pbHeaderAndQueriesP ) ;
        cbHeaderAndQueriesP = pbc - pbReplyP ;
        _IO_
    {
    if( !POOP )

    }
        }
            }
                }
                    stsQueriesP << pSoul ;

                    soul << v2 ;
                    soul << v1 ;
                    delF( tin0P , psttName ) ;
                    soul << psttName ;

                    soulC& soul = *pSoul ;
                {
                else
                }
                    break ;
                    __1
                    delF( tin0P , psttName ) ;
                {
                if( !pSoul )
                //processGlobal2I.pc Utility[ 0 ] = (countT)pSoul ;
                //traceF( tin0P , T("dnsParseF [pSoul]:    ")+TF2((countT)pSoul,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN) ) ;
                soulC* pSoul = new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) ) ; ___( pSoul ) ;

                countT v2 = SWABnET2( *(count01T*)pbc ) ; pbc += sizeof( count01T ) ;
                countT v1 = SWABnET2( *(count01T*)pbc ) ; pbc += sizeof( count01T ) ;
                _IO_
            {
            else
            }
                break ;
                __1
                delF( tin0P , psttName ) ;
            {
            if( pbc + 2 * sizeof( count01T ) > pbe )

            header.nameF( tin0P , *this , psttName , pbc , pbe - pbc ) ; ___( psttName ) ;
            ZE( strokeS* , psttName ) ;
            _IO_
        {
        while( pbc < pbe && cq -- )
        countT cq = header.cQuerys ;
        _IO_
    {
    // LOAD stsQueriesP AND SET pbc TO THE END OF THE QUERIES PORTION OF pbReplyP

    const byteT* const pbe = pbReplyP + cbReplyP ;
    const byteT*       pbc = pbReplyP + sizeof( dnsMsgHeaderS ) ; // QNAME
    header.swabF() ;
    dnsMsgHeaderS& header = *(dnsMsgHeaderS*)pbReplyP ;

    _IO_

    }
        if( POOP ) return ;
        __( cbReplyP <= sizeof( dnsMsgHeaderS ) ) ;
        __Z( pbReplyP ) ;
        __( stsRepliesP.idTypeF( tin0P ) - ifcSTACKtYPE_PTR_soulC ) ;
        __( stsRepliesP ) ;
        __( stsQueriesP.idTypeF( tin0P ) - ifcSTACKtYPE_PTR_soulC ) ;
        __( stsQueriesP ) ;
        __( cbHeaderAndQueriesP ) ;
        __NZ( pbHeaderAndQueriesP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::dnsParseF( tin0S& tin0P , byteT*& pbHeaderAndQueriesP , countT& cbHeaderAndQueriesP , stackC& stsQueriesP , stackC& stsRepliesP , const byteT* const pbReplyP , const countT cbReplyP )/*1*/

//U::20250728@1705: USE [pbReplyP,cbReplyP] TO VALIDATE ALL CALCULATED POINTER VALUES TO ELIMINATE ATTACK SURFACE

/**/
*/
  the length of the data at pbReplyP
 cbReplyP
   a dnsMsgHeaderS followed by the number of queries, answers, authorities, and notes indicated in that header
  must contain the address of a full dns reply
  must not be 0
 pbReplyP  
  the soulC object will contain the resource information from wo resource record
  i will put a soulC object onto this stack for each resource record at pbReplyP
  must be empty
 stsRepliesP
   idClass
   idType
   psttName
  each soul is a query
 stsQueriesP
  i will set it to the length of the data that i put into pbHeaderAndQueriesP
  must be 0
 cbHeaderAndQueriesP
  i will allocate this and copy the header and queries portion of the data at pbReplyP into it
  must be 0
 pbHeaderAndQueriesP
 tin0P
arguments
 20130918@0900: U:: i should be edited to refer to the input as a "dns message" rather than a "dns reply"
i obtain information by parsing the dns reply at headerP
\<A HREF=\"5.103018e.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dnsParseF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

