
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            thirdC::c_memsetIF( tinBaseP , pReg->postPoolName , sizeof pReg->postPoolName ) ;
            pReg->resetF( tinBaseP ) ;
            pReg->flagsi = fliPOOLrEGISTRATIONs_GRABBED ;
        {
        if( pReg && 1 == decv02AM( pReg->cRefPoolReg ) )                       // MUST BE DONE AFTER sexC ARE DT
        grabitC grabx( tinBaseP , TAG( TAGiDnULL ) , (byteT*)&pReg->flagsi , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_null , 0 , ifcIDgRABlAYER_8POOL4dT ) ;
    {

    }
        DELzOMBIE( pDoomed ) ;                                          // slotsC AND sexC ARE DT HERE
        guts_poolC_S* pDoomed = (guts_poolC_S*)(byteT*)napGuts ; 
    {

    }
        if( offr == CpOOLrEGISTRATIONSmAX ) { BLAMMO ; }
        }
            }
                break ;
                pReg = pRegs + offr ;
            {
            if( pRegs[ offr ].flagsi & fliPOOLrEGISTRATIONs_FORMATTED && !thirdC::c_strcmpIF( tinBaseP , pRegs[ offr ].postPoolName , guts.postName ) )
        {
        for( offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )
        grabitC grabx( tinBaseP , TAG( TAGiDnULL ) , (byteT*)&home.fliGrab , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_null , 0 , ifcIDgRABlAYER_8POOL3dT ) ;
        ZE( countT , offr ) ;
        poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;

        // if array exhausted blammo
        //   break
        //    unformat
        //   if decrementing cRef resulted in 0
        //  if formatted and name matches
        // for each array element
        // grab array
        // 
        // RECIPE

        // THIS MEANS THAT poolC INSTANCES THAT ARE REGISTERED ARE NOT NECESSARILY FULLY CONSTRUCTED AND USEABLE
    {   // *this IS REGISTERED EARLY AND DEREGISTERED LATE BECAUSE sexC CONSTRUCTORS AND DESTRUCTORS MUST REFER TO IT
    ZE( poolRegistrationS* , pReg ) ;
    homeS& home = homeS::homeIF() ;

    //CONoUTrAW( " *********************************************************************************************************\r\n" ) ;
    //CONoUTrAW( guts.postName ) ;
    //CONoUTrAW( "~poolC/-:  " ) ;

    processGlobal5I._poolC_grab_pPool.ungrabF( tinBaseP ) ;

    }
        __Z( pCursor ) ;
        }
            pCursor = pCursor->pNext ;

            }
                break ;
                pCursor->pNext = pNext ;
            {
            if( pCursor->pNext == this )
        {
        while( pCursor )
        poolC* pCursor = processGlobal2I._poolC_pPool ;
    {
    else
    if( processGlobal2I._poolC_pPool == this ) processGlobal2I._poolC_pPool = pNext ;

    if( guts.idStateSpace && ! -- processGlobal2I._poolC_cBacked ) processGlobal2I._poolC_bQuitFlushing ++ ;

    processGlobal5I._poolC_grab_pPool.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

    }
        DELzOMBIE( pDoomed ) ;
        fileC* pDoomed = (fileC*)pbFileFace ;
    {
    if( F(flagsInstance) & flPOOLiNSTANCE_FACEcONSTRUCTED )

    if( ((tinNormalS&)tinBaseP).pPoolUse == this ) ((tinNormalS&)tinBaseP).pPoolUse = 0 ;

    else if( ((tinNormalS&)tinBaseP).pag1->pPoolAdamTemp == this ) ((tinNormalS&)tinBaseP).pag1->pPoolAdamTemp = 0 ;
    else if( ((tinNormalS&)tinBaseP).pag1->pPoolHomeTemp == this ) ((tinNormalS&)tinBaseP).pag1->pPoolHomeTemp = 0 ;
    else if( ((tinNormalS&)tinBaseP).pag1->pPoolScratch  == this ) ((tinNormalS&)tinBaseP).pag1->pPoolScratch  = 0 ;
    else if( ((tinNormalS&)tinBaseP).pag1->pPoolAdamPerm == this ) ((tinNormalS&)tinBaseP).pag1->pPoolAdamPerm = 0 ;
         if( ((tinNormalS&)tinBaseP).pag1->pPoolHomePerm == this ) ((tinNormalS&)tinBaseP).pag1->pPoolHomePerm = 0 ;

    }
        DELzOMBIE( ((tinNormalS&)tinBaseP).pag1->pPoolHomePerm ) ;
        DELzOMBIE( ((tinNormalS&)tinBaseP).pag1->pPoolAdamPerm ) ;
        DELzOMBIE( ((tinNormalS&)tinBaseP).pag1->pPoolScratch  ) ;
        DELzOMBIE( ((tinNormalS&)tinBaseP).pag1->pPoolHomeTemp ) ;
    {
    if( ((tinNormalS&)tinBaseP).pag1->pPoolAdamTemp == this ) // THIS IS OK BECAUSE ADAMteMP CONTAINS ITS OWN INDEX

    }
        }
            THREADmODE3rESTORE
            }
                }
                    if( ~hList ) listC::unIndexIF( tinBaseP , hList ) ;

                    listC::openIF( tinBaseP , hList , pczName , flLISToPEN_IFeXISTS ) ;
                    countT pczName[] = { LISTnAMEsYS_ROOT , LISTnAMEsYS_ROOTaPPLICATION , 0 } ;
                    handleC hList( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

                    puseC puseMe( tinBaseP , *this ) ;
                {
            {
            if( bIndexed )

            }
                bIndexed = listC::isIndexedIF( tinBaseP ) ; // IF I JUST DELETED LISTnAMEsYS_ROOT, THE ASSOCIATED INDEX WILL NO LONGER EXIST
                puseC puseMe( tinBaseP , *this ) ;
            {
            ZE( boolT , bIndexed ) ;

            }
                DELzOMBIE( pFace ) ;
                }
                    listC::deleteIF( tinBaseP , pczName ) ;
                    countT pczName[] = { LISTnAMEsYS_ROOT , 0 } ;
                    puseC puseMe( tinBaseP , *this ) ;
                {
            {
            if( !guts.idStateSpace )
            THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY )
        {
        if( 1 == decv02AM( pFace->cRef ) )
        face_poolC_S* pFace = (face_poolC_S*)(byteT*)napFace ;
    {

    }
        stPoolNames.ungrabF( tinBaseP ) ;
        if( ids ) stPoolNames.extractF( 0 , tinBaseP ) ;
        stPoolNames.sinkF( tinBaseP , ids , (countT)guts.postName , flSTACKsINK_QUERY ) ;
        stPoolNames.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        ZE( countT , ids ) ;
        stackC& stPoolNames = ((tinNormalS&)tinBaseP).pEther->ifcStkPoolNamesF( tinBaseP ) ;
    {
    if( ((tinNormalS&)tinBaseP).pEther )               // IF !((tinNormalS&)tinBaseP).pEther THEN I WILL NOT BE DEREGISTERED, BUT THAT DOES NOT MATTER BECAUSE tmWatchF IS GONE

    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------
    // UNREGISTER MY NAME SO THAT tmWatchF CAN SEE WHICH poolC NAMES THIS PROCESSES IS USING
    // ---------------------------------------------------------------------------------------------------------------------------------------------------------------

    //CONoUTrAW( " *********************************************************************************************************\r\n" ) ;
    //CONoUTrAW( guts.postName ) ;
    //CONoUTrAW( "~poolC/+:  " ) ;

    _IO_
    TINSL
{
/*1*/poolC::~poolC( voidT )/*1*/

}
    //THREADmODE3rESTORE
    //DEL( pRoot ) ;
    //THREADmODE3oN( flTHREADmODE3_ALLOWdESTRUCTIONoFlISTINGc ) ;
    //listC* pRoot = &APT( listC , aptListRoot ) ;
    //U:: THIS CODE IS NOW REDUNDANT AND DOES NOT WORK

    //_IO_
    TINSL
{
poolC::face_poolC_S::~face_poolC_S( voidT )

}
    }
        DELzOMBIE( ppSlots[ offs ] ) ;
        DELzOMBIE( pDoomed ) ;
        grabC* pDoomed = (grabC*)pbzaGrab + offs ;
    {
    for( countT offs = 0 ; offs < sizeof ppSlots / sizeof ppSlots[ 0 ] ; offs ++ )

    }
        if( !cTried ) break ; // ALL ppSlots ELEMENTS ARE NULL

        }
            }
                break ;
                if( rc == 2 ) bDone = 1 ;
            {
            if( rc )
            countT rc = ppSlots[ offs ]->deleteTopSexF( tinBaseP ) ;
            cTried ++ ;

            if( !ppSlots[ offs ] ) continue ;
        {
        for( countT offs = 0 ; offs < sizeof ppSlots / sizeof ppSlots[ 0 ] ; offs ++ )
        ZE( countT , cTried ) ;
    {
    while( !bDone )
    ZE( boolT , bDone ) ;

    _IO_
    TINSL
{
poolC::guts_poolC_S::~guts_poolC_S( voidT )

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

