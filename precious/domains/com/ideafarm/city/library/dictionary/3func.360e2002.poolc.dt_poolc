
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            thirdC::c_memsetIF( tinP , pReg->postPoolName , sizeof pReg->postPoolName ) ;
            pReg->resetF( tinP ) ;
            pReg->flagsi = fliPOOLrEGISTRATIONs_GRABBED ;
        {
        if( pReg && 1 == decv02AM( pReg->cRefPoolReg ) )                       // MUST BE DONE AFTER sexC ARE DT
        grabitC grabx( tinP , TAG( TAGiDnULL ) , (byteT*)&pReg->flagsi , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_null , 0 , ifcIDgRABlAYER_8POOL4dT ) ;
    {

    }
        DELzOMBIE( pDoomed ) ;                                          // slotsC AND sexC ARE DT HERE
        guts_poolC_S* pDoomed = (guts_poolC_S*)(byteT*)napGuts ; 
    {

    }
        if( offr == CpOOLrEGISTRATIONSmAX ) { BLAMMO ; }
        }
            }
                break ;
                pReg = pRegs + offr ;
            {
            if( pRegs[ offr ].flagsi & fliPOOLrEGISTRATIONs_FORMATTED && !thirdC::c_strcmpIF( tinP , pRegs[ offr ].postPoolName , guts.postName ) )
        {
        for( offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )
        grabitC grabx( tinP , TAG( TAGiDnULL ) , (byteT*)&home.fliGrab , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_null , 0 , ifcIDgRABlAYER_8POOL3dT ) ;
        ZE( countT , offr ) ;
        poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;

        // if array exhausted blammo
        //   break
        //    unformat
        //   if decrementing cRef resulted in 0
        //  if formatted and name matches
        // for each array element
        // grab array
        // 
        // RECIPE

        // THIS MEANS THAT poolC INSTANCES THAT ARE REGISTERED ARE NOT NECESSARILY FULLY CONSTRUCTED AND USEABLE
    {   // *this IS REGISTERED EARLY AND DEREGISTERED LATE BECAUSE sexC CONSTRUCTORS AND DESTRUCTORS MUST REFER TO IT
    ZE( poolRegistrationS* , pReg ) ;
    homeS& home = homeS::homeIF() ;

    //CONoUTrAW( " *********************************************************************************************************\r\n" ) ;
    //CONoUTrAW( guts.postName ) ;
    //CONoUTrAW( "~poolC/-:  " ) ;

    processGlobal5I._poolC_grab_pPool.ungrabF( tinP ) ;

    }
        __Z( pCursor ) ;
        }
            pCursor = pCursor->pNext ;

            }
                break ;
                pCursor->pNext = pNext ;
            {
            if( pCursor->pNext == this )
        {
        while( pCursor )
        poolC* pCursor = processGlobal2I._poolC_pPool ;
    {
    else
    if( processGlobal2I._poolC_pPool == this ) processGlobal2I._poolC_pPool = pNext ;

    if( guts.idStateSpace && ! -- processGlobal2I._poolC_cBacked ) processGlobal2I._poolC_bQuitFlushing ++ ;

    processGlobal5I._poolC_grab_pPool.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        DELzOMBIE( pDoomed ) ;
        fileC* pDoomed = (fileC*)pbFileFace ;
    {
    if( F(flagsInstance) & flPOOLiNSTANCE_FACEcONSTRUCTED )

    if( tinP.pPoolUse == this ) tinP.pPoolUse = 0 ;

    else if( tinP.pag1->pPoolAdamTemp == this ) tinP.pag1->pPoolAdamTemp = 0 ;
    else if( tinP.pag1->pPoolHomeTemp == this ) tinP.pag1->pPoolHomeTemp = 0 ;
    else if( tinP.pag1->pPoolScratch  == this ) tinP.pag1->pPoolScratch  = 0 ;
    else if( tinP.pag1->pPoolAdamPerm == this ) tinP.pag1->pPoolAdamPerm = 0 ;
         if( tinP.pag1->pPoolHomePerm == this ) tinP.pag1->pPoolHomePerm = 0 ;

    }
        DELzOMBIE( tinP.pag1->pPoolHomePerm ) ;
        DELzOMBIE( tinP.pag1->pPoolAdamPerm ) ;
        DELzOMBIE( tinP.pag1->pPoolScratch  ) ;
        DELzOMBIE( tinP.pag1->pPoolHomeTemp ) ;
    {
    if( tinP.pag1->pPoolAdamTemp == this ) // THIS IS OK BECAUSE ADAMteMP CONTAINS ITS OWN INDEX

    }
        }
            THREADmODE3rESTORE
            }
                }
                    if( ~hList ) listC::unIndexIF( tinP , hList ) ;

                    listC::openIF( tinP , hList , pczName , flLISToPEN_IFeXISTS ) ;
                    countT pczName[] = { LISTnAMEsYS_ROOT , LISTnAMEsYS_ROOTaPPLICATION , 0 } ;
                    handleC hList( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LISTING ) ;

                    puseC puseMe( tinP , *this ) ;
                {
            {
            if( bIndexed )

            }
                bIndexed = listC::isIndexedIF( tinP ) ; // IF I JUST DELETED LISTnAMEsYS_ROOT, THE ASSOCIATED INDEX WILL NO LONGER EXIST
                puseC puseMe( tinP , *this ) ;
            {
            ZE( boolT , bIndexed ) ;

            }
                DELzOMBIE( pFace ) ;
                }
                    listC::deleteIF( tinP , pczName ) ;
                    countT pczName[] = { LISTnAMEsYS_ROOT , 0 } ;
                    puseC puseMe( tinP , *this ) ;
                {
            {
            if( !guts.idStateSpace )
            THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY )                                                                                            \
        {
        if( 1 == decv02AM( pFace->cRef ) )
        face_poolC_S* pFace = (face_poolC_S*)(byteT*)napFace ;
    {

    //CONoUTrAW( " *********************************************************************************************************\r\n" ) ;
    //CONoUTrAW( guts.postName ) ;
    //CONoUTrAW( "~poolC/+:  " ) ;

    _IO_
    TINSL
{
/*1*/poolC::~poolC( voidT )/*1*/

}
    //THREADmODE3rESTORE
    //DEL( pRoot ) ;
    //THREADmODE3oN( flTHREADmODE3_ALLOWdESTRUCTIONoFlISTINGc ) ;
    //listC* pRoot = &APT( listC , aptListRoot ) ;
    //U:: THIS CODE IS NOW REDUNDANT AND DOES NOT WORK

    //_IO_
    TINSL
{
poolC::face_poolC_S::~face_poolC_S( voidT )

}
    }
        DELzOMBIE( ppSlots[ offs ] ) ;
        DELzOMBIE( pDoomed ) ;
        grabC* pDoomed = (grabC*)pbzaGrab + offs ;
    {
    for( countT offs = 0 ; offs < sizeof ppSlots / sizeof ppSlots[ 0 ] ; offs ++ )

    }
        if( !cTried ) break ; // ALL ppSlots ELEMENTS ARE NULL

        }
            }
                break ;
                if( rc == 2 ) bDone = 1 ;
            {
            if( rc )
            countT rc = ppSlots[ offs ]->deleteTopSexF( tinP ) ;
            cTried ++ ;

            if( !ppSlots[ offs ] ) continue ;
        {
        for( countT offs = 0 ; offs < sizeof ppSlots / sizeof ppSlots[ 0 ] ; offs ++ )
        ZE( countT , cTried ) ;
    {
    while( !bDone )
    ZE( boolT , bDone ) ;

    _IO_
    TINSL
{
poolC::guts_poolC_S::~guts_poolC_S( voidT )

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

