
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK * 0x4 ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    
        etThread.delF( tin0P , pstt1m ) ;
        }
            etThread.delF( tin0P , psttRenamed ) ;
            etThread.delF( tin0P , posti ) ;
            }
                etThread( tin0P , pStkTo ) ;

                }
                    psttRenamed = 0 ;
                    pStk->sinkF( tin0P , countTC() , psttRenamed , flSTACKsINK_UNIQUE ) ;
                    stackC* pStk = bRejected ? &st_psttRejected : &st_psttSent ;
                    POOPR
                {
                if( POOP )

                etThread.delF( tin0P , psttShort ) ;
                else ((tin123S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tOutboxSent+T(psttShort) , psttRenamed ) ;
                }
                    ((tin123S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tOutboxNotSent+T(psttShort) , psttRenamed ) ;
                    bRejected = 1 ;
                    POOPR
                {
                if( POOP )
                ZE( boolT , bRejected ) ;

                etThread.strWordF( tin0P , psttShort , psttRenamed , sttq , sSlash , - 1 ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

                ((tin123S&)tin0P).pEtScratch->boxPutF( tin0P , tName , posti , costi ) ;
                //}
                //    etThread.delF( tin0P , pstte ) ;
                //    tName += T("/")+T(pstte) ;
                //    *pStkTo >> pstte ;
                //    ZE( strokeS* , pstte ) ;
                //{
                //while( *pStkTo )
                TN( tName , "k2smtpout.secureserver.net//smtp/0" ) ; //DEFAULT idAccountFrom

                }
                    etThread.delF( tin0P , pstti ) ;
                    etThread.delF( tin0P , pstt1lines ) ;

                    }
                        etThread.delF( tin0P , psttLower ) ;
                        }
                            }
                                }
                                    //LOGrAW( T("email: \"")+T(psttEmail)+T("\"\r\n") ) ;
                                    *pStkTo << psttEmail ;
                                {
                                if( psttEmail )
                                etThread.strSubstringF( tin0P , psttEmail , idf , sttq , S1C('>') , psttLower ) ; ___( psttEmail ) ;
                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                ZE( strokeS* , psttEmail ) ;
                            {
                            if( idf )
                            etThread.strIdF( tin0P , idf , sttq , S1C('<') , psttLower ) ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                            countT idf = 1 ;
                        {
                        )
                            1 == etThread.strIdF( tin0P , T("bcc" ": ") , psttLower )
                            1 == etThread.strIdF( tin0P , T( "cc" ": ") , psttLower ) ||
                            1 == etThread.strIdF( tin0P , T( "to: ") , psttLower ) ||
                        (
                        if

                        etThread.strConvertToLowerCaseF( tin0P , psttLower , psttc2 ) ; ___( psttLower ) ;
                        ZE( strokeS* , psttLower ) ;
                    {
                    FORsTRINGSiN2( pstt1lines )
                    etThread.strWordsOldF( tin0P , pstt1lines, pstti , sttq , T("\r\n") ) ; ___( pstt1lines ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , pstt1lines ) ;

                    etThread.strMakeF( tin0P , LF , pstti , T(posti) ) ; ___( pstti ) ;
                    ZE( strokeS* , pstti ) ;
                {
                if( pStkTo )
                etThread( tin0P , pStkTo , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE | flSTACKc_ALLOWmULTIPLEuNSERIALIZED , ifcSTACKtYPE_PTR_strokeS ) ;
                ZE( stackC* , pStkTo ) ;
                CONoUTrAW3( "costi" ":" , costi , "\r\n" ) ;
            {
            else
            if( POOP ) { POOPR ; }
            ((tin123S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , psttRenamed ) ; ___( posti ) ;
            ZE( countT , costi ) ;
            ZE( osTextT* , posti ) ;
            CONoUTrAW( T("RENAMED: ")+T(psttRenamed)+T("\r\n") ) ;

            }
                continue ;
                POOPR
            {
            if( POOP )
            ((tin123S&)tin0P).pEtScratch->diskMoveFileOrDirUniqueF( tin0P , psttRenamed , psttc1 ) ;
            ZE( strokeS* , psttRenamed ) ;

            CONoUTrAW( T("   FILE: ")+T(psttc1)+T("\r\n") ) ;
        {
        FORsTRINGSiN1( pstt1m )
        etThread.boxMenuF( tin0P , soul , tOutbox+tStar , 0 , 0x10 ) ; ___( pstt1m ) ;
        ZE( strokeS* , pstt1m ) ;

        }
            }
                while( ~hWalk ) ;
                }
                    }
                        ppStk[ off ]->extractF( tin0P ) ;
                        etThread.delF( tin0P , psttr ) ;
                    {
                    else
                    if( POOP ) { POOPR }

                    etThread.delF( tin0P , psttShort ) ;
                    ((tin123S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , (off?tOutboxNotSent:tOutboxSent)+T(psttShort) , psttr ) ;
                    etThread.strWordF( tin0P , psttShort , psttr , sttq , sSlash , - 1 ) ; ___( psttShort ) ;
                    ZE( strokeS* , psttShort ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

                    strokeS*& psttr = *(strokeS**)&ppStk[ off ]->downF( tin0P , hWalk ) ;
                {
                do
                handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( *ppStk[ off ] )
        {
        for( countT off = 0 ; off < sizeof ppStk / sizeof ppStk[ 0 ] ; off ++ )
        stackC* ppStk[] = { &st_psttSent , &st_psttRejected } ;
    {
    while( !ether && !etThread )
    strokeS sSlash( '/' , sc_cFROMaSCII ) ;
    TN( tStar , "*" ) ;
    etThread.osThreadAdamF( tin0P , ifcIDaDAM_ROOTfORMdATAeATER   ) ;
    //etThread.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_ROOTfORMdATAeATER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

    stackC st_psttRejected( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC st_psttSent(     tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

    etThread.diskMakeDirIfNeededF( tin0P , tOutboxNotSent ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tOutboxSent ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tOutbox ) ;

    TN( tOutboxNotSent , "" ) ; tOutboxNotSent = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF2(etherC::ifc_idAdamRootI_IF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("/notsent/") ;
    TN( tOutboxSent    , "" ) ; tOutboxSent    = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF2(etherC::ifc_idAdamRootI_IF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("/sent/") ;
    TN( tOutbox        , "" ) ; tOutbox        = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/")+TF2(etherC::ifc_idAdamRootI_IF(tin0P),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("/in/") ;

    //TN( tOutboxNotSent , "" ) ; tOutboxNotSent = T("///desk/" POSTfOLDERsMTPoUTBOXnOTsENT)+(idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/") ;
    //TN( tOutboxSent    , "" ) ; tOutboxSent    = T("///desk/" POSTfOLDERsMTPoUTBOXsENT   )+(idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/") ;
    //TN( tOutbox        , "" ) ; tOutbox        = T("///desk/" POSTfOLDERsMTPoUTBOX       )+(idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/") ;

    const countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;

    SCOOPS
{
IFsCRATCH

CONoUTrAW( "MAILOUT\r\n" ) ; //U::
 
TODO

/*1*/WAKEhIDE( "server.mailout" )/*1*/

/**/
*/
  terminated by eof (not by a lone period)
  must contain at least one recipient
 specs of input file
 | 
 |  line 4
 |  line 3
 |  line 2
 |  line 1
 |  
 |  Subject: looey
 |  Bcc : <hooey@hooey.com>
 |  Cc : <gooey@gooey.com>
 |  Cc : <gooey@gooey.com>
 |  Cc : <gooey@gooey.com>
 |  Cc : <gooey@gooey.com>
 |  To: <fooey@gooey.com>
 |  To: <fooey@gooey.com>
 |  To: <fooey@gooey.com>
 |  To: <fooey@gooey.com>
 | 
example format of email file
 Bcc semantics must be done by whoever writes the file into my directory
 if there are multiple Bcc : lines, each recipient can see them all
 in particular, i do not process Bcc : lines in any special way
the file is the exact image that is sent to all recipients
watches a directory containing email to send
/*

//OBSOLETED BY 3a50104

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

