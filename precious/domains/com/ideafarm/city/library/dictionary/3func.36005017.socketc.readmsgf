
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cbMsgInLast ;
    dec02AM( cFunctionsPending ) ;
    }
    
        if( idleTimeAllowedRead ) FRESHtIMEaTOMIC( *pEther , timeLathRead.time1 , timeLathRead.time2 )
    
        ((tinFullS&)tinBaseP).pag3->_socketC_.grab.ungrabF( tinBaseP ) ;
        pOdometer->cbWrite += ((tinFullS&)tinBaseP).odoSockCbWrite - _odoSockCbWriteOpen ;
        pOdometer->cbRead  += ((tinFullS&)tinBaseP).odoSockCbRead  - _odoSockCbReadOpen  ;
        pOdometer = (sockOdometerS*)&(countT&)*((tinFullS&)tinBaseP).pag3->_socketC_.pSwOdometer ;
        ((tinFullS&)tinBaseP).pag3->_socketC_.nnLever = nnPeer ;
        ((tinFullS&)tinBaseP).pag3->_socketC_.grab.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
    
        }
            THREADmODE2rESTORE

            }
                pEther->sockReadF( tinBaseP , handle , pbP , cbMsgInLast ) ;
                //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("flSOCKETc_CRYPTfOREIGNsSL is not set") ) ;
            {
            else
            }
                pEther->openSslTls_readF( tinBaseP , pbP , cbMsgInLast , handle ) ;
                armSslC armMe( tinBaseP , flagsOpenSslFails ) ;
                //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("flSOCKETc_CRYPTfOREIGNsSL is     set") ) ;
            {
            if( F(flags) & flSOCKETc_CRYPTfOREIGNsSL ) 

            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
            if( pbP ) pbP[ cbMsgInLast ] = 0 ;
            pEther->newF( tinBaseP , LF , pbP , cbMsgInLast + 1 ) ; ___( pbP ) ;
        {
        if( cbMsgInLast )
        __Z( cbMsgInLast ) ;
        THREADmODE2rESTORE

        }
            pEther->sockReadF( tinBaseP , handle , (byteT*)&cbMsgInLast , sizeof cbMsgInLast ) ;
            //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("flSOCKETc_CRYPTfOREIGNsSL is not set") ) ;
        {
        else
        }
            pEther->openSslTls_readF( tinBaseP , (byteT*)&cbMsgInLast , sizeof cbMsgInLast , handle ) ;
            armSslC armMe( tinBaseP , flagsOpenSslFails ) ;
            //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("flSOCKETc_CRYPTfOREIGNsSL is     set") ) ;
        {
        if( F(flags) & flSOCKETc_CRYPTfOREIGNsSL ) 

        }
            idMsgInLast = idMsgIn ;
            __( idMsgIn - idMsgInLast - 1 ) ;
            }
                pEther->sockReadF( tinBaseP , handle , (byteT*)&idMsgIn , sizeof idMsgIn ) ;
                //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("flSOCKETc_CRYPTfOREIGNsSL is not set") ) ;
            {
            else
            }
                pEther->openSslTls_readF( tinBaseP , (byteT*)&idMsgIn , sizeof idMsgIn , handle ) ;
                armSslC armMe( tinBaseP , flagsOpenSslFails ) ;
                //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("flSOCKETc_CRYPTfOREIGNsSL is     set") ) ;
            {
            if( F(flags) & flSOCKETc_CRYPTfOREIGNsSL ) 
            ZE( countT , idMsgIn ) ;
        {
    
        }
             __( idType - 1 ) ;
            }
                pEther->sockReadF( tinBaseP , handle , (byteT*)&idType  , sizeof idType ) ;
                //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("flSOCKETc_CRYPTfOREIGNsSL is not set") ) ;
            {
            else
            }
                pEther->openSslTls_readF( tinBaseP , (byteT*)&idType  , sizeof idType , handle ) ;
                armSslC armMe( tinBaseP , flagsOpenSslFails ) ;
                //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("flSOCKETc_CRYPTfOREIGNsSL is     set") ) ;
            {
            if( F(flags) & flSOCKETc_CRYPTfOREIGNsSL ) 
            ZE( countT , idType ) ;
        {

        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
    
        bRead.grabF( tinBaseP , TAG( TAGiDnULL ) ) ; // THIS IS RELEASED BY readMsgOkF OR readMsgNokF
    
        const countT _odoSockCbWriteOpen = ((tinFullS&)tinBaseP).odoSockCbWrite ;
        const countT _odoSockCbReadOpen  = ((tinFullS&)tinBaseP).odoSockCbRead  ;
    
        _IO_
    
        }

            }
                return 0 ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )

            __NZ( pbP ) ;

            }
                return 0 ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL    
        SCOOPP
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/countT socketC::readMsgF( tinBaseS& tinBaseP , byteT*& pbP )/*1*/

/**/
*/
  must be 0
 pbP
arguments
this function appends a null byte to the data, which is not included in the length value that is returned
this function evaluates to the number of bytes of data received (and placed into pbP)
 call readMsgNokF if the data cannot be processed
 call readMsgOkF after the data received has been processed
 readMsgOkF will release it without grabbing it
 this function grabs the socketC object but does not release it
the caller -must- follow this call with a call to readMsgOkF (or readMsgNokF)
  both ends of a connection should use writeMsgF, readMsgF, and readMsgOkF (or readMsgNack)
 this protocol is subject to change
   cbr must equal the cbP just sent
   idMsgr must equal the idMsg just sent
   2 indicates that this is an ack
  then reads 2, idMsgr, cbr
   idMsg is consecutive from 1 and is unique for each message going out from a socket
   1 indicates that this is a message (rather than an ack)
  writes 1, idMsg, cbP, pbP
 the remote peer is assumed to have written a message using the following protocol
reads specified bytes to the peer using the IFC message protocol
  \<A HREF=\"5.3930104.1.1.0.html\"\>3930104:  WAKEsHOW( "example.simplest.func.107001a.socketC.readMsgF" )\</A\>
 simplest
examples
\<A HREF=\"5.107001a.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$readMsgF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

