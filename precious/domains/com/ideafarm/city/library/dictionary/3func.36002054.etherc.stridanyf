
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idHit ;
    }
        }
            }
                }
                    if( !idHit || idFirstP > ccBig ) idFirstP  = 0 ;_WQ

                    }
                        while( idFirstP <= ccBig &&  strIdF( tin0P , countTC( 1 ) , psttBigP[ CSpREFIX - 1 + idFirstP ] , psttSmall ) ) idFirstP ++ ;_WQ
                        idFirstP = idHit + 1 ;_WQ
                    {
                    else
                    }
                        while( idFirstP <= ccBig && !strIdF( tin0P , countTC( 1 ) , psttBigP[ CSpREFIX - 1 + idFirstP ] , psttSmall ) ) idFirstP ++ ;_WQ
                        idFirstP = idHit + 1 ;_WQ
                    {
                    else if( bNot )
                    if( idHit > ccBig ) idHit = 0 ;
    
                    }
                        if( ( !bUseQuotes || !bInQuote ) && bHit && !bEscaped ) break ;

                        boolT bEscaped = idHit > 1 && psttBigP[ CSpREFIX - 2 + idHit ].idAdam == '\\' ;
                        //U:: 20230615@2227: MAKE THIS USE OF bEscaped OPTIONAL TO AVOID BREAKING EXISTING CALLING CODE; THIS WAS ADDED W/O ANALYSIS AND W/O REGRESSION TESTING TO GET strIdMatchingF TO WORK WITH SOIL KT BODY INPUT THAT CONTAINS E.G. "\{"

                        ;_WQ
                            :  strIdF( tin0P , countTC( 1 ) , psttBigP[ CSpREFIX - 1 + idHit ] , psttSmall )
                            ? !strIdF( tin0P , countTC( 1 ) , psttBigP[ CSpREFIX - 1 + idHit ] , psttSmall )
                        boolT bHit = bNot

                        if( bUseQuotes ) bInQuote = strIsInQuoteF( tin0P , sttQuoteP , idHit , psttBigP ) ;_WQ
                        ZE( boolT , bInQuote ) ;_WQ
                    {
                    for( idHit = idFirstP ; idHit <= ccBig ; idHit ++ )
                {
                if( !POOP )
            {
            else
            if( idFirstP > ccBig ) idFirstP = 0 ;
    
            countT ccBig   = idLastP && idLastP < psttBigP->idAdam ? idLastP : psttBigP->idAdam ;_WQ
        {
        if( !POOP )
    
        const strokeS* const psttSmall = ( psttSmallP && psttSmallP->idAdam ) ? psttSmallP : psttOneNull ;_WQ
        SETpREFIX( (strokeS*)psttOneNull , 1 , 0 ) ;_WQ
        const strokeS psttOneNull[] = { strokeS() , strokeS() , strokeS() , strokeS() } ;_WQ
    {
    STRiDrECURSE( strIdAnyF( tin0P , pstMatchP , flagsMatchP , idf , sttQuoteP , psttSmallP , psttBigP , idLastP , 1 , flagsP ) )

    const boolT bNot = F(flagsP) & flSTRiDaNY_NOT ;_WQ

    _IO_

    }
        if( POOP ) return 0 ;
        }
            __( F( pstMatchP->flagsF( tin0P ) ) & flSTACKc_FIFO ) ; // IF FIFO THEN WILL CONTAIN INCORRECT CONTENTS
        {
        if( pstMatchP )
        __( psttSmallP && psttSmallP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        __( psttBigP->idCaste != sc_PREFIXlENGTH ) ;_WQ
        if( POOP ) return 0 ;
        FV( flSTRiDaNY , flagsP ) ;_WQ
        __Z( idP ) ;_WQ
        __( idFirstP == 1 && (countT)sttQuoteP && bUseQuotes ) ;_WQ
        __Z( idFirstP ) ;_WQ
        __Z( psttBigP ) ;_WQ
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL

    const boolT bUseQuotes = sttQuoteP.idCaste != sc_IGNOREqUOTES ;_WQ
    SCOOP
{
/*1*/countT etherC::strIdAnyF( tin0S& tin0P , stackC* const pstMatchP , const flagsT flagsMatchP , countT& idFirstP , strokeS& sttQuoteP , const strokeS* psttSmallP , const strokeS* psttBigP , const countT idLastP , sCountT idP , const flagsT flagsP )/*1*/

/**/
*/
  if not 0 then only the strokes between idFirstP and idLastP inclusive are inspected
  if 0 then the search is over the entire psttBigP string
  can be 0
 idLastP
 psttBigP
   behavior is identical to that of a unit length string containing a null stroke
  this can also be null, or a null length string
  this string can include a null stroke
 psttSmallP
 sttQuoteP
 idFirstP
arguments
 see doc for strIsInQuoteF for notes on how sttQuoteP is set at the beginning and at the end of a quote
 see doc for strIsInQuoteF for notes on which quote marks are recognized
 sttQuoteP is either 0 or contains the last quote mark encountered
initialize sttQuoteP to the quote state at idFirstP
skips over quoted strokes when searching for the first match
idFirstP will point to the stroke after the ones found
evaluates to the id in psttBigP of the first occurance of a stroke that is in psttSmallP
  \<A HREF=\"5.b910104.1.1.0.html\"\>b910104:  WAKEsHOW( "example.simplest.func.103005e.etherC.strIdAnyF" )\</A\>
 simplest
examples
\<A HREF=\"5.103005e.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strIdAnyF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

