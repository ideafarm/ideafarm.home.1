
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //SAYnAME( "~tinS/-\r\n" )
    TELL( "~tinS: final tell tag in ~tinS" )
    TINSL

    }
        }
            LOGrAW( "-\r\n" ) ;
            LOGrAW( postThreadName ) ;
        {
        if( F(thirdC::third_flagsModeAdam2I_IF(*this)) & flADAMmODE2_THREADcHATTER )

        }
            if( F(flags) & flTINs_DELETEtLS ) { PUSE( tinP , *(byteT**)&pbTls           ) ; }
                                                PUSE( tinP , pbPendingInOutFramePackets ) ;
        {
        else          
        if( !pPoolUse ) processGlobal4I.heap.delF( tinP , pbPendingInOutFramePackets ) ;

        }
            }
                etherC::etRockIF( tinP ).traceF( tinP , (const strokeS* const)(const osTextT* const)ostoSay , /*flTRACE_LOOP |*/ flTRACE_PARAMETERiSoStEXT ) ;  //USES pbTls SO CANNOT BE LATER

                OStEXTAK( ostoSay , " ----" ) ;
                OStEXTA(  ostoSay , postThreadName ) ;
                OStEXTAK( ostoSay , "_9    " ) ;
                OStEXTC9( ostoSay , osTid ) ;
                OStEXTAK( ostoSay , "_9    " ) ;
                OStEXTC9( ostoSay , osPid ) ;
                OStEXTAK( ostoSay , "tinS [osPid,osTid]:    " ) ;
                OStEXT(   ostoSay , TUCK << 0 ) ;

                tinS& tinP = *this ;

                if( pTinF() != this && idTinNamed != ifcIDtINnAMED_tinHeartI && idTinNamed != ifcIDtINnAMED_tinBreakI ) { BLAMMOiD( 0x22222222 ) } ;

                tell_tmWatchF_toIgnoreMeF() ;
            {
            if( idTinNamed != ifcIDtINnAMED_tinHeartI && idTinNamed != ifcIDtINnAMED_tinBreakI && idTinNamed != ifcIDtINnAMED_tinVeryVeryEarlyLateMainI )
        {
        if( F(processGlobal2I.flCt) & flCTdTg_exceptionHandlerRegistered && !( F(processGlobal2I.flDt) & flCTdTg_exceptionHandlerRegistered ) )             //THIS IS TO AVOID CLUTTERING THE LOG FILE

        POOPIES
        dtTellCopyDoneF( (countT)this ) ;

        }
            TELLaPPc3LIFI( ifcIDtYPEtELLaPP_INoUTtINdT , (byteT*)&info , sizeof info , ifcLINE , DDNUMB ) ;
            THREADmODE5oN0( flTHREADmODE5_INoUTfRAMEdEFERwRITINGaPPtELEMETRY ) ;

                                                 cCpuCyclesWriteInOutTelemetry = 0 ;
            info.cCpuCyclesWriteInOutTelemetry = cCpuCyclesWriteInOutTelemetry ;
                          cTellsWriteInOutTelemetry = 0 ;
            info.cTells = cTellsWriteInOutTelemetry ;
            info.idThreadReporting = monitor.idThread ;
            tellInfoAppInOutFrameTinDtS info ;
            //PS:PSEUDOdUPLICATE CODE: 36024002 360fc002

            }
                }
                    cPending = 0 ;

                    }
                        thirdC::dosTellMonitorIF( tinP , tell , ifcIDbOOKStELL_APP ) ;
                        tellC tell( tinP , LF , 0 , ifcIDtYPEtELLaPP_INoUTaRRAY , tinP.pbPendingInOutFramePackets , sizeof( countT ) + cPending * sizeof( tellInfoAppInOutFrameS ) ) ;
                    {

                    }
                        BLAMMOiD( 0x11111111 ) ;
                        LOGrAW5(    "~tinS error: [cPending,cMax]: " , cPending , " " , CmAXpENDINGiNoUTfRAMEpACKETS , "\r\n" ) ;
                        CONoUTrAW5( "~tinS error: [cPending,cMax]: " , cPending , " " , CmAXpENDINGiNoUTfRAMEpACKETS , "\r\n" ) ;
                    {
                    if( cPending > CmAXpENDINGiNoUTfRAMEpACKETS )

                    tellInfoAppInOutFrameS* pPending = (tellInfoAppInOutFrameS*)( tinP.pbPendingInOutFramePackets + sizeof( countT ) ) ;
                {
                if( cPending )

                countT& cPending = *(countT*)tinP.pbPendingInOutFramePackets ;
            {
            if( tinP.pbPendingInOutFramePackets )
            //PSEUDOdUPLICATEcODE 360fc002 33000065

            THREADmODE5oN0( flTHREADmODE5_INoUTfRAMEdOnOTcOLLECTaPPtELEMETRY | flTHREADmODE5_DOnOTfLUSHpENDINGaPPtELEMETRY ) ;
        {
        if( monitor.idThread > 3 ) // FOR THREAD 1, SEE doC::~doC; THREAD 2 AND 3 ARE tinHeart AND tinBreak, WHICH NORMALLY ACCUMULATE NO TELEMETRY

        TINSL       // I CANNOT USE MYSELF BECAUSE I MIGHT BE tinHeart OR tinBreak
    {
    else
    }
        }
            thirdC::dosExitProcessIF( ifcEXITcODE_EXITpROCESSdTtINSnOTpOINTINGtOeLDER ) ;
        {
        if( pTinF() != pTinOld )

        }
            thirdC::dosExitProcessIF( ifcEXITcODE_EXITpROCESSdTtINSpOURfAILED ) ;
            CONoUTrAW( "\r\n" ) ; //CODE SYNC: 003002a 12f0002 12f0003
        {
        if( thirdC::c_memcpyWithCallBackIF( (byteT*)pTinOld + CBtINpREFIX , (byteT*)this + CBtINpREFIX , sizeof( tinS ) - CBtINpREFIX - CBtINsUFFIX , dtTellCopyDoneF , (countT)this ) )

        }
            //SAYnAME( "~tinS/ " ) CONoUTrAW( "copying to " ) ; CONoUTrAW( NAME( pTinOld->idTinNamed ) ) ; ; CONoUTrAW( "\r\n" ) ;
            TINSL
        {
    {
    if( pTinOld )

    }
        DEL( pSwsRecycle ) ; //TO MAKE SURE THAT etRock EXISTS WHEN THESE ARE DELETED
        }
            THREADmODE2rESTORE
            }
                }
                    }
                        }
                            }
                                break ;
                                thirdC::dosExitProcessIF( ifcEXITcODE_EXITpROCESSdTtINSuNEXPECTEDrECYCLEtYPE ) ;
                            {
                            default                            :
                            case ifcIDtYPErECYCLE_switchStackC : { DEL( *(switchStackC**)&pObject ) ; break ; }
                            case ifcIDtYPErECYCLE_switchC      : { DEL(      *(switchC**)&pObject ) ; break ; }
                            case ifcIDtYPErECYCLE_stackC       : { DEL(       *(stackC**)&pObject ) ; break ; }
                            case ifcIDtYPErECYCLE_soulC        : { DEL(        *(soulC**)&pObject ) ; break ; }
                        {
                        switch( *pczl_pSwsRecycle )
                    {
                    if( pczl_pSwsRecycle && pObject )

                    *pSwsRecycle >> *(countT*)&pObject ;
                    ZE( voidT* , pObject ) ;
                {
                while( *pSwsRecycle )
        
                pczl_pSwsRecycle = (countT*)pSwsRecycle->leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = pSwsRecycle->cFlavorsF( tinP ) ;
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        {
        if( pSwsRecycle )
        //PSEUDODUPLICATE CODE: 1450002 12f0002 1030003 1020171

        deregisterIfF( tinP ) ;
        TELL( "~tinS: deregistering" )

        }
            thirdC::dosExitProcessIF( ifcEXITcODE_EXITpROCESSdTtINSsOMETHINGgRABBED ) ;
            }
                }
                    LOGrAW5( "~tinS dying while this is grabbed [idLineCt,idiFileCt]: " , tinP.pPanLifiRecurseGrabbedLevel[ off + 1 ] , " " , tinP.pPanLifiRecurseGrabbedLevel[ off + 2 ] , "\r\n" ) ;
                {
                if( tinP.pPanLifiRecurseGrabbedLevel[ off ] )
            {
            for( countT off = 0 ; off < offEnd ; off += 5 )
            const countT offEnd = OFFgRABBEDmAX * 5 ;
        {
        if( tinP.monitor.cGrabbed )
        TELL( "verifying that nothing is now grabbed by this thread" )

        TELL( "~tinS: after setting processGlobal2I.flDt flag" )
        }
            }
                case ifcIDtINnAMED_tinInPoolMain             : { processGlobal2I.flDt |= flCTdTg_tinMainInPool             ; break ; }
                case ifcIDtINnAMED_tinVeryEarlyLateMainI     : { processGlobal2I.flDt |= flCTdTg_tinVeryEarlyLateMainI     ; break ; }
                case ifcIDtINnAMED_tinVeryVeryEarlyLateMainI : { processGlobal2I.flDt |= flCTdTg_tinVeryVeryEarlyLateMainI ; break ; }
            {
            switch( idTinNamed )

            }
                thirdC::dosExitProcessIF( ifcEXITcODE_EXITpROCESSdTtINSnOTpOINTINGtOmE ) ;
            {
            if( pTinF() != this )
        {
        if( idTinNamed != ifcIDtINnAMED_tinHeartI && idTinNamed != ifcIDtINnAMED_tinBreakI )
        TELL( "~tinS: setting processGlobal2I.flDt flag and testing pTinF()" )

        }
            }
                { ++ s ; thirdC::dosSleepWinkIF( tinP ) ; }
                //if( !cQuiet || !( -- cQuiet ) ) { LOGrAW5( postThreadName , cKidThreads , " ( pTinKid : " , (countT)pTinKid , " )\r\n" ) ; }

                }
                    thirdC::dosExitProcessIF( ifcEXITcODE_EXITpROCESSdTtINSkIDSeXISTdURINGclEANUP ) ;
                    CONoUTrAW( "~tinS: calling ExitProcess because i am being cleaned up and i have kid threads.\r\n" ) ;
                {
                if( F(flagsThreadMode4) & flTHREADmODE4_EXCEPTIONcLEANUPdELETIONiNpROGRESS || F(processGlobal2I._thirdC_flagsProcessState) & flPROCESSsTATE_EXCEPTIONnOThANDLED )
            {
            while( cKidThreads ) //tmWindowsF must not put itself into this list because main CANNOT BLOCK HERE FOR tmWindowsF TO END BECAUSE tmWindowsF ENDS LATER
            countT cQuiet = 0x40 ; //INCR FROM 01 TO 04 TO AVOID LOGrAW
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        {
    
        POOPIES

        // ExitProcess RATHER THAN BLAMMO IS USED HERE BECAUSE I CAN BE CALLED BY EXCEPTION HANDLER CLEANUP LOOP

        }
            //}
            //    etherC::etRockIF( tinP ).traceF( tinP , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
            //
            //    OStEXTC(  ostoSay , usedPerTuck , 0 ) ;
            //    OStEXTAK( ostoSay , "    " ) ;
            //    OStEXTC(  ostoSay , monitor.idThread , 0 ) ;
            //    OStEXTAK( ostoSay , "~tinS thread stack max usage [idThread,usedPerTuck]:    " ) ;
            //    OStEXT(   ostoSay , TUCK << 0 ) ;
            //{
            //countT usedPerTuck = !cbStackAll ? 0 : cbStackUsed * 0x100 / cbStackAll ;
            //countT cbStackUsed = pbThreadStackEnd - pbThreadStackLowest ;
            //countT cbStackAll  = pbThreadStackEnd - pbThreadStackStart ;
        {
        if( idTinNamed != ifcIDtINnAMED_tinVeryVeryEarlyLateMainI )  //20221029@1850: IF DO THIS FOR VERYVERY, traceF CALL WILL CAUSE scoopC CT'OR TO FAIL DUE TO ZOMBIE FINGERPRINT IN my poop MEMBER (NOT ANALYZED)

        //SAYnAME( "~tinS/+\r\n" )
        TINSL
    {
{
/*1*/tinS::~tinS( voidT )/*1*/

//#define SAYnAME(postP) { CONoUTrAW7( "[idTin,idThread,idSerial,name]: " , idTin , " " , monitor.idThread , " " , idSerial , " " ) ; CONoUTrAW( NAME( idTinNamed ) ) ; CONoUTrAW( " " postP ) ; }

//#define NAME(idP) processGlobal4I.mapTinName( idP )

/**/
*/
i work unconditionally so that the monitor receives notice of me and so that processGlobal5I.tinVeryEarlyLateMain is maintained even if impotence occurs
\<A HREF=\"5.12f0002.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

