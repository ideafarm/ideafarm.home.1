
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmStripeWebHookIpListF )
}
    grab_pnnAllowP.ungrabF( tin0P ) ;                
    etThread.delF( tin0P , pnnAllowP ) ;                     //OTHER THREADS THAT REFERENCE pnnAllowP MUST GRAB AND THEN VERIFY THAT pnnAllowP IS NOT 0 BEFORE ACCESSING IT
    grab_pnnAllowP.grabF( tin0P , TAG( TAGiDnULL ) ) ;                

    }
        }
            ++ s ; ether.osSleepF( tin0P , time1NapP ) ;

            etThread.delF( tin0P , postIn ) ;

            DEL( pSwPathValue ) ;

            }
                grab_pnnAllowP.ungrabF( tin0P ) ;                
                etThread.traceF( tin0P , T("updated  whitelist") ) ;
                }
                    etThread.delF( tin0P , psttValue ) ;

                    }
                        }
                            pnnAllowP[ cnnAllowP ++ ] = nn ;
                            etThread.traceF( tin0P , T("[off,nn,isIPv4F()]:    ")+TF2(cnnAllowP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nn)+tb4+TF2(nn.isIPv4F(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        if( ~nn )
                        nicNameC nn = socketC::nicNameIF( tin0P , etThread , psttValue ) ;

                        //etThread.traceF( tin0P , T("[ip]:    ")+T(psttValue) ) ;
                    {
                    if( psttValue && psttPath->idAdam == 0x19 && 1 == idHit )

                    //etThread.traceF( tin0P , T("[idAdam,idHit]:    ")+TF2(psttPath->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT idHit = etThread.strIdF( tin0P , countTC( 1 ) , T("\"WEBHOOKS\"/item.") , psttPath , 1 ) ;

                    //etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

                    // "WEBHOOKS"/item.0000000c/
                    // 123456789abcdef0123456789abcdef0

                    strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                    psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                    _IO_
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )

                etThread.newF( tin0P , LF , pnnAllowP , cFlavors ) ; ___( pnnAllowP ) ;      //LARGER THAN NECESSARY BECAUSE SOME FLAVORS ARE NOT IP ADDRESSES
                etThread.delF( tin0P , pnnAllowP ) ;
                cnnAllowP = 0 ;
                etThread.traceF( tin0P , T("updating whitelist") ) ;
                grab_pnnAllowP.grabF( tin0P , TAG( TAGiDnULL ) ) ;                

                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
            {
            if( pSwPathValue && !POOP )

            }
                }
                    DEL( pSwPathValue ) ;
                    etThread.traceF( tin0P , T("!exception / could not parse json reply") ) ;
                    POOPR
                {
                if( POOP )
                ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , postIn , flSTACKc_null ) ; ___( pSwPathValue ) ;
                SCOOPS
            {
            IFsCRATCHoK
            ZE( switchC* , pSwPathValue ) ;
            ZE( strokeS* , psttPath     ) ;

            //etThread.traceF( tin0P , T("---- END ----") ) ;
            //etThread.traceF( tin0P , T(postIn)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            //etThread.traceF( tin0P , T("---- BEGIN ----") ) ;

            }
                }
                    etThread.traceF( tin0P , T("boxGetShadowF failed") ) ;
                    POOPRqUIET
                {
                if( POOP )
                ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , postIn , costIn , tUri , 1 , SOCKETtIMEOUTdEFAULTwAN ) ; ___( postIn ) ;
                SCOOPS
            {
            IFsCRATCHoK
            TN( tUri , "stripe.com//https/files/ips/ips_webhooks.json" ) ;
            ZE( countT , costIn ) ;
            ZE( byteT* , postIn ) ;

            etThread.traceF( tin0P , T("querying Stripe for the current Stripe Webhook client IP list") ) ;
        {
        while( !ether )
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    {
    if( !POOP )

    TN( tb4 , "    " ) ;

    __NZ( pnnAllowP ) ;
    countT       time1NapP      =              pTaskP->c5 ;
    grabC&       grab_pnnAllowP =     *(grabC*)pTaskP->c4 ;
    countT&      cnnAllowP      =    *(countT*)pTaskP->c3 ;
    nicNameC*&   pnnAllowP      = *(nicNameC**)pTaskP->c2 ;
    const boolT& bQuitP         =     *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
/*1*/TASK( tmStripeWebHookIpListF )/*1*/


/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
