
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    __Z( bOk ) ;

    }
        }
            }
                etPrime.osSleepF( tinBaseP , TOCK ) ;
                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

                ether.traceF( tinBaseP , T("will retry after napping for a tock") ) ;

                ether.delF( tinBaseP , pbP ) ;

                POOPRqUIET ;
            {
            else
            }
                break ;
                bOk = 1 ;
            {
            if( !POOP )

            }
                }
                    }
                        }
                            }
                                pbP[ cbP ] = 0 ;
                                }
                                    }
                                        }
                                            pbc += cbGot ;
                                            cDo -= cbGot ;
                                        {
                                        else
                                        if( POOP ) break ;

                                        __Z( cbGot ) ;
                                        countT cbGot = ss.readF( tinBaseP , pbc , cDo ) ;
                                    {
                                    while( cDo )
                                    countT cDo = cbP ;
                                    byteT* pbc = pbP ;
                                {
                                if( !POOP )

                                __Z( pbP ) ;
                                ether.newF( tinBaseP , LF , pbP , cbP + 1 ) ; ___( pbP ) ;
                            {
                            if( cbP )
                        {
                        if( !POOP )

                        }
                            }
                                else if( !POOP ) offb = - 1 ;
                                if( !offb ) break ;

                                }
                                    }
                                        ether.delF( tinBaseP , psttw ) ;
                                        cbP = ether.strDigitsToSCountF( tinBaseP , psttw , 0xa , 1 ) ;
                                        ether.strSubstringF( tinBaseP , psttw , idf , idl , psttLine ) ; ___( psttw ) ;
                                        ZE( strokeS* , psttw ) ;

                                        ZE( countT , idl ) ;
                                        while( psttLine[ CSpREFIX - 1 + idf ] == sttBlank ) idf ++ ;
                                        countT idf = tContentLength.csF( tinBaseP ) + 1 ;
                                        strokeS* psttLine = tLine ;
                                    {
                                    if( 1 == ether.strIdF( tinBaseP , tContentLength , tLine ) )
                                    strokeS sttBlank( ' ' ) ;
                                {
                                if( !POOP )

                                }
                                    __NZ( ostLF != '\n' ) ;
                                    __Z( ss.readF( tinBaseP , &ostLF , 1 ) ) ;
                                    osTextT ostLF ;

                                    }
                                        //ether.traceF( tinBaseP , T("header line: ")+T(postBuffer) ) ;
                                        postBuffer[ offb ] = 0 ;
                                    {
                                    if( offb )
                                {
                                if( !POOP )

                                }
                                    }
                                        }
                                            __1
                                            etRock.traceF( tinBaseP , T("[tSay]: ")+tSay ) ;
                                            etRock.traceF( tinBaseP , T("pullFileF / exception: did not expect [tLine]: ")+tLine ) ;
                                        {
                                        if( !ether.strIdF( tinBaseP , tReplyCode200_OK , tLine ) )

                                        }
                                            break ;
                                            etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("authorization refused") ) ;
                                        {
                                        if( POOP )
                                        __NZ( 1 == ether.strIdF( tinBaseP , tReplyCode401_Unauthorized , tLine ) ) ;
                                    {
                                    if( !POOP )

                                    __Z( offb ) ;
                                    bWoth = 0 ;
                                {
                                if( bWoth )

                                TN( tLine , postBuffer ) ;
                                postBuffer[ offb ] = 0 ;
                            {
                            if( postBuffer[ offb ] == '\r' )         // IF I HAVE A LINE OF HEADER

                            if( POOP ) break ;
                            __Z( ss.readF( tinBaseP , postBuffer + offb , 1 ) ) ;
                        {
                        for( offb = 0 ; !POOP && offb < sizeof postBuffer ; offb ++ )
                        TN( tContentLength , "Content-Length:" ) ;
                        boolT bWoth = 1 ;
                        ZE( countT , offb ) ;
                        osTextT postBuffer[ TOCK ] ;

                        // 
                        // my.iddisk
                        // administrator.email@foo.com
                        // 
                        // Date: Mon, 08 Dec 2014 04:14:34 GMT
                        // X-Trans-Id: tx567c206bc36246dab9325-00548525aaiad3
                        // Content-Type: application/octet-stream
                        // X-Timestamp: 1418012073.44724
                        // Etag: f1290729de5a5ba08b49016a88a0f740
                        // Last-Modified: Mon, 08 Dec 2014 04:14:34 GMT
                        // Accept-Ranges: bytes
                        // Content-Length: 39
                        // HTTP/1.1 200 OK
                        // 
                        // SAMPLE REPLY
                    {
                    else
                    if( POOP ) ether.traceF( tinBaseP , T("pullFileF / could not write") ) ;
                    ss.writeF( tinBaseP , (osTextT*)tSay , (countT)tSay.csF( tinBaseP ) ) ;
                {
                else
                if( POOP ) ether.traceF( tinBaseP , T("pullFileF / could not connect") ) ;
                ss.connectF( tinBaseP , 443 , socketC::nicNameIF( tinBaseP , ether , tHost ) ) ;
            {
            else
            if( POOP ) ether.traceF( tinBaseP , T("pullFileF / could not ct socket") ) ;
            socketC ss( tinBaseP , *((tinNormalS&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL ) ;

            SCOOPS
        {
        IFsCRATCH

        }
            ether.delF( tinBaseP , psttShortUrlEncoded ) ;
            }
                bHandle.ungrabF( tinBaseP ) ;
                tSay = T("GET ")+tUrlCloudAgent+T("/")+T(psttCloudContainerP)+T("/")+T(psttShortUrlEncoded)+T(" HTTP/1.1\r\nHost: ")+tHost+T("\r\nX-Auth-Token: ")+cloudInfo.tRackspaceAccessToken+T("\r\n\r\n") ;
                cloudInfoS& cloudInfo = *(cloudInfoS*)hCloud.osF( ifcIDtYPEhANDLE_CLOUD ) ;
                bHandle.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
            {

            //  
            // X-Auth-Token: f064c46a782c444cb4ba4b6434288f7c
            // Host: storage.clouddrive.com
            // GET /v1/MossoCloudFS_0672d7fa-9f85-4a81-a3ab-adb66a880123/archive/shortEncodedName HTTP/1.1
            // 
            // EXAMPLE

            ether.strToUrlF( tinBaseP , psttShortUrlEncoded , psttShortP ) ; ___( psttShortUrlEncoded ) ;
            ZE( strokeS* , psttShortUrlEncoded ) ;
        {
        if( !tSay.csF( tinBaseP ) )

        //}
        //    __1 ;
        //    bWoth = 0 ;
        //{
        //if( bWoth ) //U:: TO FIND A BUG
    {
    )
        )
            )
                ( bNoQuitEarly || cTriesRemaining -- )
                &&
                !etPrime
            (
            ||
            bNoQuit
        (
        &&
        !POOP
    (
    while
    TN( tSay , "" ) ;

    countT cTriesRemaining = cTriesP ;
    boolT bNoQuitEarly     = !cTriesP ;
    boolT bNoQuit          = cTriesP == - 1 ;

    //boolT bWoth = 1 ; //U::TO FIND A BUG
    etherC& etPrime   = etherC::etPrimeIF( tinBaseP ) ;
    ZE( boolT , bOk ) ;

    //etRock.traceF( tinBaseP , T("the GET utterance has been appended to the log") ) ;
    //LOGrAW( tSay ) ;

    _IO_

    }
        if( POOP ) return ;
        __Z( psttShortP ) ;
        __Z( psttCloudContainerP ) ;
        __NZ( cbP ) ;
        __NZ( pbP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    etherC& etRock = etherC::etRockIF( tinBaseP ) ;

    SCOOP
{
/*1*/voidT cloudC::pullFileF( tinBaseS& tinBaseP , byteT*& pbP , countT& cbP , const strokeS* const psttCloudContainerP , const strokeS* const psttShortP , const countT cTriesP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

