
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.strokeF( tinBaseP , T("ok\r\n") ) ;
WRITEwOfILE( Menus )
idFileNext = 1 ;
WRITEwOfILE( Helps )
idFileNext = 1 ;
WRITEwOfILE( Loads )
idFileNext = 1 ;
WRITEwOfILE( Protos )
idFileNext = 1 ;
WRITEwOfILE( Defs )
etThread.delF( tinBaseP , pstt1l ) ;
}
    }
        }
            }
                WRITEwOfILE( Defs )
                cApiNew = 0 ;
            {
            if( ++ cApiNew > cDefLimit )

            }
                case 4 : { cDefLimit -= 0x20 ; break ; }
                case 3 : { cDefLimit -= 0x10 ; break ; }
                case 1 : { cDefLimit -= 0x18 ; break ; }
            {
            switch( idFileNext )
            countT cDefLimit = 0x40 ;

            parsePrototypeF( tinBaseP , etThread , stAllDefs , stAllProtos , stAllLoads , stAllHelps , stAllMenus , psttc1 ) ;
        {
        )
            ( idf = 1 , !etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , tWake     , psttc1 ) )

            SUPPRESS( "etherDoHttpJobF" )
            SUPPRESS( "count04T" )
            SUPPRESS( "patternC&" )
            SUPPRESS( "patternC*" )
            SUPPRESS( "osThreadSwitchingDesireF" )
            SUPPRESS( "strClockOldF" )
            SUPPRESS( "strFromF" )
            SUPPRESS( "countT*" )
            SUPPRESS( "poolC&" )
            SUPPRESS( "napkinC" )
            SUPPRESS( "count01T" )
            SUPPRESS( "measureT*" )
            SUPPRESS( "count2S*" )
            SUPPRESS( "count3S*" )
            SUPPRESS( "count4S*" )
            SUPPRESS( "count5S*" )
            SUPPRESS( "count6S*" )
            SUPPRESS( "count7S*" )
            SUPPRESS( "count8S*" )
            SUPPRESS( "count9S*" )
            //SUPPRESS( "const byteT*&" )
            //SUPPRESS( "byteT " )
            SUPPRESS( "(tm)" )
            SUPPRESS( "infoFile" )
            SUPPRESS( "infoDisk" )
            SUPPRESS( "dnsMsgHeaderS" )
            SUPPRESS( "FT" )
            SUPPRESS( "jobFillCourseFT" )
            SUPPRESS( "serverInfo1S" )
            SUPPRESS( "ifcRenderingHandlerFT" )
            SUPPRESS( "ifcFT" )
            SUPPRESS( "osIdF" )
            SUPPRESS( "signC*" )
            SUPPRESS( "voidT*" )
            SUPPRESS( "soulC&" )
            SUPPRESS( "soulC " )
            SUPPRESS( "nicNameC*" )
            SUPPRESS( "strDigitsToSCountF" )
            SUPPRESS( "sCountT" )
            SUPPRESS( "stackC" )
            SUPPRESS( "sCountC" )
            SUPPRESS( "switchC" )
            SUPPRESS( "switchStackC" )
            SUPPRESS( "batonC" )
            SUPPRESS( "unTextT" )
            SUPPRESS( "strokeS " )
            SUPPRESS( "strokeS&" )
            SUPPRESS( "lakeC" )
            SUPPRESS( "windowOldC" )

            //( idf = 1 , etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , T("ifcCellHostsF")  , psttc1 ) ) &&
            //( idf = 1 , !etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , T("fLeading")  , psttc1 ) ) &&
            //( idf = 1 , etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , T("strFuseF") , psttc1 ) ) &&
            //( idf = 1 , etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , T("strFuseSeparateF") , psttc1 ) ) &&

            ( idf = 1 , !etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , T("dnsSkipLabelsF") , psttc1 ) ) &&
            ( idf = 1 , !etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , tOperator , psttc1 ) ) &&
            ( idf = 1 , !etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , tFriend   , psttc1 ) ) &&
            ( idf = 1 , !etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , tEtherC   , psttc1 ) ) &&
            ( idf = 1 , !etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , tStatic   , psttc1 ) ) &&
            ( idf = 1 , !etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , tND       , psttc1 ) ) &&
            ( idf = 1 , !etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , tSpacer   , psttc1 ) ) &&
            ( idpa && ( !idss || idss > idpa ) ) &&
        (
        if
        countT idpa = ( idf = 1 , etThread.strIdF( tinBaseP , idf , sttq , sttOpen , psttc1 ) ) ;
        countT idss = ( idf = 1 , etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , tss  , psttc1 ) ) ;
    {
    if( bPublic )

    }
        }
            continue ;
            bPublic = 0 ;
        {
        )
            ( idf = 1 , etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , tPrivate   , psttc1 ) )
            ( idf = 1 , etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , tProtected , psttc1 ) ) ||
        (
        if
    {
    else
    }
        }
            continue ;
            bPublic = 1 ;
        {
        if( idf = 1 , etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , tPublic , psttc1 ) )
    {
    if( !bPublic )
    ZE( countT , idf ) ;

    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    //etThread.strokeF( tinBaseP , T(psttc1)+tcr ) ;
{
FORsTRINGSiN1( pstt1l )
ZE( countT , cApiNew ) ;
countT idFileNext = 1 ;
ZE( boolT , bPublic ) ;
stackC stAllMenus( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
stackC stAllHelps( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
stackC stAllLoads( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
stackC stAllProtos( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
stackC stAllDefs( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
strokeS sttOpen( '(' ) ;
etThread.delF( tinBaseP , psttIn ) ;
etThread.strWordsOldF( tinBaseP , pstt1l , psttIn , sttq , tcr ) ; ___( pstt1l ) ;
strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
ZE( strokeS* , pstt1l ) ;
TN( tProtected , "protected :" ) ;
TN( tPrivate , "private :" ) ;
TN( tPublic , "public :" ) ;
TN( tOperator , "operator" ) ;
TN( tFriend , "friend" ) ;
TN( tEtherC , "etherC(" ) ;
TN( tss , "//" ) ;
TN( tStatic , "static" ) ;
TN( tND , "NEWdELcLASSpROTOS" ) ;
TN( tWake , "WAKEsHOWtEXT(" ) ;
TN( tSpacer , "SPACER(" ) ;

etThread.delF( tinBaseP , postIn ) ;
etThread.strReverseF( tinBaseP , psttIn , T(postIn) , tcr ) ; ___( psttIn ) ;
ZE( strokeS* , psttIn ) ;
TN( tcr , "\r\n" ) ;

etThread.boxGetShadowF( tinBaseP , postIn , costIn , T("///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.15000006.etherC") ) ; ___( postIn ) ;
ZE( countT   , costIn ) ;
ZE( osTextT* , postIn ) ;

CONoUTrAW( "SOIXLoLD WORD DEFS\r\n" ) ;

TODO

    }
        ;                                                                                    \
            TF2(idFileNext++,flFORMAT_NObIGITvALUES)+T(".h") , tCode , tCode.csF( tinBaseP ) )                                \
            T("///ideafarm/precious/domains/com/ideafarm/city/library/snip/1snip.005001c.genSoixlOldWord" #whatP "_etherC_")+   \
        etThread.boxPutF( tinBaseP ,                                                             \
        etThread.strokeF( tinBaseP , T("----")+TF2(idFileNext,flFORMAT_NObIGITvALUES)+T("-------------------------------------------------------------\r\n") ) ; \
        etThread.delF( tinBaseP , psttAll ) ;                                                    \
        TN( tCode , "" ) ; tCode = T(psttAll) ;                                              \
        etThread.strConcatenateF( tinBaseP , psttAll , stAll##whatP ) ; ___( psttAll ) ;         \
        ZE( strokeS* , psttAll ) ;                                                         \
    {                                                                                        \
                                                                                             \
#define WRITEwOfILE(whatP)                                                                   \

#define SUPPRESS(postP) ( idf = 1 , !etThread.strIdF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , T(postP) , psttc1 ) ) &&

}
    etThread.delF( tinBaseP , psttName ) ;
    etThread.delF( tinBaseP , psttReturnType ) ;

    }
        stAllMenusP << psttw ;
        stPartM1 >> psttw ;
        ZE( strokeS* , psttw ) ;
    {
    while( stPartM1 )

    }
        stAllHelpsP << psttw ;
        stPartH4 >> psttw ;
        ZE( strokeS* , psttw ) ;
    {
    while( stPartH4 )

    }
        stAllHelpsP << psttw ;
        stPartH3 >> psttw ;
        ZE( strokeS* , psttw ) ;
    {
    while( stPartH3 )

    }
        stAllHelpsP << psttv ; psttv = 0 ;
        strokeS* psttv = psttOldC( tinBaseP , etThread , T("        \"\\r\\n\"\r\n") ) ; ___( psttv ) ;
    {
    if( stPartH3 )

    }
        stAllHelpsP << psttw ;
        stPartH2 >> psttw ;
        ZE( strokeS* , psttw ) ;
    {
    while( stPartH2 )

    }
        stAllHelpsP << psttw ;
        stPartH1 >> psttw ;
        ZE( strokeS* , psttw ) ;
    {
    while( stPartH1 )

    }
        stAllLoadsP << psttw ;
        stPartL1 >> psttw ;
        ZE( strokeS* , psttw ) ;
    {
    while( stPartL1 )

    }
        stAllProtosP << psttw ;
        stPartP1 >> psttw ;
        ZE( strokeS* , psttw ) ;
    {
    while( stPartP1 )

    }
        stAllDefsP << psttw ;
        stPartD5 >> psttw ;
        ZE( strokeS* , psttw ) ;
    {
    while( stPartD5 )

    }
        stAllDefsP << psttw ;
        stPartD4 >> psttw ;
        ZE( strokeS* , psttw ) ;
    {
    while( stPartD4 )

    }
        stAllDefsP << psttw ;
        stPartD3 >> psttw ;
        ZE( strokeS* , psttw ) ;
    {
    while( stPartD3 )

    }
        stAllDefsP << psttw ;
        stPartD2 >> psttw ;
        ZE( strokeS* , psttw ) ;
    {
    while( stPartD2 )

    }
        stAllDefsP << psttw ;
        stPartD1 >> psttw ;
        ZE( strokeS* , psttw ) ;
    {
    while( stPartD1 )

    }
        stPartD4 << psttw ; psttw = 0 ;
        strokeS* psttw = psttOldC( tinBaseP , etThread , tFooter2 ) ; ___( psttw ) ;
    {
    if( idArg < 2 )

    }
        while( !stPartH3.third && ~hDown ) ;
        }
            etThread.strReplaceF( tinBaseP , psttw , 0 , T("@@i@@") , TF1(++idPush) , 0 , flSTRrEPLACE_IGNOREqUOTES ) ;
            strokeS*& psttw = *(strokeS**)&stPartH3.downF( tinBaseP , hDown ) ;
        {
        do
        handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        ZE( countT , idPush ) ;
    {
    if( stPartH3 )

    }
        while( !stArgs.third && ~hDown ) ;
        }
            etThread.delF( tinBaseP , *(strokeS**)&c4p.c3 ) ;
            etThread.delF( tinBaseP , *(strokeS**)&c4p.c2 ) ;
            etThread.delF( tinBaseP , *(strokeS**)&c4p.c1 ) ;

            }
                }
                    stPartH3 << psttHelpPushes ; psttHelpPushes = 0 ;
                    ___( psttHelpPushes ) ;
                    etThread.strReplaceF( tinBaseP , psttHelpPushes , 0           , T("@@n@@") , (strokeS*)c4p.c2          , 0          , flSTRrEPLACE_IGNOREqUOTES ) ;
                    etThread.strReplaceF( tinBaseP , psttHelpPushes , tHelpPushes , T("@@t@@") , TP((strokeS*)c4p.c1,0x10) , csttExtra1 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttHelpPushes ) ;
                    ZE( strokeS* , psttHelpPushes ) ;
                    if( csttExtra1 < 0 ) csttExtra1 = 0 ;
                    sCountT csttExtra1 = ((strokeS*)c4p.c2)->idAdam - 5 ;

                    stPartD4 << psttPart4 ; psttPart4 = 0 ;
                    etThread.strReplaceF( tinBaseP , psttPart4 , bType ? tPushT : tPush , T("@@n@@") , (strokeS*)c4p.c2 ) ; ___( psttPart4 ) ;
                    ;
                        ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] == S1C('*')
                        ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] == S1C('T') ||
                    boolT bType =
                {
                if( c4p.c4 )

                stPartD4 << psttPart4 ; psttPart4 = 0 ;
                etThread.strReplaceF( tinBaseP , psttPart4 , ( bClass ? tDeleteClass : tDeleteType ) , T("@@n@@") , (strokeS*)c4p.c2 ) ; ___( psttPart4 ) ;
                ZE( strokeS* , psttPart4 ) ;

                ;
                    !etThread.strCompareF( tinBaseP , (strokeS*)c4p.c1 , T("handleC*") )
                    ||
                    !etThread.strCompareF( tinBaseP , (strokeS*)c4p.c1 , T("pbRefC*") )
                    ||
                    !etThread.strCompareF( tinBaseP , (strokeS*)c4p.c1 , T("grabC*") )
                    ||
                    !etThread.strCompareF( tinBaseP , (strokeS*)c4p.c1 , T("soulC*") )
                boolT bClass =
            {
            if( ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] == sttast )

            else idArgTin = idArg ;
            }
                stPartH2 << psttHelpPops ; psttHelpPops = 0 ;
                ___( psttHelpPops ) ;
                etThread.strReplaceF( tinBaseP , psttHelpPops , 0         , T("@@i@@") , TF1(++idPop)              , 0          , flSTRrEPLACE_IGNOREqUOTES ) ;
                etThread.strReplaceF( tinBaseP , psttHelpPops , 0         , T("@@n@@") , (strokeS*)c4p.c2          , 0          , flSTRrEPLACE_IGNOREqUOTES ) ;
                etThread.strReplaceF( tinBaseP , psttHelpPops , tHelpPops , T("@@t@@") , TP((strokeS*)c4p.c1,0x10) , csttExtra1 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttHelpPops ) ;
                ZE( strokeS* , psttHelpPops ) ;

                stPartD2 << psttPart2 ; psttPart2 = 0 ;
                ___( psttPart2 ) ;
                stPartD2 << psttv ; psttv = 0 ;
                psttv = psttOldC( tinBaseP , etThread , T("   SOIXLoLDtESTtYPE( 0x")+TF2(idTypeSoulItem,flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T(" , etherC )\r\n") ) ; ___( psttv ) ;
                stPartD2 << psttv ; psttv = 0 ;
                strokeS* psttv = psttOldC( tinBaseP , etThread , T("\r\n   SOIXLoLDtESTeMPTY( 0x")+TF2(idTypeSoulItem,flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T(" , etherC )\r\n") ) ; ___( psttv ) ;
                etThread.strReplaceF( tinBaseP , psttPart2 , 0                                                             , T("@@a@@") , tCtArg           ) ;
                etThread.strReplaceF( tinBaseP , psttPart2 , 0                                                             , T("@@t@@") , (strokeS*)c4p.c1 ) ;
                etThread.strReplaceF( tinBaseP , psttPart2 , bZe ? ( bType ? tArgTZ : tArgZ ) : ( bType ? tArgT : tArg ) , T("@@n@@") , (strokeS*)c4p.c2 , csttExtra1 + csttExtra2 ) ; ___( psttPart2 ) ;
                ZE( strokeS* , psttPart2 ) ;

                }
                    if( csttExtra2 < 0 ) csttExtra2 = 0 ;
                    sCountT csttExtra2 = tCtArg.csF( tinBaseP ) - 5 ;

                    else if( !etThread.strCompareF( tinBaseP , (strokeS*)c4p.c1 , T("patternC") ) ) tCtArg = T("( /*GOOEY*/tinBaseP , TAG( TAGiDnULL ) )") ; //20200530@1612: ADDED WITHOUT ANALYSIS, HOPING THAT THIS WILL SUPPRESS patternC* PARAMETERS
                         if( !etThread.strCompareF( tinBaseP , (strokeS*)c4p.c1 , T("handleC" ) ) ) tCtArg = T("( /*GOOEY*/tinBaseP , TAG( TAGiDnULL ) )") ;
                {
                if( !bZe )
                ZE( countT , csttExtra2 ) ;
                TN( tCtArg , "" ) ;

                ;
                    ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] != S1C('U')
                    ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] != S1C('S') &&
                    ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] != S1C('C') &&
                boolT bZe =

                ;
                    ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] == S1C('*')
                    ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] == S1C('T') ||
                boolT bType =

                if( csttExtra1 < 0 ) csttExtra1 = 0 ;
                sCountT csttExtra1 = ((strokeS*)c4p.c2)->idAdam - 5 ;
            {
            else if( etThread.strCompareF( tinBaseP , (strokeS*)c4p.c2 , tTinP ) )
            }
                stPartH2 << psttHelpPops ; psttHelpPops = 0 ;
                ___( psttHelpPops ) ;
                etThread.strReplaceF( tinBaseP , psttHelpPops , 0         , T("@@i@@") , TF1(++idPop)              , 0         , flSTRrEPLACE_IGNOREqUOTES ) ;
                etThread.strReplaceF( tinBaseP , psttHelpPops , 0         , T("@@n@@") , (strokeS*)c4p.c2          , 0         , flSTRrEPLACE_IGNOREqUOTES ) ;
                etThread.strReplaceF( tinBaseP , psttHelpPops , tHelpPops , T("@@t@@") , TP((strokeS*)c4p.c1,0x10) , csttExtra , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttHelpPops ) ;
                ZE( strokeS* , psttHelpPops ) ;

                stPartD2 << psttPart2 ; psttPart2 = 0 ;
                ___( psttPart2 ) ;
                stPartD2 << psttv ; psttv = 0 ;
                psttv = psttOldC( tinBaseP , etThread , T("    SOIXLoLDtESTtYPE( 0x")+TF2(idTypeSoulItem,flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T(" , etherC )\r\n") ) ; ___( psttv ) ;
                stPartD2 << psttv ; psttv = 0 ;
                psttv = psttOldC( tinBaseP , etThread , T("\r\n    SOIXLoLDtESTeMPTY( 0x")+TF2(idTypeSoulItem,flFORMAT_UNSIGNED|flFORMAT_FOREIGN)+T(" , etherC )\r\n") ) ; ___( psttv ) ;
                ZE( strokeS* , psttv ) ;
                etThread.strReplaceF( tinBaseP , psttPart2 , 0       , T("@@t@@") , (strokeS*)c4p.c1 ) ;
                etThread.strReplaceF( tinBaseP , psttPart2 , tArgPtr , T("@@n@@") , (strokeS*)c4p.c2 , csttExtra ) ; ___( psttPart2 ) ;
                ZE( strokeS* , psttPart2 ) ;

                if( csttExtra < 0 ) csttExtra = 0 ;
                sCountT csttExtra = ((strokeS*)c4p.c2)->idAdam - 5 ;
            {
            else if( ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] == sttast )
            }
                stPartH2 << psttHelpPops ; psttHelpPops = 0 ;
                ___( psttHelpPops ) ;
                etThread.strReplaceF( tinBaseP , psttHelpPops , 0                 , T("@@i@@") , TF1(++idPop)              , 0                 , flSTRrEPLACE_IGNOREqUOTES ) ;
                etThread.strReplaceF( tinBaseP , psttHelpPops , 0                 , T("@@d@@") , (strokeS*)c4p.c3          , 0                 , flSTRrEPLACE_IGNOREqUOTES ) ;
                etThread.strReplaceF( tinBaseP , psttHelpPops , 0                 , T("@@n@@") , TP((strokeS*)c4p.c2,0x10) , 0                 , flSTRrEPLACE_IGNOREqUOTES ) ;
                etThread.strReplaceF( tinBaseP , psttHelpPops , tHelpPopsDefaults , T("@@t@@") , TP((strokeS*)c4p.c1,0x10) , csttExtra1 + 0x10 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttHelpPops ) ;
                ZE( strokeS* , psttHelpPops ) ;

                stPartD2 << psttPart2 ; psttPart2 = 0 ;
                ___( psttPart2 ) ;
                etThread.strReplaceF( tinBaseP , psttPart2 , 0                                                                         , T("@@z@@") , TF2(idTypeSoulItem,flFORMAT_UNSIGNED|flFORMAT_FOREIGN) ) ;
                etThread.strReplaceF( tinBaseP , psttPart2 , 0                                                                         , T("@@a@@") , tCtArg           ) ;
                etThread.strReplaceF( tinBaseP , psttPart2 , 0                                                                         , T("@@v@@") , (strokeS*)c4p.c3 ) ;
                etThread.strReplaceF( tinBaseP , psttPart2 , 0                                                                         , T("@@t@@") , (strokeS*)c4p.c1 ) ;
                etThread.strReplaceF( tinBaseP , psttPart2 , bZe ? ( bType ? tDefArgTZ : tDefArgZ ) : ( bType ? tDefArgT : tDefArg ) , T("@@n@@") , (strokeS*)c4p.c2 , csttExtra1 + csttExtra2 + csttExtra3 ) ; ___( psttPart2 ) ;
                ZE( strokeS* , psttPart2 ) ;

                }
                    if( csttExtra3 < 0 ) csttExtra3 = 0 ;
                    sCountT csttExtra3 = tCtArg.csF( tinBaseP ) - 5 ;

                    else if( !etThread.strCompareF( tinBaseP , (strokeS*)c4p.c1 , T("patternC") ) ) tCtArg = T("( /*FOOEY*/tinBaseP , TAG( TAGiDnULL ) )") ; //20200530@1612: ADDED WITHOUT ANALYSIS, HOPING THAT THIS WILL SUPPRESS patternC* PARAMETERS
                         if( !etThread.strCompareF( tinBaseP , (strokeS*)c4p.c1 , T("handleC" ) ) ) tCtArg = T("( /*FOOEY*/tinBaseP , TAG( TAGiDnULL ) )") ;
                {
                if( !bZe )
                ZE( countT , csttExtra3 ) ;
                TN( tCtArg , "" ) ;

                ;
                    ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] != S1C('U')
                    ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] != S1C('S') &&
                    ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] != S1C('C') &&
                boolT bZe =

                ;
                    ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] == S1C('*')
                    ((strokeS*)c4p.c1)[ CSpREFIX - 1 + ((strokeS*)c4p.c1)->idAdam ] == S1C('T') ||
                boolT bType =

                if( csttExtra2 < 0 ) csttExtra2 = 0 ;
                if( csttExtra1 < 0 ) csttExtra1 = 0 ;
                sCountT csttExtra2 = ((strokeS*)c4p.c3)->idAdam - 5 ;
                sCountT csttExtra1 = ((strokeS*)c4p.c2)->idAdam - 5 ;
            {
            if( c4p.c3 )

            }
                etThread.delF( tinBaseP , psttNoStar ) ;
                idTypeSoulItem = processGlobal4S::_processGlobal4I_IF().mapSoulItem( T(psttNoStar) ) ;
                etThread.strReplaceF( tinBaseP , psttNoStar , (strokeS*)c4p.c1 , T("*") , T("ptr") ) ; ___( psttNoStar ) ;
                ZE( strokeS* , psttNoStar ) ;
            {
            ZE( countT , idTypeSoulItem ) ;

            //etThread.strokeF( tinBaseP , T("\"")+T((strokeS*)c4p.c1)+T("\" \"")+T((strokeS*)c4p.c2)+T("\" \"")+T((strokeS*)c4p.c3)+T("\"\r\n") ) ;
            count4S& c4p =  *(count4S*)&stArgs.downF( tinBaseP , hDown ) ;
            idArg ++ ;
        {
        do
        handleC hDown( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stArgs )
    ZE( countT , idPop ) ; //WILL DIFFER FROM idArg WHENEVER tinBaseP IS AN ARG, BECAUSE tinBaseP IS NEVER POPPED
    ZE( countT , idArgTin ) ;
    ZE( countT , idArg ) ;

    //etThread.strokeF( tinBaseP , T("name: \"")+T(psttName)+T("\"\r\n") ) ;
    //etThread.strokeF( tinBaseP , T("return type: \"")+T(psttReturnType)+T("\"\r\n") ) ;

    }
        stPartM1 << psttHelpMenu ; psttHelpMenu = 0 ;
        etThread.strReplaceF( tinBaseP , psttHelpMenu , tHelpMenu , T("@@w@@") , tMangled , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttHelpMenu ) ;
        ZE( strokeS* , psttHelpMenu ) ;

        stPartH4 << psttw ; psttw = 0 ;
        etThread.delF( tinBaseP , psttEx ) ;
        ) ) ; ___( psttw ) ;

            "}\r\n"
            "   _pSwSoixlOldApi->ungrabF( tinBaseP ) ;\r\n"
            "   *_pSwSoixlOldApiDoc = (countT)(strokeS*)psttOldC( tinBaseP , *this , tDoc ) ;\r\n"
            "   if( *_pSwSoixlOldApiDoc ) { BLAMMO ; }\r\n"
            "   _psttLeverSoixlOldApi = tNameSoixlOld ;\r\n"
            "   _pSwSoixlOldApi->grabF( tinBaseP , TAG( TAGiDnULL ) ) ;\r\n"
            "    TN( tNameSoixlOld , \"")+tMangled+T("\" ) ;\r\n"
            "    TN( tDoc , postDoc ) ;\r\n"
            "\r\n"
            "    ;\r\n"
            "\r\n"
            "        \"    . off space\\r\\n\"\r\n"
            T(psttEx)+T(
            "        \"    . on space\\r\\n\"\r\n")+
            "        \"\\r\\n\"\r\n"
            "        \"the Depository:\\r\\n\"\r\n"
            "        \"To manifest the following example code, drop this document into\\r\\n\"\r\n"
            "        \"\\r\\n\"\r\n"

        psttw = psttOldC( tinBaseP , etThread , T(

        }
            etThread.delF( tinBaseP , pstt1l ) ;
            }
                etThread.delF( tinBaseP , psttl ) ;
                etThread.strFuseF( tinBaseP , psttEx , T("        \"    ")+T(psttl)+T("\\r\\n\"\r\n") ) ;
                etThread.strReplaceF( tinBaseP , psttl , psttc1 , T("\"") , T("\\\"") , 0 , flSTRrEPLACE_IGNOREqUOTES ) ;
                ZE( strokeS* , psttl ) ;
            {
            FORsTRINGSiN1( pstt1l )
            etThread.strMakeF( tinBaseP , LF , psttEx , T("") , cLines * 0x40 + pstt1l->idAdam * 2 ) ; ___( psttEx ) ;
            etThread.delF( tinBaseP , pstti ) ;
            countT cLines = etThread.strWordsOldF( tinBaseP , pstt1l , pstti , sttq , T("\r\n") ) ; ___( pstt1l ) ;
            ZE( strokeS* , pstt1l ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            etThread.delF( tinBaseP , pbi ) ;
            etThread.strReverseF( tinBaseP , pstti , T(pbi) , T("\r\n") ) ; ___( psttEx ) ;
            ZE( strokeS* , pstti ) ;
            etThread.boxGetShadowF( tinBaseP , pbi , cbi , tFileName ) ; ___( pbi ) ;
            ZE( countT   , cbi ) ;
            ZE( osTextT* , pbi ) ;
        {
        else
        }
            etThread.strMakeF( tinBaseP , LF , psttEx , tNA ) ; ___( psttEx ) ;
            TN( tNA , "" ) ; tNA = T("        \"    . \\\"Simple example code for \\\\\\\"")+tMangled+T("\\\\\\\" is not yet available.  Example code will eventually be presented for every word; this is a universal feature of all IdeaFarm (tm) software products and is enforced by the internal IdeaFarm " "(tm) development environment.\\\" POPUP\\r\\n\"\r\n") ;
        {
        if( !etThread.diskFileExistsF( tinBaseP , tFileName ) )
        TN( tFileName , "" ) ; tFileName = T("///d/ideafarm.work/backed.up.daily/txt/soixlOld/examples/simplest/soixlOld.")+tMangled+T(".txt") ;
        ZE( strokeS* , psttEx ) ;

        stPartH1 << psttw ; psttw = 0 ;
        ) ) ; ___( psttw ) ;

            "        \"\\r\\n\"\r\n"
            "        \"Each manifestation of \\\"")+tMangled+T("\\\" uses the current stack in this way:\\r\\n\"\r\n"
            "        \"\\r\\n\"\r\n"
            "        \"is also an executable SOIL (tm) program.\\r\\n\"\r\n"
            "        \"manifest that code, drop this file into the Depository.  IOW, this file\\r\\n\"\r\n"
            "        \"Instructions:  Read this file.  It contains simple example code.  To\\r\\n\"\r\n"
            "        \"\\r\\n\"\r\n"
            "        \"\\r\\n\"\r\n"
            "        \"Subject: Command word \\\"")+tMangled+T("\\\"\\r\\n\"\r\n"
            "        \"\\r\\n\"\r\n"
            "        \"Author: \\\"")+tMangled+T("\\\"\\r\\n\"\r\n"
            "        \"Class: etherC")+T("\\r\\n\"\r\n"
            "        \"\\r\\n\"\r\n"
            "        \"IdeaFarm " "(tm) SOIL (tm) - Sentient Object Interface Language\\r\\n\"\r\n"
            "        \"" USCORE79 "\\r\\n\"\r\n"
            "        \"\\r\\n\"\r\n"
            "        \". off space\\r\\n\"\r\n"
            "        \"" POSTpROLOG "\\r\\n\"\r\n"
            "\r\n"
            "    osTextT* postDoc =\r\n"
            "{\r\n"
            "\r\n"

        psttw = psttOldC( tinBaseP , etThread , T(
        TN( tMangled , "" ) ; tMangled = T(psttName)+T("_")+tMangle ;

        stPartL1 << psttw ; psttw = 0 ;
        ) ) ; ___( psttw ) ;

            "}\r\n"
            "    _pSwSoixlOldApi->ungrabF( tinBaseP ) ;\r\n"
            "    *_pSwSoixlOldApi = (countT)")+tNameCpp+T(" ;\r\n"
            "    if( *_pSwSoixlOldApi ) { BLAMMO ; }\r\n"
            "    _psttLeverSoixlOldApi = tNameSoixlOld ;\r\n"
            "    _pSwSoixlOldApi->grabF( tinBaseP , TAG( TAGiDnULL ) ) ;\r\n"
            "    TN( tNameSoixlOld , \"")+T(psttName)+T("_")+tMangle+T("\" ) ;\r\n"
            "{\r\n"

        psttw = psttOldC( tinBaseP , etThread , T(

        stPartD1 << psttw ; psttw = 0 ;
        etThread.strReplaceF( tinBaseP , psttw , tHeader , T("@@f@@") , tNameCpp , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttw ) ;

        stPartP1 << psttw ; psttw = 0 ;
        etThread.strReplaceF( tinBaseP , psttw , tProto , T("@@f@@") , tNameCpp , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttw ) ;

        }
            etThread.delF( tinBaseP , psttm2 ) ;
            tNameCpp = T(psttName)+S1C('_')+T(psttm2)+T("_GF") ;
            etThread.strReplaceF( tinBaseP , psttm2 , tMangle , T("@") , T("P") , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttm2 ) ;
            ZE( strokeS* , psttm2 ) ;
        {

        stPartD5 << psttw ; psttw = 0 ;
        psttw = psttOldC( tinBaseP , etThread , T("}\r\n") ) ; ___( psttw ) ;

        stPartD3 << psttw ; psttw = 0 ;
        strokeS* psttw = psttOldC( tinBaseP , etThread , T(" ) ;\r\n") ) ; ___( psttw ) ;

        etThread.delF( tinBaseP , pstt1w ) ;
        }
            }
                }
                    cNest -= etThread.strTallyF( tinBaseP , tCloseParen , psttc1 , sttq ) ;
                    cNest += etThread.strTallyF( tinBaseP , tOpenParen , psttc1 , sttq ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;

                    }
                        }
                            break ;
                            }
                                else              tDefaultValue += tb+T(psttc1) ;
                                if( idWord == 4 ) tDefaultValue  =    T(psttc1) ;
                            {
                            if( bAssign )
                        {
                        default :
                        }
                            break ;
                            bAssign = psttc1[ CSpREFIX ] == sttAssign ;
                        {
                        case 3 :
                        }
                            break ;

                            stPartD3 << psttw ; psttw = 0 ;
                            strokeS* psttw = psttOldC( tinBaseP , etThread , T(idArg>1?" , ":" ")+T(psttc1) ) ; ___( psttw ) ;

                            c4p.c2 = (countT)(strokeS*)psttOldC( tinBaseP , etThread , psttc1 ) ; ___( c4p.c2 ) ;
                            count4S& c4p = *(count4S*)&stArgs[ - 1 ] ;
                        {
                        case 2 :
                        }
                            break ;
                            stArgs << (byteT*)&c4p ;
                            //etThread.strokeF( tinBaseP , T("after appending for \"")+T((strokeS*)c4p.c1)+T("\", mangle is \"")+tMangle+T("\"\r\n") ) ; //U::
                            if( idArg > 1 || etThread.strCompareF( tinBaseP , (strokeS*)c4p.c1 , T("tin9S") ) ) tMangle += tMangleNew ;

                            }
                                else tMangleNew = T(postMangleF(tinBaseP,T((strokeS*)c4p.c1))) ;
                                }
                                    etThread.delF( tinBaseP , psttw ) ;
                                    tMangleNew = T(postMangleF(tinBaseP,T(psttw)))+TPS("",((strokeS*)c4p.c1)->idAdam-idlSave,sttAt) ;
                                    if( idl ) { etThread.strSubstringF( tinBaseP , psttw , idf , idl , (strokeS*)c4p.c1 ) ; ___( psttw ) ; }
                                    ZE( strokeS* , psttw ) ;
                                    countT idf = 1 ;
                                    countT idlSave = idl ;
                                {
                                if( idl != ((strokeS*)c4p.c1)->idAdam )
                                while( idl && ((strokeS*)c4p.c1)[ CSpREFIX - 1 + idl ] == sttast ) idl -- ;
                                countT idl = ((strokeS*)c4p.c1)->idAdam ;
                            {
                            TN( tMangleNew , "" ) ;

                            else { c4p.c1 = (countT)(strokeS*)psttOldC( tinBaseP , etThread , psttc1 ) ; ___( c4p.c1 ) ; }
                            }
                                etThread.strSubstringF( tinBaseP , *(strokeS**)&c4p.c1 , idf , idl , psttc1 ) ; ___( c4p.c1 ) ;
                                countT idl = psttc1->idAdam - 1 ;
                                countT idf = 1 ;
                            {
                            if( c4p.c4 )
                            count4S c4p( 0 , 0 , 0 , psttc1[ CSpREFIX - 1 + psttc1->idAdam ] == sttamp ) ;
                            ++ idArg ;
                        {
                        case 1 :
                    {
                    switch( idWord )
                {
                else
                }
                    break ;
                    }
                        tDefaultValue = tNull ;
                        c4p.c3 = (countT)(strokeS*)psttOldC( tinBaseP , etThread , tDefaultValue ) ; ___( c4p.c3 ) ;
                        count4S& c4p = *(count4S*)&stArgs[ - 1 ] ;
                    {
                    if( tDefaultValue.csF( tinBaseP ) )
                {
                else if( psttc1[ CSpREFIX ] == sttClose && !cNest )
                }
                    idWord = 0 ;
                    }
                        tDefaultValue = tNull ;
                        c4p.c3 = (countT)(strokeS*)psttOldC( tinBaseP , etThread , tDefaultValue ) ; ___( c4p.c3 ) ;
                        count4S& c4p = *(count4S*)&stArgs[ - 1 ] ;
                    {
                    if( tDefaultValue.csF( tinBaseP ) )
                {
                if( psttc1[ CSpREFIX ] == sttComma && !cNest )
                ++ idWord ;
            {
            else if( 1 != etThread.strIdF( tinBaseP , tConst , psttc1 ) )
            }
                //etThread.strokeF( tinBaseP , T(psttName)+tcr ) ;

                stPartD3 << psttw ; psttw = 0 ;
                strokeS* psttw = psttOldC( tinBaseP , etThread , T("etherP.")+T(psttName)+T("(") ) ; ___( psttw ) ; //E: psttw: "delF"

                etThread.strSubstringF( tinBaseP , psttName , idf , idl , psttc1 ) ; ___( psttName ) ; //E: psttc1: "delF("
                countT idl = psttc1->idAdam - 1 ;
                countT idf = 1 ;
            {
            else if( !psttName )
            }
                }
                    stPartD3 << psttw ; psttw = 0 ;
                    strokeS* psttw = psttOldC( tinBaseP , etThread , tIndent+tIfPotent ) ; ___( psttw ) ;
                {
                else
                }
                    etThread.delF( tinBaseP , psttReturnName ) ;
                    stPartH3 << psttHelpPushes ; psttHelpPushes = 0 ;
                    ___( psttHelpPushes  ) ;
                    etThread.strReplaceF( tinBaseP , psttHelpPushes , 0           , T("@@n@@") , psttReturnName ? T(psttReturnName) : T("") , 0         , flSTRrEPLACE_IGNOREqUOTES ) ;
                    etThread.strReplaceF( tinBaseP , psttHelpPushes , tHelpPushes , T("@@t@@") , TP(psttReturnType,0x10)                    , csttExtra , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttHelpPushes ) ;
                    ZE( strokeS* , psttHelpPushes ) ;
                    if( csttExtra < 0 ) csttExtra = 0 ;
                    sCountT csttExtra = psttReturnName ? psttReturnName->idAdam - 5 : 0 ;

                    stPartD5 << psttw ; psttw = 0 ;
                    ___( psttw ) ;
                    ;
                        : psttOldC( tinBaseP , etThread , T("\r\n")+tIndent+T(psttReturnName)+T(" >> slP ;\r\n") )
                        ? psttOldC( tinBaseP , etThread , T("\r\n")+tIndent+T("slP << ")+T(psttReturnName)+T(" ;\r\n") )
                    psttw = bType

                    stPartD3 << psttw ; psttw = 0 ;
                    ; ___( psttw ) ;
                        : psttOldC( tinBaseP , etThread , T("\r\n")+tIndent+T(psttReturnType)+T(" ")+T(psttReturnName)+T(" ;\r\n")+tIndent+tIfPotent+T(psttReturnName)+T(" = ") )
                        ? psttOldC( tinBaseP , etThread , T("\r\n")+tIndent+T("ZE( ")+T(psttReturnType)+T(" , ")+T(psttReturnName)+T(" ) ;\r\n")+tIndent+tIfPotent+T(psttReturnName)+T(" = ") )
                    strokeS* psttw = bType

                    }
                        if( !psttReturnName ) { psttReturnName = psttOldC( tinBaseP , etThread , T("noName") ) ; ___( psttReturnName ) ; }

                        }
                            etThread.delF( tinBaseP , psttd ) ;
                            etThread.strSubstringF( tinBaseP , psttReturnType , idf , idl , psttd ) ; ___( psttReturnType ) ;
                            strokeS* psttd = psttReturnType ; psttReturnType = 0 ;
                            idl = idfSave - 1 ;
                            idf = 1 ;

                            etThread.strSubstringF( tinBaseP , psttReturnName , idf , idl , psttc1 ) ; ___( psttReturnName ) ;
                            idl -- ;
                            idf += 2 ;
                            countT idfSave = idf ;
                        {
                        if( idf > 1 && idf < idl )
                        countT idl = etThread.strIdF( tinBaseP , T("*/") , psttc1 ) ;
                        countT idf = etThread.strIdF( tinBaseP , T("/*") , psttc1 ) ;
                    {
                    ZE( strokeS* , psttReturnName ) ;
                    ;
                        psttc1[ CSpREFIX - 1 + psttc1->idAdam ] == S1C('*')
                        psttc1[ CSpREFIX - 1 + psttc1->idAdam ] == S1C('T') ||
                    boolT bType =
                {
                if( etThread.strCompareF( tinBaseP , tVoidT , psttc1 ) && !etThread.strIdF( tinBaseP , T("&") , psttc1 ) )
                psttReturnType = psttOldC( tinBaseP , etThread , psttc1 ) ; ___( psttReturnType ) ; //E: psttc1: "voidT"
            {
            if( !psttReturnType )
        {
        FORsTRINGSiN1( pstt1w )
        ZE( countT , cNest ) ;
        ZE( countT , idArg ) ;
        ZE( boolT , bAssign ) ;
        ZE( countT , idWord ) ;
        etThread.strWordsOldF( tinBaseP , pstt1w , pstt1P , sttq ) ; ___( pstt1w ) ; //E: pstt1P: " voidT delF( tin0S& tinBaseP , byteT*& pP ) ;"
        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , pstt1w ) ;
        strokeS sttAssign( '=' ) ;
        strokeS sttClose( ')' ) ;
        strokeS sttComma( ',' ) ;
        TN( tVoidT , "voidT" ) ;
        TN( tConst , "const" ) ;
        TN( tcr , "\r\n" ) ;
        TN( tb , " " ) ;
    {
    TN( tNameCpp , "" ) ;
    TN( tIfPotent , "if( !POOP ) " ) ;
    TN( tNull , "" ) ;
    TN( tDefaultValue , "" ) ;
    strokeS sttamp( '&' ) ;
    strokeS sttAt( '@' ) ;
    strokeS sttast( '*' ) ;
    TN( tMangle , "" ) ;
    ZE( strokeS* , psttName ) ;
    ZE( strokeS* , psttReturnType ) ;
    TN( tCloseParen , ")" ) ;
    TN( tOpenParen , "(" ) ;
    TN( tIndent , postIndent ) ;
    TN( tFooter2 , postFooter2 ) ;
    TN( tFooter , postFooter ) ;
    TN( tHeader , postHeader ) ;
    TN( tProto , postProto ) ;
    TN( tHelpMenu , postHelpMenu ) ;
    TN( tHelpPushes , postHelpPushes ) ;
    TN( tHelpPops , postHelpPops ) ;
    TN( tHelpPopsDefaults , postHelpPopsDefaults ) ;
    TN( tPush   , postPush ) ;
    TN( tPushT  , postPushT ) ;
    TN( tDeleteClass , postDeleteClass ) ;
    TN( tDeleteType , postDeleteType ) ;
    TN( tArg    , postArg    ) ;
    TN( tArgT   , postArgT   ) ;
    TN( tArgZ   , postArgZ   ) ;
    TN( tArgTZ  , postArgTZ  ) ;
    TN( tArgPtr , postArgPtr ) ; //****
    TN( tDefArgZ , postDefArgZ ) ;
    TN( tDefArgTZ , postDefArgTZ ) ;
    TN( tDefArg , postDefArg ) ;
    TN( tDefArgT , postDefArgT ) ;
    TN( tTinP , "tinBaseP" ) ;

    stackC stPartM1( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stPartH4( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stPartH3( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stPartH2( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stPartH1( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stPartL1( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stPartP1( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stPartD5( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stPartD4( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stPartD3( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stPartD2( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stPartD1( tinBaseP, etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stArgs( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO|flSTACKc_BLOB , sizeof( count4S ) ) ;

    //E: pstt1P: " voidT delF( tin0S& tinBaseP , byteT*& pP ) ;"
    //E: THE LINE OF INPUT IN THE COMMENT LINE IMMEDIATELY FOLLOWING ME IS ASSUMED AS AN EXAMPLE IN COMMENTS HEREIN

    //20240725@1117: MY PARSING OBSERVED TO FAIL WHEN A COMMA IS NOT PRECEDED BY A SPACE (EXAMPLE: " voidT delF( tin0S& tinBaseP, byteT*& pP ) ;"
{
voidT parsePrototypeF( tin0S& tinBaseP , etherC& etThread , stackC& stAllDefsP , stackC& stAllProtosP , stackC& stAllLoadsP , stackC& stAllHelpsP , stackC& stAllMenusP , const strokeS* const pstt1P )

const osTextT postHelpMenu[] = "    \"    . @@w@@       . ?? \")+T(postName)+T(\"\\r\\n\"\r\n" ;

const osTextT postHelpPushes[] = "        \"    Push @@i@@:    @@t@@ @@n@@\\r\\n\"\r\n" ;

const osTextT postHelpPops[] = "        \"    Pop  @@i@@:    @@t@@ @@n@@\\r\\n\"\r\n" ;

const osTextT postHelpPopsDefaults[] = "        \"    Pop  @@i@@:    @@t@@ @@n@@                (defaults to @@d@@)\\r\\n\"\r\n" ;

const osTextT postPush[] = "\r\n    if( !POOP ) @@n@@ >> slP ;\r\n" ;

const osTextT postPushT[] = "\r\n    if( !POOP ) slP << @@n@@ ;\r\n" ;

const osTextT postDeleteClass[] = "    DEL( @@n@@ ) ;\r\n" ;

const osTextT postDeleteType[] = "    etherP.delF( tinBaseP , @@n@@ ) ;\r\n" ;

;
    "    }\r\n"
    "        }\r\n"
    "            }\r\n"
    "                if( !POOP ) { @@n@@ << slP ; idArgNext ++ ; }\r\n"
    "                SOIXLoLDtESTtYPE( 0x@@z@@ , etherC )\r\n"
    "            {\r\n"
    "            else\r\n"
    "            }\r\n"
    "                etherP.delF( tinBaseP , psttNext ) ;\r\n"
    "                if( !POOP ) { slP >> psttNext ; ___( psttNext ) ; idArgNext ++ ; }\r\n"
    "                psttNext = 0 ;\r\n"
    "                @@n@@ = @@v@@ ;\r\n"
    "            {\r\n"
    "            if( idTypeNext == ifcIDtYPEsOULiTEM_strokeSptr && psttNext && psttNext->idAdam == 1 && psttNext[ CSpREFIX ] == sttColon )\r\n"
    "            strokeS* psttNext = *pbFieldNext & flSOULiTEM_NULLpTR ? 0 : (strokeS*)pbFieldNext ;\r\n"
    "            pbFieldNext = slP.pbFieldF( tinBaseP , idTypeNext , flagsNext , cbFieldNext , 1 ) ;\r\n"
    "           idTypeNext = flagsNext = cbFieldNext = 0 ;\r\n"
    "        {\r\n"
    "        if( !POOP )\r\n"
    "        SOIXLoLDtESTeMPTY( 0x@@z@@ , etherC )\r\n"
    "        strokeS sttColon( ':' ) ;\r\n"
    "    {\r\n"
    "    ZE( @@t@@ , @@n@@ ) ;\r\n"
    "\r\n"
const osTextT postDefArgZ[] =

;
    "    }\r\n"
    "        }\r\n"
    "            }\r\n"
    "                if( !POOP ) { slP >> @@n@@ ; idArgNext ++ ; }\r\n"
    "                SOIXLoLDtESTtYPE( 0x@@z@@ , etherC )\r\n"
    "            {\r\n"
    "            else\r\n"
    "            }\r\n"
    "                etherP.delF( tinBaseP , psttNext ) ;\r\n"
    "                if( !POOP ) { slP >> psttNext ; ___( psttNext ) ; idArgNext ++ ; }\r\n"
    "                psttNext = 0 ;\r\n"
    "                @@n@@ = @@v@@ ;\r\n"
    "            {\r\n"
    "            if( idTypeNext == ifcIDtYPEsOULiTEM_strokeSptr && psttNext && psttNext->idAdam == 1 && psttNext[ CSpREFIX ] == sttColon )\r\n"
    "            strokeS* psttNext = *pbFieldNext & flSOULiTEM_NULLpTR ? 0 : (strokeS*)pbFieldNext ;\r\n"
    "            pbFieldNext = slP.pbFieldF( tinBaseP , idTypeNext , flagsNext , cbFieldNext , 1 ) ;\r\n"
    "           idTypeNext = flagsNext = cbFieldNext = 0 ;\r\n"
    "        {\r\n"
    "        if( !POOP )\r\n"
    "        SOIXLoLDtESTeMPTY( 0x@@z@@ , etherC )\r\n"
    "        strokeS sttColon( ':' ) ;\r\n"
    "    {\r\n"
    "    ZE( @@t@@ , @@n@@ ) ;\r\n"
    "\r\n"
const osTextT postDefArgTZ[] =

;
    "    }\r\n"
    "        }\r\n"
    "            }\r\n"
    "                if( !POOP ) { @@n@@ << slP ; idArgNext ++ ; }\r\n"
    "                SOIXLoLDtESTtYPE( 0x@@z@@ , etherC )\r\n"
    "                SOIXLoLDtESTeMPTY( 0x@@z@@ , etherC )\r\n"
    "            {\r\n"
    "            else\r\n"
    "            }\r\n"
    "                etherP.delF( tinBaseP , psttNext ) ;\r\n"
    "                if( !POOP ) { slP >> psttNext ; ___( psttNext ) ; idArgNext ++ ; }\r\n"
    "                psttNext = 0 ;\r\n"
    "                @@n@@ = @@v@@ ;\r\n"
    "            {\r\n"
    "            if( idTypeNext == ifcIDtYPEsOULiTEM_strokeSptr && psttNext && psttNext->idAdam == 1 && psttNext[ CSpREFIX ] == sttColon )\r\n"
    "            strokeS* psttNext = *pbFieldNext & flSOULiTEM_NULLpTR ? 0 : (strokeS*)pbFieldNext ;\r\n"
    "           pbFieldNext = slP.pbFieldF( tinBaseP , idTypeNext , flagsNext , cbFieldNext , 1 ) ;\r\n"
    "           idTypeNext = flagsNext = cbFieldNext = 0 ;\r\n"
    "        {\r\n"
    "        if( !POOP )\r\n"
    "        SOIXLoLDtESTeMPTY( 0x@@z@@ , etherC )\r\n"
    "        strokeS sttColon( ':' ) ;\r\n"
    "    {\r\n"
    "    @@t@@ @@n@@@@a@@ ;\r\n"
    "\r\n"
const osTextT postDefArg[] =

;
    "    }\r\n"
    "        }\r\n"
    "            }\r\n"
    "                if( !POOP ) { slP >> @@n@@ ; idArgNext ++ ; }\r\n"
    "                SOIXLoLDtESTtYPE( 0x@@z@@ , etherC )\r\n"
    "                SOIXLoLDtESTeMPTY( 0x@@z@@ , etherC )\r\n"
    "            {\r\n"
    "            else\r\n"
    "            }\r\n"
    "                etherP.delF( tinBaseP , psttNext ) ;\r\n"
    "                if( !POOP ) { slP >> psttNext ; ___( psttNext ) ; idArgNext ++ ; }\r\n"
    "                psttNext = 0 ;\r\n"
    "                @@n@@ = @@v@@ ;\r\n"
    "            {\r\n"
    "            if( idTypeNext == ifcIDtYPEsOULiTEM_strokeSptr && psttNext && psttNext->idAdam == 1 && psttNext[ CSpREFIX ] == sttColon )\r\n"
    "            strokeS* psttNext = *pbFieldNext & flSOULiTEM_NULLpTR ? 0 : (strokeS*)pbFieldNext ;\r\n"
    "           pbFieldNext = slP.pbFieldF( tinBaseP , idTypeNext , flagsNext , cbFieldNext , 1 ) ;\r\n"
    "           idTypeNext = flagsNext = cbFieldNext = 0 ;\r\n"
    "        {\r\n"
    "        if( !POOP )\r\n"
    "        SOIXLoLDtESTeMPTY( 0x@@z@@ , etherC )\r\n"
    "        strokeS sttColon( ':' ) ;\r\n"
    "    {\r\n"
    "    @@t@@ @@n@@@@a@@ ;\r\n"
    "\r\n"
const osTextT postDefArgT[] =

;
    "    if( !POOP ) { slP >> @@n@@ ; ___( @@n@@ ) ; idArgNext ++ ; }\r\n"
    "    ZE( @@t@@ , @@n@@ ) ;\r\n"
const osTextT postArgPtr[] =

;
    "    if( !POOP ) { @@n@@ << slP ; idArgNext ++ ; }\r\n"
    "    ZE( @@t@@ , @@n@@ ) ;\r\n"
const osTextT postArgZ[] =

;
    "    if( !POOP ) { slP >> @@n@@ ; idArgNext ++ ; }\r\n"
    "    ZE( @@t@@ , @@n@@ ) ;\r\n"
const osTextT postArgTZ[] =

;
    "    if( !POOP ) { @@n@@ << slP ; idArgNext ++ ; }\r\n"
    "    @@t@@ @@n@@@@a@@ ;\r\n"
const osTextT postArg[] =

;
    "    if( !POOP ) { slP >> @@n@@ ; idArgNext ++ ; }\r\n"
    "    @@t@@ @@n@@@@a@@ ;\r\n"
const osTextT postArgT[] =

const osTextT postIndent[] = "    " ;

const osTextT postFooter[] = "}\r\n" ;

const osTextT postFooter2[] = "    if( ((tin9S&)tinBaseP).fingerprint && _psttNameP && slP ) ;\r\n" ;

;
    "    ZE( countT , cbFieldNext ) ;\r\n"
    "    ZE( flagsT , flagsNext ) ;\r\n"
    "    ZE( countT , idTypeNext ) ;\r\n"
    "    ZE( byteT* , pbFieldNext ) ;\r\n"
    "    countT idArgNext = 1 ;\r\n"
    "{\r\n"
    "\r\nvoidT @@f@@( tin0S& tinBaseP , etherC& etherP , soulC& slP , const strokeS* const _psttNameP )\r\n"
const osTextT postHeader[] =

const osTextT postProto[] = "\r\nvoidT @@f@@( tin0S& tinBaseP , etherC& etherP , soulC& slP , const strokeS* const _psttNameP ) ;\r\n" ;

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_SOIXLoLDwORDdEFS.tool.genSoixlOldWordDefs" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

