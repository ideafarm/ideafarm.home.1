
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    //}
    //    ether.traceF( tin0P , T("literal:    \"")+T(ppostLiteral[offLit])+T("\"") ) ;
    //{
    //for( offLit = 0 ; offLit < sizeof ppostLiteral / sizeof ppostLiteral[ 0 ] && ppostLiteral[ offLit ] ; offLit ++ )

    }
        }
            if( offLit >= sizeof ppostLiteral / sizeof ppostLiteral[ 0 ] ) break ;
            offo = 0 ;
            offLit ++ ; 
        {
        if( bFlush && offo )

        }
            }
                break ;
                if( bSuppress ) bSuppress = 0 ;
            {
            default :
            }
                break ;
                bSuppress = 1 ;
            {
            case sc_ccSSSrEPEAT :
            }
                break ;
                }
                    }
                        break ;
                        idLevel -- ;
                    {
                    case sa_SSSoReND  :
                    case sa_SSSaNDeND :
                    }
                        break ;
                        idLevel ++ ;
                    {
                    case sa_SSSoR  :
                    case sa_SSSaND :
                {
                switch( psttPattern[ CSpREFIX - 1 + ids ].idAdam )
                if( bSuppress ) bSuppress = 0 ;
            {
            case sc_ccSSS :
            }
                break ;

                }
                    }
                        ppostLiteral[ offLit ][ offo ++ ] = (osTextT)psttPattern[ CSpREFIX - 1 + ids ].idAdam ;

                        }
                            offo = 0 ;
                            thirdC::c_memsetIF( tin0P      , ppostLiteral[ offLit ] , psttPattern->idAdam + 1 ) ;
                            etherP.newF(        tin0P , LF , ppostLiteral[ offLit ] , psttPattern->idAdam + 1 ) ; ___( ppostLiteral[ offLit ] ) ;
                        {
                        if( !ppostLiteral[ offLit ] )
                        bFlush = 0 ;

                        else if( ids == psttPattern->idAdam - 1 ) flagsLiterals |= flPATTERNlITERALS_LITERALeNDING    ;
                             if( ids == 2                       ) flagsLiterals |= flPATTERNlITERALS_LITERALbEGINNING ;
                    {
                    else
                    if( bSuppress ) bSuppress = 0 ;
                {
                if( idLevel == 1 )
            {
            case sc_cALPHABET1 :
        {
        switch( psttPattern[ CSpREFIX - 1 + ids ].idCaste )
        boolT bFlush = 1 ;
    {
    for( countT ids = 1 ; ids <= psttPattern->idAdam ; ids ++ )
    ZE( boolT  , bSuppress ) ;
    ZE( countT , idLevel   ) ;
    ZE( countT , offo      ) ;
    ZE( countT , offLit    ) ;

    __NZ( psttPattern[ CSpREFIX ].idAdam  - sa_SSSaND ) ;   // (LITERAL STROKES ARE ACCUMULATED ONLY WHEN idLevel == 1)
    __NZ( psttPattern[ CSpREFIX ].idCaste - sc_ccSSS  ) ;   // THE FOLLOWING CODE ASSUMES THAT psttPattern IS A CONFORMANT IPDOS (TM) PATTERN, WHICH MUST BEGIN WITH sa_SSSaND

    thirdC::c_memsetIF( tin0P , (byteT*)ppostLiteral , sizeof ppostLiteral ) ;

    //ether.delF( tin0P , psttd ) ;
    //ether.traceF( tin0P , T("[pattern]:    ")+T(psttd) ) ;
    //ether.strDumpStrokesIF( tin0P , psttd , psttPattern , 0 ) ; ___( psttd ) ;
    //ZE( strokeS* , psttd ) ;

    }
        default                                               : { BLAMMO ; break ; }
        case ifcIDtYPEpATTERN_FOREIGNuNIXrEGULAReXPRESSION    : { BLAMMO ; break ; }  //U:: MARKUP THAT EXACTLY SIMULATES UNIX REGULAR EXPRESSION SEMANTICS AND SYNTAX
        case ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT           : { ether.strPatternFromWildcardsStrictF(    tin0P , psttPattern , flagsOptimize , pFlagsOverride , pcMinOverride , pcMaxOverride , psttP ) ; ___( psttPattern ) ; ___( pFlagsOverride ) ; ___( pcMinOverride ) ; ___( pcMaxOverride ) ; ; break ; }
        case ifcIDtYPEpATTERN_FOREIGNwILDCARDmICROSOFT        : { ether.strPatternFromWildcardsMicrosoftF( tin0P , psttPattern , flagsOptimize , pFlagsOverride , pcMinOverride , pcMaxOverride , psttP ) ; ___( psttPattern ) ; ___( pFlagsOverride ) ; ___( pcMinOverride ) ; ___( pcMaxOverride ) ; ; break ; }
        case ifcIDtYPEpATTERN_NATIVE                          : { BLAMMO ; break ; }  //U:: MARKUP FOR PLAIN TEXT STRING THAT IS A THIN WRAP OF THE UNDERLYING sa_SSS CONSTANTS: sp_SSSfLAG sa_SSS
        case ifcIDtYPEpATTERN_LITERAL                         : { ether.strMakeF( tin0P , LF , psttPattern , psttP ) ; ___( psttPattern ) ; break ; }    //20230207@1254: ADDED W/O ANALYSIS
    {
    switch( idTypeP )

    //U:: MIGRATE flPATTERNc FROM FLAGS TO AN IDtYPE
    //U:: CONSIDER WHETHER SHOULD USE flagsP OR idTypeP : IS THERE ANY BENEFIT FROM SUPPORTING MULTIPLE MAPPINGS (I.E. SUPPORTING THE SETTING OF MORE THAN ONE FLAG).  WOULD I EVER WANT TO USE BOTH UNIX REGULAR EXPRESSIONS AND MICROSOFT WILDCARDS?  PROBABLY NOT

    }
        if( POOP ) return ;
        __Z( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    thirdC::c_memsetIF( (byteT*)ppostLiteral , sizeof ppostLiteral ) ;
{
flagsLiterals( flPATTERNlITERALS_null )
pcMaxOverride( 0 ) ,
pcMinOverride( 0 ) ,
pFlagsOverride( 0 ) ,
flagsOptimize( 0 ) ,
psttPattern( 0 ) ,
ether( etherP ) ,
/*1*/patternC::patternC( tin0S& tin0P , etherC& etherP , const strokeS* const psttP , const countT idTypeP ) :/*1*/

/**/
*/
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

