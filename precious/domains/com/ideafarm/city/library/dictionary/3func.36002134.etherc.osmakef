
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    /**/traceF( tin0P , T("osMakeF / -") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
    delF( tin0P , psttHome ) ;
    //bHost.ungrabF( tin0P ) ;
    THREADmODE1rESTORE

    }
        /**/traceF( tin0P , T("osMakeF / 0") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        osMakeHoverFileF( tin0P , idAdamP ) ;
        /**/traceF( tin0P , T("osMakeF / 1") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        //}
        //    FORsTRINGSiNsPANNEDcOMBINEDtAIL1
        //    }
        //        diskFileOrDirDeleteF( tin0P , psttc1 ) ;
        //    {
        //    FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
        //    boxMenuF( tin0P , soul1m , tLongObjLike ) ;
        //    soulC soul1m( tin0P , *this , TAG( TAGiDnULL ) ) ;
        //{
        //20251108@1254: KEEP THE OBJ FILES SO THAT THEY CAN BE USED TO BUILD STATIC LIBRARIES AND EXECUTABLES

        }
            thirdC::c_systemIF( tin0P , T("wlib -p=32 -q -n -b ")+tShortLib+T(" +")+tShortDll ) ;
            hoverC hover( tin0P , *this , tPathMaster ) ;
        {

        delF( tin0P , postDescription ) ;
        third.osLinkF( tin0P , osFileNameC( tin0P , third , tLongDll ) , osFileNameC( tin0P , third , tLongObjLike ) , flagsP , osFileNameC( tin0P , third , tLongLibBase ) , postDescription ) ;
        TN( tLongLibBase , "" ) ; tLongLibBase = T(psttHome)+T("ephemeral/city/park/exedll/1/master/ideafarm.81000001.ipdos-wl") ;
        TN( tLongObjLike , "" ) ; tLongObjLike = T(psttHome)+T("ephemeral/city/workshop/3object.dll/")+tIdiForeign+T(".*.obj") ;

        postDescription[ 0 ] = '!' ;
        strMakeF( tin0P , LF , postDescription , T("?ifcExeDllDescBegin !cName ")+tIdi+T(" !idCopy ")+TF3(idCopyLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(" !contact http://ideafarm.com IdeaFarm " "(tm) Piggyback Distributed Operating System (c) Wo Of Ideafarm all rights reserved !ifcExeDllDescEnd") ) ; ___( postDescription ) ;
        ZE( osTextT* , postDescription ) ;

        grabOsMake.ungrabF( tin0P ) ;
        }
            }
                idCopyLath = 1 + incv02AM( *(countT*)pbi ) ;

                //if( idCopyLath < idCopyHW ) idCopyLath = idCopyHW ;
                //countT idCopyHW = mm.idCopyHighWaterF() ;
                //masterOldC mm( tin0P , *this , TAG( TAGiDnULL ) ) ;
                //20210825@1356: REMOVED THIS FOR SPEED AND FOR THREAD SAFETY ; CONJ: NOT NEEDED
            {
            if( pbi && cbi == sizeof( countT ) )
            fwsLath.getF( tin0P , pbi , cbi , sizeof( countT ) ) ;
            ZE( countT , cbi ) ;
            ZE( byteT* , pbi ) ;
            fileWindowsC fwsLath( tin0P , *this , tName , flFILEwINDOW_WRITE ) ;
            TN( tName , "///ideafarm/ephemeral/ipdos/idCopyLath" ) ;
        {
        grabOsMake.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        ZE( countT , idCopyLath ) ;
        //CS:CODEsYNC: PSEUDOdUPLICATE 33002111 33002134

        //if( diskFileExistsF( tin0P , tLongLib ) ) diskFileOrDirDeleteF( tin0P , tLongLib ) ;
        //if( diskFileExistsF( tin0P , tLongDll ) ) diskFileOrDirDeleteF( tin0P , tLongDll ) ;
        //20251108@1245: KEEP THE OBJECT FILES SO THAT THEY CAN BE USED TO BUILD STATIC LIBRARIES AND BENCH EXECUTABLES

        diskMakeDirIfNeededF( tin0P , tLongDll ) ;
        TN( tLongLib    , "" ) ; tLongLib    = tPathMaster+tShortLib ;
        TN( tLongDll    , "" ) ; tLongDll    = tPathMaster+tShortDll ;
        TN( tPathMaster , "" ) ; tPathMaster = T(psttHome)+T("ephemeral/city/park/exedll/1/master/") ;
        TN( tShortLib   , "" ) ; tShortLib   = T("ideafarm.")+tIdiForeign+T(".ipdos-wl") ;
        TN( tShortDll   , "" ) ; tShortDll   = T("ideafarm.")+tIdiForeign+T(".ipdos-wm") ;
        /**/traceF( tin0P , T("osMakeF / 2") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
    {
    if( !bErrorsAll )
    // MAKE THE DLL

    }
        /**/traceF( tin0P , T("osMakeF / 3") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        }
            break ;

            }
                }
                    stErrorsP << ps ;
                    *ps << (strokeS*)T("compilation failed, but the compiler did not identify an offending code line") ;
                    *ps << (strokeS*)0 ;
                    *ps << 0U ;
                    *ps << 0U ;
                {
                if( ps )
                soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) ) ; ___( ps ) ;
            {
            if( !stErrorsP )
    
            }
                delF( tin0P , psttl ) ;
                }
                    }
                        }
                            stErrorsP << ps ;
    
                            delF( tin0P , psttNote ) ;
                            delF( tin0P , psttLine ) ;
                            *ps << psttNote ;
                            *ps << psttLine ;
                            *ps << idColumn ;
                            *ps << idLine ;
    
                            if( !psttNote ) { strMakeF( tin0P , LF , psttNote , psttl ) ; ___( psttNote ) ; }
                            if( idf2      ) { strSubstringF( tin0P , psttNote , idf2 , idl2 , psttl ) ; ___( psttNote ) ; }
                            if( idf2      ) { strIdF( tin0P , 0 , flSTRmATCH_null , idf2 , sttq2 , tColon , psttl ) ; }
                            strIdF( tin0P , 0 , flSTRmATCH_null , idf2 , sttq2 , tColon , psttl ) ;
                            //sttq2 = ze ;
                            idl2 = 0 ;
                            idf2 = 1 ;
    
                            }
                                strSubstringLineF( tin0P , psttLine , idf2 , sttq2 , tSrcBody , idLine ) ; ___( psttLine ) ;
                                //sttq2 = ze ;
                                idf2 = 1 ;
                            {
                            if( idLine )
    
                            delF( tin0P , psttw ) ;
                            if( psttw ) idColumn = strDigitsToSCountF( tin0P , psttw , 0xa , 1 ) ;
                            strSubstringF( tin0P , psttw , idf2 , sttq2 , S1C(')') , psttl ) ; ___( psttw ) ;
    
                            delF( tin0P , psttw ) ;
                            if( psttw ) idLine = strDigitsToSCountF( tin0P , psttw , 0xa , 1 ) ;
                            strSubstringF( tin0P , psttw , idf2 , sttq2 , S1C(',') , psttl ) ; ___( psttw ) ;
                            //sttq2 = ze ;
                            idf2 = 2 ;
    
                            ZE( strokeS* , psttw ) ;
                            ZE( strokeS* , psttNote ) ;
                            ZE( strokeS* , psttLine ) ;
                            ZE( countT , idColumn ) ;
                            ZE( countT , idLine ) ;
                        {
                        if( ps )
                        soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) ) ; ___( ps ) ;
                    {
                    if( 1 == strIdF( tin0P , idf2 , sttq2 , S1C('(') , psttl ) )
                    //sttq2 = ze ;
                    idf2 = 1 ;
                {
                if( 1 != strIdF( tin0P , 0 , flSTRmATCH_null , idf2 , sttq2 , tFile , psttl ) )
                strokeS sttq2( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( countT , idl2 ) ;
                countT idf2 = 1 ;
    
                if( !psttl ) break ;
                strSubstringLineF( tin0P , psttl , idf , sttq , tErrBody ) ; ___( psttl ) ;
            {
            while( !POOP && idf )
            TN( tColon , ": " ) ;
            TN( tFile , "File: " ) ;
            ZE( strokeS* , psttl ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
    
            }
                delF( tin0P , posti ) ;
                tSrcBody = T(posti) ;
                boxGetShadowF( tin0P , posti , costi , tSrc ) ; ___( posti ) ;
                ZE( countT   , costi ) ;
                ZE( osTextT* , posti ) ;
    
                delF( tin0P , poste ) ;
                tErrBody = T(poste) ;
                boxGetShadowF( tin0P , poste , coste , tErr , 1 ) ; ___( poste ) ;
                ZE( countT   , coste ) ;
                ZE( osTextT* , poste ) ;
            {
            TN( tErrBody , "" ) ;
            TN( tSrcBody , "" ) ;

            bErrorsAll |= 1 ;
        {
        if( bErrors )

        }
            if( !bExe ) third.osCompileF( tin0P , bErrors , osFileNameC( tin0P , third ,        tObjForExe              ) , osFileNameC( tin0P , third , tErr ) , osFileNameC( tin0P , third , tSrc ) , flagsP | flMAKE_EXE ) ;
                        third.osCompileF( tin0P , bErrors , osFileNameC( tin0P , third , bExe ? tObjForExe : tObjForDll ) , osFileNameC( tin0P , third , tErr ) , osFileNameC( tin0P , third , tSrc ) , flagsP              ) ;
            boolT bExe = F(flagsP) & flMAKE_EXE || F(flagsP) & flMAKE_EXEwIN ;
        {
        ZE( boolT , bErrors ) ;

        if( diskFileExistsF( tin0P , tErr ) ) diskFileOrDirDeleteF( tin0P , tErr ) ;
        if( diskFileExistsF( tin0P , tObjForDll ) ) diskFileOrDirDeleteF( tin0P , tObjForDll ) ;
        diskMakeDirIfNeededF( tin0P , tErr ) ;
        diskMakeDirIfNeededF( tin0P , tObjForExe ) ;
        diskMakeDirIfNeededF( tin0P , tObjForDll ) ;

        TN( tErr       , "" ) ; tErr       = T(psttHome)+T("ephemeral/city/workshop/4report/"    )+tIdiForeign+tDot+tIdModule+T(".err") ;
        TN( tObjForExe , "" ) ; tObjForExe = T(psttHome)+T("ephemeral/city/workshop/3object.exe/")+tIdiForeign+tDot+tIdModule+T(".obj") ;
        TN( tObjForDll , "" ) ; tObjForDll = T(psttHome)+T("ephemeral/city/workshop/3object.dll/")+tIdiForeign+tDot+tIdModule+T(".obj") ;
        TN( tSrc       , "" ) ; tSrc       = T(psttHome)+T("ephemeral/city/workshop/2source/"    )+tIdiForeign+tDot+tIdModule+T(".cpp") ;
    
        }
            delF( tin0P , psttIdModule ) ;
            tIdModule = T(psttIdModule) ;
            st_psttIdModule >> psttIdModule ;
            ZE( strokeS* , psttIdModule ) ;
        {
        TN( tIdModule , "" ) ;
        /**/traceF( tin0P , T("osMakeF / 4") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
    {
    while( st_psttIdModule )
    ZE( boolT , bErrorsAll ) ;
    // MAKE THE OBJECT MODULES

    }
        FORsTRINGSiNsPANNEDcOMBINEDtAIL1
        }
            }
                writeLineSnipF( tin0P , *this , tIdiForeign , tIdModule , tDefBody ) ;
    
                }
                    delF( tin0P , postp ) ;
                    fileWriteF( tin0P , hFile1 , postp , costp ) ;
                    countT costp = strMakeF( tin0P , LF , postp , tTail ) ; ___( postp ) ;
                    ZE( osTextT* , postp ) ;
                {

                }
                    delF( tin0P , postp ) ;
                    fileWriteF( tin0P , hFile1 , postp , costp ) ;

                    delF( tin0P , psttp ) ;
                    countT costp = strMakeF( tin0P , LF , postp , psttp ) ; ___( postp ) ;
                    ZE( osTextT* , postp ) ;

                    soulr >> psttp ; ___( psttp ) ;
                    ZE( strokeS* , psttp ) ;
                {
                while( soulr )

                }
                    delF( tin0P , postp ) ;
                    fileWriteF( tin0P , hFile1 , postp , costp ) ;
                    //LOGrAW( "\r\n-------- END ------------------\r\n" ) ;
                    //LOGrAW( postp ) ;
                    //LOGrAW( "\r\n-------- BEGIN ------------------\r\n" ) ;
                    countT costp = strMakeF( tin0P , LF , postp , tHead ) ; ___( postp ) ;
                    ZE( osTextT* , postp ) ;
                {

                tTail += T("//SOURCE: 5adam.")+tIdiForeign+tDot+tIdModule+T(" END\r\n") ;

                ) ;

                    "#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\1snip.")+tIdiForeign+tDot+tIdModule+T(".ClINESiNdEF\"\r\n"
                    
                tHead += T(

                else tHead += T("#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.adam.hide.third.1.h\"\r\n#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.adam.hide.third.2.h\"\r\n") ;
                }
                    tTail += T("#undef ifcENABLEtHIRDpARTIES\r\n") ;

                    ) ;
                        "#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\1snip.1e000001.omittedWindowsHeaders.h\"\r\n"
                        "#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\1snip.01000002.cnotcppheader.h\"\r\n"
                        "#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.adam.show.third.2.h\"\r\n"
                        "#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.adam.show.third.1.h\"\r\n"
                        "#define ifcENABLEtHIRDpARTIES\r\n"
                    tHead += T(
                {
                if( F(flagsP) & flMAKE_ENABLEtHIRDpARTIES )

                ) ;

                    "#undef postADAMhEADER\r\n"
                    "#undef IDFILE\r\n"
                    "#undef DDNAME\r\n"
                    "#undef DDNUMB\r\n"
                    "\r\n"

                TN( tTail , "" ) ; tTail = T(

                ) ;

                    "#define postADAMhEADER \"")+tIdiForeign+T(".h\"\r\n"
                    "#define IDFILE (countT)0x0\r\n"
                    "#define DDNUMB 0x")+tIdiForeign+T("\r\n"
                    "#define DDNAME \"5adam.")+tIdiForeign+tDot+tIdModule+T("\"\r\n"
                    "//SOURCE: 5adam.")+tIdiForeign+tDot+tIdModule+T(" BEGIN\r\n"

                TN( tHead , "" ) ; tHead = T(

                fileOpenF( tin0P , hFile1 , countTC() , tSrc , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
                handleC hFile1( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;                                                                                          \
                if( diskFileExistsF( tin0P , tSrc ) ) diskFileOrDirDeleteF( tin0P , tSrc ) ;
                tSrc = T(psttHome)+T("ephemeral/city/workshop/2source/")+tIdiForeign+tDot+tIdModule+T(".cpp") ;
    
                st_psttIdModule << psttIdModule ; psttIdModule = 0 ;
                TN( tIdModule , "" ) ; tIdModule = T(psttIdModule) ;
            {
            else
            }
                }
                    delF( tin0P , postp ) ;
                    fileWriteF( tin0P , hFile1 , postp , costp ) ;

                    delF( tin0P , psttp ) ;
                    countT costp = strMakeF( tin0P , LF , postp , psttp ) ; ___( postp ) ;
                    ZE( osTextT* , postp ) ;

                    soulr >> psttp ; ___( psttp ) ;
                    ZE( strokeS* , psttp ) ;
                {
                while( soulr )

                fileOpenF( tin0P , hFile1 , countTC() , tSrc , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
                handleC hFile1( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;                                                                                          \
                tSrc = T(psttHome)+T("ephemeral/city/workshop/2source/")+tIdiForeign+T(".h") ;

                delF( tin0P , psttIdModule ) ;
            {
            if( !strCompareF( tin0P , psttIdModule , tH ) )
            TN( tSrc , "" ) ;
    
            __NZ( psttRev ) ;
            strReverseF( tin0P , psttRev , tDefBody , T("\r\n") , &soulr ) ; ___( psttRev ) ;
            soulC soulr( tin0P , *this , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;
            ZE( strokeS* , psttRev ) ;

            strWordF( tin0P , psttIdModule , psttc1 , sttq , strokeS('.') , - 1 ) ; ___( psttIdModule ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , psttIdModule ) ;
    
            }
                delF( tin0P , postd ) ;
                tDefBody = T(postd) ;
                boxGetShadowF( tin0P , postd , costd , psttc1 ) ; ___( postd ) ;
                ZE( countT   , costd ) ;
                ZE( osTextT* , postd ) ;
            {
            TN( tDefBody , "" ) ;
            /**/traceF( tin0P , T("osMakeF / 5") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        {
        FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
        /**/traceF( tin0P , T("osMakeF / 6") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        boxMenuF( tin0P , soul1m , T(psttHome)+T("precious/domains/com/ideafarm/city/library/dictionary/5adam.")+tIdiForeign+T(".*") ) ;

        /**/traceF( tin0P , T("osMakeF / 7") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        soulC soul1m( tin0P , *this , TAG( TAGiDnULL ) ) ;
    {
    stackC st_psttIdModule( tin0P , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO|flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
    // MAKE THE SOURCE FILES
    /**/traceF( tin0P , T("osMakeF / 8") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)

    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

    //batonC bHost( tin0P , TAG( TAGiDnULL ) , T("masterOldC") , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_GRABBED | flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) ; // A HOST BATON WITH THE SAME NAME IS ALSO USED BY masterOldC
    //20210825@1453: CONJ: NO LONGER NEED TOSERIALIZE

    /**/traceF( tin0P , T("osMakeF / 9") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)

    TN( tIdiForeign , "" ) ; tIdiForeign = TF3(idAdamP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ;
    TN( tIdi        , "" ) ; tIdi        = TF3(idAdamP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE                 ,8) ;
    TN( tCpp , "cpp" ) ;
    TN( tH   , "h"   ) ;
    TN( tDot , "."   ) ;
    /**/traceF( tin0P , T("osMakeF / a") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)

    diskMapFileNameF( tin0P , psttHome , T("///ideafarm/") ) ; //THIS LINE "HARDCODES" psttHome SO THAT I CAN BE RUN ON ifc21 USING THE DEFINITION FILES ON ifc11
    ZE( strokeS* , psttHome ) ;
    /**/traceF( tin0P , T("osMakeF / +") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)

    _IO_

    }
        if( POOP ) return ;
        FV( flMAKE , flagsP ) ;
        __Z( idAdamP ) ;
        __NZ( stErrorsP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::osMakeF( tin0S& tin0P , stackC& stErrorsP , const countT idAdamP , const flagsT flagsP )/*1*/

/**/
*/
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001015f.flMAKE!||
 flagsP
    in this case, the caller must explicitly d elete all removed soulC objects
   alt: remove some or all plates
    in this case, the soulC objects will be d eleted when stErrorsP is destroyed
   alt: just inspect the number of plates without removing any plates from stErrorsP
  after i return, the caller can process stErrorsP in wo of these ways
    is guaranteed to be nonze
   strokeS* psttNote
    might be 0, but will usually be nonze
   strokeS* psttLine
    might be 0, but will usually be nonze
   countT idColumn
    might be 0, but will usually be nonze
   countT idLine
  after i return, each soulC object (if any) on stErrorsP contains the following elements
  must be empty
  must be of type ifcSTACKtYPE_PTR_soulC
 stErrorsP
 tin0P
arguments
the caller can assume that compile and link completed aok if stErrorsP has no plates
impotence does not occur when i cannot compile or link
i prepare the final source code, compile and link it, and report errors, if any
\<A HREF=\"5.1030175.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$osMakeF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

