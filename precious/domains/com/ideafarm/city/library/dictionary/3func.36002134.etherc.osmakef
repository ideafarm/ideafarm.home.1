
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    /**/traceF( tinBaseP , T("osMakeF / -") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
    delF( tinBaseP , psttHome ) ;
    //bHost.ungrabF( tinBaseP ) ;
    THREADmODE2rESTORE

    }
        /**/traceF( tinBaseP , T("osMakeF / 0") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        osMakeHoverFileF( tinBaseP , idAdamP ) ;
        /**/traceF( tinBaseP , T("osMakeF / 1") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        }
            FORsTRINGSiNsPANNEDcOMBINEDtAIL1
            }
                diskFileOrDirDeleteF( tinBaseP , psttc1 ) ;
            {
            FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
            boxMenuF( tinBaseP , soul1m , tObjLike ) ;
            soulC soul1m( tinBaseP , TAG( TAGiDnULL ) ) ;
        {
        delF( tinBaseP , postDescription ) ;
        third.osLinkF( tinBaseP , osFileNameC( tinBaseP , third , tDll ) , osFileNameC( tinBaseP , third , tObjLike ) , flagsP , osFileNameC( tinBaseP , third , tLib ) , postDescription ) ;
        TN( tLib , "" ) ; tLib = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/park/exedll/1/master/ideafarm.81000001.ipdos-wl") ;
        TN( tObjLike , "" ) ; tObjLike = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/workshop/3object/")+tIdiForeign+T(".*.obj") ;

        postDescription[ 0 ] = '!' ;
        strMakeF( tinBaseP , LF , postDescription , T("?ifcExeDllDescBegin !cName ")+tIdi+T(" !idCopy ")+TF3(idCopyLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(" !contact http://ideafarm.com IdeaFarm " "(tm) Piggyback Distributed Operating System (c) Wo Of Ideafarm all rights reserved !ifcExeDllDescEnd") ) ; ___( postDescription ) ;
        ZE( osTextT* , postDescription ) ;

//U:: TO FIND A BUG        grabOsMake.ungrabF( tinBaseP ) ;
        }
            }
                idCopyLath = 1 + incv02AM( *(countT*)pbi ) ;

                //if( idCopyLath < idCopyHW ) idCopyLath = idCopyHW ;
                //countT idCopyHW = mm.idCopyHighWaterF() ;
                //masterOldC mm( tinBaseP , *this , TAG( TAGiDnULL ) ) ;
                //20210825@1356: REMOVED THIS FOR SPEED AND FOR THREAD SAFETY ; CONJ: NOT NEEDED
            {
            if( pbi && cbi == sizeof( countT ) )
            fwsLath.getF( tinBaseP , pbi , cbi , sizeof( countT ) ) ;
            ZE( countT , cbi ) ;
            ZE( byteT* , pbi ) ;
            fileWindowsC fwsLath( tinBaseP , *this , tName , flFILEwINDOW_WRITE ) ;
            TN( tName , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/idCopyLath" ) ;
        {
//U:: TO FIND A BUG        grabOsMake.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        ZE( countT , idCopyLath ) ;
        //CS:CODEsYNC: PSEUDOdUPLICATE 33002111 33002134

        if( diskFileExistsF( tinBaseP , tDll ) ) diskFileOrDirDeleteF( tinBaseP , tDll ) ;
        diskMakeDirIfNeededF( tinBaseP , tDll ) ;
        TN( tDll , "" ) ; tDll = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/park/exedll/1/master/ideafarm.")+tIdiForeign+T(".ipdos-wm") ;
        /**/traceF( tinBaseP , T("osMakeF / 2") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
    {
    if( !bErrorsAll )
    // MAKE THE DLL

    }
        /**/traceF( tinBaseP , T("osMakeF / 3") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        }
            break ;

            }
                }
                    stErrorsP << ps ;
                    *ps << (strokeS*)T("compilation failed, but the compiler did not identify an offending code line") ;
                    *ps << (strokeS*)0 ;
                    *ps << 0U ;
                    *ps << 0U ;
                {
                if( ps )
                soulC* ps = new( 0 , tinBaseP , LF ) soulC( tinBaseP , TAG( TAGiDnULL ) ) ; ___( ps ) ;
            {
            if( !stErrorsP )
    
            }
                delF( tinBaseP , psttl ) ;
                }
                    }
                        }
                            stErrorsP << ps ;
    
                            delF( tinBaseP , psttNote ) ;
                            delF( tinBaseP , psttLine ) ;
                            *ps << psttNote ;
                            *ps << psttLine ;
                            *ps << idColumn ;
                            *ps << idLine ;
    
                            if( !psttNote ) { strMakeF( tinBaseP , LF , psttNote , psttl ) ; ___( psttNote ) ; }
                            if( idf2      ) { strSubstringF( tinBaseP , psttNote , idf2 , idl2 , psttl ) ; ___( psttNote ) ; }
                            if( idf2      ) { strIdF( tinBaseP , 0 , flSTRmATCH_null , idf2 , sttq2 , tColon , psttl ) ; }
                            strIdF( tinBaseP , 0 , flSTRmATCH_null , idf2 , sttq2 , tColon , psttl ) ;
                            //sttq2 = ze ;
                            idl2 = 0 ;
                            idf2 = 1 ;
    
                            }
                                strSubstringLineF( tinBaseP , psttLine , idf2 , sttq2 , tSrcBody , idLine ) ; ___( psttLine ) ;
                                //sttq2 = ze ;
                                idf2 = 1 ;
                            {
                            if( idLine )
    
                            delF( tinBaseP , psttw ) ;
                            if( psttw ) idColumn = strDigitsToSCountF( tinBaseP , psttw , 0xa , 1 ) ;
                            strSubstringF( tinBaseP , psttw , idf2 , sttq2 , S1C(')') , psttl ) ; ___( psttw ) ;
    
                            delF( tinBaseP , psttw ) ;
                            if( psttw ) idLine = strDigitsToSCountF( tinBaseP , psttw , 0xa , 1 ) ;
                            strSubstringF( tinBaseP , psttw , idf2 , sttq2 , S1C(',') , psttl ) ; ___( psttw ) ;
                            //sttq2 = ze ;
                            idf2 = 2 ;
    
                            ZE( strokeS* , psttw ) ;
                            ZE( strokeS* , psttNote ) ;
                            ZE( strokeS* , psttLine ) ;
                            ZE( countT , idColumn ) ;
                            ZE( countT , idLine ) ;
                        {
                        if( ps )
                        soulC* ps = new( 0 , tinBaseP , LF ) soulC( tinBaseP , TAG( TAGiDnULL ) ) ; ___( ps ) ;
                    {
                    if( 1 == strIdF( tinBaseP , idf2 , sttq2 , S1C('(') , psttl ) )
                    //sttq2 = ze ;
                    idf2 = 1 ;
                {
                if( 1 != strIdF( tinBaseP , 0 , flSTRmATCH_null , idf2 , sttq2 , tFile , psttl ) )
                strokeS sttq2( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( countT , idl2 ) ;
                countT idf2 = 1 ;
    
                if( !psttl ) break ;
                strSubstringLineF( tinBaseP , psttl , idf , sttq , tErrBody ) ; ___( psttl ) ;
            {
            while( !POOP && idf )
            TN( tColon , ": " ) ;
            TN( tFile , "File: " ) ;
            ZE( strokeS* , psttl ) ;
            strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
    
            }
                delF( tinBaseP , posti ) ;
                tSrcBody = T(posti) ;
                boxGetShadowF( tinBaseP , posti , costi , tSrc ) ; ___( posti ) ;
                ZE( countT   , costi ) ;
                ZE( osTextT* , posti ) ;
    
                delF( tinBaseP , poste ) ;
                tErrBody = T(poste) ;
                boxGetShadowF( tinBaseP , poste , coste , tErr , 1 ) ; ___( poste ) ;
                ZE( countT   , coste ) ;
                ZE( osTextT* , poste ) ;
            {
            TN( tErrBody , "" ) ;
            TN( tSrcBody , "" ) ;

            bErrorsAll |= 1 ;
        {
        if( bErrors )

        third.osCompileF( tinBaseP , bErrors , osFileNameC( tinBaseP , third , tObj ) , osFileNameC( tinBaseP , third , tErr ) , osFileNameC( tinBaseP , third , tSrc ) , flagsP ) ;
        ZE( boolT , bErrors ) ;

        if( diskFileExistsF( tinBaseP , tErr ) ) diskFileOrDirDeleteF( tinBaseP , tErr ) ;
        if( diskFileExistsF( tinBaseP , tObj ) ) diskFileOrDirDeleteF( tinBaseP , tObj ) ;
        diskMakeDirIfNeededF( tinBaseP , tErr ) ;
        diskMakeDirIfNeededF( tinBaseP , tObj ) ;

        TN( tErr , "" ) ; tErr = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/workshop/4report/")+tIdiForeign+tDot+tIdModule+T(".err") ;
        TN( tObj , "" ) ; tObj = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/workshop/3object/")+tIdiForeign+tDot+tIdModule+T(".obj") ;
        TN( tSrc , "" ) ; tSrc = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/workshop/2source/")+tIdiForeign+tDot+tIdModule+T(".cpp") ;
    
        }
            delF( tinBaseP , psttIdModule ) ;
            tIdModule = T(psttIdModule) ;
            st_psttIdModule >> psttIdModule ;
            ZE( strokeS* , psttIdModule ) ;
        {
        TN( tIdModule , "" ) ;
        /**/traceF( tinBaseP , T("osMakeF / 4") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
    {
    while( st_psttIdModule )
    ZE( boolT , bErrorsAll ) ;
    // MAKE THE OBJECT MODULES

    }
        FORsTRINGSiNsPANNEDcOMBINEDtAIL1
        }
            }
                writeLineSnipF( tinBaseP , *this , tIdiForeign , tIdModule , tDefBody ) ;
    
                }
                    delF( tinBaseP , postp ) ;
                    fileWriteF( tinBaseP , hFile1 , postp , costp ) ;
                    countT costp = strMakeF( tinBaseP , LF , postp , tTail ) ; ___( postp ) ;
                    ZE( osTextT* , postp ) ;
                {

                }
                    delF( tinBaseP , postp ) ;
                    fileWriteF( tinBaseP , hFile1 , postp , costp ) ;

                    delF( tinBaseP , psttp ) ;
                    countT costp = strMakeF( tinBaseP , LF , postp , psttp ) ; ___( postp ) ;
                    ZE( osTextT* , postp ) ;

                    soulr >> psttp ; ___( psttp ) ;
                    ZE( strokeS* , psttp ) ;
                {
                while( soulr )

                }
                    delF( tinBaseP , postp ) ;
                    fileWriteF( tinBaseP , hFile1 , postp , costp ) ;
                    //LOGrAW( "\r\n-------- END ------------------\r\n" ) ;
                    //LOGrAW( postp ) ;
                    //LOGrAW( "\r\n-------- BEGIN ------------------\r\n" ) ;
                    countT costp = strMakeF( tinBaseP , LF , postp , tHead ) ; ___( postp ) ;
                    ZE( osTextT* , postp ) ;
                {

                tTail += T("//SOURCE: 5adam.")+tIdiForeign+tDot+tIdModule+T(" END\r\n") ;

                ) ;

                    "#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\1snip.")+tIdiForeign+tDot+tIdModule+T(".ClINESiNdEF\"\r\n"
                    
                tHead += T(

                else tHead += T("#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.adam.hide.third.1.h\"\r\n#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.adam.hide.third.2.h\"\r\n") ;
                }
                    tTail += T("#undef ifcENABLEtHIRDpARTIES\r\n") ;

                    ) ;
                        "#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\1snip.01000002.cnotcppheader.h\"\r\n"
                        "#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.adam.show.third.2.h\"\r\n"
                        "#include \"\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\library\\snip\\ipdos.adam.show.third.1.h\"\r\n"
                        "#define ifcENABLEtHIRDpARTIES\r\n"
                    tHead += T(
                {
                if( F(flagsP) & flMAKE_ENABLEtHIRDpARTIES )

                ) ;

                    "#undef postADAMhEADER\r\n"
                    "#undef IDFILE\r\n"
                    "#undef DDNAME\r\n"
                    "#undef DDNUMB\r\n"
                    "\r\n"

                TN( tTail , "" ) ; tTail = T(

                ) ;

                    "#define postADAMhEADER \"")+tIdiForeign+T(".h\"\r\n"
                    "#define IDFILE (countT)0x0\r\n"
                    "#define DDNUMB 0x")+tIdiForeign+T("\r\n"
                    "#define DDNAME \"5adam.")+tIdiForeign+tDot+tIdModule+T("\"\r\n"
                    "//SOURCE: 5adam.")+tIdiForeign+tDot+tIdModule+T(" BEGIN\r\n"

                TN( tHead , "" ) ; tHead = T(

                fileOpenF( tinBaseP , hFile1 , countTC() , tSrc , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
                handleC hFile1( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;                                                                                          \
                if( diskFileExistsF( tinBaseP , tSrc ) ) diskFileOrDirDeleteF( tinBaseP , tSrc ) ;
                tSrc = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/workshop/2source/")+tIdiForeign+tDot+tIdModule+T(".cpp") ;
    
                st_psttIdModule << psttIdModule ; psttIdModule = 0 ;
                TN( tIdModule , "" ) ; tIdModule = T(psttIdModule) ;
            {
            else
            }
                }
                    delF( tinBaseP , postp ) ;
                    fileWriteF( tinBaseP , hFile1 , postp , costp ) ;

                    delF( tinBaseP , psttp ) ;
                    countT costp = strMakeF( tinBaseP , LF , postp , psttp ) ; ___( postp ) ;
                    ZE( osTextT* , postp ) ;

                    soulr >> psttp ; ___( psttp ) ;
                    ZE( strokeS* , psttp ) ;
                {
                while( soulr )

                fileOpenF( tinBaseP , hFile1 , countTC() , tSrc , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
                handleC hFile1( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;                                                                                          \
                tSrc = T(psttHome)+T("ephemeral/domains/com/ideafarm/city/workshop/2source/")+tIdiForeign+T(".h") ;

                delF( tinBaseP , psttIdModule ) ;
            {
            if( !strCompareF( tinBaseP , psttIdModule , tH ) )
            TN( tSrc , "" ) ;
    
            __NZ( psttRev ) ;
            strReverseF( tinBaseP , psttRev , tDefBody , T("\r\n") , &soulr ) ; ___( psttRev ) ;
            soulC soulr( tinBaseP , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;
            ZE( strokeS* , psttRev ) ;

            strWordF( tinBaseP , psttIdModule , psttc1 , sttq , strokeS('.') , - 1 ) ; ___( psttIdModule ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , psttIdModule ) ;
    
            }
                delF( tinBaseP , postd ) ;
                tDefBody = T(postd) ;
                boxGetShadowF( tinBaseP , postd , costd , psttc1 ) ; ___( postd ) ;
                ZE( countT   , costd ) ;
                ZE( osTextT* , postd ) ;
            {
            TN( tDefBody , "" ) ;
            /**/traceF( tinBaseP , T("osMakeF / 5") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        {
        FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
        /**/traceF( tinBaseP , T("osMakeF / 6") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        boxMenuF( tinBaseP , soul1m , T(psttHome)+T("precious/domains/com/ideafarm/city/library/dictionary/5adam.")+tIdiForeign+T(".*") ) ;
        /**/traceF( tinBaseP , T("osMakeF / 7") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)
        soulC soul1m( tinBaseP , TAG( TAGiDnULL ) ) ;
    {
    stackC st_psttIdModule( tinBaseP , *this , TAG( TAGiDnULL ) , flSTACKc_FIFO|flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
    // MAKE THE SOURCE FILES
    /**/traceF( tinBaseP , T("osMakeF / 8") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)

    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

    //batonC bHost( tinBaseP , TAG( TAGiDnULL ) , T("masterOldC") , ifcIDgRABlAYER_7BASEmISC1 , flBATONc_GRABBED | flBATONc_NOTjEALOUS | flBATONc_SHARElAYER ) ; // A HOST BATON WITH THE SAME NAME IS ALSO USED BY masterOldC
    //20210825@1453: CONJ: NO LONGER NEED TOSERIALIZE

    /**/traceF( tinBaseP , T("osMakeF / 9") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)

    TN( tIdiForeign , "" ) ; tIdiForeign = TF3(idAdamP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ;
    TN( tIdi        , "" ) ; tIdi        = TF3(idAdamP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE                 ,8) ;
    TN( tCpp , "cpp" ) ;
    TN( tH   , "h"   ) ;
    TN( tDot , "."   ) ;
    /**/traceF( tinBaseP , T("osMakeF / a") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)

    diskMapFileNameF( tinBaseP , psttHome , T("///ideafarm/") ) ; //THIS LINE "HARDCODES" psttHome SO THAT I CAN BE RUN ON ifc21 USING THE DEFINITION FILES ON ifc11
    ZE( strokeS* , psttHome ) ;
    /**/traceF( tinBaseP , T("osMakeF / +") ) ; //U:: TO FIND A BUG (SPEED PROBLEM)

    _IO_

    }
        if( POOP ) return ;
        FV( flMAKE , flagsP ) ;
        __Z( idAdamP ) ;
        __NZ( stErrorsP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::osMakeF( tin0S& tinBaseP , stackC& stErrorsP , const countT idAdamP , const flagsT flagsP )/*1*/

/**/
*/
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001015f.flMAKE!||
 flagsP
    in this case, the caller must explicitly d elete all removed soulC objects
   alt: remove some or all plates
    in this case, the soulC objects will be d eleted when stErrorsP is destroyed
   alt: just inspect the number of plates without removing any plates from stErrorsP
  after i return, the caller can process stErrorsP in wo of these ways
    is guaranteed to be nonze
   strokeS* psttNote
    might be 0, but will usually be nonze
   strokeS* psttLine
    might be 0, but will usually be nonze
   countT idColumn
    might be 0, but will usually be nonze
   countT idLine
  after i return, each soulC object (if any) on stErrorsP contains the following elements
  must be empty
  must be of type ifcSTACKtYPE_PTR_soulC
 stErrorsP
 tinBaseP
arguments
the caller can assume that compile and link completed aok if stErrorsP has no plates
impotence does not occur when i cannot compile or link
i prepare the final source code, compile and link it, and report errors, if any
\<A HREF=\"5.1030175.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$osMakeF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

