
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return exitCode ;
    countT exitCode = bComplain ? ifcEXITcODE_EXITpROCESSiMPOTENT : ifcEXITcODE_EXITpROCESSaOK ;

    #endif

        //return bComplain ? ifcEXITcODE_EXITpROCESSiMPOTENT : ifcEXITcODE_EXITpROCESSaOK ;
        //THIS CODE DOES NOT WORK ; IT RETURNS ifcEXITcODE_EXITpROCESSaOK EVEN IF bComplain

        }
            return ifcEXITcODE_EXITpROCESSaOK ;
            ((etherC*)0)->traceF( tin0P , (strokeS*)"returning the aok code" , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
        {
        else
        }
            return ifcEXITcODE_EXITpROCESSiMPOTENT ;
            ((etherC*)0)->traceF( tin0P , (strokeS*)"returning the impotent code" , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
        {
        if( bComplain )
        //THIS CODE WORKS

    #if defined( NEVERdEFINED )

    ((etherC*)0)->traceF( tin0P , (strokeS*)postSay , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;

    ;
        : "------------------------------------------------------------------------------------------------------------------------ adamMainF ---- AOK"
        ? "------------------------------------------------------------------------------------------------------------------------ adamMainF ---- POOP"
    osTextT* postSay = bComplain

    boolT bComplain = POOP || F(thirdC::third_flagsModeProcess2I_IF()) & flMODEpROCESS2_EXITcODEiMPOTENCE ;

    }
        { CONoUTrAW3( "adamMainF set   [pEther]" , processGlobal5I.tin9VeryEarlyLateMain.pEther , "\r\n" ) ; }
        if( processGlobal5I.tin9VeryEarlyLateMain.pEther )
    {
    if( processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH07 )
    //CS:DUPLICATE: 3612c002 3612c003
    //U:: TO FIND A BUG

    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINb1 ) ;
    }
        //((tin123S&)tin0P).pc Utility[ 0 ] -- ; //U::TO FIND A BUG
        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        if( ((tin123S&)tin0P).monitor.idThread == 1 && !( ++ processGlobal2I.pcPhaseLow[ ((tin123S&)tin0P).monitor.idThread ] ) ) { BLAMMO ; }
        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN91 ) ;
        }
            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN81 ) ;

            etherC::etRockIF( tin0P ).traceF( tin0P , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
            OStEXTC(  ostoSay , processGlobal1S::_processGlobal1I_IF().cOsHandles , '0' ) ;
            OStEXTAK( ostoSay , "." ) ;
            OStEXTC(  ostoSay , ((tin1S&)tin0P).pag1->cSpins4 , '0' ) ;
            OStEXTAK( ostoSay , "." ) ;
            OStEXTC(  ostoSay , ((tin1S&)tin0P).pag1->cSpins3 , '0' ) ;
            OStEXTAK( ostoSay , "." ) ;
            OStEXTC(  ostoSay , ((tin1S&)tin0P).pag1->cSpins2 , '0' ) ;
            OStEXTAK( ostoSay , "." ) ;
            OStEXTC(  ostoSay , ((tin1S&)tin0P).pag1->cSpins1 , '0' ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , ((tin1S&)tin0P).pag1->cYieldHighWater , 0 ) ;
            OStEXTAK( ostoSay , "    " ) ;
            OStEXTC(  ostoSay , ((tin1S&)tin0P).pag1->idAdam , 0 ) ;
            OStEXTAK( ostoSay , "adamMainF [idAdam,cYieldHighWater,cSpins1,cSpins2,cSpins3,cSpins4,cOsHandles]:    " ) ;
            OStEXT(   ostoSay , TUCK << 2 ) ;

            ((tin1S&)tin0P).pag1->_etherC_.pHdll = 0 ;
            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN71 ) ;
            }
                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN61 ) ;
                }
                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN51 ) ;
                    }
                        }
                            while( !( F(thirdC::third_flagsProcessStateI_IF(tin0P)) & flPROCESSsTATE_tmWindowsF_HASeNDED ) ) { ++ s ; thirdC::dosSleepRawIF( tin0P , 250 ) ; }
                            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                        {
                        thirdC::third_flagsProcessStateI_IF( tin0P , flPROCESSsTATE_MAINtHREADcLEANUPiScOMPLETE , 1 ) ;
                        //if( idTypeP == ifcIDtYPEtLS_WINDOW && !idCmdShowP && !hPreviousWindowingClientP ) { ZE( countT , foo ) ; } //U:: CONJ: NOT NEEDED
                    {
                    if( idTypeP == ifcIDtYPEtLS_WINDOW )
                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN41 ) ;

                    if( ((tin123S&)tin0P).monitor.idThread == 1 && !( ++ processGlobal2I.pcPhaseLow[ ((tin123S&)tin0P).monitor.idThread ] ) ) { BLAMMO ; }
                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN31 ) ;
        
                    if( thirdC::third_cThirdObjectsI_IF( tin0P ) ) ;//TELLsYSc1( ifcIDtYPEtELLsYS_ERRORsOMEtHIRDoBJECTSeXIST )
                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN21 ) ;
                    }
                        ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN11 ) ;
                        }
                            DELzOMBIE( pzPoolAdamTemp ) ;
                            // ALL poolC INSTANCES REGISTERED IN tin0P ARE DESTROYED HERE (IN DT'OR FOR poolC ADAM TEMP) IF NOT ALREADY DESTROYED
                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN01 ) ;

                            }
                                THREADmODE5rESTORE
                                }
                                    cPending = 0 ;

                                    }
                                        thirdC::dosTellMonitorIF( tin0P , tell , ifcIDbOOKStELL_APP ) ;
                                        tellC tell( tin0P , LF , 0 , ifcIDtYPEtELLaPP_INoUTaRRAY , ((tin123S&)tin0P).pbPendingInOutFramePackets , sizeof( countT ) + cPending * sizeof( tellInfoAppInOutFrameS ) ) ;
                                    {

                                    }
                                        BLAMMO ;
                                        LOGrAW5(    "adamMainF error: [cPending,cMax]: " , cPending , " " , CmAXpENDINGiNoUTfRAMEpACKETS , "\r\n" ) ;
                                        CONoUTrAW5( "adamMainF error: [cPending,cMax]: " , cPending , " " , CmAXpENDINGiNoUTfRAMEpACKETS , "\r\n" ) ;
                                    {
                                    if( cPending > CmAXpENDINGiNoUTfRAMEpACKETS )

                                    tellInfoAppInOutFrameS* pPending = (tellInfoAppInOutFrameS*)( ((tin123S&)tin0P).pbPendingInOutFramePackets + sizeof( countT ) ) ;
                                {
                                if( cPending )

                                countT& cPending = *(countT*)((tin123S&)tin0P).pbPendingInOutFramePackets ;

                                THREADmODE5oN( flTHREADmODE5_INoUTfRAMEdOnOTcOLLECTaPPtELEMETRY | flTHREADmODE5_DOnOTfLUSHpENDINGaPPtELEMETRY ) ;
                            {
                            if( ((tin123S&)tin0P).pbPendingInOutFramePackets )
                            //PSEUDOdUPLICATEcODE 360fc002 33000065
                            //THE CODE IS RETAINED BECAUSE tellC MIGHT USE *((tin123S&)tin0P).pPoolUse IN THE FUTURE, AND ALSO FLUSHING ESTABLISHES A KNOWN STATE (AN EMPTY BUFFER) FOR PROCESS TERMINATION
                            //THIS IS DONE HERE TO FLUSH PENDING inOutFrameC APP TELEMETRY WHILE poolC IS STILL AVAILABLE (AS OF THIS WRITING, tellC ALWAYS USES heap, SO WHETHER ((tin123S&)tin0P).pPoolUse IS NONZE HAS NO EFFECT

                            }
                                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINf ) ;
                                if( ((tin123S&)tin0P).monitor.idThread == 1 && !( ++ processGlobal2I.pcPhaseLow[ ((tin123S&)tin0P).monitor.idThread ] ) ) { BLAMMO ; }
                                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINe ) ;
                                }
                                    // tin0P IS DESTROYED HERE (BY etherC DT'OR)
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINd ) ;
                                    }
                                        TELL( "main: destroying ether" ) ;
                                        if( ((tin123S&)tin0P).monitor.idThread == 1 && !( ++ processGlobal2I.pcPhaseLow[ ((tin123S&)tin0P).monitor.idThread ] ) ) { BLAMMO ; }
                                        TINSL
                                    {
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINc ) ;
                                    }
                                        ((tin123S&)tin0P).pEther = 0 ;
                                        }
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINb ) ;

                                            TELL( "main: destroying etThread and tin0P reference" ) ;

                                            //((tin123S&)tin0P).monitor.idWhat2 = 0 ;
                                            //ether.etherWhereF( tin0P , ifcIDaCTIONwHERE_SHUTDOWN ) ;
                                            //ether.etherWhereF( tin0P , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
                                            //ether.etherWhereF( tin0P , ifcIDaCTIONwHERE_UNWATCH ) ;
                                            //ether.traceF( tin0P , T("disabling where") ) ;

                                            //U::POOLS 2 3 4 WERE DESTROYED HERE

                                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAINa ) ;
                                            DEL( ((tin1S&)tin0P).pag1->pBksLog ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN9 ) ;
                                            TELL( "main: destroying log" ) ;

                                            }
                                                if( ((tin123S&)tin0P).monitor.idThread == 1 && !( ++ processGlobal2I.pcPhaseLow[ ((tin123S&)tin0P).monitor.idThread ] ) ) { BLAMMO ; }
                                                TINSL
                                            {
                                            TELL( "main: inspecting phase 2" ) ;
            
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN8 ) ;
                                            DEL( ((tin123S&)tin0P).pEtScratch ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN7 ) ;
                                            TELL( "main: destroying pEtScratch" ) ;
                                            if( ((tin123S&)tin0P).monitor.idThread == 1 && !( ++ processGlobal2I.pcPhaseLow[ ((tin123S&)tin0P).monitor.idThread ] ) ) { BLAMMO ; }
                                            TELL( "main: inspecting phase" ) ;
                                            //if( etThread ) thirdC::third_flagsModeProcess1I_IF() |= flMODEpROCESS1_etThreadONmainISiMPOTENT ;
                        
                                            ((tin123S&)tin0P).tally.flushF( tin0P , etThread ) ;
                                            ((tin123S&)tin0P).tally.nowF( tin0P , etThread ) ;
                                            ((tin123S&)tin0P).tally.bTally = 0 ;
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN6 ) ;
                        
                                            }
                                                if( ((tin123S&)tin0P).monitor.idThread == 1 && !( ++ processGlobal2I.pcPhaseLow[ ((tin123S&)tin0P).monitor.idThread ] ) ) { BLAMMO ; }
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN5 ) ;
                                                thirdC::s_shutdown1IF( tin0P ) ;
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN4 ) ;
                                                }
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN3 ) ;
                                                    }
                                                        DEL( ((tin1S&)tin0P).pag1->_deviceC_pStkJob ) ;
                                                        DELzOMBIE( pDisplay ) ;
                                                    {
                                                    if( idTypeP == ifcIDtYPEtLS_WINDOW )

                                                    if( F(thirdC::third_flagsModeAdam1I_IF(tin0P)) & flADAMmODE1_WHEREaLL ) etThread.etherWhereF( tin0P , ifcIDaCTIONwHERE_SHUTDOWN ) ;
                                                    }
                                                        TELLsYSc1( ifcIDtYPEtELLsYS_AOKfYIjUSTcALLEDaDAMmAIN ) 
                                                        TELL( "main: returned from pMainF" ) ;
                                                        }
                                                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN2 ) ;
                                                            ((tin123S&)tin0P).tell_tmWatchF_toIgnoreMeF() ;
                                                            //etherC::ifcSayIF( T("called pMainF") , flSAY_APPEND | flSAY_LOG ) ;
                                                            if( ((tin123S&)tin0P).monitor.idThread == 1 && !( ++ processGlobal2I.pcPhaseLow[ ((tin123S&)tin0P).monitor.idThread ] ) ) { BLAMMO ; }
                                                            cryC cry0d( TOCK + 0x0d ) ;
                                                            ADAMpHASE( ifcIDpHASEaDAM_EXEePILOGaDAMmAIN1 ) ;
                                                            }
                                                                }
                                                                    etThread.traceF( tin0P , (strokeS*)"--------------------------------------------------------------------------------------------------------------------------------------- adamDll ----" , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                                                                    }
                                                                        (*pMainF)( &main ) ; // ASSUME: WILL NOT RETURN UNTIL ALL KID THREADS HAVE ENDED, INCLUDING tmWatchF
                                                                        _IO_
                                                                    {
                                                                    etThread.traceF( tin0P , (strokeS*)"--------------------------------------------------------------------------------------------------------------------------------------- adamDll ++++" , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                                                                    _IO_
                                                                {

                                                                }
                                                                    }
                                                                        SCOOPS
                                                                    {
                                                                    _IO_
                                                                {
                                                                IFsCRATCH

                                                                _IO_
                                                            {
                                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN23 ) ;
                                                            cryC cry0c( TOCK + 0x0c ) ;

                                                            __( ((tin1S&)tin0P).pag1->idMemorySpace - rootAdamGlobal1I.idMemorySpace ) ; // THIS ENSURES THAT ALL ADAMS WITHIN A PROCESS ARE USING THE SAME MEMORY SPACE (THEY HAVE ACCESS TO PROCESS GLOBALS THAT USE A MEMORY SPACE)
                                                            cryC cry201( ( TOCK << 1 ) + 0x01 ) ;

                                                            }
                                                                countT foo = 2 ;
                                                            {
                                                            if( idAdamWant == ((tin1S&)tin0P).pag1->idAdam )
                                                            static countT idAdamWant = 0x401057b ; //TO FACILITATE WDW DEBUGGING

                                                            if( ((tin123S&)tin0P).monitor.idThread == 1 && !( ++ processGlobal2I.pcPhaseLow[ ((tin123S&)tin0P).monitor.idThread ] ) ) { BLAMMO ; }
                                                            //etherC::ifcSayIF( T("calling pMainF") , flSAY_APPEND | flSAY_LOG ) ;
                                                            _IO_
                                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN13 ) ;
                                                            cryC cry202( ( TOCK << 1 ) + 0x02 ) ;
                                                        {
                
                                                        cryC cry401( ( TOCK << 2 ) + 0x01 ) ;
                                                        TELL( "main: calling pMainF" ) ;
                                                        cryC cry402( ( TOCK << 2 ) + 0x02 ) ;
                                                        TELLsYSc1( ifcIDtYPEtELLsYS_AOKfYIaBOUTtOcALLaDAMmAIN ) 
                                                        cryC cry403( ( TOCK << 2 ) + 0x03 ) ;
                                                        declareVmUsageTypeGF( tin0P , (byteT*)pMainF , flVMuSAGEtYPE_CODEaDAM ) ;
                                                        cryC cry404( ( TOCK << 2 ) + 0x04 ) ;
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN03 ) ;
                                                        cryC cry203( ( TOCK << 1 ) + 0x03 ) ;
                                                        _IO_
                                                    {
                                                    else
                                                    }
                                                        ((tin123S&)tin0P).tell_tmWatchF_toIgnoreMeF() ;
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINf2 ) ;
                                                        _IO_
                                                    {
                                                    if( !pMainF || ether )
                                                    cryC cry204( ( TOCK << 1 ) + 0x04 ) ;

                                                    TELL( "main: mainS object constructed" ) ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINe2 ) ;
                        
                                                    mainS main( tin0P , ether , etThread , hDll , T("cid ")+tCid+T(" level 1") ) ;
                                                    TELL( "main: constructing mainS object" ) ;
                                                    cryC cry205( ( TOCK << 1 ) + 0x05 ) ;

                                                    }
                                                        __Z( pMainF ) ;
                                                        etThread.dllEntryF( tin0P , pMainF , hDll , T("mainF") ) ;
                                                        __Z( hDll ) ;
                                                        etThread.delF( tin0P , psttDll ) ;
                                                        TELL( "main: looking up the entry point" ) ;
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINd2 ) ;
                                                        _IO_
                                                    {
                                                    ZE( mainFT , pMainF ) ;
                                                    cryC cry206( ( TOCK << 1 ) + 0x06 ) ;

                                                    }
                                                        cryC cry31( ( TOCK << 2 ) + 0x01 ) ;
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINc2 ) ;
                                                        }
                                                            cryC cry32( ( TOCK << 2 ) + 0x02 ) ;
                                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINb2 ) ;
                                                            }
                                                                cryC cry41( ( TOCK << 3 ) + 0x01 ) ;
                                                                //etThread.traceF( tin0P , T("adamMainF / called  dllOpenF [tDll]:    ")+tDll ) ;
                                                                etThread.dllOpenF( tin0P , hDll , tDll ) ;
                                                                //etThread.traceF( tin0P , T("adamMainF / calling dllOpenF [tDll]:    ")+tDll ) ;
                                                                //hoverC hover( tin0P , etThread , T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/") ) ;
                                                                cryC cry42( ( TOCK << 3 ) + 0x02 ) ;

                                                                TN( tDll , "" ) ; tDll = T("///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/hover/ideafarm.")+T(psttDll)+T(".ipdos-wd") ;
                                                            {
                                                            else
                                                            }
                                                                cryC cry43( ( TOCK << 3 ) + 0x03 ) ;
                                                                etThread.dllOpenF( tin0P , hDll , psttDll ) ;
                                                                cryC cry44( ( TOCK << 3 ) + 0x04 ) ;
                                                            {
                                                            if( etThread.strIdF( tin0P , S1C('/') , psttDll ) )
                                                            cryC cry33( ( TOCK << 2 ) + 0x03 ) ;

                                                            // state C IS OBSOLETED BY THE adam.perm POOL AND ALL state C CODE SHOULD BE MIGRATED AND THEN state C REMOVED
                                                            // THIS FEATURE IS BROKEN AND REQUIRES WORK

                                                            // THE OLD INSTANCE WILL COMPLETE ALL SERVICE TO EXISTING CLIENTS AND THEN TERMINATE
                                                            // THE NEW INSTANCE WILL IMMEDIATELY ASSUME RESPONSIBILITY FOR ACCEPTING NEW CLIENTS
                                                            // BY DEFAULT, ONLY ONE INSTANCE OF AN ADAM CAN EXIST AT A TIME IN A HOME
                                                            // THE FOLLOWING COMMENTS ARE OBSOLETE; MULTIPLE INSTANCES CAN COEXIST (SEE E.G. ifcIDaDAM_CLOUD); THE OLD HANDOFF CODE WAS DISABLED/REMOVED AND CODE RELATED TO SAVING AND LOADING ADAM STATE IS DISABLED OR IN AN UNKNOWN UNUSED STATE

                                                            // A MASTER FILE CAN BE UPDATED WHILE ITS CORRESPONDING HOVER FILE IS LOADED AND IN USE BY RUNNING PROCESSES

                                                            // THE MAIN (PERHAPS ONLY) REASON FOR THIS IS TO MAKE "HOT UPDATING" POSSIBLE
                                                            // IPDOS PROCESSES ARE NORMALLY LOADED FROM THE HOVER DIRECTORY
                                                            // THIS WILL BE DONE IF THE EXE IMAGE IS COMING FROM THE HOVER DIRECTORY

                                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINa2 ) ;
                                                            cryC cry34( ( TOCK << 2 ) + 0x04 ) ;
                                                            _IO_
                                                            cryC cry35( ( TOCK << 2 ) + 0x05 ) ;
                                                        {
                                                        else
                                                        }
                                                            cryC cry36( ( TOCK << 2 ) + 0x06 ) ;
                                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN92 ) ;
                                                            etThread.dllOpenF( tin0P , hDll , T("ideafarm.")+T(psttDll)+T(bMasterMaster?".ipdos-wm":".ipdos-tm") ) ;
                                                            __( etThread.strIdF( tin0P , S1C('/') , psttDll ) ) ;
                                                            cryC cry37( ( TOCK << 2 ) + 0x07 ) ;

                                                            // FOR EXAMPLE, WHEN INSTALLING THE BUILD FOLDER ON A NEW DEVELOPMENT COMPUTER, THE BUILD PROGRAMS (IN BENCH) WILL BUILD THE MASTER FILES AND THEN LOAD PROCESSES FROM THEM TO BUILD THE HOVER FILES
                                                            // IPDOS PROCESSES ARE ONLY LAUNCHED FROM THE MASTER DIRECTORY WHEN THE DESIRED IMAGE DOES NOT EXIST IN THE HOVER DIRECTORY
                                                            // THIS WILL BE DONE IF THE EXE IMAGE IS COMING FROM THE MASTER DIRECTORY

                                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN82 ) ;
                                                            _IO_
                                                            cryC cry38( ( TOCK << 2 ) + 0x08 ) ;
                                                        {
                                                        else if( bMasterMaster || bMasterTemporary )

                                                        }
                                                            cryC cry39( ( TOCK << 2 ) + 0x09 ) ;
                                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN72 ) ;
                                                            etThread.dllOpenF( tin0P , hDll , psttDll ) ;
                                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN62 ) ;
                                                            _IO_
                                                            cryC cry3a( ( TOCK << 2 ) + 0x0a ) ;
                                                        {
                                                        if( etThread.strIdF( tin0P , T("/IdeaFarm " "(tm) Removal Utility/") , psttDll ) )

                                                        }
                                                            bMasterTemporary = !etThread.strCompareF( tin0P , T(thirdC::postBaseNameIF(tin0P)) , T(ostoCopy2) ) ;
                                                            bMasterMaster    = !etThread.strCompareF( tin0P , T(thirdC::postBaseNameIF(tin0P)) , T(ostoCopy1) ) ;

                                                            ( (osTextT*)(const osTextT*)ostoCopy2 )[ 9 ] = '8' ;  // THE SMUDGER THAT MAKES THE HOVER FILE WILL NOT REPLACE ostoCopy2 BUT IT WILL REPLACE THE STRING IN postBasenameIF
                                                            ( (osTextT*)(const osTextT*)ostoCopy1 )[ 9 ] = '8' ;  // THE SMUDGER THAT MAKES THE HOVER FILE WILL NOT REPLACE ostoCopy1 BUT IT WILL REPLACE THE STRING IN postBasenameIF
                                                            OStEXTV( ostoCopy2 , "ideafarm.@1000001.ipdos-tm" )   //"t" IS FOR "temporary", REFERRING TO "TEMPORARY" MASTER FILES IN THE MASTER FOLDER, WHICH ARE USED ONLY TO BOOTSTRAP THE BUILD OF THE EARLIEST HOVER FILES.  SUCH TEMPORARY FILES ARE NEEDED BECAUSE WINDOWS NO LONGER ALLOWS A PROCESS TO MODIFY THE BACKING FILES FOR ITS OWN EXECUTABLE IMAGES, AS OF 20221207@1435
                                                            OStEXTV( ostoCopy1 , "ideafarm.@1000001.ipdos-wm" )
                                                        {
                                                        ZE( boolT , bMasterTemporary ) ;
                                                        ZE( boolT , bMasterMaster    ) ;

                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN52 ) ;
                                                        _IO_
                                                        cryC cry3b( ( TOCK << 2 ) + 0x0b ) ;
                                                    {
                                                    TELL( "main: linking in the adam dll" ) ;
                                                    cryC cry207( ( TOCK << 1 ) + 0x07 ) ;

                                                    TNCID ;
                                                    //U:etThread.constructedInLine = 0 ;
                                                    //U:etThread.postcConstructedInFile = ppostHowP[ 1 ] ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN42 ) ;
                                                    cryC cry208( ( TOCK << 1 ) + 0x08 ) ;

                                                    }
                                                        pDisplay = new( 0 , tin0P , pbDisplay , sizeof pbDisplay ) displayC( tin0P , etThread , ((measureT)1e1) , 0 , 0 , flDEVICEc_NOsMOOTHIES ) ; //USE SMOOTHIES IN PRODUCTION BUT NOT FOR SOME TESTING
                                                        ((tin1S&)tin0P).pag1->_deviceC_pStkJob = new( 0 , tin0P , LF ) stackC( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_GIVEsIGNnEWpLATE , sizeof( drawJobS ) ) ; ___( ((tin1S&)tin0P).pag1->_deviceC_pStkJob ) ;
                                                        _IO_
                                                    {
                                                    if( idTypeP == ifcIDtYPEtLS_WINDOW )        //U:: 20200314@1545: CT THIS STACK FAILS ON NONMONOTONIC GRAB.  TESTING OF NONMONOTONIC GRAB ENFORCEMENT DID NOT INCLUDE TESTS FOR GUI PROCESSES

                                                    ZE( displayC* , pDisplay ) ;
                                                    byteT pbDisplay[ sizeof( displayC ) ] ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN32 ) ;
                                                    cryC cry209( ( TOCK << 1 ) + 0x09 ) ;
                
                                                    }
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN22 ) ;
                                                        sgnWatchReady.waitF( tin0P ) ;
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN12 ) ;

                                                        }
                                                            sgnWatchReady.giveF( tin0P ) ;
                                                            if( idTypeP == ifcIDtYPEtLS_WINDOW ) sgnWindowsReady.waitF( tin0P ) ;
                                                        {
                                                        if( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_NOsYSTEMtHREADS )

                                                        }
                                                            etThread.osThreadF( TaRG1( tmWindowsF ) , (countT)&sgnWindowsReady , (countT)&psttTitle ) ;
                                                            thirdC::third_flagsModeAdam1I_IF( tin0P ) |= flADAMmODE1_tmWindows ;
                                                            etThread.traceF( tin0P , T("launching tmWindowsF") ) ;
                                                        {
                                                        else
                                                        }
                                                            }
                                                                etThread.delF( tin0P , psttTitle ) ;
                                                                etThread.winSetTitleF( tin0P , psttTitle ) ;
                                                            {
                                                            if( ((tin123S&)tin0P).idTinNamed == ifcIDtINnAMED_tinInPoolMain )
                                                            sgnWindowsReady.giveF( tin0P ) ;
                                                        {
                                                        if( idTypeP != ifcIDtYPEtLS_WINDOW )
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN02 ) ;

                                                        //ether.osSleepF( tin0P , TOCK << 2 ) ;
                                                        //sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                                                        //etThread.winSetTitleF( tin0P , T("tmWatchF launched ; napping for 4 tocks") ) ;
                                                        //TO FIND BUGS
                    
                                                        //etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_NORMAL ) ;

                                                        else etThread.traceF( tin0P , T("warning: build is configured for \"no system threads\"") ) ;
                                                        }
                                                            etThread.osThreadF( tin0P , countTC() , tmWatchF , 0 , 0  , flTHREADlAUNCH_null , CBsTACKmIN << 2 , 0 , (countT)&sgnWatchReady , (countT)&sgnWindowsReady ) ;
                                                            //etThread.traceF( tin0P , T("launching tmWatchF") ) ;
                                                        {
                                                        if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_NOsYSTEMtHREADS ) )
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINf1 ) ;

                                                        //etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUSH ) ;
            
                                                        signC sgnWindowsReady( tin0P , TAG( TAGiDnULL ) ) ;
                                                        signC sgnWatchReady(   tin0P , TAG( TAGiDnULL ) ) ;
                                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINe1 ) ;
                                                        _IO_
                                                    {
                                                    cryC cry20a( ( TOCK << 1 ) + 0x0a ) ;
                
                                                    }
                                                        }
                                                            }
                                                                ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;

                                                                }
                                                                    break ;
                                                                    etThread.traceF( tin0P , T("IdeaFarm (tm) keys found") ) ;
                                                                {
                                                                else if( idKeys )
                                                                }
                                                                    etThread.traceF( tin0P , T("!exception: could not obtain idIdeaFarmKeys [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc) ) ;
                                                                    const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                                    POOPRqUIET
                                                                    countT rc = POOP ;
                                                                {
                                                                if( POOP )

                                                                count04T idKeys = ((tin123S&)tin0P).pEtScratch->idIdeaFarmKeysF( tin0P ) ;
                                                            {
                                                            while( !ether && !home.idIdeaFarmKeys )

                                                            TN( tb4 , "    " ) ;
                                                            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                                                            homeS& home = homeS::homeIF() ;
                                                            _IO_
                                                        {

                                                        SCOOPS
                                                        _IO_
                                                    {
                                                    IFsCRATCH

                                                    __( &sadams - sadamsC::pSadamsIF( tin0P ) ) ;
                                                    sadamsC sadams( tin0P , etThread , TAG( TAGiDnULL ) ) ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINd1 ) ;
                                                    cryC cry20b( ( TOCK << 1 ) + 0x0b ) ;

                                                    }
                                                        etThread.etherWhereF( tin0P , ifcIDaCTIONwHERE_SETUP , 0x30 ) ;
                                                        _IO_
                                                    {
                                                    if( F(thirdC::third_flagsModeAdam1I_IF(tin0P)) & flADAMmODE1_WHEREaLL )
                                                    cryC cry20c( ( TOCK << 1 ) + 0x0c ) ;

                                                    //etherC::ifcSayIF( T("ADAM CELL (idAdam,osPid): ")+TF1(processGlobal1I.idAdamRoot)+T(" ")+TF1(((tin123S&)tin0P).osPid)+T("\r\n") , flSAY_APPEND | flSAY_LOG ) ;
                                                    }
                                                        etThread.traceF( tin0P , tTitle ) ; //RETAIN THIS; IT IS USEFUL TO DEFEND AGAINST ATTACK
                                                    
                                                        ;
                                                            +t8+T("P_")+TF2(((tin123S&)tin0P).osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("(")+TF4(((tin123S&)tin0P).osPid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(")")
                                                            +t8+T("F_")+TF2(((tin1S&)tin0P).pag1->idGroupFireAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                            +t8+T("A+")+TF2(((tin1S&)tin0P).pag1->idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("(")+TF2(((tin1S&)tin0P).pag1->idAdam&0xfff,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(")")
                                                            +t8+T("A_")+TF2(rootAdamGlobal1I.idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("(")+TF2(processGlobal1I.idAdamRoot&0xfff,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(")")
                                                            +t8+T("M_")+TF2(((tin1S&)tin0P).pag1->idMemorySpace,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                            +t8+T("H_")+TF2(processGlobal2I.idHome,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)
                                                            T(postIPDOSsHORT)
                                                        TN( tTitle , "" ) ; tTitle =

                                                        TN( t8 , "        " ) ;
                                                        _IO_
                                                    {
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINc1 ) ;
                                                    cryC cry20d( ( TOCK << 1 ) + 0x0d ) ;

                                                    }
                                                        #endif

                                                            etThread.strMakeF( tin0P , LF , psttDll , TF3(((tin1S&)tin0P).pag1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ; ___( psttDll ) ;

                                                        #else

                                                        }
                                                            break ;
                                                            etThread.strMakeF( tin0P , LF , psttDll , psttc1 ) ; ___( psttDll ) ;
                        
                                                            if( !psttc1->idAdam || psttc1[ CSpREFIX ] == sttExclaim ) break ;
                                                            if( cSkip -- ) continue ;
                                                            //CONoUTrAW( T("parameter: \"")+T(psttc1)+T("\"\r\n") ) ;
                                                        {
                                                        FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tin0P ) )
                                                        strokeS sttExclaim('!') ;
                                                        countT cSkip = 1 ;

                                                        // THE TRAILING FO SYMBOLS AND ~ AND ` SHOULD NOT BE USED FOR PARAMETER KEYS BECAUSE THEY WOULD BE USEFUL AS OPERATORS
                                                        // RESERVED: ` ~ ! @ # $ % ^ & * - + =
                                                        // NEW CONFORMANCE SPEC:  PARAMETER KEYS CAN START WITH EITHER '!' OR '@', WITH POSSIBLE FUTURE USE OF '#', '$', '%', ... TO RESERVE SUCH USE OF ALL OF THE SYMBOLS IN THE TOPMOST ROW OF THE US KEYBOARD
                                                        // THIS DECISION TO USE '@' RATHER THAN '!' MIGHT BE THE BEGINNING OF CHANGING CONFORMANCE RULES TO ABANDON THE SPEC THAT ALL PARAMETER KEYS START WITH '!'
                                                        // 20181113@0922:

                                                        // OTHERWISE, THE SYMBOLIC ADAMS WOULD BE OF THE FORM "!aFind", AND SPECIFYING THEM WOULD CAUSE ME TO THINK THAT NO idAdam WAS SPECIFIED, UNLESS ALL OF THEIR POSSIBLE VALUES WERE HARDCODED IN ME
                                                        // '@' IS USED RATHER THAN '!' SO THAT I CAN LOOK AT ONLY THE WOTH CHARACTER TO DETECT THE ABSENCE OF AN idAdam SPECIFICATION IN THE WOTH PARAMETER AFTER THE EXE NAME
                                                        // 20181112@1144: THE WOTH ARGUMENT (IDENTIFYING idAdam) IS NOW ALLOWED TO BE SYMBOLIC, E.G. "@find", SO THIS CODE IS REPLACED WITH CODE THAT USES processGlobal1I.idAdamRoot

                                                        #if defined( NEVERdEFINED )
                                                        _IO_
                                                    {
                                                    ZE( strokeS* , psttDll ) ;
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINb1 ) ;
                                                    cryC cry20e( ( TOCK << 1 ) + 0x0e ) ;
                                                    _IO_
                                                {
                                                else
                                                }
                                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINa1 ) ;
                                                    _IO_
                                                {
                                                if( ether )
                                                cryC cry20f( ( TOCK << 1 ) + 0x0f ) ;
                                                _IO_

                                                etThread.ifcDatumF( tin0P , flDATUM1_CLASStRACEaLWAYShIRE , flDATUM2_null , 0 , 0 , 0 , (voidT*)DDNAME ) ;
                                                }
                                                    etThread.osThreadF( TaRG1( tmTimeNowF    ) ) ;
                                                    //etThread.traceF( tin0P , T("launching tmTimeNowF") ) ;
                                                    etThread.osThreadF( TaRG1( tmKillSocketF ) ) ; //A:ASSUME: thirdC::s_setupIF HAS ALREADY BEEN CALLED (LOOK FOR IT VERY EARLY DURING CT OF processGlobal4I)
                                                    //etThread.traceF( tin0P , T("launching tmKillSocketF") ) ;
                                                {
                                                if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_NOsYSTEMtHREADS ) )
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN91 ) ;
                                                cryC cry2010( ( TOCK << 1 ) + 0x10 ) ;

                                                TELL( "main: parameters scanned" ) ;
                                                }
                                                    //etThread.traceF( tin0P , T("adam parameters (command line arguments) END [idAdam]:    ")+TF2(((tin1S&)tin0P).pag1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    }
                                                        //U::if( bOk ) etThread.strokeF( tin0P , T("process parameter \"")+T(psttc1)+T("\" recognized\r\n") ) ;

                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!faceHear"          ) ) ) { idArg = 3                                                                                    ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!cUtility"          ) ) ) { idArg = 2                                                                                    ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!idCitizenHirerI"   ) ) ) { idArg = 1                                                                                    ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!bWatchfulINo"      ) ) ) { ((thirdC&)ether).third_bWatchfulI_F( tin0P ) = 0                                              ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!bCarefulINo"       ) ) ) { ((thirdC&)ether).third_bCarefulI_F( tin0P ) = 0                                               ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!dead"              ) ) ) { thirdC::third_flagsModeAdam1I_IF( tin0P ) |=      flADAMmODE1_LOGdEADLOCKS                    ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!hideWithIcon"      ) ) ) { thirdC::third_flagsModeProcess1I_IF()    |=      flMODEpROCESS1_HIDEwITHiCON                 ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!noSynchronousTells") ) ) { thirdC::third_flagsModeProcess1I_IF()    |=      flMODEpROCESS1_NOsYNCHRONOUStELLS           ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!noTells"           ) ) ) { thirdC::third_flagsModeProcess1I_IF()    |=      flMODEpROCESS1_SUPPRESStELLS                ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!noTellsHome"       ) ) ) { homeS::homeIF().flags                    |=      flHOMEs_SUPPRESStELLS                       ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!whereAll"          ) ) ) { thirdC::third_flagsModeAdam1I_IF( tin0P ) |=      flADAMmODE1_WHEREaLL                        ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!noGlobalGrab"      ) ) ) { thirdC::third_flagsModeAdam1I_IF( tin0P ) |=      flADAMmODE1_DISALLOWgRABoFiNTERPROCESSgRABs ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!minimized"         ) ) ) { thirdC::third_flagsModeProcess1I_IF()    |=      flMODEpROCESS1_LAUNCHmINIMIZED              ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!quitAtShutdown"    ) ) ) { thirdC::third_flagsModeProcess1I_IF()    |=      flMODEpROCESS1_QUITaTsHUTDOWN               ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!quitAtLogoff"      ) ) ) { thirdC::third_flagsModeProcess1I_IF()    |=      flMODEpROCESS1_QUITaTlOGOFF                 ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!log2monitor"       ) ) ) { thirdC::third_flagsModeAdam1I_IF( tin0P ) |=      flADAMmODE1_LOG | flADAMmODE1_LOGtOmONITOR  ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!log2popup"         ) ) ) { thirdC::third_flagsModeAdam1I_IF( tin0P ) |=      flADAMmODE1_LOG | flADAMmODE1_LOGtOpOPUP    ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!log2file"          ) ) ) { thirdC::third_flagsModeAdam1I_IF( tin0P ) |=      flADAMmODE1_LOG | flADAMmODE1_LOGtOfILE     ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!bWatchSay"         ) ) ) { etThread.flagsWatch                      |=      flWATCH_SAY                                 ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!bWatchEmployers"   ) ) ) { etThread.flagsWatch                      |=      flWATCH_EMPLOYERS                           ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!debug"             ) ) ) { thirdC::third_flagsModeProcess1I_IF()    |=      flMODEpROCESS1_DEBUG  ;                     ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!testAutoDoSleeps"  ) ) ) { etThread.flagsMode                       |=      flTHIRDmODE_TESTaUTOdOsLEEPS                ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!testAuto"          ) ) ) { etThread.flagsMode                       |=      flTHIRDmODE_TESTaUTO                        ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!bWatchTimeNo"      ) ) ) { etThread.flagsWatch                      &= ~( F(flWATCH_TIME        ) )                     ; bOk = 1 ; }
                                                        else if( !etThread.strCompareF( tin0P , psttc1 , T("!noDebug"           ) ) ) { thirdC::third_flagsModeProcess1I_IF()    &= ~( F(flMODEpROCESS1_DEBUG) )                     ; bOk = 1 ; }
                                                        //CS:CODEsYNC: 33000065 33000065
                                                        }
                                                            }
                                                                }
                                                                    break ;
                                                                    if( psttc1->idAdam && 1 == etThread.strIdF( tin0P , idf , sttq , S1C('!') , psttc1 ) ) idArg = 0 ;
                                                                    countT idf = 1 ;
                                                                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                                                {
                                                                case  3 :
                                                                case  2 : { idArg = 0 ; etherC::ether_cUtility_IF( tin0P )          = etThread.strDigitsToSCountF( tin0P , psttc1 ) ; bOk = 1 ; break ; }
                                                                case  1 : { idArg = 0 ; etThread.ether_idCitizenHirerI_F( tin0P ) = etThread.strDigitsToSCountF( tin0P , psttc1 ) ; bOk = 1 ; break ; }
                                                            {
                                                            switch( idArg )
                                                        {
                                                        if( idArg )
                                                        ZE( boolT , bOk ) ;

                                                        if( idTypeP == ifcIDtYPEtLS_WINDOW && !psttTitle && ( off ++ ) == 1 ) { etThread.strMakeF( tin0P , LF , psttTitle , psttc1 ) ; ___( psttTitle ) ; }

                                                        //etThread.traceF( tin0P , T("    [parameter]: ")+T(psttc1) ) ;
                                                    {
                                                    FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tin0P ) )
                                                    ZE( countT , idArg ) ;
                                                    ZE( countT , off ) ;
                                                    //etThread.traceF( tin0P , T("adam parameters (command line arguments) BEGIN [idAdam]:    ")+TF2(((tin1S&)tin0P).pag1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                TELL( "main: inspecting process parameters" ) ;
                                                cryC cry211( ( TOCK << 1 ) + 0x11 ) ;

                                                etThread.etherScanProcessParametersF( tin0P ) ;
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN81 ) ;

                                                }
                                                    //}
                                                    //    etThread.traceF( tin0P , T("parameter: \"")+T(psttc1)+T("\"") ) ;
                                                    //{
                                                    //FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tin0P ) )

                                                    }
                                                        }
                                                            etThread.strFuseSeparateF( tin0P , etThread.ether_pstt1_processParametersI_F( tin0P ) , tMonitor ) ;
                                                            etThread.strFuseSeparateF( tin0P , etThread.ether_pstt1_processParametersI_F( tin0P ) , tDriver  ) ;
                                                        {
                                                        )
                                                            )
                                                                )
                                                                    *ppostHowP[ off + 1 ] == '!'
                                                                (
                                                                ||
                                                                cHowP == 1
                                                            (
                                                            &&
                                                            && !off
                                                               bOsSupportsServices
                                                        (
                                                        if
                                                        etThread.strFuseSeparateF( tin0P , etThread.ether_pstt1_processParametersI_F( tin0P ) , T(ppostHowP[off]) ) ; ___( etThread.ether_pstt1_processParametersI_F( tin0P ) ) ;
                                                    {
                                                    for( countT off = 0 ; off < cHowP ; off ++ )

                                                    etThread.strMakeF( tin0P , LF , etThread.ether_pstt1_processParametersI_F( tin0P ) , 0 , csttNeeded ) ; ___( etThread.ether_pstt1_processParametersI_F( tin0P ) ) ;
                                                    }
                                                        csttNeeded += 2 * CSpREFIX + tDriver.csF( tin0P ) + tMonitor.csF( tin0P ) ;
                                                        )
                                                            )
                                                                )
                                                                    *ppostHowP[ off + 1 ] == '!'
                                                                (
                                                                ||
                                                                cHowP == 1
                                                            (
                                                            &&
                                                            && !off
                                                               bOsSupportsServices
                                                        (
                                                        if

                                                        csttNeeded += CSpREFIX + thirdC::c_strlenIF( tin0P , ppostHowP[off] ) ;
                                                    {
                                                    for( countT off = 0 ; off < cHowP ; off ++ )
                                                    countT csttNeeded = CSpREFIX ;

                                                    }
                                                        tMonitor = TF1(ifcIDaDAM_2GLASS2) ;
                                                        tDriver  = TF1(ifcIDaDAM_1DRIVER)  ;
                                                    {
                                                    if( bOsSupportsServices )
                                                    TN( tMonitor , "" ) ;
                                                    TN( tDriver  , "" ) ;
                                                {
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN71 ) ;
                                                cryC cry212( ( TOCK << 1 ) + 0x12 ) ;

                                                }
                                                    etThread.strMakeF( tin0P , LF , psttTitle , TF4(((tin123S&)tin0P).osPid,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,0,0xa)+tb4+tAdam+tb8+T(postIPDOSsHORTlONG)+( processGlobal2I.idHome==1 ? T("") : T(" (home ")+TF2(processGlobal2I.idHome,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(")") ) ) ; ___( psttTitle ) ;

                                                    TN( tb8 , "        " ) ;
                                                    TN( tb4 , "    " ) ;
                                                    if( !tAdam.csF( tin0P ) ) tAdam = TF2(((tin1S&)tin0P).pag1->idAdam,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
                                                    TN( tAdam , "" )       ; tAdam = T(mapAdam(((tin1S&)tin0P).pag1->idAdam)) ;

                                                    mapCTC& mapAdam = processGlobal4S::_processGlobal4I_IF().mapAdam ;
                                                {
                                                ZE( strokeS* , psttTitle ) ;
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN61 ) ;

                                                ((tin123S&)tin0P).time2    = timeBorn.time2 ;
                                                ((tin123S&)tin0P).time1    = timeBorn.time1 ;
                                                etThread.osTimeNowF( tin0P , timeBorn.time1 , timeBorn.time2 ) ;
                                                timeS timeBorn ;
                                                TELL( "main: informing ether of time and of process parameters" ) ;
            
                                                /*U:((thirdC&)ether).osRealtimeModeOnF( tin0P ) ;*/
                        
                                                etThread.delF( tin0P , psttDriverName ) ;
                                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN51 ) ;
                                                cryC cry213( ( TOCK << 1 ) + 0x13 ) ;
                                            {
                                            if( !ether )
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN41 ) ;
                
                                            cryC cry214( ( TOCK << 1 ) + 0x14 ) ;
                                            }
                                                bServiceManagerHiredMe = ifcDRIVERsTATUS_STARTING == ((thirdC&)ether).osDriverStatusF( tin0P , T(psttDriverName) ) ;
                                                etThread.osDriverNameFromMasterF( tin0P , psttDriverName , ifcIDaDAM_2GLASS2 ) ; ___( psttDriverName ) ;
                                                TELL( "main: setting bServiceManagerHiredMe" ) ;
                                            {
                                            if( ( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WITHINpROCESS ) && cHowP == 1 && bOsSupportsServices )
                                            ZE( strokeS* , psttDriverName ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN31 ) ;

                                            cryC cry0b( TOCK + 0x0b ) ;
                                            ((tin1S&)tin0P).pag1->pBksLog = new( 0 , tin0P , LF ) booksC( tin0P , TAG( TAGiDnULL ) , "log" , ifcIDsTATEsPACE_MULTIPLEaDAMS , flBOOKSc_WRITER , TOCK ) ; ___( ((tin1S&)tin0P).pag1->pBksLog ) ;
                                            cryC cry0a( TOCK + 0x0a ) ;
                                            TELL( "main: constructing log" ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN21 ) ;

                                            ((tin123S&)tin0P).tally.bTally = 1 ;
                                            ((tin123S&)tin0P).tally.nowF( tin0P , etThread ) ;
                                            ((tin123S&)tin0P).tally.resetF( tin0P ) ;
                        
                                            TELL( "main: " ) ;
                                            TELL( "main: ether and etThread constructed" ) ;
                                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN11 ) ;

                                            //etThread.traceF( tin0P , T("adamMainF / [idGroupFireAll]:    ")+TF2(((tin1S&)tin0P).pag1->idGroupFireAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            
                                            //__( ((tin123S&)tin0P).monitor.idThread - ifcIDtHREADlOW_main ) ;
                                            scoopC scoop( tin0P , LF , etThread ) ;
                                        {
                                        TELL( "constructed ((tin123S&)tin0P).pEtScratch" ) ;
                                        ((tin123S&)tin0P).pEtScratch = new( 0 , tin0P , LF ) etherC( tin0P , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ; ___( ((tin123S&)tin0P).pEtScratch ) ;
                                        TELL( "constructing ((tin123S&)tin0P).pEtScratch" ) ;
                                        TELL( "constructed etThread" ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN01 ) ;

                                        if( processGlobal2I.idNumaNode ) etThread.traceF( tin0P , T("NUMA:  this process will default to limiting itself to using a single NUMA node on NUMA computers [idNumaNode]: ")+TF2(processGlobal2I.idNumaNode,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                        //etThread.etherWhereF( tin0P , ifcIDaCTIONwHERE_WATCH ) ;
                                        //etThread.etherWhereF( tin0P , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
                                        //etThread.etherWhereF( tin0P , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , 1 ) ;
                                        //((tin123S&)tin0P).monitor.idWhat2 = - 1 ;
                                        //etThread.traceF( tin0P , T("enabling where") ) ;

                                        }
                                            if( pPoop ) ;
                                            poopC* pPoop = (poopC*)&(const poopC&)etThread ;
                                        {   //TO FACILITATE DEBUGGING (CAN SET A WATCHPOINT HERE TO BREAK WHEN pPoop->idSubType CHANGES)

                                        cryC cry09( TOCK + 0x09 ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINf ) ;
                                        ((tin1S&)tin0P).pag1->pEtThreadMain = ((tin123S&)tin0P).pEther = &etThread ;
                                        etherC etThread( tin0P , TAG( TAGiDnULL ) ) ;
                                        cryC cry08( TOCK + 0x08 ) ;
                                        TELL( "constructing etThread" ) ;
                                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINe ) ;
                                        _IO_
                                    {
                                    if( !ether )

                                    ((tin123S&)tin0P).pEther = &ether ;
        
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINd ) ;
                                    cryC cry07( TOCK + 0x07 ) ;

                                    _IO_        // MUST BE CT AFTER ether BECAUSE DT OF ether WILL DESTROY THE CURRENT tin0P
                                    //TELL( "constructed ether" ) ;
                                    //ether.traceF( tin0P , T("adamMainF / ct'd etPrime [&ether,&poop]:    ")+TF2((countT)&ether,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)&(const poopC&)ether,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    etherC ether( tin0P , TAG( TAGiDnULL ) , flTHIRDmODE_TINoWNER | flTHIRDmODE_QUITTER /* | flTHIRDmODE_CHECKpOOLoLD */ ) ; //DEBUGGING: TURN ON flTHIRDmODE_CHECKpOOLoLD HERE
                                    TELL( "constructing ether" ) ;
                                    cryC cry06( TOCK + 0x06 ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINc ) ;
        
                                    }
                                        //DELzOMBIE( pbnu ) ;
                                        //declareVmUsageTypeGF( tin0P , pbnu , flVMuSAGEtYPE_DEFAULThEAP ) ;
                                        //byteT* pbnu = new byteT ;
                                        //U::NOW THAT I AM IN base, THE NEXT LINE EXERCISES THE OVERLOAD SO DOES NOT WORK
                                    {
                                    declareVmUsageTypeGF( tin0P , (byteT*)declareVmUsageTypeGF , flVMuSAGEtYPE_CODEbASE ) ;
            
                                    ((tin123S&)tin0P).idlTask  = ifcLINE ;
                                    ((tin123S&)tin0P).idiTask  = DDNUMB ;
                                    putNegAM( ((tin123S&)tin0P).fingerprint , FINGERnEG_TINs ) ;
                                    ___( &tin0P ) ;                                          /*HERE*/
                                    TELL( "main: setting up" ) ;
                                    ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINb ) ;
                                    //_IO_  CANNOT DO THIS HERE, BECAUSE DT'OR FOR ether WILL DESTROY THE CURRENT tin0P
                                    TINSL
                                {
                                if( bTinOk )
                                //_IO_    CANNOT CT HERE, BECAUSE tin0P CURRENTLY REFERENCES THE PRIOR tin123S

                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAINa ) ;
                                cryC cry05( TOCK + 0x05 ) ;
                                }
                                    _MOLE
                                    TELL( "main: tin123S, in poolOld is constructed" ) ;_
                                    }
                                        TELLsYSlIFInAME( postName ) ; //THE TELLsYSlIFInAME MUST BE ON THE SAME LINE AS THE CONSTRUCTOR CALL
                                        bTinOk = 1 ;_
                                    {
                                    if( pTin ) // pTin WILL BE TAGGED AT /*HERE*/
                                    TINSL
                                    tin0S* pTin = new( 0 , tin0P , LF ) tin123S( tin0P , TAG( TAGiDnULL ) , ebpAM() , 0 , 0 , postName , flTINs_null , ((tin123S&)tin0P).monitor.idThread == 1 ? ifcIDtINnAMED_tinInPoolMain : ifcIDtINnAMED_tinInPool ) ;_
                                    osTextT* postName = POSTtHREADnAMEmAIN ;_
                                    _MILE
                                {
                                ZE( boolT , bTinOk ) ;
                                cryC cry04( TOCK + 0x04 ) ;
                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN9 ) ;
        
                                //boolT bWorkNotRoot = !!thirdC::c_strcmpIF( tin0P , ostoPoolAdamTemp , "root" ) ; /* HANDY FOR DEBUGGING */
        
                                }
                                    OStEXTAK( ostoPoolAdamTemp , "testAuto" )
                                    OStEXTcLEAR( ostoPoolAdamTemp )
                                {
                                else if( bTestAuto )
                                }
                                    //OStEXTAK( ostoPoolAdamTemp , "driver" )
                                    //OStEXTcLEAR( ostoPoolAdamTemp )
                                    //COMMENTED THIS OUT SO WILL USE LESS MEMORY, FOR SERVICE ON GODADDY VIRTUAL DEDICAED HOST THAT IS MEMORY CONSTRIAED
        
                                {
                                else if( cHowP == 1 ) //ASSUME: IF THERE ARE NO PARAMETERS THEN I WAS LAUNCHED BY THE WINDOWS SERVICE CONTROL MGR
                                }
                                    }
                                        OStEXTAK( ostoPoolAdamTemp , "testAuto" )
                                        OStEXTcLEAR( ostoPoolAdamTemp )
                                    {
                                    if( bTestAuto )
                                {
                                if( idTypeP == ifcIDtYPEtLS_WINDOW )
                                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN8 ) ;
                                _IO_
                            {
                            if( !POOP )
                            ZE( boolT , bServiceManagerHiredMe ) ; // 1 IFF THE O.S. SUPPORTS "SERVICES" AND I AM THE INSTANCE BEING STARTED BY THE SERVICE MANAGER; WILL BE 0 IF I AM THE IDEAFARM DRIVER ON AN OS THAT DOES NOT SUPPORT "SERVICES"

                            if( !thirdC::third_idProcessOldI_IF( tin0P ) ) thirdC::third_idProcessOldI_IF( tin0P ) = - 1 ;
                            
                            //thirdC::third_flagsModeAdam2I_IF(tin0P) |= flADAMmODE2_THREADcHATTER /*| flMODEpROCESS1_ NOsYSTEMtHREADS*/ ;
                            //U:: THE NEXT LINE, WHICH WAS COMMENTED OUT, CONTAINS A BUG (A PROCESS MODE FLAG)

                            cryC cry03( TOCK + 0x03 ) ;
                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN7 ) ;
                            }
                                #endif
                                    new( 0 , tin0P , pbPoolAdamTemp , sizeof pbPoolAdamTemp ) poolC( tin0P , TAG( TAGiDnULL ) , ostoPoolAdamTemp , sizeof( countT ) , flPOOLc_null  ) ; //MUST BE WOTH       20221228@1430: ADDED flPOOLc_DOnOTbLOCK (CHANGE OF PERSONALITY) SO THAT CODE CAN FAIL GRACEFULLY IF A DROP CANNOT BE ALLOCATED
                                #else
                                    new( 0 , tin0P , pbPoolAdamTemp , sizeof pbPoolAdamTemp ) poolC( tin0P , TAG( TAGiDnULL ) , ostoPoolAdamTemp , sizeof( countT ) , flPOOLc_NOTES ) ; //MUST BE WOTH       20221228@1430: ADDED flPOOLc_DOnOTbLOCK (CHANGE OF PERSONALITY) SO THAT CODE CAN FAIL GRACEFULLY IF A DROP CANNOT BE ALLOCATED
                                #if defined( ENABLEdROPnOTES )

                                tlsAllocStackExp_b_C tlsForMe( tin0P ) ;
                            {
                            poolC* pzPoolAdamTemp = (poolC*)pbPoolAdamTemp ;
                            byteT  pbPoolAdamTemp[ sizeof( poolC ) ] ;

                            //20221228@1601: flPOOLc_DOnOTbLOCK DEFINED BUT CANNOT BE USED BECAUSE CODE ASSUMES THAT ALLOCATION WILL SUCCEED, AND USING THIS NEW FLAG BREAKS THAT CODE (FOR EXAMPLE, ADAM FAILS SO CANNOT EVEN BUILD EVE TO FINISH BUILDING)

                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN6 ) ;
                            // UNDEFINE ENABLEdROPnOTES IN PRODUCTION AND WHEN NOT CHECKING FOR LEAKS
                            cryC cry02( TOCK + 0x02 ) ;
                            
                            //CS:CODEsYNC: 0b50064 0b50064 21b0002 21b0003
                            //WHEN A BUG IS LOCATED THAT IS DUE TO CODE OUT OF SYNC, EDIT CODE TO CONDITIONALLY COMPILE BASED ON WHETHER ENABLEdROPnOTES IS DEFINED
                            //20141026@1654: IGNORE THIS CS COMMENT; IT IS UNUSEABLE SINCE IT REFERENCES OBSOLETE MODULE NUMBERS (BEFORE ALL FILES IN DICTIONARY WERE RENUMBERED TO A NEW NUMBERING SCHEME YEARS AGO)
                            
                            //TO DEBUG FOR LEAKS OR TO USE poolC::reportF, ENABLE THE  FLAG HERE AND ALSO ENABLE THE DEFINITION OF THE "ENABLEdROPnOTES" SYMBOLIC CONSTANT
                            
                            //U:: ifcIDsTATEsPACE_MULTIPLEaDAMS: REMOVE IN PRODUCTION AND WHEN NOT INVESTIGATING LEAKAGE
                            
                            OStEXTC(  ostoPoolAdamTemp , ((tin123S&)tin0P).osPid , 0 )                   //20141129@1426: ADDED TO UNIQUIFY SO THAT MULTIPLE INSTANCES OF SAME idAdam CAN COEXIST
                            OStEXTAK( ostoPoolAdamTemp , "." )
                            OStEXTC(  ostoPoolAdamTemp , ((tin1S&)tin0P).pag1->idAdam , 0 )
                            OStEXTAK( ostoPoolAdamTemp , "adam.temp." )
                            OStEXT(   ostoPoolAdamTemp , TUCK << 2 )
                            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN5 ) ;
                        {
                        if( !POOP )
                        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN4 ) ;
                    {
                {
                cryC cry01( TOCK + 0x01 ) ;
                _IO_
                //QueryThreadCycleTime( (HANDLE)(-2) , (ULONG64*)&((tin123S&)tin0P).pc Utility04[ 0 ] ) ; //U:: TO FIND A BUG

                }
                    processGlobal1S::_processGlobal1I_IF().phExceptionHandler = 0         ;
                    processGlobal1S::_processGlobal1I_IF().phExceptionHandler->closeIfF() ;
                {
                if( processGlobal1S::_processGlobal1I_IF().phExceptionHandler && F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_DEBUG )

                }
                    }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!threadChatter"            ) ) { thirdC::third_flagsModeProcess2I_IF(   ) |= flMODEpROCESS2_CHATTERtHREADcTdT            ; }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!threadChatterAdam"        ) ) { thirdC::third_flagsModeAdam2I_IF( tin0P ) |= flADAMmODE2_THREADcHATTER                   ; }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!noSystemThreads"          ) ) { thirdC::third_flagsModeProcess1I_IF(   ) |= flMODEpROCESS1_NOsYSTEMtHREADS              ; }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!noInterprocessGrabs"      ) ) { thirdC::third_flagsModeAdam1I_IF( tin0P ) |= flADAMmODE1_DISALLOWgRABoFiNTERPROCESSgRABs ; }
                        //else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!utility0"               ) ) { ((tin123S&)tin0P).pc Utility[ 0 ] = 1 ; }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!utility"                  ) ) { thirdC::third_flagsModeProcess2I_IF(   ) |= flMODEpROCESS2_CHECKtINuTILITYeLEMENTS      ; }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!debug1"                   ) ) { thirdC::third_flagsModeAdam1I_IF( tin0P ) |= flADAMmODE1_DEBUG1                          ; }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!debug"                    ) ) { thirdC::third_flagsModeProcess1I_IF(   ) |= flMODEpROCESS1_DEBUG                        ; }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!jot"                      ) ) { thirdC::third_flagsModeProcess1I_IF(   ) |= flMODEpROCESS1_JOT                          ; }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!ignoreFireByOperator"     ) ) { thirdC::third_flagsModeProcess1I_IF(   ) |= flMODEpROCESS1_IGNOREfIREbYoPERATOR         ; }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!threadFiles"              ) ) { thirdC::third_flagsModeAdam1I_IF( tin0P ) |= flADAMmODE1_SEEtHREADSaSfILES               ; }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!quietConsole"             ) ) { thirdC::third_flagsModeAdam1I_IF( tin0P ) |= flADAMmODE1_QUIETcONSOLE                    ; } // WIN32 DOES NOT PROVIDE A WAY TO QUERY WHETHER THIS PROCESS IS ATTACHED TO A CONSOLE; CALLING system( cls ) WHEN NOT ATTACHED CAUSES A CONSOLE WINDOW TO MOMENTARILY APPEAR; THE WORKAROUND IS TO USE A CMD LINE PARAMETER; DETACHED PROCESSES THAT ALLOCATE A CONSOLE MUST MAINTAIN (RESET) THIS FLAG
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!testAuto"                 ) ) { bTestAuto      = 1 ; }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!idProcessOld"             ) ) { idArg          = 2 ; }
                        else if( !thirdC::c_strcmpIF( tin0P , ppostHowP[ idp - 1 ] , "!idTrial"                  ) ) { idArg          = 5 ; }
                        //CS:CODEsYNC: 33000065 33000065
                        }
                            }
                                case 5 : { idArg = 0 ; thirdC::third_idTrialI_IF( tin0P ) = thirdC::c_atoiIF( tin0P , ppostHowP[ idp - 1 ] ) ; break ; }
                                case 2 : { idArg = 0 ; thirdC::third_idProcessOldI_IF( tin0P ) = thirdC::c_atoiIF( tin0P , ppostHowP[ idp - 1 ] ) ; break ; }
                            {
                            switch( idArg )
                        {
                        if( idArg )
                    {
                    for( countT idp = 1 ; idp <= cHowP ; idp ++ )
                    ZE( countT , idArg ) ;
        
                    }
                        thirdC::third_flagsModeProcess1I_IF() |= flMODEpROCESS1_DRIVER ; //I WANT TO SET flMODEpROCESS1_DRIVER BIT AS SOON AS I KNOW THAT I AM THE DRIVER PROCESS, SO THAT I WILL GET POPUP IF AN EXCEPTION OCCURS
                        bPseudoService = 1 ;
                    {
                    else
                    }
                        thirdC::third_flagsModeProcess1I_IF() |= flMODEpROCESS1_DRIVER ; //I WANT TO SET flMODEpROCESS1_DRIVER BIT AS SOON AS I KNOW THAT I AM THE DRIVER PROCESS, SO THAT I WILL GET POPUP IF AN EXCEPTION OCCURS
                    {
                    else if( bOsSupportsServices )
                    if( cHowP > 1 ) ;
                    ZE( boolT , bPseudoService ) ;

                    }
                        ppostHowP = ppostHow ;
                        cHowP = cHow ;
        
                        }
                            }
                                if( ( !off || !postOldCopy[ off - 1 ] ) && postOldCopy[ off ] ) ppostHow[ cHow ++ ] = postOldCopy + off ;
        
                                if( !postOldCopy[ off ] ) continue ;
                            {
                            for( countT off = 0 ; off < costCopy && cHow < sizeof ppostHow / sizeof ppostHow[ 0 ] ; off ++ )
        
                            if( postOldCopy[ 1 ] != ':' ) ppostHow[ cHow ++ ] = postUnk ; //WINDOWS CMD.EXE DOES NOT INCLUDE THE EXE FILE NAME WITH THE PARAMETER LIST FOR GUI PROCESSES
        
                            }
                                }
                                    off ++ ;
                                    if( !bQuote && postOldCopy[ off ] == ' ' ) postOldCopy[ off ] = 0 ;
                                    if( postOldCopy[ off ] == 0x22 ) bQuote = !bQuote ;
                                {
                                while( cToDo -- )
                                ZE( countT , off ) ;
                                countT cToDo = costCopy ;
                                ZE( boolT , bQuote ) ;
                            {
                            const countT costCopy = thirdC::c_strlenIF( postOldCopy ) ;
                            thirdC::c_strncpyIF( postOldCopy , postP , sizeof postOldCopy ) ;
                            osTextT postOldCopy[ 0x200 ] ;
                        {
                        const osTextT* postUnk = idTypeP == ifcIDtYPEtLS_WINDOW ? postUnk1 : postUnk2 ;
                        static const osTextT* const postUnk2 = "<withinDadProcess>" ;
                        static const osTextT* const postUnk1 = "<exeNameNotAvailable>" ;
                        ZE( countT , cHow ) ;
                        _IO_
                    {
                    if( idTypeP == ifcIDtYPEtLS_WINDOW || idTypeP == ifcIDtYPEtLS_WITHINpROCESS )
                {
                const boolT bOsSupportsServices = osId == 'w' ;
                const osTextT osId = thirdC::osIdIF( tin0P ) ;
        
                ZE( boolT , bTestAuto ) ;
                ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN3 ) ;
            {
            ((tin1S&)tin0P).pag1->_etherC_.pHdll = &hDll ;
            handleC hDll( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DLL ) ; //MUST NOT BE CLOSED UNTIL tmWindowsF HAS ENDED, BECAUSE LATTER CAN CALL CALLBACK FUNCTIONS DEFINED IN THE ADAM
        
            }
                if( !thirdC::third_hWindowingClientIF( tin0P ) ) BLAMMO
                ((handleC&)thirdC::third_hWindowingClientIF( tin0P )).osF( ifcIDtYPEhANDLE_WINDOWINGcLIENT , hWindowingClientIP ) ;

                //BLAMMO ; //20120907@1304: TO PREVENT THE BLACK SCREEN THAT IGNORES ALL HUMAN INPUT BECAUSE THE GRAPHICS PRESENTATION SYSTEM IS BEING REWRITTEN
                //AllocConsole() ; //U::DO THIS IFF PARAMETER IS SPECIFIED !console
            {
            if( idTypeP == ifcIDtYPEtLS_WINDOW )

            //OStEXTcLEAR( _ostoTmp )
            //osTextC _ostRangerTag( _ostoTmp.costF() + 1 , _ostoTmp , _tlsBlobStatRangerTag , _tlsBlobStatRangerTag.cbF() ) ;
            //tlsBlobC _tlsBlobStatRangerTag( tin0P , "rangerTag" , "sys" , 2 * sizeof( countT ) + _ostoTmp.costF() + 1 , ifcIDtYPEtLSbLOBc_FOOT ) ;
            //tlsAllocStackExp_7_C tlsForMe( tin0P ) ;
            //OStEXTAK( _ostoTmp , "RangerTag:threadStack.tm1F.1" )
            //OStEXTAK( _ostoTmp , "!ifc" )
            //OStEXT(   _ostoTmp , 0x80 )

            etherC::paperZitsOffF( tin0P ) ;

            if( ((tin123S&)tin0P).monitor.idThread == 1 && !( ++ processGlobal2I.pcPhaseLow[ ((tin123S&)tin0P).monitor.idThread ] ) ) { BLAMMO ; }
            ((tin123S&)tin0P).flagsThreadMode3 |= flTHREADmODE3_ADAMmAINtHREAD ;
            const osTextT* ppostHow[ 0x10 ] ; //WILL BE FILLED WITH REFERENCES TO SNIPS IN postOldCopy; ppostHowP WILL BE SET TO ME, SO I MUST EXIST WHILE ppostHowP IS VISIBLE
            ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN2 ) ;
        {
        thirdC::dosPriorityIF( tin0P , ifcTHREADpRIORITY_NORMAL ) ;

        }
            if( pRegs ) ;
            poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;

            homeS& home = homeS::homeIF() ;
        {

        //((tin123S&)tin0P).pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
        _IO_

        //}
        //    }
        //        poolt( tin0P , pbt ) ;
        //        byteT* pbt = poolt.newF( tin0P , LF , cbWant ) ;
        //
        //        while( cDo -- ) cbWant <<= 1 ;
        //        countT cDo = expCb ;
        //        countT cbWant = 1 ;
        //    {
        //    for( countT expCb = 0 ; expCb < 0x1e ; expCb ++ )
        //    p oolC poolt( tin0P , TAG( TAGiDnULL ) , "test" , 0x10 ) ;
        //{
        //REMOVE THIS, OR MAKE IT A TESTER TO VERIFY THAT THIS MUCH MEMORY IS AVAILABLE

        cryC cry00( TOCK + 0x00 ) ;
        ADAMpHASE( ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 ) ;
    {
    cryC cry004( TOCK + 0xff ) ;
    cryC cry003( TOCK + 0xff ) ;
    cryC cry002( TOCK + 0xff ) ;
    cryC cry001( TOCK + 0xff ) ;

    //}
    //    etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , /*flTRACE_LOOP |*/ flTRACE_PARAMETERiSoStEXT ) ;
    //    OStEXTA(  ostoSay , postBaseName ) ;
    //    OStEXTAK( ostoSay , "    " ) ;
    //    OStEXTA(  ostoSay , postExeSuffix ) ;
    //    OStEXTAK( ostoSay , "adamMainF [postExeSuffix,postBaseName]:    " ) ;
    //    OStEXT(   ostoSay , TUCK << 0 ) ;
    //
    //    const osTextT* postBaseName  = thirdC::postBaseNameIF( tin0P ) ;
    //    const osTextT* postExeSuffix = thirdC::postExeFileSuffixIF() ; //U:: DELETE IN PROD
    //    const osTextT* postExe       = thirdC::postExeFileNameIF() ; //U:: DELETE IN PROD
    //
    //{
    //COMMENT OUT IN PROD

    //if( ((tin123S&)tin0P).monitor.idThread == 1 ) etherC::os_cAllKidThreadsI_IF( tin0P ) = BM_HIGH ; //U:: TO FIND A BUG
    ((etherC*)0)->traceF( tin0P , (strokeS*)"------------------------------------------------------------------------------------------------------------------------ adamMainF ++++" , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
{
/*1*/countT adamMainF( tin0S& tin0P , const countT idTypeP , countT cHowP , const osTextT** ppostHowP , countT hWindowingClientIP , countT hPreviousWindowingClientP , const osTextT* postP , countT idCmdShowP )/*1*/

//U::#define ADAMpHASE(idPhaseP) if( thirdC::third_idPhaseAdam_IF( tin0P ) < (idPhaseP) ) thirdC::third_idPhaseAdam_IF( tin0P ) = (idPhaseP)

#define ADAMpHASE(idPhaseP) if( thirdC::third_idPhaseAdam_IF( tin0P ) < (idPhaseP) ) { thirdC::third_idPhaseAdam_IF( tin0P ) = (idPhaseP) ; /*CONoUTrAW3( "[idPhase]: " , idPhaseP , "\r\n" ) ;*/ }

//U::MOVE TO SYMPOL DEF FILE

/**/
*/
/*
                                                   
//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

