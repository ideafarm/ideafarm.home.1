
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }

}
    tinP.pcUtility[ 1 ] ++ ;
    }
        TRACEcALLnEST( "ifcTHREADpRIORITY_LAZIEST 2" ) ;
        LOGcALLnEST(   "ifcTHREADpRIORITY_LAZIEST 2" ) ;
    {
    if( ifcTHREADpRIORITY_LAZIEST == thirdC::dosPriorityIF( tinP ) )
    tinP.pcUtility[ 1 ] ++ ;
{
if( tinP.pcUtility[ 0 ] )
//U:: TO FIND A BUG

        }
            say.dTimeCt      = say.cTime2      - say.cTime1      ;
            say.dCpuCyclesCt = say.cCpuCycles2 - say.cCpuCycles1 ;

            tinP.cTime2Or5Lath      = say.cTime2      ;
            tinP.cCpuCycles2Or5Lath = say.cCpuCycles2 ;

            }
                pDad->auditTime.dTimeAuditKidCt           += say.cTime2      - say.cTime1      ;
                pDad->auditCpuCycles.dCpuCyclesAuditKidCt += say.cCpuCycles2 - say.cCpuCycles1 ;
            {
            if( pDad )

            QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&say.cCpuCycles2 ) ;
            QueryPerformanceCounter( (LARGE_INTEGER*)&say.cTime2 ) ;
        {
        if( !( F(flagsCt) & flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY ) )

        //#endif
        //
        //    }
        //        THREADmODE5rESTORE
        //        PUSE.testDropHeadersF( tinP ) ;
        //        THREADmODE5oN( flTHREADmODE5_DOnOTtESTdROPhEADERS )
        //    {
        //    if( tinP.pag1->idAdam == ifcIDaDAM_ROOThTTPsERVER && !( F(tinP.flagsThreadMode5) & flTHREADmODE5_DOnOTtESTdROPhEADERS ) && tinP.pPoolUse )
        //
        //#if defined( ENABLEdROPnOTES )

        tinP.monitor.idWhat1 = ifcIDwHAT_GOiNoUTfRAMED ;_
        }
            _MOLE
            //}
            //    }
            //        BLAMMO ;_
            //        LOGrAW5( "_IO_ process global [valueExpectedByInOut,*pcWatchedByInOut]: " , pg1.valueExpectedByInOut , " != " , *pg1.pcWatchedByInOut , "\r\n" ) ;_
            //    {
            //    if( pg1.pcWatchedByInOut && *pg1.pcWatchedByInOut != pg1.valueExpectedByInOut )
            //    processGlobal2S& pg1 = processGlobal2S::_processGlobal2I_IF() ;_
            //{
            //
            //}
            //    BLAMMO ;_
            //    LOGrAW5( "_IO_ tinP [valueExpectedByInOut,*pcWatchedByInOut]: " , tinP.valueExpectedByInOut , " != " , *tinP.pcWatchedByInOut , "\r\n" ) ;_
            //{
            //if( tinP.pcWatchedByInOut && *tinP.pcWatchedByInOut != tinP.valueExpectedByInOut )
            //
            //}
            //    }
            //        BLAMMO ;_
            //        /*LOGrAW3( "_IO_ / !this [idiFileCt]" , idiFileCt , "\r\n" ) ;*/
            //    {
            //    if( !c_this )
            //    countT c_this = (countT)this ;_
            //{
            //if( bClassP )

            }
                }
                    }
                        thirdC::dosSleepRawIF( tinP , TUCK ) ;
                        
                        }
                            //CONoUTrAW( "\r\nstop\r\n" ) ;
                            //LOGrAW( "\r\nstop\r\n" ) ;
                            bWoth = 0 ;_
                        {
                        if( bWoth )
                    {
                    )
                        !( F(tinP.flagsThreadMode4) & flTHREADmODE4_GO )
                        &&
                        F(tinP.pag1->_thirdC_.flagsModeAdam2) & flADAMmODE2_STOP
                        &&
                        thirdC::third_idPhaseProcess_IF() <  ifcIDpHASEpROCESS_EPILOGdESTROYINGgLOBALS
                        &&
                        thirdC::third_idPhaseProcess_IF() >= ifcIDpHASEpROCESS_PROLOGaLLgLOBALScONSTRUCTED
                    (
                    while
                    boolT bWoth = 1 ;                                                                                               // OBEY flADAMmODE2_STOP AND flTHREADmODE4_GO
                {
                if( tinP.idTinNamed != ifcIDtINnAMED_tinHeartI && tinP.idTinNamed != ifcIDtINnAMED_tinBreakI && thirdC::third_idPhaseProcess_IF() >= ifcIDpHASEpROCESS_PROLOGaLLgLOBALScONSTRUCTED && thirdC::third_idPhaseProcess_IF() < ifcIDpHASEpROCESS_EPILOGdESTROYINGgLOBALS )

                tinP.monitor.idWhat2 = idiFileCt >> 0xc ;_

                thirdC::inOutChatterIfIF( tinP ) ;_

                }
                    tinP.bSuppressInOutTrace -- ;_
                    }
                        //U::SUSPECTED DEADLOCK: ((etherC*)0)->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;_

                        }
                            OStEXTA( ostoSay , postTitle ) ;_
                        {
                        if( postTitle )
                        const osTextT* postTitle = processGlobal8S::_processGlobal8I_IF().source.postFileTitleF( tinP , processGlobal8S::_processGlobal8I_IF().source.idFileRankF( tinP , idiFileCt ) ) ;_
                        OStEXTAK( ostoSay , ") ++    " ) ;_
                        OStEXTC9( ostoSay , idLineCt ) ;_
                        OStEXTAK( ostoSay , "(" ) ;_
                        OStEXTC(  ostoSay , idiFileCt , 0 ) ;_
                        OStEXT(   ostoSay , TUCK << 1 ) ;_
                    {
                    if( !( tinP.bSuppressInOutTrace ++ ) && tinP.monitor.idThread != ifcIDtHREADlOW_tmHeartF && tinP.monitor.idThread != ifcIDtHREADlOW_break && tinP.monitor.idThread != ifcIDtHREADlOW_tmKillSocketF && tinP.monitor.idThread != ifcIDtHREADlOW_tmWatchF && tinP.monitor.idThread != ifcIDtHREADlOW_tmTimeNowF )
                {
                if( ph && ph->flags & F(flHOMEs_INoUTtRACE) )

                }
                    }
                        }
                            if( -1 == incv02AM( ph->pcTallyIn[ offt ] ) ) bCarry ++ ;_
                        {
                        while( cDo -- )
                        if( bCarry ) bCarry = 0 ;_
                        countT cDo = !offt + bCarry ;_
                    {
                    for( countT offt = 0 ; offt < sizeof ph->pcTallyIn / sizeof ph->pcTallyIn[ 0 ] ; offt ++ )
                    ZE( boolT , bCarry ) ;_
                {
                if( ph )

                homeS* ph = &homeS::homeIF() ;_

                tinP.monitor.idDirty ++ ;_

                                                  eipF( &tinP.pEIPInNest[ offon ] ) ;_
                eipInNestSave               =            tinP.pEIPInNest[ offon ]   ;_

                tinP.pIdInNest[ offonk    ] = 0 ;_
                tinP.pIdInNest[ offon     ] ++ ;_

                tinP.pLFstep  [ offos2 + 1 ] =           tinP.monitor.pLFnest      [ offon2 + 1 ] = idiFileCt                                                       ;_
                idFileNestSave               =           tinP.monitor.pLFnest      [ offon2 + 1 ]                                                                   ;_

                tinP.pLFstep  [ offos2     ] =      (    tinP.monitor.pLFnest      [ offon2     ] = idLineCt & ~fliSTEP_FLAGmASK    )    |    fliSTEP_NESTcHANGE    ;_
                idLineNestSave               =           tinP.monitor.pLFnest      [ offon2     ]                                                                   ;_

                pFlagsThreadLevelModeSave    =           tinP.pFlagsThreadLevelMode[ offon ]                                                                       ;_
                idProgressNestSave           =           tinP.pIdProgressNest      [ offon ]                                                                       ;_

                const countT offonk = ( tinP.monitor.cInNest + 1 ) & OFFsLOTtINnESTmAX ; // "k" IS FOR "KID"
                const countT offon  = tinP.monitor.cInNest & OFFsLOTtINnESTmAX ; const countT offon2 = offon << 1 ;_
                const countT offos  = tinP.monitor.idStep  & OFFsLOTtINsTEPmAX ; const countT offos2 = offos << 1 ;_

                tinP.monitor.cInNest ++ ;_
                tinP.monitor.idStep ++ ;_
                tinP.monitor.idDirty ++ ;_
            {
            if( F(tinP.flagsThreadMode2) & flTHREADmODE2_UPDATEtIN && !( tinP.monitor.idDirty % 2 ) )
            _MILE
        {
        if( F(flagsCt) & flINoUTfRAMEc_REGISTERcALLnEST )
        tinP.monitor.idWhat1 = ifcIDwHAT_GOiNoUTcT ;_

        }
            }
                BLAMMO ;
                LOGrAW(    "inOutFrameC: error fingerprint\r\n" ) ;
                CONoUTrAW( "inOutFrameC: error fingerprint\r\n" ) ;

                //U:: CONJ: OBSOLETE CODE LINE: *(countT*)0 = 1 ;       // CANNOT USE BLAMMO BECAUSE DON'T HAVE tinP
            {
            if( getNegAM( pTin->fingerprint ) != FINGERnEG_TINs && getNegAM( pTin->fingerprint ) != FINGERnEG_TINszOMBIE )      //CT OF WOTH tinS INSTANCE IN EACH THREAD INVOLVES CALLING INOUT BEFORE ZOMBIE FINGERPRINT IS REPLACED
            }
                BLAMMO ;
                LOGrAW(    "inOutFrameC: error !pTin\r\n" ) ;
                CONoUTrAW( "inOutFrameC: error !pTin\r\n" ) ;
            {
            if( !pTin )
            tinS* pTin = &tinP ;
        {

        }
            if( pHome && F(pHome->flags) & flHOMEs_KILLsELFiMMEDIATELY ) { *(countT*)0 = 1 ; }
            homeS* pHome = &homeS::homeIF() ;
        {

        }
            say.dTimeB4      = !pDad ? 0 : say.cTime1      - tinP.cTime2Or5Lath      ;
            say.dCpuCyclesB4 = !pDad ? 0 : say.cCpuCycles1 - tinP.cCpuCycles2Or5Lath ;

            }
                pDad->auditTime     .dTimeAuditKidBetween      += say.cTime1      - tinP.cTime2Or5Lath      ;
                pDad->auditCpuCycles.dCpuCyclesAuditKidBetween += say.cCpuCycles1 - tinP.cCpuCycles2Or5Lath ;
            {
            if( pDad )
            processGlobal1I.trueRandom ^= (countT)say.cCpuCycles1 ;
            QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&say.cCpuCycles1 ) ;
            QueryPerformanceCounter( (LARGE_INTEGER*)&say.cTime1 ) ;
        {
        if( !( F(flagsCt) & flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY ) )

        }
            }
#endif
                ^= (countT)( cycles ^ cycles << 0x10 ^ cycles << 0x20 ^ cycles << 0x30 ) ;
                )
                        : processGlobal1I.trueRandom
                        ? processGlobal1I.pSlab->trueRandom
                    processGlobal1I.pSlab
                (
#else

                }
                    thirdC::dosWriteStdOutIF( ostoBuf ) ;
                    OStEXTA(  ostoBuf , "\r\n" ) ;
                    OStEXTCF( ostoBuf , trueRandom , '0' ) ;
                    OStEXTA(  ostoBuf , "\r\n" ) ;
                    OStEXT(   ostoBuf , 0x140 )
                {
                if( processGlobal1I.idAdamRoot == 0x51012002 )
                //CONoUTrAW3( "\r\n" , trueRandom , "\r\n" ) ;
                trueRandom ^= (countT)cycles ;

                ;
                    : processGlobal1I.trueRandom
                    ? processGlobal1I.pSlab->trueRandom
                countT& trueRandom = processGlobal1I.pSlab

#if defined( NEVERdEFINED )

                QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&cycles ) ;
                processGlobal1I.trueRandom ^= (countT)cycles ;              //INTENTIONAL USE OF UNINITIALIZED SOURCE DATA
                count04T cycles ;
            {
            //if( !( cIn ++ % ( TUCK >> 3 ) ) )       // THIS IS ONLY GOING TO "LOOK" RANDOM IF THERE ARE MANY THREADS DOING THIS ACTIVELY
            //static countT cIn ;
        {

        say.idiFileInOut = idiFileP ;
        say.idLineInOut  = idLineP ;

        //}
        //    }
        //        }
        //            countT foo = 2 ;
        //        {
        //        if( cNest > TUCK )
        //        cNest ++ ;
        //
        //        pc = pc->pDad ;
        //    {
        //    while( pc->pDad )
        //    inOutFrameC* pc = tinP.pInOutFrame ;
        //    ZE( countT , cNest ) ;
        //{

        if( F(processGlobal2I._thirdC_flagsModeProcess1) & flMODEpROCESS1_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY ) { BLAMMO ; } //U:: THIS FLAG CANNOT BE SUPPORTED UNTIL CODE THAT MUST SUPPRESS inOutFrameC APP TELEMETRY IGNORES IT ; THIS COULD BE DONE WITH A NEW THREAD MODE FLAG

        // if( processGlobal1I.pHome && tinP.pc Utility[ 0 ] ) { *(countT*)0 = 0x1234 ; }

        }
            //}
            //    CONoUTrAW5( "\r\ninOutFrameC thread stack max usage [idThread,usedPerTuck]:    " , tinP.monitor.idThread , "    " , usedPerTuck , "\r\n" ) ;
            //    countT usedPerTuck = cbStackUsed * 0x100 / cbStackAll ;
            //    countT cbStackUsed = tinP.pbThreadStackEnd - tinP.pbThreadStackLowest ;
            //    countT cbStackAll  = tinP.pbThreadStackEnd - tinP.pbThreadStackStart ;
            //{
            //if( !( idIn % TICK ) && tinP.pbThreadStackStart && tinP.pbThreadStackEnd >= tinP.pbThreadStackStart )
            countT idIn = ++ idInLath ; // COLLISIONS CAN OCCUR SINCE NOT USING incv02AM() (FOR SPEED)
            static countT idInLath ;

            if( pbEbp <  tinP.pbThreadStackLowest ) tinP.pbThreadStackLowest = pbEbp ;
            //if( pbEbp >= tinP.pbThreadStackEnd    ) { BLAMMO ; }
            //if( pbEbp <  tinP.pbThreadStackStart  ) { BLAMMO ; }
            const byteT* pbEbp = (const byteT*)ebpAM() ;
        {

}
    tinP.pcUtility[ 1 ] ++ ;
    }
        TRACEcALLnEST( "ifcTHREADpRIORITY_LAZIEST 1" ) ;
        LOGcALLnEST(   "ifcTHREADpRIORITY_LAZIEST 1" ) ;
    {
    if( ifcTHREADpRIORITY_LAZIEST == thirdC::dosPriorityIF( tinP ) )
    tinP.pcUtility[ 1 ] ++ ;
{
if( tinP.pcUtility[ 0 ] )
//U:: TO FIND A BUG

        tinP.pInOutFrame = this ;
    {
    //if( !( F(thirdC::third_flagsModeProcess2I_IF()) & flMODEpROCESS2_SUPPRESSiNoUTfRAMEc ) )
{
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles4
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles3
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles2
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles1
//INTENTIONALLY UNINITIALIZED FOR SPEED: pFlagsThreadLevelModeSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: idProgressNestSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: eipInNestSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: idLineNestSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: idFileNestSave
idWhat2Save( tinP.monitor.idWhat2 )
idWhat1Save( tinP.monitor.idWhat1 ) ,
) ,
    )
                        //: flINoUTfRAMEc_null                            //TO ENABLE  GENERALLY  (ENABLE THIS LINE IN PRODUCTION IFF WANT FULL TIME TELEMETRY)
                        : flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY          //TO DISABLE GENERALLY  (ENABLE THIS LINE IN PRODUCTION IFF WANT MAXIMUM SPEED)

                        ? flINoUTfRAMEc_null
                    : processGlobal1I.idAdamRoot == 0 /*ifcIDaDAM_SCRATCH07*/      //THIS LINE  ENABLES TELEMETRY FOR THE SPECIFIED ADAM (IF NOT 0)
                    ? flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY
                )
                  || processGlobal1I.idAdamRoot == 0 /*ifcIDaDAM_SCRATCH08*/       //THIS LINE DISABLES TELEMETRY FOR THE SPECIFIED ADAM (IF NOT 0)
                  || F(processGlobal2I._thirdC_flagsModeProcess1) & flMODEpROCESS1_INoUTfRAMEdOnOTcOLLECTaPPtELEMETRY
                     F(tinP.flagsThreadMode5) & flTHREADmODE5_INoUTfRAMEdOnOTcOLLECTaPPtELEMETRY
                (
                :
                ? flINoUTfRAMEc_null
            : F(tinP.flagsThreadMode5) & flTHREADmODE5_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY
            ? flINoUTfRAMEc_null
        F(processGlobal2I._thirdC_flagsModeProcess1) & flMODEpROCESS1_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY             // CS:CODEsYNC: 360cc003 3612c003: "TICK >> 0" IS NEEDED IF flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY IS EVER NOT USED (SEE inOutFrameC CT'OR)
    (
    |
    )
        : flINoUTfRAMEc_null
        ? flINoUTfRAMEc_DEFERwRITINGaPPtELEMETRY
    ( F(tinP.flagsThreadMode5) & flTHREADmODE5_INoUTfRAMEdEFERwRITINGaPPtELEMETRY
    |
    )
        : flINoUTfRAMEc_null
        ? flINoUTfRAMEc_REGISTERcALLnEST
    ( F(tinP.flagsThreadMode4) & flTHREADmODE4_INoUTfRAMErEGISTERcALLnEST
(
flagsCt
idFileRankCt( idFileRankP ) ,
idiFileCt( idiFileP ) ,
idLineCt( idLineP ) ,
tinCt( tinP ) ,
pDad( tinP.pInOutFrame ) ,
/*1*/inOutFrameC::inOutFrameC( tinS& tinP , const countT idLineP , const countT idiFileP , const countT idFileRankP , const boolT bClassP ) :/*1*/

/* ASSUME: 02 BITS PER countT */

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

