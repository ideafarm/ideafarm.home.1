
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
//}
//    tin1P.pc Utility[ 1 ] ++ ;
//    }
//        TRACEcALLnEST( "ifcTHREADpRIORITY_LAZIEST 2" ) ;
//        LOGcALLnEST(   "ifcTHREADpRIORITY_LAZIEST 2" ) ;
//    {
//    if( ifcTHREADpRIORITY_LAZIEST == thirdC::dosPriorityIF( tin0P ) )
//    tin1P.pc Utility[ 1 ] ++ ;
//{
//if( tin1P.pc Utility[ 0 ] )
//U:: TO FIND A BUG

        }
            say.dTimeCt      = say.cTime2      - say.cTime1      ;
            say.dCpuCyclesCt = say.cCpuCycles2 - say.cCpuCycles1 ;

            tin12P.cTime2Or5Lath      = say.cTime2      ;
            tin12P.cCpuCycles2Or5Lath = say.cCpuCycles2 ;

            }
                pDad->auditTime.dTimeAuditKidCt           += say.cTime2      - say.cTime1      ;
                pDad->auditCpuCycles.dCpuCyclesAuditKidCt += say.cCpuCycles2 - say.cCpuCycles1 ;
            {
            if( pDad )

            QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&say.cCpuCycles2 ) ;
            QueryPerformanceCounter( (LARGE_INTEGER*)&say.cTime2 ) ;
        {
        if( !( F(flagsCt) & flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY ) )

        //#endif
        //
        //    }
        //        THREADmODE4rESTORE
        //        PUSE.testDropHeadersF( tin0P ) ;
        //        THREADmODE4oN( flTHREADmODE4_DOnOTtESTdROPhEADERS )
        //    {
        //    if( tin1P.pag1->idAdam == ifcIDaDAM_ROOThTTPsERVER && !( F(tin1P.flagsThreadMode4) & flTHREADmODE4_DOnOTtESTdROPhEADERS ) && tin1P.pPoolUse )
        //
        //#if defined( ENABLEdROPnOTES )

        tin123P.where.idWhat1 = ifcIDwHAT_GOiNoUTfRAMED ;_
        }
            _MOLE
            //}
            //    }
            //        BLAMMO ;_
            //        LOGrAW5( "_IO_ process global [valueExpectedByInOut,*pcWatchedByInOut]: " , pg1.valueExpectedByInOut , " != " , *pg1.pcWatchedByInOut , "\r\n" ) ;_
            //    {
            //    if( pg1.pcWatchedByInOut && *pg1.pcWatchedByInOut != pg1.valueExpectedByInOut )
            //    processGlobal2S& pg1 = processGlobal2S::_processGlobal2I_IF() ;_
            //{
            //
            //}
            //    BLAMMO ;_
            //    LOGrAW5( "_IO_ tin0P [valueExpectedByInOut,*pcWatchedByInOut]: " , tin1P.valueExpectedByInOut , " != " , *tin1P.pcWatchedByInOut , "\r\n" ) ;_
            //{
            //if( tin1P.pcWatchedByInOut && *tin1P.pcWatchedByInOut != tin1P.valueExpectedByInOut )
            //
            //}
            //    }
            //        BLAMMO ;_
            //        /*LOGrAW3( "_IO_ / !this [idiFileCt]" , idiFileCt , "\r\n" ) ;*/
            //    {
            //    if( !c_this )
            //    countT c_this = (countT)this ;_
            //{
            //if( bClassP )

            }
                }
                    }
                        thirdC::dosSleepRawIF( tin0P , TUCK ) ;
                        
                        }
                            //CONoUTrAW( "\r\nstop\r\n" ) ;
                            //LOGrAW( "\r\nstop\r\n" ) ;
                            bWoth = 0 ;_
                        {
                        if( bWoth )
                    {
                    )
                        !( F(tin1P.flagsThreadMode3) & flTHREADmODE3_GO )
                        &&
                        F(tin1P.pag1->_thirdC_.flagsModeAdam2) & flADAMmODE2_STOP
                        &&
                        thirdC::third_idPhaseProcess_IF() <  ifcIDpHASEpROCESS_EPILOGdESTROYINGgLOBALS
                        &&
                        thirdC::third_idPhaseProcess_IF() >= ifcIDpHASEpROCESS_PROLOGaLLgLOBALScONSTRUCTED
                    (
                    while
                    boolT bWoth = 1 ;                                                                                               // OBEY flADAMmODE2_STOP AND flTHREADmODE3_GO
                {
                if( tin1P.idTinNamed != ifcIDtINnAMED_tinHeartI && tin1P.idTinNamed != ifcIDtINnAMED_tinBreakI && thirdC::third_idPhaseProcess_IF() >= ifcIDpHASEpROCESS_PROLOGaLLgLOBALScONSTRUCTED && thirdC::third_idPhaseProcess_IF() < ifcIDpHASEpROCESS_EPILOGdESTROYINGgLOBALS )

                tin123P.where.idWhat2 = idiFileCt >> 0xc ;_

                thirdC::inOutChatterIfIF( tin0P ) ;_

                }
                    tin1P.bSuppressInOutTrace -- ;_
                    }
                        //U::SUSPECTED DEADLOCK: ((etherC*)0)->traceF( tin0P , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;_

                        }
                            OStEXTA( ostoSay , postTitle ) ;_
                        {
                        if( postTitle )
                        const osTextT* postTitle = processGlobal8S::_processGlobal8I_IF().source.postFileTitleF( tin0P , processGlobal8S::_processGlobal8I_IF().source.idFileRankF( tin0P , idiFileCt ) ) ;_
                        OStEXTAK( ostoSay , ") ++    " ) ;_
                        OStEXTC9( ostoSay , idLineCt ) ;_
                        OStEXTAK( ostoSay , "(" ) ;_
                        OStEXTC(  ostoSay , idiFileCt , 0 ) ;_
                        OStEXT(   ostoSay , TUCK << 1 ) ;_
                    {
                    if( !( tin1P.bSuppressInOutTrace ++ ) && tin1P.glass.idThread != ifcIDtHREADlOW_tmHeartF && tin1P.glass.idThread != ifcIDtHREADlOW_break && tin1P.glass.idThread != ifcIDtHREADlOW_tmKillSocketF && tin1P.glass.idThread != ifcIDtHREADlOW_tmWatchF && tin1P.glass.idThread != ifcIDtHREADlOW_tmWatchRudeF && tin1P.glass.idThread != ifcIDtHREADlOW_tmTimeNowF )
                {
                if( ph && ph->flags & F(flHOMEs_INoUTtRACE) )

                }
                    }
                        }
                            if( -1 == incv02AM( ph->pcTallyIn[ offt ] ) ) bCarry ++ ;_
                        {
                        while( cDo -- )
                        if( bCarry ) bCarry = 0 ;_
                        countT cDo = !offt + bCarry ;_
                    {
                    for( countT offt = 0 ; offt < sizeof ph->pcTallyIn / sizeof ph->pcTallyIn[ 0 ] ; offt ++ )
                    ZE( boolT , bCarry ) ;_
                {
                if( ph )

                homeS* ph = &homeS::homeIF() ;_

                tin123P.where.idDirty ++ ;_

                                                  eipF( &tin123P.pEIPInNest[ offon ] ) ;_
                eipInNestSave               =            tin123P.pEIPInNest[ offon ]   ;_

                tin123P.pIdInNest[ offonk    ] = 0 ;_
                tin123P.pIdInNest[ offon     ] ++ ;_

                tin123P.pLFstep  [ offos2 + 1 ] =           tin123P.where.pLFnest      [ offon2 + 1 ] = idiFileCt                                                       ;_
                idFileNestSave               =           tin123P.where.pLFnest      [ offon2 + 1 ]                                                                   ;_

                tin123P.pLFstep  [ offos2     ] =      (    tin123P.where.pLFnest      [ offon2     ] = idLineCt & ~fliSTEP_FLAGmASK    )    |    fliSTEP_NESTcHANGE    ;_
                idLineNestSave               =           tin123P.where.pLFnest      [ offon2     ]                                                                   ;_

                pFlagsThreadLevelModeSave    =           tin123P.pFlagsThreadLevelMode[ offon ]                                                                       ;_
                idProgressNestSave           =           tin123P.pIdProgressNest      [ offon ]                                                                       ;_

                const countT offonk = ( tin123P.where.cInNest + 1 ) & OFFsLOTtINnESTmAX ; // "k" IS FOR "KID"
                const countT offon  = tin123P.where.cInNest & OFFsLOTtINnESTmAX ; const countT offon2 = offon << 1 ;_
                const countT offos  = tin1P.glass.idStep  & OFFsLOTtINsTEPmAX ; const countT offos2 = offos << 1 ;_

                tin123P.where.cInNest ++ ;_
                tin1P.glass.idStep ++ ;_
                tin123P.where.idDirty ++ ;_
            {
            if( tin0P.idTypeTin == ifcIDtYPEtIN_123 && F(tin1P.flagsThreadMode1) & flTHREADmODE1_UPDATEtIN && !( tin123P.where.idDirty % 2 ) )
            _MILE
        {
        if( F(flagsCt) & flINoUTfRAMEc_REGISTERcALLnEST )
        tin123P.where.idWhat1 = ifcIDwHAT_GOiNoUTcT ;_

        }
            }
                BLAMMO ;
                LOGrAW(    "inOutFrameC: error fingerprint\r\n" ) ;
                CONoUTrAW( "inOutFrameC: error fingerprint\r\n" ) ;

                //U:: CONJ: OBSOLETE CODE LINE: *(countT*)0 = 1 ;       // CANNOT USE BLAMMO BECAUSE DON'T HAVE tin0P
            {
            if( getNegAM( ((tin123S*)pTin)->fingerprint ) != FINGERnEG_TINs && getNegAM( ((tin123S*)pTin)->fingerprint ) != FINGERnEG_TINszOMBIE )      //CT OF WOTH tin123S INSTANCE IN EACH THREAD INVOLVES CALLING INOUT BEFORE ZOMBIE FINGERPRINT IS REPLACED
            }
                BLAMMO ;
                LOGrAW(    "inOutFrameC: error !pTin\r\n" ) ;
                CONoUTrAW( "inOutFrameC: error !pTin\r\n" ) ;
            {
            if( !pTin )
            tin0S* pTin = &tin0P ;
        {

        }
            if( pHome && F(pHome->flags) & flHOMEs_KILLsELFiMMEDIATELY ) { *(countT*)0 = 1 ; }
            homeS* pHome = &homeS::homeIF() ;
        {

        }
            say.dTimeB4      = !pDad ? 0 : say.cTime1      - tin12P.cTime2Or5Lath      ;
            say.dCpuCyclesB4 = !pDad ? 0 : say.cCpuCycles1 - tin12P.cCpuCycles2Or5Lath ;

            }
                pDad->auditTime     .dTimeAuditKidBetween      += say.cTime1      - tin12P.cTime2Or5Lath      ;
                pDad->auditCpuCycles.dCpuCyclesAuditKidBetween += say.cCpuCycles1 - tin12P.cCpuCycles2Or5Lath ;
            {
            if( pDad )
            processGlobal1I.trueRandom ^= (countT)say.cCpuCycles1 ;
            QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&say.cCpuCycles1 ) ;
            QueryPerformanceCounter( (LARGE_INTEGER*)&say.cTime1 ) ;
        {
        if( !( F(flagsCt) & flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY ) )

        }
            }
#endif
                ^= (countT)( cycles ^ cycles << 0x10 ^ cycles << 0x20 ^ cycles << 0x30 ) ;
                )
                        : processGlobal1I.trueRandom
                        ? processGlobal1I.pSlab->trueRandom
                    processGlobal1I.pSlab
                (
#else

                }
                    thirdC::dosWriteStdOutIF( ostoBuf ) ;
                    OStEXTA(  ostoBuf , "\r\n" ) ;
                    OStEXTCF( ostoBuf , trueRandom , '0' ) ;
                    OStEXTA(  ostoBuf , "\r\n" ) ;
                    OStEXT(   ostoBuf , 0x140 )
                {
                if( processGlobal1I.idAdamRoot == 0x51012002 )
                //CONoUTrAW3( "\r\n" , trueRandom , "\r\n" ) ;
                trueRandom ^= (countT)cycles ;

                ;
                    : processGlobal1I.trueRandom
                    ? processGlobal1I.pSlab->trueRandom
                countT& trueRandom = processGlobal1I.pSlab

#if defined( NEVERdEFINED )

                QueryThreadCycleTime( (HANDLE)(-2) ,  (ULONG64*)&cycles ) ;
                processGlobal1I.trueRandom ^= (countT)cycles ;              //INTENTIONAL USE OF UNINITIALIZED SOURCE DATA
                count04T cycles ;
            {
            //if( !( cIn ++ % ( TUCK >> 3 ) ) )       // THIS IS ONLY GOING TO "LOOK" RANDOM IF THERE ARE MANY THREADS DOING THIS ACTIVELY
            //static countT cIn ;
        {

        say.idiFileInOut = idiFileP ;
        say.idLineInOut  = idLineP ;

        //}
        //    }
        //        }
        //            countT foo = 2 ;
        //        {
        //        if( cNest > TUCK )
        //        cNest ++ ;
        //
        //        pc = pc->pDad ;
        //    {
        //    while( pc->pDad )
        //    inOutFrameC* pc = tin1P.pInOutFrame ;
        //    ZE( countT , cNest ) ;
        //{

        if( F(processGlobal2I._thirdC_flagsModeProcess1) & flMODEpROCESS1_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY ) { BLAMMO ; } //U:: THIS FLAG CANNOT BE SUPPORTED UNTIL CODE THAT MUST SUPPRESS inOutFrameC APP TELEMETRY IGNORES IT ; THIS COULD BE DONE WITH A NEW THREAD MODE FLAG

        // if( processGlobal1I.pHome && tin1P.pc Utility[ 0 ] ) { *(countT*)0 = 0x1234 ; }

        }
            //}
            //    CONoUTrAW5( "\r\ninOutFrameC thread stack max usage [idThread,usedPerTuck]:    " , tin1P.glass.idThread , "    " , usedPerTuck , "\r\n" ) ;
            //    countT usedPerTuck = cbStackUsed * 0x100 / cbStackAll ;
            //    countT cbStackUsed = tin1P.pbThreadStackEnd - tin1P.pbThreadStackLowest ;
            //    countT cbStackAll  = tin1P.pbThreadStackEnd - tin1P.pbThreadStackStart ;
            //{
            //if( !( idIn % TICK ) && tin1P.pbThreadStackStart && tin1P.pbThreadStackEnd >= tin1P.pbThreadStackStart )
            //countT idIn = ++ idInLath ; // COLLISIONS CAN OCCUR SINCE NOT USING incv02AM() (FOR SPEED)
            //static countT idInLath ;
        {
        if( tin1P.idTinNamed != ifcIDtINnAMED_tinHeartI && tin1P.idTinNamed != ifcIDtINnAMED_tinBreakI )

//}
//    tin1P.pc Utility[ 1 ] ++ ;
//    }
//        TRACEcALLnEST( "ifcTHREADpRIORITY_LAZIEST 1" ) ;
//        LOGcALLnEST(   "ifcTHREADpRIORITY_LAZIEST 1" ) ;
//    {
//    if( ifcTHREADpRIORITY_LAZIEST == thirdC::dosPriorityIF( tin0P ) )
//    tin1P.pc Utility[ 1 ] ++ ;
//{
//if( tin1P.pc Utility[ 0 ] )
//U:: TO FIND A BUG

        tin1P.pInOutFrame = this ;
    {
    if( !( F(thirdC::third_flagsModeProcess2I_IF()) & flMODEpROCESS2_SUPPRESSiNoUTfRAMEc ) )

    }
        }
            }
                }
                    THREADmODE3rESTORE
                    }
                        //USES TOO MUCH THREAD STACK: ((etherC*)0)->traceF( tin0P , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;_

                        CONoUTrAW( ostoSay ) ;

                        OStEXTAK( ostoSay , "\r\n" ) ;_
                        OStEXTC(  ostoSay , perTuckAvailable , 0 ) ;_
                        OStEXTAK( ostoSay , "    " ) ;_
                        OStEXTC(  ostoSay , cbStack , '0' ) ;_
                        OStEXTAK( ostoSay , "_9    " ) ;_
                        OStEXTC9( ostoSay , tin1P.osTid ) ;_
                        OStEXTAK( ostoSay , "\r\nthread stack [osTid,cbStack,perTuckAvailable]:    " ) ;_
                        OStEXT(   ostoSay , TUCK >> 1 ) ;_
                    {
                    THREADmODE3oN( flTHREADmODE3_SUPPRESStHREADsTACKuSAGEiNSPECTION )
                {
                if( perTuckAvailable < 0x20 )
                //G:if( perTuckAvailable < 0x18 )
                //B:TOO SHALLOW (WORKS, BUT PRACTICALLY NO WARNING): if( perTuckAvailable < 0x10 )

                countT perTuckAvailable = ( cbAvailable << SB ) / cbStack ;
                countT cbAvailable = tin1P.pbThreadStackLowest - tin1P.pbThreadStackStart ;
            {
            if( cbStack )
            countT cbStack = tin1P.pbThreadStackEnd - tin1P.pbThreadStackStart ;

            //const byteT* pbLowest = tin1P.pbThreadStackLowest ;
            //const byteT* pbStart  = tin1P.pbThreadStackStart  ;
            //const byteT* pbEnd    = tin1P.pbThreadStackEnd    ;
            //TO FIND A BUG
        {
        if( !( F(tin1P.flagsThreadMode3) & flTHREADmODE3_SUPPRESStHREADsTACKuSAGEiNSPECTION ) )

        if( pbEsp <  tin1P.pbThreadStackLowest ) tin1P.pbThreadStackLowest = pbEsp ;

        if( tin1P.pbThreadStackEnd   && pbEsp >= tin1P.pbThreadStackEnd    ) { BLAMMO ; }
        if( tin1P.pbThreadStackStart && pbEsp <  tin1P.pbThreadStackStart  ) { BLAMMO ; }

        if( tin1P.pbThreadStackEnd   && pbEbp >= tin1P.pbThreadStackEnd    ) { BLAMMO ; }
        if( tin1P.pbThreadStackStart && pbEbp <  tin1P.pbThreadStackStart  ) { BLAMMO ; }

        const byteT* pbEsp = (const byteT*)espAM() ;
        const byteT* pbEbp = (const byteT*)ebpAM() ;
    {                                                                                                                                                                   // I MUST AVOID DOING THIS BLOCK IF MY tin0P PARAMETER IS NOT FOR THE CURRENT THREAD
    if( tin1P.idTinNamed != ifcIDtINnAMED_tinHeartI && tin1P.idTinNamed != ifcIDtINnAMED_tinBreakI && tin1P.osTid == GetCurrentThreadId() )         // WHEN THE EXCEPTION HANDLER CALLS ExitProcess(), THE DT'OR FOR processGlobal8I.processGloEnd WILL SET bTlsEarlyLateI, WHICH WILL CAUSE TINSL TO POINT TO THE WRONG tin0S INSTANCE

    //}
    //    else                                                                      { CONoUTrAW3( "\r\n||||||||||||||||||||||||||||||||||||||||||||" , ++ tin1P.idDozeMaybe           , "" ) ; }
    //    if( F(thirdC::third_flagsModeProcess2I_IF()) & flMODEpROCESS2_DOZEmAYBE ) { CONoUTrAW3( "\r\n____________________________________________" , ++ tin1P.idDozeMaybe | BM_HIGH , "" ) ; }
    //{
    //if( !( ++ tin1P.idDozeMaybe % TICK << 4  ) )

    if( F(thirdC::third_flagsModeProcess2I_IF()) & flMODEpROCESS2_DOZEmAYBE && !( ++ tin1P.idDozeMaybe % MODULOdOZE ) ) { /*CONoUTrAW( "\r\n----------------------------------------------" ) ;*/ thirdC::dosSleepWinkIF( tin0P , 1 ) ; } // 4,2:TOO MUCH ; 0: TOO LITTLE

    if( tin1P.idDozeMaybe != - 1 && !( F(thirdC::third_flagsModeProcess2I_IF()) & flMODEpROCESS2_DOZEmAYBE ) ) tin1P.idDozeMaybe = - 1 ;

    // 
    //   THIS IS DONE BY ENSURING THAT tin1P.idDozeMaybe == - 1 FOR EVERY THREAD
    //   THE ULTIMATE GOAL IS TO ENSURE THAT, WHEN AN UP TRANSITION IN flMODEpROCESS2_DOZEmAYBE OCCURS, EVERY THREAD WILL IMMEDIATELY WINK
    //
    // RECIPE FOR USING tin1P.idDozeMaybe: THE GOAL IS TO DETECT AN "UP TRANSITION" IN flMODEpROCESS2_DOZEmAYBE WITHOUT USING A DEDICATED flagsT TO STORE THE LAGGED VALUE OF flagsModeProcess2I

    tin123S& tin123P = (tin123S&)tin0P ;
    tin12S&  tin12P  =  (tin12S&)tin0P ;
    tin1S&   tin1P   =   (tin1S&)tin0P ;
{
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles4
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles3
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles2
//INTENTIONALLY UNINITIALIZED FOR SPEED: say.cCpuCycles1
//INTENTIONALLY UNINITIALIZED FOR SPEED: pFlagsThreadLevelModeSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: idProgressNestSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: eipInNestSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: idLineNestSave
//INTENTIONALLY UNINITIALIZED FOR SPEED: idFileNestSave
idWhat2Save( ((tin123S&)tin0P).where.idWhat2 )
idWhat1Save( ((tin123S&)tin0P).where.idWhat1 ) ,
) ,
    )
                        //: flINoUTfRAMEc_null                            //TO ENABLE  GENERALLY  (ENABLE THIS LINE IN PRODUCTION IFF WANT FULL TIME TELEMETRY)
                        : flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY          //TO DISABLE GENERALLY  (ENABLE THIS LINE IN PRODUCTION IFF WANT MAXIMUM SPEED)

                        ? flINoUTfRAMEc_null
                    : processGlobal1I.idAdamRoot == 0 /*ifcIDaDAM_SCRATCH07*/      //THIS LINE  ENABLES TELEMETRY FOR THE SPECIFIED ADAM (IF NOT 0)
                    ? flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY
                )
                  || processGlobal1I.idAdamRoot == 0 /*ifcIDaDAM_SCRATCH08*/       //THIS LINE DISABLES TELEMETRY FOR THE SPECIFIED ADAM (IF NOT 0)
                  || F(processGlobal2I._thirdC_flagsModeProcess1) & flMODEpROCESS1_INoUTfRAMEdOnOTcOLLECTaPPtELEMETRY
                     F(((tin1S&)tin0P).flagsThreadMode4) & flTHREADmODE4_INoUTfRAMEdOnOTcOLLECTaPPtELEMETRY
                (
                :
                ? flINoUTfRAMEc_null
            : F(((tin1S&)tin0P).flagsThreadMode4) & flTHREADmODE4_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY
            ? flINoUTfRAMEc_null
        F(processGlobal2I._thirdC_flagsModeProcess1) & flMODEpROCESS1_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY             // CS:CODEsYNC: 360cc003 3612c003: "TICK >> 0" IS NEEDED IF flINoUTfRAMEc_DOnOTcOLLECTaPPtELEMETRY IS EVER NOT USED (SEE inOutFrameC CT'OR)
    (
    |
    )
        : flINoUTfRAMEc_null
        ? flINoUTfRAMEc_DEFERwRITINGaPPtELEMETRY
    ( F(((tin1S&)tin0P).flagsThreadMode4) & flTHREADmODE4_INoUTfRAMEdEFERwRITINGaPPtELEMETRY
    |
    )
        : flINoUTfRAMEc_null
        ? flINoUTfRAMEc_REGISTERcALLnEST
    ( F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_INoUTfRAMErEGISTERcALLnEST
(
flagsCt
idFileRankCt( idFileRankP ) ,
idiFileCt( idiFileP ) ,
idLineCt( idLineP ) ,
tin0Ct( tin0P ) ,
pDad( ((tin1S&)tin0P).pInOutFrame ) ,
/*1*/inOutFrameC::inOutFrameC( tin0S& tin0P , const countT idLineP , const countT idiFileP , const countT idFileRankP , const boolT bClassP ) :/*1*/

/* ASSUME: 02 BITS PER countT */

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

