
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            c_strcpyIF( tinP , postP , ostot ) ;

            if( info.symACHnAME ) OStEXTA( ostot , info.symACHnAME )
            OStEXTAL( ostot , postLikeP , costPrefix )
            OStEXT( ostot , 0x200 )

            countT costPrefix = postEnd - postLikeP + 1 ;
            postEnd = c_strrchrIF( tinP , postLikeP , '\\' ) ;
            ZE( osTextT* , postEnd ) ;
        {
        if( !POOP && fFound )

        }
            BLAMMO ; //U:: TO FIND A BUG
            countT foo = 2 ;
        {
        if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_INVALIDhANDLE )

        }
            #endif

                if( cFail ) { __( ifcIDiMPOTENCEbASEeRRORcODE_NOTrEADY ) ; }
                while( cFail && -- cDo ) ;
                }
                    }
                        }
                            BOSpOOP ;
                            ((tinNormalS&)tinP).brcLath = brcLathSave ;
                            ((tinNormalS&)tinP).bosFail = bosFailSave ;
                        {
                        else
                        if( brcLathSave == ERROR_FILE_NOT_FOUND || brcLathSave == ERROR_PATH_NOT_FOUND || brcLathSave == ERROR_NO_MORE_FILES ) bosFailSave = 0 ;

                        handleP.closeIfF() ;
                        fFound = 0 ;
                    {
                    if( bosFailSave )

                    }
                        fFound = !((tinNormalS&)tinP).bosFail ;
                        brcLathSave = ((tinNormalS&)tinP).brcLath ;
                        bosFailSave = ((tinNormalS&)tinP).bosFail ;
                        else if( cFail ) cFail = 0 ;
                        }
                            continue ;
                            //Sleep( 8000 ) ;
                            if( ((tinNormalS&)tinP).pEther ) etherC::etRockIF( tinP ).traceF( tinP , T("!exception: dosFindFileOrDirSimpleIF / FindNextFile returned ERROR_NOT_READY.  will retry [cFail,postLikeP]:    ")+TF2(cFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postLikeP) ) ;
                        {
                        if( ((tinNormalS&)tinP).brcLath == ERROR_NOT_READY )

                        //if( processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH06 && !strcmp( postLikeP , "g:\\ipdos.archives\\*" ) /*((tinNormalS&)tinP).pc Utility[ 0 ]*/ ) ((tinNormalS&)tinP).brcLath = ERROR_NOT_READY ; //U:: TO FIND A BUG
                        BOS( WHATsfr , BOSoK , FindNextFile( (HANDLE)pOsh->hFind.osF( ifcIDtYPEhANDLE_FILEfINDbASE ) , &info ) )
                    {
                    else
                    }
                        if( ~pOsh->hFind ) fFound = 1 ;
                        pOsh->hFind.osF( ifcIDtYPEhANDLE_FILEfINDbASE , (countT)((tinNormalS&)tinP).brcRaw ) ;
                        brcLathSave = ((tinNormalS&)tinP).brcLath ;
                        bosFailSave = ((tinNormalS&)tinP).bosFail ;
                        else if( cFail ) cFail = 0 ;
                        }
                            continue ;
                            //Sleep( 8000 ) ;
                            if( ((tinNormalS&)tinP).pEther ) etherC::etRockIF( tinP ).traceF( tinP , T("!exception: dosFindFileOrDirSimpleIF / FindFirstFile returned ERROR_NOT_READY.  will retry [cFail,postLikeP]:    ")+TF2(cFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postLikeP) ) ;
                            cFail ++ ;
                        {
                        if( ((tinNormalS&)tinP).brcLath == ERROR_NOT_READY )

                        //if( processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH06 && !strcmp( postLikeP , "g:\\ipdos.archives\\*" ) /*((tinNormalS&)tinP).pc Utility[ 0 ]*/ ) ((tinNormalS&)tinP).brcLath = ERROR_NOT_READY ; //U:: TO FIND A BUG
                        BOS( WHATsfr , BOShANDLE , FindFirstFile( postLikeP , &info ) )
                    {
                    if( bWoth )
                    ZE( countT , brcLathSave ) ;
                    ZE( countT , bosFailSave ) ;
                {
                do                                                 //SILENTLY RETRY 8 TIMES IF ERROR_NOT_READY
                countT cDo = 1 ;       //20230802@1626: 8 --> 1 TO ELIMINATE RETRYING (PERSONALITY: LET CALLER HANDLE THIS)
                ZE( countT , cFail ) ;
                //CS:CODEsYNCH: DUPLICATE CODE 3600101d 35001186

            #elif defined( __NT__ )
            #ifdef __OS2__
        {

        c_memsetIF( tinP , (byteT*)&info , sizeof info ) ;
        #endif
            WIN32_FIND_DATA info ;
        #elif defined( __NT__ )
        #ifdef __OS2__
        ZE( boolT , fFound ) ;
    {
    else
    }
        }
            c_strcpyIF( tinP , postP , ostot ) ;

            if( posti ) OStEXTA( ostot , posti )
            OStEXTAL( ostot , postLikeP , costPrefix )
            OStEXT( ostot , 0x200 )

            countT costPrefix = postEnd - postLikeP + 1 ;
            postEnd = c_strrchrIF( tinP , postLikeP , '\\' ) ;
            ZE( osTextT* , postEnd ) ;

            posti[ costi ] = 0 ;
            countT rc = thirdC::s_readIF( tinP , posti , costi , pOsh->hSockCloak ) ;
            osTextT* posti = processGlobal4I.heap.newF( tinP , LF , costi + 1 ) ;
        {
        else
        if( !costi || costi > TUCK << 2 ) handleP.closeIfF() ;

        countT rc = thirdC::s_readIF( tinP , (byteT*)&costi , sizeof costi , pOsh->hSockCloak ) ;
        ZE( countT , costi ) ;
    {
    if( bCloaked )

    }
        }
            thirdC::s_writeIF( tinP , pOsh->hSockCloak , postLikeP , costLike ) ;
            thirdC::s_writeIF( tinP , pOsh->hSockCloak , (byteT*)&costLike , sizeof costLike ) ;
            countT costLike = thirdC::c_strlenIF( tinP , postLikeP ) ;

            thirdC::s_writeIF( tinP , pOsh->hSockCloak , (byteT*)&idFormat , sizeof idFormat ) ;
            countT idFormat = 1 ;

            thirdC::s_writeIF( tinP , pOsh->hSockCloak , (byteT*)&finger , sizeof finger ) ;
            countT finger = FINGERnEG_CLOAKsIMPLEcONNECTION ;

            thirdC::s_writeIF( tinP , pOsh->hSockCloak , (byteT*)&idTypeConnection , sizeof idTypeConnection ) ;
            countT idTypeConnection = ifcIDtYPEcLOAKcONNECTION_SIMPLE ;

            thirdC::s_connectIF( tinP , countTC() , pOsh->hSockCloak , homeS::homeIF().portCloak ) ;

            thirdC::s_socketIF( tinP , pOsh->hSockCloak , ifcSOCKETtYPE_STREAM ) ;
        {
        if( bCloaked )

        }
            handleP.osF( ifcIDtYPEhANDLE_FILEfIND , (countT)pOsh ) ;
            pOsh = new( 0 , tinP , pba , cba ) diskFindHandleS( tinP ) ;
        {
        if( pba )
        byteT* pba = processGlobal4I.heap.newF( tinP , LF , cba ) ;
        countT cba = sizeof( diskFindHandleS ) ;
    {
    else
    if( ~handleP ) pOsh = (diskFindHandleS*)handleP.osF( ifcIDtYPEhANDLE_FILEfIND ) ;
    boolT bWoth = !handleP ;
    ZE( diskFindHandleS* , pOsh ) ;
    //CS:CODEsYNC: DUPLICATE CODE 3600101d 35001186

    }
        //}
        //    if( ((tinNormalS&)tinP).pEther ) etherC::etRockIF( tinP ).traceF( tinP , T("dosFindFileOrDirSimpleIF / setting bCloaked [postf]:    ")+T(postf) ) ;
        //    bCloaked = 1 ;
        //    POOPRqUIET
        //{
        //if( POOP )

        // TO UNBREAK CLOAKING, THE FOLLOWING CODE, AND OTHER CODE LIKE IT, SHOULD BE REWRITTEN TO DETECT CLOAKING IN A WAY THAT DOES NOT GIVE A FALSE POSITIVE
        // COMMENTING OUT THE FOLLOWING CODE WILL ENABLE NORMAL IMPOTENCE BEHAVIOR BUT WILL ALSO BREAK CLOAKING
        // THE OO'TH DEFECT IS THAT CODE SUCH AS THE FOLLOWING (WHICH IS COMMENTED OUT) TESTS POOP, AND IF NONZE, INFERS THAT THE FAILURE WAS CAUSED BY CLOAKING
        // THE WO'TH DEFECT IS THAT NO THOUGHT WAS GIVENN TO SUPPORTING CLOAKING FOR NETWORKED DIRECTORIES
        //U:: 20221204@0820: SUPPORT FOR CLOAKING, AS CURRENTLY IMPLEMENTED, SUFFERS FROM OO FATAL DESIGN DEFECTS

        thirdC::dosFindFileOrDirSimpleIF( tinP , postf , sizeof postf , hFind , postLikeP , flDOSfINDfILEoRdIR_DOnOTtESTwATER ) ;
        handleC hFind( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        postf[ 0 ] = 0 ;
        osTextT postf[ TUCK << 1 ] ;

        SCOOP
        poopC poop ;
    {
    //CS:CODEsYNC: PSEUDODUPLICATE CODE 3600101d 35001186
    if( !( F(flagsP) & flDOSfINDfILEoRdIR_DOnOTtESTwATER ) )
    ZE( boolT , bCloaked ) ;

    //}
    //    CONoUTrAW( "\r\n" ) ;
    //    CONoUTrAW( postLikeP ) ;
    //    CONoUTrAW( "dosFindFileOrDirSimpleIF: " ) ;
    //{
    //if( processGlobal1I.idAdamRoot == ifcIDaDAM_SCRATCH07 )

    _IO_

    }
        if( POOP ) return ;
        #endif
            __( sizeof( countT ) != sizeof( HANDLE ) || fnu ) ;
        #elif defined( __NT__ )
        #ifdef __OS2__
        ZE( boolT , fnu ) ;
        //U::__( !postLikeP[ 3 ] ) ;
        if( POOP ) return ;
        __( !postLikeP[ 2 ] ) ;
        if( POOP ) return ;
        }
            __( postLikeP[ 1 ] - ':' ) ;
            __( postLikeP[ 0 ] < 'a' || postLikeP[ 0 ] > 'z' ) ;
        {
        if( postLikeP[ 1 ] != '\\' )            //20190826@0902: ACCOMMODATE NETBIOS FILE NAMES OF THE FORM "\\netbiosname\disk\path\short"
        if( POOP ) return ;
        __( !postLikeP[ 0 ] ) ;
        __( !!*postP ) ;     //CALLER MUST INSPECT THIS TO DETERMINE WHETHER AN OBJECT WAS FOUND
        if( POOP ) return ;
        FV(flDOSfINDfILEoRdIR,flagsP) ;
        __Z( postLikeP ) ;
        __( costaP <= costMax ) ;
        __Z( costMax ) ;
        __Z( postP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    

    const countT costMax = dosQuerySysInfoMaxPathLengthIF( tinP ) ;
{
/*1*/voidT thirdC::dosFindFileOrDirSimpleIF( tinBaseS& tinP , osTextT* const postP , const countT costaP , handleC& handleP , const osTextT* const postLikeP , const flagsT flagsP )/*1*/

#endif
    #define symACHnAME         cFileName
#elif defined( __NT__ )
#ifdef __OS2__

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

