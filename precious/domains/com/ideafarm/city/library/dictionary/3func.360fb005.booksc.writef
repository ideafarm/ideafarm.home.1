
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

#undef CBTsCRATCHbUFFER
//U:: TO FIND A BUG

}
    return idBook ;

    //DELzOMBIE( pInOutFrame ) ;

    THREADmODE2rESTORE
    THREADmODE4rESTORE

    }
        //if( bDeleteOutParam ) { PUSE( tin0P , *(byteT**)ppcpIdAptP ) ; }

        if( processGlobal2I._grabC_pgw ) grabBookNow.ungrabF( tin0P ) ;

        }
            processGlobal4I.heap.delF( tin0P , pbtScratchBuffer ) ;
            DELzOMBIE( pBk0Doomed ) ;

            }
                THREADmODE2rESTORE ;
                writeF( tin0P , pbi , cbi ) ; //THIS LINE MIGHT USE CONSTRUCT AND USE A NEW SCRATCH BOOK
                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING ) ;
                _IO_
            {
            if( cbi )

                                 *ppBk0Scratch = 0 ;
            book0C* pBk0Doomed = *ppBk0Scratch ;
            (*ppBk0Scratch)->readF( tin0P , pbi , cbi , offi ) ;
            ZE( countT , offi ) ;
            countT cbi = - 1 ;
            ZE( const byteT* , pbi ) ;

            if( !ppBk0Scratch ) { BLAMMO ; }
            _IO_
        {
        if( pbtScratchBuffer )

        }
            }
                if( bNullWrite || F(flagsP) & flBOOKScwRITE_SETrEMAINING || ( F(flagsP) & flBOOKScwRITE_ALLoRsOME && cbDone1 ) ) break ;

                }
                    THREADmODE5rESTORE
                    }
                        }
                            }
                                if( flagsSnap == setIfEqualsAM( flags , flagsSnap | flBOOKhEADs_PRIORbOOKnOTcONTINUEDhERE , flagsSnap ) ) break ;
                                flagsT flagsSnap = flags ;
                                _IO_
                            {
                            for(;;)
            
                            flagsT& flags = ((bookHeadS&)BOOKnOW).flags ;
                            _IO_
                        {
                        else //GIVE OTHERS PERMISSION TO WRITE WOTH BYTE
                        }
                            flagsWrite |= flBOOK0cwRITE_CONTINUEfROMpRIOR ; //GIVE MYSELF PERMISSION TO WRITE WOTH BYTE (ON MY NEXT ITERATION)
                        {
                        )
                            cb1P
                            &&
                            !( F(flagsP) & flBOOKScwRITE_ALLoRsOME    )
                            &&
                            !( F(flagsP) & flBOOKScwRITE_SETrEMAINING )
                        (
                        if
                        _IO_
                    {
                    )
                        )
                            )
                                !bWroteAll
                                &&
                                F(flagsP) & flBOOKScwRITE_ALLoRnONE
                            (
                            ||
                            bWroteLath
                        (
                        &&
                        !POOP
                    (
                    if

                    pcRef_postBookNameNoPuse2[ offEltMyHeap ] = 0 ;                                     //THIS FREES THE HEAP ALLOCATION THAT I WAS USING FOR THE NAME
                    //if( !( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE ) ) PUSE( tin0P , postBookName ) ;
                    THREADmODE2rESTORE ;
                    //CONoUTrAW( "\r\n+++++++++++ NEWED  BOOK ------------" ) ;

                    pBookUse = &BOOKnOW ;

                    }
                        NEWbOOK2sETfLAG

                        //((tin123S&)tin0P).pc Utility[ 0 ] -- ; //U:: TO FIND A BUG
                        THREADmODE4rESTORE
                        }
                            THREADmODE4rESTORE
                            }
                                THREADmODE4rESTORE
                                new( 0 , tin0P , PBbOOKbACKnOW , SIZEOF_bookC ) bookC( tin0P , TAG( TAGiDnULL ) , postBookName , idStateSpace , flagsCtBook , F(flagsCt) & flBOOKSc_WRITER ? cbBodyNew : 0 , bFill , idMemorySpace ) ;
                                THREADmODE4oFF( flTHREADmODE4_SUPPRESStRACING )
                                _IO_
                            {
                            THREADmODE4oN(  flTHREADmODE4_ALLOWeXPLICITmEMORYsPACE )
                            _IO_
                        {
                        THREADmODE4oN( flTHREADmODE4_ALLOWeXPLICITmEMORYsPACE )
                        //((tin123S&)tin0P).pc Utility[ 0 ] ++ ; //U:: TO FIND A BUG

                        //}
                        //                  ((tin123S&)tin0P).pc Utility[ 0 ] = save ;
                        //    ((tin123S&)tin0P).pEther->traceF( tin0P , T("newing book [idBook]:    ")+TF2(PCPiDbOOKnOW[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //                  ((tin123S&)tin0P).pc Utility[ 0 ] = 0 ;
                        //    countT save = ((tin123S&)tin0P).pc Utility[ 0 ] ;
                        //{
                        //if( ((tin123S&)tin0P).pc Utility[ 0 ] && ((tin123S&)tin0P).pEther ) //U:: TO FIND A BUG

                        NEWbOOK1bLAMMOiFcT
                        _IO_
                    {
                    if( bBookNowIsDestroyed )

                    //CONoUTrAW( "\r\n+++++++++++ NEWING BOOK ++++++++++++" ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING ) ;

                    //}
                    //    if( postBookName ) thirdC::c_strcpyIF( tin0P , postBookName , tName ) ;
                    //    PUSE.newF( tin0P , LF , *(byteT**)&postBookName , tName.csF( tin0P ) + 1 ) ; ___( postBookName ) ;
                    //    ;
                    //        : T(postPath)+T(postShort)+T(".booksC.1.book.")+tIdBook
                    //        ? T(postShort)+T(".booksC.1.book.")+tIdBook
                    //    TN( tName , "" ) ; tName = !*postPath
                    //
                    //    }
                    //        for( countT offi = *PCPiDbOOKnOW ; offi ; offi -- ) tIdBook += tDot+TF3(PCPiDbOOKnOW[offi],flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ;
                    //        TN( tDot , "." ) ;
                    //        tIdBook = TF3(*PCPiDbOOKnOW,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ;
                    //    {
                    //    TN( tIdBook , "" ) ;                             //U::ELIMINATE USE OF POOL WHILE grabBookNew IS GRABBED
                    //{
                    //else
                    }
                        thirdC::c_strcpyIF( tin0P , postBookName , ostoName ) ;
            
                        }
                            OStEXTCF(  ostoName , PCPiDbOOKnOW[ offi ] , '0' ) ;
                            OStEXTAK( ostoName , "." ) ;
                        {
                        for( countT offi = *PCPiDbOOKnOW ; offi ; offi -- )
                        OStEXTCF(  ostoName , *PCPiDbOOKnOW , '0' ) ;
                        OStEXTAK( ostoName , ".booksC.1.book." ) ;
                        OStEXTA(  ostoName , postShort ) ;
                        }
                            OStEXTA(  ostoName , postPath ) ;
                        {
                        if( *postPath )
                        OStEXT(   ostoName , TUCK << 1 ) ; //JUST TO MAKE SURE THAT BASE OS MAXPATH IS THE LIMITING CAPACITY CONSTRAINT
                        _IO_
                    {
                    //if( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE )
                    //20171112@1617: ALWAYS USE OStEXT RATHER THAN POOL, IN ORDER TO AVOID USING POOL WHILE grabBookNow IS GRABBED IN ORDER TO AVOID NONMONOTONIC GRABBING

                    }
                        //}
                        //    //if( ((tin123S&)tin0P).pEther ) ((tin123S&)tin0P).pEther->trace F( tin0P , T("booksC::writeF [idBook]: ")+TF2(PCPiDbOOKnOW[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //{
                        //if( PCPiDbOOKnOW[ 0 ] && PCPiDbOOKnOW[ 1 ] >= TUCK ) //U::20141104@0740: TO FIND A BUG (RUNAWAY WHILE PROCESSING all.soil)

                        addF( tin0P , PCPiDbOOKnOW , PCPiDbOOKlAG , pcpWo ) ;
                        countT pcpWo[] = { 1 , 1 } ;
                        _IO_
                    {

                    }
                        //CONoUTrAW( "\r\n----------- DELETED  BOOK ------------" ) ;
                        bBookNowIsDestroyed = 1 ;
                        //((tin123S&)tin0P).pc Utility[ 0 ] -- ; //U:: TO FIND A BUG
                        DELzOMBIEbOOKbACKnOWiF
                        //((tin123S&)tin0P).pc Utility[ 0 ] ++ ; //U:: TO FIND A BUG
                        pBookUse = 0 ;
                        //CONoUTrAW( "\r\n----------- DELETING BOOK ++++++++++++" ) ;

                        //}
                        //                  ((tin123S&)tin0P).pc Utility[ 0 ] = save ;
                        //    ((tin123S&)tin0P).pEther->traceF( tin0P , T("deleting book [idBook]:    ")+TF2(PCPiDbOOKnOW[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        //                  ((tin123S&)tin0P).pc Utility[ 0 ] = 0 ;
                        //    countT save = ((tin123S&)tin0P).pc Utility[ 0 ] ;
                        //{
                        //if( PCPiDbOOKnOW[ 1 ] && ((tin123S&)tin0P).pc Utility[ 0 ] && ((tin123S&)tin0P).pEther ) //U:: TO FIND A BUG
                        _IO_
                    {
                    else if( !bSameBook )
                    }
                        else                              BOOKnOW.purgeF( tin0P ) ;
                        if( offBookBackNow < CbOOKsLOTS ) bBookNowIsDestroyed = 1 ;
                        _IO_
                    {
                    if( F(flagsCt) & flBOOKSc_CYCLE )
                    ZE( boolT , bBookNowIsDestroyed ) ;
                    //if( ((tin123S&)tin0P).pEther ) ((tin123S&)tin0P).pEther->trace F( tin0P , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": ")+T(postShort)+T(": ")+TF2(offBookBackNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": writeF / incremented") ) ; //U:: TO FIND A BUG

                    }
                        }
                            bSameBook = pcpIdBookTest[ 0 ] == PCPiDbOOKnOW[ 0 ] && !thirdC::c_memcmpIF( tin0P , (byteT*)pcpIdBookTest , (byteT*)PCPiDbOOKnOW , sizeof( countT ) * ( 1 + pcpIdBookTest[ 0 ] ) ) ;

                            addF( tin0P , pcTest , PCPiDbOOKlAG , pcpWo ) ;
                            countT* pcTest = pcpIdBookTest ;
                            countT pcpWo[] = { 1 , 1 } ;
                            countT pcpIdBookTest[ 9 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ;
                        {                              // 1   2   3   4   5   6   7   8   9
                        else
                        }
                            if( ((tin123S&)tin0P).pEther ) ((tin123S&)tin0P).pEther->traceF( tin0P , T("!exception: booksC::writeF: idBookNow is too long to test so unnecesary close/open might occur [ccMax]:    ")+TF2(ccMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        if( ccMax > 8 )

                        ;
                            : ccLag
                            ? ccNow
                        countT ccMax = ccNow >= ccLag

                        countT ccLag = PCPiDbOOKlAG[ 0 ] ;
                        countT ccNow = PCPiDbOOKnOW[ 0 ] ;

                        _IO_
                    {
                    ZE( boolT , bSameBook ) ;   // THIS WILL NEVER BE TRUE IF I AM JUST BEING WRITTEN TO ; BUT IF DIRECT ACCESS READING IS ALSO BEING DONE, THE BOOK THAT I AM NOW POINTING TO MIGHT BE THE WO THAT I WANT

                    offBookBackNow ++ ;

                    }
                        }
                            //if( !(    (bookHeadS&)**ppBk0Scratch    ).cbBody ) { BLAMMO ; } //U::TO FIND A BUG  20140401
                            ((bookHeadS&)**ppBk0Scratch).flags |= flBOOKhEADs_PRIORbOOKnOTcONTINUEDhERE ;
                            }
                                *ppBk0Scratch = new( 0 , tin0P , pbaBook0 , cbaBook0 ) book0C( tin0P , pbtScratchBuffer , cbtBuffer ) ;
                            {

                            ;
                                    : &((tin123S&)tin0P).pBk0TraceScratch
                                    ? &((tin123S&)tin0P).pBk0TelemetryAppScratch
                                : bTelemetryApp
                                ? &((tin123S&)tin0P).pBk0TelemetrySysScratch
                            ppBk0Scratch = bTelemetrySys
                            _IO_
                        {
                        else
                        if( !pbtScratchBuffer ) { BLAMMO ; }
                        byteT pbaBook0[ cbaBook0 ] ;
                        const countT cbaBook0 = sizeof( book0C ) ;

                        }
                            TELL( "booksC::writeF / called heapC::newF 1" )
                            pbtScratchBuffer = processGlobal4I.heap.newF( tin0P , LF , cbtBuffer ) ;
                            TELL( "booksC::writeF / calling heapC::newF 1" )
                            _IO_
                        {

                          const countT cbtBuffer = CBTsCRATCHbUFFER ;
                        //const countT cbtBuffer = TOCK << 4 ; //20211117@1225: OLD CODE FAILS ; RATHER THAN ANALYZE, JUST THROW MORE BYTES AT THE PROBLEM
                        //const countT cbtBuffer = TOCK      ; //20151125@1605: OLD CODE FAILS ; RATHER THAN ANALYZE, JUST THROW A TOCK AT THE PROBLEM
                    
                        //;
                        //    : TOCK ; //A:ASSUME: TRACE FROM DEL( p BookOld ) NEW( p BookOld ) IS FEWER THAN TOCK BYTES
                        //    ? sizeof( bookHeadS ) + 2 * ( sizeof( tellS ) + CBtELEMETRYeNVELOPE + sizeof( tellInfoSysNapkinS ) ) + 1       // ADD 1 TO ENSURE THAT THE LATH BYTE OF THE SCRATCH BUFFER IS NOT WRITTEN BY THE TELEMETRY EMITTED WHEN I DELETE AND NEW p BookOld
                        //const countT cbtBuffer = bTelemetrySys || bTelemetryApp
                        //ALLOCATED ROOM FOR 4 NAPKIN TELLS: DEL( p BookOld ) + NEW( p BookOld )
                        _IO_
                    {
                    )
                        ( bTrace     && !((tin123S&)tin0P).pBk0TraceScratch )
                        ||
                        ( bTelemetryApp && !((tin123S&)tin0P).pBk0TelemetryAppScratch )
                        ||
                        ( bTelemetrySys && !((tin123S&)tin0P).pBk0TelemetrySysScratch )
                    (
                    if

                    //IF flBOOKScwRITE_SETrEMAINING || !cb1P THEN I AM DONE WRITING MY DATA BUT MUST SET A FLAG IN THE NEW HEADER TO INDICATE THAT I WAIVE MY RIGHT TO WRITE ITS WOTH BYTE

                    }                 
                        cb1P = cb2P ; cb2P = 0 ;
                        pb1P = pb2P ; pb2P = 0 ;
                    {
                    if( !cb1P && cb2P && !bNullWrite )

                               cb2P -= cbDone2 ;
                    if( pb2P ) pb2P += cbDone2 ;

                               cb1P -= cbDone1 ;
                    if( pb1P ) pb1P += cbDone1 ;

                    // !cbDone1 || bWroteLath

                    }
                        if( offEltMyHeap == cElts ) { BLAMMO ; }
                        }
                            }
                                break ;
                                postBookName = ppostBookNameNoPuse2[ offEltMyHeap ] ;
                            {
                            if( !setIfZeAM( pcRef_postBookNameNoPuse2[ offEltMyHeap ] , 1 ) )
                            _IO_
                        {
                        for( offEltMyHeap = 0 ; offEltMyHeap < cElts ; offEltMyHeap ++ )
                        countT cElts = sizeof ppostBookNameNoPuse2 / sizeof ppostBookNameNoPuse2[ 0 ] ;
                        _IO_
                    {
                    ZE( countT   , offEltMyHeap ) ;
                    ZE( osTextT* , postBookName ) ;   //U:: BUG: THIS IS NOT REENTRANT.  I NEED TO USE POOL OR SOME OTHER MEMORY ALLOCATION SCHEME FOR THIS NAME SO THAT I AM REENTRANT
                    //ALLOCATE postBookNameNoPuse2 (PUSE IS NOT USED TO AVOID NONMONOTONIC GRABBING.  SO I NEED TO HAVE MY OWN LITTLE HEAP)
                    THREADmODE5oFF( flTHREADmODE5_INoUTfRAMEfORCEcOLLECTaPPtELEMETRY )
                    _IO_
                {
                else
                else if( F(flagsP) & flBOOKScwRITE_NOsCRATCHING ) { BLAMMO ; }
                //
                //
                //
                // 20211218@1748: OBSERVED FACTORY4 UNIDENTIFIED PROCESS (JUST KEEP DOUBLING SIZE in booksC::writeF WHENEVER SEE THIS)    RESPONSE: cbtBuffer = TICK << 0  (01x)
                // 20211117@1221: OBSERVED WITHIN GLASS2
                //
                }
                    BLAMMO ;
                    fileWriteGF( "\\tmp\\booksc.scratch.buffer.image.ttt" , pbtScratchBuffer , CBTsCRATCHbUFFER , flSAY_null ) ;    //U:: TO FIND A BUG ; THIS TEMP CODE WILL FAIL IF \\tmp DOES NOT EXIST
                {
                else if( pBookUse == ((tin123S&)tin0P).pBk0TraceScratch )
                else if( pBookUse == ((tin123S&)tin0P).pBk0TelemetryAppScratch ) { BLAMMO ; }
                else if( pBookUse == ((tin123S&)tin0P).pBk0TelemetrySysScratch ) { BLAMMO ; } //20141206@0700: OBSERVED WITHIN ifcIDaDAM_CLOUD WHILE 3 INSTANCES EXISTED ; 20151026@2013: DITTO WHILE MORE THAN 3 EXISTED BUT ONLY WO WAS ACTIVE AT A TIME ; 20151125@1532 piss (156)
                }
                    break ;
                    if( ( !( F(flagsP) & flBOOKScwRITE_SETrEMAINING ) && cbDone1 != cb1P ) || cbDone2 != cb2P ) { BLAMMO ; } // cbDoneX MUST EQUAL cbXP; IF I DIDN'T WRITE THE LATH BYTE THEN I MUST HAVE WRITTEN ALL THAT I WANTED TO WRITE
                    _IO_
                {
                if( ( cbDone1 || bNullWrite ) && !bWroteLath ) // SHOULD BE IMPOSSIBLE IF flBOOKScwRITE_SETrEMAINING BECAUSE A flBOOKScwRITE_SETrEMAINING CALL WILL ALWAYS WRITE AT LEAST WO BYTE AND WILL ALWAYS WRITE THE LATH BYTE ; THIS IS BECAUSE ANY PRIOR WRITE THAT WRITES THE LATH BYTE WILL ALWAYS CLOSE THE BOOK AND OPEN THE NEXT BOOK

                //}
                //    }
                //        countT foo = 2 ;
                //    {
                //    if( !bWroteLath && !bWroteAll )
                //                  ((tin123S&)tin0P).pc Utility[ 0 ] = save ;
                //    ((tin123S&)tin0P).pEther->traceF( tin0P , T("[cb1P,cbDone1,bWroteLath,bWroteAll]:    ")+TF2(cb1P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cbDone1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(bWroteLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(bWroteAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                //                  ((tin123S&)tin0P).pc Utility[ 0 ] = 0 ;
                //    countT save = ((tin123S&)tin0P).pc Utility[ 0 ] ;
                //{
                //if( ((tin123S&)tin0P).pc Utility[ 0 ] && ((tin123S&)tin0P).pEther )

                boolT bWroteAll  =  !( F(flagsResult) & flBOOK0cwRITErESULT_COULDnOTwRITEaLL ) ;
                boolT bWroteLath = !!( F(flagsResult) & flBOOK0cwRITErESULT_WROTElATHbYTE    ) ;

                //}
                //    }
                //        thirdC::c_memcpyIF( tin0P , (byteT*)( *ppcpIdAptP + 2 ) , (byteT*)( PCPiDbOOKnOW + 1 ) , sizeof( countT ) * *PCPiDbOOKnOW ) ;
                //        (*ppcpIdAptP)[ 1 ] = offAt ;
                //        (*ppcpIdAptP)[ 0 ] = 1 + *PCPiDbOOKnOW ;
                //    {
                //    else
                //    if( !cbDone1 ) bDeleteOutParam = 1 ;
                //{
                //if( ppcpIdAptP && *ppcpIdAptP )

                flagsWrite &= ~( F(flBOOK0cwRITE_CONTINUEfROMpRIOR) ) ;

                if( cbDone1 && !idBook ) idBook = PCPiDbOOKnOW[ 1 ] ; // APPS CAN USE THE LOWEST ORDER idBook countT TO IDENTIFY WHICH BOOK A TRANSACTION WAS WRITTEN TO, EVEN WHEN THE FULL IDbOOK VALUE IS LEN > 1, IN ORDER TO SUPPORT CHECKPOINT / RESTART FUNCTIONALITY WITHIN TRANSACTION PROCESSING
                // idBook IS INTENDED TO BE THE ID OF THE WOTH BOOK TO RECEIVE ANY PART OF THE FULL ITEM WRITTEN; FOR CHECKPOINT / RESTART FUNCTIONALITY, TRANSACTION PROCESSING SHOULD USE flBOOKScwRITE_ALLoRnONE

                }
                    }
                        c2AppNote.c2 = PCPiDbOOKnOW[ 1 ] ;
                        c2AppNote.c1 = offWrote ;
                        HANDLEaPPnOTEScOUNTcLASS& c2AppNote = *phWroteP ;
                        phWroteP->osF( ifcIDtYPEhANDLE_BOOKS , FINGERnEG_HANDLEbOOKSjOT , 0 , cbDone1 + cbDone2 ) ;
                        _IO_
                    {
                    if( !POOP )

                    __( cb2P - cbDone2 ) ;
                    if( !( F(flagsP) & flBOOKScwRITE_SETrEMAINING ) && !( F(flagsP) & flBOOKScwRITE_ALLoRsOME ) ) { __( cb1P - cbDone1 ) ; }
                    _IO_
                {
                if( phWroteP && ( cbDone1 || bNullWrite ) )

                }
                    THREADmODE2rESTORE ;
                    offAt = pBookUse->writeF( tin0P , flagsResult , pb1P , cbDone1 , pb2P , cbDone2 , flagsWrite , phWroteP ? &offWrote : 0 ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING ) ;
                    _IO_
                {
                ZE( countT , offAt ) ;
                ZE( countT , offWrote ) ;
                ZE( flagsT , flagsResult ) ;
                countT cbDone2 = cb2P ;
                countT cbDone1 = cb1P ;

                }
                    if( POOP ) break ;
                    __( *PCPiDbOOKnOW != 1 ) ; // IDbOOK VALUES ARE UNLIMITED.  BUT ONLY LENGTH 1 IDbOOK VALUES CAN BE STORED WITHIN A handleC.  FOR MORE CAPACITY, INCREASE THE SIZE OF handleC::c2AppNote
                    _IO_
                {
                if( phWroteP ) // MUST BE CHECKED AGAIN HERE BECAUSE PCPiDbOOKnOW MIGHT HAVE CHANGED SINCE ENTERING ME

                _IO_
            {
            //U:: IS A MYSTERY BECAUSE flTHREADmODE4_POOLaLLOCATEfROMhEAP IS SET
            //U:: IS USING poolC SOMEWHERE IN HERE, WHICH CAUSES NONMONOTONIC GRAB BLAMMO ; THE CALL NEST CONTAINS OO LEVELS WITH BLANK idiFile ; SO _IO_ LINES ARE ADDED TO SQUEEZE THIS

            _IO_
        {
        while( cb1P || F(flagsP) & flBOOKScwRITE_SETrEMAINING || bNullWrite )
        boolT bNullWrite = !cb1P ;
        //ZE( boolT , bDeleteOutParam ) ;
        ZE( book0C** , ppBk0Scratch ) ;

        }
            if( F(flagsP) & flBOOKScwRITE_FLUSHaTpAGE                   ) flagsWrite |= flBOOK0cwRITE_FLUSHaTpAGE                   ;
            if( F(flagsP) & flBOOKScwRITE_FLUSHaFTER                   ) flagsWrite |= flBOOK0cwRITE_FLUSHaFTER                     ;
            _IO_
        {
        if( pBookUse != ((tin123S&)tin0P).pBk0TelemetrySysScratch && pBookUse != ((tin123S&)tin0P).pBk0TelemetryAppScratch && pBookUse != ((tin123S&)tin0P).pBk0TraceScratch )

        if( F(flagsP) & flBOOKScwRITE_SETrEMAINING                  ) flagsWrite |= flBOOK0cwRITE_SETrEMAINING                  ;
        if( F(flagsP) & flBOOKScwRITE_ALLOWoDDlENGTH                ) flagsWrite |= flBOOK0cwRITE_ALLOWoDDlENGTH                ;
        if( F(flagsP) & flBOOKScwRITE_TAILfINGER                    ) flagsWrite |= flBOOK0cwRITE_TAILfINGER                    ;
        if( F(flagsP) & flBOOKScwRITE_HEADfINGER2                   ) flagsWrite |= flBOOK0cwRITE_HEADfINGER2                   ;
        if( F(flagsP) & flBOOKScwRITE_HEADcBdATA                    ) flagsWrite |= flBOOK0cwRITE_HEADcBdATA                    ;
        if( F(flagsP) & flBOOKScwRITE_HEADiDfORMAT                  ) flagsWrite |= flBOOK0cwRITE_HEADiDfORMAT                  ;
        if( F(flagsP) & flBOOKScwRITE_HEADfINGER1                   ) flagsWrite |= flBOOK0cwRITE_HEADfINGER1                   ;
        if( F(flagsP) & flBOOKScwRITE_ELSEfILLtOeND                 ) flagsWrite |= flBOOK0cwRITE_ELSEfILLtOeND                 ;
        if( F(flagsP) & flBOOKScwRITE_ALLoRnONE                     ) flagsWrite |= flBOOK0cwRITE_ALLoRnONE                     ;
        if( F(flagsP) & flBOOKScwRITE_PURGE                         ) flagsWrite |= flBOOK0cwRITE_PURGE                         ; //WARNING: THIS ONLY PURGES THE CURRENT BOOK; TO PURGE THE BOOK SET, APP CAN DESTROY THIS INSTANCE AND CT AN INSTANCE USING flBOOKSc_PURGEoNcT
        flagsT flagsWrite = flBOOK0cwRITE_null ;

        ZE( byteT* , pbtScratchBuffer ) ; //USED AS BOOLEAN TO INDICATE THAT I AM THE CALL NEST LEVEL THAT MUST POUR AND THEN DESTROY THE SCRATCH BOOK

        //if( !( (bookHeadS&)*pBookUse ).cbBody ) { BLAMMO ; } //U::TO FIND A BUG  20140401

        ;
                    : &BOOKnOW
                    ? ((tin123S&)tin0P).pBk0TraceScratch
                : bTrace && ((tin123S&)tin0P).pBk0TraceScratch
                ? ((tin123S&)tin0P).pBk0TelemetryAppScratch
            : bTelemetryApp && ((tin123S&)tin0P).pBk0TelemetryAppScratch
            ? ((tin123S&)tin0P).pBk0TelemetrySysScratch
        book0C* pBookUse = bTelemetrySys && ((tin123S&)tin0P).pBk0TelemetrySysScratch

        //}
        //    }
        //        grabBookNow.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        //        PUSE.newF( tin0P , LF , *(byteT**)ppcpIdAptP , sizeof( countT ) * ( 2 + save ) ) ; ___( *ppcpIdAptP ) ;
        //        save = *PCPiDbOOKnOW ;
        //        PUSE( tin0P , *(byteT**)ppcpIdAptP ) ;
        //        grabBookNow.ungrabF( tin0P ) ;
        //    {
        //    while( *PCPiDbOOKnOW - save )
        //
        //    grabBookNow.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        //    PUSE.newF( tin0P , LF , *(byteT**)ppcpIdAptP , sizeof( countT ) * ( 2 + save ) ) ; ___( *ppcpIdAptP ) ;
        //    countT save = *PCPiDbOOKnOW ;
        //{
        //else
        //}
            }
                grabBookNow.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                _IO_

                //CONoUTrAW3( "[idIn]: " , idIn , "\r\n" ) ;
                countT idIn = 1 + incv02AM( idInLath ) ;
                static countT idInLath ;
            {
            if( processGlobal2I._grabC_pgw )
        //{
        //if( !ppcpIdAptP || !((tin123S&)tin0P).pPoolUse || !processGlobal2I._grabC_pgw )
        //20171117@2104: ppcpIdAptP SUPPORT IS COMMENTED OUT BECAUSE IT IS NOT CURRENTLY USED AND ITS CURRENT CODE REQUIRES USE OF PUSE, WHICH CAUSES NONMONOTONIC GRABBING.  BEFORE ENABLING, MUST BE REWRITTEN TO AVOID USING PUSE

        //const boolT bTraceDivert1 = this == &processGlobal4I.bksTraceDivert01 ;
        const boolT bTrace        = this == &processGlobal4I.bksTrace           ;
        const boolT bTelemetryApp = this == &processGlobal4I.bksTelemetryApp    ;
        const boolT bTelemetrySys = this == &processGlobal4I.bksTelemetrySys    ;
        _IO_
    {
    //if( cb1P || F(flagsP) & flBOOKScwRITE_SETrEMAINING )
    ZE( countT , idBook ) ;

    //;
    //    : new( 0 , tin0P , _pbInOutFrame , sizeof _pbInOutFrame ) inOutFrameC( tin0P , LF , IDFILE , BiFCcLASS )
    //    ? 0 
    //inOutFrameC* pInOutFrame = this == &processGlobal4I.bksTrace || this == &processGlobal4I.bksTraceDivert01 || this == &processGlobal4I.bksTraceDivert02 || this == &processGlobal4I.bksTraceDivert03 || this == &processGlobal4I.bksTraceDivert04 || this == &processGlobal4I.bksTraceDivert05 || this == &processGlobal4I.bksTraceDivert06 || this == &processGlobal4I.bksTraceDivert07 || this == &processGlobal4I.bksTraceDivert08
    //byteT _pbInOutFrame[ sizeof( inOutFrameC ) ] ;
    //20191008@0844: DON'T KNOW WHY DONE THIS WAY RATHER THAN JUST USE _IO_

    //if( this == &processGlobal4I.bksTelemetrySys || this == &processGlobal4I.bksTelemetryApp /*|| this == &processGlobal4I.bksTrace || this == &processGlobal4I.bksTraceDivert01*/ || this == &processGlobal4I.bksWord || this == &processGlobal4I.bksWords ) return 0 ;  //U:: TO WORKAROUND A BUG (NONMONOTONIC GRABBING)
    //U::DELETE THE NEXT LINE ONCE I AM TESTED TO VERIFY THAT I DO NOT TRIGGER NONMONOTONIC GRABBING BLAMMO

    THREADmODE4oN( flTHREADmODE4_POOLaLLOCATEfROMhEAP )

    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )     //20200912@1846: ADDED WITHOUT ANALYSIS TO PREVENT RARE EVENT FAILURE THAT I CANNOT LOCATE

    _IO_

    //    ungrab grabBookNow
    //       dt scratch and free tls
    //       pour scratch  (this might ct and use a new scratch book)
    //      if i allocated scratch
    //       ct book
    //       dt book
    //       increment offBookNow
    //       allocate from tls and ct scratch book
    //      if scratch not allocated
    //      adjust parameters by cbDone      
    //     else
    //     else if scratch or no scratching then blammo
    //     if wrote something but did not exhaust book then break
    //     write to pBookUse
    //    while have something to write
    //    set pBookUse to scratch if exists, or to BOOKnOW otherwise
    //    grab grabBookNow
    //   if have something to write
    //   set flag pool alloc from heap
    //  pseudocode

    }
        if( POOP ) return 0 ;
        }
            }
                }
                    break ;
                    __1 ;
                {
                if( ((tin123S&)tin0P).pBookMark[ offr ].pBooks == this )                                                     //THIS ENFORCEMENT ADDED 20231111@1839
            {                                                                                                   //THIS IS TO PREVENT A DEADLOCK IF I TRY TO CHANGE THE CURRENT bookC AND THE SMARTPOINTER HAPPENS TO BE POINTING INTO THE bookC TO BE DELETED
            for( countT offr = 0 ; offr < sizeof ((tin123S&)tin0P).pBookMark / sizeof ((tin123S&)tin0P).pBookMark[ 0 ] ; offr ++ )        //ENFORCES RULE: THREAD IS NOT ALLOWED TO WRITE TO A booksC OBJECT WHILE HOLDING A SMARTPOINTER INTO THAT booksC OBJECT
        {
        }
            __( *PCPiDbOOKnOW != 1 ) ; // IDbOOK VALUES ARE UNLIMITED.  BUT ONLY LENGTH 1 IDbOOK VALUES CAN BE STORED WITHIN A handleC.  FOR MORE CAPACITY, INCREASE THE SIZE OF handleC::c2AppNote
            __NZ( !bAllOrNone && !bAllOrSome && !bSetRemaining ) ;                             // COMPLAIN IF NOT ALLoRnONE AND NOT ALLoRsOME AND NOT SETrEMAINING  U:: 20231106@1519: WHY IS bSetRemaining INSPECTED HERE?
            boolT bSetRemaining = F(flagsP) & flBOOKScwRITE_SETrEMAINING ;
            boolT bAllOrSome    = F(flagsP) & flBOOKScwRITE_ALLoRsOME    ;
            boolT bAllOrNone    = F(flagsP) & flBOOKScwRITE_ALLoRnONE    ;
        {
        if( phWroteP )
        FV( flBOOKScwRITE , flagsP ) ;
        //__( ppcpIdAptP && ( this == &processGlobal4I.bksTelemetrySys || this == &processGlobal4I.bksTelemetryApp || this == &processGlobal4I.bksTrace || this == &processGlobal4I.bksTraceDivert01 || this == &processGlobal4I.bksWord || this == &processGlobal4I.bksWords ) ) ; //CAPTURE OF TELEMETRY OR TRACE IS GUARANTEED TO NEVER INVOLVE USE OF A poolC INSTANCE; SUCH USAGE COULD EMIT TELEMETRY OR TRACE, CAUSING SCRATCH BOOK OVERFLOW
        //__( ppcpIdAptP && *ppcpIdAptP ) ; //20171112@1557: ADDED WITHOUT ANALYSIS WHILE EDITING TO PREALLOCATE TO AVOID USING POOL WHILE grabBookNow IS GRABBED
        if( POOP ) return 0 ;
        __NZ( cbBodyNew < cb1P + cb2P && F(flagsP) & flBOOKScwRITE_ALLoRnONE ) ;
        __NZ( !pb2P && cb2P ) ;

        //if( pb2P && !cb2P ) cb2P = thirdC::c_strlenIF( tin0P , pb2P ) ;
        //if( pb1P && !cb1P ) cb1P = thirdC::c_strlenIF( tin0P , pb1P ) ;  //20200920@1713: MOVED THESE 2 LINES EARLIER TO HERE W/O ANALYSIS
        if( pb2P && !cb2P && ((tin123S&)tin0P).pEther ) ((tin123S&)tin0P).pEther->traceF( tin0P , T("!exception: coding error ; booksC::writeF no longer calculates string length for pb2P") ) ;
        if( pb1P && !cb1P && ((tin123S&)tin0P).pEther ) ((tin123S&)tin0P).pEther->traceF( tin0P , T("!exception: coding error ; booksC::writeF no longer calculates string length for pb1P") ) ;
        //20231114@1257: REMOVED THE CALCULATION OF STRING LENGTH ; NOW !cb1P MEANS DO A NULL LENGTH WRITE

        if( POOP ) return 0 ;
        __( tin0P.idTypeTin - ifcIDtYPEtIN_123 ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL    

    }
        BLAMMOiD( 0x19191919 ) ;
    {
    if( this == &processGlobal4I.bksTelemetryApp )

    SCOOP
{
/*1*/countT booksC::writeF( tin0S& tin0P , const byteT* pb1P , countT cb1P , const byteT* pb2P , countT cb2P , const flagsT flagsP , handleC* const phWroteP /*U::, countT** ppcpIdAptP*/ )/*1*/

countT pcRef_postBookNameNoPuse2[ 0x10 ] ;                  //CS:CODEsYNC: 360fb005 360fb005

;
}
    postBookNameNoPuse2_f ,
    postBookNameNoPuse2_e ,
    postBookNameNoPuse2_d ,
    postBookNameNoPuse2_c ,
    postBookNameNoPuse2_b ,
    postBookNameNoPuse2_a ,
    postBookNameNoPuse2_9 ,
    postBookNameNoPuse2_8 ,
    postBookNameNoPuse2_7 ,
    postBookNameNoPuse2_6 ,
    postBookNameNoPuse2_5 ,
    postBookNameNoPuse2_4 ,
    postBookNameNoPuse2_3 ,
    postBookNameNoPuse2_2 ,
    postBookNameNoPuse2_1 ,
    postBookNameNoPuse2_0 ,
{
osTextT* ppostBookNameNoPuse2[] =                           //CS:CODEsYNC: 360fb005 360fb005

osTextT postBookNameNoPuse2_f[ TUCK ] ;
osTextT postBookNameNoPuse2_e[ TUCK ] ;
osTextT postBookNameNoPuse2_d[ TUCK ] ;
osTextT postBookNameNoPuse2_c[ TUCK ] ;
osTextT postBookNameNoPuse2_b[ TUCK ] ;
osTextT postBookNameNoPuse2_a[ TUCK ] ;
osTextT postBookNameNoPuse2_9[ TUCK ] ;
osTextT postBookNameNoPuse2_8[ TUCK ] ;
osTextT postBookNameNoPuse2_7[ TUCK ] ;
osTextT postBookNameNoPuse2_6[ TUCK ] ;
osTextT postBookNameNoPuse2_5[ TUCK ] ;
osTextT postBookNameNoPuse2_4[ TUCK ] ;
osTextT postBookNameNoPuse2_3[ TUCK ] ;
osTextT postBookNameNoPuse2_2[ TUCK ] ;
osTextT postBookNameNoPuse2_1[ TUCK ] ;
osTextT postBookNameNoPuse2_0[ TUCK ] ;

#define CBTsCRATCHbUFFER ( TICK >> 4 )
//20220106@1535: TOO BIG CANNOT ALLOCATE IN HEAP: #define CBTsCRATCHbUFFER ( TICK << 0 ) // 20211218@1753: OLD CODE FAILS ; RATHER THAN ANALYZE, JUST THROW MORE BYTES AT THE PROBLEM
//U:: TO FIND A BUG

//I SUPPORT UP TO 01 THREADS SIMULTANEOUSLY 
//20171117@2056: THE FOLLOWING IS A KLUDGE THAT I AM USING TO IMPLEMENT A HEAP SO THAT I CAN ELIMINATE THE USE OF PUSE IN ORDER TO AVOID NONMONOTONIC GRABBING

/**/
*/
  if 0 then i will calculate the null terminated length of pb2P
  if pb2P then should not be 0
  may be 0
 cb2P
  if not 0 then points to second input source
   is normally 0
  may be 0
 pb2P
   if 0 then i will calculate the null terminated length of pb1P
   should not be 0
  if  pb1P then specifies the number of bytes at pb1P
  if !pb1P then specifies the fill value and must be < TUCK
 cb1P
  if 0 then all remaining bytes of book will be set to (byteT)cb1P
  is normally not 0
  can be 0
 pb1P
 tin0P
parameters
for caller convenience, i optionally take input from oo sources
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

