
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinBaseP ) ;

}
    af1.walkF( tinBaseP , associateCBF ) ;

    af2.moonThePhotographersF( tinBaseP ) ;
    af2.idState ++ ;

    af1.walkF( tinBaseP , associateCBF ) ;

    af1 += af2 ;
    
    aFooS af2( tinBaseP , etThread ) ;
    aFooS af1( tinBaseP , etThread ) ;
{

TODO

}
    return 0 ;

    }
        }
            CONoUTrAW7( "walker [idw,idGroup,idState]: " , idw , " " , idGroup , "(" , idState , ")\r\n" ) ;

            }
                case IDG_aFooS : { idState = ((aFooS&)assWalker).idState ; break ; }
            {
            switch( idGroup )
            ZE( countT , idState ) ;

            countT idGroup = assWalker.idGroupF() ;
            associateC& assWalker = *(associateC*)(*pStqWalkerP)[ idw ] ;
        {
        for( countT idw = 1 ; idw <= cWalker ; idw ++ )
        countT cWalker = *pStqWalkerP ;
    {
    if( pStqWalkerP )

    CONoUTrAWb( "associateCBF [idGroupViewer,idStateViewer,idGroupView,idGroupViewee,idStateViewee]: " , idGroupViewer , "(" , idStateViewer , ") is viewing a view of type " , idGroupView , " of subject " , idGroupViewee , "(" , idStateViewee , ")\r\n" ) ;

    }
        }
            break ;
            idStateViewee = (*(const vFooS*)&assViewP).idStateViewed ;
        {
        case IDG_vFooS :
    {
    switch( assViewP.idGroupF() )
    ZE( countT , idStateViewee ) ;
    countT idGroupViewee = assViewP.idGroupSubjectF() ;
    countT idGroupView   = assViewP.idGroupF() ;

    }
        }
            break ;
            idStateViewer = (*(const aFooS*)&viewerP).idState ;
        {
        case IDG_aFooS :
    {
    switch( viewerP.idGroupF() )
    ZE( countT , idStateViewer ) ;
    countT idGroupViewer = viewerP.idGroupF() ;
{
boolT associateCBF( tin0S& tinBaseP , const assViewC& assViewP , const associateC& viewerP , const countT cArgP , staqC* const pStqWalkerP )

}
{
idStateViewed( idStateViewedP )
assViewC( IDG_vFooS , idGroupSubjectP , cbaP ) ,
vFooS::vFooS( countT cbaP , countT idGroupSubjectP , countT idStateViewedP ) :

}
{
vFooS::~vFooS( voidT )

NEWdELcLASS( 1 , vFooS )

}
    }
        new( 0 , tinBaseP , pbaViewP , sizeof( vFooS ) ) vFooS( sizeof( vFooS ) , idGroup , idState ) ;
    {
    if( cbaViewP >= sizeof( vFooS ) )
{
voidT aFooS::sayCheeseF( tin0S& tinBaseP , byteT* const pbaViewP , countT cbaViewP , associateC& viewerP )

}
{
idState( idStateLathFoo <<= 1 )
associateC( tinBaseP , etherP , IDG_aFooS , sizeof( vFooS ) ) ,
aFooS::aFooS( tin0S& tinBaseP , etherC& etherP ) :

;
}
    vFooS( countT cbaP , countT idGroupSubjectP , countT idStateViewedP ) ;
    virtual ~vFooS( voidT ) ;
    NEWdELcLASSpROTOS

    const countT idStateViewed ;
{
struct vFooS : public assViewC

;
}
    virtual voidT sayCheeseF( tin0S& tinBaseP , byteT* const pbaViewP , countT cbaViewP , associateC& viewerP ) ;
    aFooS( tin0S& tinBaseP , etherC& etherP ) ;

    countT idState ;
{
struct aFooS : public associateC

countT idStateLathFoo = TOCK >> 1 ;

#define IDG_vFooS               2
#define IDG_aFooS               1

/*1*/WAKEsHOWtEXT( "example.other.associateC.with.assViewC.stale" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

