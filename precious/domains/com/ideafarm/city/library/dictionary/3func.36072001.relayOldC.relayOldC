
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        TELL( "relayOldC: cleaning up" )
    
        THREADmODE1rESTORE
        DEL( pStPop4 ) ;
        DEL( pStPop3 ) ;
        DEL( pStPop2 ) ;
        DEL( pStPop1 ) ;
        DEL( pStPop0 ) ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        TELL( "deleting bang stacks" )
    
        if( pStPop4 ) { cPoof += *pStPop4 ; }
        if( pStPop3 ) { cPoof += *pStPop3 ; }
        if( pStPop2 ) { cPoof += *pStPop2 ; }
        if( pStPop1 ) { cPoof += *pStPop1 ; }
        if( pStPop0 ) { cPoof += *pStPop0 ; }
        TELL( "unregistering my bang stacks and calc poof" )
        ZE( countT , cPoof ) ;
    
        handleUnregisterIF( tin0P , idpt ) ; //P: ENDING NODE DEREGISTERS ITSELF AS HANDLE
    
        sgnDone_tmRelayOldInitiatorF.waitF( tin0P ) ;
        sgnDone_tmRelayOldKillF.waitF( tin0P ) ;
        sgnDone_tmRelayOldPopClientF4.waitF( tin0P ) ;
        sgnDone_tmRelayOldPopClientF3.waitF( tin0P ) ;
        sgnDone_tmRelayOldPopClientF2.waitF( tin0P ) ;
        sgnDone_tmRelayOldPopClientF1.waitF( tin0P ) ;
        sgnDone_tmRelayOldPopClientF0.waitF( tin0P ) ;
        sgnDone_tmRelayOldTeatAcceptorF.waitF( tin0P ) ;
    
        }
            }
                ++ s ; ((tin1S&)tin0P).pEtScratch->osSleepF( tin0P , TUCK * 0x40 ) ;
    
                if( sgnDone_tmRelayOldTeatAcceptorF ) break ;

                }
                    SCOOPSdEL
                    POOPR
                {
                else
                }
                    break ;
                    SCOOPSdEL
                {
                if( !POOP )
                sock.connectF( tin0P , home.idpTeat , (nicNameC&)home.idpTeat , 1 ) ;
                socketC sock( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
                SCOOPSnEW
            {
            while( !sgnDone_tmRelayOldTeatAcceptorF )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        
            //}
            //    if( POOP ) POOPR
            //
            //    while( !POOP && !home.idpTeat ) { ++ s ; ((tin1S&)tin0P).pEtScratch->osSleepF( tin0P , TUCK * 0x40 ) ; }
            //    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            //    SCOOPS
            //{
        {
        if( bLaunchedAcceptor )
        bQuit = 1 ; //U::ADDED WITHOUT STUDY
    
        }
            }
                }
                    }
                        if( POOP ) POOPR

                        DEL( pso ) ;
                        SCOOPS
                        pso->etherF( tin0P , *((tin1S&)tin0P).pEtScratch ) ;
                    {
                    else 
                    if( !ether && pso ) etThread.osThreadF( tin0P , countTC() , tmRelayOldServerCatchBagF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , RELAYiNFOaRGcOUNTS , (countT)pso , (countT)&sListen , (countT)&stIdptPopClient , (countT)&cLooksForNewPing ) ;
                    TELL( "launching tmRelayOldServerCatchBagF" )
    
                    //else { CONoUTrAW( "z" ) ; } //U::
                    }
                        break ;
                        if( POOP ) POOPR

                        DEL( pso ) ;
                        SCOOPS
                        pso->etherF( tin0P , *((tin1S&)tin0P).pEtScratch ) ;
                        //etherC::ifcSayIF( T("gasp!") , flSAY_APPEND | flSAY_LOG ) ;
                        TELL( "quitting" )
                    {
                    else if( bQuit )
                    }
                        continue ;
    
                        if( !etThread ) bLaunchedAcceptor = 1 ;
                        etThread.osThreadF( tin0P , countTC() , tmRelayOldTeatAcceptorF , &sgnDone_tmRelayOldTeatAcceptorF , 0 , flTHREADlAUNCH_null , 0 , 0 , RELAYiNFOaRGcOUNTS ) ;
                        etThread.osThreadF( tin0P , countTC() , tmRelayOldInitiatorF    , &sgnDone_tmRelayOldInitiatorF    , 0 , flTHREADlAUNCH_null , 0 , 0 , RELAYiNFOaRGcOUNTS , (countT)&stIdptPopClient , (countT)&cLooksForNewPing , (countT)&bReadyP ) ;
                        etThread.osThreadF( tin0P , countTC() , tmRelayOldKillF         , &sgnDone_tmRelayOldKillF         , 0 , flTHREADlAUNCH_null , 0 , 0 , RELAYiNFOaRGcOUNTS ) ;
    
                        }
                            etThread.osThreadF( tin0P , countTC() , tmRelayOldPopClientF , &sgnDone_tmRelayOldPopClientF4 , 0 , flTHREADlAUNCH_null , 0 , 0 , RELAYiNFOaRGcOUNTS , OLDiDtYPErELAYpOPcLIENTwORK_RIGHT    ) ;
                            etThread.osThreadF( tin0P , countTC() , tmRelayOldPopClientF , &sgnDone_tmRelayOldPopClientF3 , 0 , flTHREADlAUNCH_null , 0 , 0 , RELAYiNFOaRGcOUNTS , OLDiDtYPErELAYpOPcLIENTwORK_LEFT     ) ;
                            etThread.osThreadF( tin0P , countTC() , tmRelayOldPopClientF , &sgnDone_tmRelayOldPopClientF2 , 0 , flTHREADlAUNCH_null , 0 , 0 , RELAYiNFOaRGcOUNTS , OLDiDtYPErELAYpOPcLIENTwORK_EXPLODE2 ) ;
                            etThread.osThreadF( tin0P , countTC() , tmRelayOldPopClientF , &sgnDone_tmRelayOldPopClientF1 , 0 , flTHREADlAUNCH_null , 0 , 0 , RELAYiNFOaRGcOUNTS , OLDiDtYPErELAYpOPcLIENTwORK_EXPLODE1 ) ;
                            etThread.osThreadF( tin0P , countTC() , tmRelayOldPopClientF , &sgnDone_tmRelayOldPopClientF0 , 0 , flTHREADlAUNCH_null , 0 , 0 , RELAYiNFOaRGcOUNTS , OLDiDtYPErELAYpOPcLIENTwORK_IMPLODE  ) ;
    
                        {
                        if( pStPop0 && pStPop1 && pStPop2 && pStPop3 && pStPop4 )
        
                        TELL( "setting up 2.3" )
                    
                        pStPop4 = new( 0 , tin0P , LF ) stackC( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        pStPop3 = new( 0 , tin0P , LF ) stackC( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        pStPop2 = new( 0 , tin0P , LF ) stackC( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        pStPop1 = new( 0 , tin0P , LF ) stackC( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        pStPop0 = new( 0 , tin0P , LF ) stackC( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        TELL( "setting up 2.4" )
                    
                        }
                            if( idpthc && NICnAMElOCAL != ((nicNameC&)(portC&)idpthc).pcId[ 0 ] ) stIdptOpen.sinkF( tin0P , countTC() , (byteT*)&idpthc , flSTACKsINK_UNIQUE , subtractIdPortTimesOldF , (countT)&stIdptGossip ) ;
                            portTimeC idpthc = handleQueryIF( tin0P ) ;
                        {
                        stIdptOpen.sinkF( tin0P , countTC() , (byteT*)&idpt   , flSTACKsINK_UNIQUE , subtractIdPortTimesOldF , (countT)&stIdptGossip ) ;
                        //P: A NEWBIE CLIENT KNOWS ABOUT ITSELF AND THE HANDLE
            
                        DEL( pso ) ;
                        }
                            }
                                etThread.traceF( tin0P , T("could not write sBagOk for woth client") ) ;
                                POOPRqUIET
                            {
                            if( POOP )
                            pso->writeF( tin0P , sBagOk ) ;
                            soulC sBagOk( tin0P , TAG( TAGiDnULL ) , flSOUL_null , (countT)ifcOLDiDtYPEbAG_SERVERoK ) ;
                            SCOOPS
                        {
                        IFsCRATCHoK
                        bWoth = 0 ;
                        pso->etherF( tin0P , *((tin1S&)tin0P).pEtScratch ) ;
                        etThread.traceF( tin0P , T("writing woth bag ifcOLDiDtYPEbAG_SERVERoK") ) ;
                    {
                    if( bWoth ) //WOTH CLIENT MUST NOT BE REFUSED
            
                    }
                        //CONoUT( "client accepted" ) ;
                        //etThread.traceF( tin0P , T("accepted [nnPeer,idPortPeer]:    ")+T(nnPeer)+T("    ")+TF2(idPortPeer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        sListen.acceptF( tin0P , pso , idPortPeer , nnPeer , bRefuse ) ;
                        ZE( countT , idPortPeer ) ;
                        nicNameC nnPeer ;
                        boolT bRefuse = /*++ idClient == ((tin1S&)tin0P).glass.idThread && !( bRefused ++ ) ? 1 :*/ 0 ;
                        //static boolT bRefused ;
                    {
                    TELL( "waiting for a client to connect" )
                    ZE( socketC* , pso ) ;
        
                    if( bWoth ) etThread.osThreadF( tin0P , countTC() , tmRelayOldTickleF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)(portC*)&idpt , (countT)&bWoth ) ;
                {
                while( !POOP && !ether && !bQuit )
                ZE( countT , idClient ) ;
                boolT bWoth = 1 ;
            
                etThread.osTimeNowF( tin0P , timeB1 , timeB2 ) ;
                ZE( sCountT , timeB2 ) ;
                ZE( countT  , timeB1 ) ;
            
                TELL( "setting up 2.b" )
                if( !ether ) sListen.listenF( tin0P ) ;
                TELL( "setting up 2.c" )
            {
            if( idpt )
            TELL( "setting up 2" )
        {
        signC sgnDone_tmRelayOldInitiatorF( tin0P , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayOldKillF( tin0P , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayOldPopClientF4( tin0P , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayOldPopClientF3( tin0P , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayOldPopClientF2( tin0P , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayOldPopClientF1( tin0P , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayOldPopClientF0( tin0P , TAG( TAGiDnULL ) ) ;
        signC sgnDone_tmRelayOldTeatAcceptorF( tin0P , TAG( TAGiDnULL ) ) ;
        ZE( boolT , bLaunchedAcceptor ) ;
        ZE( countT , cLooksForNewPing ) ;
        stackC*& pStPop4 = *(stackC**)&_c8ni2P.c1 ;
        stackC*& pStPop3 = *(stackC**)&_c8ni1P.c8 ;
        stackC*& pStPop2 = *(stackC**)&_c8ni1P.c7 ;
        stackC*& pStPop1 = *(stackC**)&_c8ni1P.c6 ;
        stackC*& pStPop0 = *(stackC**)&_c8ni1P.c5 ;
    
        count8S _c8ni3P( (countT)&idSerialLathHeader , (countT)&idPortOrigin , (countT)&swsIdSerialReceived , (countT)&bAltSws , (countT)&cLeverPayload , (countT)&swsWrapRef ) ;
        count8S _c8ni2P( 0 , (countT)&stIdptTemp , (countT)&stIdptOpen , (countT)&stIdptGossip , (countT)&idAdamMediator , (countT)&swsIdptMediator , (countT)&swsIdptMediatorAlt , (countT)&cGossipIn ) ;
        count8S _c8ni1P( (countT)&idpt , (countT)&bQuit , (countT)&stPsoServer , (countT)&swsIdSerialReceived , 0 , 0 , 0 , 0 ) ;
    
        ZE( boolT , bAltSws ) ;
        ZE( countT , idSerialLathHeader ) ;
        ZE( countT , cGossipIn ) ;
        ZE( boolT , bTalk ) ;
    
        //}
        //    }
        //        if( !cTries && !handleQueryIF( tin0P ) ) handleRegisterMeIfIF( tin0P , idpt ) ; //P: A NEWBIE NODE WILL POLL FOR 4 TOCKS BEFORE REGISTERING ITSELF AS HANDLE
        //
        //        }
        //            if( handleQueryIF( tin0P ) ) break ;
        //            ether.osSleepF( tin0P , TOCK ) ;
        //        {
        //        while( !ether && cTries && cTries -- )
        //        countT cTries = TUCK / /* 8 */0x40 ;
        //        sleepC s( tin0P , TAG( TAGiDnULL ) ) ; //GIVE EXISTING NODES TIME TO ASSUME THE HANDLE ROLE
        //    {
        //{
        //if( !handleQueryIF( tin0P ) )
    
        idpt.timeStampIfF( tin0P , etThread ) ;
        idpt = idPort ;
        portTimeC idpt ;
    
        idPort = socketC::nicNameIF( tin0P , etThread ) ;

        sListen.etherF( tin0P , etThread ) ;

        }
            if( POOP ) POOPR

            }
                }
                    idpTry ++ ;
                    etThread.traceF( tin0P , T("could not bind to requested port [idPort]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    idPort = portC() ;
                    POOPRqUIET
                {
                else
                }
                    break ;
                    etThread.traceF( tin0P , T("bind aok to requested port [idPort]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( !POOP )
                idPort = sListen.bindF( tin0P , idpTry , nicNameC() , 1 ) ;
            {
            for(;;)
            countT idpTry = ifcIDpORT_RELAY ;

            SCOOPS
        {
        portC idPort ;
        socketC sListen( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL )/*U:: , 0 , flSOCKETc_TOPsECRET*/ ) ;
    {
    IFsCRATCHoK

    portTimeC idptHandle = handleQueryIF( tin0P ) ;

    switchStackC swsWrapRef( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , cLeverPayload , flSTACKc_FIFO|flSTACKc_GIVEsIGNnEWpLATE ) ;
    ZE( countT , cLeverPayload ) ;
    homeS& home = homeS::homeIF() ;
    ZE( boolT , bQuit ) ;
    ranUniC ruZeWo( tin0P , 1 , 1 ) ;
    const countT cKidThreadsSave = ((tin1S&)tin0P).cKidThreads ;

    switchStackC swsIdptMediatorAlt(    tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idAdamMediator , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    switchStackC swsIdptMediator(       tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , idAdamMediator , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    ZE( countT , idAdamMediator ) ;
    stackC stIdptPopClient(             tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ;
    stackC stIdptGossip(                tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ; // { idpt , timeBorn1 , timeBorn2 }, SORTED BY TIME BORN
    stackC stIdptOpen(                  tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ; // { idpt , timeBorn1 , timeBorn2 }, SORTED BY TIME BORN
    stackC stIdptTemp(                  tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) ) ; // { idpt , timeBorn1 , timeBorn2 }, SORTED BY TIME BORN
    switchStackC swsIdSerialReceivedAlt( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , pbLever , sizeof idPortOrigin ) ;
    switchStackC swsIdSerialReceived(    tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , pbLever , sizeof idPortOrigin ) ;
    const byteT* pbLever = (const byteT*)&idPortOrigin ;
    portC idPortOrigin ;
    stackC stPsoServer(                  tin0P , etThread , TAG( TAGiDnULL ) ) ;
    etherC& ether = etherC::etPrimeIF() ;
    _IO_
{
/*1*/relayOldC::relayOldC( tin0S& tin0P , etherC& etThread , boolT& bReadyP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

