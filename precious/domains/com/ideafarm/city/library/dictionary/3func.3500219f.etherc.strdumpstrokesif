
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        ) ;

            tpc
            )+
                    //TF2(sttc.cNote,flFORMAT_NObIGITvALUES)+
                    : TF2(*(measureT*)&sttc.cNote,flFORMAT_NObIGITvALUES)            // NObIGITvALUES MIGHT NOT BE NEEDED WHEN FORMATTING MEASURE
                    ? TF2(sttc.cNote,flFORMAT_NObIGITvALUES)
                sttc.idCaste == sc_ccSSSrEPEAT || sttc.idCaste == sc_ccSSS
            (
            tco+
            )+
                            : TF2(*(measureT*)&sttc.idAdam,flFORMAT_NObIGITvALUES)
                            //: TF2(sttc.idAdam,flFORMAT_NObIGITvALUES)
                            ? TF2(sttc.idAdam,flFORMAT_NObIGITvALUES)+(sttc.idCaste==sc_cFROMcONTROL?T(""):(T(" '")+T(post2)+T("'")))
                        : sttc.idCaste == sc_cALPHABET1 || sttc.idCaste == sc_cFROMaSCII || sttc.idCaste == sc_cFROMgRAPHICS || sttc.idCaste == sc_cSSSmARK || sttc.idCaste == sc_cFROMcONTROL
                        ? TF2(sttc.idAdam,flFORMAT_NObIGITvALUES)
                    : sttc.idCaste == sc_ccSSSrEPEAT || sttc.idCaste == sc_ccSSS
                    ? T(postIdAdam)
                postIdAdam
            (
            tpo+
            T(processGlobal4I.mapCaste(sttc.idCaste))+
            (bIdAdam?tb4+TF2(ids,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tColon+tb4:tn)+
            (ids==1?td:tn)+tcr+                                                                   //20240414@1514: ADDED tcr TO PRETTY UP THE FORMAT

        ether.strFuseF( tin0P , psttP , 

        const osTextT  post2[] = { (osTextT)sttc.idAdam , 0 } ;
        const osTextT* postIdAdam = mapAdamUse( sttc.idAdam ) ;

        mapCTC& mapAdamUse = ( sttc.idCaste == sc_ccSSS || sttc.idCaste == sc_cSSSmARK ) ? processGlobal4I.mapSSSIdAdam : processGlobal4I.mapAdam ;

        const strokeS& sttc = psttInP[ CSpREFIX - 1 + ids ] ;
    {
    for( countT ids = 1 ; ids <= psttInP->idAdam ; ids ++ )
    TN( tColon , ":" ) ;
    TN( tb4 , "    " ) ;
    TN( tb  , " " ) ;
    TN( tn  , ""  ) ;
    TN( tco , " , " ) ;
    TN( tpc , " )" ) ;
    TN( tpo , "( " ) ;
    TN( tcr , "\r\n" ) ;

    const boolT bIdAdam = 1 ;  //U:: USE A flagsP PARAMETER TO DECIDE
    //const boolT bIdAdam = !ether.strCompareF( tin0P , td , T("\r\n") ) ;

    }
        ether.strMakeF( tin0P , LF , psttP , T("") , cstta ) ; //CALLER MUST TAG ___( psttP ) ;
        const countT cstta = psttInP->idAdam * ( td.csF( tin0P ) + processGlobal4I.mapCaste.costMaxF() + processGlobal4I.mapAdam.costMaxF() /*+ 3 + 0x10*/ + 0x40/*U::USE EXACT REQUIREMENT; THIS LINE WAS EDITED WHEN EDITED DEF TO DISPLAY measureT VALUES*/ ) ;
    {

    //ether.traceF( tin0P , T("[delimiter]:  >>>>")+td+T("<<<<") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    TN( td , "    " ) ; if( psttDelimiterP ) td = T(psttDelimiterP) ;

    //FORMAT: "idCaste(idAdam,cNote) idCaste(idAdam,cNote) idCaste(idAdam,cNote) ..."

    etherC& ether = *((tin1S&)tin0P).pEther ;

    _IO_
    
    }
        if( POOP ) return ;
        __( !((tin1S&)tin0P).pEther ) ;
        __Z( psttInP ) ;
        __NZ( psttP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT etherC::strDumpStrokesIF( tin0S& tin0P , strokeS*& psttP , const strokeS* const psttInP , const strokeS* const psttDelimiterP )/*1*/

/**/
*/
 psttInP
 psttP
 tin0P
arguments
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

