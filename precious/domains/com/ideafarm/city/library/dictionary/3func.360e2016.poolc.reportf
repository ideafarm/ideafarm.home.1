
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    walkF( tinBaseP , slotsWalkTraceCBF , countTC( (countT)&etherP ) ) ;
    _IO_

    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT poolC::reportF( tinBaseS& tinBaseP , etherC& etherP )/*1*/

}
    }
        }
            }
                }
                    }
                        etherP.delF( tinBaseP , psttg ) ;
                        etherC::etRockIF( tinBaseP ).traceF( tinBaseP , !tDump.csF( tinBaseP ) ? psttg : (strokeS*)( T(psttg)+tDump ) ) ;
                        pn->glassF( tinBaseP , psttg ) ; ___( psttg ) ;
                        ZE( strokeS* , psttg ) ;

                        }
                            }
                                else psttc += CSpREFIX ;
                                }
                                    psttc += CSpREFIX + psttc->idAdam ;

                                    etherP.delF( tinBaseP , psttd ) ;
                                    tDump += tq+T(psttd)+tq ;
                                    if( tDump.csF( tinBaseP ) ) tDump += tb4 ;

                                    }
                                        etherP.delF( tinBaseP , psttDoomed ) ;
                                        etherP.strSubstringF( tinBaseP , psttd , idf , idl , psttDoomed ) ; ___( psttd ) ;
                                        countT idl = TOCK ;
                                        countT idf = 1 ;
                                        strokeS* psttDoomed = psttd ; psttd = 0 ;
                                    {
                                    if( psttd->idAdam > TOCK )

                                    etherP.strReplaceAnyF( tinBaseP , psttd , psttc , T(TbLACK) , T(" ") ) ; ___( psttd ) ;
                                    ZE( strokeS* , psttd ) ;
                                {
                                else if( psttc->idAdam )
                                }
                                    continue ;
                                    psttc += CSpREFIX ;
                                {
                                if( psttc->idAdam >= CSpREFIX && psttc[ CSpREFIX ].idCaste == sc_PREFIXlENGTH )

                                if( psttc->idCaste != sc_PREFIXlENGTH ) break ;
                            {
                            while( psttc < pstte )
                            //DISPLAY EACH STRING IN A STRING OF STRINGS WITH ARBITRARY NONUNIFORM NESTING

                            strokeS* pstte = psttRaw + CSpREFIX + psttRaw->idAdam ;
                            strokeS* psttc = psttRaw ;
                            strokeS* psttRaw = (strokeS*)( pbDataP + cbSlot * offb ) ;
                            countT cbSlot = 1 << pHeadP->expCbDrop ;
                        {
                        if( pn->idType == ifcIDtYPEdROPnOTE_strokeS )
                        TN( tq , "\"" ) ;
                        TN( tb4 , "    " ) ;
                        TN( tDump , "" ) ;

                        const dropNoteS* pn = pNotesP + offb ;
                    {
                    //if( pbBitsOwnedP[ offByte ] >> offBit & 1 )

                    countT offBit  = offb % SB ;
                    countT offByte = offb / SB ;
                {
                for( countT offb = 0 ; offb < cBits ; offb ++ )
            {
            //if( cFound )

            }
                if( pbBitsOwnedP[ offByte ] >> offBit & 1 ) cFound ++ ;

                countT offBit  = offb % SB ;
                countT offByte = offb / SB ;
            {
            for( countT offb = 0 ; offb < cBits ; offb ++ )
            ZE( countT , cFound ) ;
            countT cBits = 1 << pHeadP->expSlots ;
        {
        if( pNotesP )

        }
            etherP.delF( tinBaseP , psttg ) ;
            etherC::etRockIF( tinBaseP ).traceF( tinBaseP , psttg ) ;
            pHeadP->glassF( tinBaseP , psttg ) ; ___( psttg ) ;
            ZE( strokeS* , psttg ) ;
        {
        if( pHeadP )

        etherC& etherP = *(etherC*)cArgP ;
    {
    if( cArgP )
{
voidT slotsWalkTraceCBF( tinBaseS& tinBaseP , countT& cArgP , const sexHeadS* pHeadP , const byteT* pbBitsOwnedP , const dropNoteS* pNotesP , const byteT* pbDataP )

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

