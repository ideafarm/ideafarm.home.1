
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //TELLsYSc1( ifcIDtYPEtELLsYS_AOKfYIeXCEPTIONhANDLERpUSH )

    handleP.osF( ifcIDtYPEhANDLE_CONSOLEhANDLER , (countT)pConsoleHandlerF ) ;
    #endif

        BOSpOOP
        BOS( WHATgbo , BOSoK , SetConsoleCtrlHandler( pConsoleHandlerF , 1 ) )

    #elif defined( __NT__ )

        }
            handleP.cNoteF( ifcIDtYPEhANDLE_CONSOLEhANDLER , (countT)pInfo ) ;
            }
                BOSpOOP
                BOS( WHATgbo , BOSfAIL , DosSetSignalExceptionFocus( SIG_SETFOCUS , &info ) )
                ZE( ULONG , info ) ;
            {
            BOSpOOP
            BOS( WHATgbo , BOSfAIL , DosSetExceptionHandler( pInfo ) )
            pInfo->ExceptionHandler = pConsoleHandlerF ;
            pInfo->prev_structure = 0 ;
        {
        if( pInfo )
        EXCEPTIONREGISTRATIONRECORD* pInfo = (EXCEPTIONREGISTRATIONRECORD*)pbInfo ;
        newF( tinP , LF , pbInfo , sizeof( EXCEPTIONREGISTRATIONRECORD ) ) ; ___( pbInfo ) ;
        ZE( byteT* , pbInfo ) ;

    #ifdef __OS2__

    consoleHandlerFT pConsoleHandlerF = pConsoleHandlerFP ? (consoleHandlerFT)pConsoleHandlerFP : consoleHandlerDfltF ;

    _IO_

    }
        if( POOP ) return ;
        __( ~handleP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL    
{
/*1*/voidT thirdC::dosPushConsoleHandlerIF( tinS& tinP , handleC& handleP , voidT* pConsoleHandlerFP )/*1*/

#endif

    }
        return 0 ;                //A:ASSUME: THAT IS ENOUGH TIME FOR THIS PROCESS TO TERMINATE (DT OF processGlobal1I)
        Sleep( 1000 * 60 * 60 ) ; //A:ASSUME: BASE OS WILL TIMEOUT AND KILL PROCESS IN ABOUT 5000 MS

        }
            if( bGasp ) processGlobal2I._thirdC_flagsProcessState |= flPROCESSsTATE_SIGNAL_TO_GASP ;
                        processGlobal2I._thirdC_flagsProcessState |= flPROCESSsTATE_SIGNAL_TO_QUIT ;
        {
        if( bQuit )

        }
            default               : {                                                                                           bGasp = bQuit = 1 ; break ; }
            case CTRL_CLOSE_EVENT :
            case CTRL_C_EVENT     : { if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_IGNOREfIREbYoPERATOR ) )         bQuit = 1 ; break ; }
        {
        switch( idType )
        ZE( boolT , bGasp ) ;
        ZE( boolT , bQuit ) ;

        }
            CONoUTrAW( ostoSay ) ;
            OStEXTAK( ostoSay , "\r\n" ) ;
            OStEXTC(  ostoSay , osTidIF() , 0 ) ;
            OStEXTAK( ostoSay , "\r\nsignal thread [osTid]:    " ) ;
            OStEXT(   ostoSay , TUCK ) ;
        {
    {
    BOOL OSF consoleHandlerDfltF( DWORD idType ) // thirdC::thPrimeIF( tinP ) IS NOT STORED, BECAUSE THIS FUNCTION COULD EXECUTE LATE

    //CONJ: THE STACK FOR THE O.S. THREAD THAT WILL CALL ME IS SMALL.  I CANNOT USE FUNCTIONS SUCH AS boxC::boxC
    //THIS MUST RETURN QUICKLY (E.G. NOT SLEEP) BECAUSE THE O.S. BROADCASTS SHUTDOWN AND LOGOFF NOTICES SERIALLY

#elif defined( __NT__ )

    }
        else                                                                                                            return XCPT_CONTINUE_SEARCH ;
        if( pReportP && pReportP->ExceptionNum == XCPT_SIGNAL && pReportP->ExceptionInfo[ 0 ] != XCPT_SIGNAL_KILLPROC ) return XCPT_CONTINUE_EXECUTION ;
        pRegistrationP = pRegistrationP ; pContextP = pContextP ; pvP = pvP ;
    {
    ULONG _export OSF consoleHandlerDfltF( EXCEPTIONREPORTRECORD* pReportP , EXCEPTIONREGISTRATIONRECORD* pRegistrationP , CONTEXTRECORD* pContextP , voidT* pvP )

    //U: UPDATE THIS TO HAVE THE SAME FUNCTIONALITY AS THE NT FLAVOR

#if defined( __OS2__ )

//}
//    //while( !( F(processGlobal2I._thirdC_flagsProcessState) & flPROCESSsTATE_GLOBALdESTRUCTIONiScOMPLETE ) ) { ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ; }
//    //sleepC s( tinP , TAG( TAGiDnULL ) ) ;
//    //TELLsYSc1( ifcIDtYPEtELLsYS_READYtOdIEnu ) ; // IFF I AM MONITORED, I WILL NEVER RETURN FROM THIS
//    //CANNOT USE tellC HERE BECAUSE pTinF WILL NOT FIND THE TLS FRAME
//    //state C::writeToDiskIfIF( tinP ) ;
//{
//if( bDie ) // FOR THE DRIVER f040104, I WILL DO bDie == 1, WHICH HAS NO EFFECT SINCE IT IS NOT MONITORED
//
//}
//    thirdC::c_strncpyIF( tinP , tinP.postTell , ostoBuf , sizeof tinP.postTell ) ;
//    OStEXTC( ostoBuf , cCloseIgnored , 0 ) ;
//    OStEXTAK( ostoBuf , "refusalsToClose:" ) ;
//    OStEXT( ostoBuf , sizeof tinP.postTell ) //CODEsYNC: 12f0006 10200cc
//{
//HISTORICAL

/**/    
*/
  it is illegal to specify a value other than 0 in the definition of an adam
 pConsoleHandlerFP
  must be 0
 handleP
 tinP
arguments
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.10200cc.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$DosPushConsoleHandlerF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

