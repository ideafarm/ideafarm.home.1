
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmWindowsF )

//CONJ: THIS COMMENT IS WRONG BECAUSE tinBaseP IS NOW tinEarlyLate
//DONE WILL NOT DO THIS BECAUSE tinBaseP AND etThread ARE ALREADY GONE
//WARNING: IF I AM EDITED TO LAUNCH KID THREADS, I MUST EXPLICITLY WAIT HERE FOR THEM ALL TO END

processGlobal2I._thirdC_flagsProcessState |= flPROCESSsTATE_tmWindowsF_HASeNDED | flPROCESSsTATE_MAINtHREADiSaLONE ;

THREADmODE2rESTORE
}
    THREADmODE3rESTORE
    }
    
#endif

        etherC::loafIF( tinBaseP ) ; //U::DOODLING
        sgnReady.giveF( tinBaseP ) ;
        etThread.delF( tinBaseP , psttTitle ) ;

#else

        }
            thirdC::winDestroyWindowClassIF( tinBaseP , MAINwINDOWcLASSnAME ) ;
            ((tinNormalS&)tinBaseP).idPhase2 = 3 ;
            //LOGrAW( "tmWindowsF/dispatchola/-\r\n" ) ;
            TINSL
        {
        //TELL( "cleaning up" )

        }
            FIREmYSELF ;
            thirdC::third_flagsModeAdam1I_IF( tinBaseP ) &= ~( F(flADAMmODE1_tmWindows) ) ;
            }
                thirdC::third_flagsProcessStateI_IF( tinBaseP , flPROCESSsTATE_WM_CLOSE_RECEIVED , 1 ) ; // main WILL PROCEED TO CLEANUP WHEN IT SEES THIS
                POOPIES
            {
        {
        else
        }
            thirdC::winDispatchMessagesIF( tinBaseP ) ; // WM_CLOSE WILL DELETE pEtThread (WHICH DELETES tinBaseP) BEFORE THIS RETURNS
            //LOGrAW( "tmWindowsF/dispatchola/+\r\n" ) ;
            //FROM HERE ON DO NOT REFER TO ANY IFC OBJECTS (EG etThread)
            ((tinNormalS&)tinBaseP).idPhase2 = 2 ;
            DEL( pTaskP ) ;
            TELL( "pumping window messages" )
        {
        if( !etThread )
        sgnReady.giveF( tinBaseP ) ;

        else __1 ;        
        }
            pRootI->letRefF() ;
        
            etThread.delF( tinBaseP , psttTitle ) ;
            if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_HIDEwITHiCON ) ) thThread.winShowWindowF( tinBaseP , *pRootI , F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_LAUNCHmINIMIZED ? idcWINsHOW_MINIMIZE : /*idcWINsHOW_MAXIMIZE*/idcWINsHOW_SHOW ) ;
    
            }
                }
                    ((paperOldC&)paper).purgeF( tinBaseP ) ;
                    const paperOldC& paper = pRootI->selectPaperF( tinBaseP , ifcIDcMDpAPERsELECT_SETrENDER , idPaper ) ;
                {
                for( countT idPaper = cPapersRoot ; idPaper >= 1 ; idPaper -- )
            {

            thThread.winSetTitleF( tinBaseP , T(psttTitle) , *pRootI ) ;
        {
        if( pRootI )
        windowOldC* pRootI = windowOldC::getRefIF( tinBaseP ) ;

        }
            { windowOldC* pwq = new( 0 , tinBaseP , LF ) windowOldC( tinBaseP , etThread , cPapersRoot , 0 , 1 , ifCol , ifRow , cCol , cRow , cColClient , cRowClient , 1 ) ; ___( pwq ) ; } // winRoot MUST BE THE WO'TH WINDOW CONSTRUCTED
            thThread.winAdjustWindowPositionF( tinBaseP , ifCol , ifRow , cCol , cRow ) ;

            }
                cRow = cRowClient ;
                cCol = cColClient ;

                //}
                //    ifRow = 1 ;
                //    ifCol = 1 ;
                //    cRowClient = TUCK >> 1 ;
                //    cColClient = TUCK >> 1 ;
                //{

                }
                    ifRow = 0 /*x30*/ ;
                    ifCol = 0 /*x8*/ ;
                    cRowClient = cRowDisplay >> 0 ;
                    //cColClient = cColDisplay - 0x80 ;
                    //LOGrAW3( "[cColClient]: " , cColClient , "\r\n" ) ;
                    cColClient = cColDisplay >> 0 ;
                {
//#endif
                //else
                }
                    cRowClient = cRowDisplay ;
                    cColClient = cColDisplay ;
                    ifRow = 1 ;
                    ifCol = 1 ;
                {
                //if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_DEBUG ) )
//#if defined( NEVERdEFINED )
    
                thThread.osDisplaySizeF( tinBaseP , cColDisplay , cRowDisplay ) ;
                ZE( countT , cRowDisplay ) ;
                ZE( countT , cColDisplay ) ;
            {
            ZE( countT , cRowClient ) ;
            ZE( countT , cColClient ) ;
            ZE( countT , cRow ) ;
            ZE( countT , cCol ) ;
            ZE( sCountT , ifRow ) ;
            ZE( sCountT , ifCol ) ;

            //PSEUDODUPLICATED CODE: 1020171 0b0001b (APPARENTLY OBSOLETE COMMENT)
        {
        const countT cPapersRoot = 3 ; //MUST BE 3 OR GREATER BECAUSE EXIST 3 IS GUARANTEED (3 CAN BE USED AS SCRATCH)
    
        thThread.winCreateWindowClassF( tinBaseP , MAINwINDOWcLASSnAME , winMessageHandlerF ) ;
        //thThread.winCreateWindowClassF( tinBaseP , MAINwINDOWcLASSnAME , winMessageHandlerDebugF ) ;
        etherC::ether_pMainRefsIF( tinBaseP ) = new( 0 , tinBaseP , LF ) mainRefsS( tinBaseP , ether , pEtThread ) ; ___( etherC::ether_pMainRefsIF( tinBaseP ) ) ;
#if defined( NEVERdEFINED )
//20230403@1610: !defined -> defiend IN ORDER TO UNBREAK PRODUCTION CODE
//20230403@1109: defined -> !defined IN ORDER TO SEE WHETHER OLD GRAPHICS CODE WORKS (WHEN THIS THREAD IS SUPPRESSED, THE NEW GRAPHICS CODE WORKS)

        thirdC& thThread = etThread ;
        thirdC::third_idThreadWindowsIF( tinBaseP ) = ((tinNormalS&)tinBaseP).monitor.idThread ;
        strokeS*& psttTitle = *(strokeS**)pTaskP->c2 ;
        signC&    sgnReady  =    *(signC*)pTaskP->c1 ;
        //THIS IS A NO NO.  A FAILURE ON THIS THREAD CAN CAUSE RUSH SPIN OF THE CPU: etThread.osThreadSwitchingDesireF( tinBaseP , ifcTHREADpRIORITY_RUSH ) ;
        }
            __( ifMin < osMin ) ;
            countT ifMin = idwm_USER ;
            countT osMin = thirdC::winIdMsgUserIF( tinBaseP ) ;
        {
    
        ((tinNormalS&)tinBaseP).idPhase2 = 1 ;
        processGlobal2I.ebp_tmWindowsF_ = ebpAM() ; //winMessageHandlerWorkF WILL USE THIS VALUE TO FIND tinBaseP
        if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_NOsYSTEMtHREADS ) ) { __( ((tinNormalS&)tinBaseP).monitor.idThread - ifcIDtHREADlOW_tmWindowsOrServiceMainF ) ; }
        TELL( "setting up" )
    {
    if( pTaskP && pTaskP->c1 && pTaskP->c2 )
    THREADmODE3oN( flTHREADmODE3_MYoWNrECYCLER )
{
THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING ) //OBSERVED SLEEP BLAMMO FOR CONSOLE a45 OCCASIONALLY July 31,2005 DURING INSTALL; DID NOT ANALYZE

((tinNormalS&)tinBaseP).tell_tmWatchF_toIgnoreMeF() ;


/*1*/TASK( tmWindowsF )/*1*/

/**/
*/
/*

// tmWindowsF IS TO BE UNAFFECTED BY ether I.E. WHETHER THE CELL HAS BEEN FIRED

/**/
*/
 in particular, i must hang around and not return from WM_CLOSE until my whole process cleanup is complete
 i must do this because MS Windows is such a piece of shit
 i am essentially an orphan thread, hanging around while main d eletes all of this processes ifc objects
  for example, i must not use the T macro
 after that time, i must avoid referring to etThread or tinBaseP and i must also avoid referring to other ifc objects
wo tricky aspect of this thread is that it blocks in the WM_CLOSE handler, which destroys its etThread and its tinBaseP objects
 psttTitle
 sgnReady
arguments
 i wake up, create my root window, and wait patiently until i can maximize it
 i reset sgnReady and sleep for 01 tock
 the WM_QUIT causes the message pump to return
 my windows are all gone
 my root window handles the WM_DESTROY by destroying its object and posting WM_QUIT
 my root window handles the WM_CLOSE by destroying itself, which also destroys the input window, its child
 my root window receives a WM_CLOSE message
 the operator logs off
 since i can now maximize my root window, i do so, create my input window, and begin pumping window messages
 an operator logs on
 i detect that i cannot maximize my root window, so i patiently wait indefinitely (hours, days,...) for an operator to log on
 at boot, i am launched
example scenario: gui process that is launched automatically at boot
i create windows, handle their messages, and destroy them
\<A HREF=\"5.0b00012.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$tmWindowsF.0.html\"\>instances\</A\>
/*

#endif
}
    return rc ;

    }
        }
            break ;
            rc = ((tinNormalS&)tinBaseP).brcRaw ;
            BOSdOnOTtEST( WHATgbo , DefWindowProc( (HWND)hWindowP , idCmdP , p1P , p2P ) )
        {
        default:
        }
            break ;
            BOSdOnOTtEST( WHATgbo , EndPaint(   (HWND)hWindowP , &info ) )
            BOSpOOP
            BOS( WHATgbo , BOSoK , BeginPaint( (HWND)hWindowP , &info ) )
        {
        case WM_PAINT :
        }
            break ;
            BOSpOOP
            BOS( WHATgbo , BOSoK , PostMessage( (HANDLE)hWindowP , WM_QUIT , 0 , 0 ) )
            rc = ((tinNormalS&)tinBaseP).brcRaw ;
            BOSdOnOTtEST( WHATgbo , DefWindowProc( (HWND)hWindowP , idCmdP , p1P , p2P ) )
            }
                while( !( F(thirdC::third_flagsProcessStateI_IF(tinBaseP)) & flPROCESSsTATE_MAINtHREADcLEANUPiScOMPLETE ) ) { ++ s ; thirdC::dosSleepRawIF( tinBaseP , 250 ) ; }
                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
            {
            thirdC::third_flagsProcessStateI_IF( tinBaseP , flPROCESSsTATE_WM_CLOSE_RECEIVED , 1 ) ; // main WILL PROCEED TO CLEANUP WHEN IT SEES THIS

            DEL( etherC::ether_pMainRefsIF( tinBaseP ) ) ; // NO FURTHER USE FOR THIS
            TINSL
            DEL( pEtThread ) ; //THIS ALSO CAUSES tinBaseP TO BE DESTROYED
            DEL( ((tinNormalS&)tinBaseP).pEtScratch ) ;
            etherC*& pEtThread  = etherC::ether_pMainRefsIF( tinBaseP )->pEtThread ;
        {
        case idwm_CLOSE :
        case WM_CLOSE :
    {
    switch( idCmdP )
    ZE( countT , rc ) ;
    TINSL
{
extern "C" countT __export OSF winMessageHandlerDebugF( const handleC& hWindowP , const countT idCmdP , const countT p1P , const countT p2P )
PAINTSTRUCT info ;
//DEBUG

#if defined( NEVERdEFINED )

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

