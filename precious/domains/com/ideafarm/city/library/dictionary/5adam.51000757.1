
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tinBaseP ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tinBaseP , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etThread.traceF( tinBaseP , T("bye") ) ;
    etherC::loafIF( tinBaseP ) ;
    etThread.traceF( tinBaseP , T("ok") ) ;

    }
        etThread.traceF( tinBaseP , T("flashed sign") ) ;
        sgnGo.giveF( tinBaseP , ifcIDmODEsIGNgIVE_FLASH ) ;
        etThread.traceF( tinBaseP , T("flashing sign") ) ;

        }
            grabAccumulators.ungrabF( tinBaseP ) ;
            mMax = 0 ;
            mSum = 0 ;
            mMin = MAXcOUNTT ;
            cGorillasWaiting = 0 ;
            etThread.traceF( tinBaseP , T("----------------------------------------------------------------------- [idCycle,mMin,mMean,mMax]:   ")+TF2(++idCycle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)mMin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)mSum,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)mMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_null , ifcIDtRACEdIVERT_1 ) ;
            mSum /= cProcessors ;
            grabAccumulators.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
            etThread.traceF( tinBaseP , T("grabbing accumulators") ) ;
        {
        if( !ether )

        }
            ether.osSleepF( tinBaseP , TOCK >> 6 ) ;
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

            if( cWaiting == cProcessors ) break ;
            ether.traceF( tinBaseP , T("[cProcessors,cWaiting]:   ")+TF2(cProcessors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cWaiting,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            countT cWaiting = grabb.idGrabberHighF() - grabb.idGrabberOkF() ;
            const grabC& grabb = sgnGo ;
        {
        while( !ether )     // THIS LOOP PREVENTS RACE IN WHICH I GIVE SIGN BEFORE ALL GORILLA THREADS ARE ACTUALLY REGISTERED AS WAITING WITHIN THE grabC OBJECT WITHIN THE SIGN
        etThread.traceF( tinBaseP , T("looping until gorillas are really ready") ) ;

        }
            ether.osSleepF( tinBaseP , TICK >> 4 , TOCK , flSLEEP_null ) ;
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        {
        while( !ether && cGorillasWaiting < cProcessors )  // NORMALLY WILL EXECUTE ONLY WO ITERATION ; CODED THIS WAY TO HANDLE HEAVILY LOADED COMPUTER ON WHICH exerciseF DOES NOT COMPLETE WITHIN THE INTENDED PERIOD
        etThread.traceF( tinBaseP , T("waiting for gorillas to get ready") ) ;
    {
    while( !ether || cExtra -- )
    countT cExtra = 0 ;
    ZE( countT , idCycle ) ;

    ether.ifcHireF( tinBaseP , T("ifcIDaDAM_WATCHiDLEcPU") , ifcIDaDAM_HOMEfLAGS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;

    while( cDo -- ) etThread.osThreadF( TaRG2cBsTACK( tmGorillaF , CBsTACKmIN << 1 ) , (countT)&sgnGo , (countT)&cGorillasWaiting , (countT)&grabAccumulators , (countT)&mMin , (countT)&mSum , (countT)&mMax ) ;
    countT cDo = cProcessors ;
    TN( tb4 , "    " ) ;
    grabC grabAccumulators( tinBaseP , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS , ifcIDgRABlAYER_7BASEmISC1 ) ;    //20200610@2039: flGRABc_NOTjEALOUS ADDED WITHOUT ANALYSIS WITHOUT IDENTIFYING THIS AS THE CULPRIT IN A JEALOUSY
    ZE( measure04T , mMax  ) ;
    ZE( measure04T , mSum  ) ;
    ZE( measure04T , mMin  ) ;
    signC sgnGo( tinBaseP , TAG( TAGiDnULL ) ) ;
    ZE( countT , cGorillasWaiting ) ;

    etThread.traceF( tinBaseP , T("[cProcessors]:    ")+TF2(cProcessors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    const countT cProcessors = thirdC::osProcessorsIF( tinBaseP ) ;
{
if( pTaskP )
TASK( tmWorkF )
                            
DONE( tmGorillaF )
}
    etThread.osThreadSwitchingDesireF( tinBaseP , idPriorityDefault ) ;
    }
        }
            }
                grabAccumulatorsP.ungrabF( tinBaseP ) ;

                if( mMaxP < timeB1 ) mMaxP  = timeB1 ;
                                     mSumP += timeB1 ;
                if( mMinP > timeB1 ) mMinP  = timeB1 ;

                grabAccumulatorsP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                etThread.traceF( tinBaseP , T("time to complete: ")+TF2(timeB1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                etThread.osTimeSubtractF( tinBaseP , timeB1 , timeB2 , timeA1 , timeA2 ) ;
                etThread.osTimeNowF( tinBaseP , timeB1 , timeB2 ) ;
                ZE( sCountT , timeB2 ) ;
                ZE( countT , timeB1 ) ;
            {
            if( !bQuit )

            etThread.osThreadSwitchingDesireF( tinBaseP , idPriorityRude ) ;
            }
                //etThread.traceF( tinBaseP , t2 ) ;
                exerciseF( bQuit ) ;
                //etThread.traceF( tinBaseP , t1 ) ;
            {
            while( !bQuit && cDo -- )
            countT idPriorityRude = etThread.osThreadSwitchingDesireF( tinBaseP , ifcTHREADpRIORITY_LAZIEST ) ;

            const countT& bQuit = ether ;
            countT cDo = CeXERCISES ;

            etThread.osTimeNowF( tinBaseP , timeA1 , timeA2 ) ;
            ZE( sCountT , timeA2 ) ;
            ZE( countT , timeA1 ) ;
        {
        if( !ether )        

        sgnGoP.waitF( tinBaseP , flSIGNcWAIT_null ) ;

        //}
        //    ether.osSleepF( tinBaseP , TOCK << 6 ) ;
        //    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        //{
        //U::REMOVE IN PRODUCTION ; THIS IS TO ELICIT RACE CONDITION TO VERIFY THAT CODE HANDLES IT BY NOT ALLOWING SIGN TO BE GIVEN BEFORE ALL ARE WAITING

        inc02AM( cGorillasWaitingP ) ;
    {
    while( !ether )
    countT idPriorityDefault = etThread.osThreadSwitchingDesireF( tinBaseP , ifcTHREADpRIORITY_RUDE ) ;

    TN( t2 , "called  exerciseF" ) ;
    TN( t1 , "calling exerciseF" ) ;
    measure04T& mMaxP             = *(measure04T*)pTaskP->c6 ;
    measure04T& mSumP             = *(measure04T*)pTaskP->c5 ;
    measure04T& mMinP             = *(measure04T*)pTaskP->c4 ;
    grabC&      grabAccumulatorsP =      *(grabC*)pTaskP->c3 ;
    countT&     cGorillasWaitingP =     *(countT*)pTaskP->c2 ;
    signC&      sgnGoP            =      *(signC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmGorillaF )

}
    while( !bQuitP && cDo -- ) ;
    }
        cc = cDo * cDo ;
    {
    do
    ZE( countT , cc ) ;
    countT cDo = ( TICK << 5 ) - 1 ;     // WILL DO THIS + 1 ITERATIONS
{
voidT exerciseF( const countT& bQuitP )         // WO CALL TO ME TAKES ABOUT 1 TOCK ON factory 1

#define CeXERCISES 1

/*1*/WAKEhIDE( "ifcIDaDAM_WATCHiDLEcPU" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
