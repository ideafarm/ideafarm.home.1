
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //G:return idSubType ;

    //return rc ;
    //    rc = idSubType ;
    //if( bFingerAOK )
    //ZE( countT , rc ) ;
    //B:

    //B: countT rc = !bFingerAOK ? - 1 : idSubType ;     //20240812@1516: COMPILER BUGS

    }
        return idSubType ;

        }
            ((poopC*)this)->idSubType = 1 ;
            ((poopC*)this)->idType = ifcIDtYPEpOOP_JUICYlUCY ;
        {
        if( processGlobal1I.pSlab && processGlobal1I.pSlab->flagsi & fliSLABs_SHUTDOWN && !idSubType )

        }
            }
                }
                    }
                        }
                            FIREmYSELF

                            TELLsYSc3( ifcIDtYPEtELLsYS_ADAMfIRED , (byteT*)&info , sizeof info ) ;
                            info.idAdam     = ((tin1S&)tin0P).pag1->idAdam ;
                            info.idAdamRoot = processGlobal1I.idAdamRoot ;
                            tellInfoSysAdamFiredS info ;
                        {

                        //if( bChatter ) ((tin123S&)tin0P).pEther->traceF( tin0P , T("poopC& / i set bFired01 [idg,bFired01]:    ")+TF2(idg,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(((tin1S&)tin0P).pag1->_thirdC_.bFired01,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    else
                    }
                        //if( bChatter ) ((tin123S&)tin0P).pEther->traceF( tin0P , T("poopC& / bFired01 was already set") ) ;
                    {
                    if( setIfEqualsAM( ((tin1S&)tin0P).pag1->_thirdC_.bFired01 , 1 , 0 ) )

                    //if( bChatter ) ((tin123S&)tin0P).pEther->traceF( tin0P , T("poopC& / bFire is SET [idg,bFired01]:    ")+TF2(idg,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(((tin1S&)tin0P).pag1->_thirdC_.bFired01,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( home.pFireAll[ idg - 1 ].bFire || F(processGlobal2I._thirdC_flagsProcessState) & flPROCESSsTATE_RECEIVEDsIGNALtObEfIRED )

                // BUT IF I AM THE WO TO SET bFired01, I DO SPECIAL "I NOTICED JUST NOW" PROCESSING
                // IF bFired01 IS ALREADY SET, I DO NOTHING FURTHER
                // IF SO, THEN I TRY TO SET bFired01
                // BUT BEFORE DOING THAT, I LOOK TO SEE WHETHER MY PROCESS HAS BEEN FIRED (BY SOMEWO SETTING bFire IN home)
                // MY MAIN JOB IS TO RETURN A REFERENCE TO MY poopC MEMBER

                if( idg > CfIREaLLrANKS ) idg = 0 ;
                countT idg = ((tin1S&)tin0P).pag1->idGroupFireAll ;
            {
            if( pHome )

            homeS* pHome = &home ;
            homeS& home = homeS::homeIF() ;
        {
        if( pTin && ((tin1S&)tin0P).pag1 && ((tin123S&)tin0P).idTinNamed != ifcIDtINnAMED_tinHeartI && ((tin123S&)tin0P).idTinNamed != ifcIDtINnAMED_tinBreakI )
        tin0S* pTin = &tin0P ;
    {
    else
    }
        return - 2 ;    // ARBITRARY VALUE MORE UNIQUE THAN - 1

        }
            }
                //CONoUTrAW9( "poopC::op countT& [ebp,esp,this,fingerprint]: " , ebpAM() , " " , espAM() , " " , this , " " , fingerprint , "\r\n" ) ;
            {
            else
            }
                //CONoUTrAW9( "poopC::op countT& zombie fingerprint [ebp,esp,this,fingerprint]: " , ebpAM() , " " , espAM() , " " , this , " " , fingerprint , "\r\n" ) ;
            {
            if( getNegAM( fingerprint ) == FINGERnEG_POOPczOMBIE )  //OBSERVED DURING SHUTDOWN 0b2c5f
            //SEE: THIS OCCURS DURING windowOldC DESTRUCTION IF SOME SADAMS STILL EXIST
        {
        else
        }
            }
                BLAMMO
                //CONoUTrAW9( "poopC::op countT& [ebp,esp,this,fingerprint]: " , ebpAM() , " " , espAM() , " " , this , " " , fingerprint , "\r\n" ) ;
            {
            else
            }
                BLAMMO
                //CONoUTrAW9( "poopC::op countT& zombie fingerprint [ebp,esp,this,fingerprint]: " , ebpAM() , " " , espAM() , " " , this , " " , fingerprint , "\r\n" ) ;
            {
            if( getNegAM( fingerprint ) == FINGERnEG_POOPczOMBIE )  //OBSERVED DURING SHUTDOWN 0b2c5f
            //SEE: THIS OCCURS DURING windowOldC DESTRUCTION IF SOME SADAMS STILL EXIST
        {
        if( !bReportingException )

        bReportingException = F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_EXCEPTIONrEPORTINGiNpROGRESS ;
    {
    if( !bFingerAOK )
    boolT bFingerAOK = getNegAM( fingerprint ) == FINGERnEG_POOPc ;
    ZE( boolT , bReportingException ) ;

    TINSL
{
/*1*/poopC::operator const countT&( voidT ) const/*1*/

//THE IMPLICATION IS THAT THE poop MEMBER OF AN INSTANCE OF A CLASS MIGHT CHANGE EVEN IF THE INSTANCE IS CONST OR THE FUNCTION THAT CALLS ME IS CONST
//THE COMPILER IS NOT INFORMED OF THIS INTENTIONALLY
//I AM NOT REALLY A CONST FUNCTION ; I WILL MODIFY *this DURING SHUTDOWN

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

