
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    delF( tin0P , argError.post ) ;
    delF( tin0P , argOut.post ) ;
    strMakeF( tin0P , LF , psttErrorP , T(argError.post) ) ; // CALLER MUST TAG ___( psttErrorP ) ;
    strMakeF( tin0P , LF , psttOutP   , T(argOut.post)   ) ; // CALLER MUST TAG ___( psttOutP ) ;
    delF( tin0P , psttUnique ) ;
    sgnDone_tmError.waitF( tin0P ) ;
    sgnDone_tmOut.waitF( tin0P ) ;

    }
        __Z( bDone ) ;
        while( !POOP && cTries -- ) ;
        }
            }
                ++ s ; osSleepF( tin0P , TUCK * 0x10 ) ;
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                SCOOPSdEL
                POOPR
            {
            else
            }
                break ;
                bDone = 1 ;
                SCOOPSdEL
            {
            if( !POOP )

            boxC process( tin0P , *((tin1S&)tin0P).pEtScratch , T("//process/")+T(psttUnique)+T("/")+T(psttExeP) , 0 , 0 , 0 , 1 ) ;

            SCOOPSnEW
        {
        do
        ZE( boolT , bDone ) ;
        countT cTries = 0x10 ;
    {
    IFsCRATCHoK

    }
        }
            ++ s ; osSleepF( tin0P , TOCK ) ; //U: IF THIS ISN''T LONG ENOUGH, THE PROCESS BOX WON''T CONSTRUCT AND WE''LL HAVE A LEAK
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        {
        { ZE( countT , tnu ) ; osThreadF( tin0P , tnu , tmErrorF , &sgnDone_tmError , 0 , flTHREADlAUNCH_null , 0 , 0 , (countT)&argError ) ; }
        { ZE( countT , tnu ) ; osThreadF( tin0P , tnu , tmOutF   , &sgnDone_tmOut   , 0 , flTHREADlAUNCH_null , 0 , 0 , (countT)&argOut   ) ; }
    {
    signC sgnDone_tmError( tin0P , TAG( TAGiDnULL ) ) ;
    signC sgnDone_tmOut( tin0P , TAG( TAGiDnULL ) ) ;
    argS argError( *this , psttUnique , psttExeP ) ;
    argS argOut( *this , psttUnique , psttExeP ) ;
    strUniqueF( tin0P , psttUnique ) ; ___( psttUnique ) ;
    ZE( strokeS* , psttUnique ) ;
    _IO_

    }
        if( POOP ) return ;
        __NZ( psttInP ) ; //U: NOT SUPPORTED YET
        __NZ( psttArgsP ) ; //U: NOT SUPPORTED YET
        __Z( psttExeP ) ;
        __NZ( psttErrorP ) ;
        __NZ( psttOutP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::strFromProcessF( tin0S& tin0P , strokeS*& psttOutP , strokeS*& psttErrorP , const strokeS* const psttExeP , const strokeS* const psttArgsP , const strokeS* const psttInP )/*1*/

/**/
*/
 psttInP
 psttArgsP
 psttExeP
 psttErrorP
 psttOutP
arguments
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.103002d.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strFromProcessF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

