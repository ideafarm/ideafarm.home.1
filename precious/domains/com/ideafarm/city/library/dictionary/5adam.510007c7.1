
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinBaseP ) ;

etThread.traceF( tinBaseP , T("ok") ) ;

}
    cReceivedFileWindows = 0 ;
    etThread.traceF( tinBaseP , T("received [cReceivedFileWindows]:    ")+TF2(cReceivedFileWindows,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    etThread.traceF( tinBaseP , T("process [mTocks]:    ")+TT(timeE1,timeE2)+tb4+TF2(mTocksE,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tinBaseP , T("throw   [mTocks]:    ")+TT(timeT1,timeT2)+tb4+TF2(mTocksT,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tinBaseP , T("[mGBits]:            ")+TF2(mGBits,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tinBaseP , T("[cGram]:            ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    measureT mGBits = (measureT)( cb04Thrown << 3 ) / ( TICK << 2 ) ;

    measureT mTocksE = (measureT)timeE1 / TOCK ;
    measureT mTocksT = (measureT)timeT1 / TOCK ;

    etThread.osTimeSubtractF( tinBaseP , timeE1 , timeE2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO PROCESS
    etThread.osTimeNowF( tinBaseP , timeE1 , timeE2 ) ;
    ZE( sCountT , timeE2 ) ;
    ZE( countT  , timeE1 ) ;

    }
        ++ s ; ether.osSleepF( tinBaseP , TOCK >> 4 ) ;
        etThread.traceF( tinBaseP , T("waiting [cThrown,cCaught1,cCaught2,cProcessed]:    ")+TF2(cThrown,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cCaught1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cCaught2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( cProcessed < cThrown )

    etThread.osTimeSubtractF( tinBaseP , timeT1 , timeT2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO THROW
    etThread.osTimeNowF( tinBaseP , timeT1 , timeT2 ) ;
    ZE( sCountT , timeT2 ) ;
    ZE( countT  , timeT1 ) ;

    }
        }
            }
                }
                    cbDone += cbNow ;
                    pbc    += cbNow ;

                    cb04Thrown += cbGram ;
                    cThrown ++ ;

                    sThrow.writeF( tinBaseP , idPortCatch , nicNameC() , pbGram , cbGram ) ;
                    //if( !( idGram % TUCK ) ) etThread.traceF( tinBaseP , T("sending [idGram,cbNow,cbGram]:    ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT cbGram = sizeof( gramHeadFileWindowS ) + cbNow ;
                    //CONoUTrAW( "!" ) ;
                    etThread.memCopyF( tinBaseP , pbPayload , pbc , cbNow ) ;
                    head.secret = secretToUse ;
                    head.len    = cbNow  ;
                    head.off    = cbDone ;
                    head.idCmd  = ifcIDcMDgRAM_PUTfILEwINDOW ;
                    head.cbThisGram = sizeof head + cbNow ;
                    //etThread.traceF( tinBaseP , T("throwing window [secretToUse]:    ")+TF2(secretToUse,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    //CONoUTrAW( "+" ) ;

                    idGram ++ ;

                    cbDo -= cbNow ;

                    ;
                        : CBpAYLOAD
                        ? cbDo
                    countT cbNow = cbDo < CBpAYLOAD

                    //etThread.traceF( tinBaseP , T("waited  for a secret") ) ;
                    }
                        Sleep( 100 ) ;
                    {
                    while( !secretToUse )
                    //etThread.traceF( tinBaseP , T("waiting for a secret") ) ;
                {
                while( cbDo )
                countT cbDo = cbw ;
                byteT* pbc = pbw ;

                //etThread.boxPutF( tinBaseP , tFileIn+T(".window.")+tIdWindow , pbw , cbw ) ;
                //etThread.traceF( tinBaseP , T("[tIdWindow,cb]:    ")+tIdWindow+tb4+TF2(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                TN( tIdWindow , "" ) ; tIdWindow = TF3(++idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;
            {
            else
            if( !pbw || !cbw ) break ;

            fwsIn.getF( tinBaseP , pbw , cbw ) ;
            ZE( countT , cbw ) ;
            ZE( byteT* , pbw ) ;
        {
        while( !ether )
        //etThread.traceF( tinBaseP , T("sending begun") ) ;
        ZE( count04T , cbDone ) ;
        byteT*     pbPayload = pbGram + sizeof( gramHeadFileWindowS ) ;
        gramHeadFileWindowS& head      = *(gramHeadFileWindowS*)pbGram ;
        byteT      pbGram[ sizeof( gramHeadFileWindowS ) + CBpAYLOAD ] ;
        ZE( countT , idWindow ) ;

        fileWindowsC fwsIn( tinBaseP , etThread , tFileIn ) ;

        sThrow.bindF( tinBaseP ) ;
        socketC sThrow( tinBaseP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
    {
    ZE( countT , idGram ) ;

    etThread.osTimeNowF( tinBaseP , timeA1 , timeA2 ) ;
    ZE( sCountT , timeA2 ) ;
    ZE( countT  , timeA1 ) ;
{
while( !ether )
TN( tFileIn     , "///d/tmp/foo.ttt" ) ;

Sleep( 4000 ) ;     // LET WORKER THREADS GET SET UP
CONoUTrAW( "\r\n" ) ;

etThread.osThreadF( TaRG1( tmGetSecretF  ) , (countT)&secretToUse ) ;
etThread.osThreadF( TaRG1( tmObey1F       ) , (countT)&secretToUse , (countT)&cPoured ) ;
ZE( countT , secretToUse ) ;
etThread.osThreadF( TaRG1( tmEpochClockF )                        ) ;

}
    ++ s ; ether.osSleepF( tinBaseP , TOCK >> 2 ) ;
{
while( !idPortCatch )
sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
TN( tb4 , "    " ) ;

etThread.osThreadF( TaRG1( tmCatchF ) , (countT)&cPoured ) ;
ZE( countT , cPoured ) ;

TODO

DONE( tmCatchF )
}
    sCatch.readF( tinBaseP , (const countT&)ether , pbFastBuffer , sizeof pbFastBuffer , cPouredP ) ;

    idPortCatch = sCatch.bindF( tinBaseP ) ;
    socketC sCatch( tinBaseP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    countT& cPouredP = *(countT*)pTaskP->c1 ;
{
if( pTaskP )
TASK( tmCatchF )

DONE( tmObey1F )
}
    }
        Sleep( 0 ) ;

        }
            pbci     += cbThis ;
            cPouredP ++ ;
            cCaught1 ++ ;

            }
                }
                    pbco += cbDo ;
                    memcpy( pbco , pbThis + cbDone , cbDo ) ;
                {
                else
                if( cbDo > pbwe - pbco ) { BLAMMO ; }           //A:ASSUME: FILE WINDOW IS LARGE ENOUGH TO CONTAIN THE LARGEST POSSIBLE INCOMING PACKET (WORST CASE IS cbDone==0 AND cbThis IS LARGEST POSSIBLE PACKET)
                countT cbDo = cbThis - cbDone ;

                pbco = pbw ;
                pbwe = pbw + cbw ;
                if( !pbw || !cbw ) { BLAMMO ; }
                fwsBuffer.getF( tinBaseP , pbw , cbw ) ;
                cbw = 0 ;
                pbw = 0 ;

                }
                    pbco += cbDone ;
                    memcpy( pbco , pbThis , cbDone ) ;
                {
                if( cbDone )

                countT cbDone = pbwe - pbco ;
            {
            else
            }
                pbco += cbThis ;
                memcpy( pbco , pbThis , cbThis ) ;          // THIS INCLUDES THE offNext FIELD, WHICH WILL BE USELESS TO tmObey2F AND AVAILABLE FOR tmObey2F TO USE AS SCRATCH BUFFER OR TO IGNORE
            {
            if( cbThis <= pbwe - pbco )

            countT cbThis = 4 * sizeof( countT ) + cbData + sizeof( sockaddr_in6 ) ;
            byteT* pbThis = pbci ;

            pcLagOffNext    =  &offNext ;
            countT& cbData  = ((countT*)pbci)[ 3 ] ;
            countT& idGram  = ((countT*)pbci)[ 1 ] ;
            countT& offNext = ((countT*)pbci)[ 0 ] ;        // I WILL USE THIS VALUE ON MY NEXT ITERATION TO POSITION MYSELF IN THE CIRCULAR BUFFER TO READ THE NEXT RECORD

            //
            //  01+cbData sizeof( sockaddr_in6 )    from
            //  01        cbData                    data
            //  c         4                         cbData
            //  8         4                         rc
            //  4         4                         idGram (serial number)
            //  0         4                         offNext
            //
            //  offset    length                    description
            //
            // INPUT LAYOUT (FROM s_readF WRITING TO MY CIRCULAR BUFFER pbFastBuffer)

            if( pbci + cbMin > pbe             ) { BLAMMO ; }
            if( pcLagOffNext                   ) pbci = pbFastBuffer + *pcLagOffNext ;      // THE PRECEDING RECORD TELLS ME WHERE IN THE CIRCULAR BUFFER TO POSITION MYSELF
            if( pcLagOffNext && !*pcLagOffNext ) { BLAMMO ; }
        {
        while( cPouredP != idGramLath )      // INTENDED TO HANDLE WRAP AOK
    {
    while( !ether )
    ZE( countT* , pcLagOffNext ) ;
    byteT* pbci = pbCircle ;
    const byteT* const pbe = pbFastBuffer + sizeof pbFastBuffer ;
    byteT* const pbCircle = pbFastBuffer + sizeof( countT ) ;
    countT& idGramLath = *(countT*)pbFastBuffer ;
    const countT cbMin = 0xc + ifcCBdATAGRAMmAX + sizeof( sockaddr_in6 ) ;

    while( cDo -- ) etThread.osThreadF( TaRG1( tmObey2F ) , (countT)&secretToUseP , ++ cWorker , cProcessorsObey2 , (countT)&cPouredP ) ;
    ZE( countT , cWorker ) ;
    countT cDo = cProcessorsObey2 ;

    etThread.traceF( tinBaseP , T("using [cProcessors,cProcessorsObey2]:    ")+TF2(cProcessors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessorsObey2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    const countT cProcessorsObey2 = cProcessors < 7 ? 1 : cProcessors - 5 ;     // "- 5" IS OPTIMAL ON factory2
    const countT cProcessors      = thirdC::osProcessorsIF( tinBaseP ) ;

    etThread.boxPutF( tinBaseP , tFileOut , "X" , 1 ) ;
    TN( tFileOut , "///d/tmp/foo.received.fws.ttt" ) ;
    TN( tb4 , "    " ) ;

    byteT* pbco = pbw ;
    byteT* pbwe = pbw + cbw ;
    if( !pbw || !cbw ) { BLAMMO ; }         //SHOULD BE IMPOSSIBLE SINCE OPENING FOR WRITING ; U:: fileWindowsC WILL FAIL IF NO MORE SPACE ON DISK OR DISK I/O FAILURE
    fwsBuffer.getF( tinBaseP , pbw , cbw ) ;    //U:: ACCESSES TO THIS MEMORY WILL EXCEPTION IF DISK I/O FAILURE ; NEED TO USE RESTART TO RECOVER FROM SUCH A FAILURE
    ZE( countT , cbw ) ;
    ZE( byteT* , pbw ) ;

    fileWindowsC fwsBuffer( tinBaseP , etThread , tFileBuffer , flFILEwINDOW_WRITE | flFILEwINDOW_DOnOTvALIDATE ) ;
    etThread.boxPutF( tinBaseP , tFileBuffer , "X" , 1 ) ;
    TN( tFileBuffer     , "///d/tmp/foo.buffer.ttt" ) ;

    etThread.osThreadF( TaRG1( tmComplainF ) ) ;

    countT& cPouredP     = *(countT*)pTaskP->c2 ;
    countT& secretToUseP = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmObey1F )                            // I SINGLEHANDEDLY COPY DATA OUT OF THE CIRCULAR BUFFER THAT s_readF WRITES TO, APPENDING THE INCOMING DATA TO A BUFFER FILE THAT GROWS WITHOUT BOUND ; I DO THIS AS QUICLY AS POSSIBLE SO THAT s_readF RARELY HAS TO WAIT FOR ME ; MAKING s_readF WAIT CAUSES PACKET LOSS

DONE( tmObey2F )
}
    }
        Sleep( 0 ) ;
        }
            }
                //etThread.traceF( tinBaseP , T("moving file window") ) ;
                }
                    cb04BufferDone += pbci - pbciSave ;

                    }
                        }
                            }
                                }
                                    //etThread.traceF( tinBaseP , T("backlog [thrown,processed,backlog]:    ")+TF2(cThrown,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBacklog,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    countT cBacklog = cThrown - cProcessed ;
                                    inc02AM( cProcessed ) ;

                                    }
                                        if( pbw && cbw == head.len ) etThread.memCopyF( tinBaseP , pbw , pbPayload , head.len ) ;

                                        fwsOut.getF( tinBaseP , pbw , cbw , head.len , head.off ) ;
                                        ZE( countT , cbw ) ;
                                        ZE( byteT* , pbw ) ;
                                    {

                                    // etThread.traceF( tinBaseP , T("received [cmd,off,len]:    ")+TF2(head.idCmd,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)head.off,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(head.len,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    inc02AM( cReceivedFileWindows ) ;

                                    byteT* pbPayload = pbData + sizeof( gramHeadFileWindowS ) ;

                                    //etThread.traceF( tinBaseP , T("===================================== file window accepted [cAccepted]:    ")+TF2(++cAccepted,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                {
                                else
                                if( !bOk ) etThread.traceF( tinBaseP , T("secret rejected") ) ;

                                }
                                    }
                                        break ;
                                        bOk = 1 ;
                                    {
                                    if( secretTry == secretOk )

                                    //etThread.traceF( tinBaseP , T("PUTfILEwINDOW [offEpochHonor,offSlot,offSecret,secretOk[0],secretOk[1],secretOk,secretTry,bOk]:    ")+TF2(offEpochHonor,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSecret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(secretOk0,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(secretOk1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(secretOk,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(secretTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(secretTry==secretOk?".":"X") ) ;

                                    //countT secretOk1 = ppcSecrets[ offSlot ][ 1 ] ;
                                    //countT secretOk0 = ppcSecrets[ offSlot ][ 0 ] ;
                                    countT secretOk  = ppcSecrets[ offSlot ][ offSecret ] ;
                                    countT secretTry = head.secret ;
                                    countT offSecret = offSecretF( tinBaseP , etThread , nnFrom , offSlot ) ;
                                    countT offSlot   = offEpochHonor % CePOCHsLOTS ;
                                {
                                for( countT offEpochHonor = OFFePOCHhONORmIN ; offEpochHonor <= OFFePOCHhONORmAX ; offEpochHonor ++ )           //U:: NEED TO HANDLE WRAP OF offEpochHonor EVERY 136 YEARS
                                ZE( boolT , bOk ) ;
                                //etThread.traceF( tinBaseP , T("PUTfILEwINDOW ---------------------------------------------------------------------------------") ) ;

                                gramHeadFileWindowS& head = *(gramHeadFileWindowS*)pbData ;
                            {
                            case ifcIDcMDgRAM_PUTfILEwINDOW :
                            }
                                break ;
                                secretToUseP = head.secret ;        //A:ASSUME: ATOMIC (secretToUseP MUST ALWAYS CONTAIN A VALID SECRET)
                                //etThread.traceF( tinBaseP , T("received [secret]:    ")+TF2(head.secret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                gramHeadSecretS& head = *(gramHeadSecretS*)pbData ;
                            {
                            case ifcIDcMDgRAM_USEtHISsECRET :
                            }
                                break ;
                                sThrow.writeF( tinBaseP , idPortCatch /*idpFrom*/ , nnFrom , (byteT*)&gram , sizeof gram ) ;

                                //gram.pad3   = 0x3d3d3d3d ;
                                //gram.pad2   = 0x3d3d3d3d ;
                                //gram.pad1   = 0x3d3d3d3d ;
                                gram.secret = secret ;
                                gram.idCmd = ifcIDcMDgRAM_USEtHISsECRET ;
                                gram.cbThisGram = sizeof gram ;
                                gramHeadSecretS gram ;

                                //etThread.traceF( tinBaseP , T("dispensing [offSlotHonorNewest,offSecret,secret]:    ")+TF2(offSlotHonorNewest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSecret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(secret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                countT secret    = ppcSecrets[ offSlotHonorNewest ][ offSecret ] ;
                                countT offSecret = offSecretF( tinBaseP , etThread , nnFrom , offSlotHonorNewest ) ;

                                countT offSlotHonorNewest = OFFePOCHhONORmAX   % CePOCHsLOTS ;
                            {
                            case ifcIDcMDgRAM_DISPENSEsECRET :
                        {
                        switch( head.idCmd )
                        gramHeadS& head = *(gramHeadS*)pbData ;

                        }

                            }
                                }
                                    break ;
                                    BLAMMO ;
                                    etThread.traceF( tinBaseP , T("received unexpected [from.sin6_family]:    ")+TF2(from.sin6_family,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                {
                                default :
                                }
                                    break ;
                                    BLAMMO ;
                                    etThread.traceF( tinBaseP , T("received AF_INET [from.sin6_family]:    ")+TF2(from.sin6_family,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                {
                                case AF_INET :
                                }
                                    break ;

                                    if( !nnFrom ) nnFrom = NICnAMElOCAL ;

                                    }
                                        pcOut[ 3 - offi ] = ((tinFullS&)tinBaseP).brcRaw ;
                                        BOSdOnOTtEST( WHATgbo , ntohl( pcIn[ offi ] ) )
                                    {
                                    for( countT offi = 0 ; offi < 4 ; offi ++ )
                                    countT* pcOut = (countT*)(const countT*)nnFrom ;
                                    countT* pcIn  = (countT*)from.sin6_addr.u.Byte ;

                                    idpFrom = ((tinFullS&)tinBaseP).brcRaw ;
                                    BOSdOnOTtEST( WHATgbo , ntohs( from.sin6_port ) )
                                {
                                case AF_INET6 :
                            {
                            switch( from.sin6_family )
                        {
                        nicNameC nnFrom ;
                        ZE( countT , idpFrom ) ;

                        cCaught2 ++ ;

                        if( from.sin6_family != AF_INET6 ) { BLAMMO ; }

                        sockaddr_in6& from   = *(sockaddr_in6*)pbci ; pbci += sizeof( sockaddr_in6 ) ;
                        byteT*        pbData = pbci                 ; pbci += cbData                 ;

                        pbci += 4 * sizeof( countT ) ;

                        if( !idGram ) { BLAMMO ; }

                        countT& cbData    = ((countT*)pbci)[ 3 ] ;
                        countT& rc        = ((countT*)pbci)[ 2 ] ;
                        countT& idGram    = ((countT*)pbci)[ 1 ] ;
                        countT& offNextNU = ((countT*)pbci)[ 0 ] ;      // THIS POINTS INTO THE CIRCULAR BUFFER USED BY s_readF AND IS USELESS TO ME

                        //
                        //  01+cbData sizeof( sockaddr_in6 )    from
                        //  01        cbData                    data
                        //  c         4                         cbData
                        //  8         4                         rc
                        //  4         4                         idGram (serial number)
                        //  0         4                         offNextNU
                        //
                        //  offset    length                    description
                        //
                    {
                    else
                    if( cIn % cWorkersP != offWorkerP ) pbci += cbThis ;

                    //CONoUTrAW( "+" ) ;
                    cIn ++ ;

                    if( bFail1 || bFail2 ) break ;     // CLOSES THE CURRENT FILE WINDOW AND, IN THE NEXT ITERATION, OPENING A NEW FILE WINDOW POSITIONED AT THE BEGINNING OF THE CURRENT RECORD

                    boolT  bFail2 = bFail1 ? 0 : pbci + cbThis > pbcie ;
                    countT cbThis = bFail1 ? 0 : 4 * sizeof( countT ) + ((countT*)pbci)[ 3 ] + sizeof( sockaddr_in6 ) ;
                    boolT  bFail1 = pbci + 4 * sizeof( countT ) > pbcie ;
                    
                    byteT* pbciSave = pbci ;

                    }
                        Sleep( 0 ) ;
                    {
                    while( cIn == idGramPouredLathP )
                {
                while( pbci < pbcie )

                byteT* pbcie = pbBufw + cbBufw ;
                byteT* pbci  = pbBufw ;

                }
                    break ;
                    //etThread.traceF( tinBaseP , T("recd: no more input") ) ;
                {
                if( !pbBufw || !cbBufw )

                //etThread.traceF( tinBaseP , T("window [cb04BufferDone,cbBufw]:    ")+TF2((countT)cb04BufferDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbBufw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                fwsBuffer.getF( tinBaseP , pbBufw , cbBufw , 0 , cb04BufferDone ) ;
                ZE( countT , cbBufw ) ;
                ZE( byteT* , pbBufw ) ;

                fileWindowsC fwsBuffer( tinBaseP , etThread , tFileBuffer , flFILEwINDOW_DOnOTvALIDATE ) ;
            {
            while( !ether )
        {
        //etThread.traceF( tinBaseP , T("constructing fwsBuffer for reading") ) ;
    {
    while( !ether )
    ZE( countT , cAccepted ) ;
    ZE( countT , cIn       ) ;
    TN( tFileBuffer , "///d/tmp/foo.buffer.ttt" ) ;
    ZE( count04T , cb04BufferDone ) ;

    TN( tb4 , "    " ) ;
    const countT cbMin = 0xc + ifcCBdATAGRAMmAX + sizeof( sockaddr_in6 ) ;
    sThrow.bindF( tinBaseP ) ;
    socketC sThrow( tinBaseP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    fileWindowsC fwsOut( tinBaseP , etThread , tFileOut , flFILEwINDOW_WRITE | flFILEwINDOW_DOnOTvALIDATE ) ;
    TN( tFileOut , "///d/tmp/foo.received.fws.ttt" ) ;

    countT&      idGramPouredLathP = *(countT*)pTaskP->c4     ;
    const countT cWorkersP         =           pTaskP->c3     ;
    const countT offWorkerP        =           pTaskP->c2 - 1 ;
    countT&      secretToUseP      = *(countT*)pTaskP->c1     ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmObey2F )

DONE( tmComplainF )
}
    }
        Sleep( 100 ) ;

        }
            dec02AM( cComplaintPending ) ;
            etThread.traceF( tinBaseP , t1+TF2(cComplaintPending,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        while( cComplaintPending )
    {
    while( !ether )
    TN( t1 , "buffer overrun (packets lost) [cComplaintsPending,cProcessed (approximate)]:    " ) ;
    TN( tb4 , "    " ) ;
{
if( pTaskP )
TASK( tmComplainF )

DONE( tmGetSecretF )
}
    }
        ++ s ; ether.osSleepF( tinBaseP , TIMEePOCH >> 1 ) ;

        }
            ++ s ; ether.osSleepF( tinBaseP , TOCK >> 4 ) ;
            sThrow.writeF( tinBaseP , idPortCatch , nicNameC() , (byteT*)&gram , sizeof gram ) ;
            gram.idCmd = ifcIDcMDgRAM_DISPENSEsECRET ;
            gram.cbThisGram = sizeof gram ;
            gramHeadSecretS gram ;
            //CONoUTrAW( "!" ) ;
        {
        while( old == secretToUseP )
        countT old =  secretToUseP ;
    {
    while( !ether )
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

    sThrow.bindF( tinBaseP ) ;
    socketC sThrow( tinBaseP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    countT& secretToUseP = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmGetSecretF )

DONE( tmEpochClockF )
}
    }
        }
            //etThread.traceF( tinBaseP , T("ready to test incoming secrets") ) ;
            bSetup = 0 ;
        {
        if( bSetup && !OFFePOCHhONORmIN )          // OFFePOCHhONORmIN IS INITIALLY NEGATIVE ; WHEN IT BECOMES 0, WE ARE READY TO START TESTING INCOMING SECRETS

        offEpochFreshening ++ ;

        if( !bSetup ) { ++ s ; ether.osSleepF( tinBaseP , TIMEePOCH ) ; }

        }
            ppcHashSecrets[ offSlotFreshen ][ offSecret ] = ru2 ;
        {
        for( countT offSecret = 0 ; offSecret < ChASHsECRETS ; offSecret ++ )
        ranUniC ru2( tinBaseP , (measure04T)MAXcOUNTT + 1 , slab.trueRandom ) ;

        }
            ppcSecrets[ offSlotFreshen ][ offSecret ] = ru1 ;
        {
        for( countT offSecret = 0 ; offSecret < CsECRETS ; offSecret ++ )
        ranUniC ru1( tinBaseP , (measure04T)MAXcOUNTT + 1 , slab.trueRandom ) ;

        //etThread.traceF( tinBaseP , T("[offEpochFreshening,OFFePOCHhONORmIN,OFFePOCHhONORmAX]:    ")+TF2(offEpochFreshening,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(OFFePOCHhONORmIN,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(OFFePOCHhONORmAX,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        //etThread.traceF( tinBaseP , T("[offSlotFreshen,offSlotHonorOldest,offSlotHonorNewest]:    ")+TF2(offSlotFreshen,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSlotHonorOldest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSlotHonorNewest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        countT offSlotHonorNewest = OFFePOCHhONORmAX   % CePOCHsLOTS ;
        countT offSlotHonorOldest = OFFePOCHhONORmIN   % CePOCHsLOTS ;
        countT offSlotFreshen     = offEpochFreshening % CePOCHsLOTS ;
    {
    while( !ether )
    slabS& slab = slabS::slabIF() ;
    boolT bSetup = 1 ;
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    TN( tb4 , "    " ) ;
{
if( pTaskP )
TASK( tmEpochClockF )

}
    return offs % CsECRETS ;

    //etherP.traceF( tinBaseP , T("offSecretF [off,nn,offSlotP]:    ")+TF2(offs%CsECRETS,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnP)+tb4+TF2(offSlotP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4 ) ;

    }
        offs ^= *( pcc ++ ) ^ hashSecret ;
        //etherP.traceF( tinBaseP , T("offSecretF [offhs,hashSecret]:    ")+TF2(offhs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(hashSecret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        countT hashSecret = ppcHashSecrets[ offSlotP ][ offhs ] ;
    {
    for( countT offhs = 0 ; pcc < pce && offhs < ChASHsECRETS ; offhs ++ )
    ZE( countT , offs ) ;
    TN( tb4 , "    " ) ;

    countT* pce = pcc + sizeof nnP / sizeof( countT ) ;         //A:ASSUME: nicNameC IS AN INTEGRAL NUMBER OF countT ; IF NOT TRUE THEN THE TRAILING PORTION WILL NOT BE HASHED
    countT* pcc = (countT*)&nnP ;
{
countT offSecretF( tinBaseS& tinBaseP , etherC& etherP , const nicNameC& nnP , const countT offSlotP )

;
}
    countT   secret ;
    countT   len ;
    count04T off ;
{
struct gramHeadFileWindowS : public gramHeadS

;
}
    countT   secret ;
{
struct gramHeadSecretS : public gramHeadS

;
}
    countT   idCmd ;
    countT   cbThisGram ;       // INCLUDES ENTIRE gramHeadS INCLUDING THIS MEMBER
{
struct gramHeadS


countT   ppcHashSecrets[ CePOCHsLOTS ][ ChASHsECRETS ] ;

                                                // THE OLDEST ROW IS NOT REFERENCED, AND RECEIVES FRESH RANDOM countT VALUES IMMEDIATELY BEFORE offEpochFreshening IS INCREMENTED
                                                // HONORS    ppcSecrets[ offHonor                   % CePOCHsLOTS ][ ii ] WHERE offHonor IS IN [ offEpochFreshening - CePOCHhONORED , offEpochFreshening - 1 ]
countT   ppcSecrets[ CePOCHsLOTS ][ CsECRETS ] ;  // DISPENSES ppcSecrets[ ( offEpochFreshening - 1 ) % CePOCHsLOTS ][ ii ] IF offSecretF RETURNS ii, CALCULATED BY HASHING THE IP ADDRESS
countT   offEpochFreshening ;
byteT    pbFastBuffer[ TICK ] ;
countT   cComplaintPending ;
countT   cCaught2 ;
countT   cCaught1 ;
countT   cProcessed ;
countT   cThrown ;
count04T cb04Thrown ;
countT   cReceivedFileWindows ;
countT   idPortCatch ;

#define ChASHsECRETS ( sizeof( nicNameC ) / sizeof( countT ) )

#define CsECRETS    TOCK

#define TIMEePOCH ( TOCK << 4 )

#define OFFePOCHhONORmAX ( offEpochFreshening - 1             )
#define OFFePOCHhONORmIN ( offEpochFreshening - CePOCHhONORED )

#define CePOCHhONORED ( CePOCHsLOTS - 1 )

#define CePOCHsLOTS 5

#define ifcIDcMDgRAM_PUTfILEwINDOW       0x3
#define ifcIDcMDgRAM_USEtHISsECRET       0x2
#define ifcIDcMDgRAM_DISPENSEsECRET      0x1

#define CBpAYLOAD ( ifcCBdATAGRAMmAX - sizeof( gramHeadFileWindowS ) )

/*1*/WAKEsHOWtEXT( "udp.cdn.proof.of.concept.now.add.source.ip.validation.hash.map.ip.to.secret.optimized.for.speed" )/*1*/
/**/
*/
 this code works and suggests that code like this can keep up with incoming datagrams on a 1 gbit per second wire
 instead, secrets are honored for unlimited requests within an epoch (e.g. a tock or tock << 2)
 i eliminate the concept of ttl for each secret per requester
 baseline: 5adam.510007c2.1
i use hash to map ip address to secret in order to bound the size of the state needed for deluge of spoofed requests for secret
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
