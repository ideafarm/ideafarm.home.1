
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            }
                }
                    etThread.delF( tin0P , postw ) ;
                    st_psttP << psttv ; psttv = 0 ;
                    strokeS* psttv = psttOldC( tin0P , etThread , T(postw) ) ; ___( psttv ) ;
                    if( postw ) postw[ cbLabel ] = 0 ;
                    etThread.memCopyF( tin0P , postw , pbLabel , cbLabel ) ;
                    etThread.newF( tin0P , LF , postw , cbLabel + 1 ) ; ___( postw ) ;
                    ZE( osTextT* , postw ) ;
                    _IO_
                {
                else
                if( !cbLabel ) break ;
                const osTextT* pbLabel =  pbP ; pbP += cbLabel ;
                _IO_
            {
            if( !POOP )

            __( pbe < pbP + cbLabel ) ;                                                         // POOP IF LABEL LITERAL EXTENDS BEYOND END
            countT cbLabel = *pbP ; pbP += 1 ;
            _IO_
        {
        else
        }
            break ;
            __1
            //TELLsYSc1( ifcIDtYPEtELLsYS_ERRORlABELiStOOlONG )
            // ILLEGAL LENGTH PREFIX VALUE
            _IO_
        {
        else if( *pbP & 0xc0 )
        }
            break ;
            pbP += 2 ;                                                                          // ADVANCE pbP TO THE END OF THIS NAME, AND RETURN

            nameF( tin0P , etThread , st_psttP , pbr , pbP - pbr ) ;                            // CALL MYSELF, LIMITING PARSING TO BYTES BELOW CURRENT pbP

            if( POOP ) break ;
            __( pbP <= pbr ) ;                                                                  // POOP IF OFFSET DOES NOT POINT BACKWARD

            const byteT* pbr = (byteT*)this + offr ;
            countT offr = SWAB2( *(count01T*)pbP ) & ~0xc000 ;

            if( POOP ) break ;
            __( pbe < pbP + sizeof( count01T ) ) ;                                              // POOP IF OFFSET VALUE IS STORED BEYOND END

                                                                                                // USE THE SPECIFIED OFFSET TO OBTAIN THE VALUE OF THIS LABEL FROM ELSEWHERE IN THE MESSAGE
            _IO_
        {
        if( ( *pbP & 0xc0 ) == 0xc0 )                                                           // IF pbP POINTS TO AN OFFSET RATHER THAN TO A LABEL LITERAL
        _IO_
    {
    for(;;)
    const byteT* const pbe = pbP + cbP ;

    _IO_

    }
        if( etThread ) return ;
        __Z( cbP ) ;
        __( pbP < (byteT*)this + sizeof( dnsMsgHeaderS ) ) ;
        __Z( pbP ) ;
        __( st_psttP.idTypeF( tin0P ) - ifcSTACKtYPE_PTR_strokeS ) ;
        if( etThread ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT dnsMsgHeaderS::nameF( tin0S& tin0P , etherC& etThread , stackC& st_psttP , const byteT*& pbP , const countT cbP )/*1*/


// HIGH ORDER BITS [ 1 , 0 ] AND [ 0 , 1 ] ARE ILLEGAL
// A POINTER MUST BEGIN WITH HIGH ORDER BITS [ 1 , 1 ]
// A LITERAL LABEL MUST BEGIN WITH HIGH ORDER BITS [ 0 , 0 ]
// A DOMAIN NAME VALUE CAN BE STORED EITHER AS A LITERAL OR PARTIALLY OR WHOLLY USING OFFSET VALUES THAT POINT TO PRIOR LOCATIONS IN THE MESSAGE
//
//    |    
//    |       - a sequence of labels ending with a pointer"
//    |    
//    |       - a pointer
//    |    
//    |       - a sequence of labels ending in a zero octet
//    |    
//    |    represented as either:
//    |    "The compression scheme allows a domain name in a message to be
//    |    
//
// EACH LABEL IS LENGTH 0-3F_ (0-63_9)
// EACH LENGTH PREFIX IS 1 BYTE
// A DOMAIN NAME VALUE IS A SEQUENCE OF LENGTH PREFIXED LABELS
//
// REF: SECTION 4.1.4. "Message compression" OF https://datatracker.ietf.org/doc/html/rfc1035

/**/
*/
 cbP
   only partially enforced
  must be within the same dns record that begins with me
  must point to the beginning of the wo'th label for a name
  must not be 0
 pbP
  must be of type ifcSTACKtYPE_PTR_strokeS
   this is not enforced, because i might be called recursively
  must be empty
 st_psttP
 etThread
 tin0P
arguments
i also set pbP to the end of the data that i used
i fill st_psttP with the "labels" that comprise the name at pbP
\<A HREF=\"5.1630006.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$nameF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

