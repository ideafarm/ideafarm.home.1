
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bFixed ;     //U:: 20240708@0855: CONJ: THIS SHOULD BE WO OF THE BASE O.S. CONSTANTS SUCH AS EXCEPTION_CONTINUE_SEARCH, EXCEPTION_CONTINUE_EXECUTION, or EXCEPTION_EXECUTE_HANDLER
    }
        THREADmODE4rESTORE
        TINSL
    {

    }
        //TELL( "osExceptionHandlerWorkIF/-" ) ;_M
        _M
        //TINSL
        }
            //TINSL
            }
                //TINSL
                }
                    if( !( -- processGlobal2I.cNestReportingException ) ) processGlobal2I.osTidReportingException = 0 ;

                    }
                        //thirdC::dosExitProcessIF( ifcEXITcODE_EXITpROCESSiMPOTENT ) ;           //TO PREVENT AN AV ON tmWindowsF FROM LEAVING DESKTOP COVERED UP WITH AN UNRESPONSIVE WINDOW
                        //flagsResultP |= flEXCEPTIONrESULT_EXITpROCESScALLED ;
                        //OBSOLETE: NOW THIS IS DONE BY rootExceptionFilterWorker1F, WHO CALLED MY CALLER

                        //}
                        //    }
                        //        }
                        //            BLAMMO ;
                        //            homeS::homeIF().flags |= flHOMEs_KILLsELFiMMEDIATELY ; //20191014@1759: ADDED WITHOUT ANALYSIS TO MAKE REBOOT MORE RELIABLE AND QUICKER
                        //
                        //            thirdC::osFireIF( tinP ) ;
                        //            if( ((tinNormalS&)tinP).pEtText ) ((tinNormalS&)tinP).pEtText->emailFactoryReportF( tinP , T("an exception occured.  rebooting") ) ;
                        //            LOGrAW3( "on unhandled exception, firing the os at age (ms) since boot: " , msSinceBoot , "\r\n" ) ;
                        //        {
                        //        else
                        //        if( msSinceBoot < msMinimum ) { LOGrAW3( "on unhandled exception, did not fire the os because ms since boot is only " , msSinceBoot , "\r\n" ) ; }
                        //        count04T msSinceBoot = thirdC::osTimeTicksSinceBootIF() >= home.osTicksAtCt ? thirdC::osTimeTicksSinceBootIF() - home.osTicksAtCt : 0 ;
                        //        count04T msMinimum = 10 * 60 * 1000 ; //20190819@1106: CHANGED TO 10 FROM 5 MINUTES
                        //    {
                        //    //else
                        //    //else if( etherC::ifc_idHomeIdisk_IF() < TUCK ) { LOGrAW3( "on unhandled exception, ignored flHOMEs_FIREoSoNuNHANDLEDeXCEPTION because idHome < TUCK for home " , etherC::ifc_idHomeIdisk_IF() , "\r\n" ) ; } //A:ASSUME: PRODUCTION HOME DISK VALUES ARE 001 OR HIGHER
                        //    //if( !( F(home.flags) & flHOMEs_FIREoSoNuNHANDLEDeXCEPTION ) ) { LOGrAW3( "on unhandled exception, did not fire the os because flHOMEs_FIREoSoNuNHANDLEDeXCEPTION is not set for home " , etherC::ifc_idHomeIdisk_IF() , "\r\n" ) ; }
                        //    //20211115@1240: DISABLED THE NEXT 3 LINES
                        //    //20191204@1440: ENABLED THE NEXT 3 LINES
                        //    //U::BUG: 20191015@2147: FLAG IS NOT SET WHEN I NEED IT TO BE SET DURING PRODUCTION FAILURE FACTORY6 HOME 102
                        //
                        //    homeS& home = homeS::homeIF() ;
                        //{
                        //20221031@1257: DISABLED FOR PRODUCTION
                        //20211115@1238: ENABLED THIS FOR PRODUCTION
                        //20200604@1356: DISABLED THIS TO BURN-IN TEST PRODUCTION SERVERS
                        //ALWAYS ENABLE REBOOT ON EXCEPTION BEFORE UPLOADING (THIS COMMENT IS OBSOLETE, ASSUMING THAT THE SYSTEM IS RUNNING A SERVER)
                        //20190812@1944: ENABLED THIS CODE

                        }
                            BLOBpOP( prFloatP )
                            }
                                }
                                {_M
                                else
                                }
                                    //THE REPORT FILE IS WRITTEN BEFORE ME BECAUSE SOMETIMES MY TELLsYSc3EBP CALL AV'S
                                    //I CAN DELETE THE REPORT FILE THAT I JUST WROTE TO DISK BECAUSE I WAS ABLE TO TELL THE MONITOR
                                    bTold = 1 ;_M
                                    THREADmODE2rESTORE
                                    TELLsYSc3( ifcIDtYPEtELLsYS_ERROReXCEPTION , (byteT*)&tellInfoSys , sizeof tellInfoSys ) _M         //20240716@1359: OBSERVED TO FAIL (ACCESS VIOLATION DUE TO BLAMMO DUE TO FALSE DESIRE DETECTED IN thirdC::dosPriorityIF())
                                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                                {_M
                                if( !*prFloatP )

                                RESTARTrEF( *prFloatP )
                            {
                            BLOBpUSH( prFloatP , sizeof *prFloatP )
                        {_M
                        if( !bDriver && !( F(thirdC::third_flagsModeProcess1I_IF()) & ( flMODEpROCESS1_SUPPRESStELLS | flMODEpROCESS1_FAILtELLS ) ) )
                        ZE( boolT , bTold ) ;_M

                        }
                            //TELL( "osExceptionHandlerWorkIF/reported the exception to disk" )

                            THREADmODE2rESTORE
                            }
                                ++ s ; dosSleepIF( tinP , TOCK ) ;_M
                                sleepC s( tinP , TAG( TAGiDnULL ) ) ;_M
                            {_M
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                            //U:: JUST TO MAKE SURE THAT IT HAS TIME TO CLOSE AND FLUSH (SHOULD NOT BE NECESSARY)

                            }
                                }
                                    //CONoUTrAW( "appending memory readability bit dump to exception report: done\r\n" ) ;_M
                                    fileWriteGF( ostoFileName , postr , sizeof postr - 1 , 1 ) ;_M
                                    etherC::ifcBitDumpIF( tinP , postr , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;_M
    
                                    static byteT postr[ CBrEADABILITYmAPdUMP ] ;_M
                                    //CONoUTrAW( "appending memory readability bit dump to exception report\r\n" ) ;_M
                                {_M
                                if( cbaNeeded == CBrEADABILITYmAPdUMP )
                                
                                //CONoUTrAW3( "memory readability map [cbaNeeded]: " , cbaNeeded , "\r\n" ) ;_M
                                LOGrAW3( "memory readability map [cbaNeeded]: " , cbaNeeded , "\r\n" ) ;_M
                                countT cbaNeeded = etherC::ifcBitDumpIF( tinP , 0 , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;_M
                                //[cbaNeeded]: 1858
                                //[cbaNeeded]: 10858
                                //[cbaNeeded]: 958
                                countT cbGrain = thirdC::osMemoryReadabilityMapIF( tinP , pbBits , sizeof pbBits ) ;_M
                                
                                //static byteT pbBits[ TOCK ] ;_M   //THERE ARE A TUCK OF CHAR PER LINE ; EACH LINE REPRESENTS 01 TOCK ; EACH CHAR REPRESENTS 01 TUCK (1 PAGE) ;
                                static byteT pbBits[ TUCK << 4 ] ;_M //EACH LINE OF REPORT WILL REPRESENT 1 TICK OF MEMORY
                            {_M
                            #endif
                                if( tinNormalSnap.brcLath == ERROR_NOT_ENOUGH_MEMORY )
                            #elif defined( __NT__ )
                                if( tinNormalSnap.brcLath == U: )
                            #if defined( __OS2__ )

                            }
                                fileWriteGF( ostoFileName , postRpt , costRpt , 1 ) ;_M
                                OStEXTAK( ostoFileName , "\\log.exception.txt" ) ;_M
                                OStEXTA(  ostoFileName , processGlobal2I.postPathHomeTmp ) ;_M
                            {_M
                            OStEXT( ostoFileName , TUCK << 1 ) ;_M

                            countT         costRpt = thirdC::c_strlenIF( tinP , postRpt ) ;_M
                            const osTextT* postRpt = ostoRpt ;_M

                            OStEXTAK( ostoRpt , "Please always report to www.ideafarm.com that this information appeared,\r\nso that the quality of this software can be improved for you and also for others.\r\n" ) ;_M
                            }
                                OStEXTAK( ostoRpt , "\r\n \r\n" ) ;_M
                                OStEXTA( ostoRpt , tellInfoSys.postFix2 ) ;_M
                                OStEXTAK( ostoRpt , " \r\nIf that does not work, try this:\r\n" ) ;_M
                            {_M
                            if( tellInfoSys.postFix2[ 0 ] )
                            OStEXTAK( ostoRpt , "\r\n \r\n" ) ;_M
                            OStEXTA( ostoRpt , tellInfoSys.postFix1 ) ;_M
                            OStEXTAK( ostoRpt , ".\r\n \r\nTry this woth:\r\n" ) ;_M
                            OStEXTA( ostoRpt , tellInfoSys.postSuspect ) ;_M
                            OStEXTAK( ostoRpt , "Probable defect location: " ) ;_M
                            
                            OStEXTAK( ostoRpt , "\r\n \r\n" ) ;_M
                            }
                                }
                                    break ;
                                    OStEXTC( ostoRpt , tellInfoSys.pcInfo[ 0 ] , 0 ) ;_M
                                    OStEXTAK( ostoRpt , "\r\nraw exception code (tellInfoSys.pcInfo[0]): " ) ;_M
                                    OStEXTC( ostoRpt , tellInfoSys.idException , 0 ) ;_M
                                    OStEXTAK( ostoRpt , "tellInfoSys.idException: " ) ;_M
                                {_M
                                default :
                                }
                                    break ;
                                    OStEXTC(    ostoRpt , tellInfoSys.pcInfo[ 2 ] , 0 ) ;_M
                                    OStEXTAK(   ostoRpt , "\r\nidiFileCt: " ) ;_M
                                    OStEXTCmIN( ostoRpt , tellInfoSys.pcInfo[ 2 ] , 4 ) ;_M
                                    OStEXTAK(   ostoRpt , "\r\nidLineCt: " ) ;_M
                                    OStEXTC(    ostoRpt , tellInfoSys.pcInfo[ 1 ] , 0 ) ;_M
                                    OStEXTAK(   ostoRpt , "\r\nidiFile: " ) ;_M
                                    OStEXTCmIN( ostoRpt , tellInfoSys.pcInfo[ 0 ] , 4 ) ;_M
                                    OStEXTAK(   ostoRpt , "idLine: " ) ;_M
                                {_M
                                case ifcIDeVENTeXCEPTIONmONITORED_BLAMMO :
                                }
                                    break ;
                                    OStEXTCmIN( ostoRpt , tellInfoSys.pcInfo[ 5 ] , 7 ) ;_M
                                    OStEXTAK( ostoRpt , "\r\nidiFileNote: " ) ;_M
                                    OStEXTCmIN( ostoRpt , tellInfoSys.pcInfo[ 4 ] , 4 ) ;_M
                                    OStEXTAK( ostoRpt , "\r\nidLineNote: " ) ;_M
                                    OStEXTC( ostoRpt , tellInfoSys.pcInfo[ 3 ] , 0 ) ;_M
                                    OStEXTAK( ostoRpt , "\r\nidType: " ) ;_M
                                    OStEXTC( ostoRpt , tellInfoSys.pcInfo[ 2 ] , 0 ) ;_M
                                    OStEXTAK( ostoRpt , "\r\nidSubType: " ) ;_M
                                    OStEXTC( ostoRpt , tellInfoSys.pcInfo[ 1 ] , 0 ) ;_M
                                    OStEXTAK( ostoRpt , "\r\nidiFile: " ) ;_M
                                    OStEXTCmIN( ostoRpt , tellInfoSys.pcInfo[ 0 ] , 4 ) ;_M
                                    OStEXTAK( ostoRpt , "idLine: " ) ;_M
                                {_M
                                case ifcIDeVENTeXCEPTIONmONITORED_GRUNT :
                                }
                                    break ;
                                    OStEXTC( ostoRpt , tellInfoSys.pcInfo[ 1 ] , 0 ) ;_M
                                    OStEXTAK( ostoRpt , "\r\npvTarget: " ) ;_M
                                    OStEXTC( ostoRpt , tellInfoSys.pcInfo[ 0 ] , 0 ) ;_M
                                    OStEXTAK( ostoRpt , "bWrite: " ) ;_M
                                {_M
                                case ifcIDeVENTeXCEPTIONmONITORED_ACCESSvIOLATION :
                            {
                            switch( tellInfoSys.idException )
                            
                            OStEXTAK( ostoRpt , " \r\n" ) ;_M
                            }
                                }
                                    OStEXTAK( ostoRpt , "\r\n" ) ;_M
                                    }
                                        OStEXTA( ostoRpt , postTitle ) ;_M
                                    {_M
                                    if( postTitle )
                                    const osTextT* postTitle = processGlobal8I.source.postFileTitleF( tinP , processGlobal8I.source.idFileRankF( tinP , idiFile ) ) ;_M
                                    OStEXTAK( ostoRpt , "    " ) ;_M
                                    OStEXTCmIN( ostoRpt , idiFile , 7 ) ;_M
                                    OStEXTAK( ostoRpt , "." ) ;_M
                                    OStEXTCmIN( ostoRpt , idLine , 4 ) ;_M
                                    OStEXTA( ostoRpt , ( bOut ? "\\ " : ( bIn ? "/ " : "| " ) ) ) ;_M
                            
                                    }
                                        ++ cIndent ;_M
                                    {_M
                                    if( bOut )

                                    }
                                        }
                                            OStEXTAK( ostoRpt , " " ) ;_M
                                        {_M
                                        while( cToDo -- )
                                        countT cToDo = cIndent ;_M
                                    {_M
                                    else
                                    }
                                        OStEXTC( ostoRpt , cIndent , ' ' ) ;_M
                                    {_M
                                    if( cIndent > TUCK >> 2 )

                                    if( bIn && cIndent ) { -- cIndent ;_M }
                            
                                    idLine &= ~fliSTEP_FLAGmASK ;_M
                                    }
                                        bIn  = !bOut ;_M
                                        bOut = idLine & fliSTEP_NESToUT ;_M
                                    {
                                    else
                                    }
                                        bIn = bOut = 0 ;_M
                                    {_M
                                    if( !( idLine & fliSTEP_NESTcHANGE ) )
                                    boolT bIn ;
                                    boolT bOut ;
                            
                                    countT idiFile = tinNormalSnap.pLFstep[ offe + 1 ] ;_M
                                    countT idLine  = tinNormalSnap.pLFstep[ offe     ] ;_M
                                    countT offe = ( ids & OFFsLOTtINsTEPmAX ) << 1 ;_M
                                {_M
                                for( countT ids = tinNormalSnap.monitor.idStep ; cDo -- ; ids -- )
                                countT cDo = OFFsLOTtINsTEPmAX + 1 ;_M                          // IF idStep IS SMALL AND NOT BECAUSE OF WRAP THEN SOME REPORT LINES WILL BE FROM [0,0] PAIRS ; TO KISS, I DO NOT TEST FOR THIS SO I WILL REPORT EVEN IF pLFstep HAS BEEN TRASHED
                                countT cIndent = tinNormalSnap.monitor.cInNest ;_M
                            
                                OStEXTAK( ostoRpt , "\r\n \r\nExecution Steps:\r\n \r\n" ) ;_M
                            {_M
                            //CS:CODEsYNC: PSEUDOdUPLICATE: 35001155 510004fb.2

                            //A:ASSUME: idStep IS VALID
                            //THIS CODE ALWAYS GIVES THE FULL STEP ARRAY AS A CIRCULAR BUFFER STARTING WITH THE MOST RECENT ELEMENT
                            //20191104@2007: REWRITE TO UNCONDITIONALLY GIVE THE FULL STEP ARRAY

                            //else
                            //else if( (sCountT)tinNormalSnap.monitor.idStep < 0 ) { OStEXTAK( ostoRpt , "\r\n \r\nExecution Steps:  error: idStep is negative\r\n" ) ;_M }
                            //U::WE CAN GET FANCY HERE; I HAVE NOT DONE SO TO KISS SO THAT THIS CODE IS RELIABLE.  THE CHANCE OF AN EXCEPTION HAPPENING IMMEDIATELY AFTER WRAP IS EXTREMELY LOW
                            //20160603@1931: THE NEXT LINE COMMENTED OUT WITHOUT ANALYSIS ;  SHOULD NOW GET A STEP LISTING EXCEPT WHEN, UNLUCKILY, idStep IS 0 OR VERY SMALL
                            //if( !tinNormalSnap.monitor.idStep ) { OStEXTAK( ostoRpt , "\r\n \r\nExecution Steps:  no step information exists\r\n" ) ;_M }
                            //20160604@1657: MADE THIS UNCONDITIONAL WITHOUT ANALYSIS, RELYING ON 2'S COMPLEMENT PROPERTIES TO CORRECTLY DISPLAY STEPS EVEN IF idStep IS NEAR ZE
                            //20191104@2007: REWRITE THIS OLD COMMENTED OUT CODE SO THAT GET CORRECT STEP REPORT EVEN IF idStep HAS WRAPPED


                            }
                                }
                                    OStEXTAK( ostoRpt , "\r\n" ) ;_M
                                    }
                                        OStEXTA( ostoRpt , postTitle ) ;_M
                                    {_M
                                    if( postTitle )
                                    const osTextT* postTitle = processGlobal8I.source.postFileTitleF( tinP , processGlobal8I.source.idFileRankF( tinP , idiFile ) ) ;_M
                                    OStEXTAK( ostoRpt , "    " ) ;_M
                                    OStEXTCmIN( ostoRpt , idiFile , 7 ) ;_M
                                    OStEXTAK( ostoRpt , "." ) ;_M
                                    OStEXTCmIN( ostoRpt , idLine , 4 ) ;_M
                                    OStEXTAK( ostoRpt , "'th: " ) ;_M
                                    OStEXTC( ostoRpt , tinNormalSnap.pIdInNest[ offez ] , 0 ) ;_M
                                    OStEXTAK( ostoRpt , " | " ) ;_M
                                    OStEXTC( ostoRpt , tinNormalSnap.pEIPInNest[ offez ] , ' ' ) ;_M
                            
                                    countT idiFile = tinNormalSnap.monitor.pLFnest[ offe + 1 ] ;_M
                                    countT idLine  = tinNormalSnap.monitor.pLFnest[ offe     ] ;_M
                                    countT offe = ( idn & OFFsLOTtINnESTmAX ) << 1 ;
                                    countT offez = idn & OFFsLOTtINnESTmAX ;
                                {_M
                                for( countT idn = tinNormalSnap.monitor.cInNest ; idn >= idnf ; idn -- )
                                /*PSEUDODUPLICATE CODE: 2e40104 0010266*/
                            
                                }
                                    idnf = 1 ;_M
                                {_M
                                if( (sCountT)idnf < 1 )
                                countT idnf = tinNormalSnap.monitor.cInNest - OFFsLOTtINnESTmAX ;_M
                                OStEXTAK( ostoRpt , "\r\n \r\nCall Nest:\r\n \r\n" ) ;_M
                            {_M
                            else
                            else if( (sCountT)tinNormalSnap.monitor.cInNest < 0 ) { OStEXTAK( ostoRpt , "\r\n \r\nCall Nest:  error: cNest is negative\r\n" ) ;_M }
                            if( !tinNormalSnap.monitor.cInNest ) { OStEXTAK( ostoRpt , "\r\n \r\nCall Nest:  no nest information exists\r\n" ) ;_M }
                            OStEXTC( ostoRpt , tinNormalSnap.monitor.cInNest , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\ncNest: " ) ;_M
                            OStEXTC( ostoRpt , tellInfoSys.cFixed , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\ncFixed: " ) ;_M
                            OStEXTC( ostoRpt , tellInfoSys.bFixed , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nbFixed: " ) ;_M
                            //OStEXTC( ostoRpt , tinNormalSnap.idiFileMileDad , 0 ) ;_M
                            //OStEXTAK( ostoRpt , "\r\nidiFileMileDad: " ) ;_M
                            //OStEXTCmIN( ostoRpt , tinNormalSnap.idLineMileDad , 4 ) ;_M
                            //OStEXTAK( ostoRpt , "\r\nidLineMileDad: " ) ;_M
                            OStEXTC( ostoRpt , tinNormalSnap.idiFileMile , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nidiFileMile: " ) ;_M
                            OStEXTCmIN( ostoRpt , tinNormalSnap.idLineMile , 4 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nidLineMile: " ) ;_M
                            OStEXTC( ostoRpt , tinNormalSnap.idPhase3 , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nidPhase3: " ) ;_M
                            OStEXTC( ostoRpt , tinNormalSnap.idPhase2 , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nidPhase2: " ) ;_M
                            }
                                OStEXTC( ostoRpt , tinNormalSnap.idPhase1 , 0 ) ;_M
                            {_M
                            else
                            }
                                OStEXTA( ostoRpt , postIdPhase1 ) ;_M
                            {_M
                            if( postIdPhase1 )
                            const osTextT* postIdPhase1 = processGlobal4I.mapThreadPhase( tinNormalSnap.idPhase1 ) ;
                            OStEXTAK( ostoRpt , "\r\nidPhase1: " ) ;_M
                            }
                                OStEXTC( ostoRpt , ((tinNormalS&)tinP).pag1->idPhaseAdam , 0 ) ;_M
                            {_M
                            else
                            }
                                OStEXTA( ostoRpt , postIdPhaseAdam ) ;_M
                            {_M
                            if( postIdPhaseAdam )
                            const osTextT* postIdPhaseAdam = processGlobal4I.mapProcessPhase( ((tinNormalS&)tinP).pag1->idPhaseAdam ) ;
                            OStEXTAK( ostoRpt , "\r\nidPhaseAdamI: " ) ;_M
                            }
                                OStEXTC( ostoRpt , processGlobal2I.idPhaseProcess , 0 ) ;_M
                            {_M
                            else
                            }
                                OStEXTA( ostoRpt , postIdPhaseProcess ) ;_M
                            {_M
                            if( postIdPhaseProcess )
                            const osTextT* postIdPhaseProcess = processGlobal4I.mapIdPhaseProcess( processGlobal2I.idPhaseProcess ) ;
                            OStEXTAK( ostoRpt , "\r\nidPhaseProcess: " ) ;_M
                            OStEXTC(  ostoRpt ,      tinNormalSnap.pag1->idAdam , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\npag1->idAdam: " ) ;_M
                            OStEXTC(  ostoRpt ,      processGlobal1I.idAdamRoot , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nprocessGlobal1I.idAdamRoot: " ) ;_M
                            OStEXTC(  ostoRpt ,      processGlobal2I.idHome , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\"\r\nprocessGlobal2I.idHome: " ) ;_M
                            OStEXTA(  ostoRpt , thirdC::postUserNameIF() ) ;_M
                            OStEXTAK( ostoRpt , "\r\nbase os user name: \"" ) ;_M
                            OStEXTC(  ostoRpt ,      tinNormalSnap.monitor.idThread , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nidThread: " ) ;_M
                            OStEXTA(  ostoRpt ,      processGlobal2I.postDllsLoaded ) ;_M
                            OStEXTAK( ostoRpt , "\r\ndll load history: " ) ;_M
                            OStEXTC(  ostoRpt ,      processGlobal2I.cDllLoaded , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\ncDllLoaded: " ) ;_M
                            OStEXTC(  ostoRpt ,      thirdC::os_cAllOrphanThreadsI_IF( tinP ) , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\ncAllOrphanThreadsI: " ) ;_M
                            OStEXTC(  ostoRpt ,      tinNormalSnap.cKidThreads , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).cKidThreads: " ) ;_M
                            OStEXTC(  ostoRpt ,      thirdC::os_cAllKidThreadsI_IF( tinP ) , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).pag1->_thirdC_.cAllKidThreads: " ) ;_M
                            }}
                                OStEXTC( ostoRpt , tinNormalSnap.pPanLifiRecurseGrabbedLevel[ off + 3 ] , 0 ) ;_M
                                OStEXTAK( ostoRpt , " " ) ;_M
                                OStEXTC( ostoRpt , tinNormalSnap.pPanLifiRecurseGrabbedLevel[ off + 2 ] , 0 ) ;_M
                                OStEXTAK( ostoRpt , " " ) ;_M
                                OStEXTC( ostoRpt , tinNormalSnap.pPanLifiRecurseGrabbedLevel[ off + 1 ] , 0 ) ;_M
                                OStEXTAK( ostoRpt , " " ) ;_M
                                OStEXTC( ostoRpt , tinNormalSnap.pPanLifiRecurseGrabbedLevel[ off + 0 ] , 0 ) ;_M
                                OStEXTAK( ostoRpt , "](pandle,idLineGrab,idiFileGrab,cRecurse): " ) ;_M
                                OStEXTC( ostoRpt , off , 0 ) ;_M
                                OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).pPanLifiRecurseGrabbedLevel[" ) ;_M
                            {
                            {for( countT off = 0 ; off < sizeof tinNormalSnap.pPanLifiRecurseGrabbedLevel / sizeof tinNormalSnap.pPanLifiRecurseGrabbedLevel[ 0 ] ; off += 5 )
                            }}
                                OStEXTC( ostoRpt , tinNormalSnap.pcUtility[ off ] , 0 ) ;_M
                                OStEXTAK( ostoRpt , "]: " ) ;_M
                                OStEXTC( ostoRpt , off , 0 ) ;_M
                                OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).pc" "Utility[" ) ;_M
                            {
                            {for( countT off = 0 ; off < sizeof tinNormalSnap.pcUtility / sizeof tinNormalSnap.pcUtility[ 0 ] ; off ++ )
                            }}
                                OStEXTC( ostoRpt , rootAdamGlobal1I._etherC_.pcUtility[ off ] , 0 ) ;_M
                                OStEXTAK( ostoRpt , "]: " ) ;_M
                                OStEXTC( ostoRpt , off , 0 ) ;_M
                                OStEXTAK( ostoRpt , "\r\netherC::pcUtilityI[" ) ;_M
                            {
                            {for( countT off = 0 ; off < CCuTILITY ; off ++ )
                            }}
                                OStEXTC( ostoRpt , processGlobal2I.pcUtility[ off ] , 0 ) ;_M
                                OStEXTAK( ostoRpt , "]: " ) ;_M
                                OStEXTC( ostoRpt , off , 0 ) ;_M
                                OStEXTAK( ostoRpt , "\r\nprocessGlobal2I.pcUtility[" ) ;_M
                            {
                            {for( countT off = 0 ; off < sizeof processGlobal2I.pcUtility / sizeof processGlobal2I.pcUtility[ 0 ] ; off ++ )
                            }}
                                OStEXTC( ostoRpt , processGlobal2I.pcPhaseLow[ off ] , 0 ) ;_M
                                OStEXTAK( ostoRpt , "]: " ) ;_M
                                OStEXTC( ostoRpt , off , 0 ) ;_M
                                OStEXTAK( ostoRpt , "\r\netherC::pcPhaseLowI[" ) ;_M
                            {
                            {for( countT off = 1 ; off <= ClOWtHREADS ; off ++ )
                            OStEXTAK( ostoRpt , "\"" ) ;_M
                            OStEXTA(  ostoRpt , tinNormalSnap.postTellIf ) ;_M
                            OStEXTAK( ostoRpt , "\"\r\npostTellIf: \"" ) ;_M
                            OStEXTA(  ostoRpt , tinNormalSnap.postTellWait ) ;_M
                            OStEXTAK( ostoRpt , "\"\r\npostTellWait: \"" ) ;_M
                            OStEXTA(  ostoRpt , tinNormalSnap.postTell ) ;_M
                            OStEXTAK( ostoRpt , "\r\npostTell: \"" ) ;_M
                            OStEXTC(  ostoRpt , tinNormalSnap.monitor.idWhat2 , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nidWhat2: " ) ;_M
                            }
                                OStEXTC( ostoRpt , tinNormalSnap.monitor.idWhat1 , 0 ) ;_M
                            {_M
                            else
                            }
                                OStEXTA( ostoRpt , postWhat ) ;_M
                            {_M
                            if( postWhat )
                            const osTextT* postWhat = processGlobal4I.mapWhat( tinNormalSnap.monitor.idWhat1 ) ;
                            OStEXTC(  ostoRpt ,      tinNormalSnap.monitor.idWhat1 , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\ntinNormalSnap.monitor.idWhat1: " ) ;_M
                            OStEXTC(  ostoRpt , tinNormalSnap.idiFile_brcLath , 0 ) ;_M
                            OStEXTAK( ostoRpt ,   "\r\nidiFile_brcLath: " ) ;_M
                            OStEXTC(  ostoRpt , tinNormalSnap.idLine_brcLath , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nidLine_brcLath: " ) ;_M
                            OStEXTC(  ostoRpt ,     tinNormalSnap.brcLath , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nbrcLath: " ) ;_M
                            OStEXTC(  ostoRpt ,   tinNormalSnap.cGrabitC_unregistered , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).cGrabitC_unregistered: " ) ;_M
                            OStEXTC(  ostoRpt ,   tinNormalSnap.cGrabitC_registered , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).cGrabitC_registered: " ) ;_M
                            OStEXTC(  ostoRpt ,   tinNormalSnap.cGrabitC_reset , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).cGrabitC_reset: " ) ;_M
                            OStEXTC(  ostoRpt ,   tinNormalSnap.cGrabitC_set , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).cGrabitC_set: " ) ;_M
                            OStEXTC(  ostoRpt ,      tinNormalSnap.monitor.cGrabbed , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\ncGrabbed: " ) ;_M

                            OStEXTC(  ostoRpt ,      processGlobal2I.idBlammo , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nprocessGlobal2I.idBlammo: " ) ;_M
                            OStEXTC(  ostoRpt ,      processGlobal2I.idiFileBlammoCt , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nprocessGlobal2I.idiFileBlammoCt: " ) ;_M
                            OStEXTC(  ostoRpt ,      processGlobal2I.idLineBlammoCt , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nprocessGlobal2I.idLineBlammoCt: " ) ;_M
                            OStEXTC(  ostoRpt ,      processGlobal2I.idiFileBlammo , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nprocessGlobal2I.idiFileBlammo: " ) ;_M
                            OStEXTC(  ostoRpt ,      processGlobal2I.idLineBlammo , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nprocessGlobal2I.idLineBlammo: " ) ;_M

                            OStEXTC(  ostoRpt ,   tinNormalSnap.pag1->idBlammo , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).pag1->idBlammo: " ) ;_M
                            OStEXTC(  ostoRpt ,   tinNormalSnap.pag1->idiFileBlammoCt , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).pag1->idiFileBlammoCt: " ) ;_M
                            OStEXTC(  ostoRpt ,   tinNormalSnap.pag1->idLineBlammoCt , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).pag1->idLineBlammoCt: " ) ;_M
                            OStEXTC(  ostoRpt ,   tinNormalSnap.pag1->idiFileBlammo , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).pag1->idiFileBlammo: " ) ;_M
                            OStEXTC(  ostoRpt ,   tinNormalSnap.pag1->idLineBlammo , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).pag1->idLineBlammo: " ) ;_M
                            OStEXTC(  ostoRpt ,   tinNormalSnap.pag1->flagsAdamState , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n((tinNormalS&)tinP).pag1->flagsAdamState: " ) ;_M
                            OStEXTC(  ostoRpt , bCleanFailed , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nbCleanFailed: " ) ;_M
                            else                 { OStEXTC(  ostoRpt ,      (const countT)*tinNormalSnap.pPoop , 0 ) ;_M }
                            if( !tinNormalSnap.pPoop ) { OStEXTAK( ostoRpt , "tinNormalSnap.pPoop is null"               ) ;_M } 
                            OStEXTAK( ostoRpt , "\r\nPOOP: " ) ;_M
                            OStEXTC(  ostoRpt ,      processGlobal2I.cNestReportingException , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\n\r\nException reporting nest level: " ) ;_M
                            OStEXTC(  ostoRpt , idExceptionEventMeP , 0 ) ;_M
                            OStEXTAK( ostoRpt , "\r\nidExceptionEvent: " ) ;_M

                            }
                                }
                                    }
                                        BLOBpOP( prFloatP )
                                        }
                                            }
                                                OStEXTAK( ostoRpt , " " ) ;_M
                                            {_M
                                            if( off == - 1 )
                                    
                                            }
                                                OStEXTAK( ostoRpt , ".." ) ;_M
                                            {_M
                                            else
                                            }
                                                if( pbCode[ off ] < 0x10 ) OStEXTAS( ostoRpt , '0' ) ;_M
                                                OStEXTC( ostoRpt , pbCode[ off ] , 0 ) ;_M //WILL GP IF CODE IS NO LONGER PRESENT IN MEMORY (E.G. DURING SHUTDOWN) OR IF THE OFFENDING EIP IS VERY CLOSE TO A MEMORY BOUNDARY SO THAT THE RANGE OF THIS LOOP CROSSES THAT BOUNDARY
                                                prFloatP->flags |= flRESTARTc_QUIET ;_M
                                            {_M
                                            if( !*prFloatP )

                                            RESTARTrEF( *prFloatP )
                                        {
                                        BLOBpUSH( prFloatP , sizeof *prFloatP )
                                    {_M
                                    for( sCountT off = - 8 ; off <= 7 ; off ++ )
                                    byteT* pbCode = (byteT*)tellInfoSys.pvOffendingCode ;_M
                                    OStEXTAK( ostoRpt , "\r\ncodes [-8,7]: " ) ;_M
                                {_M
                            
                                OStEXTAK( ostoRpt , ")" ) ;_M
                                OStEXTC(  ostoRpt , (countT)tellInfoSys.pvOffendingCode - tinNormalSnap.pEIPInNest[ tinNormalSnap.monitor.cInNest & OFFsLOTtINnESTmAX ] , 0 ) ;_M
                                OStEXTAK( ostoRpt , " (offset from in: " ) ;_M
                                OStEXTC(  ostoRpt , tellInfoSys.pvOffendingCode , 0 ) ;_M
                                OStEXTAK( ostoRpt , " at " ) ;_M
                            {_M
                            if( tellInfoSys.idException != ifcIDeVENTeXCEPTIONmONITORED_GRUNT )
                            OStEXTA(  ostoRpt , tinNormalSnap.postThreadName ) ;_M
                            OStEXTAK( ostoRpt , ") exception occured while executing thread\r\n" ) ;_M
                            OStEXTC(  ostoRpt , osInfoP.ExceptionRecord->ExceptionCode , 0 ) ;_M
                            OStEXTAK( ostoRpt , ")    (base os: " ) ;_M
                            OStEXTC(  ostoRpt , tellInfoSys.idException , 0 ) ;_M
                            OStEXTAK( ostoRpt , " (ipdos: " ) ;_M
                            OStEXTA(  ostoRpt , postET ? postET : "unknown type" ) ;_M
                            const osTextT* postET = processGlobal4I.mapExceptionType( tellInfoSys.idException ) ;_M
                            OStEXTAK( ostoRpt , "Subject: IPDOS (tm) Exception Event\r\n\r\nIdeaFarm " "(tm) Piggyback Distributed Operating System\r\nhttp://ideafarm.com\r\nWo'O Ideafarm\r\n \r\nAn " ) ;_M
                            OStEXTAK( ostoRpt , "\r\n//\r\n// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.\r\n//\r\n// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.\r\n// Respecting the rights of other people is an important part of empowering one another.\r\n//\r\n\r\n" ) ;_M

                            osTextC ostoRpt( COSTArPTeXCEPTION - 2 * sizeof( countT ) , 0 , postaUse , COSTArPTeXCEPTION ) ;_M
                        {_M
                        if( bReport )

                        }
                            bReport = 0 ;_M
                            LOGrAW( "\r\nosExceptionHandlerWorkIF / too many nested exceptions so not writing report" ) ;_M
                        {_M
                        if( !postaUse )

                        }
                            bReport = 0 ;_M
                            LOGrAW( "\r\nosExceptionHandlerWorkIF / *processGlobal2I.postPathHomeTmp is null so not writing report" ) ;_M
                        {_M
                        if( !*processGlobal2I.postPathHomeTmp )

                        boolT bReport = 1 ;_M

                        //CONoUTrAW( "osExceptionHandlerWorkIF/5\r\n" ) ;_M
                        //CONoUTrAW9( " [bosTicks,idHome,idAdamRoot,idAdam]: " , thirdC::osTimeTicksSinceBootIF() , "/" , processGlobal2I.idHome , "/" , processGlobal1I.idAdamRoot , "/" , tinNormalSnap.pag1->idAdam , ": UNHANDLED EXCEPTION\r\n" ) ;_M
                        //CONoUTrAW( "osExceptionHandlerWorkIF/4\r\n" ) ;_M
                        //LOGrAW9( " [bosTicks,idHome,idAdamRoot,idAdam]: " , thirdC::osTimeTicksSinceBootIF() , "/" , processGlobal2I.idHome , "/" , processGlobal1I.idAdamRoot , "/" , tinNormalSnap.pag1->idAdam , ": UNHANDLED EXCEPTION (NO RESTART HANDLER FOUND)\r\n" ) ;_M
                        //LOGrAW( thirdC::postUserNameIF() ) ;_M
                        //LOGrAW( "\r\nosExceptionHandlerWorkIF ") ;_M
                        //CONoUTrAW( "osExceptionHandlerWorkIF/3\r\n" ) ;_M

                        homeS::homeIF().flags |= flHOMEs_EXCEPTIONhASoCCURRED ;_M
                    {_M
                    if( idMe <= 2 ) //CAN BE CHANGED; "1" LIMITS EACH PROCESS TO 1 REPORT; FOR PRODUCTION, PERHAPS IT WOULD BE BEST TO SET THIS TO 1 (SO THAT I KNOW WHICH EXCEPTION HAPPENED WOTH) ; 20240711@1630: SET TO 2 SO GET WO ROOT REPORT AND WO NEST REPORT (A NEST REPORT IS FOR AN EXCEPTION THAT OCCURS DURING EXCEPTION REPORTING)
                    //20160610@0912: "2" -> "1" IN THE NEXT LINE
                    countT idMe = 1 + incv02AM( cRpts ) ;_M
                    static countT cRpts ;_M
                    //CONoUTrAW( "osExceptionHandlerWorkIF/2\r\n" ) ;_M

                    ;_M
                        : 0
                        ? processGlobal2I.postRptException
                    osTextT* postaUse = ++ processGlobal2I.cNestReportingException == 1     // THIS IS JUST FOR SAFETY, SINCE ANY EXCEPTION IN ME SHOULD NEVER RESULT IN ME BEING CALLED NESTED ; IT SHOULD BE HANDLED BY rootExceptionFilterWorker1F

                    }
                        Sleep( TUCK ) ;_M //SIMPLE, TO AVOID A NESTED EXCEPTION
                    {_M
                    while( setIfZeAM( processGlobal2I.osTidReportingException , ((tinNormalS&)tinP).osTid ) )
                    //TO AVOID NESTED EXCEPTION, DON'T DO THIS: _IO_
                {_M
                if( !bFixed || !bQuiet )
                //CONoUTrAW( "osExceptionHandlerWorkIF/1\r\n" ) ;_M
                TINSL

                }
                    BLOBpOP( prFloatP )

                    }
                        // }
                        //     //if( pTinSave ) pTinF() = pTinSave ;
                        // 
                        //     //CONoUTrAW3( "osExceptionHandlerWorkIF: cleanup done [cDeleted]: " , cDeleted , "\r\n" ) ;
                        //     }
                        //         }
                        //             if( pTin->pClean == pTin ) pTin = pTinF() ;
                        // 
                        //             cDeleted ++ ;
                        //             { TINSL THREADmODE4rESTORE THREADmODE3rESTORE }
                        //             delete pTin->pClean ;
                        //             THREADmODE4oN( flTHREADmODE4_EXCEPTIONcLEANUPdELETIONiNpROGRESS )
                        //             THREADmODE3oN( flTHREADmODE3_DOnOTcaLLdELif )
                        //             //CONoUTrAW3( "osExceptionHandlerWorkIF:   deleting [pClean]: " , pTin->pClean , "\r\n" ) ;
                        // 
                        //             break ;
                        //             )
                        //                 pTin->pClean == (cleanC*)&processGlobal6I.tinBreak // ExitProcess WILL CALL THE DLL TERMINATION ROUTINE, WHICH WILL DELETE tinBreak ; THIS LINE MUST TEST FOR THE LATH cleanC DERIVED INSTANCE CONSTRUCTED DURING DLL INITIALIZATION
                        //                 ||
                        //                 ( bFixed && ebpAtRestart && ebpAtRestart < (countT)pTin->pClean )
                        //             (
                        //             if
                        //             tinNormalS& tinP = *pTin ; //THIS IS JUST FOR THE CONoUTrAW CALLS
                        //         {
                        //         while( pTin->pClean )
                        // 
                        //         //U:: THE FOLLOWING CODE WILL NOT DESTROY THE INTENDED INSTANCES IF THE WOTH cleanC INSTANCE IS IN poolC AND HAPPENS TO HAVE A HIGHER ADDRESS THAN THE ADDRESSES ON THE STACK FOR THE INSTANT THREAD
                        //         //U:: 20140404@2006: BUG: SOME cleanC INSTANCES ARE NOT ON A THREAD STACK.  (tinNormalS INSTANCES CAN BE IN THE poolC.)  CONJ: ORIGINALLY, cleanC WAS ENVISIONED AS ASSUMING THAT ALL INSTANCES ARE ON A THREAD STACK.  CONJ: EXCEPTION HANDLER CODE ASSUMES THIS AND WILL BREAK IF A cleanC INSTANCE IS NOT ON A THREAD STACK
                        // 
                        //         // WILL ALWAYS DESTROY cleanC INSTANCES IN THE STACK FRAMES OF AND WITHIN THE RESTART POINT ; IF !bFixed OR NOT EXIST RESTART POINT THEN WILL DESTROY ALL cleanC INSTANCES
                        // 
                        //         //
                        //         //  * SIMPLE RECIPE:  AT THE BEGINNING OF THE RESTART BLOCK, TALLY THE NUMBER OF cleanC INSTANCES REGISTERED.  ON RESTART, IF bFixed, DELETE ALL NEW INSTANCES.  IF !bFixed, DO NOTHING
                        //         //
                        //         //  * FORGET ABOUT STACK FRAMES
                        //         //
                        //         //  * RESTART BLOCKS CAN BE NESTED (NOT SURE WHETHER CURRENT CODE SUPPORTS THIS)
                        //         //
                        //         //  * ANY CLASS CAN BE DERIVED FROM cleanC SUCH THAT EACH INSTANCE REGISTERS ITSELF FOR CLEANUP (CURRENT CODE SUPPORTS THIS; NO NEW CRAFTWORK NEEDED)
                        //         //
                        //         // WISH LIST FOR cleanC SUPPORT
                        //         //
                        //         //FUTURE CRAFTWORK:  REWRITE THIS LOOP ACCORDING TO THE FOLLOWING WISH LIST
                        // 
                        //         //20171003@1354: DECISION: JUST COMMENT THIS OUT.  DO NOT DESTROY tinNormalS INSTANCES CT WITHIN A RESTART BLOCK
                        //         //THE FOLLOWING CODE DOES NOT WORK CORRECTLY SO ISN'T A GOOD EXAMPLE
                        //         //THERE ISN'T REALLY ANY NEED TO CLEAN UP tinNormalS INSTANCES BECAUSE tinNormalS INSTANCES WILL NEVER BE CT ON THE STACK BY APPLICATION CODE
                        //         //THINK: THIS CODE WAS WRITTEN MAINLY TO SERVE AS AN EXAMPLE OF HOW TO USE cleanC TO PERFORM CLEANUP DURING RESTART
                        //         //20171003@1354:  CONJECTURE: THE INTENT HERE IS TO DESTROY tinNormalS INSTANCES CONSTRUCTED ON THE STACK WITHIN THE RESTART BLOCK
                        // 
                        //         tinNormalS* pTin = &tinP ;
                        //         //CONoUTrAW( "osExceptionHandlerWorkIF: clean +\r\n" ) ;
                        // 
                        //         if( !bFixed ) ((tinNormalS&)tinP).cKidThreads = 0 ;
                        //         if( &tinP != pTinMainI ) { BLAMMO ; }
                        //         TINSL
                        //     {
                        //     ZE( countT , cDeleted ) ;
                        // 
                        //     ;
                        //         : ( pTinF() = pTinMainI , &tinP )
                        //         ? 0
                        //     tinNormalS* pTinSave = &tinP == pTinMainI
                        // {_M
                        // else
                        // 20171003@1405:  COMMENTED THIS OUT TO WORK AROUND INSTABILITY DURING EXCEPTION HANDLING.  REWRITE IF cleanC SUPPORT IS EVER NEEDED.  THIS cleanC FUNCTIONALITY IS REALLY A DOODLE THAT ISN'T NEEDED FOR IPDOS (tm) TO WORK

                        }
                            bCleanFailed = 1 ;_M //U::REPORT THIS
                            //CONoUTrAW( "osExceptionHandlerWorkIF: skipping clean\r\n" ) ;_M
                        {_M
                        if( *prFloatP )

                        RESTARTrEF( *prFloatP )
                    {

                    BLOBpUSH( prFloatP , sizeof *prFloatP )
                {_M
                if( bFixed ) //U::ADDED THIS TEST AS WORKAROUND TO MAKE EXCEPTION REPORTING RELIABLE RATHER THAN ALLOWING BLOCKAGE TO OCCUR IN DT'OR FOR tinNormalS
                ZE( boolT , bCleanFailed ) ;
                //U::ISSUE: IF THE EXCEPTION IS NOT ON MAIN THREAD THEN THIS WILL NOT CLEAN UP THE INTENDED ITEMS FOR DLL TERMINATION

                }
                    processGlobal2I.osTidTerminator = ((tinNormalS&)tinP).brcRaw ;
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , GetCurrentThreadId() )
                    processGlobal2I._thirdC_flagsProcessState |= flPROCESSsTATE_EXCEPTIONnOThANDLED ;
                {
                if( !bFixed )

                }
                    }
                        //TELL( "osExceptionHandlerWorkIF/rolled back registers" )
                        #endif

                            osInfoP.ContextRecord->SegCs                 = pr->pcRegisters[ 0xf ] ;_M
                            osInfoP.ContextRecord->SegSs                 = pr->pcRegisters[ 0xe ] ;_M
                            osInfoP.ContextRecord->SegGs                 = pr->pcRegisters[ 0xd ] ;_M
                            osInfoP.ContextRecord->SegFs                 = pr->pcRegisters[ 0xc ] ;_M
                            osInfoP.ContextRecord->SegEs                 = pr->pcRegisters[ 0xb ] ;_M
                            osInfoP.ContextRecord->SegDs                 = pr->pcRegisters[ 0xa ] ;_M
                            osInfoP.ContextRecord->EFlags                = pr->pcRegisters[ 0x9 ] ;_M
                            osInfoP.ContextRecord->Eip                   = pr->pcRegisters[ 0x8 ] ;_M
                            osInfoP.ContextRecord->Esp                   = pr->pcRegisters[ 0x7 ] ;_M
                            osInfoP.ContextRecord->Ebp    = ebpAtRestart = pr->pcRegisters[ 0x6 ] ;_M
                            osInfoP.ContextRecord->Edi                   = pr->pcRegisters[ 0x5 ] ;_M
                            osInfoP.ContextRecord->Esi                   = pr->pcRegisters[ 0x4 ] ;_M
                            osInfoP.ContextRecord->Edx                   = pr->pcRegisters[ 0x3 ] ;_M
                            osInfoP.ContextRecord->Ecx                   = pr->pcRegisters[ 0x2 ] ;_M
                            osInfoP.ContextRecord->Ebx                   = pr->pcRegisters[ 0x1 ] ;_M
                            osInfoP.ContextRecord->Eax                   = pr->pcRegisters[ 0x0 ] ;_M

                            ebpAtException = osInfoP.ContextRecord->Ebp ;_M

                        #if defined( __NT__ )

                        if( F(pr->flags) & flRESTARTc_QUIET ) bQuiet = 1 ;_M
                        bFixed = 1 ;_M
                        if( !( F(pr->flags) & flRESTARTc_DOnOTtALLY ) ) pr->cRestarted ++ ;_M
                        //TELL( "osExceptionHandlerWorkIF/rolling back registers" )
                        _IO_
                    {_M
                    if( pr )

                    //TELL( "osExceptionHandlerWorkIF/looked for a restartC" )
                    }
                        pr = pr->prD ;_M

                        else if( pr->bAcceptF( &tinP , tellInfoSys ) ) break ;
                             if( F(pr->flags) & flRESTARTc_SKIP    ) ;
                    {_M
                    while( pr )
                    pr = ((tinNormalS&)tinP).pRestart ;_M
                    restartC* pr ;_M
                    //TELL( "osExceptionHandlerWorkIF/looking for a restartC" )
                    _IO_
                {_M
                if( !bFixed )
                ZE( countT , ebpAtException ) ;
                ZE( countT , ebpAtRestart ) ;

                tellInfoSys.cFixed = cFixed ;_M
                tellInfoSys.bFixed = bFixed ;_M
                }
                    inc02AM( cFixed ) ;_M
                {_M
                if( bFixed )

                }
                    }
                        break ;
                        ADVICE( "COMPUTER CIRCUITRY" , "Use the Services icon to stop the IdeaFarm driver.  Reboot if necessary.  Start the driver." , "" ) ;_M
                        tellInfoSys.pcInfo[ 0 ] = osInfoP.ExceptionRecord->ExceptionCode ;_M
                        tellInfoSys.ccInfo = 1 ;_M
                        tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_NOTlISTED ;_M
                        _IO_
                    {_M
                    default :
                    }
                        break ;
                        ADVICEdFLT ;_M
                        for( countT off = 0 ; off < tellInfoSys.ccInfo ; off ++ ) tellInfoSys.pcInfo[ off ] = osInfoP.ExceptionRecord->ExceptionInformation[ off ] ;_M
                        if( tellInfoSys.ccInfo > sizeof tellInfoSys.pcInfo / sizeof tellInfoSys.pcInfo[ 0 ] ) tellInfoSys.ccInfo = sizeof tellInfoSys.pcInfo / sizeof tellInfoSys.pcInfo[ 0 ] ;_M
                        tellInfoSys.ccInfo = osInfoP.ExceptionRecord->NumberParameters ;_M
                        tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_BLAMMO ;_M
                        //bFixed = 1 ;_M
                        //2011.04.10: COMMENTED OUT NEXT LINE SO THAT EXCEPTION HANDLER WOULD NOT BLOCK CLEANING UP BY DELETING tinNormalS FOR A THREAD THAT HAS KIDS
                        _IO_
                    {_M
                    case ifcIDeVENTeXCEPTIONmONITORED_BLAMMO              : //SEEN IT NOT BE CLEARED_
                    case ifcIDeVENTeXCEPTIONmONITORED_BLAMMO & 0xefffffff : //WINDOWS CLEARS BIT 28 IN RaiseException(...)
                    }
                        break ;
                        ADVICEdFLT ;_M
                        for( countT off = 0 ; off < tellInfoSys.ccInfo ; off ++ ) tellInfoSys.pcInfo[ off ] = osInfoP.ExceptionRecord->ExceptionInformation[ off ] ;_M
                        if( tellInfoSys.ccInfo > sizeof tellInfoSys.pcInfo / sizeof tellInfoSys.pcInfo[ 0 ] ) tellInfoSys.ccInfo = sizeof tellInfoSys.pcInfo / sizeof tellInfoSys.pcInfo[ 0 ] ;_M
                        tellInfoSys.ccInfo = osInfoP.ExceptionRecord->NumberParameters ;_M
                        tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_GRUNT ;_M
                        //bFixed = 1 ;_M
                        //2011.04.10: COMMENTED OUT NEXT LINE SO THAT EXCEPTION HANDLER WOULD NOT BLOCK CLEANING UP BY DELETING tinNormalS FOR A THREAD THAT HAS KIDS
                        _IO_
                    {_M
                    case ifcIDeVENTeXCEPTIONmONITORED_GRUNT              : //SEEN IT NOT BE CLEARED_
                    case ifcIDeVENTeXCEPTIONmONITORED_GRUNT & 0xefffffff : //WINDOWS CLEARS BIT 28 IN RaiseException(...)
                    }
                        break ;

                        }
                            ADVICEdFLT ;_M
                        {_M

                        if( cCodeReadRetries ) ;
                        //else
                        //}
                        //    THREADmODE2rESTORE
                        //    }
                        //        ++ s ; dosSleepIF( tinP , cCodeReadRetries == 1 ? TUCK * 0x40 : TOCK ) ;
                        //        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                        //    {
                        //    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                        //    LOGrAW5( "i will nap and then retry " , cCodeReadRetries , " to read code at " , tellInfoSys.pcInfo[ 1 ] , "\r\n" ) ;
                        //    bQuiet = bFixed = 1 ;_M
                        //{_M
                        //if( !tellInfoSys.pcInfo[ 0 ] && tellInfoSys.pcInfo[ 1 ] == (countT)tellInfoSys.pvOffendingCode && incv02AM( cCodeReadRetries ) < 0x4 )

                        tellInfoSys.pcInfo[ 1 ] =   osInfoP.ExceptionRecord->ExceptionInformation[ 1 ] ;_M // pvTarget
                        tellInfoSys.pcInfo[ 0 ] = !!osInfoP.ExceptionRecord->ExceptionInformation[ 0 ] ;_M // bWrite
                        if( !tellInfoSys.ccInfo ) tellInfoSys.ccInfo = 2 ;_M
                        if( !tellInfoSys.idException ) tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_ACCESSvIOLATION ;_M
                        _IO_
                    {_M
                    case EXCEPTION_ACCESS_VIOLATION :
                    }
                        // INTENTIONAL FALLTHROUGH
                        tellInfoSys.pcInfo[ 2 ] =   osInfoP.ExceptionRecord->ExceptionInformation[ 2 ] ;_M // NTSTATUS CODE (TYPICALLY A DISK FAILURE CODE) THAT CAUSED THE INpAGEeRROR
                        tellInfoSys.ccInfo = 3 ;_M
                        tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_INpAGEeRROR ;
                        _IO_
                    {_M
                    case EXCEPTION_IN_PAGE_ERROR :
                    case EXCEPTION_INVALID_HANDLE                            : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_INVALIDhANDLE           ; ADVICEdFLT ; bQuiet = bFixed = 1 ; break ; }  // bFixed AND bQuiet ARE SET, SO EXCEPTIONS THROWN BY CloseHandle() ARE IGNORED ; CODE THAT CALLS CloseHandle() SHOULD DETECT AND HANDLE FAILURE GRACEFULLY
                    case EXCEPTION_GUARD_PAGE                                : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_GUARDpAGE               ; ADVICEdFLT ; break ; }
                    case DBG_CONTINUE                                        : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_DBGcONTINUE             ; ADVICEdFLT ; break ; }
                    case DBG_TERMINATE_THREAD                                : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_DBGtERMINATEtHREAD      ; ADVICEdFLT ; break ; }
                    case DBG_TERMINATE_PROCESS                               : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_DBGtERMINATEpROCESS     ; ADVICEdFLT ; break ; }
                    case DBG_CONTROL_C                                       : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_DBGcONTROLc             ; ADVICEdFLT ; break ; }
                    case DBG_CONTROL_BREAK                                   : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_DBGcONTROLbREAK         ; ADVICEdFLT ; break ; }
                    case DBG_EXCEPTION_NOT_HANDLED                           : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_DBGnOThANDLED           ; ADVICEdFLT ; break ; }
                    case CONTROL_C_EXIT                                      : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_CONTROLcnOTIFICATION    ; ADVICEdFLT ; break ; } //U: NOT TESTED.  THE OS CONSTANT LISTED IN WIN32 DOC IS "DBG_CONTROL_C"; CONJ: THIS IS A DOC ERROR; DBG_CONTROL_C IS MEANT TO BE A CODE THAT A DEBUGGER CAN RETURN IN ORDER TO RAISE A CONTROL_C EXCEPTION
                    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED                     : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_ARRAYbOUNDSeXCEEDED     ; ADVICEdFLT ; break ; }
                    case EXCEPTION_DATATYPE_MISALIGNMENT                     : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_DATATYPEmISALIGNMENT    ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_DENORMAL_OPERAND                      : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOATdENORMALoPERAND    ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_DIVIDE_BY_ZERO                        : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOATdIVIDEbYzE         ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_INEXACT_RESULT                        : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOATiNEXACTrESULT      ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_INVALID_OPERATION                     : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOATiNVALIDoPERATION   ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_OVERFLOW                              : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOAToVERFLOW           ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_STACK_CHECK                           : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOATsTACKcHECK         ; ADVICEdFLT ; break ; }
                    case EXCEPTION_FLT_UNDERFLOW                             : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_FLOATuNDERFLOW          ; ADVICEdFLT ; break ; }
                    case EXCEPTION_ILLEGAL_INSTRUCTION                       : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_ILLEGALiNSTRUCTION      ; ADVICEdFLT ; break ; }
                    case EXCEPTION_INT_DIVIDE_BY_ZERO                        : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_INTEGERdIVIDEbYzE       ; ADVICEdFLT ; break ; }
                    case EXCEPTION_INT_OVERFLOW                              : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_INTEGERoVERFLOW         ; ADVICEdFLT ; break ; }
                    case EXCEPTION_INVALID_DISPOSITION                       : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_INVALIDdISPOSITION      ; ADVICEdFLT ; break ; }
                    case EXCEPTION_NONCONTINUABLE_EXCEPTION                  : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_NONCONTINUABLEeXCEPTION ; ADVICEdFLT ; break ; }
                    case EXCEPTION_PRIV_INSTRUCTION                          : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_PRIVILEGEDiNSTRUCTION   ; ADVICEdFLT ; break ; }
                    case EXCEPTION_STACK_OVERFLOW                            : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_STACKoVERFLOW           ; ADVICEdFLT ; break ; }
                    case EXCEPTION_SINGLE_STEP                               : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_SINGLEsTEP              ; ADVICEdFLT ; break ; }
                    case EXCEPTION_BREAKPOINT                                : {_M _IO_                  tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_BREAKPOINT              ; ADVICEdFLT ; break ; }
                {
                else switch( osInfoP.ExceptionRecord->ExceptionCode )                       //20230124@1708:  EXCEPTION_IN_PAGE_ERROR: DISABLED bFixed = 1 W/O ANALYSIS SO THAT I WILL SEARCH FOR RESTART HANDLER ; I DO NOT KNOW WHY bFixed = 1 WAS DONE ONLY FOR THIS EXCEPTION TYPE ; CONJ: I MISUNDERSTOOD THIS EXCEPTION TO BE A TRANSIENT H/W FAILURE
                }
                    tellInfoSys.idException = ifcIDeVENTeXCEPTIONmONITORED_CODEnOTaVAILABLE ; ADVICEdFLT ;_M
                {_M
                if( !osInfoP.ExceptionRecord )
                static boolT cFixed ;_M
                ZE( boolT , bQuiet ) ;_M

                tellInfoSys.postSuspect[ 0 ] = 0 ;_M
                tellInfoSys.pcInfo[ 4 ] = tellInfoSys.pcInfo[ 3 ] = tellInfoSys.pcInfo[ 2 ] = tellInfoSys.pcInfo[ 1 ] = tellInfoSys.pcInfo[ 0 ] = tellInfoSys.ccInfo = tellInfoSys.idException = 0 ;_M
                tellInfoSys.pvOffendingCode = !osInfoP.ExceptionRecord ? 0 : osInfoP.ExceptionRecord->ExceptionAddress ;_M
                //TELL( "osExceptionHandlerWorkIF/filling tellInfoSys" )

                }
                    OStEXTCmIN( ostoSuspectDflt , tinNormalSnap.pag1->idAdam , 7 ) ;_M
                    OStEXTAK( ostoSuspectDflt , "/" ) ;_M
                    OStEXTCmIN( ostoSuspectDflt , processGlobal1I.idAdamRoot , 7 ) ;_M
                    OStEXTAK( ostoSuspectDflt , "IdeaFarm " "(tm) Cell " ) ;_M
                {_M
                else
                }
                    OStEXTAK( ostoSuspectDflt , "IdeaFarm " "(tm) Operating System Driver" ) ;_M
                {_M
                if( bDriver )
                OStEXT( ostoSuspectDflt , TUCK << 2 ) _M
                const boolT bDriver = !!( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_DRIVER ) ;_M
            {_M
        {_M
        scoopC _scoop( tinP , LF , _poop , flSCOOPc_DOnOTcHECKtINiD ) ;_M
        poopC _poop( flPOOP_null ) ;_M
        static countT cCodeReadRetries ;

        const tinNormalS&            tinNormalSnap     = *(tinNormalS*)tellInfoSys.pbTin ;
        tellInfoSysExceptionS& tellInfoSys = *((tinNormalS&)tinP).pzTieLath ;_M

        //TELL( "osExceptionHandlerWorkIF/+" )
        //A: ASSUME: ((tinNormalS&)tinP).pzTieLath POINTS TO A STRUCTURE THAT CONTAINS AN IMAGE OF tinP AT EXCEPTION EVENT TIME
    {
    if( ((tinNormalS&)tinP).pzTieLath )
    ZE( boolT , bFixed ) ;
    _IO_

    THREADmODE4oN( flTHREADmODE4_EXCEPTIONrEPORTINGiNpROGRESS )

    TINSL
    ebpTlsAM() = ebpOffenderP ; //THIS IS NEEDED BECAUSE SOMETIMES THE TLS IS NOT IN THE STACK CHAIN (E.G. WHEN TINSL WOULD FAIL AT BEGINNING OF winMessageHandlerWorkF)

    countT               idExceptionEventMeP =                        c8p.c5 ;
    restartC*&           prFloatP            =           *(restartC**)c8p.c4 ;
    countT               ebpOffenderP        =                        c8p.c3 ;
    countT&              idMile              =              *(countT*)c8p.c2 ;
    _EXCEPTION_POINTERS& osInfoP             = *(_EXCEPTION_POINTERS*)c8p.c1 ;
    count8S& c8p = *(count8S*)cArgP ;
{
/*1*/boolT thirdC::osExceptionHandlerWorkIF( const countT cArgP )/*1*/

#define ADVICEdFLT ADVICE( ostoSuspectDflt , "Use the Services icon to stop the IdeaFarm driver.\r\nReboot if necessary.  Start the driver." , "" )

 thirdC::c_strncpyIF( tinP , tellInfoSys.postFix2    , postFix2P    , sizeof tellInfoSys.postFix2    ) ;
 thirdC::c_strncpyIF( tinP , tellInfoSys.postFix1    , postFix1P    , sizeof tellInfoSys.postFix1    ) ;  \
 thirdC::c_strncpyIF( tinP , tellInfoSys.postSuspect , postSuspectP , sizeof tellInfoSys.postSuspect ) ;  \
                                                                                                    \
#define ADVICE(postSuspectP,postFix1P,postFix2P)                                                    \

//  b. USING BLAMMO IN ~tinNormalS SEEMS TO CAUSE EXECUTION TO HALT (EDITED TO CALL ExitProcess NOT BLAMMO IN ~tinNormalS)
//  a. ~tinNormalS CAN SLEEP FOREVER WAITING FOR KID THREADS
// THESE WORKAROUNDS AVOID 2 SEPARATE PROBLEMS OCCURING DURING ~tinNormalS
// 3. EDITED ~tinNormalS TO NOT WAIT FOR KIDS IF I AM ACTIVE, BUT TO INSTEAD CALL ExitProcess
// 2. CLEAN ONLY IF bFixed
// 1. MADE GRUNT !bFixed
// WORKAROUNDS TO MAKE EXCEPTION REPORTING RELIABLE

/**/
*/
it is illegal to refer to this symbol in the definition of an adam
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

