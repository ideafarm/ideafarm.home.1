
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

ether.loafIF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("ok") ) ;

}
    etThread.osThreadF( TaRG1( tmWorkerF ) , (countT)ptRoot[ offt ] , (countT)pcArgInner ) ;
{
for( countT offt = 0 ; offt < sizeof ptRoot / sizeof ptRoot[ 0 ] ; offt ++ )

textC* ptRoot[] = { /*&tRootE ,*/ &tRootW , &tRootX , &tRootY , &tRootZ } ;

TN( tRootZ , "///z/archive/" ) ;
TN( tRootY , "///y/archive/" ) ;
TN( tRootX , "///x/archive/" ) ;
TN( tRootW , "///w/archive/" ) ;
//TN( tRootE , "///e/archive/" ) ;

countT pcArgInner[] = { (countT)&etThread , (countT)&tPatternOld , (countT)&tPatternHash , (countT)&sttq } ;

strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

;

    +S2(sa_SSSaNDeND,sc_ccSSS)

        +T(".")
        // TERMINATOR

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERICf,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(0x1f,sc_ccSSSrEPEAT,0x1f)
        +T(".")
        // HASH

    +S2(sa_SSSaND,sc_ccSSS)
    T("")

TN( tPatternHash , "" ) ; tPatternHash =

;

    +S2(sa_SSSaNDeND,sc_ccSSS)

        +T(".")
        // TERMINATOR

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +T(".")
        // SEQUENCE NUMBER

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +T(".")
        // SEQUENCE NUMBER

        +S2(sa_SSSoReND,sc_ccSSS)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("012xz")
        +S2(sa_SSSoR,sc_ccSSS)
        +T("@")
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(7,sc_ccSSSrEPEAT,7)
        +T(".")
        // DATETIME

        +S2(sa_SSSoReND,sc_ccSSS)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("012xz")
        +S2(sa_SSSoR,sc_ccSSS)
        +T("@")
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("xz")                                                 // "x" OR "z" ARE ALLOWED AS A DIGIT.  IT MEANS "UNKNOWN"
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(7,sc_ccSSSrEPEAT,7)
        +T(".")
        // DATETIME

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(7,sc_ccSSSrEPEAT,7)
        +T(".")
        // IDoWNER

        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(7,sc_ccSSSrEPEAT,7)
        +T(".")
        // IDoWNER

        +T("/!ideafarm.8.2")
        // CONSTANT

    +S2(sa_SSSaND,sc_ccSSS)
    T("")

TN( tPatternOld , "" ) ; tPatternOld =

// GRP:  ------------------------------------------------------------------------------------------
// KEEP: ---------------------------------------------------------------------------------    ----------------------------------------------------------------------->
//  OLD: ///z/archive/1999/!ideafarm.8.2.00000000.00000001.19990903@1308.20150910@0202.001.001.7d84358e991c2d16afaa9d1acb468f55.00000001.meta.currentname
//       123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
//       0              1               2               3               4               5               6               7               8               9               a

// KEEP: -------------------------------------------------------------------------------------------    ----------------------------------------------------------------------->
//  OLD: ////factory9/z/archive/1999/!ideafarm.8.2.00000000.00000001.19990903@1308.20150910@0202.001.001.7d84358e991c2d16afaa9d1acb468f55.00000001.meta.currentname
//       123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
//       0              1               2               3               4               5               6               7               8               9               a

TODO

DONE( tmWorkerF )
}
    etThread.traceF( tinBaseP , T("root ---- [cFiles,cDirs]:    ")+*ptRootP+tb4+TF2(cFiles,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+TF2(cDirs,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
    etThread.diskWalkF( tinBaseP , cDirs , cFiles , *ptRootP , countTC() , cleanCBF , pcArgInnerP , 0 , 0 ) ;
    etThread.traceF( tinBaseP , T("root ++++               :    ")+*ptRootP ) ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs ) ;

    TN( tb4 , "    " ) ;
    countT* pcArgInnerP = (countT*)pTaskP->c2 ;
    textC*  ptRootP     =  (textC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmWorkerF )


}
    return 0 ;

    }
        }
#endif
            }
                DELzOMBIE( pFwsNew ) ;
                DELzOMBIE( pFwsOld ) ;

                }
                    }
                        //}
                        //    etherP.traceF( tinBaseP , T("could not rename") ) ;
                        //    POOPR
                        //{
                        //else
                        //if( !POOP ) etherP.traceF( tinBaseP , T("renamed aok") ) ;
                        //((tinNormalS&)tinBaseP).pEtScratch->disk Move File Or Dir F( tinBaseP , tNameNew , tNameOld , 1 ) ;

                        etherP.traceF( tinBaseP , T("content is the same ; attempting to delete old (not really)") ) ;

                        DELzOMBIE( pFwsNew ) ;
                        DELzOMBIE( pFwsOld ) ;
                    {
                    if( bSame && !bQuitP )

                    }
                        }
                            }
                                etherP.traceF( tinBaseP , T("different content [idWindow]:    ")+TF2(idWindow,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                bSame = 0 ;
                            {
                            else if( etherP.memCompareF( tinBaseP , pbwOld , pbwNew , cbwOld ) )
                            else if( !pbwOld || !cbwOld ) break ;
                            }
                                etherP.traceF( tinBaseP , T("different sizes (unexpected) [idWindow]:    ")+TF2(idWindow,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                bSame = 0 ;
                            {
                            if( cbwOld != cbwNew )

                            pFwsNew->getF( tinBaseP , pbwNew , cbwNew ) ;
                            ZE( countT , cbwNew ) ;
                            ZE( byteT* , pbwNew ) ;

                            pFwsOld->getF( tinBaseP , pbwOld , cbwOld ) ;
                            ZE( countT , cbwOld ) ;
                            ZE( byteT* , pbwOld ) ;

                            idWindow ++ ;
                        {
                        while( !bQuitP )
                        ZE( countT , idWindow ) ;
                    {
                    boolT bSame = 1 ;
                {
                else
                else if( pFwsOld->cbFileLoF() != pFwsNew->cbFileLoF() || pFwsOld->cbFileHiF() != pFwsNew->cbFileHiF() ) etherP.traceF( tinBaseP , T("different sizes") ) ;
                }
                    }
                        etherP.traceF( tinBaseP , T("could not rename") ) ;
                        POOPR
                    {
                    else
                    if( !POOP ) etherP.traceF( tinBaseP , T("renamed aok") ) ;
                    ((tinNormalS&)tinBaseP).pEtScratch->diskMoveFileOrDirF( tinBaseP , tNameNew , tNameOld , 1 ) ;

                    etherP.traceF( tinBaseP , T("could not ct both file windows ; attempting to rename") ) ;

                    DELzOMBIE( pFwsNew ) ;
                    DELzOMBIE( pFwsOld ) ;
                    POOPR ;
                {
                if( POOP )

                fileWindowsC* pFwsNew = new( 0 , tinBaseP , pb_fwsNew , sizeof pb_fwsNew ) fileWindowsC( tinBaseP , *((tinNormalS&)tinBaseP).pEtScratch , tNameNew , flFILEwINDOW_null , 1 ) ;
                fileWindowsC* pFwsOld = new( 0 , tinBaseP , pb_fwsOld , sizeof pb_fwsOld ) fileWindowsC( tinBaseP , *((tinNormalS&)tinBaseP).pEtScratch , tNameOld , flFILEwINDOW_null , 1 ) ;

                byteT pb_fwsNew[ sizeof( fileWindowsC ) ] ;
                byteT pb_fwsOld[ sizeof( fileWindowsC ) ] ;

                SCOOPS
            {
            IFsCRATCH

            etherP.traceF( tinBaseP , T("new: ")+tNameNew ) ;

            }
                etherP.delF( tinBaseP , psttSnip2 ) ;
                etherP.delF( tinBaseP , psttSnip1 ) ;
                tNameNew = T(psttSnip1) ;
                etherP.strFuseF( tinBaseP , psttSnip1 , psttSnip2 ) ;
                etherP.strSubstringF( tinBaseP , psttSnip2 , idf , idl , tNameOld ) ; ___( psttSnip2 ) ;
                idl = 0 ;
                idf = 0x56 ;
                ZE( strokeS* , psttSnip2 ) ;

                etherP.strSubstringF( tinBaseP , psttSnip1 , idf , idl , tNameOld , tNameOld.csF( tinBaseP ) ) ; ___( psttSnip1 ) ;
                countT idl = 0x51 ;
                countT idf = 1 ;
                ZE( strokeS* , psttSnip1 ) ;
            {
            TN( tNameNew , "" ) ;

            etherP.traceF( tinBaseP , T("old: ")+tNameOld ) ;
            etherP.traceF( tinBaseP , T("------------------------------------------------------------------") ) ;


#if defined( NEVERdEFINED )








            }
                }
                    etherP.delF( tinBaseP , psttGroup ) ;
                    etherP.delF( tinBaseP , pstt1f ) ;

                    }
                        }
                            }
                                etherP.traceF( tinBaseP , T("could not rename") ) ;
                                POOPR
                            {
                            else
                            if( !POOP ) etherP.traceF( tinBaseP , T("renamed aok") ) ;
                            ((tinNormalS&)tinBaseP).pEtScratch->diskMoveFileOrDirF( tinBaseP , tNew , psttc1 , 1 ) ;

                            SCOOPS
                        {
                        IFsCRATCH

                        etherP.delF( tinBaseP , psttSnip2 ) ;
                        etherP.delF( tinBaseP , psttSnip1 ) ;
                        etherP.traceF( tinBaseP , T("  new:    ")+tNew ) ;

                        TN( tNew , psttSnip1 ) ; tNew += tHash+tDot+T(psttSnip2) ;
            
                        etherP.strSubstringF( tinBaseP , psttSnip2 , idf , idl , psttc1 ) ; ___( psttSnip2 ) ;
                        idl = 0 ;
                        ZE( strokeS* , psttSnip2 ) ;

                        etherP.strIdF( tinBaseP, idf , sttqP , tDot , psttc1 ) ;

                        etherP.strSubstringF( tinBaseP , psttSnip1 , idf , idl , psttc1 ) ; ___( psttSnip1 ) ;
                        countT idl = 0x56 ;
                        countT idf = 1 ;
                        ZE( strokeS* , psttSnip1 ) ;

                        etherP.traceF( tinBaseP , T(" file:    ")+T(psttc1) ) ;
                    {
                    FORsTRINGSiN1( pstt1f )

                    etherP.diskFindFileOrDirOldF( tinBaseP , pstt1f , T(psttGroup)+tStar ) ; ___( pstt1f ) ;
                    ZE( strokeS* , pstt1f ) ;

                    etherP.traceF( tinBaseP , T("group:    ")+T(psttGroup) ) ;
            
                    etherP.strSubstringF( tinBaseP , psttGroup , idf , idl , tNameOld , tNameOld.csF( tinBaseP ) ) ; ___( psttGroup ) ;
                    countT idl = 0x5a ;
                    countT idf = 1 ;
                    ZE( strokeS* , psttGroup ) ;
                {

                etherP.traceF( tinBaseP , T("hash:                                                                                                  ")+tHash ) ;

                }
                    etherP.delF( tinBaseP , posti ) ;
                    }
                        etherP.delF( tinBaseP , psttHash ) ;
                        tHash = T(psttHash) ;
                        hasher.queryStringF( tinBaseP , psttHash ) ; ___( psttHash ) ;
                        ZE( strokeS* , psttHash ) ;

                        hasher.eatF( tinBaseP , posti , costi ) ;
                        hasherC hasher( tinBaseP , etherP ) ;
                    {

                    etherP.boxGetShadowF( tinBaseP , posti , costi , tNameOld ) ; ___( posti ) ;
                    ZE( countT   , costi ) ;
                    ZE( osTextT* , posti ) ;
                {
                TN( tHash , "" ) ;

                etherP.traceF( tinBaseP , T("not correct old: ")+tNameOld ) ;
            {
            else
            }
                //etherP.traceF( tinBaseP , T("    correct old: ")+tNameOld ) ;
            {
            if( idHit == 0x56 )

            //etherP.traceF( tinBaseP , T("hash [idHit]:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            idHit = etherP.strIdF( tinBaseP, idf , sttqP , tPatternHashP , tNameOld ) ;
            idf -- ;
        {
        if( idHit == 0x12 )
        //etherP.traceF( tinBaseP , T("[idHit,name:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tNameOld ) ;

        countT idHit = etherP.strIdF( tinBaseP, idf , sttqP , tPatternOldP , tNameOld ) ;
        countT idf = 1 ;

        TN( tDot , "." ) ;
        TN( tStar , "*" ) ;
        TN( tNameOld , ifName ) ;
        ifFileNameC ifName( tinBaseP , etherP , postNameP ) ;

        strokeS sttqP         = *(strokeS*)pcArgP[ 3 ] ;
        textC&  tPatternHashP =   *(textC*)pcArgP[ 2 ] ;
        textC&  tPatternOldP  =   *(textC*)pcArgP[ 1 ] ;
        etherC& etherP        =  *(etherC*)pcArgP[ 0 ] ;
    {
    if( postNameP && thirdC::c_strstrIF( tinBaseP , postNameP , ".hashedname" ) )
{
boolT cleanCBF( tinBaseS& tinBaseP , countT& cDirsP , countT& cFilesP , boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )




/*1*/WAKEsHOWtEXT( "tool.fix.the.screwed.up.file.names.in.all.archives" )/*1*/
/**/
*/
my job is to restore the correct hash values, which were smudged by a bug in another tool
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
