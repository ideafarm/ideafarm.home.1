
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            }
                if( idLastP > csttBig ) idLastP = csttBig ;_WQ
                idLastP = idFirstP - 1 + csttCopy ;_WQ
            {
            else
            if( idFirstP > csttBig ) idFirstP = idLastP = 0 ;
            idFirstP = idLastP + 1 ;_WQ
            for( countT offi = 0 ; offi < csttCopy ; offi ++ ) psttP[ CSpREFIX + csttBefore + offi ] = psttBigP[ CSpREFIX + idFirstP - 1 + offi ] ;_WQ
        {
        if( !POOP )

        if( !psttP ) { __( 0x88888888 ) ; }
        }
            if( psttP ) { SETpREFIX( psttP , csttCopy , csttExtraP ) ; }

            third.newF( tin0P , LF , psttP , csNew ) ; // CALLER MUST TAG ___( psttP ) ;_WQ
            countT csNew = CSpREFIX + csttCopy + csttExtraP ;_WQ
        {
        else
        }
            }
                psttP[ 2 ].idAdam -= csttCopy ;_WQ
                psttP[ 0 ].idAdam += csttCopy ;_WQ
            {
            if( !POOP )
            if( psttP[ 2 ].idAdam < csttCopy ) { __( 0x77777777 ) ; }
        {
        if( psttP )
        countT csttBefore = psttP ? psttP->idAdam : 0 ;_WQ
    
        countT csttCopy = idLastP - idFirstP + 1 ;_WQ
        if( idFirstP > idLastP ) { __( 0x66666666 ) ; }
        if( idLastP  > csttBig ) { __( 0x55555555 ) ; }
        if( !idLastP ) idLastP = csttBig ;_WQ
        _IO_
    {
    else
    if( csttBig < idFirstP ) idFirstP = 0 ;
    countT csttBig = psttBigP->idAdam ;_WQ

    _IO_

    }
        if( POOP ) return ;
        if( psttBigP->idCaste != sc_PREFIXlENGTH ) { __( 0x44444444 ) ; }
        if( POOP ) return ;
        if( idLastP && idFirstP > idLastP        ) { __( 0x33333333 ) ; }
        if( !idFirstP                            ) { __( 0x22222222 ) ; }
        if( !psttBigP                            ) { __( 0x11111111 ) ; }
        if( POOP ) return ;
    {
    IFbEcAREFUL

    //ON RETURNING, idLastP WILL POINT IMPLY AN EQUAL LENGTH STRING, SHORTENED IF NECESSARY TO FIT WITHIN psttBigP
    //ON RETURNING, idFirstP WILL POINT TO THE STROKE AFTER THE ONES FOUND
    SCOOP
{
/*1*/voidT etherC::strSubstringF( tin0S& tin0P , strokeS*& psttP , countT& idFirstP , countT& idLastP , const strokeS* psttBigP , const countT csttExtraP )/*1*/

/**/
*/
 csttExtraP
 psttBigP
  if not 0 then must not be less than idFirstP
  if 0 then the end of psttBigP is implied
  can be 0
 idLastP
  if there aren't enough strokes in psttBigP, psttP will receive T("") and impotence will not occur
  this is usually set to 1 when drawing the first substring from a string
  must not be ze
 idFirstP
   must have sufficient capacity
  if not 0 then result will be appended
   will be allocated from the pool
  can be 0
 psttP
arguments
  \<A HREF=\"5.1a10104.1.1.0.html\"\>1a10104:  WAKEsHOW( "example.simplest.func.1030066.etherC.strSubstringF" )\</A\>
 simplest
examples
\<A HREF=\"5.1030066.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strSubstringF.0.html\"\>instances\</A\>
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

