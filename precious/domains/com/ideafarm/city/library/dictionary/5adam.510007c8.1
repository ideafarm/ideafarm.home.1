
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;

etThread.traceF( tinP , T("ok") ) ;

}
    cReceivedFileWindows = 0 ;
    etThread.traceF( tinP , T("received [cReceivedFileWindows]:    ")+TF2(cReceivedFileWindows,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    etThread.traceF( tinP , T("process [mTocks]:    ")+TT(timeE1,timeE2)+tb4+TF2(mTocksE,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tinP , T("throw   [mTocks]:    ")+TT(timeT1,timeT2)+tb4+TF2(mTocksT,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tinP , T("[mGBits]:            ")+TF2(mGBits,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tinP , T("[cGram]:            ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    measureT mGBits = (measureT)( cb04Thrown << 3 ) / ( TICK << 2 ) ;

    measureT mTocksE = (measureT)timeE1 / TOCK ;
    measureT mTocksT = (measureT)timeT1 / TOCK ;

    etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO PROCESS
    etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
    ZE( sCountT , timeE2 ) ;
    ZE( countT  , timeE1 ) ;

    }
        ++ s ; ether.osSleepF( tinP , TOCK >> 4 ) ;
        etThread.traceF( tinP , T("waiting [cThrown,cCaught1,cCaught2,cProcessed]:    ")+TF2(cThrown,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cCaught1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cCaught2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( cProcessed < cThrown )

    etThread.osTimeSubtractF( tinP , timeT1 , timeT2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO THROW
    etThread.osTimeNowF( tinP , timeT1 , timeT2 ) ;
    ZE( sCountT , timeT2 ) ;
    ZE( countT  , timeT1 ) ;

    }
        }
            }
                }
                    cbDone += cbNow ;
                    pbc    += cbNow ;

                    cb04Thrown += cbGram ;
                    cThrown ++ ;

                    sThrow.writeF( tinP , idPortCatch , nicNameC() , pbGram , cbGram ) ;
                    //if( !( idGram % TUCK ) ) etThread.traceF( tinP , T("sending [idGram,cbNow,cbGram]:    ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT cbGram = sizeof( udpFileGramHeadFileWindowS ) + cbNow ;
                    //CONoUTrAW( "!" ) ;
                    etThread.memCopyF( tinP , pbPayload , pbc , cbNow ) ;
                    head.secret = secretToUse ;
                    head.len    = cbNow  ;
                    head.off    = cbDone ;
                    head.cbThisGram = sizeof head + cbNow ;
                    //etThread.traceF( tinP , T("throwing window [secretToUse]:    ")+TF2(secretToUse,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    //CONoUTrAW( "+" ) ;

                    idGram ++ ;

                    cbDo -= cbNow ;

                    ;
                        : CBpAYLOAD
                        ? cbDo
                    countT cbNow = cbDo < CBpAYLOAD

                    //etThread.traceF( tinP , T("waited  for a secret") ) ;
                    }
                        Sleep( 100 ) ;
                    {
                    while( !secretToUse )
                    //etThread.traceF( tinP , T("waiting for a secret") ) ;
                {
                while( cbDo )
                countT cbDo = cbw ;
                byteT* pbc = pbw ;

                //etThread.boxPutF( tinP , tFileIn+T(".window.")+tIdWindow , pbw , cbw ) ;
                //etThread.traceF( tinP , T("[tIdWindow,cb]:    ")+tIdWindow+tb4+TF2(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                TN( tIdWindow , "" ) ; tIdWindow = TF3(++idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;
            {
            else
            if( !pbw || !cbw ) break ;

            fwsIn.getF( tinP , pbw , cbw ) ;
            ZE( countT , cbw ) ;
            ZE( byteT* , pbw ) ;
        {
        while( !ether )
        ZE( count04T , cbDone ) ;
        ZE( countT , idWindow ) ;

        head.idMeta     = 0 ;
        head.idMetaType = ifcIDuDPfILEmETAtYPE_CONTENT ;
        head.idFileHi     = 0 ;
        head.idFileLo     = 1 ;
        head.idCmd      = ifcIDcMDuDPfILEgRAM_PUTfILEwINDOW ;

        udpFileGramHeadFileWindowS& head = *(udpFileGramHeadFileWindowS*)pbGram ;
        byteT*               pbPayload = pbGram + sizeof( udpFileGramHeadFileWindowS ) ;
        byteT                pbGram[ sizeof( udpFileGramHeadFileWindowS ) + CBpAYLOAD ] ;

        fileWindowsC fwsIn( tinP , etThread , tFileIn ) ;

        sThrow.bindF( tinP ) ;
        socketC sThrow( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
    {
    ZE( countT , idGram ) ;

    etThread.osTimeNowF( tinP , timeA1 , timeA2 ) ;
    ZE( sCountT , timeA2 ) ;
    ZE( countT  , timeA1 ) ;
{
while( !ether )
TN( tFileIn     , "///d/tmp/foo.ttt" ) ;

Sleep( 4000 ) ;     // LET WORKER THREADS GET SET UP
CONoUTrAW( "\r\n" ) ;

etThread.osThreadF( TaRG1( tmGetSecretF  ) , (countT)&secretToUse ) ;
etThread.osThreadF( TaRG1( tmUdpFileObey1F       ) , (countT)&secretToUse , (countT)&cPoured ) ;
ZE( countT , secretToUse ) ;
etThread.osThreadF( TaRG1( tmUdpFileEpochClockF )                        ) ;

}
    ++ s ; ether.osSleepF( tinP , TOCK >> 2 ) ;
{
while( !idPortCatch )
sleepC s( tinP , TAG( TAGiDnULL ) ) ;
TN( tb4 , "    " ) ;

etThread.osThreadF( TaRG1( tmUdpFileCatchF ) , (countT)&cPoured ) ;
ZE( countT , cPoured ) ;

TODO

DONE( tmUdpFileCatchF )
}
    sCatch.readF( tinP , (const countT&)ether , pbFastBuffer , sizeof pbFastBuffer , cPouredP ) ;

    idPortCatch = sCatch.bindF( tinP ) ;
    socketC sCatch( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    countT& cPouredP = *(countT*)pTaskP->c1 ;
{
if( pTaskP )
TASK( tmUdpFileCatchF )

DONE( tmUdpFileObey1F )
}
    }
        Sleep( 0 ) ;

        }
            pbci     += cbThis ;
            cPouredP ++ ;
            cCaught1 ++ ;

            }
                }
                    pbco += cbDo ;
                    memcpy( pbco , pbThis + cbDone , cbDo ) ;
                {
                else
                if( cbDo > pbwe - pbco ) { BLAMMO ; }           //A:ASSUME: FILE WINDOW IS LARGE ENOUGH TO CONTAIN THE LARGEST POSSIBLE INCOMING PACKET (WORST CASE IS cbDone==0 AND cbThis IS LARGEST POSSIBLE PACKET)
                countT cbDo = cbThis - cbDone ;

                pbco = pbw ;
                pbwe = pbw + cbw ;
                if( !pbw || !cbw ) { BLAMMO ; }
                fwsBuffer.getF( tinP , pbw , cbw ) ;
                cbw = 0 ;
                pbw = 0 ;

                }
                    pbco += cbDone ;
                    memcpy( pbco , pbThis , cbDone ) ;
                {
                if( cbDone )

                countT cbDone = pbwe - pbco ;
            {
            else
            }
                pbco += cbThis ;
                memcpy( pbco , pbThis , cbThis ) ;          // THIS INCLUDES THE offNext FIELD, WHICH WILL BE USELESS TO tmUdpFileObey2F AND AVAILABLE FOR tmUdpFileObey2F TO USE AS SCRATCH BUFFER OR TO IGNORE
            {
            if( cbThis <= pbwe - pbco )

            countT cbThis = 4 * sizeof( countT ) + cbData + sizeof( sockaddr_in6 ) ;
            byteT* pbThis = pbci ;

            pcLagOffNext    =  &offNext ;
            countT& cbData  = ((countT*)pbci)[ 3 ] ;
            countT& idGram  = ((countT*)pbci)[ 1 ] ;
            countT& offNext = ((countT*)pbci)[ 0 ] ;        // I WILL USE THIS VALUE ON MY NEXT ITERATION TO POSITION MYSELF IN THE CIRCULAR BUFFER TO READ THE NEXT RECORD

            //
            //  01+cbData sizeof( sockaddr_in6 )    from
            //  01        cbData                    data
            //  c         4                         cbData
            //  8         4                         rc
            //  4         4                         idGram (serial number)
            //  0         4                         offNext
            //
            //  offset    length                    description
            //
            // INPUT LAYOUT (FROM s_readF WRITING TO MY CIRCULAR BUFFER pbFastBuffer)

            if( pbci + cbMin > pbe             ) { BLAMMO ; }
            if( pcLagOffNext                   ) pbci = pbFastBuffer + *pcLagOffNext ;      // THE PRECEDING RECORD TELLS ME WHERE IN THE CIRCULAR BUFFER TO POSITION MYSELF
            if( pcLagOffNext && !*pcLagOffNext ) { BLAMMO ; }
        {
        while( cPouredP != idGramLath )      // INTENDED TO HANDLE WRAP AOK
    {
    while( !ether )
    ZE( countT* , pcLagOffNext ) ;
    byteT* pbci = pbCircle ;
    const byteT* const pbe = pbFastBuffer + sizeof pbFastBuffer ;
    byteT* const pbCircle = pbFastBuffer + sizeof( countT ) ;
    countT& idGramLath = *(countT*)pbFastBuffer ;
    const countT cbMin = 0xc + ifcCBdATAGRAMmAX + sizeof( sockaddr_in6 ) ;

    while( cDo -- ) etThread.osThreadF( TaRG1( tmUdpFileObey2F ) , (countT)&secretToUseP , ++ cWorker , cProcessorsObey2 , (countT)&cPouredP ) ;
    ZE( countT , cWorker ) ;
    countT cDo = cProcessorsObey2 ;

    etThread.traceF( tinP , T("using [cProcessors,cProcessorsObey2]:    ")+TF2(cProcessors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessorsObey2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    const countT cProcessorsObey2 = cProcessors < 7 ? 1 : cProcessors - 5 ;     // "- 5" IS OPTIMAL ON factory2
    const countT cProcessors      = thirdC::osProcessorsIF( tinP ) ;

    byteT* pbco = pbw ;
    byteT* pbwe = pbw + cbw ;
    if( !pbw || !cbw ) { BLAMMO ; }         //SHOULD BE IMPOSSIBLE SINCE OPENING FOR WRITING ; U:: fileWindowsC WILL FAIL IF NO MORE SPACE ON DISK OR DISK I/O FAILURE
    fwsBuffer.getF( tinP , pbw , cbw ) ;    //U:: ACCESSES TO THIS MEMORY WILL EXCEPTION IF DISK I/O FAILURE ; NEED TO USE RESTART TO RECOVER FROM SUCH A FAILURE
    ZE( countT , cbw ) ;
    ZE( byteT* , pbw ) ;
    TN( tb4 , "    " ) ;

    fileWindowsC fwsBuffer( tinP , etThread , tFileBuffer , flFILEwINDOW_WRITE | flFILEwINDOW_DOnOTvALIDATE ) ;
    etThread.boxPutF( tinP , tFileBuffer , "X" , 1 ) ;
    TN( tFileBuffer     , "///d/tmp/foo.buffer.ttt" ) ;

    etThread.osThreadF( TaRG1( tmComplainF ) ) ;

    countT& cPouredP     = *(countT*)pTaskP->c2 ;
    countT& secretToUseP = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmUdpFileObey1F )                            // I SINGLEHANDEDLY COPY DATA OUT OF THE CIRCULAR BUFFER THAT s_readF WRITES TO, APPENDING THE INCOMING DATA TO A BUFFER FILE THAT GROWS WITHOUT BOUND ; I DO THIS AS QUICLY AS POSSIBLE SO THAT s_readF RARELY HAS TO WAIT FOR ME ; MAKING s_readF WAIT CAUSES PACKET LOSS

DONE( tmUdpFileObey2F )
}
    }
        ether.osSleepF( tinP , TOCK ) ;

        }
            DEL( pDoomed ) ;
            fileWindowsC*& pDoomed = *(fileWindowsC**)&(countT&)swFwsOut ;
            pbLeverFN = (const byteT*)swFwsOut.leverF( tinP , idf ) ;
            etThread.traceF( tinP , T("deleting fws") ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swFwsOut.cFlavorsF( tinP ) ;

        }
            if( bNap ) break ;

            }
                //etThread.traceF( tinP , T("inner: moving input window") ) ;
                cb04BufferDone += pbci - pbciSave ;

                }
                    }
                        }
                            }
                                //etThread.traceF( tinP , T("backlog [thrown,processed,backlog]:    ")+TF2(cThrown,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBacklog,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                countT cBacklog = cThrown - cProcessed ;
                                inc02AM( cProcessed ) ;

                                }
                                    if( pbw && cbw == head.len ) etThread.memCopyF( tinP , pbw , pbPayload , head.len ) ;

                                    fwsOut.getF( tinP , pbw , cbw , head.len , head.off ) ;
                                    ZE( countT , cbw ) ;
                                    ZE( byteT* , pbw ) ;

                                    fileWindowsC& fwsOut = *(fileWindowsC*)(countT)swFwsOut ;
                                {

                                }
                                    etThread.delF( tinP , psttf ) ;

                                    swFwsOut = (countT)pFws ;
                                    fileWindowsC* pFws = new( 0 , tinP , LF ) fileWindowsC( tinP , etThread , psttf , flFILEwINDOW_WRITE | flFILEwINDOW_DOnOTvALIDATE ) ; ___( pFws ) ;

                                    etThread.traceF( tinP , T("file name:    ")+T(psttf) ) ;
                                    etThread.strReplaceF( tinP , psttf , 0 , tColon , tDot ) ;
                                    etThread.strFuseF( tinP , psttf , TF3(head.idMeta,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ;
                                    etThread.strFuseF( tinP , psttf , tDot ) ;
                                    etThread.strFuseF( tinP , psttf , TF3(head.idMetaType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ;
                                    etThread.strFuseF( tinP , psttf , tDot ) ;
                                    etThread.strFuseF( tinP , psttf , TF3(head.idFileLo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ;
                                    etThread.strFuseF( tinP , psttf , tDot ) ;
                                    etThread.strFuseF( tinP , psttf , TF3(head.idFileHi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ;
                                    etThread.strFuseF( tinP , psttf , tDotHeyDot ) ;
                                    etThread.strFuseF( tinP , psttf , T(nnFrom) ) ;
                                    etThread.strMakeF( tinP , LF , psttf , tfn1 , TUCK ) ; ___( psttf ) ;
                                    ZE( strokeS* , psttf ) ;
                                {
                                if( !swFwsOut.idSlotOfLeverF( tinP , (countT)pbLeverFN ) )
                                pbLeverFN = (byteT*)&fn ;

                                fn.idMeta       = head.idMeta     ;
                                fn.idMetaType   = head.idMetaType ;
                                fn.idFileHi     = head.idFileHi   ;
                                fn.idFileLo     = head.idFileLo   ;
                                fn.nnFrom       = nnFrom          ;
                                udpFileNameS fn ;

                                inc02AM( cReceivedFileWindows ) ;

                                byteT* pbPayload = pbData + sizeof( udpFileGramHeadFileWindowS ) ;
                            {
                            else
                            if( !bOk ) etThread.traceF( tinP , T("secret rejected") ) ;

                            }
                                }
                                    break ;
                                    bOk = 1 ;
                                {
                                if( secretTry == secretOk )

                                countT secretOk  = ppcSecrets[ offSlot ][ offSecret ] ;
                                countT secretTry = head.secret ;
                                countT offSecret = offSecretF( tinP , etThread , nnFrom , offSlot ) ;
                                countT offSlot   = offEpochHonor % CuDPfILEePOCHsLOTS ;
                            {
                            for( countT offEpochHonor = OFFuDPfILEePOCHhONORmIN ; offEpochHonor <= OFFuDPfILEePOCHhONORmAX ; offEpochHonor ++ )           //U:: NEED TO HANDLE WRAP OF offEpochHonor EVERY 136 YEARS
                            ZE( boolT , bOk ) ;
                            //etThread.traceF( tinP , T("PUTfILEwINDOW ---------------------------------------------------------------------------------") ) ;

                            udpFileGramHeadFileWindowS& head = *(udpFileGramHeadFileWindowS*)pbData ;
                        {
                        case ifcIDcMDuDPfILEgRAM_PUTfILEwINDOW :
                        }
                            break ;
                            secretToUseP = head.secret ;        //A:ASSUME: ATOMIC (secretToUseP MUST ALWAYS CONTAIN A VALID SECRET)
                            //etThread.traceF( tinP , T("received [secret]:    ")+TF2(head.secret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            udpFileGramHeadSecretS& head = *(udpFileGramHeadSecretS*)pbData ;
                        {
                        case ifcIDcMDuDPfILEgRAM_USEtHISsECRET :
                        }
                            break ;
                            sThrow.writeF( tinP , idPortCatch /*idpFrom*/ , nnFrom , (byteT*)&gram , sizeof gram ) ;

                            //gram.pad3   = 0x3d3d3d3d ;
                            //gram.pad2   = 0x3d3d3d3d ;
                            //gram.pad1   = 0x3d3d3d3d ;
                            gram.secret = secret ;
                            gram.idCmd = ifcIDcMDuDPfILEgRAM_USEtHISsECRET ;
                            gram.cbThisGram = sizeof gram ;
                            udpFileGramHeadSecretS gram ;

                            //etThread.traceF( tinP , T("dispensing [offSlotHonorNewest,offSecret,secret]:    ")+TF2(offSlotHonorNewest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSecret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(secret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            countT secret    = ppcSecrets[ offSlotHonorNewest ][ offSecret ] ;
                            countT offSecret = offSecretF( tinP , etThread , nnFrom , offSlotHonorNewest ) ;

                            countT offSlotHonorNewest = OFFuDPfILEePOCHhONORmAX   % CuDPfILEePOCHsLOTS ;
                        {
                        case ifcIDcMDuDPfILEgRAM_WHATiSmYsECRET :
                    {
                    switch( head.idCmd )
                    udpFileGramHeadS& head = *(udpFileGramHeadS*)pbData ;

                    }

                        }
                            }
                                break ;
                                BLAMMO ;
                                etThread.traceF( tinP , T("received unexpected [from.sin6_family]:    ")+TF2(from.sin6_family,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            default :
                            }
                                break ;
                                BLAMMO ;
                                etThread.traceF( tinP , T("received AF_INET [from.sin6_family]:    ")+TF2(from.sin6_family,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            case AF_INET :
                            }
                                break ;

                                if( !nnFrom ) nnFrom = NICnAMElOCAL ;

                                }
                                    pcOut[ 3 - offi ] = ((tinNormalS&)tinP).brcRaw ;
                                    BOSdOnOTtEST( WHATgbo , ntohl( pcIn[ offi ] ) )
                                {
                                for( countT offi = 0 ; offi < 4 ; offi ++ )
                                countT* pcOut = (countT*)(const countT*)nnFrom ;
                                countT* pcIn  = (countT*)from.sin6_addr.u.Byte ;

                                idpFrom = ((tinNormalS&)tinP).brcRaw ;
                                BOSdOnOTtEST( WHATgbo , ntohs( from.sin6_port ) )
                            {
                            case AF_INET6 :
                        {
                        switch( from.sin6_family )
                    {
                    nicNameC nnFrom ;
                    ZE( countT , idpFrom ) ;

                    cCaught2 ++ ;

                    if( from.sin6_family != AF_INET6 ) { BLAMMO ; }

                    sockaddr_in6& from   = *(sockaddr_in6*)pbci ; pbci += sizeof( sockaddr_in6 ) ;
                    byteT*        pbData = pbci                 ; pbci += cbData                 ;

                    pbci += 4 * sizeof( countT ) ;

                    if( !idGram ) { BLAMMO ; }

                    countT& cbData    = ((countT*)pbci)[ 3 ] ;
                    countT& rc        = ((countT*)pbci)[ 2 ] ;
                    countT& idGram    = ((countT*)pbci)[ 1 ] ;
                    countT& offNextNU = ((countT*)pbci)[ 0 ] ;      // THIS POINTS INTO THE CIRCULAR BUFFER USED BY s_readF AND IS USELESS TO ME

                    //
                    //  01+cbData sizeof( sockaddr_in6 )    from
                    //  01        cbData                    data
                    //  c         4                         cbData
                    //  8         4                         rc
                    //  4         4                         idGram (serial number)
                    //  0         4                         offNextNU
                    //
                    //  offset    length                    description
                    //
                {
                else
                if( cIn % cWorkersP != offWorkerP ) pbci += cbThis ;

                //CONoUTrAW( "+" ) ;
                cIn ++ ;

                if( bFail1 || bFail2 ) break ;     // CLOSES THE CURRENT FILE WINDOW AND, IN THE NEXT ITERATION, OPENING A NEW FILE WINDOW POSITIONED AT THE BEGINNING OF THE CURRENT RECORD

                boolT  bFail2 = bFail1 ? 0 : pbci + cbThis > pbcie ;
                countT cbThis = bFail1 ? 0 : 4 * sizeof( countT ) + ((countT*)pbci)[ 3 ] + sizeof( sockaddr_in6 ) ;
                boolT  bFail1 = pbci + 4 * sizeof( countT ) > pbcie ;
                
                byteT* pbciSave = pbci ;

                }
                    break ;
                    bNap = 1 ;
                {
                if( cIn == idGramPouredLathP )
            {
            while( pbci < pbcie )
            ZE( boolT , bNap ) ;

            byteT* pbcie = pbBufw + cbBufw ;
            byteT* pbci  = pbBufw ;

            if( !pbBufw || !cbBufw ) break ;

            //etThread.traceF( tinP , T("window [cb04BufferDone,cbBufw]:    ")+TF2((countT)cb04BufferDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbBufw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            fwsBuffer.getF( tinP , pbBufw , cbBufw , 0 , cb04BufferDone ) ;
            ZE( countT , cbBufw ) ;
            ZE( byteT* , pbBufw ) ;

            fileWindowsC fwsBuffer( tinP , etThread , tFileBuffer , flFILEwINDOW_DOnOTvALIDATE ) ;
        {
        while( !ether )  // FOR EACH INPUT FILE WINDOW (SELECTED WITH cb04BufferDone)

        switchC swFwsOut( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pbLeverFN , sizeof( udpFileNameS ) ) ;
        ZE( const byteT* , pbLeverFN ) ;
    {
    while( !ether )
    ZE( countT , cAccepted ) ;
    ZE( countT , cIn       ) ;
    TN( tFileBuffer , "///d/tmp/foo.buffer.ttt" ) ;
    ZE( count04T , cb04BufferDone ) ;

    TN( tfn1 , "///d/tmp/foo.udp.file.") ;      //U:: REMOVE "foo."
    TN( tDotHeyDot , ".!." ) ;
    TN( tColon , ":" ) ;
    TN( tDot , "." ) ;
    TN( tb4  , "    " ) ;
    const countT cbMin = 0xc + ifcCBdATAGRAMmAX + sizeof( sockaddr_in6 ) ;
    sThrow.bindF( tinP ) ;
    socketC sThrow( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    countT&      idGramPouredLathP = *(countT*)pTaskP->c4     ;
    const countT cWorkersP         =           pTaskP->c3     ;
    const countT offWorkerP        =           pTaskP->c2 - 1 ;
    countT&      secretToUseP      = *(countT*)pTaskP->c1     ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmUdpFileObey2F )

DONE( tmComplainF )
}
    }
        Sleep( 100 ) ;

        }
            dec02AM( cComplaintPending ) ;
            etThread.traceF( tinP , t1+TF2(cComplaintPending,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        while( cComplaintPending )
    {
    while( !ether )
    TN( t1 , "buffer overrun (packets lost) [cComplaintsPending,cProcessed (approximate)]:    " ) ;
    TN( tb4 , "    " ) ;
{
if( pTaskP )
TASK( tmComplainF )

DONE( tmGetSecretF )
}
    }
        ++ s ; ether.osSleepF( tinP , TIMEuDPfILEePOCH >> 1 ) ;

        }
            ++ s ; ether.osSleepF( tinP , TOCK >> 4 ) ;
            sThrow.writeF( tinP , idPortCatch , nicNameC() , (byteT*)&gram , sizeof gram ) ;
            gram.idCmd = ifcIDcMDuDPfILEgRAM_WHATiSmYsECRET ;
            gram.cbThisGram = sizeof gram ;
            udpFileGramHeadSecretS gram ;
            //CONoUTrAW( "!" ) ;
        {
        while( old == secretToUseP )
        countT old =  secretToUseP ;
    {
    while( !ether )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    sThrow.bindF( tinP ) ;
    socketC sThrow( tinP , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    countT& secretToUseP = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmGetSecretF )

DONE( tmUdpFileEpochClockF )
}
    }
        }
            //etThread.traceF( tinP , T("ready to test incoming secrets") ) ;
            bSetup = 0 ;
        {
        if( bSetup && !OFFuDPfILEePOCHhONORmIN )          // OFFuDPfILEePOCHhONORmIN IS INITIALLY NEGATIVE ; WHEN IT BECOMES 0, WE ARE READY TO START TESTING INCOMING SECRETS

        offEpochFreshening ++ ;

        if( !bSetup ) { ++ s ; ether.osSleepF( tinP , TIMEuDPfILEePOCH ) ; }

        }
            ppcHashSecrets[ offSlotFreshen ][ offSecret ] = ru2 ;
        {
        for( countT offSecret = 0 ; offSecret < CuDPfILEhASHsECRETS ; offSecret ++ )
        ranUniC ru2( tinP , (measure04T)MAXcOUNTT + 1 , slab.trueRandom ) ;

        }
            ppcSecrets[ offSlotFreshen ][ offSecret ] = ru1 ;
        {
        for( countT offSecret = 0 ; offSecret < CuDPfILEsECRETS ; offSecret ++ )
        ranUniC ru1( tinP , (measure04T)MAXcOUNTT + 1 , slab.trueRandom ) ;

        //etThread.traceF( tinP , T("[offEpochFreshening,OFFuDPfILEePOCHhONORmIN,OFFuDPfILEePOCHhONORmAX]:    ")+TF2(offEpochFreshening,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(OFFuDPfILEePOCHhONORmIN,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(OFFuDPfILEePOCHhONORmAX,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        //etThread.traceF( tinP , T("[offSlotFreshen,offSlotHonorOldest,offSlotHonorNewest]:    ")+TF2(offSlotFreshen,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSlotHonorOldest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSlotHonorNewest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        countT offSlotHonorNewest = OFFuDPfILEePOCHhONORmAX   % CuDPfILEePOCHsLOTS ;
        countT offSlotHonorOldest = OFFuDPfILEePOCHhONORmIN   % CuDPfILEePOCHsLOTS ;
        countT offSlotFreshen     = offEpochFreshening % CuDPfILEePOCHsLOTS ;
    {
    while( !ether )
    slabS& slab = slabS::slabIF() ;
    boolT bSetup = 1 ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    TN( tb4 , "    " ) ;
{
if( pTaskP )
TASK( tmUdpFileEpochClockF )

}
    return offs % CuDPfILEsECRETS ;

    //etherP.traceF( tinP , T("offSecretF [off,nn,offSlotP]:    ")+TF2(offs%CuDPfILEsECRETS,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnP)+tb4+TF2(offSlotP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4 ) ;

    }
        offs ^= *( pcc ++ ) ^ hashSecret ;
        //etherP.traceF( tinP , T("offSecretF [offhs,hashSecret]:    ")+TF2(offhs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(hashSecret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        countT hashSecret = ppcHashSecrets[ offSlotP ][ offhs ] ;
    {
    for( countT offhs = 0 ; pcc < pce && offhs < CuDPfILEhASHsECRETS ; offhs ++ )
    ZE( countT , offs ) ;
    TN( tb4 , "    " ) ;

    countT* pce = pcc + sizeof nnP / sizeof( countT ) ;         //A:ASSUME: nicNameC IS AN INTEGRAL NUMBER OF countT ; IF NOT TRUE THEN THE TRAILING PORTION WILL NOT BE HASHED
    countT* pcc = (countT*)&nnP ;
{
countT offSecretF( tinBaseS& tinP , etherC& etherP , const nicNameC& nnP , const countT offSlotP )

;
}
    countT   idMeta ;
    countT   idMetaType ;
    countT   idFileHi ;
    countT   idFileLo ;
    countT   secret ;
    countT   len ;
    count04T off ;
{
struct udpFileGramHeadFileWindowS : public udpFileGramHeadS

;
}
    countT   secret ;
{
struct udpFileGramHeadSecretS : public udpFileGramHeadS

;
}
    countT   idCmd ;
    countT   cbThisGram ;       // INCLUDES ENTIRE udpFileGramHeadS INCLUDING THIS MEMBER
{
struct udpFileGramHeadS

;
}
    countT   idMeta ;
    countT   idMetaType ;
    countT   idFileHi ;
    countT   idFileLo ;
    nicNameC nnFrom ;
{
struct udpFileNameS

countT   ppcHashSecrets[ CuDPfILEePOCHsLOTS ][ CuDPfILEhASHsECRETS ] ;

                                                // THE OLDEST ROW IS NOT REFERENCED, AND RECEIVES FRESH RANDOM countT VALUES IMMEDIATELY BEFORE offEpochFreshening IS INCREMENTED
                                                // HONORS    ppcSecrets[ offHonor                   % CuDPfILEePOCHsLOTS ][ ii ] WHERE offHonor IS IN [ offEpochFreshening - CuDPfILEePOCHhONORED , offEpochFreshening - 1 ]
countT   ppcSecrets[ CuDPfILEePOCHsLOTS ][ CuDPfILEsECRETS ] ;  // DISPENSES ppcSecrets[ ( offEpochFreshening - 1 ) % CuDPfILEePOCHsLOTS ][ ii ] IF offSecretF RETURNS ii, CALCULATED BY HASHING THE IP ADDRESS
countT   offEpochFreshening ;
byteT    pbFastBuffer[ TICK ] ;
countT   cComplaintPending ;
countT   cCaught2 ;
countT   cCaught1 ;
countT   cProcessed ;
countT   cThrown ;
count04T cb04Thrown ;
countT   cReceivedFileWindows ;
countT   idPortCatch ;

#define CuDPfILEhASHsECRETS ( sizeof( nicNameC ) / sizeof( countT ) )

#define CuDPfILEsECRETS    TOCK

#define TIMEuDPfILEePOCH ( TOCK << 4 )

#define OFFuDPfILEePOCHhONORmAX ( offEpochFreshening - 1             )
#define OFFuDPfILEePOCHhONORmIN ( offEpochFreshening - CuDPfILEePOCHhONORED )

#define CuDPfILEePOCHhONORED ( CuDPfILEePOCHsLOTS - 1 )

#define CuDPfILEePOCHsLOTS 5

#define ifcIDuDPfILEmETAtYPE_IDoWNERhI          0xa
#define ifcIDuDPfILEmETAtYPE_IDoWNERlO          0x9
#define ifcIDuDPfILEmETAtYPE_IDvERSION          0x8
#define ifcIDuDPfILEmETAtYPE_IDgENERATION       0x7
#define ifcIDuDPfILEmETAtYPE_TIMEmODIFIED       0x6
#define ifcIDuDPfILEmETAtYPE_TIMEcREATED        0x5
#define ifcIDuDPfILEmETAtYPE_CONTENT            0x4
#define ifcIDuDPfILEmETAtYPE_HASHoFcONTENT      0x3
#define ifcIDuDPfILEmETAtYPE_CONTROLsETTINGS    0x2
#define ifcIDuDPfILEmETAtYPE_BASEoSfILEnAME     0x1

#define ifcIDcMDuDPfILEgRAM_PUTfILEwINDOW       0x3
#define ifcIDcMDuDPfILEgRAM_USEtHISsECRET       0x2
#define ifcIDcMDuDPfILEgRAM_WHATiSmYsECRET      0x1

#define CBpAYLOAD ( ifcCBdATAGRAMmAX - sizeof( udpFileGramHeadFileWindowS ) )

//BASELINE: 510007c7

/*1*/WAKEsHOWtEXT( "udp.cdn.proof.of.concept.add.idFile.and.attributes" )/*1*/
/**/
*/
 this code works and suggests that code like this can keep up with incoming datagrams on a 1 gbit per second wire
 instead, secrets are honored for unlimited requests within an epoch (e.g. a tock or tock << 2)
 i eliminate the concept of ttl for each secret per requester
 baseline: 5adam.510007c2.1
i use hash to map ip address to secret in order to bound the size of the state needed for deluge of spoofed requests for secret
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
