
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    THREADmODE4rESTORE
    }
        root.ungrabF( tin0P ) ;

        }
            //20161225@0937: CONJ: NOT NEEDED: pKid->ungrabF( tin0P ) ;

                   root.pKid = this ;
            pKid = root.pKid ;

            //20161225@0937: CONJ: NOT NEEDED: root.pKid->grabF( tin0P , TAGoR( TAGiDnULL , idLineCt , idiFileCt , (byteT*)0 ) ) ;
        {
        else
        if( !root.pKid ) { root.pKid = this ; }

        root.grabF( tin0P , TAGoR( TAGiDnULL , idLineCt , idiFileCt , (byteT*)0 ) ) ;

        }
            pc->ungrabF( tin0P ) ;
            }
                pc = pc->pKid ;
                pc->ungrabF( tin0P ) ;
        
                }
                    BLAMMO ;
                    LOGrAW( "linkedC::linkedC / error: i am already in the list, so am calling BLAMMO\r\n" ) ;      //U::20201027@1300: OBSERVED, AFTER ADDING bksTelemetryApp
                {
                if( pc->pKid == this )
        
                //LOGrAW5( "linkedC ++++      walk [idThread,pc->pKid]:    " , ((tin123S&)tin0P).monitor.idThread , "                      " , pc->pKid , "\r\n" ) ;

                pc->pKid->grabF( tin0P , TAGoR( TAGiDnULL , idLineCt , idiFileCt , (byteT*)0 ) ) ;
                if( getNegAM( pc->pKid->finger ) != FINGERnEG_LINKEDc ) { BLAMMO ; }
                if( getNegAM( pc->finger ) != FINGERnEG_LINKEDc ) { BLAMMO ; }
            {
            while( pc->pKid )
            linkedC* pc = &root ;
        
            //LOGrAW5( "linkedC ++++                              :    " , ((tin123S&)tin0P).monitor.idThread , "    " , this , "\r\n" ) ;

            root.grabF( tin0P , TAGoR( TAGiDnULL , idLineCt , idiFileCt , (byteT*)0 ) ) ;
        {
        //U::TO FIND A BUG 20161225@0951

        grabitC grabitx( tin0P , TAG( TAGiDnULL ) ) ;

        putNegAM( finger , FINGERnEG_LINKEDc ) ;
        if( getNegAM( finger ) != FINGERnEG_GRABOTc ) { BLAMMO ; }  //U:: 20201027@1358: TO FIND A BUG
        if( getNegAM( finger ) == FINGERnEG_LINKEDc ) { BLAMMO ; }  //U:: 20201027@1358: TO FIND A BUG

        //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) { CONoUTrAW( "linkedC 1\r\n" ) ; } //U:: TO FIND A BUG

        _IO_
    {
    THREADmODE4oN( flTHREADmODE4_INoUTfRAMEdEFERwRITINGaPPtELEMETRY )
    ((tin123S&)tin0P).flushPendingInOutFrameTelemetryIfF() ;

    //LOGrAW3( " linkedC ++++++++ [this]:    " , this , "\r\n" ) ; //U:: TO FIND A BUG
{
idAdam( ((tin1S&)tin0P).pag1->idAdam )
pKid( 0 ) ,
root( rootP ) ,
idType( rootP.idType ) ,
grabotC( tin0P , idLineCtP , idiFileCtP , pbBitsCtP , &rootP == &processGlobal4I._handleC_linked_sm ? flGRABITc_SHARElAYER | flGRABITc_SNEAKYlOVER : flGRABITc_SHARElAYER , 0 , rootP.idGrabLayer ) ,
/*1*/linkedC::linkedC( tin0S& tin0P , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , linkedC& rootP ) :/*1*/

/**/

*/
 the caller must construct: tlsAllocStackExp_8_C tls( tin0P )
    but ct and dt is fastest when it is strictly lifo
    lifo is not required
   this is most efficient when ct and dt is probabilistically lifo
   the former kid of the root will become my kid
  i will be attached as the kid of the root
   the root instance has no application data associated with it
  should specify an instance that is not of a derived type
 rootP
 pbBitsCtP
 idiFileCtP
 idLineCtP
 tin0P
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

