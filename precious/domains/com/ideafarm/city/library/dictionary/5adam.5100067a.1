
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;

}
    }
        etThread.delF( tin0P , pc2 ) ;
        etThread.delF( tin0P , *(strokeS**)&pc2->c2 ) ;
        etThread.delF( tin0P , *(strokeS**)&pc2->c1 ) ;
        etThread.strokeF( tin0P , T("[idEmail,label]: ")+T((strokeS*)pc2->c1)+T("    ")+T((strokeS*)pc2->c2)+T("\r\n") ) ;

        swsLabel >> pc2 ;
        ZE( count2S* , pc2 ) ;
    {
    while( swsLabel )

    etThread.strokeF( tin0P , T("key: ")+T(psttLever)+T("\r\n") ) ;
    psttLever = (strokeS*)swsLabel.leverF( tin0P , idf ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
countT cFlavors = swsLabel.cFlavorsF( tin0P ) ;

etThread.delF( tin0P , pstt1Lines ) ;
etThread.delF( tin0P , psttLabel ) ;
etThread.delF( tin0P , psttIdEmail ) ;
}

    }
        default : { __1 ; break ; }
        }
            break ;

            etThread.delF( tin0P , psttKey ) ;

            }
                pc2 = 0 ;
                swsLabel.sinkF( tin0P , countTC() , pc2 , flSTACKsINK_null , subtractKeyIdEmailF ) ;
                psttLever = psttKey ;

                etThread.strMakeF( tin0P , LF , *(strokeS**)&pc2->c2 , psttLabel   ) ; ___( *(strokeS**)&pc2->c2 ) ;
                etThread.strMakeF( tin0P , LF , *(strokeS**)&pc2->c1 , psttIdEmail ) ; ___( *(strokeS**)&pc2->c1 ) ;

                pc2->c2 = pc2->c1 = 0 ;
            {
            if( !POOP )

            __Z( pc2 ) ;
            etThread.newF( tin0P , LF , pc2 ) ; ___( pc2 ) ;
            ZE( count2S* , pc2 ) ;

            etThread.strokeF( tin0P , T("key: ")+T(psttKey)+tcr ) ;
            __( etThread.strIdF( tin0P , countTC( 1 ) , countTC( 1 ) , sttq , sttBlank , psttKey ) ) ;
            etThread.strTrimF( tin0P , psttKey , psttc1 ) ; ___( psttKey ) ;
            ZE( strokeS* , psttKey ) ;
        {
        case ' ' :
        }
            break ;

            }
                __Z( psttIdEmail->idAdam ) ;
                __Z( psttLabel->idAdam ) ;
            {
            if( !POOP )
            __Z( psttIdEmail ) ;
            __Z( psttLabel ) ;
    
            if( idf ) { etThread.strSubstringF( tin0P , psttIdEmail , idf , countTC() , psttc1 ) ; ___( psttIdEmail ) ; }
    
            etThread.strSubstringF( tin0P , psttLabel , idf , sttq , sttColon , psttc1 ) ; ___( psttLabel ) ;
            countT idf = 2 ;
    
            etThread.delF( tin0P , psttLabel ) ;
            etThread.delF( tin0P , psttIdEmail ) ;
        {
        case ':' :
    {
    switch( psttc1[ CSpREFIX ].idAdam )
    etThread.strokeF( tin0P , T(psttc1)+tcr ) ;
{
FORsTRINGSiN1( pstt1Lines )
ZE( strokeS* , psttIdEmail ) ;
ZE( strokeS* , psttLabel ) ;
strokeS sttBlank( ' ' ) ;
strokeS sttColon( ':' ) ;
TN( tcr , "\r\n" ) ;

etThread.delF( tin0P , pstti ) ;
etThread.strWordsF( tin0P , pstt1Lines , pstti , sttq , T("\r\n") ) ; ___( pstt1Lines ) ;
strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
ZE( strokeS* , pstt1Lines ) ;

etThread.delF( tin0P , posti ) ;
etThread.strMakeFromOsTextF( tin0P , pstti , posti , costi ) ; ___( pstti ) ;
ZE( strokeS* , pstti ) ;

etThread.boxGetShadowF( tin0P , posti , costi , T("///d/ideafarm.work/txt/email.record.category.assignments.small.ttt") ) ; ___( posti ) ;
ZE( countT   , costi ) ;
ZE( osTextT* , posti ) ;

switchStackC swsLabel( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttLever , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_count2S ) ;
ZE( strokeS* , psttLever ) ;

TODO

}
    return sgn ;

    if( !sgn ) sgn = ether.strCompareF( tin0P , (strokeS*)pc1P->c2 , (strokeS*)pc2P->c2 ) ;
    sCountT    sgn = ether.strCompareF( tin0P , (strokeS*)pc1P->c1 , (strokeS*)pc2P->c1 ) ;

    count2S* pc2P = (count2S*)c2P ;
    count2S* pc1P = (count2S*)c1P ;

    etherC& ether = *(etherC*)pEtherP ;

    }
        if( !pEtherP || !c1P || !c2P ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/countT subtractKeyIdEmailF( tin0S& tin0P , countT& pEtherP , countT& c1P , countT& c2P , countT& c3P )/*1*/

/*1*/WAKEsHOWtEXT( "tool.unfinished.categorize.email.record" )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

