
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    grab.ungrabF( tinBaseP ) ;

    }
        }
            ether.delF( tinBaseP , *(byteT**)&pKid ) ;
            hdr.pSwsKids->insertF( tinBaseP , (countT)pKid , ifcSTACKtYPE_BLOB , 0 , bLeftP ) ;
            psttLeverKidsShared = pCursor->psttLeverKids ;
            if( !pCursor->psttLeverKids ) wifeF( tinBaseP ) ;
            SET_psttLeverKids( pCursor )
            }
                }
                    }
                        ether.delF( tinBaseP , pKid->psttLeverKids ) ;
                        *pSoulP >> pKid->psttLeverKids ; //U::ELIMINATE THIS
                    {
                    if( F(flagsTreeWrite) & flTREEwRITE_psttLeverKids )

                    }
                        pKid->cLeverWife = save ;
        
                        }
                            }
                                *pSoulP >> *(strokeS**)&(countT&)*pKid->pSw_psttWife ;
                                cLeverWifeShared = pKid->cLeverWife ;
                                *pSoulP >> pKid->cLeverWife ;
                                pKid->cLeverWife = 0 ;
                            {
                            while( cFlavors -- )
        
                            *pSoulP >> cFlavors ;
                            ZE( countT , cFlavors ) ;
                        {
                        if( pKid->pSw_psttWife )
                        ether( tinBaseP , pKid->pSw_psttWife , TAG( TAGiDnULL ) , flagsSwitch , cLeverWifeShared , sw_pCursor.pLeverLathRefF( tinBaseP ) ) ;
        
                        const countT save = pKid->cLeverWife ;
                    {
                    if( F(flagsTreeWrite) & flTREEwRITE_pSw_psttWife )
        
                    }
                        *pSoulP >> pKid->cLeverWife ;
                    {
                    if( F(flagsTreeWrite) & flTREEwRITE_cLeverWife )
        
                    *pSoulP >> flagsTreeWrite ;
                    ZE( flagsT , flagsTreeWrite ) ;
                {
                if( pSoulP )
    
                (*pBranchDefinitionCBF)( tinBaseP , ether , ifcIDtYPEtREEbRANCHdEFINITIONoLDcb_NEW , flTREEwALK_null , handle , (byteT*)( pKid + 1 ) , cbd , cArg ) ;

                handle.osF( ifcIDtYPEhANDLE_TREEwALK , (countT)pKid ) ;
                handleC handle( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_TREEwALK ) ;

                countT cArg = (countT)psttP ;
                new( 0 , tinBaseP , (byteT*)pKid , sizeof( branchHeaderOldS ) ) branchHeaderOldS( &hdr ) ;
            {
            if( pKid )
            ether.newF( tinBaseP , LF , *(byteT**)&pKid , sizeof( branchHeaderOldS ) + cbd ) ; ___( pKid ) ;
            ZE( branchHeaderOldS* , pKid ) ;
        {
        if( hdr.pSwsKids && hdr.pSw_psttWife && hdr.pSw_idKidLathHugged )

        if( !hdr.pSwsKids            ) { ether( tinBaseP , hdr.pSwsKids            , TAG( TAGiDnULL ) , flagsSwitch , psttLeverKidsShared , flagsStack | flSTACKc_BLOB , sizeof( branchHeaderOldS ) + cbd , sw_pCursor.pLeverLathRefF( tinBaseP ) ) ; }
        if( !hdr.pSw_idKidLathHugged ) { ether( tinBaseP , hdr.pSw_idKidLathHugged , TAG( TAGiDnULL ) , flagsSwitch , psttLeverKidsShared , sw_pCursor.pLeverLathRefF( tinBaseP ) ) ; }
        if( !hdr.pSw_psttWife        ) { ether( tinBaseP , hdr.pSw_psttWife        , TAG( TAGiDnULL ) , flagsSwitch , cLeverWifeShared    , sw_pCursor.pLeverLathRefF( tinBaseP ) ) ; }
        branchHeaderOldS& hdr = *pCursor ;
    {
    else
    }
        }
            }
                }
                    ether.delF( tinBaseP , pRoot->psttLeverKids ) ;
                    *pSoulP >> pRoot->psttLeverKids ; //U::ELIMINATE THIS
                {
                if( F(flagsTreeWrite) & flTREEwRITE_psttLeverKids )

                }
                    pRoot->cLeverWife = save ;

                    }
                        }
                            *pSoulP >> *(strokeS**)&(countT&)*pRoot->pSw_psttWife ;
                            cLeverWifeShared = pRoot->cLeverWife ;
                            *pSoulP >> pRoot->cLeverWife ;
                            pRoot->cLeverWife = 0 ;
                        {
                        while( cFlavors -- )

                        *pSoulP >> cFlavors ;
                        ZE( countT , cFlavors ) ;
                    {
                    if( pRoot->pSw_psttWife )
                    ether( tinBaseP , pRoot->pSw_psttWife , TAG( TAGiDnULL ) , flagsSwitch , cLeverWifeShared , sw_pCursor.pLeverLathRefF( tinBaseP ) ) ;

                    const countT save = pRoot->cLeverWife ;
                {
                if( F(flagsTreeWrite) & flTREEwRITE_pSw_psttWife )

                }
                    *pSoulP >> pRoot->cLeverWife ;
                {
                if( F(flagsTreeWrite) & flTREEwRITE_cLeverWife )

                *pSoulP >> flagsTreeWrite ;
                ZE( flagsT , flagsTreeWrite ) ;
            {
            if( pSoulP )
    
            (*pBranchDefinitionCBF)( tinBaseP , ether , ifcIDtYPEtREEbRANCHdEFINITIONoLDcb_NEW , flTREEwALK_null , handle , (byteT*)( pRoot + 1 ) , cbd , cArg ) ;
            countT cArg = (countT)(strokeS*)tRoot ;

            handle.osF( ifcIDtYPEhANDLE_TREEwALK , (countT)pRoot ) ;
            handleC handle( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_TREEwALK ) ;
    
            TN( tRoot , "" ) ; tRoot = T(psttP) ;

            new( 0 , tinBaseP , (byteT*)pRoot , sizeof( branchHeaderOldS ) ) branchHeaderOldS( 0 ) ;
            PcURSOR
        {
        if( pRoot )
        ether.newF( tinBaseP , LF , *(byteT**)&pRoot , sizeof( branchHeaderOldS ) + cbd ) ; ___( pRoot ) ;
    {
    if( !pCursor )
    PcURSOR

    *sw_pCursor.pLeverLathRefF( tinBaseP ) = cLeverCursor ;
    grab.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
{
/*1*/voidT treeOldC::newKidF( tin0S& tinBaseP , const strokeS* const psttP , soulC* pSoulP , const boolT bLeftP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

