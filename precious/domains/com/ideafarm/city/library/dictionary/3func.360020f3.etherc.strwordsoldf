
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cWords ;

    }
        }
            }
                }
                    cWords ++ ;_WQ
                    delF( tin0P , psttd ) ;_WQ
                    strFuseSeparateF( tin0P , pstt1P , psttd , csttPrefixNullsP , csttSuffixNullsP ) ;_WQ
                    strSubstringF( tin0P , psttd , idfDelim , idlDelim , psttP ) ; ___( psttd ) ;_WQ
                    ZE( strokeS* , psttd ) ;_WQ
                {
                else
                if( cTries ) csNeeded += CSpREFIX + idlDelim - idfDelim + 1 + csttPrefixNullsP + csttSuffixNullsP ;
            {
            if( bDelimiters && idfDelim )

            }
                delF( tin0P , psttw3 ) ;_WQ

                }
                    cWords ++ ;_WQ
                    strFuseSeparateF( tin0P , pstt1P , psttw3 , csttPrefixNullsP , csttSuffixNullsP ) ; ___( pstt1P ) ;_WQ
                    strReplaceF( tin0P , psttw3 , 0 , T("\\\"") , T("\"") , 0 , flSTRrEPLACE_IGNOREqUOTES ) ;_WQ
                {
                else
                if( cTries ) csNeeded += CSpREFIX + psttw3->idAdam + csttPrefixNullsP + csttSuffixNullsP ;

                delF( tin0P , psttw2 ) ;_WQ
                else { strMakeF( tin0P , LF , psttw3 , psttw2 ) ; ___( psttw3 ) ; }
                }
                    }
                        strSubstringF( tin0P , psttw3 , idf3 , idl3 , psttw2 ) ; ___( psttw3 ) ;_WQ
                        countT idl3 = psttw2->idAdam - 1 ;_WQ
                        countT idf3 = 2 ;_WQ
                    {
                    else
                    if( psttw2->idAdam == 2 ) { strMakeF( tin0P , LF , psttw3 , T("") ) ; ___( psttw3 ) ; }
                {
                if( sttQuoteP.idCaste != sc_IGNOREqUOTES && psttw2->idAdam > 1 && psttw2[ CSpREFIX ] == sttd && psttw2[ CSpREFIX - 1 + psttw2->idAdam ] == sttd )
                strokeS sttd = S1C(0x22) ; //0x22 is a double quote
                ZE( strokeS* , psttw3 ) ;_WQ
                strSubstringF( tin0P , psttw2 , idfSave , idw , psttP ) ; ___( psttw2 ) ;_WQ
                ZE( strokeS* , psttw2 ) ;_WQ
                if( idw > idfSave ) idw -- ;_WQ
            {
            if( idfSave <= psttP->idAdam && !strIdF( tin0P , psttP[ CSpREFIX - 1 + idfSave ] , psttDelimiters ) )

            //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) LOGrAW5( "[idfDelim,idlDelim]: " , idfDelim , " " , idlDelim , "\r\n" ) ;_WQ

            ;_WQ
                    : psttP->idAdam ;_WQ
                    ? idf - 1
                : idf
                ? 0
            countT idlDelim = !idfDelim
            countT idfDelim = idw ;_WQ

            countT idw = strIdAnyF( tin0P , 0 , flSTRmATCH_null , idf , sttQuoteP , psttDelimiters , psttP ) ;_WQ
            sttQuoteP = sttqSave ; //NEEDED WHEN INPUT CONTAINS AN UNPAIRED QUOTE
            countT idfSave = idf ;_WQ
        {
        while( !POOP && idf )
        countT idf = 1 ;_WQ

        }
            strMakeF( tin0P , LF , pstt1P , T("") , csNeeded + csttExtraP ) ; //CALLER MUST TAG ___( pstt1P ) ;_WQ
        {
        if( !cTries )
    {
    while( cTries -- )
    ZE( countT , cWords ) ;_WQ
    ZE( countT , csNeeded ) ;_WQ
    countT cTries = 2 ;_WQ

    //}
    //    PUSE( tin0P , *(byteT**)&psttd ) ;_WQ
    //    LOGrAW( T(USCORE79 "\r\n\r\n")+T(((tin123S&)tin0P).monitor.idThread)+T("|psttP| ")+T(psttd)+T("\r\n") ) ;_WQ
    //    etherC::strDumpStrokesIF( tin0P , psttd , psttP ) ; ___( psttd ) ;_WQ
    //    ZE( strokeS* , psttd ) ;_WQ
    //{
    //if( ((tin123S&)tin0P).pc Utility[ 0 ] )

    const strokeS* psttDelimiters = psttDelimitersP ? psttDelimitersP : (strokeS*)tWhite ;_WQ
    TN( tWhite , TbLACK ) ;_WQ
    const strokeS sttqSave = sttQuoteP ;_WQ
    boolT bDelimiters = !!( F(flagsP) & flSTRwORDS_DELIMITERS ) ;_WQ

    _IO_

    }
        if( POOP ) return 0 ;
        __Z( psttP ) ;_WQ
        FV( flSTRwORDS , flagsP )
        __NZ( pstt1P ) ;_WQ
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/countT etherC::strWordsOldF( tin0S& tin0P , strokeS*& pstt1P , const strokeS* const psttP , strokeS& sttQuoteP , const strokeS* psttDelimitersP , const flagsT flagsP , const countT csttExtraP , const countT csttPrefixNullsP , const countT csttSuffixNullsP )/*1*/

/**/
*/
  each word in pstt1P will be suffixed with this many nulls
 csttSuffixNullsP
  each word in pstt1P will be prefixed with this many nulls
 csttPrefixNullsP
 csttExtraP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00103cf.flSTRwORDS!||
 flagsP
  if 0 then T(TbLACK) is used
  can be 0
 psttDelimitersP
 sttQuoteP
  must not be 0
 psttP
  after evaluation, will be allocated with exactly the number of strokes needed to store the result, plus csttExtraP
  must be 0
 pstt1P
 tin0P
arguments
backslash quote pairs are replaced with a quote stroke
a single leading and trailing pair of double quotes, if present, is trimmed from each string
delimiters within quotes are not used as delimiters
evaluates to the number of separate strings
parses psttP into separate strings
\<A HREF=\"5.103011a.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strWordsOldF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

