
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return *pRslt ;
    if( pBaton ) pBaton->ungrabF( tin0P ) ;
    else        pRslt = &(*pStack)[ idP ] ;
    if( third ) pRslt = &*(countT*)pbnu ;
    ZE( countT* , pRslt ) ;
    __Z( pStack ) ;
    stackC* pStack = (stackC*)(countT)swMe ;

    _IO_
    else if( osTidOwner != ((tin9S&)tin0P).osTid && !bDying && !( F(flagsSwitch) & flSTACKc_ALLOWmULTIPLEuNSERIALIZED ) ) BLAMMO ;
    else if( !osTidOwner ) osTidOwner = ((tin9S&)tin0P).osTid ;
    if( pBaton ) pBaton->grabF( tin0P , TAG( TAGiDnULL ) ) ;

    }
        if( third ) return *(countT*)pbnu ;
    {
    IFbEcAREFUL    

    SCOOP
    TINSL
{
/*1*/countT& switchStackC::operator [] ( const countT idP )/*1*/

/**/
*/
  idP == -2 , -3 , -4 , ... refer to items near the bottom of the stack
  idP == -1 refers to the bottommost (earliest) item
  idP == 1 refers to the topmost (most recently added) item
  U:: nawwh: conj: idP == 0 will work aok
  1-based: idP == 0 is illegal
  idP == 2 , 3 , 4 , ... refer to items near the top of the stack
 idP
arguments
like plateF except does not support pTinHasLeverP
if idP == i then evaluates to the i'th element on the stack for this thread
  \<A HREF=\"5.8e20104.1.1.0.html\"\>8e20104:  WAKEsHOW( "example.simplest.func.121000b.switchStackC.operator_element" )\</A\>
 simplest
examples
\<A HREF=\"5.121000b.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

