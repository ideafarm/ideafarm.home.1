
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;

etThread.traceF( tin0P , T("ok") ) ;

etThread.delF( tin0P , pbBuffer ) ;

}
    //break ; //U:: TO FIND A BUG

    cReceived = 0 ;
    etThread.traceF( tin0P , T("received [cReceived]:    ")+TF2(cReceived,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;

    etThread.traceF( tin0P , T("sent [cGram,time,timePerPacket]:    ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TT(timeE1,timeE2)+tb4+TF2(timePerPacket,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4 ) ;

    countT timePerPacket = timeE1 / idGram ;

    etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeA1 , timeA2 ) ;
    etThread.osTimeNowF( tin0P , timeE1 , timeE2 ) ;
    ZE( sCountT , timeE2 ) ;
    ZE( countT  , timeE1 ) ;

    }
        }
            }
                }
                    //Sleep( 0 ) ;            // TO SLOW ME DOWN

                    cbDone += cbNow ;
                    pbc    += cbNow ;

                    cThrown ++ ;

                    sThrow.writeF( tin0P , idPortCatch , nicNameC() , pbGram , sizeof( gramHeadS ) + cbNow ) ;
                    //CONoUTrAW( "!" ) ;
                    etThread.memCopyF( tin0P , pbPayload , pbc , cbNow ) ;
                    head.len = cbNow  ;
                    head.off = cbDone ;
                    idGram ++ ;

                    cbDo -= cbNow ;

                    ;
                        : CBpAYLOAD
                        ? cbDo
                    countT cbNow = cbDo < CBpAYLOAD
                {
                while( cbDo )
                countT cbDo = cbw ;
                byteT* pbc = pbw ;

                //etThread.boxPutF( tin0P , tFileIn+T(".window.")+tIdWindow , pbw , cbw ) ;
                //etThread.traceF( tin0P , T("[tIdWindow,cb]:    ")+tIdWindow+tb4+TF2(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                TN( tIdWindow , "" ) ; tIdWindow = TF3(++idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;
            {
            else
            if( !pbw || !cbw ) break ;

            fwsIn.getF( tin0P , pbw , cbw ) ;
            ZE( countT , cbw ) ;
            ZE( byteT* , pbw ) ;
        {
        while( !ether )
        etThread.traceF( tin0P , T("sending begun") ) ;
        ZE( count04T , cbDone ) ;
        byteT*     pbPayload = pbGram + sizeof( gramHeadS ) ;
        gramHeadS& head      = *(gramHeadS*)pbGram ;
        byteT      pbGram[ sizeof( gramHeadS ) + CBpAYLOAD ] ;
        ZE( countT , idWindow ) ;

        fileWindowsC fwsIn( tin0P , etThread , tFileIn ) ;

        sThrow.bindF( tin0P ) ;
        socketC sThrow( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
    {
    ZE( countT , idGram ) ;

    etThread.osTimeNowF( tin0P , timeA1 , timeA2 ) ;
    ZE( sCountT , timeA2 ) ;
    ZE( countT  , timeA1 ) ;
{
while( !ether )
TN( tFileIn     , "///d/tmp/foo.ttt" ) ;

}
    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
{
while( !idPortCatch )
sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
TN( tb4 , "    " ) ;

etThread.osThreadF( TaRG1( tmCatchF ) ) ;

TODO

DONE( tmCatchF )
}
    sCatch.readF( tin0P , (const countT&)ether , pbFastBuffer , sizeof pbFastBuffer ) ;

    idPortCatch = sCatch.bindF( tin0P ) ;
    socketC sCatch( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    etThread.osThreadF( TaRG1( tmObeyF ) ) ;
{
if( pTaskP )
TASK( tmCatchF )

DONE( tmObeyF )
}
    }
        Sleep( 0 ) ;

        }
            //etThread.traceF( tin0P , T("backlog [thrown,processed,backlog]:    ")+TF2(cThrown,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBacklog,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            //countT cBacklog = cThrown - cProcessed ;
            //cProcessed ++ ;

            }
                if( pbw && cbw == head.len ) etThread.memCopyF( tin0P , pbw , pbPayload , head.len ) ;

                fwsOut.getF( tin0P , pbw , cbw , head.len , head.off ) ;
                ZE( countT , cbw ) ;
                ZE( byteT* , pbw ) ;
            {

            // etThread.traceF( tin0P , T("received [off,len]:    ")+TF2((countT)head.off,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(head.len,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            byteT* pbPayload = pbData + sizeof( gramHeadS ) ;
            gramHeadS& head = *(gramHeadS*)pbData ;

            }
                idGramProcessedLath = idGram ;
                inc02AM( cComplaintPending ) ;
            {                
            if( idGramProcessedLath != idGram )

            sockaddr_in6& from   = *(sockaddr_in6*)pbc ; pbc += sizeof( sockaddr_in6 ) ;
            byteT*        pbData = pbc                 ; pbc += cbData                 ;

            pbc += 3 * sizeof( countT ) ;

            countT& cbData = ((countT*)pbc)[ 2 ] ;
            countT& rc     = ((countT*)pbc)[ 1 ] ;
            countT& idGram = ((countT*)pbc)[ 0 ] ;

            //
            //  c+cbData sizeof( sockaddr_in6 )    from
            //  c        cbData                    data
            //  8        4                         cbData
            //  4        4                         rc
            //  0        4                         idGram (serial number)
            //
            //  offset   length                    description
            //

            idGramProcessedLath ++ ;
            cReceived ++ ;

            if( pbc + cbMin > pbe ) pbc = pbCircle ;
        {
        while( idGramProcessedLath != idGramLath )      // INTENDED TO HANDLE WRAP AOK
    {
    while( !ether )
    ZE( countT , idGramProcessedLath ) ;
    TN( tb4 , "    " ) ;
    byteT* pbc = pbCircle ;
    const byteT* const pbe = pbFastBuffer + sizeof pbFastBuffer ;
    byteT* const pbCircle = pbFastBuffer + sizeof( countT ) ;
    countT& idGramLath = *(countT*)pbFastBuffer ;
    const countT cbMin = 0xc + ifcCBdATAGRAMmAX + sizeof( sockaddr_in6 ) ;

    fileWindowsC fwsOut( tin0P , etThread , tFileOut , flFILEwINDOW_WRITE | flFILEwINDOW_DOnOTvALIDATE ) ;
    etThread.boxPutF( tin0P , tFileOut , "X" , 1 ) ;
    TN( tFileOut     , "///d/tmp/foo.received.fws.ttt" ) ;

    etThread.osThreadF( TaRG1( tmComplainF ) ) ;
{
if( pTaskP )
TASK( tmObeyF )

DONE( tmComplainF )
}
    }
        Sleep( 100 ) ;

        }
            dec02AM( cComplaintPending ) ;
            etThread.traceF( tin0P , t1+TF2(cComplaintPending,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        while( cComplaintPending )
    {
    while( !ether )
    TN( t1 , "buffer overrun (packets lost) [cComplaintsPending,cProcessed (approximate)]:    " ) ;
    TN( tb4 , "    " ) ;
{
if( pTaskP )
TASK( tmComplainF )

;
}
    countT   len ;
    count04T off ;
{
struct gramHeadS

byteT  pbFastBuffer[ TOCK ] ;

count04T cbBufferUsed ;
countT   cbBuffer ;
byteT*   pbBuffer ;           //U:: REPLACE THIS CODE WITH CODE THAT SUPPORTS HUGE FILES (UP TO THE SIZE LIMIT SUPPORTED BY THE BASE OS)

countT cQueued ;
byteT* ppbQueue[ TOCK ] ;

countT cComplaintPending ;
countT cProcessed ;
countT cThrown ;
countT cReceived ;
countT idPortCatch ;

#define CBpAYLOAD ( ifcCBdATAGRAMmAX - sizeof( gramHeadS ) )

/*1*/WAKEsHOWtEXT( "udp.cdn.proof.of.concept.no.security" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
