
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    etThread.loafIF( tinBaseP ) ;

    //{ countT idAdam = 0x4010350 ; etThread.ifcHireF( tinBaseP , T("tool.gorilla.http.ideafarm.3") , idAdam , 0 , flHIRE_DISPLAYaUTO , nicNameC() ) ; }
    TELL( "hiring 0530104" ) ;

    //U::etThread.osThreadF( tinBaseP , countTC() , tmWatchDogF ) ;
    }
        ++ s ; ether.osSleepF( tinBaseP , TOCK * 2 ) ;
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    {

    while( cGorillas -- ) etThread.osThreadF( tinBaseP , countTC() , tmGorillaF ) ;
    countT cGorillas = 1 ;

    stateS state( tinBaseP , etThread ) ;
{

TODO

DONE( tmWatchDogF )

etThread.delF( tinBaseP , psttServer ) ;
        
}
    }
        }
            break ;
            }
                }
                    ++ s ; ether.osSleepF( tinBaseP , TICK * 0x10 , TOCK ) ;
                    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                {
    
                //etThread.strokeF( tinBaseP , T("notified Wo'O that http is down\r\n") ) ;
                //}
                //    WRITE( 221 , T("quit\r\n") ) ;
                //    WRITE( 250 , T("Subject: http down\r\n\r\nhttp is down at ")+TT(timeN1,timeN2)+T("\r\n.\r\n") ) ;
                //    WRITE( 354 , T("data\r\n") ) ;
                //    WRITE( 250 , T("rcpt to:<6507595306@vtext.com>\r\n") ) ;
                //    WRITE( 250 , T("mail from:<")+TF1(DDNUMB)+T(ifcEMAIL_MXsUFFIX ">\r\n") ) ;
                //    WRITE( 250 , T("helo ")+TF1(DDNUMB)+T(".ideafarm.com\r\n") ) ;
                //    TN( tOut , "" ) ;
                //
                //    __( sockc.readWoReplyF( tinBaseP , psttr ) - 220 ) ;
                //    sockc.connectF( tinBaseP , 0x19 , nnServer , 1 ) ;
                //
                //    socketC sockc( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
                //    ZE( strokeS* , psttr ) ;
                //{
                //etThread.strokeF( tinBaseP , TT(timeN1,timeN2)+T(": notifying Wo'O that http is down\r\n") ) ;
                //
                //etThread.osTimeNowF( tinBaseP , timeN1 , timeN2 ) ;
                //ZE( sCountT , timeN2 ) ;
                //ZE( countT , timeN1 ) ;
            {
            if( !ether )

            }
                ++ s ; ether.osSleepF( tinBaseP , TOCK * 2 ) ;
                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
            {
        {
        if( cOk == cOkSave && !ether )
    
        }
            ++ s ; ether.osSleepF( tinBaseP , TOCK * 0x20 ) ; //OCCASIONAL FALSE ALARMS AT 0x8
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        {
        countT cOkSave = cOk ;
    {
    while( !ether && !etThread )
{
while( !ether && !etThread )

nicNameC nnServer = socketC::nicNameIF( tinBaseP , etThread , psttServer ) ;
etThread.strokeF( tinBaseP , T("name server: \"")+T(psttServer)+T("\"\r\n") ) ;
etThread.dnsNicNamesF( tinBaseP , psttServer , psttd , ifcIDtYPEdNSqUERY_MX ) ; ___( psttServer ) ;
strokeS* psttd = tDomain ;
TN( tDomain , "vtext.com" ) ;
ZE( strokeS* , psttServer ) ;
TASK( tmWatchDogF )

DONE( tmGorillaF )

}
    }
        ++ s ; ether.osSleepF( tinBaseP , /*ru*/TOCK ) ;
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    {
    else
    }
        ++ s ; ether.osSleepF( tinBaseP , TOCK * 0x10 ) ; //ALLOWS TERMINATING THREADS TO COMPLETE
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    {
    if( !( idMe % 0x1000 ) )

    }
        etThread.ifcSayF( tinBaseP , TF1(DDNUMB)+T(" [idMe,cBad]: ")+TF1(idMe)+tb+TF1(cBad)+T("; request for ")+tHome+T(" fulfilled aok\r\n") , flSAY_APPEND | flSAY_LOG ) ;
        cOk ++ ;
    {
    else
    }
        //U::etThread.ifcSayF( tinBaseP , TF1(DDNUMB)+T(" [idMe,cBad]: ")+TF1(idMe)+tb+TF1(cBadMe)+T("; request for ")+tHome+T(" FAILED ********\r\n") , flSAY_APPEND | flSAY_LOG ) ;
        countT cBadMe = 1 + incv02AM( cBad ) ;
        *((tinFullS&)tinBaseP).zEtScratch = 0 ;
    {
    if( *((tinFullS&)tinBaseP).zEtScratch || !cbHome /*|| cbHome != cbHomeWoth*/ )
    if( !cbHomeWoth  ) cbHomeWoth  = cbHome ;   
    { ZE( byteT* , pbHome  ) ; ((tinFullS&)tinBaseP).zEtScratch->boxGetShadowF( tinBaseP , pbHome  , cbHome  , tHome  ) ; ___( pbHome  ) ; ((tinFullS&)tinBaseP).zEtScratch->delF( tinBaseP , pbHome  ) ; }
    ZE( countT , cbHome ) ;
    etThread.strokeF( tinBaseP , T("trial ")+TF1(idMe)+T("\r\n") ) ;
    countT idMe = 1 + incv02AM( idTrial ) ;
{
while( !etThread && !ether )
ranUniC ru( TICK , ((tinFullS&)tinBaseP).monitor.idThread ) ;
ZE( countT , cbHomeWoth ) ;
TN( tb , " " ) ;

//TN( tHome  , "www.ideafarm.com//http//" ) ;
//TN( tHome  , "127.1.1.1//http//" ) ;
TN( tHome  , "127.1.1.1//http//newblabroom.html" ) ;

THREADmODE2oN( flTHREADmODE2_QUIETiMPOTENCE )
//etThread.osThreadSwitchingDesireF( tinBaseP , ifcTHREADpRIORITY_RUSH ) ;

TASK( tmGorillaF )

countT cBad ;
countT cOk ;
countT idTrial ;

    etThread.delF( tinBaseP , psttr ) ;
    }                                                                                           \
        CONoUT2( T(psttr) , rc ) ;                                                              \
        __( rc - rcOkP ) ;                                                          \
        countT rc = sockc.readWoReplyF( tinBaseP , psttr ) ;                                       \
    {                                                                                           \
    sockc.writeF( tinBaseP , (osTextT*)tOut , tOut.csF( tinBaseP ) ) ;                                 \
    tOut = textP ;                                                                              \
                                                                                                \
#define WRITE(rcOkP,textP)                                                                      \

STATE0

/*1*/WAKEhIDE( "tool.gorilla.http.ideafarm.3" )/*1*/
/**/
*/
initially, use homogeneous gorillas that sleep a random time
 the mean sleep of the gorillas is a multiple of S such that there are 3 bunch levels
 G heterogeneous gorilla threads that sleep random times and periodically bunch
specs
obsoletes f940104
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

