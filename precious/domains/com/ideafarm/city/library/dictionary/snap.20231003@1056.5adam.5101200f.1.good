
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("ok") ) ;

}
    break ;

    }
        sorta.traceRangeF( pbArray , cbArray , T("after") ) ;
        sorta.sortF( tinBaseP ) ;
        sorta.traceRangeF( pbArray , cbArray , T("before") ) ;
        sortaC sorta( tinBaseP , etThread , bQuit , pbArray , cbArray , sizeof( countT ) , sizeof( countT ) , sizeof( countT ) , 1 , 0 ) ;
        //etThread.traceF( tinBaseP , TPS("@",0x25+cCounts*0x9,'@') , flTRACE_NOpREFIX ) ;
    {

    //}
    //    //sorta.traceRangeF( pbArray , cbArray , T("after") ) ;
    //    sorta.sortF( tinBaseP ) ;
    //    //sorta.traceRangeF( pbArray , cbArray , T("before") ) ;
    //    sortaC sorta( tinBaseP , etThread , bQuit , pbArray , cbArray , sizeof( countT ) , sizeof( countT ) , sizeof( countT ) , modulo , remainder ) ;
    //    //etThread.traceF( tinBaseP , TPS("@",0x25+cCounts*0x9,'@') , flTRACE_NOpREFIX ) ;
    //{
    //for( countT remainder = 0 ; remainder < modulo ; remainder ++ )
    //countT modulo = 4 ;
    ZE( boolT , bQuit ) ;

    }
        }
            case 2 : { pcArray[ offca ] = 0x33333333                                                      ; break ; }
            case 1 : { pcArray[ offca ] = ruChallenge /*; if( offca / 3 == 0xa ) pcArray[ offca ] = - 1*/ ; break ; }
            case 0 : { pcArray[ offca ] = 0x11111111                                                      ; break ; }
        {
        switch( offca % 3 )
    {
    for( countT offca = 0 ; offca < ccArray ; offca ++ )

    ranUniC ruChallenge( tinBaseP , (measure04T)MAXcOUNTT + 1 , cSeed ) ;
    //etThread.traceF( tinBaseP , T("[cSeed]:    ")+TF2(cSeed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_NOpREFIX ) ;
    cSeedLath = cSeed ;
    countT cSeed = 0x78E86FC1 /*slab.trueRandom*/ ;

    if( !( ++ idPass % ( TOCK << 0 ) ) ) etThread.traceF( tinBaseP , T("[idPass]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; ;
{
while( !ether )
ZE( countT , idPass ) ;
countT  cCounts = ccArray ;
countT  ccArray = sizeof pbArray / sizeof( countT ) ;
countT* pcArray = (countT*)pbArray ;
slabS& slab = slabS::slabIF() ;

//etherC::loafIF( tinBaseP ) ;

TODO

countT cSeedLath ; // TO FIND A BUG

countT cbArray = sizeof pbArray ;
byteT  pbArray[ sizeof( countT ) * 0x30 ] ;

}
    if( cbArray >= ( cbElt << 1 ) * modulo ) doBitF( pbArray , cbArray , cbKey * SB - 1 ) ;
{
voidT sortaC::sortF( tinBaseS& tinBaseP )

}
    }
        }
            if( cEltsHigh > modulo ) doBitF( pbHighs , cbP - cbLows , shiftP ) ;
            if( cEltsLow  > modulo ) doBitF( pbP     , cbLows , shiftP ) ;

            countT cEltsHigh = ( cbP - cbLows ) / cbElt ;
            countT cEltsLow  = cbLows / cbElt ;
            countT cbLows    = pbHighs - pbP ;
        {
        else
        }
            doBitF( pbP , cbP , shiftP ) ;
        {
        if( !pbHighs || pbHighs == pbP + cbElt * remainderUse )

        shiftP -- ;
    {
    if( shiftP )

    while( idError ) ;
    }
        pbHighs = sp.pbHighs ;
        //swapIF( pbP , cbP ) ;
        rs.recursionSimulatorF( pc2 , 2 ) ;
        countT pc2[] = { (countT)pbP , cbP } ;
        idError = 0 ;

        sp.shift = shiftP ;
    {
    do
    ZE( byteT* , pbHighs ) ;

    }
        }
            countT foo = 2 ;
        {
        if( cEltsBefore == 5 )

        remainderUse = ( remainder - cEltsBefore ) % modulo ;
        countT cEltsBefore = ( pbP - pbArray ) / cbElt ;

        if( ( pbP - pbArray ) % cbElt ) { BLAMMO ; }
    {
    ZE( countT , remainderUse ) ;
{
voidT sortaC::doBitF( byteT* pbP , countT cbP , countT shiftP )

}
    }
        }
            pbc += cbElt * modulo ;
            else                  keyLath = keyMe ;
            if( keyLath > keyMe ) { BLAMMO ; }
            countT keyMe = *(countT*)( pbc + cbPrefix ) & mask ;
        {
        while( pbc < pbe )
        byteT* pbc = pbP + cbElt * remainderUse ;
        ZE( countT , keyLath ) ;
        byteT* pbe = pbP + cbP ;

        countT mask = (countT)( - 1 ) << shiftP ;

        }
            remainderUse = ( remainder - cEltsBefore ) % modulo ;
            countT cEltsBefore = ( pbP - pbArray ) / cbElt ;
    
            if( ( pbP - pbArray ) % cbElt ) { BLAMMO ; }
        {
        ZE( countT , remainderUse ) ;

        // 0x1d     0xe0000000  0b11100000 00000000 ...
        // 0x1e     0xc0000000  0b11000000 00000000 ...
        // 0x1f     0x80000000  0b10000000 00000000 ...
        // shiftP   mask
        //
        //EXAMPLES
    {
    ZE( byteT* , pbUpNew ) ;
    ZE( boolT , bMaskChanged ) ;
{
voidT sortaC::verifySortF( byteT* pbP , countT cbP , const countT shiftP )

}
    ((tinNormalS&)tinBaseP).pEther->delF( tinBaseP , psttd ) ;
    ((tinNormalS&)tinBaseP).pEther->traceF( tinBaseP , T("range is sorted by bit ")+TF3(bit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tIndent+T(psttd) , flTRACE_NOpREFIX ) ;
    ((tinNormalS&)tinBaseP).pEther->strReplaceF( tinBaseP , psttd , 0 , T("\r\n") , T("") ) ;   ___( psttd ) ;
    ((tinNormalS&)tinBaseP).pEther->strReplaceF( tinBaseP , psttd , 0 , T("33333333") , T("<<<<<<<<") ) ;   ___( psttd ) ;
    ((tinNormalS&)tinBaseP).pEther->strReplaceF( tinBaseP , psttd , 0 , T("11111111") , T(">>>>>>>>") ) ;   ___( psttd ) ;
    etherC::strDumpIF( tinBaseP , psttd , pbP , cbP , flSTRdUMP_null , cbElt * cEltRange , cbElt / 3 , 0 , 0 ) ;  ___( psttd ) ;
    ZE( strokeS* , psttd ) ;

    countT bit = 1 << shiftP ;

    textC tIndent( tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "" , 7 + myOff * 2 + ( myOff / cbElt ) * 3 ) ;
    countT cEltRange = cbP / cbElt ;
    countT myOff = pbP - pbArray ;
    TINSL
{
voidT sortaC::traceRangeIsSortedF( byteT* pbP , countT cbP , const countT shiftP )

}
    }
        ((tinNormalS&)tinBaseP).pEther->traceF( tinBaseP , T("        ")+tIndent2+tMark+tIndent3+tMark , flTRACE_NOpREFIX ) ;
        textC tIndent3( tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "" , csttIndentDelta ) ;
        textC tIndent2( tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "" , csttIndent2 ) ;
        countT csttIndentDelta = csttIndent3 - csttIndent2 - ( cbElt << 1 ) - 2 ;
        countT csttIndent3 = myOff3 * 2 + ( myOff3 / cbElt ) * 3 + 0x1e ;
        countT csttIndent2 = myOff2 * 2 + ( myOff2 / cbElt ) * 3 + 0x1e ;
        countT myOff3 = ppbP[ 1 ] - pbArray ;
        countT myOff2 = ppbP[ 0 ] - pbArray ;
        TN( tMark , "" ) ; tMark = TPS("|",(cbElt<<1)+2,'|') ;
    {
    else
    else if( ppbP[ 0 ] >= ppbP[ 1 ] ) { BLAMMO ; }
    else if( cpbP != 2 ) { BLAMMO ; }
    if( !ppbP ) { BLAMMO ; }
    TINSL
{
voidT sortaC::traceMarkSelectedElementsF( byteT** ppbP , countT cpbP )

}
    ((tinNormalS&)tinBaseP).pEther->delF( tinBaseP , psttd ) ;
    ((tinNormalS&)tinBaseP).pEther->traceF( tinBaseP , TP(psttSayP,0xb)+T(" [off,cbP]:    ")+TF3(myOff,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,4)+T("    ")+TF3(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,4)+tIndent+T(psttd) , flTRACE_NOpREFIX ) ;
    ((tinNormalS&)tinBaseP).pEther->strReplaceF( tinBaseP , psttd , 0 , T("\r\n") , T("") ) ;   ___( psttd ) ;
    ((tinNormalS&)tinBaseP).pEther->strReplaceF( tinBaseP , psttd , 0 , T("33333333") , T("<-------") ) ;   ___( psttd ) ;
    ((tinNormalS&)tinBaseP).pEther->strReplaceF( tinBaseP , psttd , 0 , T("11111111") , T("------->") ) ;   ___( psttd ) ;
    etherC::strDumpIF( tinBaseP , psttd , pbP , cbP , flSTRdUMP_null , cbElt * cEltRange , cbElt / 3 , 0 , 0 ) ;  ___( psttd ) ;
    ZE( strokeS* , psttd ) ;
    textC tIndent( tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "" , myOff * 2 + ( myOff / cbElt ) * 3 ) ;
    countT cEltRange = cbP / cbElt ;
    countT myOff = pbP - pbArray ;
    TINSL
{
voidT sortaC::traceRangeF( byteT* pbP , countT cbP , strokeS* psttSayP )

}
    else       { BLAMMO ; }
    if( !pMe ) pMe = this ;
    if( cbArrayP % cbElt ) { BLAMMO ; }
{
rs( 0x11111111 , swapRsPrologF , swapRsCallPrologF , swapRsCallPushF , swapRsCallF , swapRsCallPopF , swapRsCallEpilogF , swapRsEpilogF )
remainder( remainderP                     ) ,
modulo(    moduloP                        ) ,
cElts(     cbArray / cbElt                ) ,
cbElt(     cbPrefixP + cbKeyP + cbSuffixP ) ,
cbKey(     cbKeyP                         ) ,
cbPrefix(  cbPrefixP                      ) ,
cbSuffix(  cbSuffixP                      ) ,
cbArray(   cbArrayP                       ) ,
pbArray(   pbArrayP                       ) ,
sortaC::sortaC( tinBaseS& tinBaseP , etherC& etherP , const boolT& bQuitP , byteT* pbArrayP , countT cbArrayP , countT cbSuffixP , countT cbPrefixP , countT cbKeyP , countT moduloP , countT remainderP ) :

}
    else              { BLAMMO ; }
    if( pMe == this ) pMe = 0 ;
{
sortaC::~sortaC( voidT )

sortaC* sortaC::pMe ;

}
    pMe->sp.pbHighs = pMe->sp.pbHighsTmp ;
    pMe->sp.idNest -- ;

    //}
    //    countT foo = 2 ;
    //{
    //if( idIn == 0x84 )
    //if( offe == 5 && offeh == - 1 )

    //countT offe = ( pbP - pMe->pbArray ) / pMe->cbElt ;

    //((tinNormalS&)tinBaseP).pEther->traceF( tinBaseP , T("swapIF returning [idIn,offEltHighs]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF3(offeh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,4) , flTRACE_NOpREFIX ) ;
    //TINSL
    //countT idIn = 1 + incv02AM( idInLath ) ;
    //static countT idInLath ;
    //;
    //    : ( pMe->sp.pbHighsTmp - pMe->pbArray ) / pMe->cbElt ;
    //    ? - 1
    //countT offeh = !pMe->sp.pbHighsTmp

    }
        }
            pMe->verifySortF( pbP , cbP , pMe->sp.shift ) ;
            //traceRangeIsSortedF( pbP , cbP , pMe->sp.shift ) ;
        {
        if( pMe->sp.idNest == 1 )

        }
            }
                }
                    }
                        }
                            break ;
                            pMe->sp.pbHighsTmp = pMe->sp.pbc ;
                        {
                        if( *(countT*)( pMe->sp.pbc + pMe->cbPrefix ) >> pMe->sp.shift & 1 )
                    {
                    else for( pMe->sp.pbc = pbP ; pMe->sp.pbc < pMe->sp.pbe ; pMe->sp.pbc += pMe->cbElt * pMe->modulo )
                    }
                        }
                            break ;
                            pMe->sp.pbHighsTmp = pMe->sp.pbc ;
                        {
                        if( *(countT*)( pMe->sp.pbc + pMe->cbPrefix ) >> pMe->sp.shift & 1 )
                    {
                    if( pMe->sp.idNest == 1 ) for( pMe->sp.pbc = pbP + pMe->cbElt * pMe->sp.remainderUseRoot ; pMe->sp.pbc < pMe->sp.pbe ; pMe->sp.pbc += pMe->cbElt * pMe->modulo )
                    pMe->sp.pbe = pbP + cbP ;
                {
                else
                if( pMe->sp.pbHighs ) pMe->sp.pbHighsTmp = pMe->sp.pbHighs ;

                }
                    }
                        //****************************************************************************************************************************************************************************************************************** RECURSIVE CALL
                        //****************************************************************************************************************************************************************************************************************** RECURSIVE CALL
                        //****************************************************************************************************************************************************************************************************************** RECURSIVE CALL
                        //****************************************************************************************************************************************************************************************************************** RECURSIVE CALL
                        swapIF( pMe->sp.pbInner , pMe->sp.cbInner ) ;                                                        // RANGE THAT IS ENCLOSED BY THE SWAP THAT I JUST DID
                        //****************************************************************************************************************************************************************************************************************** RECURSIVE CALL
                        //****************************************************************************************************************************************************************************************************************** RECURSIVE CALL
                        //****************************************************************************************************************************************************************************************************************** RECURSIVE CALL
                        //****************************************************************************************************************************************************************************************************************** RECURSIVE CALL
                    {
                    if( pMe->sp.cbInner >= ( pMe->cbElt << 1 ) * pMe->modulo )                                                // IF THE NEW RANGE CONTAINS AT LEAST OO * pMe->modulo ELEMENTS THEN RECURSIVELY CALL MYSELF
                    pMe->sp.cbInner = pMe->sp.pbDn - pMe->sp.pbUp - pMe->cbElt * pMe->modulo ;
                    pMe->sp.pbInner = pMe->sp.pbUp + pMe->cbElt * pMe->modulo ;
                {
                pMe->sp.pbHighs = 0 ;

                pMe->traceRangeF( pbP , cbP , T("after  swap") ) ;
                memcpy(                                 pMe->sp.pbUp , pMe->pbScratch , pMe->cbElt ) ;
                memcpy(                  pMe->sp.pbDn , pMe->sp.pbUp                  , pMe->cbElt ) ;
                memcpy( pMe->pbScratch , pMe->sp.pbDn                                 , pMe->cbElt ) ;            // DO THE SWAP
                }
                    pMe->traceMarkSelectedElementsF( pbUpDn ) ;
                    byteT* pbUpDn[] = { pMe->sp.pbUp , pMe->sp.pbDn } ;
                {
                pMe->traceRangeF( pbP , cbP , T("before swap") ) ;
                TINSL
            {
            else                                                                                            // THE WO'TH HIGH ELEMENT IS BELOW THE LATH LOW ELEMENT, SO SWAP THEM AND THEN CALL MYSELF FOR THE ENCLOSED RANGE
            }
                pMe->sp.pbHighsTmp = pMe->sp.pbUp ;
            {
            else if( pMe->sp.pbUp > pMe->sp.pbDn )                                                                          // ELEMENTS ARE SORTED ON THE FOCUS BIT (ALL OF THE LOWS ARE FOLLOWED BY ALL OF THE HIGHS)
            if( pMe->sp.pbUp == pMe->sp.pbDn ) { BLAMMO ; }                                                                 // SHOULD BE IMPOSSIBLE
        {
        else if( pMe->sp.pbUp && pMe->sp.pbDn )                                                                             // HAVE BOTH LOW AND HIGH ELEMENTS
        }
            pMe->sp.pbHighsTmp = pMe->sp.pbUp ;
            }
                if( pMe->sp.pbUp - pbP                                    ) { BLAMMO ; }
            {
            else
            }
                if( pMe->sp.pbUp - pbP - pMe->cbElt * pMe->sp.remainderUseRoot ) { BLAMMO ; }
            {
            if( pMe->sp.idNest == 1 )
        {
        else if( !pMe->sp.pbDn )                                                                                    // NO LOW  ELEMENTS WERE FOUND (ALL ELEMENTS ARE HIGH)
        else if( !pMe->sp.pbUp )                ;                                                                   // NO HIGH ELEMENTS WERE FOUND (ALL ELEMENTS ARE LOW )
        if( !pMe->sp.pbUp && !pMe->sp.pbDn ) { BLAMMO ; }                                                                   // SHOULD BE IMPOSSIBLE

        }
            }
                }
                    break ;
                    pMe->sp.pbDn = pbP + pMe->sp.sregC ;
                {
                if( !( *(countT*)( pbP + pMe->sp.sregC + pMe->cbPrefix ) >> pMe->sp.shift & 1 ) )
            {
            for( pMe->sp.sregC = pMe->sp.sregA ; pMe->sp.sregC > pMe->sp.sregB ; pMe->sp.sregC -= pMe->cbElt * pMe->modulo )      // ACCEPT THIS ELEMENT AS AN "DOWN CANDIDATE" SINCE THE FOCUS BIT IS NOT SET

            //;
            //    : - 1
            //    ? - 1 + pMe->sp.remainderUseRoot
            //pMe->sp.sregB = pMe->sp.idNest == 1

            else                 pMe->sp.sregB = - 1                       ;
            if( pMe->sp.idNest == 1 ) pMe->sp.sregB = - 1 + pMe->sp.remainderUseRoot ;

            pMe->sp.sregA = pMe->sp.regA ;

            }
                else                                                           pMe->sp.regA -= pMe->cbElt ;
                if(                        !( ( pMe->sp.regA / pMe->cbElt ) % pMe->modulo ) ) break            ;
            {
            else for(;;)                                                                                    //U::O: USE A FORMULA RATHER THAN ITERATIVE SEARCH
            }
                else                                                           pMe->sp.regA -= pMe->cbElt ;
                if( pMe->sp.remainderUseRoot ==    ( pMe->sp.regA / pMe->cbElt ) % pMe->modulo   ) break            ;
            {
            if( pMe->sp.idNest == 1 ) for(;;)                                                               //U::O: USE A FORMULA RATHER THAN ITERATIVE SEARCH
            pMe->sp.regA = cbP - pMe->cbElt ;

            }
                }
                    break ;
                    pMe->sp.pbUp = pbP + pMe->sp.regC ;
                {
                if( *(countT*)( pbP + pMe->sp.regC + pMe->cbPrefix ) >> pMe->sp.shift & 1 )
            {
            for( pMe->sp.regC = pMe->sp.regA ; pMe->sp.regC < pMe->sp.regB ; pMe->sp.regC += pMe->cbElt * pMe->modulo )
            pMe->sp.regB = cbP ;

            //;
            //    : 0
            //    ? pMe->sp.remainderUseRoot * pMe->cbElt
            //pMe->sp.regA = pMe->sp.idNest == 1

            else                 pMe->sp.regA = 0 ;
            if( pMe->sp.idNest == 1 ) pMe->sp.regA = pMe->sp.remainderUseRoot * pMe->cbElt ;
        {
        pMe->sp.pbDn = 0 ;                                                                       // SET pMe->sp.pbDn TO THE LATH LOW ELEMENT   (ELEMENT WITH FOCUS BIT NOT SET)
        pMe->sp.pbUp = 0 ;                                                                       // SET pMe->sp.pbUp TO THE WOTH HIGH ELEMENT  (ELEMENT WITH FOCUS BIT     SET)
    {
    pMe->sp.pbHighsTmp = 0 ;

    }
        pMe->sp.remainderUseRoot = ( pMe->remainder - pMe->sp.regA ) % pMe->modulo ;
        pMe->sp.regA = ( pbP - pMe->pbArray ) / pMe->cbElt ;

        if( ( pbP - pMe->pbArray ) % pMe->cbElt ) { BLAMMO ; }
    {
    if( !( pMe->sp.idNest ++ ) )
    if( !pbP || !cbP ) { BLAMMO ; }
{
voidT sortaC::swapIF( byteT* const pbP , const countT cbP )             // THIS IS RETAINED FOR TESTING ; CALLING THE RECURSION SIMULATOR SHOULD PRODUCE THE SAME RESULT AS CALLING ME

}
    return rc ;

    pMe->sp.pbHighs = pMe->sp.pbHighsTmp ;
    pMe->sp.idNest -- ;

    //}
    //    countT foo = 2 ;
    //{
    //if( idIn == 0x84 )
    //if( offe == 5 && offeh == - 1 )

    //countT offe = ( pbP - pMe->pbArray ) / pMe->cbElt ;

    //((tinNormalS&)tinBaseP).pEther->traceF( tinBaseP , T("swapIF returning [idIn,offEltHighs]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF3(offeh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,4) , flTRACE_NOpREFIX ) ;
    //TINSL
    //countT idIn = 1 + incv02AM( idInLath ) ;
    //static countT idInLath ;
    //;
    //    : ( pMe->sp.pbHighsTmp - pMe->pbArray ) / pMe->cbElt ;
    //    ? - 1
    //countT offeh = !pMe->sp.pbHighsTmp

    }
        rc = ifcIDtYPEsTEPrECURSION_DONE ;
        pMe->verifySortF( pbP , cbP , pMe->sp.shift ) ;
        //traceRangeIsSortedF( pbP , cbP , pMe->sp.shift ) ;
    {
    if( pMe->sp.idNest == 1 )

    countT rc = ifcIDtYPEsTEPrECURSION_CALLePILOG ;
    TRACEpARAMS( "swapRsEpilogF" )
{
countT sortaC::swapRsEpilogF( recursionSimulatorC& rsP )

}
    return rc ;

    }
        }
            }
                break ;
                pMe->sp.pbHighsTmp = pMe->sp.pbc ;
            {
            if( *(countT*)( pMe->sp.pbc + pMe->cbPrefix ) >> pMe->sp.shift & 1 )
        {
        else for( pMe->sp.pbc = pbP ; pMe->sp.pbc < pMe->sp.pbe ; pMe->sp.pbc += pMe->cbElt * pMe->modulo )
        }
            }
                break ;
                pMe->sp.pbHighsTmp = pMe->sp.pbc ;
            {
            if( *(countT*)( pMe->sp.pbc + pMe->cbPrefix ) >> pMe->sp.shift & 1 )
        {
        if( pMe->sp.idNest == 1 ) for( pMe->sp.pbc = pbP + pMe->cbElt * pMe->sp.remainderUseRoot ; pMe->sp.pbc < pMe->sp.pbe ; pMe->sp.pbc += pMe->cbElt * pMe->modulo )
        pMe->sp.pbe = pbP + cbP ;
    {
    else
    if( pMe->sp.pbHighs ) pMe->sp.pbHighsTmp = pMe->sp.pbHighs ;

    rsP.prsStack[ -- rsP.oprStack ] = 0 ;
    rsP.prsStack[ -- rsP.oprStack ] = 0 ;

    countT rc = ifcIDtYPEsTEPrECURSION_EPILOG ;
    TRACEpARAMS( "swapRsCallEpilogF" )
{
countT sortaC::swapRsCallEpilogF( recursionSimulatorC& rsP )

}
    return rc ;

    countT rc = ifcIDtYPEsTEPrECURSION_CALLePILOG ;
    TRACEpARAMS( "swapRsCallPopF" )
{
countT sortaC::swapRsCallPopF( recursionSimulatorC& rsP )

}
    return rc ;
    countT rc = ifcIDtYPEsTEPrECURSION_PROLOG ;
    TRACEpARAMS( "swapRsCallF" )
{
countT sortaC::swapRsCallF( recursionSimulatorC& rsP )

}
    return rc ;

    countT rc = ifcIDtYPEsTEPrECURSION_CALL ;
    TRACEpARAMS( "swapRsCallPushF" )
{
countT sortaC::swapRsCallPushF( recursionSimulatorC& rsP )

}
    return rc ;

    }
        }
            rsP.prsStack[ rsP.oprStack ++ ] = - 1 ;
            rsP.prsStack[ rsP.oprStack ++ ] = - 1 ;
        {
        else
        }
            rc = ifcIDtYPEsTEPrECURSION_CALL ;
            rsP.prsStack[ rsP.oprStack ++ ] =         pMe->sp.cbInner ;
            rsP.prsStack[ rsP.oprStack ++ ] = (countT)pMe->sp.pbInner ;
        {
        if( pMe->sp.cbInner >= ( pMe->cbElt << 1 ) * pMe->modulo )                                                          // IF THE NEW RANGE CONTAINS AT LEAST OO * pMe->modulo ELEMENTS THEN RECURSIVELY CALL MYSELF
        pMe->sp.cbInner = pMe->sp.pbDn - pMe->sp.pbUp - pMe->cbElt * pMe->modulo ;
        pMe->sp.pbInner = pMe->sp.pbUp + pMe->cbElt * pMe->modulo ;
    {
    pMe->sp.pbHighs = 0 ;

    pMe->traceRangeF( pbP , cbP , T("after  swap") ) ;
    memcpy(                                 pMe->sp.pbUp , pMe->pbScratch , pMe->cbElt ) ;
    memcpy(                  pMe->sp.pbDn , pMe->sp.pbUp                  , pMe->cbElt ) ;
    memcpy( pMe->pbScratch , pMe->sp.pbDn                                 , pMe->cbElt ) ;            // DO THE SWAP
    }
        pMe->traceMarkSelectedElementsF( pbUpDn ) ;
        byteT* pbUpDn[] = { pMe->sp.pbUp , pMe->sp.pbDn } ;
    {
    pMe->traceRangeF( pbP , cbP , T("before swap") ) ;
    TINSL

    countT rc = ifcIDtYPEsTEPrECURSION_CALLePILOG ;
    TRACEpARAMS( "swapRsCallPrologF" )
{
countT sortaC::swapRsCallPrologF( recursionSimulatorC& rsP )

}
    return rc ;

    }
        }
            }
                rc = ifcIDtYPEsTEPrECURSION_CALLpROLOG ;
            {
            else                                                                                                            // THE WO'TH HIGH ELEMENT IS BELOW THE LATH LOW ELEMENT, SO SWAP THEM AND THEN CALL MYSELF FOR THE ENCLOSED RANGE
            }
                pMe->sp.pbHighsTmp = pMe->sp.pbUp ;
            {
            else if( pMe->sp.pbUp > pMe->sp.pbDn )                                                                          // ELEMENTS ARE SORTED ON THE FOCUS BIT (ALL OF THE LOWS ARE FOLLOWED BY ALL OF THE HIGHS)
            if( pMe->sp.pbUp == pMe->sp.pbDn ) { BLAMMO ; }                                                                 // SHOULD BE IMPOSSIBLE
        {
        else if( pMe->sp.pbUp && pMe->sp.pbDn )                                                                             // HAVE BOTH LOW AND HIGH ELEMENTS
        }
            pMe->sp.pbHighsTmp = pMe->sp.pbUp ;
            }
                if( pMe->sp.pbUp - pbP                                         ) { BLAMMO ; }
            {
            else
            }
                if( pMe->sp.pbUp - pbP - pMe->cbElt * pMe->sp.remainderUseRoot ) { BLAMMO ; }
            {
            if( pMe->sp.idNest == 1 )
        {
        else if( !pMe->sp.pbDn )                                                                                    // NO LOW  ELEMENTS WERE FOUND (ALL ELEMENTS ARE HIGH)
        else if( !pMe->sp.pbUp )                ;                                                                   // NO HIGH ELEMENTS WERE FOUND (ALL ELEMENTS ARE LOW )
        if( !pMe->sp.pbUp && !pMe->sp.pbDn ) { BLAMMO ; }                                                                   // SHOULD BE IMPOSSIBLE

        }
            }
                }
                    break ;
                    pMe->sp.pbDn = pbP + pMe->sp.sregC ;
                {
                if( !( *(countT*)( pbP + pMe->sp.sregC + pMe->cbPrefix ) >> pMe->sp.shift & 1 ) )
            {
            for( pMe->sp.sregC = pMe->sp.sregA ; pMe->sp.sregC > pMe->sp.sregB ; pMe->sp.sregC -= pMe->cbElt * pMe->modulo )      // ACCEPT THIS ELEMENT AS AN "DOWN CANDIDATE" SINCE THE FOCUS BIT IS NOT SET

            //;
            //    : - 1
            //    ? - 1 + pMe->sp.remainderUseRoot
            //pMe->sp.sregB = pMe->sp.idNest == 1

            else                 pMe->sp.sregB = - 1                       ;
            if( pMe->sp.idNest == 1 ) pMe->sp.sregB = - 1 + pMe->sp.remainderUseRoot ;

            pMe->sp.sregA = pMe->sp.regA ;

            }
                else                                                           pMe->sp.regA -= pMe->cbElt ;
                if(                        !( ( pMe->sp.regA / pMe->cbElt ) % pMe->modulo ) ) break            ;
            {
            else for(;;)                                                                                    //U::O: USE A FORMULA RATHER THAN ITERATIVE SEARCH
            }
                else                                                           pMe->sp.regA -= pMe->cbElt ;
                if( pMe->sp.remainderUseRoot ==    ( pMe->sp.regA / pMe->cbElt ) % pMe->modulo   ) break            ;
            {
            if( pMe->sp.idNest == 1 ) for(;;)                                                               //U::O: USE A FORMULA RATHER THAN ITERATIVE SEARCH
            pMe->sp.regA = cbP - pMe->cbElt ;

            }
                }
                    break ;
                    pMe->sp.pbUp = pbP + pMe->sp.regC ;
                {
                if( *(countT*)( pbP + pMe->sp.regC + pMe->cbPrefix ) >> pMe->sp.shift & 1 )
            {
            for( pMe->sp.regC = pMe->sp.regA ; pMe->sp.regC < pMe->sp.regB ; pMe->sp.regC += pMe->cbElt * pMe->modulo )
            pMe->sp.regB = cbP ;

            //;
            //    : 0
            //    ? pMe->sp.remainderUseRoot * pMe->cbElt
            //pMe->sp.regA = pMe->sp.idNest == 1

            else                 pMe->sp.regA = 0 ;
            if( pMe->sp.idNest == 1 ) pMe->sp.regA = pMe->sp.remainderUseRoot * pMe->cbElt ;
        {
        pMe->sp.pbDn = 0 ;                                                                       // SET pMe->sp.pbDn TO THE LATH LOW ELEMENT   (ELEMENT WITH FOCUS BIT NOT SET)
        pMe->sp.pbUp = 0 ;                                                                       // SET pMe->sp.pbUp TO THE WOTH HIGH ELEMENT  (ELEMENT WITH FOCUS BIT     SET)
    {
    pMe->sp.pbHighsTmp = 0 ;

    }
        pMe->sp.remainderUseRoot = ( pMe->remainder - pMe->sp.regA ) % pMe->modulo ;
        pMe->sp.regA = ( pbP - pMe->pbArray ) / pMe->cbElt ;

        if( ( pbP - pMe->pbArray ) % pMe->cbElt ) { BLAMMO ; }
    {
    if( !( pMe->sp.idNest ++ ) )
    if( !pbP || !cbP ) { BLAMMO ; }

    countT rc = ifcIDtYPEsTEPrECURSION_EPILOG ;
    TRACEpARAMS( "swapRsPrologF" )
{
countT sortaC::swapRsPrologF( recursionSimulatorC& rsP )

;
}
    voidT  traceRangeF( byteT* pbP , countT cbP , strokeS* psttSayP ) ;
    voidT  sortF( tinBaseS& tinBaseP ) ;
    sortaC( tinBaseS& tinBaseP , etherC& etherP , const boolT& bQuitP , byteT* pbArrayP , countT cbArrayP , countT cbSuffixP , countT cbPrefixP , countT cbKeyP , countT moduloP = 1 , countT remainderP = 0 ) ;
    ~sortaC( voidT ) ;

    public :

    voidT           verifySortF( byteT* pbP , countT cbP , const countT shiftP ) ;
    voidT           traceRangeIsSortedF( byteT* pbP , countT cbP , const countT shiftP ) ;
    voidT           traceMarkSelectedElementsF( byteT** ppbP , countT cpbP = 2 ) ;
    static voidT    swapIF( byteT* const pbP , const countT cbP ) ;
    voidT           doBitF( byteT* pbP , countT cbP , countT shiftP ) ;

    static countT swapRsEpilogF(       recursionSimulatorC& rsP ) ;
    static countT swapRsCallEpilogF(   recursionSimulatorC& rsP ) ;
    static countT swapRsCallPopF(      recursionSimulatorC& rsP ) ;
    static countT swapRsCallF(         recursionSimulatorC& rsP ) ;
    static countT swapRsCallPushF(     recursionSimulatorC& rsP ) ;
    static countT swapRsCallPrologF(   recursionSimulatorC& rsP ) ;
    static countT swapRsPrologF(       recursionSimulatorC& rsP ) ;

    recursionSimulatorC rs                  ;
    swapPadS            sp                  ;
    byteT               pbScratch[ TUCK ]   ;

    countT              idError             ;
    const countT        remainder           ;
    const countT        modulo              ;
    const countT        cElts               ;
    const countT        cbElt               ;
    const countT        cbKey               ;
    const countT        cbPrefix            ;    
    const countT        cbSuffix            ;    
    const countT        cbArray             ;
    byteT* const        pbArray             ;
    static sortaC*      pMe                 ;

    ;
    }
        inline swapPadS( voidT ) : shift( 0 ) , idNest( 0 ) , pbHighs( 0 ) , remainderUseRoot( 0 ) {}

        byteT*  pbHighsTmp          ;
        countT  cbInner             ;
        byteT*  pbInner             ;
        byteT*  pbDn                ;
        byteT*  pbUp                ;
        byteT*  pbe                 ;
        byteT*  pbc                 ;
        sCountT sregH               ;
        sCountT sregG               ;
        sCountT sregF               ;
        sCountT sregE               ;
        sCountT sregD               ;
        sCountT sregC               ;
        sCountT sregB               ;
        sCountT sregA               ;
        countT  regH                ;
        countT  regG                ;
        countT  regF                ;
        countT  regE                ;
        countT  regD                ;
        countT  regC                ;
        countT  regB                ;
        countT  regA                ;
        // REGISTERS: LOCAL VARIABLES NOT PRESERVED ACROSS THE RECURSIVE CALL ; INTENTIONALLY NOT INITIALIZED BECAUSE CODE MUST INITIALIZE BEFORE USE

        countT remainderUseRoot ;   // swapIF LOCAL VARIABLE USED ONLY WHEN idNest == 1
        byteT* pbHighs ;            // swapIF RETURN VALUE
        countT idNest ;             // swapIF PARAMETER
        countT shift ;              // swapIF PARAMETER
    {
    struct swapPadS
{
class sortaC

    }
        ((tinNormalS&)tinBaseP).pEther->traceF( tinBaseP , psttSay ) ;                                                                     \
        strokeS* psttSay = tSay ;                                                                                   \
        tSay = tSay1 + tSay2 + tb4 + tSay3 ;                                                                        \
        TN( tSay , "" ) ;                                                                                           \
        tSay3 = TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;                                                 \
        TN( tSay3 , "" ) ;                                                                                          \
        tSay2 = TF3((countT)pbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8) ;      \
        TN( tSay2 , "" ) ;                                                                                          \
        TN( tSay1 , postFunctionP ## " [pbP,cbP]:    " ) ;                                                          \
        TN( tb4 , "    " ) ;                                                                                        \
        cbP =         rsP.prsStack[ rsP.oprStack - 1 ] ;                                                            \
        pbP = (byteT*)rsP.prsStack[ rsP.oprStack - 2 ] ;                                                            \
        TINSL                                                                                                       \
    {                                                                                                               \
    ZE( countT , cbP ) ;                                                                                            \
    ZE( byteT* , pbP ) ;                                                                                            \
                                                                                                                    \
#define TRACEpARAMS(postFunctionP)                                                                                  \

#define IDeRROR_STACKeXHAUSTED    0x1

/*1*/WAKEsHOW( "dut.sortaC" )/*1*/
/**/
*/
 this snapshot works but deep nesting of swapIF is not yet eliminated
the essence of the design concept is that if sorting and bisection on the focus bit is done correctly, the higher bits will all be identical within each range
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
