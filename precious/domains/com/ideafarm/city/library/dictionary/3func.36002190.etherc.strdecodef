
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cbUsed ;

    }
        }
            }
                etherC::etRockIF( tin0P ).traceF( tin0P , T("strDecodeF / detected impotence") ) ;
                POOPRqUIET
            {
            if( POOP )

            __( bFail ) ;

            }
                }
                    bFail = 1 ;
                    etherC::etRockIF( tin0P ).traceF( tin0P , T("strDecodeF / caught an exception") ) ;
                {
                else
                }
                    TELL( "U:: 0" ) ;
                    }
                        TELL( "U:: 1" ) ;
                        //}
                        //    delF( tin0P , psttdStrokes ) ;
                        //    LOGrAW( td ) ;
                        //    TN( td , "" ) ; td = T("  to strokes: ")+T(psttdStrokes)+T("\r\n") ;
                        //    strDumpIF( tin0P , psttdStrokes , (byteT*)psttP , ( CSpREFIX + psttP->idAdam ) * sizeof( strokeS ) ) ; ___( psttdStrokes ) ;
                        //    ZE( strokeS* , psttdStrokes ) ;
                        //{
                        //if( ((tin1S&)tin0P).pc Utility[ 0 ] )
                        //COMMENT OUT IN PRODUCTION
                        
                        //}
                        //    delF( tin0P , psttdCodes ) ;
                        //    LOGrAW( td ) ;
                        //    TN( td , "" ) ; td = T("\r\nfrom codes  : ")+T(psttdCodes)+T("\r\n") ;
                        //    strDumpIF( tin0P , psttdCodes , pbP , ((countT*)pbP)[ 1 ] + 2 * sizeof( countT ) ) ; ___( psttdCodes ) ;
                        //    ZE( strokeS* , psttdCodes ) ;
                        //{
                        //if( ((tin1S&)tin0P).pc Utility[ 0 ] )
                        //COMMENT OUT IN PRODUCTION

                        //CONoUTrAW( T("decoded  \"")+T(psttP)+T("\"\r\n") ) ; //TO FIND SLOWNESS
                        TELL( "U:: 2" ) ;

                        }
                            TELL( "U:: 3" ) ;
                            }
                                }
                                    }
                                        cToDo -= csImage ;
                                        offo  += csImage ;
                                        offbi += cbImage * SB ;
                                        thirdC::c_memcpyIF( tin0P , (byteT*)&psttP[ offo ] , pbP + offbi / SB , cbImage ) ;
                                        countT cbImage = csImage * sizeof( strokeS ) ;
                                        countT csImage = psttP[ offo - 1 ].idAdam ;

                                        valueInF( pbP , offbi , ( SB - offbi ) % SB ) ;
                                        _IO_
                                    {
                                    if( psttP[ offo - 1 ].idCaste == sc_cADAMeXPORT )
                                    getStrokeS( psttP[ offo ++ ] , pbP , offbi ) ;
                                    countT offbisave = offbi ;
                                    _IO_
                                {
                                while( cToDo -- )
                                countT cToDo = psttP->idAdam ;

                                while( cToDoPrefix -- ) getStrokeS( psttP[ offo ++ ] , pbP , offbi ) ;
                                countT cToDoPrefix = CSpREFIX - 1 ;
                                psttP[ offo ++ ] = stt1 ;
                                ZE( countT , offo ) ;
                                _IO_
                            {
                            if( psttP )
                            newF( tin0P , LF , psttP , CSpREFIX + stt1.idAdam ) ; // CALLER MUST TAG ___( psttP ) ;
                            _IO_
                            TELL( "U:: 4" ) ;
                        {
                        if( !POOP)

                        TELL( "U:: 5" ) ;
                        __( stt1.idCaste - sc_PREFIXlENGTH ) ;
                        TELL( "U:: 6" ) ;
                        }
                            TELL( "U:: 7" ) ;
                            getStrokeS( stt1 , pbP , offbi ) ;
                            _IO_
                            TELL( "U:: 8" ) ;
                        {
                        strokeS stt1 ;
                        //WOTH STROKE

                        }
                            TELL( "U:: 9" ) ;
                            //__( cbActual != cbClaimed && cbActual - 1 != cbClaimed && cbActual + 1 != cbClaimed ) ; //soulC APPENDS NULL TERMINATOR AS A COURTESY; I REQUIRE THAT LENGTHS DIFFER BY NO MORE THAN 1 BYTE
                            //countT cbClaimed = cbPrefix + 2 * sizeof( countT ) ;
                            //countT cbActual = ((tin1S&)tin0P).pDropNoteNewest->cbUsedReally ;
                            //COMMENTED OUT SO pbP CAN BE WITHIN A LARGE AGGREGATE OF ENCODINGS
                            cbUsed = cbPrefix + 2 * sizeof( countT ) ;
                            const countT cbPrefix = valueInF( pbP , offbi , sizeof( countT ) * SB ) ;

                            __( finger != FINGERnEG_STReNCODEf && finger != FINGERnEGoLD_strEncodeF ) ;
                            countT finger = valueInF( pbP , offbi , sizeof( countT ) * SB ) ;
                            _IO_
                            TELL( "U:: a" ) ;
                        {
                        TELL( "U:: b" ) ;
                        _IO_
                        TELL( "U:: c" ) ;
                    {
                    TELL( "U:: d" ) ;
                {
                if( !_restart )
                _restart.flags |= flRESTARTc_QUIET ;
                RESTART
            {
            ZE( boolT , bFail ) ;

            SCOOPS
        {
        IFsCRATCHoK
        _IO_
    {
    ZE( countT , offbi ) ; //BIT OFFSET OF NEXT READ
    ZE( countT , cbUsed ) ;

    }
        TELL( "U:: e" ) ;
        if( POOP ) return 0 ;
        __( !((countT*)pbP)[ 1 ] ) ;
        __( ((countT*)pbP)[ 0 ] != FINGERnEG_STReNCODEf && ((countT*)pbP)[ 0 ] != FINGERnEGoLD_strEncodeF ) ;
        if( POOP ) return 0 ;
        }
            __( pbP ) ;
        {
        if( (countT)pbP & BM_HIGH )
        __Z( pbP ) ;
        __NZ( psttP ) ;
        if( POOP ) return 0 ;
        _IO_
        TELL( "U:: f" ) ;
    {
    IFbEcAREFUL
    _IO_
{
/*1*/countT etherC::strDecodeF( tin0S& tin0P , strokeS*& psttP , const byteT* const pbP )/*1*/

/**/
*/
i evaluate to the length of the encoding at pbP
i decompress a prefixed stroke string
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

