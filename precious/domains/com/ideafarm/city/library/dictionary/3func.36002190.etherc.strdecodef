
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cbUsed ;

    }
        }
            }
                etherC::etRockIF( tin0P ).traceF( tin0P , T("strDecodeF / detected impotence") ) ;
                POOPRqUIET
            {
            if( POOP )

            __( bFail ) ;

            }
                }
                    bFail = 1 ;
                    etherC::etRockIF( tin0P ).traceF( tin0P , T("strDecodeF / caught an exception") ) ;
                    _IO_
                {
                else
                }
                    TELL( "U:: 0" ) ;
                    }
                        }
                            TELL( "U:: 1" ) ;
                            //}
                            //    delF( tin0P , psttdStrokes ) ;
                            //    LOGrAW( td ) ;
                            //    TN( td , "" ) ; td = T("  to strokes: ")+T(psttdStrokes)+T("\r\n") ;
                            //    strDumpIF( tin0P , psttdStrokes , (byteT*)psttP , ( CSpREFIX + psttP->idAdam ) * sizeof( strokeS ) ) ; ___( psttdStrokes ) ;
                            //    ZE( strokeS* , psttdStrokes ) ;
                            //{
                            //if( ((tin1S&)tin0P).pc Utility[ 0 ] )
                            //COMMENT OUT IN PRODUCTION
                            
                            //}
                            //    delF( tin0P , psttdCodes ) ;
                            //    LOGrAW( td ) ;
                            //    TN( td , "" ) ; td = T("\r\nfrom codes  : ")+T(psttdCodes)+T("\r\n") ;
                            //    strDumpIF( tin0P , psttdCodes , pbP , ((countT*)pbP)[ 1 ] + 2 * sizeof( countT ) ) ; ___( psttdCodes ) ;
                            //    ZE( strokeS* , psttdCodes ) ;
                            //{
                            //if( ((tin1S&)tin0P).pc Utility[ 0 ] )
                            //COMMENT OUT IN PRODUCTION

                            //CONoUTrAW( T("decoded  \"")+T(psttP)+T("\"\r\n") ) ; //TO FIND SLOWNESS
                            TELL( "U:: 2" ) ;
                        {
                        if( !POOP)

                        }
                            TELL( "U:: 3" ) ;
                            }
                                }
                                    }
                                        cToDo -= csImage ;
                                        offo  += csImage ;
                                        offbi += cbImage * SB ;
                                        thirdC::c_memcpyIF( tin0P , (byteT*)&psttP[ offo ] , pbP + offbi / SB , cbImage ) ;
                                        countT cbImage = csImage * sizeof( strokeS ) ;
                                        countT csImage = psttP[ offo - 1 ].idAdam ;

                                        valueInF( pbP , offbi , ( SB - offbi ) % SB ) ;
                                        _IO_
                                    {
                                    if( !POOP && psttP[ offo - 1 ].idCaste == sc_cADAMeXPORT )
                                    getStrokeGF( psttP[ offo ++ ] , pbP , offbi ) ;
                                    countT offbisave = offbi ;
                                    _IO_
                                {
                                while( !POOP && cToDo -- )
                                countT cToDo = psttP->idAdam ;

                                while( !POOP && cToDoPrefix -- ) getStrokeGF( psttP[ offo ++ ] , pbP , offbi ) ;
                                countT cToDoPrefix = CSpREFIX - 1 ;
                                psttP[ offo ++ ] = stt1 ;
                                ZE( countT , offo ) ;
                                _IO_
                            {
                            if( psttP )
                            newF( tin0P , LF , psttP , CSpREFIX + stt1.idAdam ) ; // CALLER MUST TAG ___( psttP ) ;
                            _IO_
                            TELL( "U:: 4" ) ;
                        {
                        if( !POOP)

                        TELL( "U:: 5" ) ;
                        __( stt1.idCaste - sc_PREFIXlENGTH ) ;
                        TELL( "U:: 6" ) ;
                        }
                            TELL( "U:: 7" ) ;
                            getStrokeGF( stt1 , pbP , offbi ) ;
                            _IO_
                            TELL( "U:: 8" ) ;
                        {
                        strokeS stt1 ;
                        //WOTH STROKE

                        }
                            TELL( "U:: 9" ) ;
                            //__( cbActual != cbClaimed && cbActual - 1 != cbClaimed && cbActual + 1 != cbClaimed ) ; //soulC APPENDS NULL TERMINATOR AS A COURTESY; I REQUIRE THAT LENGTHS DIFFER BY NO MORE THAN 1 BYTE
                            //countT cbClaimed = cbPrefix + 2 * sizeof( countT ) ;
                            //countT cbActual = ((tin1S&)tin0P).pDropNoteNewest->cbUsedReally ;
                            //COMMENTED OUT SO pbP CAN BE WITHIN A LARGE AGGREGATE OF ENCODINGS
                            cbUsed = cbPrefix + 2 * sizeof( countT ) ;
                            const countT cbPrefix = valueInF( pbP , offbi , sizeof( countT ) * SB ) ;

                            __( finger != FINGERnEG_STReNCODEf && finger != FINGERnEGoLD_strEncodeF ) ;
                            countT finger = valueInF( pbP , offbi , sizeof( countT ) * SB ) ;
                            _IO_
                            TELL( "U:: a" ) ;
                        {
                        TELL( "U:: b" ) ;
                        _IO_
                        TELL( "U:: c" ) ;
                    {
                    TELL( "U:: d" ) ;
                {
                if( !_restart )
                _restart.flags |= flRESTARTc_QUIET ;
                RESTART
                _IO_
            {
            ZE( boolT , bFail ) ;

            //SCOOPS
            _IO_
        {
        //IFsCRATCHoK
        //20250427@1602: COMMENTED OUT IFsCRATCHoK AND SCOOPS BECAUSE I APPARENTLY DON'T CONTAIN ANY CODE THAT USES pEtScratch
        _IO_
    {
    ZE( countT , offbi ) ; //BIT OFFSET OF NEXT READ
    ZE( countT , cbUsed ) ;

    }
        TELL( "U:: e" ) ;
        if( POOP ) return 0 ;
        __( !((countT*)pbP)[ 1 ] ) ;
        __( ((countT*)pbP)[ 0 ] != FINGERnEG_STReNCODEf && ((countT*)pbP)[ 0 ] != FINGERnEGoLD_strEncodeF ) ;
        if( POOP ) return 0 ;
        }
            __( pbP ) ;
        {
        if( (countT)pbP & BM_HIGH )
        __Z( pbP ) ;
        __NZ( psttP ) ;
        if( POOP ) return 0 ;
        _IO_
        TELL( "U:: f" ) ;
    {
    IFbEcAREFUL
    _IO_
{
/*1*/countT etherC::strDecodeF( tin0S& tin0P , strokeS*& psttP , const byteT* const pbP )/*1*/

//  MOTIVATION: TRASHING OF sexC DELIMITER BYTES WAS OBSERVED AFTER CALLING ME
//U:: DON'T RELY ON RESTART ; PREVENT WRITES TO UNAUTHORIZED MEMORY EVEN IF THAT MEMORY IS WRITEABLE BY THE CALLING PROCESS

//20250611@1203: getStrokeGF CAN NOW CAUSE IMPOTENCE, SO NOW I TEST FOR THAT

/**/
*/
i evaluate to the length of the encoding at pbP
i decompress a prefixed stroke string
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

