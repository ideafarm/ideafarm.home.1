
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

THREADmODE2rESTORE
THREADmODE3rESTORE
THREADmODE4rESTORE

}
    }
        }
            ++ s ; ether.osSleepF( tinP , TOCK << 3 ) ;
            etThread.traceF( tinP , T("napping with record grabbed") ) ;                                                                            // THIS IS BAD CODING STYLE AND IS DONE HERE ONLY TO DEMONSTRATE THE EFFECT OF FAILING TO IMMEDIATELY DESTROY A recordC INSTANCE
        {
        if( idCell == 2 )

        }
            }
                ++ s ; ether.osSleepF( tinP , TOCK << 3 ) ;
                etThread.traceF( tinP , T("napping with field references retained") ) ;
            {
            if( idCell == 2 )

            etThread.traceF( tinP , T("[" /*"idPass,"*/ "*pc1,*pc2" /*",flagsRC1,flagsRC2"*/ "]:    ")/*+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4*/+TF3(*pc1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF3(*pc2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)/*+tb4+TF3(flagsRC1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF3(flagsRC2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)*/ ) ;

            }
                if( cbWas == setIfEqualsAM( *pc2 , cbNow , cbWas ) ) break ;
                countT cbNow = cbWas + delta2 ;
                countT cbWas = *pc2 ;
            {
            for(;;)
            //DO THIS ATOMICALLY: *pc2 += delta2 ;

            }
                if( cbWas == setIfEqualsAM( *pc1 , cbNow , cbWas ) ) break ;
                countT cbNow = cbWas + delta1 ;
                countT cbWas = *pc1 ;
            {
            for(;;)
            //DO THIS ATOMICALLY: *pc1 += delta1 ;

            countT*  pc2 = vsp2Lath ;
            countT*  pc1 = vsp1Lath ;

            countVSP vsp2Lath = listC::countIF( tinP , myRecord , count2S( LISTnAME_RETURNiNFO2 ) ) ;                                               // THIS OBTAINS SHARED READ/WRITE ACCESS TO ANOTHER FIELD (A LISTING) THAT CAN BE USED UNTIL THE countVSP INSTANCE IS DESTROYED
            countVSP vsp1Lath = listC::countIF( tinP , myRecord , count2S( LISTnAME_RETURNiNFO1 ) ) ;                                               // THIS OBTAINS SHARED READ/WRITE ACCESS TO A       FIELD (A LISTING) THAT CAN BE USED UNTIL THE countVSP INSTANCE IS DESTROYED
        {

        recordC myRecord( tinP , pcNameRecord , flLISToPEN_null , ifcIDgRABlAYER_7BASEmISC1 ) ;                                                                                                   // THIS OPENS THE SPECIFIED RECORD, WHICH IS JUST A LIST
        countT  pcNameRecord[] = { LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION , LISTnAME_GLOBALrECORD , LISTnAME_PROCESSoUTCOME , 0 } ;               // THIS CAN BE ANY VALID LIST NAME

        //tinP.pc Utility[ 0 ] -- ;
        puseC   puseHT( tinP , ifcIDpOOL_HOMEtEMP ) ;                                                                                               // THIS poolC INSTANCE USES BACKING MEMORY THAT IS SHARED BY ALL PROCESSES IN THIS IPDOS (TM) HOME
        //tinP.pc Utility[ 0 ] ++ ;

        _IO_
    {
    //for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
{
while( !ether )
sleepC s( tinP , TAG( TAGiDnULL ) ) ;

const countT delta2 = idCell % 2 ? 1 : - 1 ;
const countT delta1 = idCell % 2 ? 1 : - 1 ;

THREADmODE4oN( flTHREADmODE4_ALLOWwRITEABLEpOINTERgET )
THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY       )
THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING   )

etThread.traceF( tinP , T("[idCell]:  ")+TF2(idCell,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
const countT idCell = tinP.pag1->idCell ;
TN( tb4 , "    " ) ;

TODO

/*1*/WAKEsHOWtEXT( "example.simplest.interprocess.communication.using.listC" )/*1*/
/**/
*/
   this is because the oo'th instance of me naps for fo tocks before destroying its countVSP instances
  note that both windows are now tracing very slowly
  now hire an oo'th instance of me, and resize and move the new window so that you can see both windows
  using IdeaFarm (tm) Elves, hire me, and observe the speed of the tracing output
 instructions
 communication is duplex and coherent and can involve complexity ranging from communicating a single volatile countT value to communicating and cooperatively modifying an entire database
 i demonstrate how a built in poolC instance that is visible to all adams of a home can be used to communicate a countT value between processes
 the listC class provides database functionality that uses a poolC instance
 heaps provided by poolC use shared memory that can optionally be backed by memory mapped disk files
 there is also a heapC class that provides a simpler, less powerful heap functionality
 in IPDOS (tm), heap functionality is provided mainly by poolC
i demonstrate a simple and powerful mechanism for ipc (interprocess communication)
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

