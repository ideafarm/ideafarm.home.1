
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / \r\n" ) ;
        handleP.osh = handleP.oshInvalid ;

        }
            }
                break ;
                BLAMMO ;
                _IO_
            {
            default :
            }
                break ;

                DECoShANDLES

                handleP.osh = 0 ;
                EVP_PKEY_free( (EVP_PKEY*)handleP.osh ) ;
                _IO_
            {
            case ifcIDtYPEhANDLE_OPENSSLkEYpUBLIC :
            case ifcIDtYPEhANDLE_OPENSSLkEYpRIVATE :
            case ifcIDtYPEhANDLE_OPENSSLkEYpAIR :
            }
                break ;
                DEL( *(bookC**)&handleP.osh ) ;
                _IO_
            {
            case ifcIDtYPEhANDLE_BOOKSrEADcURSOR :
            }
                break ;
                DEL( *(cloudInfoS**)&handleP.osh ) ;
                _IO_
            {
            case ifcIDtYPEhANDLE_CLOUD :
            }
                break ;
                }
                    DECoShANDLES

                    //etherC::etTextIF( tin0P ).traceF( tin0P , T("~handleCloseIF / called  OpenSSL free context") ) ;
                    BOSnOvALUE( WHATgbo , SSL_CTX_free( (SSL_CTX*)handleP.osh ) )     //20211111@1551: OBSERVED TO NEVER RETURN AFTER EXCEPTION CAUGHT WITHIN acceptF CALL TO shakeHandsAsServerF
                    //etherC::etTextIF( tin0P ).traceF( tin0P , T("~handleCloseIF / calling OpenSSL free context") ) ;
                    _IO_
                {
                else
                }
                    etherC::etTextIF( tin0P ).traceF( tin0P , T("~handleCloseIF / suppressing OpenSSL free context call") ) ;
                    THREADmODE4oFF( flTHREADmODE4_DOnOTfREEsSLcONTEXT )
                {
                if( F(((tin1S&)tin0P).flagsThreadMode4) & flTHREADmODE4_DOnOTfREEsSLcONTEXT )

                _IO_
            {
            case ifcIDtYPEhANDLE_openSslContext :
            }
                break ;

                #endif
    
                    }
                        DECoShANDLES

                        PUSE( tin0P , *(byteT**)&handleP.osh ) ;
                        if( !POOP ) { BOSnOvALUE( WHATgbo , DeleteCriticalSection( (CRITICAL_SECTION*)handleP.osh ) ) }
                        __( !handleP.osh ) ;
                        TINSL
                    {
    
                #if defined( __NT__ )
                _IO_
            {
            case ifcIDtYPEhANDLE_CRITICALsECTION :
            }
                break ;
            {
            case ifcIDtYPEhANDLE_FORaDAMtOuSEf :
            case ifcIDtYPEhANDLE_FORaDAMtOuSEe :
            case ifcIDtYPEhANDLE_FORaDAMtOuSEd :
            case ifcIDtYPEhANDLE_FORaDAMtOuSEc :
            case ifcIDtYPEhANDLE_FORaDAMtOuSEb :
            case ifcIDtYPEhANDLE_FORaDAMtOuSEa :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE9 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE8 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE7 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE6 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE5 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE4 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE3 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE2 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE1 :
            case ifcIDtYPEhANDLE_FORaDAMtOuSE0 :
            case ifcIDtYPEhANDLE_TREEwALK :
            case ifcIDtYPEhANDLE_STACKwALK :
            case ifcIDtYPEhANDLE_FISH :
            }
                break ;

                }
                    thirdC::openSslTls_wrapperFreeIF( tin0P , handleP ) ;
                    armSslC armMe( tin0P , flagsOpenSslFails ) ;
                    ZE( flagsT , flagsOpenSslFails ) ;
                {
                if( handleP.cNoteF() )
    
                handleP.osh = handleP.oshInvalid ;

                #endif
                    
                    DECoShANDLES

                    }
                        BLAMMOiD( ((tin1S&)tin0P).brcLath ) ;
                        //((tin1S&)tin0P).pc Utility[ 0 ] = ((tin1S&)tin0P).brcLath - WSABASEERR ;
                    {
                    )
                        && ((tin1S&)tin0P).brcLath != ERROR_HANDLE_EOF             //20210214@1745: OBSERVED ON factory9 within voidT socketC::acceptF( tin0S& tin0P , socketC*& pSocketP , countT& idPortP , nicNameC& nicNameP , boolT& bRefuseP )
                        && ((tin1S&)tin0P).brcLath != WSAENOTSOCK
                        && ((tin1S&)tin0P).brcLath != WSAENOTCONN
                        && handleP.osh != handleP.oshInvalid
                           ((tin1S&)tin0P).bosFail
                    (
                    if

                    BOSS( WHATgbo , BOSfAIL , closesocket( handleP.osh ) )
                    //LOGrAW5( "" , handleP.osh , "    " , ((tin1S&)tin0P).pag1->idAdam , " ----\r\n" ) ;
                    
                #elif defined( __NT__ )

                    DECoShANDLES

                    if( 0 > (sCountT)((tin1S&)tin0P).brcLath ) { BLAMMO ; }
                    BOSdOnOTtEST( WHATgbo , soclose( handleP.osh ) )

                #ifdef __OS2__

                #endif

                    BOSS( WHATgbo , BOSfAIL , shutdown( handleP.osh , 2 ) )

                #elif defined( __NT__ )

                    BOSdOnOTtEST( WHATgbo , so_cancel( handleP.osh ) )

                #ifdef __OS2__
                
                //}
                //    thp = 0 ;
                //    thp.s_optionLingerF( tin0P , handleP , 60 ) ; //20150322@1105: 0->60 TO FIND A BUG
                //    thirdC thp( tin0P , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ;
                //    //U::O: ELIMINATE CONSTRUCTION OF THIS thp
                //    TINSL
                //{
                //U:: 20200524@2335: WHY NEEDED?  CAN'T DO THIS EARLY OR LATE.  COMMENTED OUT BECAUSE CAUSES PROCESS C++ INIT TO FAIL WHEN HOME IS CLOAKED

                }
                    thirdC::openSslTls_waveByeIF( tin0P , handleP ) ;
                    armSslC armMe( tin0P , flagsOpenSslFails ) ;
                    ZE( flagsT , flagsOpenSslFails ) ;
                {
                if( handleP.cNoteF() )

                _IO_
            {
            case ifcIDtYPEhANDLE_SOCKET :
            }
                break ;
            {
            case ifcIDtYPEhANDLE_PROCESStOKEN :
            }
                break ;
            {
            case ifcIDtYPEhANDLE_PIPE :
            }
                break ;
                #endif

                    }
                        BOSpOOP
                        BOS( WHATgbo , BOSoK , SetConsoleCtrlHandler( (PHANDLER_ROUTINE)handleP.osh , 0 ) )     // IF flPROCESSsTATE_RECEIVEDsIGNALtObEfIRED THEN THIS WOULD BLOCK UNTIL THE SLEEP IN THE HANDLER TERMINATED SO THAT THE HANDLER RETURNED
                    {
                    if( !( F(processGlobal2I._thirdC_flagsProcessState) & flPROCESSsTATE_RECEIVEDsIGNALtObEfIRED ) )

                #elif defined( __NT__ )
                #if defined( __OS2__ )
                _IO_
            {
            case ifcIDtYPEhANDLE_CONSOLEhANDLER :
            }
                break ;
                BOSdOnOTtEST( WHATgbo , SetUnhandledExceptionFilter( (LPTOP_LEVEL_EXCEPTION_FILTER)handleP.cNoteF() ) )
                processGlobal2I.flDt |= flCTdTg_EXCEPTIONhANDLERrEGISTERED ;
                _IO_
            {
            case ifcIDtYPEhANDLE_EXCEPTIONhANDLER :
            }
                break ;

                DECoShANDLES

                BOSpOOP
                BOS( WHATgbo , BOSoK , DeleteObject( (HGDIOBJ)handleP.osh ) )
                TINSL
                _IO_
            {
            case ifcIDtYPEhANDLE_DRAWINGtOOL :
            }
                break ;
    
                    #endif
                
                    DECoShANDLES

                    if( ((tin1S&)tin0P).bosFail ) { BLAMMO ; }
                    BOS( WHATgbd , BOSoK , DeleteDC( (HDC)handleP.osh ) )
        
                    //U::hDrawP = 0 ;

                    //U::}
                    //U::    BOSpOOP
                    //U::    BOS( WHATgbd , BOSoK , DeleteDC( (HDC)hDrawP.osF( ifcIDtYPEhANDLE_DRAWpRIVATE ) ) )
                    //U::{
                    //U::if( !hWindow ) //ASSUME: IF hWindow THEN IS A PRIVATE DC; ELSE IS A MEMORY (BITMAP) DC
                    //U::
                    //U::pswWinFromDraw->freeF( tin0P ) ;
                    //U::countT hWindow = *pswWinFromDraw ;
                    //U::thirdC::lever_swWinFromDraw = handleP.osh ;
                
                #elif defined( __NT__ )
                
                    //U:
                
                #if defined( __OS2__ )
                _IO_
            {
            case ifcIDtYPEhANDLE_DRAWpRIVATE :
            }
                break ;
            {
            case ifcIDtYPEhANDLE_DRAWsHARED :
            }
                break ;
    
                }
                    #endif

                        DECoShANDLES

                        BOSpOOP
                        BOS( WHATgbd , BOSoK , DestroyWindow( (HWND)handleP.osh ) )

                    #elif defined( __NT__ )
                        //U:
                    #if defined( __OS2__ )
                {
                if( !handleP.cNote )
                _IO_
            {
            case ifcIDtYPEhANDLE_WINDOW :
            }
                break ;
            {
            case ifcIDtYPEhANDLE_WINDOWINGcLIENT :
            }
                break ;
    
                #endif
                    
                    DECoShANDLES

                    BOSpOOP
                    BOS( WHATgbo , BOSoK , FindCloseChangeNotification( (HANDLE)handleP.osh ) )
                    
                #elif defined( __NT__ )
                    
                    //U:
                    
                #ifdef __OS2__
                _IO_
            {
            case ifcIDtYPEhANDLE_FILEwAIT :
            }
                break ;
    
                #endif

                    }
                        processGlobal4I.heap.delF( tin0P , pbd ) ;
                        DELzOMBIE( pOsh ) ;
                        byteT* pbd = (byteT*)pOsh ;
                    {
                    if( pOsh )

                    diskFindHandleS* pOsh = (diskFindHandleS*)handleP.osh ;
                    
                #elif defined( __NT__ )
                    
                    //U:
                    
                #ifdef __OS2__
                _IO_
            {
            case ifcIDtYPEhANDLE_FILEfIND :
            }
                break ;
    
                #endif
                    
                    DECoShANDLES

                    //if( ((tin1S&)tin0P).pc Utility[ 0 ] && ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("---- [oshFind]:    ")+TF3(handleP.osh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                    
                    BOSpOOP
                    BOS( WHATgbo , BOSoK , FindClose( (HANDLE)handleP.osh ) )

                #elif defined( __NT__ )
                    
                    //U:
                    
                #ifdef __OS2__
                _IO_
            {
            case ifcIDtYPEhANDLE_FILEfINDbASE :
            }
                break ;
    
                }
                    #endif

                        DECoShANDLES

                        BOSpOOP
                        BOSS( WHATgbo , BOSoK , CloseHandle( (HANDLE)handleP.osh ) )

                    #elif defined( __NT__ )
                        DECoShANDLES

                        BOSpOOP
                        BOS( WHATgbo , BOSfAIL , DosClose( (HFILE)handleP.osh ) )
                    #ifdef __OS2__
                {
                if( handleP.idType != ifcIDtYPEhANDLE_PROCESS || !handleP.cNote )
                _IO_
            {
            case ifcIDtYPEhANDLE_THREAD         :
            case ifcIDtYPEhANDLE_PROCESS        :
            case ifcIDtYPEhANDLE_MUTEXsEMAPHORE :
            case ifcIDtYPEhANDLE_EVENTsEMAPHORE :
            }
                // INTENTIONAL FALLTHROUGH

                //}
                //    //etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                //    LOGrAW(   ostoSay ) ;
                //    OStEXTA(  ostoSay , !POOP ? " - (file mapping) / handleCloseIF / FILEmAPPING\r\n" : " - (file mapping) / handleCloseIF / FILEmAPPING (failed)\r\n" ) ;
                //    OStEXTC(  ostoSay , save , '0' ) ;
                //    OStEXT(   ostoSay , TUCK >> 2 ) ;
                //{
                //if( ((tin1S&)tin0P).pc Utility[ 0 ] )

                BOSpOOP
                BOS( WHATgbo , BOSoK , UnmapViewOfFile( (voidT*)handleP.cNote ) )
                countT save = handleP.cNote ;
                _IO_
            {
            case ifcIDtYPEhANDLE_FILEmAPPING    :
            }
                break ;
                handleP.cNote = 0 ;
                #endif

                    }
                        DECoShANDLES

                        BOSpOOP
                        BOS( WHATgbo , BOSoK , CloseHandle( (HANDLE)handleP.osh ) )
                        //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 0\r\n" ) ;
        
                        thirdC::dosPriorityIF( tin0P , idDesireSave ) ;
                        }
                            }
                                //}
                                //    //etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                                //    LOGrAW(   ostoSay ) ;
                                //    OStEXTA(  ostoSay , !POOP ? " - (file mapping) / handleCloseIF / SHAREDmEMORY\r\n" : " - (file mapping) / handleCloseIF / SHAREDmEMORY (failed)\r\n" ) ;
                                //    OStEXTC(  ostoSay , save , '0' ) ;
                                //    OStEXT(   ostoSay , TUCK >> 2 ) ;
                                //{
                                //if( ((tin1S&)tin0P).pc Utility[ 0 ] )

                                //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 1\r\n" ) ;
                                BOSpOOP
                                BOS( WHATgbo , BOSoK , UnmapViewOfFile( (voidT*)handleP.cNote ) )
                                countT save = handleP.cNote ;
                                //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 2\r\n" ) ;
                            {
                            if( !bFoundAlias )
                            //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 3\r\n" ) ;

                            }
                                THREADmODE4rESTORE
                                }
                                    //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 4\r\n" ) ;
                                    }
                                        //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 5\r\n" ) ;
                                        }
                                            linkedC::nextIF( tin0P , hx ) ;
                                            _IO_
                                        {
            
                                        }
                                            break ;
                                            //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 6\r\n" ) ;
                                            ++ bFoundAlias ;
                                        {
                                        )
                                            &he       != &handleP
                                            he.cNote  ==  handleP.cNote               &&
                                            he.idType ==  handleP.idType              &&
                                        (
                                        if
            
                                        handleC& he = *(handleC*)( (byteT*)&linked - SIZEOF_baseSoilXxxxC ) ;
                                        linkedC& linked = linkedC::getLinkIF( tin0P , hx ) ;

#endif

                                        //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 7\r\n" ) ;

                                        }
                                            }
                                                }
                                                    //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 8\r\n" ) ;
                                                    thirdC::dosSleepIF( tin0P , TICK , TOCK ) ;
                                                    //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / 9\r\n" ) ;
                                                {
                                                while( !etPrime )
                                                etherC& etPrime = etherC::etPrimeIF() ;
                                                LOGrAW( "calling dosSleepIF because hopefully i've logged enough loop handle values" ) ; // THIS RATHER THAN BLAMMO SO MINUTE REPORTS CAN REVEAL WHO CALLED ME
                                                //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / a\r\n" ) ;

                                                }
                                                    linkedC::nextIF( tin0P , hx2 ) ;
                                                    LOGrAWd( "[idThread,INtALLY,hx2,idLineCt,idiFileCt]:    " , ((tin1S&)tin0P).glass.idThread , "    " , INtALLY , "    " , hx2.osF( ifcIDtYPEhANDLE_LINKED ) , "    " , linked.idLineCtF() , "    " , linked.idiFileCtF() , "    " , linked.idThreadCtF() , "\r\n" ) ;
                                                    linkedC& linked = linkedC::getLinkIF( tin0P , hx2 ) ;

                                                    _IO_
                                                {
                                                while( cDo -- && ~hx2 )
                                                countT cDo = TUCK ;
                                                //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / b\r\n" ) ;
                                            
                                                root.openKidF( tin0P , hx2 ) ;
                                                linkedC& root = processGlobal4I._handleC_linked_sm ;
                                                handleC hx2( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LINKED ) ;

                                                LOGrAW( "walking from the root to document the state of the list (hopefully i've logged enough loop handle values)" ) ;
                                                //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / c\r\n" ) ;
                                            {
                                            if( ++ cLogged > TOCK )

                                            LOGrAW7( "[idThread,INtALLY,hx]:    " , ((tin1S&)tin0P).glass.idThread , "    " , INtALLY , "    " , hx.osF( ifcIDtYPEhANDLE_LINKED ) , "\r\n" ) ;

                                            static countT cLogged ;
                                        {
                                        if( INtALLY > TUCK ) //20161219@0929: LIST REPEATS WITH GROUPS OF 8
                                        //U:: TO FIND A BUG
                                        //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / d\r\n" ) ;

#if defined( NEVERdEFINED )

                                        _IO_
                                    {
                                    while( ~hx )
                                
                                    //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / e\r\n" ) ;
                                    root.openKidF( tin0P , hx ) ;
                                    linkedC& root = processGlobal4I._handleC_linked_sm ;
                                    handleC hx( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_LINKED ) ;
                                    //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / f\r\n" ) ;


                                    _IO_
                                {
                                THREADmODE4oN( flTHREADmODE4_DOnOTfLUSHpENDINGaPPtELEMETRY | flTHREADmODE4_INoUTfRAMEdEFERwRITINGaPPtELEMETRY )
                            {
                            ZE( boolT , bFoundAlias ) ;

                            TINSL
                        {
                        if( handleP.cNote ) //WILL BE 0 IF WAS NOT ABLE TO MAP A VIEW
                        //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / g\r\n" ) ;

                        //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / h\r\n" ) ;
        
                        }
                            if( F(processGlobal2I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal2I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal4I.grabMemorySpace.ungrabF( tin0P ) ;
                            }
                                }
                                    break ;
                                    processGlobal2I._thirdC_pSharedMemInfo[ offr ].pv = 0 ;
                                    processGlobal2I._thirdC_pSharedMemInfo[ offr ].osh = 0 ;
                                    *processGlobal2I._thirdC_pSharedMemInfo[ offr ].postName = 0 ;
                                {
                                if( processGlobal2I._thirdC_pSharedMemInfo[ offr ].osh == handleP.osh )
                            {
                            for( countT offr = 0 ; offr < CsHAREDmEMiNFO ; offr ++ )
                            if( F(processGlobal2I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal2I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal4I.grabMemorySpace.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        {
                        thirdC::dosPriorityIF( tin0P , ifcTHREADpRIORITY_SPINLOCK ) ;
                        const countT idDesireSave = thirdC::dosPriorityIF( tin0P ) ;
                        //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / i\r\n" ) ;
                    {
                    //if( !( F(processGlobal2I._thirdC_flagsProcessState) & flPROCESSsTATE_SIGNAL_TO_CRY ) )
    
                #elif defined( __NT__ )

                    DECoShANDLES

                    BOSdOnOTtEST( WHATgbo , DosFreeMem( (voidT*)handleP.cNote ) )

                #ifdef __OS2__
                _IO_
            {
            case ifcIDtYPEhANDLE_SHAREDmEMORY :
            }
                break ;

                }
                    DEL( pInfo ) ;

                    }
                        if( pInfo->postNameTag ) { BOS( WHATgbo , BOSoK , DeleteFile( pInfo->postNameTag ) ) }
                        if( ~pInfo->hTag       ) pInfo->hTag.closeIfF() ; //IT WOULD BE NICE TO DO THIS AFTER DELETING THE FILE, BUT NO CAN DO FOR NT FLAVOR OF win32
                        }
                            }
                                countT foo = 2 ;
                            {
                            if( c_strstrIF( pInfo->postName , ".!.transcript." ) )
                            //U:: TO FIND A BUG

                            BOS( WHATgbo , BOSoK , DeleteFile( pInfo->postName ) )
                        {
                        if( F(pInfo->flagsAtClose) & flFILEaTcLOSE_DELETE )
                    {
                    if( pInfo )

                    handleP.osh = handleP.oshInvalid ;
                    #endif

                        DECoShANDLES

                        BOSpOOP
                        BOS( WHATgbo , BOSoK , CloseHandle( (HANDLE)handleP.osh ) )

                    #elif defined( __NT__ )
                        //U::
                    #ifdef __OS2__

                    }
                        }
                            ((tin1S&)tin0P).pag1->_thirdC_.pSwFileOpen->ungrabF( tin0P ) ;
                            ((tin1S&)tin0P).pag1->_thirdC_.pSwFileOpen->freeF( tin0P ) ;
                            pInfo = (fileOpenS*)(countT)*((tin1S&)tin0P).pag1->_thirdC_.pSwFileOpen ;
                            ((tin1S&)tin0P).pag1->_thirdC_.cLever_pSwFileOpen = handleP.osh ;
                            ((tin1S&)tin0P).pag1->_thirdC_.pSwFileOpen->grabF( tin0P , TAG( TAGiDnULL ) ) ;
                            puseC puseat( tin0P , ifcIDpOOL_ADAMtEMP ) ;
                        {
                        if( ((tin1S&)tin0P).pag1->_thirdC_.pSwFileOpen ) //DEREGISTRATION MUST OCCUR BEFORE HANDLE CLOSURE BECAUSE THE OS MIGHT IMMEDIATELY REUSE THAT HANDLE, RESULTING IN AN ATTEMPT TO REGISTER IT (WHICH WOULD FAIL IF IT WINS THE RACE)
                    {
                    if( F(handleP.cNote) & flFILEhANDLEnOTE_OPENrEGISTERED )
                    ZE( fileOpenS* , pInfo ) ;

                    TINSL
                {
                if( handleP.osh > 2 ) //DO NOT CLOSE THE STANDARD FILE HANDLES 0 , 1 , 2 (STDIN STDOUT STDERR)
                _IO_
            {
            case ifcIDtYPEhANDLE_FILE :
            }
                break ;
                #endif

                    DECoShANDLES

                    BOSpOOP
                    BOS( WHATgbo , BOSoK , FreeLibrary( (HMODULE)handleP.osh ) )
                    dec02AM( processGlobal2I.cDllLoaded ) ; //COUNT WILL BE WRONG IF THE NEXT LINE FAILS

                #elif defined( __NT__ )
                    //U::
                #ifdef __OS2__
                _IO_
            {
            case ifcIDtYPEhANDLE_DLL :
            }
                break ;

                //}
                //    etherC::etRockIF( tin0P ).traceF( tin0P , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
                //
                //    OStEXTC(  ostoSay , idNameDebug , 0 ) ;
                //    OStEXTAK( ostoSay , "openF / COULD NOT UNGRAB (NOT REGISTERED) [idName]: " ) ;
                //    OStEXT(   ostoSay , TUCK << 2 ) ;
                //{
                //else if( ((tin1S&)tin0P).pc Utility[ 0 ] && ((tin1S&)tin0P).pag1->idAdam == ifcIDaDAM_ 2GLASS2 )
                }
                    //}
                    //    CONoUTrAW( ostoSay ) ;
                    //    //PUSE( tin0P , postName ) ;
                    //    //OStEXTA(  ostoSay , postName ) ;
                    //    OStEXTC(  ostoSay , pListing->nameF() , 0 ) ;
                    //    OStEXTAK( ostoSay , " | ----- " ) ;
                    //    OStEXTC(  ostoSay , ((tin1S&)tin0P).glass.idThread , 0 ) ;
                    //    OStEXTAK( ostoSay , "\r\n" ) ;
                    //    OStEXT(   ostoSay , TUCK << 1 ) ;
                    //
                    //    //getListNameGF( tin0P , postName , pListing->nameF() ) ; ___( postName ) ;
                    //    //ZE( osTextT* , postName ) ;
                    //{
                    //if( pListing->flagsF() & fliLISTINGc_MIXINlIST )

                    //}
                    //    etherC::etRockIF( tin0P ).traceF( tin0P , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
                    //
                    //    OStEXTC(  ostoSay , idNameDebug , 0 ) ;
                    //    OStEXTAK( ostoSay , "openF / ungrabbed  [idName]: " ) ;
                    //    OStEXT(   ostoSay , TUCK << 2 ) ;
                    //{
                    //if( ((tin1S&)tin0P).pc Utility[ 0 ] && ((tin1S&)tin0P).pag1->idAdam == ifcIDaDAM_ 2GLASS2 )


                    //etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
                    OStEXTAK( ostoSay , " --   ungrabbed" ) ;
                    //U:: TO FIND A BUG

                    grabitx.ungrabF( tin0P ) ; //FOR APPLICATION CODING CONVENIENCE; AS OF THIS WRITING THERE IS NO WAY TO EXPLICITLY UNGRAB A LIST THAT HAS BEEN OPENED AND KEPT OPEN EXCEPT TO MAKE SURE THAT THE LATH LIST WALK DOES NOT SPECIFY THE "DO NOT UNGRAB LIST" FLAG


                    //etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
                    //THESE HAVE TRIGGERED DEADLOCK WHEN CAUSES A NEW bookC INSTANCE TO BE CT'D; ENABLE WHEN traceF IS ENHANCED TO AVOID CREATING bookC INSTANCES
                    OStEXTAK( ostoSay , " : --   ungrabbing" ) ;
                    OStEXTCF( ostoSay , (countT)&pListing->flagsRefF() , '0' ) ;
                    OStEXT(   ostoSay , TUCK << 2 ) ;
                    //U:: TO FIND A BUG


                    _IO_
                {
                if( grabitx.isRegisteredF( tin0P ) )

                //}
                //    etherC::etRockIF( tin0P ).traceF( tin0P , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
                //
                //    OStEXTC(  ostoSay , idNameDebug , 0 ) ;
                //    OStEXTAK( ostoSay , "openF / ungrabbing [idName]: " ) ;
                //    OStEXT(   ostoSay , TUCK << 2 ) ;
                //{
                //if( ((tin1S&)tin0P).pc Utility[ 0 ] && ((tin1S&)tin0P).pag1->idAdam == ifcIDaDAM_ 2GLASS2 )

                grabitC grabitx( tin0P , TAG( TAGiDnULL ) , pListing->flagsRefF() , ifcIDgRABITbIT_00 + offLISTINGgRABBEDbIT , *(grabitC*)0 , 0 , 0 , 0 , flagsx ) ;

                }
                    flagsx |= flGRABITc_RECURSEuSINGtINs ;
                    )
                        )
                            idName <= LISTnAMEsYS_ROOTsYSTEM8              //CS:CODEsYNC: 330e5007 33001126 3300039b
                            &&
                            idName >= LISTnAMEsYS_ROOTsYSTEM1
                        (
                        ||
                        idName == LISTnAMEsYS_ROOTaPPLICATION
                        ||
                        idName == LISTnAMEsYS_ROOT
                    (
                    if
                    //idNameDebug = idName ;
                    countT idName = ((listC*)pListing)->nameF() ;
                {
                if( pListing->flagsF() & fliLISTINGc_MIXINlIST )
                //ZE( countT , idNameDebug ) ;
                flagsT flagsx = flGRABITc_SUPPRESScTdT | flGRABITc_UNKEYED ; //CS:CODEsYNC 360e5007 35001126 "flGRABITc_UNKEYED" IS SPECIFIED TO AVOID NEEDING TO DOUBLE THE SIZE OF THE sexC ALLOCATION DROP FOR listingC INSTANCES.  sizeof( listingC ) IS CURRENTLY OPTIMAL.  ADDING A countT MEMBER TO HOLD A KEY WOULD CHANGE THE ALLOCATION DROP SIZE.

                listingC* pListing = (listingC*)handleP.osh ;

                //__( thirdC::dosPriorityIF( tin0P ) - ifcTHREADpRIORITY_SPINLOCK ) ;
                _IO_
            {
            case ifcIDtYPEhANDLE_LISTING :
            }
                break ;
                ((linkedC*)handleP.osh)->ungrabF( tin0P ) ;
                _IO_
            {
            case ifcIDtYPEhANDLE_LINKED :
            }
                break ;
            {
            case ifcIDtYPEhANDLE_BOOKS :
            }
                break ;
                sadamsC::pSadamsIF( tin0P )->unlockF( tin0P , handleP ) ;
                _IO_
            {
            case ifcIDtYPEhANDLE_sadamsC :
        {
        switch( handleP.idType )

        _IO_

        //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) CONoUTrAW( "thirdC::handleCloseIF / j\r\n" ) ;

        TINSL //U::CONJ: THIS WILL FAIL VERY EARLY; IF NOT THEN LET'S JUST ADD tin0P TO THE PARAMETERS
    {
    if( ~handleP.osh != handleP.oshInvalid )
{
/*1*/voidT thirdC::handleCloseIF( handleC& handleP )/*1*/

/**/
*/
\<A HREF=\"5.1020161.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$handleCloseIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

