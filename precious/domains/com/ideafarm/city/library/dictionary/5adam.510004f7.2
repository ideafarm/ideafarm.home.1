
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
pStNodeGod = 0 ;
pRuAge = 0 ;
pStStBang = 0 ;
TELL( "cleaning up" )
etherC::ifcSayIF( T("GOD: i am outa here") , flSAY_APPEND | flSAY_LOG ) ;

}
    }
        ++ s ; etThread.osSleepF( tin0P , TUCK * 0x40 ) ;
    {
    while( cNodes )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
{
TELL( "waiting for all acceptors to die" )
etherC::ifcSayIF( T("GOD: waiting for all nodes to die") , flSAY_APPEND | flSAY_LOG ) ;

}
    ++ s ; ether.osSleepF( tin0P , TOCK * 0x8 ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    TELL( "napping" )

    }
        }
            }
                break ;
                CONoUTrAW( "* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n* * * * * * * *GOD: I AM NOW WAITING FOR ALL NODES TO DIE * * * * * * * *\r\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n" ) ;
                etherC::ifcSayIF( T("GOD: breaking from launch loop") , flSAY_APPEND | flSAY_LOG ) ;
            {
            if( cLaunches >= CnODES )
            }
                //break ; //ENABLE FOR SINGLE SHOT; DISABLE FOR BURST
                TELL( "launching tmNodeF-" )
                if( !etThread ) cNodes ++ , cLaunches ++ ;
                etThread.osThreadF( tin0P , countTC() , tmNodeF , 0 , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&cNodes ) ;
                TELL( "launching tmNodeF+" )
            {
            while( cToDo -- )
            countT cToDo = CnODES - cNodes ;
            //etThread.strokeF( tin0P , T("no backlog\r\n") ) ;
            cSuppress = 0 ;
        {
        else if( !( cSuppress && cSuppress -- ) )
        else if( cNodes > CnODES ) etThread.strokeF( tin0P , T("cNodes: ")+TF1(cNodes)+T("\r\n") ) ;
        if( cBacklog ) etThread.strokeF( tin0P , T("----")+TF1(cBacklog)+T("----\r\n") ) ;
    {
    //if( cLaunches < 2 )
    TELL( "deciding whether to launch tmNodeF" )

    countT cBacklog = godBacklogF( tin0P ) ;
    TELL( "calculating cBacklog" )
{
while( !ether )
ZE( countT , cSuppress ) ;
ZE( countT , cLaunches ) ;
ZE( countT , cNodes ) ;

pRuAge = &ruAge ;
ranUniC ruAge( TICK * 0x10 , 1 ) ;
pStStBang = &stStBang ;
stackC stStBang( tin0P , etThread , TAG( TAGiDnULL ) ) ;
TELL( "setting up 2" )

pStNodeGod = &stNodeGod ;
stackC stNodeGod( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( nodeC ) ) ;
TELL( "setting up" )

TODO

}
    return cBacklog ;
    pStStBang->ungrabF( tin0P ) ;
    }
        while( !pStStBang->third && ~hDown ) ;
        }
            if( pStBang && *pStBang ) cBacklog += *pStBang ;
            stackC* pStBang = (stackC*)pStStBang->downF( tin0P , hDown ) ;
        {
        do
        handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( *pStStBang )
    pStStBang->grabF( tin0P , TAG( TAGiDnULL ) ) ;
    ZE( countT , cBacklog ) ;
{
countT godBacklogF( tin0S& tin0P )

DONE( tmNodeF )
}
    cNodes -- ;
    nodeMainF( tin0P , etThread ) ;
    countT& cNodes = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TELL( "setting up" )
TASK( tmNodeF )

}
    pStStBang->ungrabF( tin0P ) ;
    if( (*pStStBang)( (countT)&stBangP ) ) pStStBang->extractF( tin0P ) ;
    pStStBang->grabF( tin0P , TAG( TAGiDnULL ) ) ;
{
voidT godByeF( tin0S& tin0P , stackC& stBangP )

}
    pStStBang->sinkF( tin0P , countTC() , (countT)&stBangP , flSTACKsINK_UNIQUE , subtractNodesF ) ;
{
voidT godHelloF( tin0S& tin0P , stackC& stBangP )

}
    pStNodeGod->ungrabF( tin0P ) ;
    if( (*pStNodeGod)( (byteT*)nodeP , subtractNodesF ) ) pStNodeGod->extractF( 0 , tin0P ) ;
    pStNodeGod->grabF( tin0P , TAG( TAGiDnULL ) ) ;
    bGasp = 1 ;
{
voidT godByeF( tin0S& tin0P , const nodeC& nodeP )

}
    pStNodeGod->sinkF( tin0P , countTC() , (byteT*)nodeP , flSTACKsINK_UNIQUE , subtractNodesF ) ;
{
voidT godHelloF( tin0S& tin0P , const nodeC& nodeP )

}
    //return TOCK * 0x10 + *pRuAge / ( nodeP.idMe % 2 ? 1.0 : 16.0 ) ;

    return TOCK * ( 0x10 * ( nodeP.idMe % 2 ? 0x40 : 1 ) ) ;

    //return TOCK * 0x8 + *pRuAge / 8 ;
    //return ( TOCK * 0x10 ) * idMe ;

    //countT idMe = 1 + incv02AM( idMeLath ) ;
    //static countT idMeLath ;

    //return pcAge[ off ++ ] ;

    //static countT off ;
    //static countT pcAge[ 2 ] = { TICK * 0x10 , TOCK * 0x20 } ;

{
countT godMyLifespanF( tin0S& tin0P , nodeC& nodeP )

}
    if( ((tin1S&)tin0P).fingerprint && etThread && stNodeOpenP ) ;

    if( bTalkP ) etThread.strokeF( tin0P , tLine ) ;
    tLine += T("\r\n") ;
    
    }
        }
            tLine += T(" ")+TF1(idMe) ;
            stIdMe >> idMe ;
            ZE( countT , idMe ) ;
        {
        while( stIdMe )
        tLine += T("                        ") ;
    {
    if( stIdMe )
    
    stNodeOpenP.ungrabF( tin0P ) ;
    }
        while( !stNodeOpenP.third && ~hDown ) ;
        }
            if( stIdMe( node.idMe ) ) stIdMe.extractF( tin0P ) ;
            tLine += T(" ")+TF1(node.idMe)+T((*pStNodeGod)((byteT*)&node,subtractNodesF)?" ":"~") ;
            //if( bGasp && !( node.idMe % 2 ) ) bTalkP = 1 ;
            nodeC& node = *(nodeC*)&stNodeOpenP.downF( tin0P , hDown ) ;
        {
        do
        handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( stNodeOpenP )
    stNodeOpenP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    bTalkP = 1 ;
    
    pStNodeGod->ungrabF( tin0P ) ;
    }
        while( !pStNodeGod->third && ~hUp ) ;
        do stIdMe.sinkF( tin0P , countTC() , pStNodeGod->upF( tin0P , hUp ) , flSTACKsINK_UNIQUE ) ;
        handleC hUp( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
    {
    if( *pStNodeGod )
    pStNodeGod->grabF( tin0P , TAG( TAGiDnULL ) ) ;
    stackC stIdMe( tin0P , etThread , TAG( TAGiDnULL ) ) ;
    
    TN( tLine , "" ) ; tLine = TF1(nodeP.idMe)+T(":") ;
{
voidT godPrayF( tin0S& tin0P , etherC& etThread , stackC& stNodeOpenP , const nodeC& nodeP , boolT& bTalkP )

boolT bGasp ;

stackC*  pStNodeGod ;
ranUniC* pRuAge ;
stackC*  pStStBang ;

#define CnODES 0x7

#include postADAMhEADER

/*1*/WAKEhIDE( "ifcIDaDAM_3BANG: simulator code" )/*1*/
/**/
*/
this file contains code that would not be running or available on the real IPDOS system
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

