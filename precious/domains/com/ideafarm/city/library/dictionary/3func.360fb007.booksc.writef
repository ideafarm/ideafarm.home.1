
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idBook ;

    THREADmODE3rESTORE

    else      __1         ;
    if( ~hw ) hw >> hJotP ;

    //}
    //    CONoUTrAW( TF2(pcp,flFORMAT_PREFIXED)+tcr ) ;
    //    TN( tcr , "\r\n" ) ;
    //
    //    countT pcp[] = { 2 , a.c1 , a.c2 } ;
    //    const HANDLEaPPnOTEScOUNTcLASS& a = hw ;
    //{

    //if( ((tin123S&)tin0P).pEther && ((tin123S&)tin0P).pc Utility[ 0 ] ) ((tin123S&)tin0P).pEther->traceF( tin0P , T("booksC::writeF [idBook]:    ")+TF2(idBook,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    countT idBook = writeF( tin0P , pb1P , cb1P , pb2P , cb2P , flagsWrite , &hw ) ;
    handleC hw( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;

    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )

    ;
        : flagsP | flBOOKScwRITE_ALLOWoDDlENGTH | flBOOKScwRITE_ALLoRsOME
        ? flagsP | flBOOKScwRITE_ALLOWoDDlENGTH
    flagsT flagsWrite = F(flagsP) & flBOOKScwRITE_ALLoRnONE

    _IO_

    }
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/countT booksC::writeF( tin0S& tin0P , handle0111C& hJotP , const byteT* const pb1P , const countT cb1P , const byteT* const pb2P , const countT cb2P , const flagsT flagsP )/*1*/

/**/
*/
use me when the application code will not know and cannot calculate cb1P+cb2P so that cb1P+cb2P must be stored within hJotP
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

