
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    // /*if( !( cFoo % TICK ) )*/ etThread.traceF( tin0P , tSayPulled+TF2(cFoo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    myCircle >> &cFoo ;
{
while( !ether )
ZE( countT , cFoo ) ;
TN( tSayPulled , "pulled:    " ) ;

etThread.osThreadF( TaRG2cBsTACK( tmPushF , CBsTACKmIN << 1 ) , (countT)&myCircle ) ;

circleC myCircle( tin0P , etThread , ether , sizeof( countT ) , 8 , deleteElementF , &cArgDelete  ) ;
countT cArgDelete = (countT)&argDelete ;
argDeleteS argDelete( etThread ) ;

TODO

DONE( tmPushF )
}
    }
        /*if( !( cFoo % TICK ) )*/ etThread.traceF( tin0P , tSayPushed+TF2(cFoo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        myCircleP << &cFoo ;
        cFoo ++ ;
    {
    while( !ether && cFoo < 0x20 )
    ZE( countT , cFoo ) ;
    TN( tSayPushed , "pushed:    " ) ;

    circleC& myCircleP = *(circleC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmPushF )

}
    return 0 ;

    etherP.traceF( tin0P , T("[cAt,cValue]:    ")+TF2(cAtP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cValue,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    countT& cValue = *(countT*)cAtP ;

    etherC& etherP = argDeleteP.ether ;
    argDeleteS& argDeleteP = *(argDeleteS*)cArgDeleteP ;
{
countT deleteElementF( tin0S& tin0P , countT& cAtP , countT& cArgDeleteP )

;
}
    {}
    ether( etherP )
    argDeleteS( etherC& etherP ) :

    etherC& ether ;
{
struct argDeleteS

/*1*/WAKEhIDE( "example.simplest.1snip.150001d1.circleC.deletion.callback" )/*1*/
/**/
*/
 generally, each element can be the image of an application defined class or structure, and the callback can call DELzOMBIE() to delete it
 in this example, each element is a countT value, and the deleteElementF callback function just traces out its address and value
i don't actually do any deleting, but i do demonstrate how each element that is about to be overwritten can be deleted or otherwise processed
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
