
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            SCOOPSdEL
            scoopC* _pScoopsSave = pScoopsSave ;
        {
        if( bSniffingTinNotMe )
    
        }
            delF( tinP , psttUid ) ;
    
            //if( pcRaceId ) ifcRaceIdF( tinP ) ;
    
            etherTestF( tinP ) ;
            }
                delF( tinP , psttLog ) ;
    
                delF( tinP , postLog ) ;
                { ifcDatumF( tinP , flDATUM1_CLASSeXCEPTIONjOURNAL , flDATUM2_osTextT , 0 , 0 , postLog , costLog ) ; }
                //else           { ifcDatumF( tinP , flDATUM1_CLASSeXCEPTIONjOURNAL   , flDATUM2_osTextT , 0 , 0 , postLog , costLog ) ; }
                //if( bImpotent ){ ifcDatumF( tinP , flDATUM1_CLASSeXCEPTIONiMPOTENCE , flDATUM2_osTextT , 0 , 0 , postLog , costLog ) ; }
                countT costLog = strMakeF( tinP , LF , postLog , psttLog ) ; ___( postLog ) ;
                ZE( osTextT* , postLog ) ;
    
                }
                    //delF( tinP , psttw ) ;
                    //third = 0 ;
                    //ifcPutHostLogEntryF( tinP , psttw ) ; // U: CONDITIONALLY DO THIS ONLY IF CONNECTED TO THE INTERNET
                    //strToUrlF( tinP , psttw , psttLog ) ; ___( psttw ) ;
                    //ZE( strokeS* , psttw ) ;
                {
    
                countT cIn = 1 + incv02AM( cInLath ) ;
                static countT cInLath ;
                //U:
            {
            if( psttLog )
    
            //}
            //    { countT pcPart[] = { idr_ETHERtIMEsLEPT1 , idiFileCt , idLineCt , 0 } ; ifcDatumF( tinP , flDATUM1_CLASStACHOMETER , flDATUM2_null , timeSlept1 , pcPart ) ; }
            //    { countT pcPart[] = { idr_ETHERtIMEsLEPT2 , idiFileCt , idLineCt , 0 } ; ifcDatumF( tinP , flDATUM1_CLASStACHOMETER , flDATUM2_null , timeSlept2 , pcPart ) ; }
            //    { countT pcPart[] = { idr_ETHERtIMEaGE1   , idiFileCt , idLineCt , 0 } ; ifcDatumF( tinP , flDATUM1_CLASStACHOMETER , flDATUM2_null , timeAge1   , pcPart ) ; }
            //    { countT pcPart[] = { idr_ETHERtIMEaGE2   , idiFileCt , idLineCt , 0 } ; ifcDatumF( tinP , flDATUM1_CLASStACHOMETER , flDATUM2_null , timeAge2   , pcPart ) ; }
            //{
    
            //#if defined( NEVERdEFINED )
            //U: NOTE: GENERATED DATA SUGGESTS THAT idiFileCt IS ALWAYS 0
            //U: ENABLE THIS AFTER FIND THE CULPRIT GENERATING CORRUPT DATUM ITEMS
    
            if( ((tinNormalS&)tinP).pag1->_etherC_.pEtPrime == this ) delF( tinP , ((tinNormalS&)tinP).pag1->_etherC_.pstt1_processParameters ) ;
    
            //U: REPORT TIME AWAKE, TIME SLEPT FOR PERFORMANCE MONITORING AT OPERATIONS
            third.osTimeSubtractF( tinP , timeAge1 , timeAge2 , timeBorn1 , timeBorn2 ) ;
            third.osTimeNowF( tinP , timeAge1 , timeAge2 ) ;
            ZE( sCountT , timeAge2 ) ;
            ZE( countT , timeAge1 ) ;
        {
    
    
        //bFunctionCountersReady = 0 ;
    
        DEL( _pSwSoixlOldApiDoc ) ;
        DEL( _pSwSoixlOldApi ) ;
        DEL( third.pswWinFromDrawDuringPaint ) ;
        DEL( third.pswWinFromDraw ) ;
        DEL( third.pswPaintInfoFromDrawingHandle ) ;
    
        }
            DEL( ((tinNormalS&)tinP).pag1->_etherC_.cio_pStkOut ) ;
            DEL( ((tinNormalS&)tinP).pag1->_etherC_.cio_pBaton ) ; //A: ASSUME: CHANNEL IO THREAD HAS ENDED
    
            }
                ((tinNormalS&)tinP).pag1->_etherC_.pSwDllReferences->ungrabF( tinP ) ;
                }
                    }
                        handle.osF( ifcIDtYPEhANDLE_DLL , osh ) ;
                        handleC handle( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DLL ) ;
                        stHandle >> osh ;
                        ZE( countT , osh ) ;
                    {
                    else while( stHandle )
                    if( !stHandle ) break ;
                    for( countT idf = 1 ;idf <= cFlavors ; idf ++ ) stHandle << ((tinNormalS&)tinP).pag1->_etherC_.pSwDllReferences->leverF( tinP , idf ) ;
                    countT cFlavors = ((tinNormalS&)tinP).pag1->_etherC_.pSwDllReferences->cFlavorsF( tinP ) ;
                {
                while( !POOP )
                ((tinNormalS&)tinP).pag1->_etherC_.pSwDllReferences->grabF( tinP , TAG( TAGiDnULL ) ) ;

                stackC stHandle( tinP , third , TAG( TAGiDnULL ) ) ;
            {
            if( ((tinNormalS&)tinP).pag1->_etherC_.pSwDllReferences )
    
            //U:__( ifcHandoffOldF( tinP ).idPhaseF( tinP ) - ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;
    
            flagsMode &= ~( F(flTHIRDmODE_QUITTER) ) ;
    
            }
                }
                    if( !b_tmWindows ) thirdC::third_flagsProcessStateI_IF( tinP , flPROCESSsTATE_MAINtHREADiSaLONE , 1 ) ;
                    //THIS CODE HAS BEEN ALTERED SO THAT I BLOCK UNTIL I AM ALONE (EXCEPT FOR tmHeartF)
                    //THAT BLOCKAGE IN WM_CLOSE IS PERMANENTLY COMMENTED OUT; WHY WAS IT NEEDED?
                    //THE PRECEEDING COMMENT IS OBSOLETE AND FALSE
                    /* ONLY main AND tmWindowsF REMAIN, AND tmWindowsF IS BLOCKED IN WM_CLOSE AND HAS ALREADY DESTROYED ITS etThread */
                    }
                        ++ s ; thirdC::dosSleepIF( tinP , TUCK * 0x40 ) ;
                        //etherC::etRockIF( tinP ).traceF( tinP , T("~etherC / waiting for all kids and orphans to die [cAllKidThreadsI,cAllOrphanThreadsI]:    ")+TF2(cAllKidThreadsI,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cAllOrphanThreadsI,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ") ) ;
                    {
                    while( cAllKidThreadsI + cAllOrphanThreadsI ) //WANT TO WAIT TILL tmWindowsF IS GONE CAUSE windowOldC::ether MUST BE DT FOR ALL WINDOWS
                    //OLD: while( cAllKidThreadsI + cAllOrphanThreadsI > !!b_tmWindows )
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    POOPIE
                {
                //if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_etThreadONmainISiMPOTENT ) )
                countT& cAllOrphanThreadsI = thirdC::os_cAllOrphanThreadsI_IF( tinP ) ;
                countT& cAllKidThreadsI    = thirdC::os_cAllKidThreadsI_IF( tinP ) ;
                const boolT b_tmWindows = !!( F(thirdC::third_flagsModeAdam1I_IF(tinP)) & flADAMmODE1_tmWindows ) ;
                if( F(((tinNormalS&)tinP).flagsThreadMode2) & flTHREADmODE2_DRIVERaDAM ) { BLAMMO ; }
                FIREmYSELF ;
            {
    
            if( ((tinNormalS&)tinP).pcQuit == &(const countT&)POOP ) ((tinNormalS&)tinP).pcQuit = 0 ;
    
            DEL( ((tinNormalS&)tinP).pSwsRecycle ) ; //TO MAKE SURE THAT etRock EXISTS WHEN THESE ARE DELETED
            }
                THREADmODE2rESTORE
                }
                    }
                        }
                            }
                                default                            : { BLAMMO                           ; break ; }
                                case ifcIDtYPErECYCLE_switchStackC : { DEL( *(switchStackC**)&pObject ) ; break ; }
                                case ifcIDtYPErECYCLE_switchC      : { DEL(      *(switchC**)&pObject ) ; break ; }
                                case ifcIDtYPErECYCLE_stackC       : { DEL(       *(stackC**)&pObject ) ; break ; }
                                case ifcIDtYPErECYCLE_soulC        : { DEL(        *(soulC**)&pObject ) ; break ; }
                            {
                            switch( *((tinNormalS&)tinP).pczl_pSwsRecycle )
                        {
                        if( ((tinNormalS&)tinP).pczl_pSwsRecycle && pObject )
    
                        //LOGrAWtID4( "deleting object " , (countT)pObject , " using pcz lever at " , ((tinNormalS&)tinP).pczl_pSwsRecycle ) ; //U::
    
                        *((tinNormalS&)tinP).pSwsRecycle >> *(countT*)&pObject ;
                        ZE( voidT* , pObject ) ;
                    {
                    while( *((tinNormalS&)tinP).pSwsRecycle )
    
                    ((tinNormalS&)tinP).pczl_pSwsRecycle = (countT*)((tinNormalS&)tinP).pSwsRecycle->leverF( tinP , idf ) ;
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                countT cFlavors = ((tinNormalS&)tinP).pSwsRecycle->cFlavorsF( tinP ) ;
                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
            {
            if( ((tinNormalS&)tinP).pSwsRecycle )
            //PSEUDODUPLICATE CODE: 1450002 12f0002 1030003 1020171

            delF( tinP , ((tinNormalS&)tinP).pag1->_etherC_.psttEarlyFolder ) ;
        {
        if( ((tinNormalS&)tinP).pag1->_etherC_.pEtPrime == this )
    
        third.pEtherContainsMe = 0 ;
    
        if( processGlobal4I.tinVeryVeryEarlyLateMain.pEther == this ) processGlobal4I.tinVeryVeryEarlyLateMain.pEther = 0 ; //U:: THIS SHOULD NOT BE NEEDED.  IT WAS NOT EFFECTIVE ANYWAY TO PAPER OVER THE BUG FOUND REGARDING ((tinNormalS&)tinP).pEther

        if( ((tinNormalS&)tinP).pag1->pEtThreadMain == this ) ((tinNormalS&)tinP).pag1->pEtThreadMain = 0 ;
        if( ((tinNormalS&)tinP).pEther              == this ) ((tinNormalS&)tinP).pEther              = 0 ;
    
        }
            }
                delF( tinP , psttd ) ;
                strokeS*& psttd = *(strokeS**)&(countT&)*_pSwSoixlOldApiDoc ;
                _psttLeverSoixlOldApi = (strokeS*)_pSwSoixlOldApiDoc->leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = _pSwSoixlOldApiDoc->cFlavorsF( tinP ) ;
        {
        if( _pSwSoixlOldApiDoc ) // THIS LOOP USES ((tinNormalS&)tinP).pEther (subractor callback uses it)
    
        }
            bSniffingTinNotMe = 1 ;
            pScoopsSave = _pScoopsSave ;
            SCOOPSnEWsPECIFIED( poopBefore )
        {
        if( ((tinNormalS&)tinP).pag1->_etherC_.pEtPrime == this && POOP == ifcIDsUBtYPEpOOP_FIREDbYmONITOR )
        ZE( scoopC* , pScoopsSave ) ;                                                                                                                 \
        ZE( boolT , bSniffingTinNotMe ) ;
    {
    _IO_

    SCOOP
    const poopC& poopBefore = *((tinNormalS&)tinP).pPoop ;
    TINSL
{
/*1*/etherC::~etherC( voidT )/*1*/

/**/
*/
  \<A HREF=\"5.f010104.1.1.0.html\"\>f010104:  WAKEsHOW( "example.simplest.func.1030003.etherC.dt_etherC" )\</A\>
 simplest
examples
\<A HREF=\"5.1030003.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

