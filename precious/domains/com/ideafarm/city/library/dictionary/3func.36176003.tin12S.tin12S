
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}


    }
        //SAYnAME( " tin12S/-\r\n" )
    
        }
            }
                }
                    *(countT*)pbPendingInOutFramePackets = 0 ;

                    }
                        pbPendingInOutFramePackets = pbn ;
                        PUSE.newF( tin0P , LF , pbn , cba ) ; ___( pbn ) ;
                        ZE( byteT* , pbn ) ;                                // pbn IS USED TO PREVENT pbPendingInOutFramePackets FROM BEING USED BEFORE ITS WOTH countT IS INITIALIZED
                    {
                    else
                    if( !pPoolUse ) pbPendingInOutFramePackets = processGlobal4I.heap.newF( tin0P , LF , cba ) ;

                    countT cba = sizeof( countT ) + CmAXpENDINGiNoUTfRAMEpACKETS * sizeof( tellInfoAppInOutFrameS ) ;
                {
                if( !pbPendingInOutFramePackets )
            {
            if( !( F(flags) & flTINs_NOiNoUTfRAMEsUPPORT ) )



            }

                info.idiFileCt  = idiFileCt ;
                info.idLineCt   = idLineCt ;
                info.idTinNamed = idTinNamed ;

                info.idTin      = idTin ;
                //info.ip       = aptMe ? aptMe : (countT)this ;
                info.ip         = (countT)this ;
                info.idSerial   = idSerial ;
                tellInfoSysTinS info ;
                //countT idTypeSay = aptMe ? ifcIDtYPEtELLsYS_TINcTI : ifcIDtYPEtELLsYS_TINcTP ;
                countT idTypeSay = ifcIDtYPEtELLsYS_TINcTP ;
                //ap_artmentOldC aptMe( tin0P , (byteT*)this ) ;

            {
            if( !( F(flags) & flTINs_CONSTRUCTqUIETLY ) )
    
            }
                }

                    info.costName = thirdC::c_strlenIF( tin0P , info.postName ) ;
                    thirdC::c_strncpyIF( tin0P , info.postName , postOverride , sizeof info.postName ) ;
                    info.idiFile = idiFileCt ;
                    info.idLine = idLineCt & 0xfff ;
                    tellInfoSysLifiS info ;
    
                    osTextT* postOverride = idiFileCt != 0x3000b71 ? postn : "earlyLate" ;
                {
                if( postn )
        
                }

                    }
                        }
                            break ;
                            if( !setIfZeAM( bDone , 1 ) ) postn = "earlyLateOrException" ;
                            static countT bDone ;
                        {
                        case ifcIDtINnAMED_tinEarlyLate :
                        case ifcIDtINnAMED_tinBreakI    : { postn = "tmBreakF" ; break ; }
                        case ifcIDtINnAMED_tinHeartI    : { postn = "tmHeartF" ; break ; }
                    {
                    switch( idTinNamed )
                {
                ZE( osTextT* , postn ) ;
            {
            if( idTinNamed == ifcIDtINnAMED_tinHeartI || idTinNamed == ifcIDtINnAMED_tinBreakI || idTinNamed == ifcIDtINnAMED_tinEarlyLate )




            }
                }
                    }
                        etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;

                        OStEXTAK( ostoSay , "_" ) ;
                        OStEXTCF( ostoSay , pbThreadStackEnd , '0' ) ;
                        OStEXTAK( ostoSay , "_    " ) ;
                        OStEXTCF( ostoSay , pbThreadStackStart , '0' ) ;
                        OStEXTAK( ostoSay , "    " ) ;
                        OStEXTC(  ostoSay , cbStack , 0 ) ;
                        OStEXTAK( ostoSay , "    " ) ;
                        OStEXTC(  ostoSay , glass.idThread , 0 ) ;
                        OStEXTAK( ostoSay , "_9    " ) ;
                        OStEXTC9( ostoSay , osTid ) ;
                        OStEXTAK( ostoSay , "_9    " ) ;
                        OStEXTC9( ostoSay , osPid ) ;
                        OStEXTAK( ostoSay , "tin12S"  " [osPid,osTid,idThread,cbStack,pbThreadStackStart,pbThreadStackEnd]:    " ) ;
                        OStEXT(   ostoSay , TUCK << 1 ) ;

                        countT cbStack = pbThreadStackEnd - pbThreadStackStart ;

                        // EXAMPLE: tin12S  [osPid,osTid,idThread,cbStack,pbThreadStackStart,pbThreadStackEnd]:    12308_9    8168_9    00000000    00004000    000a0000_    000e0000_
                        //          123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
                        //          0              1               2               3               4               5               6               7               8               9               a               b               c               d               e               f               0
                    {
                    if( F(thirdC::third_flagsModeProcess2I_IF()) & flMODEpROCESS2_CHATTERtHREADsTACK && ( idTinNamed == ifcIDtINnAMED_tinInPoolMain || this == &tin0SelfOrElderP ) )

                    }
                        etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , /*flTRACE_LOOP |*/ flTRACE_PARAMETERiSoStEXT ) ;

                        OStEXTAK( ostoSay , " ++++" ) ;
                        OStEXTAK( ostoSay , "_9    " ) ;
                        OStEXTC9( ostoSay , osTid ) ;
                        OStEXTAK( ostoSay , "_9    " ) ;
                        OStEXTC9( ostoSay , osPid ) ;
                        OStEXTAK( ostoSay , "tin12S [osPid,osTid]:    " ) ;
                        OStEXT(   ostoSay , TUCK >> 0 ) ;

                        tin0S& tin0P = *this ;
                    {
                    if( F(thirdC::third_flagsModeProcess2I_IF()) & flMODEpROCESS2_CHATTERtHREADcTdT )
                {
                if( idTinNamed == ifcIDtINnAMED_tinInPoolMain || ( this == &tin0SelfOrElderP && idTinNamed != ifcIDtINnAMED_tinHeartI && idTinNamed != ifcIDtINnAMED_tinBreakI && idTinNamed != ifcIDtINnAMED_tin9VeryVeryEarlyLateMainI ) )
            {
            //if( F(processGlobal2I.flCt) & flCTdTg_WITHINlIFETIMEoFmAIN && !( F(processGlobal2I.flDt) & flCTdTg_WITHINlIFETIMEoFmAIN ) )                                                                       //THIS IS TO AVOID CLUTTERING THE LOG FILE

            }
                }
                    case ifcIDtINnAMED_tinInPoolMain             : { processGlobal2I.flCt |= flCTdTg_tinMainInPool             ; break ; }
                    case ifcIDtINnAMED_tin9VeryEarlyLateMainI     : { processGlobal2I.flCt |= flCTdTg_tin9VeryEarlyLateMainI     ; break ; }
                    case ifcIDtINnAMED_tin9VeryVeryEarlyLateMainI : { processGlobal2I.flCt |= flCTdTg_tin9VeryVeryEarlyLateMainI ; break ; }
                {
                switch( idTinNamed )
    
                if( pTinF() != this ) { BLAMMO } ;
            {
            if( idTinNamed != ifcIDtINnAMED_tinHeartI && idTinNamed != ifcIDtINnAMED_tinBreakI )
        
            TINSL
    
            }
                *(countT*)&pbThreadStackEnd   = (countT)info.BaseAddress + info.RegionSize ;
                *(countT*)&pbThreadStackStart = (countT)info.AllocationBase ;
                VirtualQuery( (byteT*)ebpP , &info , sizeof info ) ;
                MEMORY_BASIC_INFORMATION info ;
                //CONoUTrAW3( "\r\ntin12S / setting [pbThreadStackStart,pbThreadStackEnd] / [idTinNamed]:    " , idTinNamed , "\r\n" ) ;
            {
            if( !pbThreadStackStart )

            }
                putNegAM( fingerprint , FINGERnEG_TINs ) ; //MY IMAGE IS NOW COMPLETELY VALID
        
                //thirdC::c_memsetIF( tin0P , (byteT*)ppTinKid   , sizeof ppTinKid    ) ;
                const boolT bComments = !( F(flags) & flTINs_DISABLEcOMMENTS  ) ;
        
                TINSL
                ctTellCopyDoneF( (countT)this ) ;
            {
            else
            }
                if( pTin9Prior->pPoop != &pTin9Prior->poop ) { BLAMMO ; }


        
                if( thirdC::c_memcpyWithCallBackIF( (byteT*)this + sizeof( tin0S ) , (byteT*)pTin9Prior + sizeof( tin0S ) , sizeof( tin12S ) - sizeof( tin0S ) , ctTellCopyDoneF , (countT)this ) ) { BLAMMO ; } //CODE SYNC: 003002a 12f0002 12f0003

                putNegAM(     pTin0Prior->fingerprint   ,  FINGERnEG_TINszOMBIE ) ; //FROM NOW UNTIL I REGISTER MYSELF, MONITOR WILL NOT BE ABLE TO SEE A tin12S FOR THIS THREAD
                if( getNegAM( pTin0Prior->fingerprint ) != FINGERnEG_TINs       ) BLAMMO ;

                //SAYnAME( " tin12S/ " ) CONoUTrAW( " copying from " ) ; CONoUTrAW( NAME( pTin0Prior->idTinNamed ) ) ; CONoUTrAW( "\r\n" ) ;
                tin12S*   pTin9Prior = (tin12S*)&tin0SelfOrElderP ;
                *(tin0S**)&pTin0Prior   =              &tin0SelfOrElderP ;
            {
            if( !( F(flags) & flTINs_NOeLDER ) )
        
            }
                idSerial  = ph ? 1 + incv02AM( ph->idSerialLath ) : 0 ;
                homeS* ph = processGlobal1I.pHome ;
            {
            //U::VALIDATE flags...NOTE THAT flags IS NOT VALIDATED. THIS IS BECAUSE I DO NOT HAVE AN POOP TO SET U::CONJ: IT COULD BE VALIDATED NOW THAT I KNOW WHETHER I CAN USE tin0P AS MY ELDER)    
        
            idDesireSetBySelf = thirdC::dosPriorityIF( tin0SelfOrElderP ) ;
        {










        //SAYnAME( " tin12S/+\r\n" )

        if( !idTinNamedP ) { BLAMMO ; }
    {
{

tin_part2_S( tin0SelfOrElderP )
tin_part1_S( tin0SelfOrElderP , pTin0DadP , idTinNamedP , idThreadP , pbTlsP , cbTlsP ) ,
tin0S( tin0SelfOrElderP , idLineCtP , idiFileCtP , pbBitsCtP , ifcIDtYPEtIN_12  , pTin0DadP , flagsP , idTinNamedP ) ,
/*1*/tin12S::tin12S( tin0S& tin0SelfOrElderP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const countT ebpP , const countT idThreadP , tin0S* const pTin0DadP , const flagsT flagsP , const countT idTinNamedP , byteT* const pbTlsP , const countT cbTlsP )/*1*/ :


                                                                                                            



/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
