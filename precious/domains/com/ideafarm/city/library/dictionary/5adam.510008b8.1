
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etherC::loafIF( tin0P ) ;
    etThread.traceF( tin0P , T("ok") ) ;

    }
        ++ s ; ether.osSleepF( tin0P , TOCK << 3 ) ;

        }
            }
                break ;
                etThread.traceF( tin0P , T("no more events") ) ;
            {
            if( !etThread.strCompareF( tin0P , tValueMore , tFalse ) )

            }
                etThread.boxPutF( tin0P , tLongStopAtThisEvent , tIdEventWothLag , tIdEventWothLag.csF( tin0P ) ) ;
                tIdEventWothLag = tIdEventWoth ;
            {
            if( tIdEventWoth.csF( tin0P ) )

            etRock.traceF( tin0P , tPrefix+T("end   " DASH79) ) ;

            DEL( pSwPathValue ) ;
            }
                }
                    etThread.delF( tin0P , psttValue ) ;
            
                   }
                        }
                            }
                                }
                                    break ;
                                    }
                                        etThread.delF( tin0P , psttLong ) ;
                                        etThread.traceF( tin0P , psttLong ) ;
                                        etThread.boxPutGenerationF( tin0P , psttLong , T("///d/save/event") , 0 , tEvent , tEvent.csF( tin0P ) , 0 , flOPENdETAILS_null , T(".ttt") ) ;
                                        ZE( strokeS* , psttLong ) ;

                                        etThread.traceF( tin0P , T("ifcIDaDAM_QUERYsTRIPEeVENTS / booked  [nnPeer,costae]:    ")+T(nnZe)+tb4+TF2(costae,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        bksWebHookNotices.writeF( tin0P , (byteT*)pcHeader , sizeof pcHeader , postze , costae , flBOOKScwRITE_ALLOWoDDlENGTH | flBOOKScwRITE_ALLoRnONE , 0 ) ;

                                        *(nicNameC*)&pcHeader[ 4 ] = nnZe ;
                                        putNegAM( pcHeader[ 0 ] , FINGERnEG_WEBhOOKnOTICES ) ;
                                        count02T pcHeader[] = { 0 , 1 , costae , fliWEBhOOKnOTICE_NEW , 0 , 0 , 0 , 0 } ;

                                        countT   costae = tEvent.csF( tin0P ) + 1 ;
                                        osTextT* postze = tEvent ;
                                    {
                                    else
                                    if( !tEvent.csF( tin0P ) ) etRock.traceF( tin0P , T("!exception / null length event") ) ;
                                    TN( tEvent , "" ) ; tEvent = *pptValue[ offe ] ;
                                {
                                case 1 :                                                                                                               //CS:CODEsYNC: 510008b8 510008b8 510008b8    ; CODE ASSUMES THAT tValueEvent   IS AT OFFSET 1
                                }
                                    break ;
                                    if( !tIdEventWoth.csF( tin0P ) )   tIdEventWoth = *pptValue[ offe ] ;
                                                                     //tIdEventLath = *pptValue[ offe ] ;
                                {
                                case 0 :                                                                                                               //CS:CODEsYNC: 510008b8 510008b8 510008b8    ; CODE ASSUMES THAT tValueIdEvent IS AT OFFSET 0
                            {
                            switch( offe )
                            etRock.traceF( tin0P , T("****    ")+T(psttPath) + T("   :    ") + *pptValue[ offe ] ) ;
                            *pptValue[ offe ] = T(psttValue) ;
                        {
                        if( 1 == etThread.strIdF( tin0P , 0 , flSTRmATCH_null , idf , sttq , *pptPath[ offe ] , psttPath , 0 , 1 ) && !idf )
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        countT idf = 1 ;
                    {
                    for( countT offe = 0 ; !ether && offe < cPaths ; offe ++ )
            
                    if( cPaths - cValues ) { BLAMMO ; }
                    countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                    countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                    //etRock.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                    //etRock.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;
            
                    strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                    psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
            
                    _IO_
                {
                for( countT idf = 1 ; !ether && idf <= cFlavors ; idf ++ )
                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
            {
            if( pSwPathValue )

            }        
                }
                    }
                        }
                            }
                                }
                                    DEL( pSwPathValue ) ;
                                    etRock.traceF( tin0P , tSayExCouldNotParseJson+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tDomainStripeApi ) ;
                                    POOPRqUIET
                                    countT rc = POOP ;
                                {
                                if( POOP )
                                __Z( pSwPathValue ) ;
                                ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                //etRock.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                //etRock.traceF( tin0P , T("json response:") ) ;
                            {
                            else
                            }
                                etRock.traceF( tin0P , tSayExCouldNotReadFromSocket+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tDomainStripeApi ) ;
                                POOPRqUIET
                                countT rc = POOP ;
                            {
                            if( POOP )
                    
                            }
                                etThread.delF( tin0P , psttLong ) ;
                                etThread.traceF( tin0P , psttLong ) ;
                                etThread.boxPutGenerationF( tin0P , psttLong , T("///d/save/stripe") , costj + TUCK , postj , costj , 0 , flOPENdETAILS_null , T(".ttt") ) ;
                                ZE( strokeS* , psttLong ) ;

                                }
                                    }
                                        break ;
                                        costj ++ ;
                                    {
                                    else if( costj )
                                         if( cNest ) costj ++ ;
                        
                                    else if( postj[ costj ] == '}' ) cNest -- ;
                                         if( postj[ costj ] == '{' ) cNest ++ ;
                        
                                    //putchar( postj[ costj ] ) ;

                                    if( !cbIn ) break ;
                                    countT cbIn = sock.readF( tin0P , postj + costj , 1 ) ;
                                {
                                while( !POOP )
                                ZE( countT , cNest ) ;
                                ZE( countT , costj ) ;
                            {
                            thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                        {
                        else
                        }
                            etRock.traceF( tin0P , tSayExCouldNotWriteToSocket+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tDomainStripeApi ) ;
                            POOPRqUIET
                            countT rc = POOP ;
                        {
                        if( POOP )
                        sock.writeF( tin0P , (osTextT*)tSay ) ;
                        //etRock.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                        //etRock.traceF( tin0P , T("request:") ) ;

                        TN( tSay , "" ) ; tSay = tSay1+(tIdEventWothLag.csF(tin0P)?tEndingBefore+tIdEventWothLag:tn)+T(" HTTP/1.1\r\nAuthorization: Bearer ")+tStripeApiKeyTest+T("\r\nHost: api.stripe.com\r\nStripe-Version: 2024-06-20\r\n\r\n") ;

                        ) ;

                            "&types[]=customer.subscription.updated"
                            "&types[]=customer.subscription.trial_will_end"
                            "&types[]=customer.subscription.resumed"
                            "&types[]=customer.subscription.pending_update_expired"
                            "&types[]=customer.subscription.pending_update_applied"
                            "&types[]=customer.subscription.paused"
                            "&types[]=customer.subscription.deleted"
                            "&types[]=customer.subscription.created"
                            "&types[]=checkout.session.completed"
                            "GET /v1/events?limit=32"

                        TN( tSay1 ,
                    {
                    else
                    }
                        etRock.traceF( tin0P , tSayExCouldNotConnectToServer+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tDomainStripeApi ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )
                    sock.connectF( tin0P , 443 , nnServer ) ;
                    socketC sock( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL ) ;

                    //etRock.traceF( tin0P , T("connecting to IPv4:    ")+T(nnServer) ) ;
                {
                else
                }
                    etRock.traceF( tin0P , tSayExCouldNotObtainNnServer+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tDomainStripeApi ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                {
                if( POOP )
                nicNameC nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tDomainStripeApi ) ;

                SCOOPS
            {
            IFsCRATCHoK
            ZE( switchC* , pSwPathValue ) ;
            ZE( strokeS* , psttPath     ) ;

            etRock.traceF( tin0P , tPrefix+T("begin " DASH79) ) ;
            TN( tPrefix , "" ) ; tPrefix = TF2(idOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tDot+TF2(idInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4 ;
            idInner ++ ;
        {
        while( !ether )
        //TN( tIdEventLath , "" ) ;               // "LATH" MEANS "LATH IN THE LIST, WHICH IS THE OLDEST      EVENT IN THE LIST RETURNED IN THIS PASS"
          TN( tIdEventWoth , "" ) ;               // "WOTH" MEANS "WOTH IN THE LIST, WHICH IS THE MOST RECENT EVENT IN THE LIST RETURNED IN THIS PASS"
        idOuter ++ ;                              // "WOTH STICKY" MEANS "WOTH IN THE PREVIOUS LIST, WHICH IS THE MOST RECENT EVENT IN THE LIST RETURNED IN THE PREVIOUS PASS"
    {
    while( !ether )
    ZE( countT , idInner ) ;
    ZE( countT , idOuter ) ;

    booksC bksWebHookNotices( tin0P , TAG( TAGiDnULL ) , "webhook.notices" , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;

    /**/etRock.traceF( tin0P , T("initial value of ending before [tIdEventWothLag]:    ")+tIdEventWothLag ) ;         // THE STRIPE API RETURNS EVENTS IN REVERSE CHRONOLOGICAL ORDER

    }
        }
            }
                etThread.delF( tin0P , posti ) ;
                tIdEventWothLag = T(posti) ;
            {
            else
            }
                etRock.traceF( tin0P , T("!exception / could not read [tLongStopAtThisEvent]:    ")+tLongStopAtThisEvent ) ;
                POOPRqUIET
            {
            if( POOP )
            ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , tLongStopAtThisEvent , 1 ) ; ___( posti ) ;
            SCOOPS
        {
        IFsCRATCHoK
        ZE( countT   , costi ) ;
        ZE( osTextT* , posti ) ;
    {
    TN( tIdEventWothLag , "evt_1SQC6fLzWCJsgIUVr8Yj2U4P" ) ;
    TN( tLongStopAtThisEvent , "" ) ; tLongStopAtThisEvent = T("///d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(ifcIDaDAM_QUERYsTRIPEeVENTS)+T("/stop.at.this.event") ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    ;
    }
        &tPathMore    ,
        &tPathType    ,
        &tPathEvent   ,         //CS:CODEsYNC: 510008b8 510008b8 510008b8    ; CODE ASSUMES THAT tValueEvent   IS AT OFFSET 1
        &tPathIdEvent ,         //CS:CODEsYNC: 510008b8 510008b8 510008b8    ; CODE ASSUMES THAT tValueIdEvent IS AT OFFSET 0
    {
    textC* pptPath[] =

    ;

        +S2(sa_SSSaNDeND,sc_ccSSS)
            +T("/")
            +S2(sa_SSSmARKnUMERICf,sc_cSSSmARK)
            +S3(7,sc_ccSSSrEPEAT,7)
            +T("\"data\"/item.")
        +S2(sa_SSSaND,sc_ccSSS)

    TN( tPathEvent , "" ) ; tPathEvent = tn

    TN( tPathMore , "\"has_more\"/" ) ;

    ;

        +S2(sa_SSSaNDeND,sc_ccSSS)
            +T("/\"type\"/")
            +S2(sa_SSSmARKnUMERICf,sc_cSSSmARK)
            +S3(7,sc_ccSSSrEPEAT,7)
            +T("\"data\"/item.")
        +S2(sa_SSSaND,sc_ccSSS)

    TN( tPathType , "" ) ; tPathType = tn

    ;

        +S2(sa_SSSaNDeND,sc_ccSSS)
            +T("/\"id\"/")
            +S2(sa_SSSmARKnUMERICf,sc_cSSSmARK)
            +S3(7,sc_ccSSSrEPEAT,7)
            +T("\"data\"/item.")
        +S2(sa_SSSaND,sc_ccSSS)

    TN( tPathIdEvent , "" ) ; tPathIdEvent = tn

    ;
    }
        &tValueMore    ,
        &tValueType    ,
        &tValueEvent   ,                             //CS:CODEsYNC: 510008b8 510008b8 510008b8    ; CODE ASSUMES THAT tValueEvent   IS AT OFFSET 1
        &tValueIdEvent ,                             //CS:CODEsYNC: 510008b8 510008b8 510008b8    ; CODE ASSUMES THAT tValueIdEvent IS AT OFFSET 0
    {
    textC* pptValue[] =

    TN( tValueEvent   , "" ) ;      // SINCE THE INPUT CONTAINS MULTIPLE EVENTS, THESE tValue* OBJECTS WILL CONTAIN THE LATH VALUES ENCOUNTERED FOR EACH
    TN( tValueMore    , "" ) ;
    TN( tValueType    , "" ) ;      // SINCE THE INPUT CONTAINS MULTIPLE EVENTS, THESE tValue* OBJECTS WILL CONTAIN THE LATH VALUES ENCOUNTERED FOR EACH
    TN( tValueIdEvent , "" ) ;      // SINCE THE INPUT CONTAINS MULTIPLE EVENTS, THESE tValue* OBJECTS WILL CONTAIN THE LATH VALUES ENCOUNTERED FOR EACH

    /**/etRock.traceF( tin0P , T("[tStripeApiKeyTest]:    ")+tStripeApiKeyTest ) ;
    }
        etThread.delF( tin0P , psttEat ) ;
        tStripeApiKeyTest = T(psttEat) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.stripe.api.key.test")  ) ; ___( psttEat ) ;
        _IO_
    {
    TN( tStripeApiKeyTest             , "" ) ;

    TN( tSayExCouldNotParseJson       , "!exception / could not parse json [rc,domain]:    " ) ;
    TN( tSayExCouldNotReadFromSocket  , "!exception / could not read from socket [rc,domain]:    " ) ;
    TN( tSayExCouldNotWriteToSocket   , "!exception / could not write to socket [rc,domain]:    " ) ;
    TN( tSayExCouldNotConnectToServer , "!exception / could not connect to server [rc,domain]:    " ) ;
    TN( tSayExCouldNotObtainNnServer  , "!exception / could not obtain IPv4 [rc,domain]:    " ) ;

    TN( tEndingBefore   , "&ending_before="        ) ;
    TN( tPathEndpoint    , "/v1/webhook_endpoints/" ) ;
    TN( tDomainStripeApi , "api.stripe.com" ) ;
    TN( tFalse , "false" ) ;
    TN( tDot , "."    ) ;
    TN( tb4  , "    " ) ;
    TN( tb   , " "    ) ;
    TN( tn   , ""     ) ;
    const nicNameC nnZe ;

    etherC& etRock = etherC::etRockIF( tin0P ) ;

    // FOR SIMPLICITY AND RELIABILITY, A NEW CONNECTION IS ESTABLISHED FOR EACH ITERATION (THIS CAN BE OPTIMIZED)
    // THIS IS JUST SKELETON CODE FOR PROOF OF CONCEPT ; I PERIODICALLY UPDATE THE STRIPE WEBHOOK DESTINATION URL FOR THE TEST ENVIRONMENT, BUT ALWAYS TO THE SAME VALUE

    _IO_
{
if( pTaskP )
TASK( tmWorkF )

osTextT postj[ TICK ] ;

/*1*/WAKEhIDE( "ifcIDaDAM_QUERYsTRIPEeVENTS" )/*1*/
/**/
*/
 avoidance of duplicate processing of an event is left to later processing (ifcIDaDAM_WELCOMER and ifcIDaDAM_ADMINISTRATOR)
 in particular, i don't worry about whether each event that i receive has already been received by the webhook system
 i am a redundant system that does exactly what the webhook system does
i obtain (and eventually will book) new stripe events
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
