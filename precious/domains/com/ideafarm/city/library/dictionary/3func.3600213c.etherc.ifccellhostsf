
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        __( swsNicName ) ;
        pNicNameP[ off ] = 0 ;
        }
            delF( tinBaseP , pNicName ) ;
            if( pNicName ) pNicNameP[ off ] = *pNicName ;
            swsNicName >> pNicName ;
            ZE( nicNameC* , pNicName ) ;
        {
        for( ; off < cNicNameP ; off ++ )
        ZE( countT , off ) ;
    {
    if( pNicNameP )
    newF( tinBaseP , LF , pNicNameP , cNicNameP + 1 ) ; ___( pNicNameP ) ;
    cNicNameP = swsNicName ;
    idaLever = idAdamP ;

    }
        }
            DEL( pStk ) ;
            stDelete_stackC_ptr >> *(countT*)&pStk ;
            ZE( stackC* , pStk ) ;
        {
        while( stDelete_stackC_ptr )

        ifcCellHostsF( tinBaseP , swsNicName , idaLever , b_idaLever , swsIdAdam , idhLever , b_idhLever , tblCells , tblHosts , stDelete_strokeS_ptr , stDelete_nicNameC_ptr , stDelete_stackC_ptr , cTriesP ) ;

        stackC stDelete_stackC_ptr(  tinBaseP , *this , TAG( TAGiDnULL ) ) ;
        stackC stDelete_nicNameC_ptr( tinBaseP , *this , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_nicNameC ) ;
        stackC stDelete_strokeS_ptr( tinBaseP , *this , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

        tableC tblHosts( tinBaseP , *this , T("hosts") ) ;
        tableC tblCells( tinBaseP , *this , T("cells") ) ;

        switchStackC swsIdAdam( tinBaseP , *this , TAG( TAGiDnULL ) , flSTACKc_null , idhLever ) ;
        batonC b_idhLever( tinBaseP , TAG( TAGiDnULL ) ) ;
        nicNameC idhLever ;

        batonC b_idaLever( tinBaseP , TAG( TAGiDnULL ) ) ;
    {
    switchStackC swsNicName( tinBaseP , *this , TAG( TAGiDnULL ) , flSTACKc_null , idaLever , flSTACKc_null , ifcSTACKtYPE_PTR_nicNameC ) ;
    ZE( countT , idaLever ) ;

    _IO_

    }
        if( POOP ) return ;
        __Z( idAdamP ) ;
        __( cNicNameP ) ;
        __NZ( pNicNameP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::ifcCellHostsF( tinBaseS& tinBaseP , nicNameC*& pNicNameP , countT& cNicNameP , const countT idAdamP , countT cTriesP )/*1*/

/**/
*/
  after i return, will contain the number of nicNameC values that pNicNameP points to
  must be 0
 cNicNameP
  after i return, will point to a null terminated array list of each host that is registered as currently hosting a cell of idAdamP
  must be 0
 pNicNameP
 tinBaseP
arguments
\<A HREF=\"5.103017d.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$ifcCellHostsF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

