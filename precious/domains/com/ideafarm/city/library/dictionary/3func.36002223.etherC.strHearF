
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    }
        }
            strMakeF( tin0P , LF , psttUnwantedP , tUnwanted ) ; ___( psttUnwantedP ) ;
            }
                delF( tin0P , psttu2 ) ;
                delF( tin0P , psttu1 ) ;
                }
                    }
                        if( psttu2->idAdam == 1 ) bDone = 1 ;
                        tUnwanted += T(psttu2) ;
                    {
                    else
                    if( !psttu2 || !psttu2->idAdam ) bDone = 1 ;
                    tUnwanted += T(psttu1) ;
                {
                else
                if( !psttu1 || !psttu1->idAdam ) bDone = 1 ;
                strHearF( tin0P , psttu1 , psttu2 , TOCK ) ; ___( psttu1 ) ; ___( psttu2 ) ;
                ZE( strokeS* , psttu2 ) ;
                ZE( strokeS* , psttu1 ) ;
            {
            while( !bDone )
            ZE( boolT , bDone ) ;

            delF( tin0P , postiUnwanted ) ;
            TN( tUnwanted , postiUnwanted ) ;
        {
        else                                                                                                            // IN THIS CASE, dosReadStdInF DID NOT DISCARD A '\n' AND THERE COULD BE ANY NUMBER OF STROKES WAITING TO BE READ
        }
            delF( tin0P , postiUnwanted ) ;
            strMakeFromOsTextF( tin0P , psttUnwantedP , postiUnwanted ) ; ___( psttUnwantedP ) ;
        {
        if( !postiUnwanted[ 1 ] )                                                                                       // IN THIS CASE postiUnwanted[ 0 ] IS THE ONLY UNWANTED STROKE ENTERED
    {
    if( postiUnwanted && postiUnwanted[ 0 ] )

    delF( tin0P , posti ) ;
    strMakeFromOsTextF( tin0P , psttP , posti ) ; ___( psttP ) ;
    third.dosReadStdInF( tin0P , posti , postiUnwanted , costi ) ; ___( posti ) ;
    countT costi = csttWantedP ;

    ZE( osTextT* , postiUnwanted ) ;
    ZE( osTextT* , posti ) ;
{
/*1*/voidT etherC::strHearF( tin0S& tin0P , strokeS*& psttP , strokeS*& psttUnwantedP , const countT csttWantedP )/*1*/

/**/

*/
  if, while browsing early adam definitions, you find code that receives text input from the console, please let us know where!
  it is also possible that it was around when HEAReNTER stopped being used that craftwork was focused on graphics presentation
  it is possible that the early code just used c library functions such as getch()
   dosReadStdInF was enhanced today to return postiUnwanted
  there must have been some way to receive keystrokes, but as of this writing no support is found in the base library other than dosReadStdInF, which was not used anywhere
   i think that it was just used to pause execution until the operator pressed the Enter key
  it is likely that the HEAReNTER macro discarded any keystrokes entered
  originally, this was done using a HEAReNTER macro, which is no longer defined
 20251109@1344: this new function restores the ability to receive strokes from the console
i receive strokes keyed from stdIn
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
