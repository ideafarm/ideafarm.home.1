
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tin0P , T("ok") ) ;
etThread.traceF( tin0P , T("final total [idIn]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

while( !ether && ~hFind && !POOP ) ;
}
    DEL( pInfo ) ;
    }
        }
            THREADmODE1rESTORE
            }
                }
                    bPrefix = !bPrefix ;

                    else          pbi = 0 ;
                    if( bDelete ) PUSE( tin0P , *(byteT**)&pbi ) ;       //SHOULD BE IMPOSSIBLE SINCE EACH EVENT WAS WRITTEN "ALL OR NONE"

                    ;
                        : sizeof( countT )
                        ? *(countT*)pbi
                    cbi = bPrefix

                    }
                        if( !( ++ idIn % ( TUCK << 4 ) ) ) etThread.traceF( tin0P , T("[idIn]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( !bPrefix )

                    __( cbi - cbiSave ) ; //SHOULD ALWAYS GET THE ENTIRE SHEBANG

                    }
                        break ;
                        hRead = hReadSave ;
                        cbi = cbiSave ;
                    {
                    if( !pbi )

                    boolT bDelete = bksPageAccessEvents.readF( tin0P , pbi , cbi , hRead , flBOOKScrEAD_null , &(countT&)ether ) ;

                    HANDLEaPPnOTEScOUNTcLASS ch = hRead ;

                    handleC hReadSave = hRead ;
                    countT cbiSave = cbi ;
                {
                while( !etThread && !POOP && !ether )
                boolT bPrefix = 1 ;
                countT cbi = sizeof( countT ) ;
                ZE( const byteT* , pbi ) ;
                handleC hRead( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
            {
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            booksC bksPageAccessEvents( tin0P , TAG( TAGiDnULL ) , tShorter , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;

            //etThread.traceF( tin0P , T("[tShorter]:    ")+tShorter ) ;

            }
                etThread.delF( tin0P , psttShorter ) ;
                tShorter = T(psttShorter) ;
                etThread.delF( tin0P , psttnu ) ;
                etThread.strBisectF( tin0P , psttShorter , psttnu , tShort , tDot , 3 , flSTRbISECT_null ) ; ___( psttShorter ) ; ___( psttnu ) ;
                ZE( strokeS* , psttnu ) ;
                ZE( strokeS* , psttShorter ) ;
            {
            TN( tShorter , "" ) ;            // .CDN_ACCESS_LOGS.!.00b0d3bc.21f75cd8.9d7e9628.0a810000.4a810000.web.archiveview.2018.01.21.18.0f687d0ce0e187c640bbe7d56b250a52.log
        {
        if( !bDir )

        }
            etThread.delF( tin0P , psttShort ) ;
            tShort = T(psttShort) ;
            etThread.delF( tin0P , psttnu ) ;
            etThread.strBisectF( tin0P , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
            ZE( strokeS* , psttShort ) ;
            ZE( strokeS* , psttnu ) ;
        {
        TN( tShort , "" ) ;            // .CDN_ACCESS_LOGS.!.00b0d3bc.21f75cd8.9d7e9628.0a810000.4a810000.web.archiveview.2018.01.21.18.0f687d0ce0e187c640bbe7d56b250a52.log

        const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;

        TN( tIfoName , pInfo->psttIfoName ) ;
    {
    else
    }
        break ;
        DEL( pInfo ) ;
    {
    if( !pInfo || !pInfo->psttIfoName )

    etThread.diskFindFileOrDirOldF( tin0P , pInfo , hFind , tLike ) ;
    ZE( infoFileS* , pInfo ) ;
{
do
handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
ZE( countT , idIn ) ;
TN( tDot , "." ) ;
TN( tSlash , "/" ) ;
TN( tLike , "" ) ; tLike = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/")+tUser+T("/" STR( ifcIDmEMORYsPACE_APPLICATION ) "/stateSpaces/ffffefff/bksPageAccessEvents.????????.????????.booksC.1.book.00000001.00000001.bookC") ;
TN( tUser , thirdC::postUserNameIF() ) ;

TODO


/*1*/WAKEhIDE( "count the events that are booked by page" )/*1*/
/**/
*/
 on output, each access event is written to a book dedicated to the corresponding idJot pair that identifies [container] [uri]
 the idJot values identify strings that i place into jotC instances
 on output, each access event soulC contains idJot values rather than string values
 on input, each access event soulC is self sufficient in that it contains string values
i "divide and conquer" by distributing access events to a dedicated booksC instantShort ) ;ce for each hash of [container] || [uri]
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
