

//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
}
#endif
    return idjSoilRootOrNewBranch ;

    }
        if( pcbWroteP ) *pcbWroteP = cbWroteSome + cWroteMore ;
        if( idjSoilRootOrNewBranchMore - idjSoilRootOrNewBranch ) { BLAMMOiD( idjSoilRootOrNewBranchMore - idjSoilRootOrNewBranch ) ; }
        countT idjSoilRootOrNewBranchMore = writeF( tinP , pb1P , cb1P , pb2P , cb2P , idjSoilRootOrNewBranch , flagsP | flJOTfILEScwRITE_APPENDpART , &cWroteMore ) & ~NM_HIGH ;
        ZE( countT , cWroteMore ) ;

        }
            cb1P -= cbWroteSome ;
            pb1P += cbWroteSome ;
        {
        else
        }
            cb2P = 0              ;
            pb2P = 0              ;
            cb1P = cb2P - cbDone2 ;
            pb1P = pb2P + cbDone2 ;

            countT cbDone2 = cbWroteSome - cb1P ;
        {
        if( cbWroteSome >= cb1P )
    {
    else
    else if( cbWroteSome > cb1P + cb2P ) { BLAMMOiD( cbWroteSome ) ; }
    }
        if( pcbWroteP ) *pcbWroteP = cbWroteSome ;
    {
    if( cbWroteSome == cb1P + cb2P )

    }
        }
            }
                }
                    if( getNegAM( part.finger ) == FINGERnEG_jotFilePartC ) part.idjBack = idjPartCursor ;
                    jotFilePartC& part = *(jotFilePartC*)(const byteT*)pagePart ;
                {
                if( pagePart == sizeof( jotFilePartC ) )
                pageC pagePart = jotCanChange.readF( tinP , idjPartNew ) ;
            {

            }
                }
                    }
                        }
                            break ;
                            part.idjNext = idjPartNew ;
                        {
                        else
                        if( part.idjNext ) idjPartCursor = part.idjNext ;
                    {
                    else
                    if( getNegAM( part.finger ) != FINGERnEG_jotFilePartC ) break ;
                    jotFilePartC& part = *(jotFilePartC*)(const byteT*)pagePart ;
                {
                else
                if( pagePart != sizeof( jotFilePartC ) ) break ;
                pageC pagePart = jotCanChange.readF( tinP , idjPartCursor ) ;
            {
            for(;;)                                                                                     // INSERT idjPartNew INTO THE LEAF PART
        {
        if( !POOP )

        __Z( idjPartCursor ) ;

        }
            }
                }
                    }
                        }
                            break ;
                            idjPartCursor  = branch.idjPart ;
                        {
                        else
                        if( branch.idjNext ) idjBranchCursor = branch.idjNext ;
                    {
                    else
                    if( getNegAM( branch.finger ) != FINGERnEG_jotFileBranchC ) break ;
                    jotFileBranchC& branch = *(jotFileBranchC*)(const byteT*)pageBranch ;
                {
                else
                if( pageBranch != sizeof( jotFileBranchC ) ) break ;
                pageC pageBranch = jotCanChange.readF( tinP , idjBranchCursor ) ;
            {
            for(;;)                                                                                     // SET idjPartCursor TO POINT TO THE ROOT PART OF THE LEAF BRANCH
        {
        else
        }
            }
                if( getNegAM( branchOld.finger ) == FINGERnEG_jotFileBranchC ) idjPartCursor = branchOld.idjPart ;
                jotFileBranchC& branchOld = *(jotFileBranchC*)(const byteT*)pageBranchOld ;
            {
            if( pageBranchOld == sizeof( jotFileBranchC ) )
            pageC pageBranchOld = jotCanChange.readF( tinP , idjSoilOrBranchP ) ;

            __NZ( F(flagsP) & flJOTfILEScwRITE_REPLACEfILE ) ;
        {
        if( bIsBranch )
        ZE( countT , idjPartCursor ) ;
    {
    else
    }
        }
            }
                }
                    }
                        if( getNegAM( branchNew3.finger ) == FINGERnEG_jotFileBranchC ) branchNew3.idjBack = idjBranchCursor ;
                        jotFileBranchC& branchNew3 = *(jotFileBranchC*)(const byteT*)pageBranchNew ;
                    {
                    if( pageBranchNew == sizeof( jotFileBranchC ) )
                    pageC pageBranchNew = jotCanChange.readF( tinP , idjBranchNew ) ;
                {

                }
                    }
                        }
                            }
                                break ;
                                branchOld.idjNext = idjBranchNew ;
                            {
                            else
                            if( branchOld.idjNext ) idjBranchCursor = branchOld.idjNext ;
                        {
                        else
                        if( getNegAM( branchOld.finger ) != FINGERnEG_jotFileBranchC ) break ;
                        jotFileBranchC& branchOld = *(jotFileBranchC*)(const byteT*)pageBranch ;
                    {
                    else
                    if( pageBranch != sizeof( jotFileBranchC ) ) break ;
                    pageC pageBranch = jotCanChange.readF( tinP , idjBranchCursor ) ;
                {
                for(;;)                                                                                     // INSERT idjBranchNew INTO THE LEAF BRANCH

                countT idjBranchNew = jotCanChange.writeF( tinP , (byteT*)&branchNew , sizeof branchNew , 0 , 0 , flJOTcwRITE_null ) & ~NM_HIGH ;
                idjPartNew = 0 ;
                jotFileBranchC branchNew( tinP , idjPartNew ) ;
            {
            else
            }
                }
                    }
                        }
                            }
                                break ;
                                soil.idjNext = idjSoilNew ;
                            {
                            else
                            if( soil.idjNext ) idjSoilOrBranchP = soil.idjNext ;
                            if( !idjSoilRootOrNewBranch ) idjSoilRootOrNewBranch      = idjSoilOrBranchP     ;
                        {
                        else
                        if( getNegAM( soil.finger ) != FINGERnEG_jotFileSoilC ) break ;
                        jotFileSoilC& soil = *(jotFileSoilC*)(const byteT*)pageSoil ;
                    {
                    else
                    if( pageSoil != sizeof( jotFileSoilC ) ) break ;
                    pageC pageSoil = jotCanChange.readF( tinP , idjSoilOrBranchP ) ;
                {
                for(;;)                                                                                         // SET idjBranchCursor TO POINT TO THE ROOT BRANCH OF THE LEAF SOIL

                countT idjSoilNew = jotCanChange.writeF( tinP , (byteT*)&soil , sizeof soil , 0 , 0 , flJOTcwRITE_null ) & ~NM_HIGH ;
                jotFileSoilC soil( tinP , idjBranchNew ) ;

                countT idjBranchNew = jotCanChange.writeF( tinP , (byteT*)&branch , sizeof branch , 0 , 0 , flJOTcwRITE_null ) & ~NM_HIGH ;
                idjPartNew = 0 ;
                jotFileBranchC branch( tinP , idjPartNew ) ;
            {
            if( F(flagsP) & flJOTfILEScwRITE_REPLACEfILE )
        {
        else
        }
            }
                }
                    }
                        }
                            branchNew3.idjBack = idjSoilOrBranchP ;
                            branchNew3.idjNext = idjNextOld       ;
                        {
                        if( getNegAM( branchNew3.finger ) == FINGERnEG_jotFileBranchC )
                        jotFileBranchC& branchNew3 = *(jotFileBranchC*)(const byteT*)pageBranchNew ;
                    {
                    if( pageBranchNew == sizeof( jotFileBranchC ) )
                    pageC pageBranchNew = jotCanChange.readF( tinP , idjBranchNew ) ;
                {
                if( idjNextOld )

                }
                    }
                        }
                            else branchOld.idjNext = idjBranchNew ;
                            }
                                             branchOld.idjNext = idjBranchNew ;
                                idjNextOld = branchOld.idjNext ;
                            {
                            if( branchOld.idjNext )
                        {
                        if( getNegAM( branchOld.finger ) == FINGERnEG_jotFileBranchC )
                        jotFileBranchC& branchOld = *(jotFileBranchC*)(const byteT*)pageBranchOld ;
                    {
                    if( pageBranchOld == sizeof( jotFileBranchC ) )
                    pageC pageBranchOld = jotCanChange.readF( tinP , idjSoilOrBranchP ) ;
                {
                ZE( countT , idjNextOld ) ;

                }
                    idjSoilRootOrNewBranch = idjBranchNew = jotCanChange.writeF( tinP , (byteT*)&branchNew2 , sizeof branchNew2 , 0 , 0 , flJOTcwRITE_null ) & ~NM_HIGH ;
                    idjPartNew = 0 ;
                    jotFileBranchC branchNew2( tinP , idjPartNew ) ;
                {
                ZE( countT , idjBranchNew ) ;
            {
            if( !POOP )
            __NZ( F(flagsP) & flJOTfILEScwRITE_REPLACEfILE ) ;
        {
        else if( bIsBranch )
        }
            }
                }
                    if( getNegAM( branchNew.finger ) == FINGERnEG_jotFileBranchC ) branchNew.idjBack = idjSoilRootOrNewBranch ;
                    jotFileBranchC& branchNew = *(jotFileBranchC*)(const byteT*)pageBranchNew ;
                {
                if( pageBranchNew == sizeof( jotFileBranchC ) )
                pageC pageBranchNew = jotCanChange.readF( tinP , idjBranchNew ) ;
            {

            idjSoilRootOrNewBranch = jotCanChange.writeF( tinP , (byteT*)&soil , sizeof soil , 0 , 0 , flJOTcwRITE_null ) & ~NM_HIGH ;
            jotFileSoilC soil( tinP , idjBranchNew ) ;

            countT idjBranchNew = jotCanChange.writeF( tinP , (byteT*)&branchNew1 , sizeof branchNew1 , 0 , 0 , flJOTcwRITE_null ) & ~NM_HIGH ;
            idjPartNew = 0 ;
            jotFileBranchC branchNew1( tinP , idjPartNew ) ;
        {
        if( !idjSoilOrBranchP )
    {
    if( !( F(flagsP) & flJOTfILEScwRITE_APPENDpART ) )

    }
        }
            }
                }
                    }
                        }
                            ((tinNormalS&)tinP).pEther->traceF( tinP , T("jotFilesC::writeF / new mod puddle [time?Modified]:    ")+TT(soilPatch.time1Modified,soilPatch.time2Modified) ) ;
                            ((tinNormalS&)tinP).pEther->osTimeNowF( tinP , soilPatch.time1Modified , soilPatch.time2Modified ) ;
                        {
                        if( ((tinNormalS&)tinP).pEther )
                        soilPatch.time2Modified = soilPatch.time1Modified = 0 ;
                    {
                    if( getNegAM( soilPatch.finger ) == FINGERnEG_jotFileSoilC )
                    jotFileSoilC& soilPatch = *(jotFileSoilC*)(const byteT*)pageSoil ;
                {
                if( pageSoil == sizeof( jotFileSoilC ) )
                pageC pageSoil = jotCanChange.readF( tinP , idjDownSoil ) ;
            {
            if( idjDownSoil )

            }
                }
                    }
                        }
                            break ;
                            idjDownSoil = branchOld.idjDown ;
                        {
                        else
                        if( branchOld.idjBack ) idjbc = branchOld.idjBack ;
                    {
                    if( getNegAM( branchOld.finger ) == FINGERnEG_jotFileBranchC )
                    jotFileBranchC& branchOld = *(jotFileBranchC*)(const byteT*)pageBranch ;
                {
                else
                if( pageBranch != sizeof( jotFileBranchC ) ) break ;
                pageC pageBranch = jotCanChange.readF( tinP , idjbc ) ;
            {
            for(;;)
            ZE( countT , idjDownSoil ) ;
            countT idjbc = idjSoilOrBranchP ;                                         // WALK BACK AND DOWN AND PATCH THE TIME IN THE SOIL
        {
        if( bIsBranch )

        __NZ( !bIsBranch && !idjBranchCursor ) ;

        }
            }
                }
                    break ;

                    }
                        ((tinNormalS&)tinP).pEther->traceF( tinP , T("jotFilesC::writeF / new mod [time?Modified]:    ")+TT(soilMaybe.time1Modified,soilMaybe.time2Modified) ) ;
                        ((tinNormalS&)tinP).pEther->osTimeNowF( tinP , soilMaybe.time1Modified , soilMaybe.time2Modified ) ;
                    {
                    if( ((tinNormalS&)tinP).pEther )
                    soilMaybe.time2Modified = soilMaybe.time1Modified = 0 ;

                    idjBranchCursor = soilMaybe.idjBranch ;
                {
                else
                if( soilMaybe.idjNext ) idjSoilOrBranchP = soilMaybe.idjNext ;
                if( !idjSoilRootOrNewBranch ) idjSoilRootOrNewBranch = idjSoilOrBranchP ;
            {
            else
            else if( pageSoilOrBranch != sizeof( jotFileSoilC ) || getNegAM( soilMaybe.finger ) != FINGERnEG_jotFileSoilC ) break ;
            }
                break ;
                //U:: WALK BACK AND DOWN TO THE SOIL AND PATCH THE TIME
                bIsBranch = 1 ;
            {
            if( pageSoilOrBranch == sizeof( jotFileBranchC ) && getNegAM( branchMaybe.finger ) == FINGERnEG_jotFileBranchC )
            jotFileBranchC& branchMaybe        = *(jotFileBranchC*)(const byteT*)pageSoilOrBranch ;
            jotFileSoilC&     soilMaybe        =   *(jotFileSoilC*)(const byteT*)pageSoilOrBranch ;
            pageC             pageSoilOrBranch =    jotCanChange.readF( tinP , idjSoilOrBranchP ) ;
        {
        for(;;)                                                                                         // SET idjBranchCursor TO POINT TO THE ROOT BRANCH OF THE LEAF SOIL
    {
    if( idjSoilOrBranchP && !( F(flagsP) & flJOTfILEScwRITE_REPLACEfILE ) )
    ZE( countT , idjBranchCursor        ) ;
    ZE( countT , idjSoilRootOrNewBranch ) ;
    ZE( boolT  , bIsBranch              ) ;

    }
        idjPartNew = jotCanChange.writeF( tinP , (byteT*)&part , sizeof part , 0 , 0 , flJOTcwRITE_null ) & ~NM_HIGH ;
        jotFilePartC part( idjDataNew ) ;

        }
            __Z( idjDataNew ) ;
            idjDataNew = jotTarget.writeF( tinP , pb1P , cb1P , pb2P , cb2P , flagsWriteData , &cbWroteSome ) & ~NM_HIGH ;

            ;
                : flJOTcwRITE_null
                ? flJOTcwRITE_ALLoRsOME
            flagsT flagsWriteData = F(flagsP) & flJOTfILEScwRITE_ALLoRsOME
        {
        ZE( countT , idjDataNew ) ;
    {                                                                                                   // WRITE THE NEW PART
    ZE( countT , idjPartNew ) ;
    ZE( countT , cbWroteSome ) ;

    jotC& jotTarget = F(flagsP) & flJOTfILEScwRITE_TOcANcHANGE ? jotCanChange : jotNeverChanges ;

    if( pb2P && !cb2P ) cb2P = 1 + thirdC::c_strlenIF( tinP , pb2P ) ;
    if( pb1P && !cb1P ) cb1P = 1 + thirdC::c_strlenIF( tinP , pb1P ) ;

#if defined( NEVERdEFINED )

    }
        }
            }
                }
                    ether.traceF( tinP , T("\r\n\r\n") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

                    if( bOk ) base.reportF( tinP ) ;

                    }
                        ether.traceF( tinP , T("not                                    [cb]:    ")+TF2((countT)pagei,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_NOpREFIX ) ;
                    {
                    else
                    }
                        name.reportF( tinP ) ;
                        jotFileNameC& name = *(jotFileNameC*)&base ;
                        bOk = 1 ;
                    {
                    else if( getNegAM( base.finger ) == FINGERnEG_jotFileNameC )
                    }
                        soil.reportF( tinP ) ;
                        jotFileSoilC& soil = *(jotFileSoilC*)&base ;
                        bOk = 1 ;
                    {
                    else if( getNegAM( base.finger ) == FINGERnEG_jotFileSoilC )
                    }
                        branch.reportF( tinP ) ;
                        jotFileBranchC& branch = *(jotFileBranchC*)&base ;
                        bOk = 1 ;
                    {
                    else if( getNegAM( base.finger ) == FINGERnEG_jotFileBranchC )
                    }
                        part.reportF( tinP ) ;
                        jotFilePartC& part = *(jotFilePartC*)&base ;
                        bOk = 1 ;
                    {
                    if( getNegAM( base.finger ) == FINGERnEG_jotFilePartC )
                    ZE( boolT , bOk ) ;

                    jotFileBaseC& base = *(jotFileBaseC*)(const byteT*)pagei ;
                {
                else
                if( pagei < sizeof( jotFileBaseC ) ) ether.traceF( tinP , T("small                             [idjc,cb]:    ")+TF2(idjc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)pagei,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_NOpREFIX ) ;
                pageC pagei = jotCanChange.readF( tinP , idjc ) ;
            {
            ether.traceF( tinP , T("")+TF2(idjc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_NOpREFIX ) ;
        {
        for( countT idjc = 1 ; idjc <= cEltsCanChange ; idjc ++ )

        ether.traceF( tinP , T("\r\n\r\njotFilesC::reportF / cElementsF() [canChange,neverChanges]:    ")+TF2(cEltsCanChange,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cEltsNeverChanges,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n\r\n") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

        countT cEltsNeverChanges = jotNeverChanges.cElementsF() ;
        countT cEltsCanChange    =    jotCanChange.cElementsF() ;

        etherC& ether = *((tinNormalS&)tinP).pEther ;
    {
    if( ((tinNormalS&)tinP).pEther )

    }
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
/*1*/voidT jotFilesC::reportF( tinNormalS& tinP , countT idjP , const flagsT flagsP )/*1*/


/**/

*/
 pcbWroteP
  if flJOTfILEScwRITE_APPENDpART then i create a new part only
  if not flJOTfILEScwRITE_APPENDpART then i create a new branch
  if flJOTfILEScwRITE_REPLACEfILE then i create a new soil at the end of the soil linked list
 flagsP
 idjSoilOrBranchP
parameters
i either create a new branch at the end of the branch linked list or create a new part at the end of a part linked list or replace the file by creating a new soil at the end of the soil linked list
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
