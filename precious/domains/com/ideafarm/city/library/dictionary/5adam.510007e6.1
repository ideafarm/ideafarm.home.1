
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

}
    }
        }
            time2AOK = time1AOK = 0 ;      // THIS WILL CAUSE THE NEXT ITERATION TO PROCEED AFTER ONLY NAPPING WO TICK
            etThread.traceF( tinP , T("exception: this cycle was aborted") ) ;
            if( cYearsInParallel > 1 && 1 == decv02AM( cYearsInParallel ) ) cYearsInParallel = 1 ;  // REDUCE cYearsInParallel BUT NOT BELOW 1
        {
        if( bAbort )

        }
            }
                //etThread.osSuspendF( tinP ) ;
                //etThread.traceF( tinP , T("ok.  hibernating") ) ;

                }
                    }
                        THREADmODE2rESTORE
                        while( cExecutiveHealYear ) thirdC::dosSleepWinkIF( tinP ) ;
                        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                    {

                    }
                        while( ~hStYearToHeal ) ;
                        }
                            }
                                }
                                    break ;
                                    bAbort = 1 ;
                                    etThread.traceF( tinP , T("exception: could not launch thread tmExecutiveHealYearF") ) ;
                                    dec02AM( cExecutiveHealYear ) ;
                                    POOPR
                                {
                                if( POOP )
                                ((tinNormalS&)tinP).pEtScratch->osThreadF( TaRG3fLAGScBtLS( tmExecutiveHealYearF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cExecutiveHealYear , (countT)psttYear , (countT)&psttzArchive , (countT)&swsPathToArchivesByArchiveName , (countT)&bAbort , (countT)&stJob ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            inc02AM( cExecutiveHealYear ) ;

                            etThread.strMakeF( tinP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                            ZE( strokeS* , psttYear ) ;

                            etThread.traceF( tinP , T("year to heal:    ")+T(psttzYear) ) ;
                            strokeS* psttzYear = (strokeS*)stYearToHeal.upF( tinP , hStYearToHeal ) ;       //PROCESSES YEARS BEGINNING WITH MOST RECENT  (A:ASSUME: CURRENT YEARS ARE IN MOST NEED OF HEALING SINCE FILES ARE ADDED AND MODIFIED)

                            }
                                THREADmODE2rESTORE
                                while( cYearsInParallel == cExecutiveHealYear ) thirdC::dosSleepWinkIF( tinP ) ;
                                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                            {
                        {
                        do
                        handleC hStYearToHeal( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( !bAbort )
                    ZE( countT , cExecutiveHealYear ) ;

                    }
                        }
                            }
                                }
                                    }
                                        break ;
                                        bAbort = 1 ;
                                        etThread.delF( tinP , psttYear ) ;
                                        etThread.traceF( tinP , T("exception: duplicate year [psttYear]:    ")+T(psttYear) ) ;                        
                                    {
                                    if( !idSlot ) //SHOULD BE IMPOSSIBLE
                                    stYearToHeal.sinkF( tinP , idSlot , psttYear , flSTACKsINK_UNIQUE ) ;
                                    ZE( countT , idSlot ) ;
                                    etThread.strMakeF( tinP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                                    ZE( strokeS* , psttYear ) ;
                                {
                                if( tally > 1 )
                                countT tally = swTallyByYear ;
                                psttzYear = (strokeS*)swTallyByYear.leverF( tinP , idf ) ;
                            {
                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                            countT cFlavors = swTallyByYear.cFlavorsF( tinP ) ;
                        {
                        if( !bAbort )

                        while( ~hSwsPathToArchives ) ;
                        }
                            etThread.delF( tinP , pstt1PathToYear ) ;
                            }
                                //etThread.traceF( tinP , T("[tYear,tally]:    ")+tYear+tb4+TF2((countT)swTallyByYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                swTallyByYear ++ ;
                                psttzYear = tYear ;

                                }
                                    etThread.delF( tinP , psttYear ) ;
                                    tYear = T(psttYear) ;
                                    etThread.strWordF( tinP , psttYear , psttc1 , sttq , sttSlash , - 2 ) ; ___( psttYear ) ;
                                    ZE( strokeS* , psttYear ) ;
                                {
                                TN( tYear , "" ) ;
                            {
                            FORsTRINGSiN1( pstt1PathToYear )
                            etThread.strConvertToLowerCaseF( tinP , pstt1PathToYear ) ;
                            }
                                }
                                    break ;
                                    bAbort = 1 ;
                                    etThread.delF( tinP , pstt1PathToYear ) ;
                                    etThread.traceF( tinP , T("exception: diskFindFileOrDirF failed [tPathToArchive]:    ")+tPathToArchive ) ;
                                    POOPR
                                {
                                if( POOP )
                                ((tinNormalS&)tinP).pEtScratch->diskFindFileOrDirF( tinP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            patternC pat( tinP , etThread , tYearPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                            ZE( strokeS* , pstt1PathToYear ) ;

                            //etThread.traceF( tinP , T("new code [tPathToArchive]:    ")+tPathToArchive ) ;
                            TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchive)+tSlash ;
                            strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveName.downF( tinP , hSwsPathToArchives ) ;
                        {
                        do
                        handleC hSwsPathToArchives( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        strokeS sttSlash( '/' ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

                        switchC swTallyByYear( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzYear ) ;
                        ZE( strokeS* , psttzYear ) ;
                    {
                    stackC stYearToHeal( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

                    // FOR EACH YEAR FOLDER (ALL YEARS FOR THIS ARCHIVE NAME (EXAMPLE: ALL YEAR PATHS FOR EVERY YEAR FOR "wo.ideafarm"), LAUNCH A FILE RECORD COLLECTION THREAD
                {
                if( cArchivesWithThisName > 1 )
                etThread.traceF( tinP , T("[cArchivesWithThisName,archive]:    ")+TF2(cArchivesWithThisName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzArchive) ) ;
                swsPathToArchivesByArchiveName.ungrabF( tinP ) ;
                countT cArchivesWithThisName = swsPathToArchivesByArchiveName ;
                psttzArchive = (strokeS*)swsPathToArchivesByArchiveName.leverF( tinP , idf ) ;
                swsPathToArchivesByArchiveName.grabF( tinP , TAG( TAGiDnULL ) ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )    // FOR EACH ARCHIVE NAME (EXAMPLE: "wo.ideafarm")
            swsPathToArchivesByArchiveName.ungrabF( tinP ) ;
            countT cFlavors = swsPathToArchivesByArchiveName.cFlavorsF( tinP ) ;
            swsPathToArchivesByArchiveName.grabF( tinP , TAG( TAGiDnULL ) ) ;
            //TN( tYearPattern , "?" "?" "?" "?" "/" ) ;                                                              //20221118@1747: "????/" PROUCES A SPURIOUS COMPILER ERROR INVOLVING TRIGRAPH
            TN( tYearPattern , "1999/" ) ;
        {
        if( !bAbort )

        }
            }
                bAbort = 1 ;
                etThread.traceF( tinP , T("exception: could not launch thread tmDoJobF") ) ;
                POOPR
            {
            if( POOP )
            ((tinNormalS&)tinP).pEtScratch->osThreadF( TaRG3fLAGScBtLS( tmDoJobF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&bAbort , (countT)&stJob ) ;
            SCOOPS
        {
        IFsCRATCH

        //stJob << (byteT*)0 ; pbDebug = (byteT*)&stJob[ - 1 ] ; etThread.traceF( tinP , TF2((countT)pbDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; new( 0 , tinP , pbDebug , sizeof( jobS ) ) jobS( tinP , etThread , IDtYPEjOB_NULL , T("4-to") , T("4-from") ) ;
        //stJob << (byteT*)0 ; pbDebug = (byteT*)&stJob[ - 1 ] ; etThread.traceF( tinP , TF2((countT)pbDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; new( 0 , tinP , pbDebug , sizeof( jobS ) ) jobS( tinP , etThread , IDtYPEjOB_NULL , T("3-to") , T("3-from") ) ;
        //stJob << (byteT*)0 ; pbDebug = (byteT*)&stJob[ - 1 ] ; etThread.traceF( tinP , TF2((countT)pbDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; new( 0 , tinP , pbDebug , sizeof( jobS ) ) jobS( tinP , etThread , IDtYPEjOB_NULL , T("2-to") , T("2-from") ) ;
        //stJob << (byteT*)0 ; pbDebug = (byteT*)&stJob[ - 1 ] ; etThread.traceF( tinP , TF2((countT)pbDebug,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; new( 0 , tinP , pbDebug , sizeof( jobS ) ) jobS( tinP , etThread , IDtYPEjOB_NULL , T("1-to") , T("1-from") ) ;
        //ZE( byteT* , pbDebug ) ;
        //TO TEST

        stackC stJob( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_BLOB | flSTACKc_ALLOWzE , sizeof( jobS ) ) ;

        swsPathToArchivesByArchiveName.lockIfF( tinP ) ;
        }
            }
                etThread.delF( tinP , pstt1Archives ) ;
                }
                    }
                        }
                            swsPathToArchivesByArchiveName.sinkF( tinP , countTC() , psttPathArchives ) ;                           // EXAMPLE: "///c/ipdos.arhives/"

                            psttzArchive = tArchive ;

                            etThread.traceF( tinP , T("    [tPathArchives,tArchive]:    ")+T(psttPathArchives)+tb4+tArchive ) ;

                            }
                                etThread.delF( tinP , psttShorter ) ;
                                tArchive = T(psttShorter) ;
                                etThread.strSubstringF( tinP , psttShorter , idf , idl , tArchiveSlash ) ; ___( psttShorter ) ;
                                ZE( strokeS* , psttShorter ) ;
                            {
                            if( idl )
                            countT idl = tArchiveSlash.csF( tinP ) ? tArchiveSlash.csF( tinP ) - 1 : 0 ;
                            countT idf = 1 ;
                            TN( tArchive , "" ) ;                                                                                   // EXAMPLE: "wo.ideafarm"

                            }
                                etThread.delF( tinP , psttArchiveSlash ) ;
                                tArchiveSlash = T(psttArchiveSlash) ;
                                etThread.strBisectF( tinP , psttPathArchives , psttArchiveSlash , psttc1 , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathArchives ) ; ___( psttArchiveSlash ) ;
                                ZE( strokeS* , psttArchiveSlash ) ;
                            {
                            TN( tArchiveSlash , "" ) ;                                                                              // EXAMPLE: "wo.ideafarm/"
                            ZE( strokeS* , psttPathArchives ) ;                                                                     // EXAMPLE: "///c/ipdos.arhives/"

                            etThread.traceF( tinP , T("processing archive ")+T(psttc1) ) ;                                          // EXAMPLE: "///c/ipdos.arhives/wo.ideafarm/"
                        {
                        FORsTRINGSiN1( pstt1Archives )
                    {
                    if( !bAbort )

                    }
                        }
                            bAbort = 1 ;
                            etThread.traceF( tinP , T("exception:  diskFindFileOrDirF [tLikeArchives]:    ")+tLikeArchives ) ;
                            POOPR
                        {
                        if( POOP )
                        RETRYsCR( 8 , diskFindFileOrDirF( tinP , pstt1Archives , tLikeArchives ) ) ___( pstt1Archives ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                {
                ZE( strokeS* , pstt1Archives ) ;
            {
            TN( tLikeArchives , "///?/ipdos.archives/" ) ;
        {
        switchStackC swsPathToArchivesByArchiveName( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzArchive , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
        ZE( strokeS* , psttzArchive ) ;
        ZE( boolT , bAbort ) ;
        // LOAD swsPathToArchivesByArchiveName WITH VALUES LIKE "///c/ipdos.arhives/" SWITCHED ON VALUES LIKE "wo.ideafarm"
    {
    if( !ether )

    }
        }
            etThread.traceF( tinP , T("napped  for a half minute") ) ;
//U::            ++ s ; ether.osSleepF( tinP , TICK >> 3 ) ;
            cNaps ++ ;
            etThread.traceF( tinP , T("napping for a half minute") ) ;
        {
        else
        break ;
        )
            (  bWaitWoDay && time2E )            // A DAY'S NAP IS     REQUIRED AND I'VE NAPPED FOR A DAY
            ||
            ( !bWaitWoDay && cNaps  )            // A DAY'S NAP IS NOT REQUIRED AND I'VE NAPPED WO TIME
        (
        if

        etThread.osTimeSubtractF( tinP , time1E , time2E , time1AOK , time2AOK ) ;
        etThread.osTimeNowF( tinP , time1E , time2E ) ;
        ZE( sCountT , time2E ) ;
        ZE( countT  , time1E ) ;

        boolT bWaitWoDay = !!time2AOK ;
    {
    while( !ether )
    ZE( countT , cNaps ) ;
{
while( !ether )
ZE( sCountT , time2AOK ) ;
ZE( countT  , time1AOK ) ;
sleepC s( tinP , TAG( TAGiDnULL ) ) ;

TN( tSlash , "/" ) ;
TN( tb4    , "    " ) ;

TODO

DONE( tmExecutiveHealYearF )
}
    dec02AM( cExecutiveHealYearP ) ;
    }
        etThread.traceF( tinP , T("done for archive ")+T(psttzArchiveP) ) ;

        DEL( pSwsMetaByShort ) ;
        grabCutoffNext.ungrabF( tinP ) ;
        etThread.delF( tinP , postShortCutoff ) ;
        grabCutoffNext.grabF( tinP , TAG( TAGiDnULL ) ) ;

        }
            cCutoffNominatorsDone = 0 ;
            //etThread.traceF( tinP , T("(end heal loop) resetting cCutoffNominatorsDone to start meta collection") ) ;

            pSwsMetaByShort->ungrabF( tinP ) ;

            //etThread.traceF( tinP , T("after calling freeAllF [cFlavors]:    ")+TF2(pSwsMetaByShort->cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            pSwsMetaByShort->freeAllF( tinP ) ;

            }
                }
                    while( ~hSwsOuter ) ;
                    }
                        DELzOMBIE( pfmOuter ) ;

                        }
                            DELzOMBIE( pd ) ;
                            imageCompareS* pd = picOuter + offd ;
                        {
                        for( countT offd = 0 ; offd < cResultStructsNeeded ; offd ++ )

                        fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + cResultStructsNeeded ) ;
                        imageCompareS* picOuter  = (imageCompareS*)&pSwsMetaByShort->downF( tinP , hSwsOuter ) ;
                    {
                    do
                    handleC hSwsOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( cFiles )
                countT cFiles = *pSwsMetaByShort ;
                postzShort = (osTextT*)pSwsMetaByShort->leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cShortFileNames ; idf ++ )
            
            //etThread.traceF( tinP , T("deleting metadata") ) ;

            }
                while( !ether && bCompareFail ) ;
                }
                    }
                        }
                            break ;
                            bAbortP = 1 ;
                            etThread.traceF( tinP , T("exception: compare failed 8 times [tShort]:    ")+tShort ) ;
                        {
                        if( ++ cCompareFail == 8 )
                    {
                    if( bCompareFail )

                    //etThread.traceF( tinP , T("processed  [tShort,bCompareFail]:    ")+tShort+tb4+TF2(bCompareFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    ++ cNamesProcessed ;

                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // ****                                                                                                                                  *******************************************************************
                    // ****  END:    COMPARE ALL COPIES OF THIS SHORT FILE NAME.  THIS IS RETRIED UNTIL ALL COMPARISONS COMPLETE WITHOUT AN EXCEPTION EVENT  *******************************************************************
                    // ****                                                                                                                                  *******************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************

                    }
                        // *********************************************************************************************************************************************************************************************************
                        // ****                *************************************************************************************************************************************************************************************
                        // ****  END:    HEAL  *************************************************************************************************************************************************************************************
                        // ****                *************************************************************************************************************************************************************************************
                        // *********************************************************************************************************************************************************************************************************

                        }
                            }
                                }
                                    etThread.delF( tinP , psttFrom ) ;
                                    etThread.delF( tinP , psttTo   ) ;

                                    stJobP.ungrabF( tinP ) ;
                                    stJobP << (byteT*)0 ; new( 0 , tinP , (byteT*)&stJobP[ - 1 ] , sizeof( jobS ) ) jobS( tinP , etThread , IDtYPEjOB_COPY , psttTo , psttFrom ) ;
                                    stJobP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                                    //etThread.traceF( tinP , T("new      [psttTo,psttFrom]:    ")+TF2((countT)psttTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)psttFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    //etThread.traceF( tinP , T("copying [idFrom,new,old,idFrom]:    ")+TF2(idFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttTo)+tb4+T(psttFrom) ) ;

                                    etThread.strMakeF( tinP , LF , psttFrom , (strokeS*)stFrom[ idFrom ] ) ; ___( psttFrom ) ;
                                    ZE( strokeS* , psttFrom ) ;

                                    countT idFrom = 1 + ( cDone ++ % cFrom ) ;

                                    stTo >> psttTo ;
                                    ZE( strokeS* , psttTo ) ;
                                {
                                while( stTo )
                                ZE( countT , cDone ) ;
                                countT cFrom = stFrom ;

                                while( ~hStPathToYear ) ;
                                }
                                    }
                                        if( !idSlot ) etThread.delF( tinP , psttLong ) ;
                                        stTo.sinkF( tinP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ;
                                        ZE( countT , idSlot ) ;
                                        //etThread.traceF( tinP , T("sinking to stTo 2 [long]:    ")+T(psttLong) ) ;
                                    {
                                    else
                                    if( stFrom( psttLong ) ) etThread.delF( tinP , psttLong ) ;

                                    etThread.strMakeF( tinP , LF , psttLong , T(psttPathToYear)+tShort ) ; ___( psttLong ) ;
                                    ZE( strokeS* , psttLong ) ;

                                    strokeS* psttPathToYear = (strokeS*)stPathToYear.downF( tinP , hStPathToYear ) ;
                                {
                                do
                                handleC hStPathToYear( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                while( ~hStUnique ) ;
                                }
                                    }
                                        while( ~hSwsInner ) ;
                                        }
                                            }
                                                if( !idSlot ) etThread.delF( tinP , psttLong ) ;
                                                }
                                                    stTo.sinkF( tinP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                    //etThread.traceF( tinP , T("sunk into stTo [cPlatesBefore,long]:    ")+TF2(stTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                {
                                                else
                                                }
                                                    stFrom.sinkF( tinP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                    //etThread.traceF( tinP , T("sunk into stFrom [cPlatesBefore,long]:    ")+TF2(stFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                {
                                                if( bYoungestNotAlone && bWinner )
                                                ZE( countT , idSlot ) ;

                                                etThread.strMakeF( tinP , LF , psttLong , T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ) ; ___( psttLong ) ;
                                                ZE( strokeS* , psttLong ) ;
                                            {
                                            if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) )

                                            }
                                                }
                                                    break ;
                                                    bMatchImage = 0 ;
                                                {
                                                if( picUnique[ offc ] - picInner[ offc ] )
                                            {
                                            for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ )
                                            boolT bMatchImage = 1 ;

                                            //picInner->traceF( tinP , T("inner :    ") ) ;
                                            fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                            imageCompareS* picInner  = (imageCompareS*)&pSwsMetaByShort->downF( tinP , hSwsInner ) ;
                                        {
                                        do
                                        handleC hSwsInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {

                                    //pfmUnique->traceF( tinP , stPathToYear , T(bYoungestNotAlone?"reporting tallies (youngestNotAlone):    ":"reporting tallies            (other):    ") ) ;

                                    //etThread.traceF( tinP , T("[bYoungestNotAlone,bWinner,cVotes,cVotesMax]:    ")+TF2(bYoungestNotAlone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bWinner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pfmUnique->cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cVotesMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    boolT bWinner           = pfmUnique->cVotes         == cVotesMaxYoungestNotAlone      ;
                                    boolT bYoungestNotAlone = pfmUnique->timeModRounded == timeModRoundedYoungestNotAlone ;

                                    //for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ ) picUnique[ offc ].traceF( tinP , T("reporting tallies:    ") ) ;

                                    //picUnique->traceF( tinP , T("unique:    ") ) ;
                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hStUnique ) ;
                                {
                                do
                                handleC hStUnique( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                stackC stTo(     tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                                stackC stFrom(   tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                            {
                            else
                            }
                                while( !bAbortP && ~hSwsInner ) ;
                                }
                                    etThread.delF( tinP , psttLong        ) ;
                                    etThread.delF( tinP , psttLongRejects ) ;

                                    stJobP.ungrabF( tinP ) ;
                                    stJobP << (byteT*)0 ; new( 0 , tinP , (byteT*)&stJobP[ - 1 ] , sizeof( jobS ) ) jobS( tinP , etThread , IDtYPEjOB_MOVEuNIQUE , psttLongRejects , psttLong ) ;
                                    stJobP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                                    etThread.strReplaceF( tinP , psttLongRejects , psttLong , tPatArchives , tPatRejects ) ; ___( psttLongRejects ) ;
                                    ZE( strokeS* , psttLongRejects ) ;

                                    etThread.strMakeF( tinP , LF , psttLong , T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ) ; ___( psttLong ) ;
                                    ZE( strokeS* , psttLong ) ;

                                    fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                    imageCompareS* picInner  = (imageCompareS*)&pSwsMetaByShort->downF( tinP , hSwsInner ) ;
                                {
                                do
                                handleC hSwsInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                etThread.traceF( tinP , T("no, or too many (more than 1), winners (authoritative copies) so i will reject all copies [file]")+tShort ) ;
                            {
                            if( !cWinners || cWinners > 1 )

                            }
                                while( ~hSt ) ;
                                }
                                    cWinners ++ ;
                                    )
                                        pfmUnique->cVotes == cVotesMaxYoungestNotAlone
                                        &&
                                        timeModRoundedYoungestNotAlone == pfmUnique->timeModRounded
                                    (
                                    if

                                    //picUnique->traceF( tinP , T("unique:    ") ) ;
                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                                {
                                do
                                handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( cVotesMaxYoungestNotAlone )        // IF ALL ARE ALONE THEN THERE WILL BE NO WINNER
                            ZE( countT , cWinners ) ;

                            // RULE; TO WIN, A SLOT MUST HAVE A "YOUNGEST NOT ALONE" AGE AND BE "NOT ALONE" AND HAVE THE MAXIMUM VOTES FOR SLOTS YOUNGEST AND NOT ALONE
                            //P:PERSONALITY: RULES FOR "WINNING": A stRecUnique SLOT "WINNING" MEANS THAT THE SLOT IS DEEMED TO BE AN AUTHORITATIVE IMAGE FOR THE FILE

                            }
                                while( ~hSt ) ;
                                }
                                    }
                                        if( pfmUnique->cVotes > 1 && cVotesMaxYoungestNotAlone < pfmUnique->cVotes ) cVotesMaxYoungestNotAlone = pfmUnique->cVotes ;
                                    {
                                    if( timeModRoundedYoungestNotAlone == pfmUnique->timeModRounded )

                                    }
                                        if(                          cVotesMaxYoungest         < pfmUnique->cVotes ) cVotesMaxYoungest         = pfmUnique->cVotes ;
                                    {
                                    if( timeModRoundedYoungest == pfmUnique->timeModRounded )

                                    //picUnique->traceF( tinP , T("unique:    ") ) ;
                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                                {
                                do
                                handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( timeModRoundedYoungestNotAlone )        // IF ALL ARE ALONE THEN THERE WILL BE NO WINNER
                            ZE( countT , cVotesMaxYoungestNotAlone ) ;
                            ZE( countT , cVotesMaxYoungest ) ;

                            }
                                while( ~hSt ) ;
                                }
                                    if( pfmUnique->cVotes > 1 && timeModRoundedYoungestNotAlone < pfmUnique->timeModRounded ) timeModRoundedYoungestNotAlone = pfmUnique->timeModRounded ;

                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                                {
                                do
                                handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            ZE( countT , timeModRoundedYoungestNotAlone ) ;
                            // SET timeModRoundedYoungestNotAlone

                            }
                                while( ~hSt ) ;
                                }
                                    while( ~hSwsOuter ) ;
                                    }
                                        if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) ) pfmUnique->cVotes ++ ;

                                        }
                                            }
                                                break ;
                                                bMatchImage = 0 ;
                                            {
                                            if( picUnique[ offc ] - picInner[ offc ] )
                                        {
                                        for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ )
                                        boolT bMatchImage = 1 ;

                                        //}
                                        //    pfmInner->traceF( tinP , stPathToYear , T("inner : ") ) ;
                                        //    picInner->traceF( tinP , T("inner :    ") ) ;
                                        //{
                                        //if( bChatter )
                                        fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                        imageCompareS* picInner  = (imageCompareS*)&pSwsMetaByShort->downF( tinP , hSwsOuter ) ;
                                    {
                                    do
                                    handleC hSwsOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                    if( timeModRoundedYoungest < pfmUnique->timeModRounded ) timeModRoundedYoungest = pfmUnique->timeModRounded ;

                                    //}
                                    //    pfmUnique->traceF( tinP , stPathToYear , T("unique: ") ) ;
                                    //    picUnique->traceF( tinP , T("unique:    ") ) ;
                                    //{
                                    //if( bChatter )
                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                                {
                                do
                                handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            ZE( countT , timeModRoundedYoungest ) ;
                            // TALLY cVotes AND SET timeModRoundedYoungest

                            }
                                bChatter = 1 ;
                                etThread.traceF( tinP , T("lengths or times or images differ [tShort]:    ")+tShort ) ;
                            {
                            if( stRecUnique > 1 )
                            ZE( boolT , bChatter ) ;
                        {
                        else                            // EVEN IF THERE IS ONLY WO PLATE, THERE IS STILL WORK TO DO BECAUSE THE FILE MIGHT NEED TO BE COPIED TO DESTINATIONS THAT DON'T HAVE IT
                        }
                            break ;
                            bAbortP = 1 ;
                            etThread.traceF( tinP , T("exception: stRecUnique is empty") ) ;
                        {
                        if( !stRecUnique ) //SHOULD  BE IMPOSSIBLE

                        while( ~hSwsOuter ) ;
                        do stRecUnique.sinkF( tinP , countTC() , (byteT*)&pSwsMetaByShort->downF( tinP , hSwsOuter ) , flSTACKsINK_UNIQUE , subtractFileMetaF ) ;
                        stackC stRecUnique( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , stPathToYear * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ;
                        handleC hSwsOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                        // *********************************************************************************************************************************************************************************************************
                        // ****                *************************************************************************************************************************************************************************************
                        // ****  BEGIN:  HEAL  *************************************************************************************************************************************************************************************
                        // ****                *************************************************************************************************************************************************************************************
                        // *********************************************************************************************************************************************************************************************************
                    {
                    if( !bCompareFail && !ether && cCopies > 1 )
                    //etThread.traceF( tinP , T("[cFound,file]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postzShort) ) ;

                    // PHASE 4: COPY TO ALL ARCHIVE CONTAINERS THAT DO NOT HAVE A COPY OF THIS FILE NAME
                    // PHASE 3: OVERWRITE ALL COPIES THAT DO NOT MATCH THIS UNIQUE META
                    // PHASE 2: IS THIS UNIQUE META VERIFIED (cVotes > 1)?
                    // PHASE 1: IDENTIFY THE UNIQUE META WITH THE LATEST FILE DATE
                    // HEALING ACTION HAS PHASES
                    // COMPARE AND FILE META FOR THIS FILE ARE SET AND READY FOR ANALYSIS AND HEALING ACTION
                    // THESE COMMENTS ARE OBSOLETED BY ACTUAL CODE WHICH CONTRADICTS THEM

                    while( !ether && ~hSwsOuter ) ;
                    }
                        if( bCompareFail ) break ;

                        // *********************************************************************************************************************************************************************************************************
                        // ****                                      ***************************************************************************************************************************************************************
                        // ****  END:    FOR EACH COPY OF THIS FILE  ***************************************************************************************************************************************************************
                        // ****                                      ***************************************************************************************************************************************************************
                        // *********************************************************************************************************************************************************************************************************

                        etThread.delF( tinP ,            pcBitsShiftLeftHeInMine ) ;
                        etThread.delF( tinP ,            pcBitsShiftLeftMeInHis  ) ;
                        etThread.delF( tinP , *(byteT**)&ppIdResultHeInMine      ) ;
                        etThread.delF( tinP , *(byteT**)&ppIdResultMeInHis       ) ;
                        etThread.delF( tinP ,            pcbwInner               ) ;
                        etThread.delF( tinP , *(byteT**)&ppbwInner               ) ;

                        }
                            }
                                etThread.delF( tinP , *(byteT**)&pfwsInner ) ;

                                etThread.delF( tinP , pEqual ) ;
                                }
                                    }
                                        //etThread.traceF( tinP , T(pEqual[offo]?"        set other and myself to BITSrESULT_EQUAL because images match [offo]:    ":"        set other and myself to BITSrESULT_NOTeQUAL because images differ [offo]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                        }
                                            //etThread.traceF( tinP , T("after  [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                            *ppIdResultMeInHis[  offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftMeInHis[  offo ] ;
                                            *ppIdResultHeInMine[ offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftHeInMine[ offo ] ;
                                            //etThread.traceF( tinP , T("before [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                        {
                                        else
                                        }
                                            *ppIdResultMeInHis[  offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftMeInHis[  offo ] ;
                                            *ppIdResultHeInMine[ offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftHeInMine[ offo ] ;
                                        {
                                        if( pEqual[ offo ] )
                                    {
                                    for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ )
                                {
                                if( !bCompareFail )

                                THREADmODE2rESTORE
                                }
                                    //etThread.delF( tinP , *(byteT**)&pfwsOuter ) ;
                                    //etThread.traceF( tinP , T("del [pfwsOuter]:    ")+TF3((countT)pfwsOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;

                                    }
                                        }
                                            bCompareFail = 1 ;
                                            etThread.traceF( tinP , T("exception: could not dt pfwsOuter [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                                            POOPR
                                        {
                                        if( POOP )
                                        DEL( pfwsOuter ) ;
                                        SCOOPS
                                    {

                                    }
                                        bAbortP = 1 ;
                                        etThread.traceF( tinP , T("exception [cbUsed,cbDone]:    ")+TT(pcbUsed[0],pcbUsed[1])+tb4+TT(pcbDone[0],pcbDone[1])+tb4+tLongOuter ) ;
                                        countT* pcbDone = (countT*)&cbDone ;
                                        countT* pcbUsed = (countT*)&pfmOuter->cbUsed ;
                                    {
                                    if( !bCompareFail && !ether && cbDone != pfmOuter->cbUsed ) //SHOULD BE IMPOSSIBLE

                                    }
                                        cbDone += cbwOuter ;

                                        if( bCompareFail ) break ;

                                        }
                                            }
                                                pcbwInner[ offi ] = 0 ;  // TELLS  TO GET ANOTHER WINDOW
                                                ppbwInner[ offi ] = 0 ;

                                                }
                                                    }
                                                        thirdC::dosSleepWinkIF( tinP ) ;
                                                        etThread.traceF( tinP , T("exception while trying to access memory for a mapped file.  will retry [idWindow,idTry]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    {
                                                    else
                                                    }
                                                        break;
                                                        }
                                                            //etThread.traceF( tinP , T("images match between unique and inner [idWindow,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        {
                                                        else
                                                        }
                                                            //etThread.delF( tinP , psttGen ) ;
                                                            //etThread.traceF( tinP , T("wrote inner [gen]:    ")+T(psttGen) ) ;
                                                            //etThread.boxPutGenerationF( tinP , psttGen , tLikeInner+TF3(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) , TUCK , ppbwInner[ offi ] , cbwOuter ) ; ___( psttGen ) ;

                                                            //etThread.delF( tinP , psttGen ) ;
                                                            //etThread.traceF( tinP , T("wrote outer [gen]:    ")+T(psttGen) ) ;
                                                            //etThread.boxPutGenerationF( tinP , psttGen , tLikeOuter , TUCK , pbwOuter , cbwOuter ) ; ___( psttGen ) ;
                                                            //ZE( strokeS* , psttGen ) ;

                                                            pEqual[ offi ] = 0 ;
                                                            etThread.traceF( tinP , T("difference detected between unique and inner [idWindow,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        {
                                                        if( etThread.memCompareF( tinP , pbwOuter , ppbwInner[ offi ] , cbwOuter ) )
                                                        //etThread.traceF( tinP , T("attempting to compare images [idWindow,idTry,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    {
                                                    if( !_restart )

                                                    idTry ++ ;
                                                    _restart.flags |= flRESTARTc_QUIET ;
                                                    RESTART
                                                {
                                                while( !ether )
                                                ZE( countT , idTry ) ;
                                            {
                                            else
                                            }
                                                break ;
                                                bDone = 1 ;
                                                //etThread.traceF( tinP , T("done inspecting images [idWindow]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            if( !pbwOuter || !cbwOuter )

                                            }
                                                break ;  // REDO THIS SHORT NAME FROM THE BEGINNING
                                                bCompareFail = 1 ;
                                                etThread.traceF( tinP , T("byte by byte comparison failed [tLongOuter]:    ")+tLongOuter ) ;
                                            {
                                            )
                                                  cbwOuter !=   pcbwInner[ offi ]
                                                ||
                                                !!cbwOuter != !!pcbwInner[ offi ]
                                                ||
                                                !!pbwOuter != !!ppbwInner[ offi ]
                                            (
                                            if

                                            //etThread.traceF( tinP , T("fed this [(countT)ppbwInner[offi],ppbwInner[offi]]:    ")+TF3((countT)ppbwInner[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+T(ppbwInner[offi]) ) ;

                                            }
                                                }
                                                    break ;  // REDO THIS SHORT NAME FROM THE BEGINNING
                                                    bCompareFail = 1 ;
                                                    etThread.traceF( tinP , T("exception:  pfwsInner[ offi ].getF [tLongOuter]:    ")+tLongOuter ) ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                RETRY( 8 , ( ppbwInner[ offi ] = 0 , pcbwInner[ offi ] = 0 , pfwsInner[ offi ].getF( tinP , ppbwInner[ offi ] , pcbwInner[ offi ] ) ) ) ;
                                                SCOOPS
                                            {
                                            IFsCRATCH
                                        {
                                        for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )

                                        }
                                            }
                                                break ;  // REDO THIS SHORT NAME FROM THE BEGINNING
                                                bCompareFail = 1 ;
                                                etThread.traceF( tinP , T("exception:  pfwsOuter->getF [tLongOuter]:    ")+tLongOuter ) ;
                                                POOPR
                                            {
                                            if( POOP )
                                            RETRY( 8 , ( pbwOuter = 0 , cbwOuter = 0 , pfwsOuter->getF( tinP , pbwOuter , cbwOuter ) ) )
                                            SCOOPS
                                        {
                                        IFsCRATCH
                                        ZE( countT , cbwOuter ) ;
                                        ZE( byteT* , pbwOuter ) ;

                                        TN( tLikeInner , "///ideafarm/tmp/debug.inner." ) ; tLikeInner += TF3(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot ;
                                        TN( tLikeOuter , "///ideafarm/tmp/debug.outer." ) ; tLikeOuter += TF3(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;

                                        idWindow ++ ;
                                    {
                                    while( !bCompareFail && !ether && !bDone )
                                    ZE( countT , idWindow ) ;
                                    ZE( boolT , bDone ) ;
                                    ZE( count04T , cbDone ) ;

                                    //etThread.traceF( tinP , T("inspecting images [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;

                                    }
                                        }
                                            bCompareFail = 1 ;
                                            etThread.traceF( tinP , T("exception: could not ct pfwsOuter [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                                            POOPR
                                        {
                                        if( POOP )
                                        new( 0 , tinP , (byteT*)pfwsOuter , sizeof( fileWindowsC ) ) fileWindowsC( tinP , *((tinNormalS&)tinP).pEtScratch , tLongOuter ) ;
                                        SCOOPS
                                    {

                                    //etThread.traceF( tinP , T("new [pfwsOuter]:    ")+TF3((countT)pfwsOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                                    etThread.newF( tinP , LF , *(byteT**)&pfwsOuter , sizeof( fileWindowsC ) ) ; ___( pfwsOuter ) ;
                                    ZE( fileWindowsC* , pfwsOuter ) ;
                                {
                                IFsCRATCH

                                for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ ) pEqual[ offo ] = 1 ;
                                etThread.newF( tinP , LF , pEqual , cInnerImagesToInspect ) ; ___( pEqual ) ;
                                ZE( boolT* , pEqual ) ;
                                TN( tDot , "." ) ;
                            {
                            if( !bCompareFail )

                            }
                                }
                                    etThread.delF( tinP , psttLongInner ) ;

                                    }
                                        }
                                            break ;
                                            bCompareFail = 1 ;
                                            etThread.traceF( tinP , T("exception: could not ct a fileWindowsC instance") ) ;
                                            POOPR
                                        {
                                        if( POOP )
                                        new( 0 , tinP , (byteT*)( pfwsInner + offi ) , sizeof( fileWindowsC ) ) fileWindowsC( tinP , *((tinNormalS&)tinP).pEtScratch , psttLongInner ) ;
                                        SCOOPS
                                    {
                                    IFsCRATCH

                                    stLongInner >> psttLongInner ;
                                    ZE( strokeS* , psttLongInner ) ;
                                {
                                for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )
                            {
                            if( pfwsInner )
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                            etThread.newF( tinP , LF , *(byteT**)&pfwsInner , cInnerImagesToInspect * sizeof( fileWindowsC ) ) ; ___( pfwsInner ) ;
                            ZE( fileWindowsC* , pfwsInner ) ;

                            }
                                break ;
                                bAbortP = 1 ;                                
                                etThread.traceF( tinP , T("exception [cInnerImagesToInspect,stLongInner]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+TF2(stLongInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            if( stLongInner != cInnerImagesToInspect ) //SHOULD BE IMPOSSIBLE
                        {
                        if( !ether && !bAbortP && cInnerImagesToInspect )

                        }
                            }
                                while( !ether && !bAbortP && ~hSwsInner ) ;
                                }
                                    }
                                        }
                                            break ;

                                            }
                                                }
                                                    bAbortP = 1 ;                                                    
                                                    etThread.traceF( tinP , T("exception: iSlotLongInnr is null") ) ;
                                                    etThread.delF( tinP , psttLongInner ) ;
                                                {
                                                if( !idSlotLongInner ) //SHOULD BE IMPOSSIBLE
                                                stLongInner.sinkF( tinP , idSlotLongInner , psttLongInner , flSTACKsINK_UNIQUE ) ;
                                                ZE( countT , idSlotLongInner ) ;

                                                etThread.strMakeF( tinP , LF , psttLongInner , tLongInner ) ; ___( psttLongInner ) ;
                                                ZE( strokeS* , psttLongInner ) ;

                                                offResult ++ ;

                                                pcBitsShiftLeftHeInMine[ offResult ] = cBitsShiftLeftHeInMine ;
                                                pcBitsShiftLeftMeInHis[  offResult ] = cBitsShiftLeftMeInHis  ;
                                                ppIdResultHeInMine[      offResult ] = &bitsResultHeInMine    ;
                                                ppIdResultMeInHis[       offResult ] = &bitsResultMeInHis     ;
                                            {
                                            if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                        {
                                        case 3 :
                                        }
                                            break ;

                                            }
                                                cInnerImagesToInspect ++ ;
                                                //etThread.traceF( tinP , T("incrementing") ) ;
                                            {
                                            if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )

                                            //etThread.traceF( tinP , T("        maybe incrementing cInnerImagesToInspect [bitsResultHeInMine,maskHeInMine,masked,cBitsShiftLeftHeInMine,inner]:    ")+TF2(bitsResultHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(maskHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((bitsResultHeInMine&maskHeInMine),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                        {
                                        case 2 :    // COUNT THE NUMBER OF INNER FILES FOR WHICH I MUST INSPECT THE IMAGE (I SET cInnerImagesToInspect HERE)
                                        }
                                            break ;

                                            }
                                                }
                                                    bitsResultHeInMine |= BITSrESULT_NOTeQUAL << cBitsShiftLeftHeInMine ;
                                                    bitsResultMeInHis  |= BITSrESULT_NOTeQUAL << cBitsShiftLeftMeInHis  ;
                                                    //etThread.traceF( tinP , T("        set other and myself to BITSrESULT_NOTeQUAL because cbUsed differs") ) ;
                                                {
                                                if( pfmOuter->cbUsed != pfmInner->cbUsed )
                                            {
                                            else if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                            }
                                                //etThread.traceF( tinP , T("        setted  myself to BITSrESULT_EQUAL [bitsResultMeInHis]:    ")+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                bitsResultMeInHis |= BITSrESULT_EQUAL << cBitsShiftLeftMeInHis ;
                                                //etThread.traceF( tinP , T("        setting myself to BITSrESULT_EQUAL [&bitsResultMeInHis,bitsResultMeInHis,&cBitsShiftLeftMeInHis,cBitsShiftLeftMeInHis]:    ")+TF2(&bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(&cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            if( pfmInner == pfmOuter )
                                        {
                                        case 1 :    // SET bitsResult WITHOUT COMPARING FILE IMAGES
                                    {
                                    switch( idPass )

                                    //etThread.traceF( tinP , T("    [idPass,tLongInner]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                    TN( tLongInner , "" ) ; tLongInner = T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ;

                                    countT maskHeInMine = BITSrESULT_ALLbITS << cBitsShiftLeftHeInMine ;
                                    countT maskMeInHis  = BITSrESULT_ALLbITS << cBitsShiftLeftMeInHis  ;

                                    countT cBitsShiftLeftHeInMine =           ( ( pfmInner->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;
                                    countT cBitsShiftLeftMeInHis  =           ( ( pfmOuter->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;

                                    countT& bitsResultHeInMine    = picOuter[ ( pfmInner->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;
                                    countT& bitsResultMeInHis     = picInner[ ( pfmOuter->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;

                                    //picInner->traceF( tinP , T("inner :    ") ) ;
                                    //pfmInner->traceF( tinP , stPathToYear , T("inner: ") ) ;
                                    fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;

                                    //etThread.traceF( tinP , T("    [picInner]:    ")+TF2((countT)picInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    imageCompareS* picInner = (imageCompareS*)&pSwsMetaByShort->downF( tinP , hSwsInner ) ;
                                {
                                do
                                handleC hSwsInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( idPass != 3 || cInnerImagesToInspect )

                            }
                                etThread.memSetF( tinP , (byteT*)pcBitsShiftLeftHeInMine , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tinP , (byteT*)pcBitsShiftLeftMeInHis  , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tinP , (byteT*)ppIdResultHeInMine      , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tinP , (byteT*)ppIdResultMeInHis       , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tinP , (byteT*)pcbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tinP , (byteT*)ppbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;

                                etThread.newF( tinP , LF ,             pcBitsShiftLeftHeInMine , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftHeInMine ) ;
                                etThread.newF( tinP , LF ,             pcBitsShiftLeftMeInHis  , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftMeInHis  ) ;
                                etThread.newF( tinP , LF , *(countT**)&ppIdResultHeInMine      , cInnerImagesToInspect ) ; ___( ppIdResultHeInMine      ) ;
                                etThread.newF( tinP , LF , *(countT**)&ppIdResultMeInHis       , cInnerImagesToInspect ) ; ___( ppIdResultMeInHis       ) ;
                                etThread.newF( tinP , LF ,             pcbwInner               , cInnerImagesToInspect ) ; ___( pcbwInner               ) ;
                                etThread.newF( tinP , LF , *(countT**)&ppbwInner               , cInnerImagesToInspect ) ; ___( ppbwInner               ) ;
                            {
                            if( idPass == 3 && cInnerImagesToInspect )
                        {
                        for( countT idPass = 1 ; !ether && idPass <= 3 ; idPass ++ )
                        ZE( countT   , offResult               ) ;
                        ZE( countT*  , pcBitsShiftLeftHeInMine ) ;
                        ZE( countT*  , pcBitsShiftLeftMeInHis  ) ;
                        ZE( countT** , ppIdResultHeInMine      ) ;
                        ZE( countT** , ppIdResultMeInHis       ) ;
                        ZE( countT*  , pcbwInner               ) ;
                        ZE( byteT**  , ppbwInner               ) ;
                        ZE( countT   , cInnerImagesToInspect   ) ;
                        stackC stLongInner( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

                        //pfmOuter->traceF( tinP , stPathToYear , T("outer: ") ) ;
                        //etThread.traceF( tinP , T("[tLongOuter]:    ")+tLongOuter ) ;
                        TN( tLongOuter , "" ) ; tLongOuter = T((strokeS*)stPathToYear[pfmOuter->idSlotPathToYear])+tShort ;

                        //picOuter->traceF( tinP , T("outer :    ") ) ;
                        fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + cResultStructsNeeded ) ;
                        imageCompareS* picOuter  = (imageCompareS*)&pSwsMetaByShort->downF( tinP , hSwsOuter ) ;

                        // *********************************************************************************************************************************************************************************************************
                        // ****                                      ***************************************************************************************************************************************************************
                        // ****  BEGIN:  FOR EACH COPY OF THIS FILE  ***************************************************************************************************************************************************************
                        // ****                                      ***************************************************************************************************************************************************************
                        // *********************************************************************************************************************************************************************************************************
                    {
                    do
                    handleC hSwsOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    // SET ALL COMPARE META ELEMENTS FOR EACH FILE'S IMAGE COMPARE META ARRAY

                    //etThread.traceF( tinP , T("processing [tShort             ]:    ")+tShort ) ;

                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // ****                                                                                                                                  *******************************************************************
                    // ****  BEGIN:  COMPARE ALL COPIES OF THIS SHORT FILE NAME.  THIS IS RETRIED UNTIL ALL COMPARISONS COMPLETE WITHOUT AN EXCEPTION EVENT  *******************************************************************
                    // ****                                                                                                                                  *******************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                {
                do
                ZE( countT , cCompareFail ) ;
                ZE( boolT  , bCompareFail ) ;

                //if( idf <= 4 ) // FOR TESTING.  IN PRODUCTION, COMMENT OUT THIS LINE

                }
                    etThread.traceF( tinP , T("!tShort.csF() [cShortFileNames,idf]:    ")+TF2(cShortFileNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( !tShort.csF( tinP ) )

                TN( tShort , postzShort ) ;

                countT cCopies = *pSwsMetaByShort ;
                postzShort = (osTextT*)pSwsMetaByShort->leverF( tinP , idf ) ;

                }
                    etThread.traceF( tinP , T("[cNamesMax,cNamesProcessed,perTuck]:    ")+TF2(cNamesMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cNamesProcessed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF3(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2)+tb+tPerTuck ) ;
                    countT perTuck = ( cNamesProcessed << 8 ) / cNamesMax ;
                {
                //if( !( cNamesProcessed % ( TUCK >> 0 ) ) )
            {
            for( countT idf = cShortFileNames ; !ether && idf ; idf -- )
            etThread.traceF( tinP , T("inspecting metadata and comparing images for each copy of each file") ) ;

            const countT cShortFileNames = pSwsMetaByShort->cFlavorsF( tinP ) ;

            //etThread.traceF( tinP , T("grabbed  *pSwsMetaByShort") ) ;
            pSwsMetaByShort->grabF( tinP , TAG( TAGiDnULL ) ) ;      //SHOULD NOT BE NEEDED SINCE ALL KIDS ARE GONE OR PAUSED
            //etThread.traceF( tinP , T("grabbing *pSwsMetaByShort") ) ;

            grabCutoffNext.ungrabF( tinP ) ;
            postShortCutoff = postShortCutoffNext ; postShortCutoffNext = 0 ;
            etThread.delF( tinP , postShortCutoff ) ;
            grabCutoffNext.grabF( tinP , TAG( TAGiDnULL ) ) ;

            // *pSwsMetaByShort NOW CONTAINS META (FILE META AND INITIALIZED ACCUMULATORS FOR COMPARE META)

            //etThread.tracePoolTalliesF( tinP ) ;
            //etThread.traceF( tinP , T("calling tracePoolTalliesF / file meta is loaded") ) ;

            etThread.traceF( tinP , T("(begin heal loop) waited  for all nominations to be done.  file meta is loaded [cCollectors,cCutoffNominatorsDone]:    ")+TF2(cCollectors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cCutoffNominatorsDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            while( cCutoffNominatorsDone < cCollectors ) ;
            }
                ++ s ; etThread.osSleepF( tinP , TOCK >> 2 ) ;
                etThread.traceF( tinP , T("(begin heal loop) waiting for all nominations to be done [cCollectors,cCutoffNominatorsDone]:    ")+TF2(cCollectors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cCutoffNominatorsDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4 ) ;
            {
            do
        {
        while( !bAbortP && cCollectors )
        ZE( countT , cNamesProcessed ) ;
        TELL( "heal" )

        cCutoffNominatorsDone = 0 ;      // WILL CAUSE BATCH 1 TO LOAD
        postShortCutoff = postShortCutoffNext ; postShortCutoffNext = 0 ;
        
        etThread.traceF( tinP , T("(before heal loop) waiting for all nominations to be done.  resetting cCutoff to start collection [cCollectors,&cCutoffNominatorsDone,cCutoffNominatorsDone,postShortCutoffNext]:    ")+TF2(cCollectors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF3((countT)&cCutoffNominatorsDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF2(cCutoffNominatorsDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postShortCutoffNext) ) ;
        while( cCutoffNominatorsDone < cCollectors ) ;
        }
            ++ s ; etThread.osSleepF( tinP , TOCK >> 2 ) ;
            etThread.traceF( tinP , T("(before heal loop) waiting for all nominations to be done [cCollectors,&cCutoffNominatorsDone,cCutoffNominatorsDone]:    ")+TF2(cCollectors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF3((countT)&cCutoffNominatorsDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF2(cCutoffNominatorsDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        do
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;

        }
            if( idPass == 1 ) stPathToYear.lockIfF( tinP ) ;

            if( bAbortP ) break ;

            while( !bAbortP && ~hSwsPathToArchives ) ;
            }
                etThread.delF( tinP , pstt1PathToYear ) ;
                }
                    }
                        }
                            }
                                break ;
                                bAbortP = 1 ;
                                etThread.traceF( tinP , T("exception: could not launch thread tmCollectFileMetaF") ) ;
                                dec02AM( cCollectors ) ;
                                POOPR
                            {
                            if( POOP )
                            ((tinNormalS&)tinP).pEtScratch->osThreadF( TaRG3fLAGScBtLS( tmCollectFileMetaF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cCollectors , (countT)&stPathToYear , idSlotPathToYear , (countT)&postzShort , (countT)pSwsMetaByShort , (countT)&grabCutoffNext , (countT)&postShortCutoffNext , (countT)&postShortCutoff , (countT)&bAbortP , (countT)&cCutoffNominatorsDone , (countT)&cNamesMax , (countT)&grabNamesMax ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        inc02AM( cCollectors ) ;
                        countT idSlotPathToYear = stPathToYear( psttc1 ) ;
                    {
                    else
                    }
                        }
                            break ;
                            bAbortP = 1 ;
                            etThread.traceF( tinP , T("exception: idSlotPathToYear is null") ) ;
                            etThread.delF( tinP , psttPathToYear ) ;
                        {
                        if( !idSlotPathToYear ) //SHOULD BE IMPOSSIBLE
                        stPathToYear.sinkF( tinP , idSlotPathToYear , psttPathToYear , flSTACKsINK_UNIQUE ) ;
                        ZE( countT , idSlotPathToYear ) ;

                        etThread.strMakeF( tinP , LF , psttPathToYear , psttc1 ) ; ___( psttPathToYear ) ;
                        ZE( strokeS* , psttPathToYear ) ;
                    {
                    if( idPass == 1 )
                {
                FORsTRINGSiN1( pstt1PathToYear )

                //etThread.traceF( tinP , T("[pstt1PathToYear]:    ")+T(pstt1PathToYear) ) ;
                etThread.strConvertToLowerCaseF( tinP , pstt1PathToYear ) ;

                }
                    }
                        break ;
                        bAbortP = 1 ;
                        etThread.traceF( tinP , T("exception:  diskFindFileOrDirF [tPathToArchive]:    ")+tPathToArchive ) ;
                        POOPR
                    {
                    if( POOP )
                    RETRYsCR( 8 , diskFindFileOrDirF( tinP , pstt1PathToYear , tPathToArchive , &pat ) ) ___( pstt1PathToYear ) ;
                    SCOOPS
                {
                IFsCRATCH
                patternC pat( tinP , etThread , tYearSlash , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                ZE( strokeS* , pstt1PathToYear ) ;

                if( idPass == 1 ) etThread.traceF( tinP , T("flavor [tPathToArchive]:    ")+tPathToArchive ) ;
                TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchiveP)+tSlash ;
                strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveNameP.downF( tinP , hSwsPathToArchives ) ;
            {
            do
            handleC hSwsPathToArchives( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

            }
                pSwsMetaByShort = new( 0 , tinP , LF ) switchStackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_SINKrEVERSE | flSTACKc_SINKiGNOREtABS , &postzShort , flSTACKc_BLOB | flSTACKc_ALLOWzE , cResultStructsNeeded * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ; ___( pSwsMetaByShort ) ;
                cResultStructsNeeded = 1 + cSlotsPathToYear / cResultsPerStruct ;
                cSlotsPathToYear = stPathToYear ;
            {
            if( idPass == 2 )                                   // NOW THAT I KNOW cbData I CAN CT *pSwsMetaByShort
        {
        for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
        ZE( countT , cNamesMax ) ;
        grabC grabNamesMax( tinP , TAG( TAGiDnULL ) ) ;
        etThread.traceF( tinP , T("correct [&cCutoffNominatorsDone]:    ")+TF3((countT)&cCutoffNominatorsDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
        ZE( countT , cCutoffNominatorsDone ) ;
        TELL( "launching tmCollectFileMetaF threads" )
        ZE( osTextT* , postShortCutoff ) ;
        ZE( osTextT* , postShortCutoffNext ) ;
        grabC grabCutoffNext( tinP , TAG( TAGiDnULL ) ) ;
        ZE( countT , cCollectors ) ;
        stackC stPathToYear( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
        ZE( switchStackC* , pSwsMetaByShort ) ;       // cbData IS NOT KNOWN UNTIL PASS 1 COMPLETES ; WILL BE CT'D IN PASS 2 USING THE THEN KNOWN NUMBER OF PATHS FOR THIS ARCHIVE NAME
        ZE( osTextT* , postzShort  ) ;
        ZE( countT   , cResultStructsNeeded ) ;
        ZE( countT   , cSlotsPathToYear     ) ;
        ZE( boolT    , bAbortP ) ;
        TELL( "setting up" )

        etThread.traceF( tinP , T("executive [pattern]:    ")+tYearSlash ) ;
        etThread.delF( tinP , psttYearP ) ;
        TN( tYearSlash , "" ) ; tYearSlash = T(psttYearP)+T("/") ;

        TN( tPatRejects  , "/ipdos.archives.rejects/" ) ;
        TN( tPatArchives , "/ipdos.archives/" ) ;
        //CS:CODEsYNC: 2 2

        TN( tPerTuck , "%" ) ;
        TN( tSlash , "/" ) ;
        TN( tb4    , "    " ) ;
        TN( tb , " " ) ;
    {

    stackC&       stJobP                          =       *(stackC*)pTaskP->c6 ;
    boolT&        bAbortP                         =        *(boolT*)pTaskP->c5 ;
    switchStackC& swsPathToArchivesByArchiveNameP = *(switchStackC*)pTaskP->c4 ;
    strokeS*&     psttzArchiveP                   =     *(strokeS**)pTaskP->c3 ;
    strokeS*      psttYearP                       =       (strokeS*)pTaskP->c2 ;
    countT&       cExecutiveHealYearP             =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmExecutiveHealYearF )

DONE( tmCollectFileMetaF )
}
    dec02AM( cCollectorsP ) ;

    }
        }
            }
                }
                    etThread.traceF( tinP , T("ended archive pathToYear:    ")+tPathToYearP ) ;
                    }
                        while( ~hWalk && !bAbortP ) ;
                        }
                            DEL( pInfoFile ) ;
                            }
                                swsMetaByShortP.ungrabF( tinP ) ;
                                //etThread.traceF( tinP , T("after pushing meta for a file [cFlavors]:    ")+TF2(swsMetaByShortP.cFlavorsF(tinP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                new( 0 , tinP , (byteT*)pCursor , sizeof( fileMetaS ) ) fileMetaS( tinP , bAbortP , idSlotPathToYearP , time1Mod , time2Mod , cbUsed ) ;

                                pCursor += cResultStructsNeeded ;
                                for( countT offs = 0 ; offs < cResultStructsNeeded ; offs ++ ) new( 0 , tinP , (byteT*)( pCursor + offs ) , sizeof( imageCompareS ) ) imageCompareS ;
                                countT cResultStructsNeeded = 1 + cSlotsPathToYear / cResultsPerStruct ;
                                imageCompareS* pCursor = (imageCompareS*)&swsMetaByShortP[ 1 ] ;

                                swsMetaByShortP << (byteT*)0 ;

                                //etThread.traceF( tinP , T("[idFile,postzShortP]:    ")+TF2(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+T(postzShortP) ) ;
                                postzShortP = tShort ;
                                swsMetaByShortP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                                count04T cbUsed = pInfoFile->cbUsedHigh << sizeof( count02T ) * SB | pInfoFile->cbUsed ;

                                sCountT time2Mod = pInfoFile->timeWritten2 ;
                                countT  time1Mod = pInfoFile->timeWritten1 ;

                                }
                                    etThread.traceF( tinP , T("[perTuck,idFile]:    ")+TF3(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2)+tb+tPerTuck+tb4+TF2(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    countT perTuck = ( idFile << 8 ) / cFiles ;
                                {
                                if( !( idFile % ( TUCK << 2 ) ) )

                                ++ idFile ;
                                                                           
                                }
                                    etThread.delF( tinP , psttYearSlashShort ) ;
                                    etThread.delF( tinP , psttPath ) ;
                                    tYearSlashShort = T(psttYearSlashShort) ;
                                    tPath  = T(psttPath) ;
                                    etThread.strBisectF( tinP , psttPath , psttYearSlashShort , tFileName , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttYearSlashShort ) ;
                                    ZE( strokeS* , psttYearSlashShort ) ;
                                    ZE( strokeS* , psttPath ) ;
                                {
                                TN( tYearSlashShort , "" ) ;
                                TN( tPath  , "" ) ;

                                TN( tFileName , pInfoFile->psttIfoName ) ;
                            {
                            if( pInfoFile )

                            }
                                }
                                    break ;
                                    DEL( pInfoFile ) ;
                                    bAbortP = 1 ;
                                    etThread.traceF( tinP , T("exception:  diskFileQueryF") ) ;
                                    POOPR
                                {
                                if( POOP )
                                RETRYsCR( 8 , diskFileQueryF( tinP , pInfoFile , fi ) ) ; ___( pInfoFile ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            fileC fi( tinP , (strokeS*)tLong , ifcOPENaCCESS_R ) ;
                            ZE( infoFileS* , pInfoFile ) ;

                            TN( tLong , "" ) ; tLong = tPathToYearP+tShort ;

                            break ;                                                     //WILL BREAK ONLY IF bAbortP WAS SET
                            )
                                nominateCutoffThenWaitForCutoffF( tinP , etThread , bAbortP , postShortCutoffNextP , grabCutoffNextP , cCutoffNominatorsDoneP , idPlate , stIdJot , jotShortFileNames )
                                &&
                                0 < thirdC::c_strcmpIF( tinP , tShort , postShortCutoffP )
                                &&
                                postShortCutoffP
                            (
                            if

                            }
                                break ;
                                bAbortP = 1 ;
                                etThread.traceF( tinP , T("exception: short file name is null length") ) ;
                            {
                            if( !tShort.csF( tinP ) )     //SHOULD BE IMPOSSIBLE

                            //etThread.traceF( tinP , T("[tShort,postShortCutoff]:    ")+tShort+tb4+T(postShortCutoffP) ) ;
                            }
                                }
                                    break ;
                                    bAbortP = 1 ;
                                    etThread.traceF( tinP , T("exception: could not obtain a pageC instance containing a short file name 2") ) ;
                                {
                                else
                                if( ~page ) tShort = T((const byteT*)page) ;
                                pageC page = jotShortFileNames[ idj ] ;
                            {
                            TN( tShort , "" ) ;

                            countT idj = stIdJot.upF( tinP , hWalk ) ;

                            idPlate ++ ; //SINCE I AM GOING UP, THIS IS NOT THE idPlate ASSOCIATED WITH stackC MEMBER FUNCTIONS, FOR WHICH THE TOP PLATE IS idPlate 1
                        {
                        do
                        handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        ZE( countT , idFile ) ;
                        ZE( countT , idPlate ) ;
                    {
                    if( stIdJot )
                    etThread.traceF( tinP , T("collecting file meta into sws, using stIdJot") ) ;
                {
                if( !bAbortP )

                nominateCutoffThenWaitForCutoffF( tinP , etThread , bAbortP , postShortCutoffNextP , grabCutoffNextP , cCutoffNominatorsDoneP , 1 , stIdJot , jotShortFileNames ) ;
            {
            if( !bAbortP )

            grabNamesMaxP.ungrabF( tinP ) ;
            if( cNamesMaxP < cFiles ) cNamesMaxP = cFiles ;
            grabNamesMaxP.grabF( tinP , TAG( TAGiDnULL ) ) ;

            etThread.traceF( tinP , T("counted files [cFiles,stIdJot]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)stIdJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            }
                while( !ether && !bAbortP && ~hFindFile && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        }
                            stIdJot.sinkF( tinP , countTC() , idJot , flSTACKsINK_null , subtractJottedOsTextF , (countT)&bAbortP ) ;
                            countT idJot = jotShortFileNames.writeF( tinP , tShort , tShort.csF( tinP ) + 1 ) ;
                        {
                        if( tShort.csF( tinP ) )        // IF NOT A DIRECTORY
                                                                   
                        }
                            etThread.delF( tinP , psttShort ) ;
                            etThread.delF( tinP , psttnu ) ;
                            tShort  = T(psttShort) ;
                            etThread.strBisectF( tinP , psttnu , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShort , "" ) ;
                        cFiles ++ ;
                    {
                    else
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( bAbortP || !pInfoFile || !pInfoFile->psttIfoName )

                    }
                        }
                            bAbortP = 1 ;
                            etThread.traceF( tinP , T("exception:  diskFindFileOrDirF") ) ;
                            POOPR
                        {
                        if( POOP )
                        RETRYsCR( 8 , diskFindFileOrDirF( tinP , pInfoFile , hFindFile , tPathToYearP ) ) ___( pInfoFile ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    ZE( infoFileS* , pInfoFile ) ;

                    }
                        etThread.traceF( tinP , T("[cFiles,volume,pathToYear]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tVolumeName+tb4+tPathToYearP ) ;
                    {
                    if( cFiles && !( cFiles % ( TUCK << 4 ) ) )
                {
                do
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                handleC hFindFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {
            
            ZE( countT , cFiles ) ;
            stackC stIdJot( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKiGNOREtABS | flSTACKc_SINKrEVERSE ) ;
            jotC jotShortFileNames( tinP , "short.file.names" , flJOTc_WRITE | flJOTc_PRIVATE | flJOTc_DELETE | flJOTc_PURGEoNcT , 1 ) ;            //1 IS ARBITRARY AND WILL BE INSUFFICIENT WHEN SORTING MUST REACH BEYOND THE PRIOR BOOK.  ENHANCE jotC TO SUPPORT A REASONABLE DEFAULT NUMBER OF INACTIVE
            etThread.traceF( tinP , T("counting files") ) ;

            etThread.traceF( tinP , T("this thread's job: [volume,pathToYear]:    ")+tVolumeName+tb4+tPathToYearP ) ;

            //}
            //    etThread.delF( tinP , pstt1Words ) ;
            //    }
            //        else if( bArm                                               ) bArm -- ;
            //        else if( !etThread.strCompareF( tinP , psttc1 , tArchives ) ) bArm = 2 ;
            //             if( bArm == 1                                          ) tYear = T(psttc1) ;
            //    {
            //    FORsTRINGSiN1( pstt1Words )
            //    TN( tArchives , "ipdos.archives" ) ;
            //    ZE( boolT , bArm ) ;
            //    etThread.strWordsF( tinP , pstt1Words , tPathToYearP , sttq , T("/") ) ; ___( pstt1Words ) ;
            //    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            //    ZE( strokeS* , pstt1Words ) ;
            //{
            //TN( tYear , "" ) ;
        {
        if( !bAbortP )

        }
            DEL( pInfoDisk ) ;
            tVolumeName = T(pInfoDisk->psttVolumeName) ;
            etThread.strConvertToLowerCaseF( tinP , pInfoDisk->psttVolumeName ) ;
            etThread.delF( tinP , psttDisk ) ;
            }
                }
                    bAbortP = 1 ;
                    etThread.traceF( tinP , T("exception:  diskInfoF: could not obtain volume name") ) ;
                    POOPR
                {
                if( POOP )
                RETRYsCR( 8 , diskInfoF( tinP , pInfoDisk , psttDisk ) ) ; ___( pInfoDisk ) ;
                SCOOPS
            {
            IFsCRATCH
            ZE( infoDiskS* , pInfoDisk ) ;

            etThread.strSubstringF( tinP , psttDisk , idf , idl , tPathToYearP ) ; ___( psttDisk ) ;
            countT idl = 5 ;
            countT idf = 1 ;
            ZE( strokeS* , psttDisk ) ;
        {
        TN( tVolumeName , "" ) ;

        TN( tPathToYearP , (strokeS*)stPathToYearP[ idSlotPathToYearP ] ) ;
        TN( tPerTuck , "%" ) ;
        TN( tDot , "." ) ;
        TN( tb4 , "    " ) ;
        TN( tb , " " ) ;
        const countT  cSlotsPathToYear = stPathToYearP ;
    {

    grabC&        grabNamesMaxP            =        *(grabC*)pTaskP->cc ;
    countT&       cNamesMaxP               =       *(countT*)pTaskP->cb ;
    countT&       cCutoffNominatorsDoneP   =       *(countT*)pTaskP->ca ;
    boolT&        bAbortP                  =        *(boolT*)pTaskP->c9 ;
    osTextT*&     postShortCutoffP         =     *(osTextT**)pTaskP->c8 ;
    osTextT*&     postShortCutoffNextP     =     *(osTextT**)pTaskP->c7 ;
    grabC&        grabCutoffNextP          =        *(grabC*)pTaskP->c6 ;
    switchStackC& swsMetaByShortP          = *(switchStackC*)pTaskP->c5 ;
    osTextT*&     postzShortP              =     *(osTextT**)pTaskP->c4 ;
    countT        idSlotPathToYearP        =                 pTaskP->c3 ;
    stackC&       stPathToYearP            =       *(stackC*)pTaskP->c2 ;
    countT&       cCollectorsP             =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 && pTaskP->c8 && pTaskP->c9 && pTaskP->ca && pTaskP->cb && pTaskP->cc )
TASK( tmCollectFileMetaF )

DONE( tmDoJobF )
}
    }
        //etThread.traceF( tinP , T("napped for a tock") ) ;
        ++ s ; ether.osSleepF( tinP , TOCK ) ;
        //etThread.traceF( tinP , T("napping for a tock") ) ;

        }
            }
                }
                    break ;
                    bAbortP = 1 ;
                    etThread.traceF( tinP , T("exception: unexpected job idType:    ")+TF2(woJob.idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                default :
                }
                    break ;

                    }
                        }
                            }
                                }
                                    }
                                        bAbortP = 1 ;
                                        etThread.traceF( tinP , T("diskCopyFileF failed too many times.  will not retry [to,from]:    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                                    {
                                    if( !bOk )
                                    }
                                        }
                                            thirdC::dosSleepWinkIF( tinP , 2 ) ;
                                            etThread.traceF( tinP , T("diskCopyFileF failed.  will retry [cRetries,to,from]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                                            POOPR
                                        {
                                        else
                                        }
                                            break ;
                                            bOk = 1 ;
                                        {
                                        if( !POOP )
                                        ((tinNormalS&)tinP).pEtScratch->diskCopyFileF( tinP , woJob.psttTo , woJob.psttFrom , 1 ) ;
                                    {
                                    while( cTries && cTries -- )
                                    ZE( boolT , bOk ) ;

                                    cTries = 8 ;

                                    etThread.traceF( tinP , T("copying [to,from]:    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                                {
                                else
                                }
                                    bAbortP = 1 ;
                                    etThread.traceF( tinP , T("bizarre!  there is still a file in the way, so not copying [to,from]:    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                                {
                                else if( bExists )
                                }
                                    bAbortP = 1 ;
                                    etThread.traceF( tinP , T("after rejecting a file out of the way, not copying because could not obtain bExists (probable drive failure) [to,from]:    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                                {
                                if( !bOk    )

                                }
                                    }
                                        thirdC::dosSleepWinkIF( tinP , 2 ) ;
                                        etThread.traceF( tinP , T("diskFileExistsF failed.  will retry [cRetries,to,from]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                                        POOPR
                                    {
                                    else
                                    }
                                        break ;
                                        bOk = 1 ;
                                    {
                                    if( !POOP )
                                    bExists = ((tinNormalS&)tinP).pEtScratch->diskFileExistsF( tinP , woJob.psttTo ) ;
                                {
                                while( cTries && cTries -- )
                                cTries = 8 ;
                                bOk = bExists = 0 ;

                                countT cTries = 8 ;
                            {
                            if( !bAbortP )

                            }
                                etThread.delF( tinP , psttLongInRejects ) ;
                                etThread.delF( tinP , psttRejected ) ;

                                if( !bAbortP ) etThread.traceF( tinP , T("rejected  file from archive because would have been overwritten [reject,from]:    ")+T(psttRejected)+T("    ")+T(woJob.psttTo) ) ;
                                }
                                    }
                                        bAbortP = 1 ;
                                        etThread.traceF( tinP , T("exception:  diskMoveFileOrDirUniqueF 2 [reject,from]:    ")+T(psttRejected)+T("    ")+T(woJob.psttTo) ) ;
                                        POOPR
                                    {
                                    if( POOP )
                                    RETRY( 8 , ( psttRejected = 0 , ((tinNormalS&)tinP).pEtScratch->diskMoveFileOrDirUniqueF( tinP , psttRejected , woJob.psttTo , psttLongInRejects ) ) ) ; ___( psttRejected ) ;
                                    SCOOPS
                                {
                                IFsCRATCH
                                ZE( strokeS* , psttRejected ) ;

                                etThread.strReplaceF( tinP , psttLongInRejects , woJob.psttTo , tPatArchives , tPatRejects ) ; ___( psttLongInRejects ) ;
                                ZE( strokeS* , psttLongInRejects ) ;
                            {
                            if( bExists )
                        {
                        else
                        }
                            bAbortP = 1 ;
                            etThread.traceF( tinP , T("not copying because could not obtain bExists (probable drive failure) [to,from]:    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                        {
                        if( !bOk )

                        }
                            }
                                thirdC::dosSleepWinkIF( tinP , 2 ) ;
                                etThread.traceF( tinP , T("diskFileExistsF failed.  will retry [cRetries,to,from]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(woJob.psttTo)+T("    ")+T(woJob.psttFrom) ) ;
                                POOPR
                            {
                            else
                            }
                                break ;
                                bOk = 1 ;
                            {
                            if( !POOP )
                            bExists = ((tinNormalS&)tinP).pEtScratch->diskFileExistsF( tinP , woJob.psttTo ) ;
                        {
                        while( cTries && cTries -- )
                        ZE( boolT , bOk ) ;
                        ZE( boolT , bExists ) ;

                        countT cTries = 8 ;

                        SCOOPS
                    {
                    IFsCRATCH
                {
                case IDtYPEjOB_COPY :
                }
                    break ;

                    etThread.delF( tinP , psttUnique ) ;
                    etThread.traceF( tinP , T("moved [to,from]:    ")+T(psttUnique)+T("    ")+T(woJob.psttFrom) ) ;
                    }
                        }
                            bAbortP = 1 ;
                            etThread.traceF( tinP , T("exception:  diskMoveFileOrDirUniqueF 1 [to,from]:    ")+T(psttUnique)+T("    ")+T(woJob.psttFrom) ) ;
                            POOPR
                        {
                        if( POOP )
                        RETRY( 8 , ( psttUnique = 0 , ((tinNormalS&)tinP).pEtScratch->diskMoveFileOrDirUniqueF( tinP , psttUnique , woJob.psttFrom , woJob.psttTo ) ) ) ; ___( psttUnique ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    ZE( strokeS* , psttUnique ) ;
                {
                case IDtYPEjOB_MOVEuNIQUE :
                }
                    break ;
                {
                case IDtYPEjOB_NULL :
            {
            switch( woJob.idType )

            woJob.traceF( tinP ) ;
            woJob.etherF( tinP , etThread ) ;
            stJobP >> pb_woJob ;
            byteT* pb_woJob = (byteT*)&woJob ;
            jobS woJob( tinP , etThread ) ;
        {
        while( stJobP )
    {
    while( !ether && !POOP && !bAbortP )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    TN( tPatRejects  , "/ipdos.archives.rejects/" ) ;
    TN( tPatArchives , "/ipdos.archives/" ) ;
    //CS:CODEsYNC: 2 2

    stackC& stJobP  = *(stackC*)pTaskP->c2 ;
    boolT&  bAbortP =  *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmDoJobF )

}
    return bBreak ;

    inc02AM( cZeSeenP ) ;

    etherP.traceF( tinP , T("nominateCutoffThenWaitForCutoffF / waited (cCutoffNominatorsDoneP is now 0)") ) ;
    while( cCutoffNominatorsDoneP ) ;
    }
        ++ s ; etherP.osSleepF( tinP , TOCK >> 2 ) ;
        etherP.traceF( tinP , T("nominateCutoffThenWaitForCutoffF / waiting [incTo,&cCutoffNominatorsDoneP,cCutoffNominatorsDoneP]:    ")+TF2(incTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF3((countT)&cCutoffNominatorsDoneP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T("    ")+TF2(cCutoffNominatorsDoneP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    do
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    }
        }
            countT foo = 2 ;
        {
        if( idIn == 2 )
        countT idIn = 1 + incv02AM( idInLath ) ;
        static countT idInLath ;
    {
    if( incTo == 4 )

    countT incTo = 1 + incv02AM( cCutoffNominatorsDoneP ) ;

    }
        }
            }
                bBreak = 1 ;
                bAbortP = 1 ;
                etherP.traceF( tinP , T("exception: could not obtain a pageC instance containing a short file name 3") ) ;
            {
            else
            }
                grabCutoffNextP.ungrabF( tinP ) ;

                }
                    etherP.strMakeF( tinP , LF , postShortCutoffNextP , tShortCutoff ) ; ___( postShortCutoffNextP ) ;
                    etherP.delF( tinP , postShortCutoffNextP ) ;
                {
                if( !postShortCutoffNextP || 0 < thirdC::c_strcmpIF( tinP , postShortCutoffNextP , tShortCutoff ) )

                grabCutoffNextP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                }
                    bBreak = 1 ;
                    bAbortP = 1 ;
                    etherP.traceF( tinP , T("exception: short cutoff is null length 3") ) ;
                {
                if( !tShortCutoff.csF( tinP ) )      //SHOULD BE IMPOSSIBLE
                //etherP.traceF( tinP , T("proposed [tShortCutoff]:    ")+tShortCutoff ) ;
                TN( tShortCutoff , (const byteT*)page ) ;
            {
            if( ~page )

            pageC page = jotShortFileNamesP[ idjCutoff ] ;
        {
        if( idjCutoff )
        countT idjCutoff = stIdJotP[ (sCountT)( 0 - idPlateCutoffWanted ) ] ;
    {
    if( stIdJotP > idPlateCutoffWanted )

    //etherP.traceF( tinP , T("[idPlateP,idPlateCutoffWanted,stIdJotP]:    ")+TF2(idPlateP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idPlateCutoffWanted,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)stIdJotP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    countT idPlateCutoffWanted = idPlateP - 1 + BATCHsIZE ;
    ZE( boolT , bBreak ) ;
{
boolT nominateCutoffThenWaitForCutoffF( tinBaseS& tinP , etherC& etherP , boolT& bAbortP , countT& cZeSeenP , osTextT*& postShortCutoffNextP , grabC& grabCutoffNextP , countT& cCutoffNominatorsDoneP , countT idPlateP , stackC& stIdJotP , jotC& jotShortFileNamesP )

}
    return sgn ;

    }
        ether.delF( tinP , post1Copy ) ;

        sgn = bAbortP ? 0 : thirdC::c_strcmpIF( tinP , post1Copy , post2 ) ; ;
        //ether.traceF( tinP , T("subtract [post1,post2]:    ")+T(post1Copy)+T("    ")+T(post2) ) ;

        }
            bAbortP = 1 ;
            ether.traceF( tinP , T("subtractJottedOsTextF / could not obtain text [idJot]:    ")+TF2(c2P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        if( !post2 )

        }
            bAbortP = 1 ;
            ether.traceF( tinP , T("subtractJottedOsTextF / could not obtain text [idJot]:    ")+TF2(c1P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        if( !post1Copy )

        const osTextT* post2 = page2 ;
        pageC page2 = jotC::readIF( tinP , c2P ) ;

        }
            thirdC::c_memcpyIF( tinP , post1Copy , post1 , cost1 ) ;    
            ether.newF( tinP , LF , post1Copy , cost1 ) ; ___( post1Copy ) ;
            countT         cost1 = page1 ;
            const osTextT* post1 = page1 ;
            pageC page1 = jotC::readIF( tinP , c1P ) ;
        {
        ZE( osTextT* , post1Copy ) ;

        boolT&  bAbortP = *(boolT*)c3P ;
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther && c3P )
    ZE( sCountT , sgn ) ;

    }
    {
    IFbEcAREFUL
{
/*1*/countT subtractJottedOsTextF( tinBaseS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    return *pfr1 - *pfr2 ;

    fileMetaS* pfr2 = (fileMetaS*)c2P ;
    fileMetaS* pfr1 = (fileMetaS*)c1P ;
{
/*1*/countT subtractFileMetaF( tinBaseS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    pEther->traceF( tinP , T("jobS [idType,psttTo,psttFrom]:    ")+TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
{
voidT jobS::traceF( tinBaseS& tinP )

}
    if( psttFromP ) { pEther->strMakeF( tinP , LF , psttFrom , psttFromP ) ; ___( psttFrom ) ; }
    if( psttToP   ) { pEther->strMakeF( tinP , LF , psttTo   , psttToP   ) ; ___( psttTo   ) ; }
{
psttFrom( 0 )
psttTo( 0 ) ,
idType( idTypeP ) ,
pEther( &etherP ) ,
jobS::jobS( tinBaseS& tinP , etherC& etherP , countT idTypeP , const strokeS* const psttToP , const strokeS* const psttFromP ) :

}
    pEther->delF( tinP , psttFrom ) ;
    pEther->delF( tinP , psttTo   ) ;
    TINSL
{
jobS::~jobS( voidT )

NEWdELcLASS( 3 , jobS ) ;

}
    ((tinNormalS&)tinP).pEther->traceF( tinP , T(psttP)+T(" [bitsResult]:    ")+TF4(bitsResult,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
{
voidT imageCompareS::traceF( tinBaseS& tinP , const strokeS* const psttP )

}
    //traceF( tinP , T("ct      :    ") ) ;
    TINSL
{
bitsResult( BITSrESULT_UNKNOWN )
imageCompareS::imageCompareS( voidT ) :

NEWdELcLASS( 2 , imageCompareS ) ;

}
    return ((tinNormalS&)tinP).pEther->memCompareF( tinP , (byteT*)this , (byteT*)&frP , sizeof( countT ) + sizeof( count04T ) ) ;    //CS:CODEsYNC 1 1
    TINSL
{
sCountT fileMetaS::operator -( const fileMetaS& frP ) const

}
    ((tinNormalS&)tinP).pEther->traceF( tinP , T(psttP)+T(" [timeModRounded,timeMod,cbUsed,cVotes,idSlotPathToYear,path]:    ")+TF3(timeModRounded,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T("    ")+TT(time1Mod,time2Mod)+T("    ")+TT(((countT*)&cbUsed)[0],((countT*)&cbUsed)[1])+T("    ")+TF2(cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idSlotPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((strokeS*)stPathToYearP[idSlotPathToYear]) ) ;
{
voidT fileMetaS::traceF( tinBaseS& tinP , stackC& stPathToYearP , const strokeS* const psttP )

}
    timeModRounded = *(countT*)( (byteT*)pc2 + 3 ) + bRoundUp ;
    countT pc2[ 2 ] = { time1Mod , time2Mod } ;

    boolT bRoundUp = !!( ( time1Mod & 0xffffff ) > 0x800000 ) ;

    }
        bAbortP = 1 ;
        ((tinNormalS&)tinP).pEther->traceF( tinP , T("fileMetaS::fileMetaS / exception: idSlotPathToYear is null") ) ;
    {
    if( !idSlotPathToYear )
{
idSlotPathToYear( idSlotPathToYearP )
cVotes( 0 ) ,
time2Mod( time2ModP ) ,
time1Mod( time1ModP ) ,
cbUsed( cbUsedP ) ,
timeModRounded( 0 ) ,
fileMetaS::fileMetaS( tinBaseS& tinP , boolT& bAbortP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) :

NEWdELcLASS( 1 , fileMetaS ) ;

osTextT* postDebugLever ;

countT cYearsInParallel = CyEARSiNpARALLEL ;
const countT cResultsPerStruct = sizeof( countT ) * SB / 2 ;     // 2 BITS ARE USED TO STORE A RESULT, SO 4 RESULTS FIT INTO A BYTE AND 01 RESULTS FIT INTO A count02T ; MY CODE SHOULD BE WRITTEN WITHOUT ASSUMING countT IS count02T

;
}
    inline voidT etherF( tinBaseS& tinP , etherC& etherP ) { pEther = &etherP ; }

    voidT traceF( tinBaseS& tinP ) ;
    jobS( tinBaseS& tinP , etherC& etherP , countT idTypeP = 0 , const strokeS* const psttToP = 0 , const strokeS* const psttFromP = 0 ) ;
    ~jobS( voidT ) ;
    NEWdELcLASSpROTOS
   

    strokeS* psttFrom ;
    strokeS* psttTo ;
    countT   idType ;
    etherC*  pEther ;
{
struct jobS

;
}
    voidT traceF( tinBaseS& tinP , const strokeS* const psttP = 0 ) ;
    inline sCountT operator -( imageCompareS& picP ) { return bitsResult - picP.bitsResult ; }
    imageCompareS( voidT ) ;
    NEWdELcLASSpROTOS

    countT bitsResult ;
{
struct imageCompareS

;
}
    sCountT operator -( const fileMetaS& frP ) const ;
    voidT traceF( tinBaseS& tinP , stackC& stPathToYearP , const strokeS* const psttP = 0 ) ;
    fileMetaS( tinBaseS& tinP , boolT& bAbortP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) ;
    NEWdELcLASSpROTOS

    countT   idSlotPathToYear ;
    countT   cVotes ;
    sCountT  time2Mod ;
    countT   time1Mod ;
    count04T cbUsed ;
    countT   timeModRounded ;   //CS:CODEsYNC 1 1
{
struct fileMetaS

#define IDtYPEjOB_COPY       0x3
#define IDtYPEjOB_MOVEuNIQUE 0x2
#define IDtYPEjOB_NULL       0x1

#define CyEARSiNpARALLEL  1
//20221210@2201: 4 IS TOO MANY.  THREAD LAUNCH FAILED.
//1 FOR TESTING; PERHAPS 4 FOR PROD

#define BATCHsIZE  ( TUCK >> 2 )
//TUCK IN PRODUCTION

#define BITSrESULT_ALLbITS        3
#define BITSrESULT_EQUAL          2
#define BITSrESULT_NOTeQUAL       1
#define BITSrESULT_UNKNOWN        0

//OBSOLETES 7e3
//OBSOLETED BY ?
//CRAFTWORK ABORTED DUE TO DECISION TO REDESIGN

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_HEALaRCHIVES" )/*1*/
/**/
*/
batch serialization does not work correctly
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
