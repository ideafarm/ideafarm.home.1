
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

etThread.delF( tin0P , pbr ) ;
}
    }
        }
            DEL( ps ) ;
            }
                }
#endif
                    }
                        break ;
                        ifcSayIF( T("unrecognized rMiddle.idType: ")+TF1(rMiddle.idType) , flSAY_APPEND | flSAY_LOG ) ;
                    {
                    default :
                    }
                        break ;

                        }
                            if( 5 < rMiddle.cbData ) soul.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_byteTptr , pbData , rMiddle.cbData - 5 ) ;           // BIT MAP
                            soul << (countT)*pbData ; pbData += 1 ;                                                                                 // PROTOCOL
                            nn >> soul ;
                            nicNameC nn( SWABnET4( *(count02T*)pbData ) ) ; pbData += sizeof( count02T ) ;                                          // ADDRESS
                        {
                        if( !POOP )

                        __( rMiddle.cbData < 5 ) ;
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_WKS :
                    }
                        break ;

                        }
                            }
                                time2 = time1 = 0 ;
                                soul << (countT&)time2 ;
                                soul << time1 ;
                                third.timeFromSecondsIF( tin0P , time1 , time2 , SWABnET4( *(count02T*)pbData ) ) ; pbData += sizeof( count02T ) ;
                            {
                            while( cTries -- )
                            countT cTries = 4 ; // REFRESH RETRY EXPIRE MINIMUM
                            ZE( sCountT , time2 ) ;
                            ZE( countT  , time1 ) ;

                            soul << (countT)SWABnET4( *(count02T*)pbData ) ; pbData += sizeof( count02T ) ; // SERIAL
                            _IO_
                        {
                        if( !POOP )

                        __( pbe - pbData < 5 * sizeof( count02T ) )

                        delF( tin0P , psttName ) ;
                        soul << psttName ;
                        header.nameF( tin0P , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;

                        delF( tin0P , psttName ) ;
                        soul << psttName ;
                        header.nameF( tin0P , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                        ZE( strokeS* , psttName ) ;
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_SOA :
                    }
                        break ;
                        soul.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_byteTptr , pbData , rMiddle.cbData ) ;
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_OPTION :
                    case ifcIDtYPEdNSqUERY_NULL :
                    }
                        break ;

                        }
                            delF( tin0P , psttName ) ;
                            soul << psttName ;
                            header.nameF( tin0P , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                            ZE( strokeS* , psttName ) ;

                            pbData += sizeof( count01T ) ;
                            soul << (countT)*(count01T*)pbData ; // cRank
                            _IO_
                        {
                        if( !POOP )

                        __( rMiddle.cbData < sizeof( count01T ) )
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_MX :
                    case ifcIDtYPEdNSqUERY_HINFO :
                    }
                        break ;
                        delF( tin0P , psttName ) ;
                        soul << psttName ;
                        header.nameF( tin0P , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                        ZE( strokeS* , psttName ) ;
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_PTR :
                    case ifcIDtYPEdNSqUERY_MR :
                    case ifcIDtYPEdNSqUERY_MG :
                    case ifcIDtYPEdNSqUERY_MB :
                    case ifcIDtYPEdNSqUERY_CNAME :
                    case ifcIDtYPEdNSqUERY_NS :
                    }
                        delF( tin0P , psttName ) ; // INTENTIONAL FALLTHROUGH
                        soul << psttName ;
                        header.nameF( tin0P , *this , psttName , pbData , pbe - pbData ) ; ___( psttName ) ;
                        ZE( strokeS* , psttName ) ;
                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_MINFO :
#if defined( NEVERdEFINED )
                    }
                        break ;

                        }
                            etThread.delF( tin0P , pbv ) ;
                            etThread.delF( tin0P , psttd ) ;
                            etRock.traceF( tin0P , T("      [dump]    :    ")+T(psttd) ) ;

                            }
                                pbc += tv.csF( tin0P ) + 1 ;
                                etRock.traceF( tin0P , T("      [text]    :    ")+tv   ) ;
                                TN( tv , pbc ) ;
                            {
                            while( pbc < pbe )
                            byteT* pbe = pbv + cbv ;
                            byteT* pbc = pbv ;

                            etThread.strDumpIF( tin0P , psttd , pbv , cbv , flSTRdUMP_FOREIGN ) ; ___( psttd ) ;
                            ZE( strokeS* , psttd ) ;

                            *ps >> pbv ;                                                    //A:ASSUME: A TERMINATING NULL BYTE IS PROVIDED BY soulC EVEN IF NO TERMINATOR WAS STORED
                            ZE( byteT* , pbv ) ;

                            etRock.traceF( tin0P , T("      [cbv]     :    ")+TF2(cbv,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            *ps >> cbv ;
                            ZE( countT , cbv ) ;
                        {
                        while( cText -- )

                        etRock.traceF( tin0P , T("      [cText]   :    ")+TF2(cText,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        *ps >> cText ;
                        ZE( countT , cText ) ;

                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_TXT :
                    }
                        break ;

                        etRock.traceF( tin0P , T("      [nicName] :    ")+T(nnv) ) ;
                        nnv << *ps ;
                        nicNameC nnv ;

                        _IO_
                    {
                    case ifcIDtYPEdNSqUERY_A :
                {
                if( idClass == 1 ) switch( idType )

                etRock.traceF( tin0P , T("      [ttl]     :    ")+TT(timeToLive1,timeToLive2) ) ;
                *ps >> (countT&)timeToLive2 ;
                *ps >>          timeToLive1 ;
                ZE( sCountT , timeToLive2 ) ;
                ZE( countT  , timeToLive1 ) ;

                etRock.traceF( tin0P , T("      [class]   :    ")+TF2(idClass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                *ps >> idClass ;
                ZE( countT , idClass ) ;

                etRock.traceF( tin0P , T("      [type]    :    ")+(postType?T(postType):TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)) ) ;
                const osTextT* postType = processGlobal4S::_processGlobal4I_IF().mapIdTypeDnsQuery( idType ) ;
                *ps >> idType ;
                ZE( countT , idType ) ;

                etRock.traceF( tin0P , T("      [domain]  :    ")+tDomainGross ) ;
                TN( tDomainGross , psttw ) ;
                if( psttw ) ((tin1S&)tin0P).pEtScratch->strConvertToLowerCaseF( tin0P , psttw ) ; ___( psttw ) ;
                *ps >> psttw ;
                ZE( strokeS* , psttw ) ;

                etRock.traceF( tin0P , T("reply [section] :    ")+(postSection?T(postSection):TF2(idSection,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)) ) ;
                const osTextT* postSection = processGlobal4S::_processGlobal4I_IF().mapIdSectionDnsReply( idSection ) ;
                *ps >> idSection ;
                ZE( countT , idSection ) ;

                _IO_
            {
            if( ps )
            stsReplies >> ps ;
            ZE( soulC* , ps ) ;
            _IO_
        {
        while( stsReplies )

        }
            DEL( ps ) ;
            }
                etRock.traceF( tin0P , T("      [class]   :    ")+TF2(idClass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                *ps >> idClass ;
                ZE( countT , idClass ) ;

                etRock.traceF( tin0P , T("      [type]    :    ")+(postType?T(postType):TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)) ) ;
                const osTextT* postType = processGlobal4S::_processGlobal4I_IF().mapIdTypeDnsQuery( idType ) ;
                *ps >> idType ;
                ZE( countT , idType ) ;

                etRock.traceF( tin0P , T("query [domain]  :    ")+tDomainGross ) ;
                TN( tDomainGross , psttw ) ;
                if( psttw ) ((tin1S&)tin0P).pEtScratch->strConvertToLowerCaseF( tin0P , psttw ) ; ___( psttw ) ;
                *ps >> psttw ;
                ZE( strokeS* , psttw ) ;
                _IO_
            {
            if( ps )
            stsQueries >> ps ;
            ZE( soulC* , ps ) ;
            _IO_
        {
        while( stsQueries )
        _IO_
    {
    if( !bFail )

    }
        }
            etRock.traceF( tin0P , T("!exception / could not parse reply [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            bFail = 1 ;
            POOPRqUIET
        {
        if( rc )

        }
            etThread.delF( tin0P , pbHeaderAndQueriesNU ) ;
            rc = POOP ;
            ((tin1S&)tin0P).pEtScratch->dnsParseF( tin0P , pbHeaderAndQueriesNU , countTC() , stsQueries , stsReplies , pbr , cbr ) ;
            ZE( byteT* , pbHeaderAndQueriesNU ) ;
        {
        ZE( countT , rc ) ;
        SCOOPS
        _IO_
    {
    IFsCRATCHoK
    ZE( boolT , bFail ) ;
    stackC stsQueries(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
    stackC stsReplies(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;

    etThread.osEditF( tin0P , tFile ) ; // THIS WILL ONLY BE USEFUL IF IFC HAS BEEN CONFIGURED TO USE AN EDITOR THAT CAN DISPLAY HEX
    etThread.boxPutF( tin0P , tFile , pbr , cbr ) ;
    TN( tFile , "///d/tmp/" ) ; tFile += TF1(DDNAME)+T(".ttt") ;
{
if( !POOP )

//etThread.dnsQueryF( tin0P , pbr , cbr , tName , ifcIDtYPEdNSqUERY_CNAME ) ; ___( pbr ) ;
etThread.dnsQueryF( tin0P , pbr , cbr , tName , ifcIDtYPEdNSqUERY_TXT ) ; ___( pbr ) ;
//etThread.dnsQueryF( tin0P , pbr , cbr , tName , ifcIDtYPEdNSqUERY_A ) ; ___( pbr ) ;
ZE( countT , cbr ) ;
ZE( byteT* , pbr ) ;

//TN( tName , "ipdos.ideafarm.com" ) ;
  TN( tName , "testtxt.hidden.ideafarm.com" ) ;
//TN( tName , "testtxt_hidden.ideafarm.com" ) ;
//TN( tName , "dns1.ideafarm.com" ) ;

//U:: PULL ALL PARAMETRIC VALUES FROM COMMAND LINE PARAMETERS

etherC& etRock = etherC::etRockIF( tin0P ) ;

TODO

// OBSOLETES 467_

// BASELINE: 467_

/*1*/WAKEhIDE( "ifcIDaDAM_TOOLdUMPdNSrEPLY" )/*1*/
/**/
*/
i dump the reply image to a dns request, and trace out its field values
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

