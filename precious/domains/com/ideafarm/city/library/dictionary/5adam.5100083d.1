
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;


#endif

    }
        ++ s ; ether.osSleepF( tin0P , TOCK ) ;
    {
    while( cWalkers )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    etThread.delF( tin0P , pstt1PseudoVolumes ) ;
    }
        etThread.osThreadF( TaRG1( tmWalkerF ) , (countT)&cWalkers , (countT)psttRootFolder , (countT)pcArg ) ; psttRootFolder = 0 ;
        inc02AM( cWalkers ) ;
        etThread.strMakeF( tin0P , LF , psttRootFolder , T(psttc1)+T("ideafarm.archives.rejects/") ) ; ___( psttRootFolder ) ;
        ZE( strokeS* , psttRootFolder ) ;

        if( ether ) break ;
    {
    FORsTRINGSiN1( pstt1PseudoVolumes )
    etThread.diskFindFileOrDirF( tin0P , pstt1PseudoVolumes , tLikePseudoVolumes ) ; ___( pstt1PseudoVolumes ) ;
    ZE( strokeS* , pstt1PseudoVolumes ) ;
    TN( tLikePseudoVolumes , "///d/ideafarm.home.101/devices/" ) ;

    ZE( countT , cWalkers ) ;

#else

    etThread.diskWalkF( tin0P , cDirs , cFiles , T("///e/") , ether , flDISKwALK_null , walkCBF , pcArg , 0 , 0 ) ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs  ) ;

#if defined( PRELUDE )

countT pcArg[] = { (countT)&stJob } ;

while( cDo -- ) etThread.osThreadF( TaRG1( tmZapperF ) , (countT)&stJob ) ;
countT cDo = 0x20 ;

stackC stJob( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;

TODO

DONE( tmZapperF )
}
    }
        stJobP.ungrabF( tin0P ) ;
        }
            stJobP.grabF( tin0P , TAG( TAGiDnULL ) ) ;

            etThread.delF( tin0P , pstt1Job ) ;
            }
                while( !ether && ~hFindFile && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        }
                            }
                                }
                                    //etThread.traceF( tin0P , T("zapped:     ")+tLong ) ;
                                    etThread.boxZapF( tin0P , tLong ) ;
                                    //etThread.traceF( tin0P , T("zapping:    ")+tLong ) ;

                                    TN( tLong , psttLong ) ;
                                {
                                else
                                }
                                    etThread.traceF( tin0P , T("found2: [timeWritten,name]:    ")+TT(timeWrittenArchive.time1,timeWrittenArchive.time2)+tb4+tShort ) ;
                                    etThread.traceF( tin0P , T("found1: [timeWritten,name]:    ")+TT(pInfoFile->timeWritten1,pInfoFile->timeWritten2)+tb4+tShort ) ;
                                    etThread.traceF( tin0P , T("elapse:                        ")+TT(timeE.time1,timeE.time2) ) ;
                                {
                                if( timeE.time2 > 0 || ( !timeE.time2 && timeE.time1 > TICK ) )
                                etThread.osTimeSubtractF( tin0P , timeE.time1 , timeE.time2 , timeWrittenArchive.time1 , timeWrittenArchive.time2 ) ;
                                timeS timeE = timeWrittenReject ;

                                }
                                    thirdC::getFileTimeIF( tin0P , fir , &timeWrittenReject , 0 , 0 ) ;
                                    fileC fir( tin0P , psttLong , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 0 , 0 ) ;
                                {
                                timeS timeWrittenReject = timeS() ;

                                }
                                    thirdC::getFileTimeIF( tin0P , fir , &timeWrittenArchive , 0 , 0 ) ;
                                    fileC fir( tin0P , pInfoFile->psttIfoName , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 0 , 0 ) ;
                                {
                                timeS timeWrittenArchive = timeS() ;
                            {
                            else
                            }
                                etThread.traceF( tin0P , T("folder found: ")+tShort ) ;

                                }
                                    etThread.delF( tin0P , psttShort ) ;
                                    etThread.delF( tin0P , psttnu ) ;
                                    tShort  = T(psttShort) ;
                                    etThread.strBisectF( tin0P , psttnu , psttShort , pInfoFile->psttIfoName , T("/") , - 2 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttShort ) ;
                                    ZE( strokeS* , psttShort ) ;
                                    ZE( strokeS* , psttnu ) ;
                                {
                            {
                            if( !tShort.csF( tin0P ) )        // IF A DIRECTORY

                            }
                                etThread.delF( tin0P , psttShort ) ;
                                etThread.delF( tin0P , psttnu ) ;
                                tShort  = T(psttShort) ;
                                etThread.strBisectF( tin0P , psttnu , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttShort ) ;
                                ZE( strokeS* , psttShort ) ;
                                ZE( strokeS* , psttnu ) ;
                            {
                            TN( tShort , "" ) ;
                        {
                        else
                        if( !pInfoFile || !pInfoFile->psttIfoName ) etThread.traceF( tin0P , T("not found") ) ;
                        bDone = 1 ;                                                                             // IN THE UNLIKELY EVENT THAT THERE ARE MULTIPLE FILES IN THE ARCHIVE WITH THE SAME PATTERN (TIMESTAMPS PLUS HASH), I DON'T CARE ; MY LOGIC JUST CARES WHETHER THE PATTERN EXISTS IN THE ARCHIVE
                    {
                    if( !bDone )

                    //etThread.traceF( tin0P , T("called  diskFindFileOrDirF") ) ;
                    //((tin1S&)tin0P).pc Utility[ 0 ] -- ;
                    //etThread.diskFindFileOrDirF( tin0P , pInfoFile , hFindFile , tPath , &pat ) ; ___( pInfoFile ) ;
                    //((tin1S&)tin0P).pc Utility[ 0 ] ++ ;

                    }
                        }
                            etThread.strMakeFromOsTextF( tin0P , pInfoFile->psttIfoName , iffn ) ; ___( pInfoFile->psttIfoName ) ;
                            ifFileNameC iffn( tin0P , etThread , pInfoFile->postOsName ) ;
                        {
                        if( pInfoFile && !pInfoFile->psttIfoName )

                        ((thirdC&)etThread).dosFindFileOrDirPrivateF( tin0P , pInfoFile , hFindFile , osfnLike ) ;

                        //etThread.traceF( tin0P , T("osfnLike:    ")+T(osfnLike) ) ;
                        osFileNameC osfnLike( tin0P , etThread , tLike ) ;
                        //etThread.traceF( tin0P , T("tLike:       ")+tLike ) ;
                        TN( tLike , "" )  ; tLike = tPath+T(psttPattern) ;
                    {

                    //etThread.traceF( tin0P , T("calling diskFindFileOrDirF") ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                ZE( boolT , bDone ) ;
                handleC hFindFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                patternC pat( tin0P , etThread , psttPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                TN( tPath , "" ) ; tPath = T("///e/ideafarm.archives/wo.ideafarm/")+T(psttYear)+T("/") ;

                //etThread.traceF( tin0P , T("job:    ")+T(psttYear)+tb4+T(psttPattern)+tb4+T(psttLong) ) ;

                }
                    else                    { BLAMMO ; }
                    else if( !psttLong    ) psttLong    = (strokeS*)psttc1 ;
                    else if( !psttPattern ) psttPattern = (strokeS*)psttc1 ;
                         if( !psttYear    ) psttYear    = (strokeS*)psttc1 ;
                {
                FORsTRINGSiN1( pstt1Job )
                ZE( strokeS* , psttLong    ) ;
                ZE( strokeS* , psttPattern ) ;
                ZE( strokeS* , psttYear    ) ;
            {
            if( !ether )

            stJobP.ungrabF( tin0P ) ;

            stJobP >> pstt1Job ;
            ZE( strokeS* , pstt1Job ) ;
        {
        while( stJobP && !ether )
        stJobP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {
    while( !ether )
    TN( tb4   , "    " ) ;
    
    stackC& stJobP = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmZapperF )

DONE( tmWalkerF )
}
    etThread.traceF( tin0P , T("end:      ")+TF2(cWalkersP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tRootFolder ) ;
    dec02AM( cWalkersP ) ;

    }
        }
            etThread.traceF( tin0P , T("failed:   ")+tRootFolder ) ;
            POOPRqUIET
        {
        if( POOP )
        ((tin1S&)tin0P).pEtScratch->diskWalkF( tin0P , cDirs , cFiles , tRootFolder , ether , flDISKwALK_null , walkCBF , pcArgP , 0 , 0 ) ;
        SCOOPS
    {
    IFsCRATCHoK    
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs  ) ;

    etThread.traceF( tin0P , T("begin:    ")+tRootFolder ) ;

    etThread.delF( tin0P , psttRootFolderP ) ;
    TN( tRootFolder , psttRootFolderP ) ;
    TN( tb4    , "    " ) ;

    countT*  pcArgP          =  (countT*)pTaskP->c3 ;
    strokeS* psttRootFolderP = (strokeS*)pTaskP->c2 ;
    countT&  cWalkersP       = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmWalkerF )

}
    return 0 ;

    }
        }
            }
                etThread.delF( tin0P , psttLower ) ;
                etThread.delF( tin0P , pstt1w ) ;
                }
                    }
                        }
                            }
                                etThread.delF( tin0P , psttFind ) ;
                                }
                                    stJobP << pstt1Job ; pstt1Job = 0 ;
                                    etThread.strFuseSeparateF( tin0P ,      pstt1Job , tLong    ) ;
                                    etThread.strFuseSeparateF( tin0P ,      pstt1Job , tPattern ) ;
                                    etThread.strFuseSeparateF( tin0P ,      pstt1Job , tYear    ) ;
                                    etThread.strMakeF(         tin0P , LF , pstt1Job , 0 , 3 * CSpREFIX + tYear.csF( tin0P ) + tPattern.csF( tin0P ) + tLong.csF( tin0P ) ) ; ___( pstt1Job ) ;
                                    ZE( strokeS* , pstt1Job ) ;
                                
                                    }
                                        ++ s ; ether.osSleepF( tin0P , TOCK ) ;
                                    {
                                    while( stJobP > ( TUCK >> 4 ) )
                                    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                                {

                                //etThread.traceF( tin0P , tPath+tb4+tPattern ) ;
                                TN( tPattern , "" ) ; tPattern = T("*")+T(psttFind)+T("*") ;
                                TN( tPath    , "" ) ; tPath    = T("///e/ideafarm.archives/wo.ideafarm/")+tYear+T("/") ;

                                //etThread.traceF( tin0P , tYear+tb4+T(psttFind) ) ;
                                etThread.strSubstringF( tin0P , psttFind , idf , idl , psttc1 , 0 ) ; ___( psttFind ) ;
                                ZE( strokeS* , psttFind ) ;

                                countT idl = etThread.strIdF( tin0P , countTC( 1 ) , T(".") , psttc1 , 8 ) ;
                                countT idf = etThread.strIdF( tin0P , countTC( 1 ) , T(".") , psttc1 , 5 ) ;

                                // !ideafarm.a.2.00000000.00000001.20001231@1617.20170131@0335.9a088138d0158dd07a8035d87a7cbdce.001.fset.zip
                                //                                |------------------------------------------------------------|

                                //etThread.traceF( tin0P , tYear+tb4+T(psttc1) ) ;

                                if( !( cRejectsWas % TUCK ) ) etThread.traceF( tin0P , TF2(cRejectsWas,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                countT cRejectsWas = incv02AM( cRejects ) ;
                            {
                            else
                            if( 1 != etThread.strIdF( tin0P , countTC( 1 ) , T("!ideafarm.") , psttc1 , 1 ) ) bNope = 1 ;
                        {
#endif

                        case 9:
                        case 8: { tYear = T(psttc1)                                                                          ; break ; }
                        case 7: { if( 1 != etThread.strIdF( tin0P , countTC( 1 ) , T("wo.ideafarm"              ) , psttc1 , 1 ) ) bNope = 1 ; break ; }
                        case 5: { if( 1 != etThread.strIdF( tin0P , countTC( 1 ) , T("ideafarm.archives.rejects") , psttc1 , 1 ) ) bNope = 1 ; break ; }

                        // | 9        !ideafarm.a.2.00000000.00000001.20001231@1617.20170131@0335.9a088138d0158dd07a8035d87a7cbdce.001.fset.zip
                        // | 8        2008
                        // | 7        wo.ideafarm
                        // | 6        000b46a0.f01ba6aa.3c259f6f.8f010000.0d010000
                        // | 5        ideafarm.archives.rejects
                        // | 4        ssd2.arc.209901
                        // | 3        devices
                        // | 2        ideafarm.home.101
                        // | 1        d
                        // | ///d/ideafarm.home.101/devices/ssd2.arc.209901/ideafarm.archives.rejects/000b46a0.f01ba6aa.3c259f6f.8f010000.0d010000/wo.ideafarm

#else
                        case 7:
                        case 6: { tYear = T(psttc1)                                                                          ; break ; }
                        case 5: { if( 1 != etThread.strIdF( tin0P , countTC( 1 ) , T("wo.ideafarm"              ) , psttc1 , 1 ) ) bNope = 1 ; break ; }
                        case 3: { if( 1 != etThread.strIdF( tin0P , countTC( 1 ) , T("ideafarm.archives.rejects") , psttc1 , 1 ) ) bNope = 1 ; break ; }
                        case 2: { if( 1 != etThread.strIdF( tin0P , countTC( 1 ) , T("from."                    ) , psttc1 , 1 ) ) bNope = 1 ; break ; }

                        // | 7        !ideafarm.a.2.00000000.00000001.20001231@1617.20170131@0335.9a088138d0158dd07a8035d87a7cbdce.001.fset.zip
                        // | 6        2008
                        // | 5        wo.ideafarm
                        // | 4        000b46d2.b5f08edd.3c259f6f.40c10000.09a20000
                        // | 3        ideafarm.archives.rejects
                        // | 2        from.hdd4.arc.2021062201
                        // | 1        e
                        // | ///e/from.hdd4.arc.2021062201/ideafarm.archives.rejects/000b46d2.b5f08edd.3c259f6f.40c10000.09a20000/wo.ideafarm/2008/!ideafarm.a.2.00000000.00000001.20001231@1617.20170131@0335.9a088138d0158dd07a8035d87a7cbdce.001.fset.zip

#if defined( PRELUDE )
                    {
                    switch( ++ idw )

                    //etThread.traceF( tin0P , TF3((countT)(idw+1),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+T(psttc1) ) ;

                    if( bNope ) break ;
                {
                FORsTRINGSiN1( pstt1w )
                TN( tYear  , ""     ) ;
                ZE( boolT  , bNope  ) ;
                ZE( countT , idw    ) ;

                etThread.strWordsF( tin0P , pstt1w , psttLower , sttq , T("/") ) ; ___( pstt1w ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , pstt1w ) ;

                // ///e/from.ssd2.arc.years01/ideafarm.archives.rejects/000b46a1.f1086dbc.3c259f6f.45b00000.05700000/wo.ideafarm/2009/!ideafarm.a.2.00000000.00000001.20090508@2258.20150910@0342.23a33919970b0e2827e5350b0079f255.001.fset.zip

                //etThread.traceF( tin0P , psttLower ) ;
                etThread.strConvertToLowerCaseF( tin0P , psttLower , psttzLong ) ; ___( psttLower ) ;
                ZE( strokeS* , psttLower ) ;

                //etThread.traceF( tin0P , tLong ) ;

                TN( tb4    , "    " ) ;
            {
            if( !bDir )
            boolT bDir = psttzLong[ CSpREFIX - 1 + psttzLong->idAdam ].idAdam == '/' ;

            strokeS* psttzLong = tLong ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            TN( tLong , iffn ) ;
            ifFileNameC iffn( tin0P , etThread , postNameP ) ;
        {
        if( !bQuitP )

        stackC& stJobP   = *(stackC*)pcArgP[ 0 ] ;
        etherC& ether    = etherC::etPrimeIF() ;
        etherC& etThread = *((tin1S&)tin0P).pEther ;

        _IO_
    {
    if( postNameP && *postNameP )

    _IO_
{
boolT walkCBF( tin0S& tin0P , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

countT cRejects ;

#define PRELUDE

/*1*/WAKEsHOWtEXT( "tool.archives.purge.rejected.files.faster" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
