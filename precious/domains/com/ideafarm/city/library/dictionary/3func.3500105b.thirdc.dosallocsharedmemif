
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    osTraceWrongNodeIF( tin0P , (byteT*)handleP.cNoteF() , "dosAllocSharedMemIF: cNote" ) ;

    #endif

        THREADmODE1rESTORE
        if( !( F(flagsP) & flOPENsHAREDmEMORY_DOnOTsERIALIZE ) && F(processGlobal2I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal2I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal4I.grabMemorySpace.ungrabF( tin0P ) ;

        }
            }
                }
                    }
                        }
                            //}
                            //    CONoUTrAW( os ) ;
                            //    OStEXTAK( os , "\"\r\n" ) ;
                            //    OStEXTA(  os , ostoOsName ) ;
                            //    OStEXTAK( os , "\r\ndosAllocSharedMemIF / new: \"" ) ;
                            //    OStEXT( os , TUCK << 1 ) ;
                            //{
                            //if( thirdC::c_strstrIF( ostoOsName , ".batonC." ) )

                            #endif
                                thirdC::setAddressUsageBitsIF( (const byteT*)pv , ifcIDtYPEaDDRESSuSAGE_SHARED ) ;
                            #if defined( SHOWmEMgRAINS )
                            //CS:PSEUDOdUPLICATE: 35001041 3500105b 3300000d 3300002d

                            handleP.osF( ifcIDtYPEhANDLE_SHAREDmEMORY , (countT)osh , 0 , (countT)pv ) ;
                
                            }
                                if( offr == CsHAREDmEMiNFO ) { BLAMMO ; }
                                }
                                    }
                                        break ;
                                        processGlobal2I._thirdC_pSharedMemInfo[ offr ].pv  = pv ;
                                        processGlobal2I._thirdC_pSharedMemInfo[ offr ].osh = (countT)osh ;
                                        thirdC::c_strncpyIF( tin0P , processGlobal2I._thirdC_pSharedMemInfo[ offr ].postName , ostoOsName , sizeof processGlobal2I._thirdC_pSharedMemInfo[ offr ].postName ) ;
                                    {
                                    if( !*processGlobal2I._thirdC_pSharedMemInfo[ offr ].postName )
                                    _IO_
                                {
                                for( offr = 0 ; offr < CsHAREDmEMiNFO ; offr ++ )
                                ZE( countT , offr ) ;
                                _IO_
                            {
                            //DUPLICATED CODE: 1020068 1020061 1020132

                            //}
                            //    etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                            //    //CONoUTrAW(  ostoSay ) ;
                            //    //OStEXTAK( ostoSay , "\r\n" ) ;
                            //    OStEXTA(  ostoSay , ostoOsName ) ;
                            //    OStEXTAK( ostoSay , " NEW: " ) ;
                            //    OStEXTC(  ostoSay , pv , ' ' ) ;
                            //    OStEXT(   ostoSay , TUCK << 2 ) ;
                            //{
                            //if( thirdC::c_strstrIF( tin0P , ostoOsName , "napSlab" ) )
                            //CAN WRITE TO LOG SINCE NO EXCEPTION HANDLER WILL BE REGISTERED

                            //if( ((tin1S&)tin0P).pc Utility[ 0 ] )
                            _IO_
                        {
                        else
                        }
                            osh = 0 ;
                            BOSpOOP
                            BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                            _IO_
                        {
                        if( POOP )
        
                        //__( IsBadReadPtr( pv , 1 ) ) ; //U::ELIMINATE USE OF THIS FUNCTION AS ADVISED BY MSDN (CAN TRIP A GUARD PAGE)
                        //U:: THE NEXT LINE, WHEN NOT COMMENTED OUT, WAS NOT REPORTED BY LINT

                        //}
                        //    //etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                        //    LOGrAW(   ostoSay ) ;
                        //    OStEXTAK( ostoSay , " + (file mapping) / dosAllocSharedMemIF\r\n" ) ;
                        //    OStEXTC(  ostoSay , save , '0' ) ;
                        //    OStEXT(   ostoSay , TUCK >> 2 ) ;
                        //{
                        //if( ((tin1S&)tin0P).pc Utility[ 0 ] )

                        voidT* pv = (voidT*)((tin1S&)tin0P).brcRaw ;
                        countT save = ((tin1S&)tin0P).brcRaw ;
                        _IO_
                    {
                    else
                    }
                        //LOGrAW3( "DosAllocSharedMem: MapViewOfFileExNuma returned " , ((tin1S&)tin0P).brcRaw , "\r\n" ) ;
                        //CONoUTrAW3( "DosAllocSharedMem: MapViewOfFileExNuma returned " , ((tin1S&)tin0P).brcRaw , "\r\n" ) ;
                        BOSdOnOTtEST( WHATgbo , GetLastError() )

                        osh = 0 ;
                        BOSpOOP
                        BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                        _IO_
                    {
                    if( POOP )

                    }
                        BOSpOOP
                        BOS( WHATgbo , BOSoK , MapViewOfFileExNuma( osh , osFlagsMap , 0 , 0 , 0 , 0 , thirdC::osOffNumaNodeValidChosenIF( processGlobal2I.idNumaNode ) ) )
                        _IO_
                    {

                    //}
                    //    LOGrAW(    ostoSay ) ;
                    //    CONoUTrAW( ostoSay ) ;
                    //    
                    //    OStEXTAK( ostoSay , "\"\r\n" ) ;
                    //    OStEXTA(  ostoSay , postP ) ;
                    //    OStEXTAK( ostoSay , " \"" ) ;
                    //    OStEXTC(  ostoSay , ((tin1S&)tin0P).brcRaw , 0 ) ;
                    //    OStEXTAK( ostoSay , " " ) ;
                    //    OStEXTC(  ostoSay , cbw , 0 ) ;
                    //    OStEXTAK( ostoSay , " " ) ;
                    //    OStEXTC(  ostoSay , cbP , 0 ) ;
                    //    OStEXTAK( ostoSay , " " ) ;
                    //    OStEXTC(  ostoSay , ((tin1S&)tin0P).pag1->idAdam , 0 ) ;
                    //    OStEXTAK( ostoSay , "dosAllocSharedMemIF [idAdam,cbP,cbw,osh,postP]: " ) ;
                    //    OStEXT(   ostoSay , TUCK << 2 ) ;
                    //{
                    //if( ((tin1S&)tin0P).pc Utility[ 0 ] )

                    ;
                        : FILE_MAP_ALL_ACCESS
                        ? FILE_MAP_READ
                    const flagsT osFlagsMap = F(flagsP) & flOPENsHAREDmEMORY_READoNLY

                    //}
                    //    etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                    //
                    //    OStEXTA(  ostoSay , ostoOsName ) ;
                    //    OStEXTAK( ostoSay , "dosAllocSharedMemIF / dosAllocSharedMemIF / created napSlab aok [osName]:    " ) ;
                    //    OStEXT(   ostoSay , TUCK << 1 ) ;
                    //{
                    //if( c_strstrIF( tin0P , ostoOsName , "napSlab" ) )
                    //COMMENTED OUT BECAUSE WILL CLUTTER LOG FILE BECAUSE AN EXCEPTION HANDLER IS NOT YET REGISTERED
                    _IO_
                {
                _IO_
            {
            if( !POOP )

            }
                __1
                osh = 0 ;
                BOSpOOP
                BOS( WHATgbo , BOSoK , CloseHandle( osh ) )
                _IO_
            {
            if( bExisted )

            HANDLE osh = (HANDLE)((tin1S&)tin0P).brcRaw ;

            BOSpOOP
            boolT bExisted = ((tin1S&)tin0P).brcQuery == ERROR_ALREADY_EXISTS ;
            BOS( WHATgbo , BOSoK , CreateFileMappingNuma( (voidT*)( phFileP ? phFileP->osF( ifcIDtYPEhANDLE_FILE ) : -1 ) , &sa , osFlagsOpen , 0 , cbw , ostoOsName , thirdC::osOffNumaNodeValidChosenIF( processGlobal2I.idNumaNode ) ) )

            if( F(flagsP) & flOPENsHAREDmEMORY_DOnOTcOMMIT ) osFlagsOpen |= SEC_RESERVE ;

            ;
                : PAGE_READWRITE
                ? PAGE_READONLY
            flagsT osFlagsOpen = F(flagsP) & flOPENsHAREDmEMORY_READoNLY

            SECURITYaTTRIBUTE_saUNRESTRICTED( 0 ) ;
            _IO_
        {
        if( !POOP )

        }
            if( ( info.cbUsed || info.cbUsedHigh ) && ( info.cbUsed != cbw || info.cbUsedHigh ) ) { BLAMMO ; } //BLAMMO BECAUSE TYPICALLY CALLING CODE WILL ASSUME THAT IMPOTENCE IS DUE TO TEMPORARY UNAVAILABILITY OF MEMORY

            thirdC::dosQueryFileInfoIF( tin0P , pInfo , *phFileP ) ;
            infoFileS* pInfo = &info ;
            infoFileS info( tin0P ) ;
            _IO_
        {                      //ADDED BECAUSE bookC CONTAINED AN UNDETECTED BUG INVOLVING AN EXISTING FILE MAPPED TO A SMALL NAPKIN, WITH APPLICATION CODE RELYING UPON THE LENGTH AS DECLARED WITHIN A HEADER WITHIN THE FILE, CAUSING AN A.V. EXCEPTION DUE TO THE ERRONEOUSLY SMALL NAPKIN
        if( phFileP && !POOP ) //20140410@0950: ADDED THIS VALIDATION OF FILE SIZE ; WILL NEED TO MAKE THIS VALIDATION OPTIONAL IF EVER WANT TO MEMORY MAP ONLY A PORTION OF A FILE

        //LOGrAW( "\r\n" ) ;
        //LOGrAW( ostoOsName ) ;
        //LOGrAW( "shared [ostoOsName]:    " ) ;

        }
            }
                }
                    break ;
                    __1 ;
                {
                if( !c_strcmpIF( tin0P , processGlobal2I._thirdC_pSharedMemInfo[ offr ].postName , ostoOsName ) )
            {
            for( countT offr = 0 ; offr < CsHAREDmEMiNFO ; offr ++ )
            _IO_
        {

        if( !( F(flagsP) & flOPENsHAREDmEMORY_DOnOTsERIALIZE ) && F(processGlobal2I.flCt) & flCTdTg_tinMainInPool && !( F(processGlobal2I.flDt) & flCTdTg_tinMainInPool ) ) processGlobal4I.grabMemorySpace.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        THREADmODE1oN( flTHREADmODE1_QUIETiMPOTENCE )       // SUPPRESS CALLS WITHIN gruntF() TO traceF() TO AVOID NONMONOTONIC GRABBING

        }
            c_zReplaceIF( tin0P , (osTextT*)(const osTextT*)ostoOsName , '/' , '.' ) ;
            OStEXTA(  ostoOsName  , postP ) ;
            OStEXTAK( ostoOsName  , "." ) ;
            else                                                  { OStEXTCF( ostoOsName , idMemorySpaceP ? idMemorySpaceP : ((tin1S&)tin0P).pag1->idMemorySpace , '0' ) ; }
            if( F(flagsP) & flOPENsHAREDmEMORY_ALLmEMORYsPACES )  { OStEXTAK( ostoOsName  , "_" ) ; }
            OStEXTAK( ostoOsName  , "." ) ;
            else                                                  { OStEXTCF( ostoOsName , processGlobal1I.idAdamRoot == ifcIDaDAM_TOOLnAPwORDvIEWER && ((tin1S&)tin0P).pag1->_thirdC_.idHomeOverride ? ((tin1S&)tin0P).pag1->_thirdC_.idHomeOverride : processGlobal2I.idHome , '0' ) ; }
            if( F(flagsP) & flOPENsHAREDmEMORY_ALLhOMES         ) { OStEXTAK( ostoOsName  , "_" ) ; }
            OStEXTAK( ostoOsName  , "." ) ;
            else                                                  { OStEXTA(  ostoOsName , thirdC::postUserNameIF() ) ; }
            if( F(flagsP) & flOPENsHAREDmEMORY_ALLuSERS         ) { OStEXTAK( ostoOsName  , "_" ) ; }
            _IO_
        {
        OStEXTA(  ostoOsName  , postPrefix ) ;
        OStEXT(   ostoOsName , COSTnAPKINnAMEmAX + 1 )
        //CODEsYNC: DUPLICATE CODE 1020061 1020068

        ;
            :  "Local\\ideafarm.domains.com.ideafarm.1."
            ? "Global\\ideafarm.domains.com.ideafarm.1."

        osTextT* postPrefix = F(flagsP) & flOPENsHAREDmEMORY_ALLsESSIONS

    #elif defined( __NT__ )

        if( POOP ) pv = 0 ;
        BOSpOOP
        BOSI( WHATgbo , BOSfAIL , DosAllocSharedMem( &pv , ostoName , cbw , PAG_COMMIT | PAG_EXECUTE | PAG_READ | PAG_WRITE ) )

        OStEXTA( ostoName  , postP ) ;
        OStEXTAK( ostoName  , "\\sharemem\\" ) ;
        OStEXT( ostoName , COSToSfILEnAMEmAX + 11 )

    #ifdef __OS2__

    ZE( voidT* , pv ) ;
    //if( tin0P.idTypeTin == ifcIDtYPEtIN_123 ) ((tin123S&)tin0P).pc Utility[ 1 ] = cbw ;
    if( !cbw ) cbw = 0x100000 ;
    countT cbw = cbP ;

    _IO_

    }
        if( POOP ) return ;
        __( idMemorySpaceP && !( F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tin0P ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tin0P ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        FV(flOPENsHAREDmEMORY,flagsP) ;
        __( phFileP && F(flagsP) & flOPENsHAREDmEMORY_DOnOTcOMMIT ) ;
        __( idMemorySpaceP == ifcIDmEMORYsPACE_GLASS2 && processGlobal1I.idAdamRoot != ifcIDaDAM_2GLASS2 && processGlobal1I.idAdamRoot != ifcIDaDAM_PISS && processGlobal1I.idAdamRoot != ifcIDaDAM_1DRIVER ) ;        // PISS SO etherSoilF CAN CREATE SETTINGS FILES FOR THE glass2 MEMORY SPACE
        __( idMemorySpaceP == ifcIDmEMORYsPACE_GLASS1 && processGlobal1I.idAdamRoot != ifcIDaDAM_2GLASS2 && processGlobal1I.idAdamRoot != ifcIDaDAM_PISS && processGlobal1I.idAdamRoot != ifcIDaDAM_1DRIVER ) ;        // PISS SO etherSoilF CAN CREATE SETTINGS FILES FOR THE glass1 MEMORY SPACE
        __( COSToSfILEnAMEmAX < thirdC::c_strlenIF( tin0P , postP ) ) ;
        __( !!thirdC::c_strchrIF( tin0P , postP , '\\' ) ) ;
        //__( !!thirdC::c_strchrIF( tin0P , postP , '/' ) ) ;
        __( !*postP ) ;
        if( POOP ) return ;
        __Z( postP ) ;
        #endif
            { ZE( boolT , foo ) ; __( !foo && sizeof(countT) != sizeof(HANDLE) ) ;  }
        #if defined( __NT__ )
        if( POOP ) return ;
    {
    IFbEcAREFUL    
{
/*1*/voidT thirdC::dosAllocSharedMemIF( tin0S& tin0P , handleC& handleP , const osTextT* const postP , const handleC* phFileP , const countT cbP , const countT idMemorySpaceP , const flagsT flagsP )/*1*/

/**/
*/
 cbP
  cannot contain slash ('/') or backslash ('\\')
  must be less than 240 bytes
 postP
 handleP
arguments
\<A HREF=\"5.1020061.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosAllocSharedMemIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

