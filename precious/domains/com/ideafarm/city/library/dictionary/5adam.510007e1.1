
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

//etThread.osSuspendF( tinP ) ;

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok.  loafing") ) ;

}
    }
        }
            THREADmODE2rESTORE
            while( cExecutiveHealYear ) thirdC::dosSleepWinkIF( tinP ) ;
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        {

        }
            while( ~hStYearToHeal ) ;
            }
                etThread.osThreadF( TaRG3fLAGScBtLS( tmExecutiveHealYearF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cExecutiveHealYear , (countT)psttYear , (countT)&psttzArchive , (countT)&swsPathToArchivesByArchiveName ) ;
                inc02AM( cExecutiveHealYear ) ;

                etThread.strMakeF( tinP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                ZE( strokeS* , psttYear ) ;

                etThread.traceF( tinP , T("year to heal:    ")+T(psttzYear) ) ;
                strokeS* psttzYear = (strokeS*)stYearToHeal.downF( tinP , hStYearToHeal ) ;
            {
            do
            handleC hStYearToHeal( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        ZE( countT , cExecutiveHealYear ) ;

        }
            }
                }
                    }
                        BLAMMO ;                                //SHOULD BE IMPOSSIBLE
                        etThread.delF( tinP , psttYear ) ;
                    {
                    if( !idSlot )
                    stYearToHeal.sinkF( tinP , idSlot , psttYear , flSTACKsINK_UNIQUE ) ;
                    ZE( countT , idSlot ) ;
                    etThread.strMakeF( tinP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                    ZE( strokeS* , psttYear ) ;
                {
                if( tally > 1 )
                countT tally = swTallyByYear ;
                psttzYear = (strokeS*)swTallyByYear.leverF( tinP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swTallyByYear.cFlavorsF( tinP ) ;

            while( ~hSwsPathToArchives ) ;
            }
                etThread.delF( tinP , pstt1PathToYear ) ;
                }
                    etThread.traceF( tinP , T("[tYear,tally]:    ")+tYear+tb4+TF2((countT)swTallyByYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    swTallyByYear ++ ;
                    psttzYear = tYear ;

                    }
                        etThread.delF( tinP , psttYear ) ;
                        tYear = T(psttYear) ;
                        etThread.strWordF( tinP , psttYear , psttc1 , sttq , sttSlash , - 2 ) ; ___( psttYear ) ;
                        ZE( strokeS* , psttYear ) ;
                    {
                    TN( tYear , "" ) ;
                {
                FORsTRINGSiN1( pstt1PathToYear )
                etThread.strConvertToLowerCaseF( tinP , pstt1PathToYear ) ;
                etThread.diskFindFileOrDirF( tinP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                patternC pat( tinP , etThread , tYearPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                ZE( strokeS* , pstt1PathToYear ) ;

                //etThread.traceF( tinP , T("new code [tPathToArchive]:    ")+tPathToArchive ) ;
                TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchive)+tSlash ;
                strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveName.downF( tinP , hSwsPathToArchives ) ;
            {
            do
            handleC hSwsPathToArchives( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            strokeS sttSlash( '/' ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

            switchC swTallyByYear( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzYear ) ;
            ZE( strokeS* , psttzYear ) ;
        {
        stackC stYearToHeal( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

        // FOR EACH YEAR FOLDER (ALL YEARS FOR THIS ARCHIVE NAME (EXAMPLE: ALL YEAR PATHS FOR EVERY YEAR FOR "wo.ideafarm"), LAUNCH A FILE RECORD COLLECTION THREAD
    {
    if( cArchivesWithThisName > 1 )
    etThread.traceF( tinP , T("[cArchivesWithThisName,archive]:    ")+TF2(cArchivesWithThisName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzArchive) ) ;
    swsPathToArchivesByArchiveName.ungrabF( tinP ) ;
    countT cArchivesWithThisName = swsPathToArchivesByArchiveName ;
    psttzArchive = (strokeS*)swsPathToArchivesByArchiveName.leverF( tinP , idf ) ;
    swsPathToArchivesByArchiveName.grabF( tinP , TAG( TAGiDnULL ) ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )    // FOR EACH ARCHIVE NAME (EXAMPLE: "wo.ideafarm")
swsPathToArchivesByArchiveName.ungrabF( tinP ) ;
countT cFlavors = swsPathToArchivesByArchiveName.cFlavorsF( tinP ) ;
swsPathToArchivesByArchiveName.grabF( tinP , TAG( TAGiDnULL ) ) ;
TN( tYearPattern , "?" "?" "?" "?" "/" ) ;                                                              //20221118@1747: "????/" PROUCES A SPURIOUS COMPILER ERROR INVOLVING TRIGRAPH

swsPathToArchivesByArchiveName.lockF( tinP ) ;
}
    }
        etThread.delF( tinP , pstt1Archives ) ;
        }
            }
                swsPathToArchivesByArchiveName.sinkF( tinP , countTC() , psttPathArchives ) ;                           // EXAMPLE: "///c/ipdos.arhives/"

                psttzArchive = tArchive ;

                etThread.traceF( tinP , T("    [tPathArchives,tArchive]:    ")+T(psttPathArchives)+tb4+tArchive ) ;

                }
                    etThread.delF( tinP , psttShorter ) ;
                    tArchive = T(psttShorter) ;
                    etThread.strSubstringF( tinP , psttShorter , idf , idl , tArchiveSlash ) ; ___( psttShorter ) ;
                    ZE( strokeS* , psttShorter ) ;
                {
                if( idl )
                countT idl = tArchiveSlash.csF( tinP ) ? tArchiveSlash.csF( tinP ) - 1 : 0 ;
                countT idf = 1 ;
                TN( tArchive , "" ) ;                                                                                   // EXAMPLE: "wo.ideafarm"

                }
                    etThread.delF( tinP , psttArchiveSlash ) ;
                    tArchiveSlash = T(psttArchiveSlash) ;
                    etThread.strBisectF( tinP , psttPathArchives , psttArchiveSlash , psttc1 , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathArchives ) ; ___( psttArchiveSlash ) ;
                    ZE( strokeS* , psttArchiveSlash ) ;
                {
                TN( tArchiveSlash , "" ) ;                                                                              // EXAMPLE: "wo.ideafarm/"
                ZE( strokeS* , psttPathArchives ) ;                                                                     // EXAMPLE: "///c/ipdos.arhives/"

                etThread.traceF( tinP , T("processing archive ")+T(psttc1) ) ;                                          // EXAMPLE: "///c/ipdos.arhives/wo.ideafarm/"
            {
            FORsTRINGSiN1( pstt1Archives )
            etThread.diskFindFileOrDirF( tinP , pstt1Archives , tLikeArchives ) ; ___( pstt1Archives ) ;
        {
        ZE( strokeS* , pstt1Archives ) ;
    {
    TN( tLikeArchives , "///?/ipdos.archives/" ) ;
{
switchStackC swsPathToArchivesByArchiveName( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzArchive , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
ZE( strokeS* , psttzArchive ) ;
// LOAD swsPathToArchivesByArchiveName WITH VALUES LIKE "///c/ipdos.arhives/" SWITCHED ON VALUES LIKE "wo.ideafarm"

TN( tSlash , "/" ) ;
TN( tb4    , "    " ) ;

TODO

countT cDebug = sizeof( grabAnnotatedS ) ;

DONE( tmExecutiveHealYearF )
}
    dec02AM( cExecutiveHealYearP ) ;
    }
        etThread.traceF( tinP , T("done for archive ")+T(psttzArchiveP) ) ;

        DEL( pSwsMetaByShort ) ;
        pSwsMetaByShort->ungrabF( tinP ) ;

        }
            }
                while( ~hSwsOuter ) ;
                }
                    DELzOMBIE( pfmOuter ) ;

                    }
                        DELzOMBIE( pd ) ;
                        imageCompareS* pd = picOuter + offd ;
                    {
                    for( countT offd = 0 ; offd < cResultStructsNeeded ; offd ++ )

                    fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + cResultStructsNeeded ) ;
                    imageCompareS* picOuter  = (imageCompareS*)&pSwsMetaByShort->downF( tinP , hSwsOuter ) ;
                {
                do
                handleC hSwsOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( cFiles )
            countT cFiles = *pSwsMetaByShort ;
            postzShort = (osTextT*)pSwsMetaByShort->leverF( tinP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cYearSlashShortFileNames ; idf ++ )
        
        //etThread.traceF( tinP , T("deleting metadata") ) ;

        }
            }
                }
                    }
                        }
                            etThread.osThreadF( TaRG3fLAGScBtLS( tmCopyFileF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)psttTo , (countT)psttFrom ) ; psttTo = psttFrom = 0 ;
                            //etThread.traceF( tinP , T("new      [psttTo,psttFrom]:    ")+TF2((countT)psttTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)psttFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            //etThread.traceF( tinP , T("copying [idFrom,new,old,idFrom]:    ")+TF2(idFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttTo)+tb4+T(psttFrom) ) ;

                            etThread.strMakeF( tinP , LF , psttFrom , (strokeS*)stFrom[ idFrom ] ) ; ___( psttFrom ) ;
                            ZE( strokeS* , psttFrom ) ;

                            countT idFrom = 1 + ( cDone ++ % cFrom ) ;

                            stTo >> psttTo ;
                            ZE( strokeS* , psttTo ) ;
                        {
                        while( stTo )
                        ZE( countT , cDone ) ;
                        countT cFrom = stFrom ;

                        while( ~hStPathToYear ) ;
                        }
                            }
                                if( !idSlot ) etThread.delF( tinP , psttLong ) ;
                                stTo.sinkF( tinP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ;
                                ZE( countT , idSlot ) ;
                                //etThread.traceF( tinP , T("sinking to stTo 2 [long]:    ")+T(psttLong) ) ;
                            {
                            else
                            if( stFrom( psttLong ) ) etThread.delF( tinP , psttLong ) ;

                            etThread.strMakeF( tinP , LF , psttLong , T(psttPathToYear)+tShort ) ; ___( psttLong ) ;
                            ZE( strokeS* , psttLong ) ;

                            strokeS* psttPathToYear = (strokeS*)stPathToYear.downF( tinP , hStPathToYear ) ;
                        {
                        do
                        handleC hStPathToYear( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                        while( ~hStUnique ) ;
                        }
                            }
                                while( ~hSwsInner ) ;
                                }
                                    }
                                        if( !idSlot ) etThread.delF( tinP , psttLong ) ;
                                        }
                                            stTo.sinkF( tinP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                            //etThread.traceF( tinP , T("sunk into stTo [cPlatesBefore,long]:    ")+TF2(stTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                        {
                                        else
                                        }
                                            stFrom.sinkF( tinP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                            //etThread.traceF( tinP , T("sunk into stFrom [cPlatesBefore,long]:    ")+TF2(stFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                        {
                                        if( bYoungest && bWinner )
                                        ZE( countT , idSlot ) ;

                                        etThread.strMakeF( tinP , LF , psttLong , T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ) ; ___( psttLong ) ;
                                        ZE( strokeS* , psttLong ) ;
                                    {
                                    if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) )

                                    }
                                        }
                                            break ;
                                            bMatchImage = 0 ;
                                        {
                                        if( picUnique[ offc ] - picInner[ offc ] )
                                    {
                                    for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ )
                                    boolT bMatchImage = 1 ;

                                    //picInner->traceF( tinP , T("inner :    ") ) ;
                                    fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                    imageCompareS* picInner  = (imageCompareS*)&pSwsMetaByShort->downF( tinP , hSwsInner ) ;
                                {
                                do
                                handleC hSwsInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {

                            //pfmUnique->traceF( tinP , stPathToYear , T(bYoungest?"reporting tallies (youngest):    ":"reporting tallies    (older):    ") ) ;

                            //etThread.traceF( tinP , T("[bYoungest,bWinner,cVotes,cVotesMax]:    ")+TF2(bYoungest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bWinner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pfmUnique->cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cVotesMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            boolT bWinner   = pfmUnique->cVotes == cVotesMax ;
                            boolT bYoungest = pfmUnique->timeModRounded == timeModRoundedYoungest ;

                            //for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ ) picUnique[ offc ].traceF( tinP , T("reporting tallies:    ") ) ;

                            //picUnique->traceF( tinP , T("unique:    ") ) ;
                            fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                            imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hStUnique ) ;
                        {
                        do
                        handleC hStUnique( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        stackC stTo(   tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                        stackC stFrom( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                    {
                    else
                    else if(  cWinners > 1 ) etThread.traceF( tinP , T("no healing is done because multiple unique meta are tied for highest votes [short]:    ")+tShort ) ;
                         if( !cWinners     ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE

                    }
                        while( ~hSt ) ;
                        }
                            if( pfmUnique->cVotes == cVotesMax ) cWinners ++ ;

                            //picUnique->traceF( tinP , T("unique:    ") ) ;
                            fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                            imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                        {
                        do
                        handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    ZE( countT , cWinners ) ;

                    }
                        while( ~hSt ) ;
                        }
                            if( cVotesMax < pfmUnique->cVotes ) cVotesMax = pfmUnique->cVotes ;

                            if( timeModRoundedYoungest != pfmUnique->timeModRounded ) continue ;

                            //picUnique->traceF( tinP , T("unique:    ") ) ;
                            fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                            imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                        {
                        do
                        handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    ZE( countT , cVotesMax ) ;

                    }
                        while( ~hSt ) ;
                        }
                            while( ~hSwsOuter ) ;
                            }
                                if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) ) pfmUnique->cVotes ++ ;

                                }
                                    }
                                        break ;
                                        bMatchImage = 0 ;
                                    {
                                    if( picUnique[ offc ] - picInner[ offc ] )
                                {
                                for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ )
                                boolT bMatchImage = 1 ;

                                //}
                                //    pfmInner->traceF( tinP , stPathToYear , T("inner : ") ) ;
                                //    picInner->traceF( tinP , T("inner :    ") ) ;
                                //{
                                //if( bChatter )
                                fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                imageCompareS* picInner  = (imageCompareS*)&pSwsMetaByShort->downF( tinP , hSwsOuter ) ;
                            {
                            do
                            handleC hSwsOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                            if( timeModRoundedYoungest < pfmUnique->timeModRounded ) timeModRoundedYoungest = pfmUnique->timeModRounded ;

                            //}
                            //    pfmUnique->traceF( tinP , stPathToYear , T("unique: ") ) ;
                            //    picUnique->traceF( tinP , T("unique:    ") ) ;
                            //{
                            //if( bChatter )
                            fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                            imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                        {
                        do
                        handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    ZE( countT , timeModRoundedYoungest ) ;
                    // TALLY cVotes AND SET timeModRoundedYoungest

                    }
                        bChatter = 1 ;
                        etThread.traceF( tinP , T("lengths or times or images differ [tShort]:    ")+tShort ) ;
                    {
                    if( stRecUnique > 1 )
                    ZE( boolT , bChatter ) ;
                {
                else                            // EVEN IF THERE IS ONLY WO PLATE, THERE IS STILL WORK TO DO BECAUSE THE FILE MIGHT NEED TO BE COPIED TO DESTINATIONS THAT DON'T HAVE IT
                if( !stRecUnique ) { BLAMMO ; } //SHOULD  BE IMPOSSIBLE

                while( ~hSwsOuter ) ;
                do stRecUnique.sinkF( tinP , countTC() , (byteT*)&pSwsMetaByShort->downF( tinP , hSwsOuter ) , flSTACKsINK_UNIQUE , subtractFileMetaF ) ;
                stackC stRecUnique( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , stPathToYear * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ;
                handleC hSwsOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( !ether && cCopies > 1 )
            //etThread.traceF( tinP , T("[cFound,file]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postzShort) ) ;

            // PHASE 4: COPY TO ALL ARCHIVE CONTAINERS THAT DO NOT HAVE A COPY OF THIS FILE NAME
            // PHASE 3: OVERWRITE ALL COPIES THAT DO NOT MATCH THIS UNIQUE META
            // PHASE 2: IS THIS UNIQUE META VERIFIED (cVotes > 1)?
            // PHASE 1: IDENTIFY THE UNIQUE META WITH THE LATEST FILE DATE
            // HEALING ACTION HAS PHASES
            // COMPARE AND FILE META FOR THIS FILE ARE SET AND READY FOR ANALYSIS AND HEALING ACTION
            // THESE COMMENTS ARE OBSOLETED BY ACTUAL CODE WHICH CONTRADICTS THEM

            while( !ether && ~hSwsOuter ) ;
            }
                etThread.delF( tinP ,            pcBitsShiftLeftHeInMine ) ;
                etThread.delF( tinP ,            pcBitsShiftLeftMeInHis  ) ;
                etThread.delF( tinP , *(byteT**)&ppIdResultHeInMine      ) ;
                etThread.delF( tinP , *(byteT**)&ppIdResultMeInHis       ) ;
                etThread.delF( tinP ,            pcbwInner               ) ;
                etThread.delF( tinP , *(byteT**)&ppbwInner               ) ;

                }
                    etThread.delF( tinP , pEqual ) ;
                    }
                        //etThread.traceF( tinP , T(pEqual[offo]?"        set other and myself to BITSrESULT_EQUAL because images match [offo]:    ":"        set other and myself to BITSrESULT_NOTeQUAL because images differ [offo]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        }
                            //etThread.traceF( tinP , T("after  [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                            *ppIdResultMeInHis[  offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftMeInHis[  offo ] ;
                            *ppIdResultHeInMine[ offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftHeInMine[ offo ] ;
                            //etThread.traceF( tinP , T("before [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                        {
                        else
                        }
                            *ppIdResultMeInHis[  offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftMeInHis[  offo ] ;
                            *ppIdResultHeInMine[ offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftHeInMine[ offo ] ;
                        {
                        if( pEqual[ offo ] )
                    {
                    for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ )

                    if( !ether && cbDone != pfmOuter->cbUsed ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE

                    THREADmODE2rESTORE
                    }
                        }
                            cbDone += cbwOuter ;

                            }
                                }
                                    pcbwInner[ offi ] = 0 ;  // TELLS  TO GET ANOTHER WINDOW
                                    ppbwInner[ offi ] = 0 ;

                                    }
                                        }
                                            thirdC::dosSleepWinkIF( tinP ) ;
                                            etThread.traceF( tinP , T("exception while trying to access memory for a mapped file.  will retry [idWindow,idTry]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        {
                                        else
                                        }
                                            break;
                                            }
                                                //etThread.traceF( tinP , T("images match between unique and inner [idWindow,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            else
                                            }
                                                //etThread.delF( tinP , psttGen ) ;
                                                //etThread.traceF( tinP , T("wrote inner [gen]:    ")+T(psttGen) ) ;
                                                //etThread.boxPutGenerationF( tinP , psttGen , tLikeInner+TF3(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) , TUCK , ppbwInner[ offi ] , cbwOuter ) ; ___( psttGen ) ;

                                                //etThread.delF( tinP , psttGen ) ;
                                                //etThread.traceF( tinP , T("wrote outer [gen]:    ")+T(psttGen) ) ;
                                                //etThread.boxPutGenerationF( tinP , psttGen , tLikeOuter , TUCK , pbwOuter , cbwOuter ) ; ___( psttGen ) ;
                                                //ZE( strokeS* , psttGen ) ;

                                                pEqual[ offi ] = 0 ;
                                                //etThread.traceF( tinP , T("difference detected between unique and inner [idWindow,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            if( etThread.memCompareF( tinP , pbwOuter , ppbwInner[ offi ] , cbwOuter ) )
                                            //etThread.traceF( tinP , T("attempting to compare images [idWindow,idTry,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        {
                                        if( !_restart )

                                        idTry ++ ;
                                        _restart.flags |= flRESTARTc_QUIET ;
                                        RESTART
                                    {
                                    while( !ether )
                                    ZE( countT , idTry ) ;
                                {
                                else
                                }
                                    break ;
                                    bDone = 1 ;
                                    //etThread.traceF( tinP , T("done inspecting images [idWindow]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                {
                                if( !pbwOuter || !cbwOuter )

                                if(   cbwOuter !=   pcbwInner[ offi ] ) { BLAMMO ; }     //SHOULD BE IMPOSSIBLE
                                if( !!cbwOuter != !!pcbwInner[ offi ] ) { BLAMMO ; }     //SHOULD BE IMPOSSIBLE
                                if( !!pbwOuter != !!ppbwInner[ offi ] ) { BLAMMO ; }     //SHOULD BE IMPOSSIBLE

                                if( pcbwInner[ offi ] == - 1 ) pcbwInner[ offi ] = 0 ;            // tmFeedFileWindowsF IS DONE AND TERMINATING

                                else           { if( pcbwInner[ offi ] != - 1           ) { BLAMMO ; } }     //SHOULD BE IMPOSSIBLE
                                if( cbwOuter ) { if( pcbwInner[ offi ] == - 1 && !ether ) { BLAMMO ; } }     //SHOULD BE IMPOSSIBLE

                                //etThread.traceF( tinP , T("fed this [(countT)ppbwInner[offi],ppbwInner[offi]]:    ")+TF3((countT)ppbwInner[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+T(ppbwInner[offi]) ) ;
                            {
                            for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )

                            }
                                if( !bAgain ) break ;

                                }
                                    }
                                        break ;
                                        bAgain = 1 ;
                                        thirdC::dosSleepWinkIF( tinP ) ;
                                    {
                                    if( !pcbwInner[ offi ] )
                                {
                                for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )
                                ZE( boolT , bAgain ) ;
                            {
                            for(;;)     //WAIT FOR EVERY FEEDER TO SET ITS ppcwInner[] ELEMENT

                            RETRY( fwsOuter.getF( tinP , pbwOuter , cbwOuter ) )
                            ZE( countT , cbwOuter ) ;
                            ZE( byteT* , pbwOuter ) ;

                            TN( tLikeInner , "///ideafarm/tmp/debug.inner." ) ; tLikeInner += TF3(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot ;
                            TN( tLikeOuter , "///ideafarm/tmp/debug.outer." ) ; tLikeOuter += TF3(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;

                            idWindow ++ ;
                        {
                        while( !ether && !bDone )
                        ZE( countT , idWindow ) ;
                        ZE( boolT , bDone ) ;

                        //etThread.traceF( tinP , T("inspecting images [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                        fileWindowsC fwsOuter( tinP , etThread , tLongOuter ) ;
                    {
                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                    for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ ) pEqual[ offo ] = 1 ;
                    etThread.newF( tinP , LF , pEqual , cInnerImagesToInspect ) ; ___( pEqual ) ;
                    ZE( boolT* , pEqual ) ;
                    ZE( count04T , cbDone ) ;
                    TN( tDot , "." ) ;

                    if( cFeedThreadsLaunched != cInnerImagesToInspect ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE
                {
                if( !ether && cInnerImagesToInspect )

                }
                    }
                        while( !ether && ~hSwsInner ) ;
                        }
                            }
                                }
                                    break ;

                                    }
                                        cFeedThreadsLaunched ++ ;

                                        pcBitsShiftLeftHeInMine[ cFeedThreadsLaunched ] = cBitsShiftLeftHeInMine ;
                                        pcBitsShiftLeftMeInHis[  cFeedThreadsLaunched ] = cBitsShiftLeftMeInHis  ;
                                        ppIdResultHeInMine[      cFeedThreadsLaunched ] = &bitsResultHeInMine    ;
                                        ppIdResultMeInHis[       cFeedThreadsLaunched ] = &bitsResultMeInHis     ;

                                        etThread.osThreadF( TaRG3fLAGScBtLS( tmFeedFileWindowsF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&ppbwInner[ cFeedThreadsLaunched ] , (countT)&pcbwInner[ cFeedThreadsLaunched ] , (countT)psttLongInner ) ; psttLongInner = 0 ;

                                        etThread.strMakeF( tinP , LF , psttLongInner , tLongInner ) ; ___( psttLongInner ) ;
                                        ZE( strokeS* , psttLongInner ) ;
                                    {
                                    if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                {
                                case 3 :
                                }
                                    break ;

                                    }
                                        cInnerImagesToInspect ++ ;
                                        //etThread.traceF( tinP , T("incrementing") ) ;
                                    {
                                    if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )

                                    //etThread.traceF( tinP , T("        maybe incrementing cInnerImagesToInspect [bitsResultHeInMine,maskHeInMine,masked,cBitsShiftLeftHeInMine,inner]:    ")+TF2(bitsResultHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(maskHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((bitsResultHeInMine&maskHeInMine),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                {
                                case 2 :    // COUNT THE NUMBER OF INNER FILES FOR WHICH I MUST INSPECT THE IMAGE (I SET cInnerImagesToInspect HERE)
                                }
                                    break ;

                                    }
                                        }
                                            bitsResultHeInMine |= BITSrESULT_NOTeQUAL << cBitsShiftLeftHeInMine ;
                                            bitsResultMeInHis  |= BITSrESULT_NOTeQUAL << cBitsShiftLeftMeInHis  ;
                                            //etThread.traceF( tinP , T("        set other and myself to BITSrESULT_NOTeQUAL because cbUsed differs") ) ;
                                        {
                                        if( pfmOuter->cbUsed != pfmInner->cbUsed )
                                    {
                                    else if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                    }
                                        //etThread.traceF( tinP , T("        setted  myself to BITSrESULT_EQUAL [bitsResultMeInHis]:    ")+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        bitsResultMeInHis |= BITSrESULT_EQUAL << cBitsShiftLeftMeInHis ;
                                        //etThread.traceF( tinP , T("        setting myself to BITSrESULT_EQUAL [&bitsResultMeInHis,bitsResultMeInHis,&cBitsShiftLeftMeInHis,cBitsShiftLeftMeInHis]:    ")+TF2(&bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(&cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    {
                                    if( pfmInner == pfmOuter )
                                {
                                case 1 :    // SET bitsResult WITHOUT COMPARING FILE IMAGES
                            {
                            switch( idPass )

                            //etThread.traceF( tinP , T("    [idPass,tLongInner]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                            TN( tLongInner , "" ) ; tLongInner = T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ;

                            countT maskHeInMine = BITSrESULT_ALLbITS << cBitsShiftLeftHeInMine ;
                            countT maskMeInHis  = BITSrESULT_ALLbITS << cBitsShiftLeftMeInHis  ;

                            countT cBitsShiftLeftHeInMine =           ( ( pfmInner->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;
                            countT cBitsShiftLeftMeInHis  =           ( ( pfmOuter->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;

                            countT& bitsResultHeInMine    = picOuter[ ( pfmInner->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;
                            countT& bitsResultMeInHis     = picInner[ ( pfmOuter->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;

                            //picInner->traceF( tinP , T("inner :    ") ) ;
                            //pfmInner->traceF( tinP , stPathToYear , T("inner: ") ) ;
                            fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;

                            //etThread.traceF( tinP , T("    [picInner]:    ")+TF2((countT)picInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            imageCompareS* picInner = (imageCompareS*)&pSwsMetaByShort->downF( tinP , hSwsInner ) ;
                        {
                        do
                        handleC hSwsInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( idPass != 3 || cInnerImagesToInspect )

                    }
                        etThread.memSetF( tinP , (byteT*)pcBitsShiftLeftHeInMine , cInnerImagesToInspect * sizeof( countT* ) ) ;
                        etThread.memSetF( tinP , (byteT*)pcBitsShiftLeftMeInHis  , cInnerImagesToInspect * sizeof( countT* ) ) ;
                        etThread.memSetF( tinP , (byteT*)ppIdResultHeInMine      , cInnerImagesToInspect * sizeof( countT* ) ) ;
                        etThread.memSetF( tinP , (byteT*)ppIdResultMeInHis       , cInnerImagesToInspect * sizeof( countT* ) ) ;
                        etThread.memSetF( tinP , (byteT*)pcbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;
                        etThread.memSetF( tinP , (byteT*)ppbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;

                        etThread.newF( tinP , LF ,             pcBitsShiftLeftHeInMine , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftHeInMine ) ;
                        etThread.newF( tinP , LF ,             pcBitsShiftLeftMeInHis  , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftMeInHis  ) ;
                        etThread.newF( tinP , LF , *(countT**)&ppIdResultHeInMine      , cInnerImagesToInspect ) ; ___( ppIdResultHeInMine      ) ;
                        etThread.newF( tinP , LF , *(countT**)&ppIdResultMeInHis       , cInnerImagesToInspect ) ; ___( ppIdResultMeInHis       ) ;
                        etThread.newF( tinP , LF ,             pcbwInner               , cInnerImagesToInspect ) ; ___( pcbwInner               ) ;
                        etThread.newF( tinP , LF , *(countT**)&ppbwInner               , cInnerImagesToInspect ) ; ___( ppbwInner               ) ;
                    {
                    if( idPass == 3 && cInnerImagesToInspect )
                {
                for( countT idPass = 1 ; !ether && idPass <= 3 ; idPass ++ )
                ZE( countT   , cFeedThreadsLaunched  ) ;
                ZE( countT*  , pcBitsShiftLeftHeInMine ) ;
                ZE( countT*  , pcBitsShiftLeftMeInHis  ) ;
                ZE( countT** , ppIdResultHeInMine      ) ;
                ZE( countT** , ppIdResultMeInHis       ) ;
                ZE( countT*  , pcbwInner               ) ;
                ZE( byteT**  , ppbwInner               ) ;
                ZE( countT   , cInnerImagesToInspect   ) ;

                //pfmOuter->traceF( tinP , stPathToYear , T("outer: ") ) ;
                //etThread.traceF( tinP , T("[tLongOuter]:    ")+tLongOuter ) ;
                TN( tLongOuter , "" ) ; tLongOuter = T((strokeS*)stPathToYear[pfmOuter->idSlotPathToYear])+tShort ;

                }
                    countT foo = 2 ;
                {
                if( !tShort.csF( tinP ) )

                //picOuter->traceF( tinP , T("outer :    ") ) ;
                fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + cResultStructsNeeded ) ;
                imageCompareS* picOuter  = (imageCompareS*)&pSwsMetaByShort->downF( tinP , hSwsOuter ) ;
            {
            do
            handleC hSwsOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            // SET ALL COMPARE META ELEMENTS FOR EACH FILE'S IMAGE COMPARE META ARRAY

            }
                etThread.traceF( tinP , T("!tShort.csF() [cYearSlashShortFileNames,idf]:    ")+TF2(cYearSlashShortFileNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            if( !tShort.csF( tinP ) )

            TN( tShort , postzShort ) ;

            countT cCopies = *pSwsMetaByShort ;
            postzShort = (osTextT*)pSwsMetaByShort->leverF( tinP , idf ) ;

            }
                etThread.traceF( tinP , T("[perTuck,idf]:    ")+TF3(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2)+tb+tPerTuck+tb4+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                countT perTuck = ( idf << 8 ) / cYearSlashShortFileNames ;
            {
            if( !( idf % ( TUCK >> 4 ) ) )

            //if( idf > 1 ) break ; //FOR TESTING
        {
        for( countT idf = 1 ; idf <= cYearSlashShortFileNames ; idf ++ )
        etThread.traceF( tinP , T("inspecting metadata and comparing images for each copy of each file") ) ;

        const countT cYearSlashShortFileNames = pSwsMetaByShort->cFlavorsF( tinP ) ;

        pSwsMetaByShort->grabF( tinP , TAG( TAGiDnULL ) ) ;      //SHOULD NOT BE NEEDED SINCE ALL KIDS ARE GONE

        // *pSwsMetaByShort NOW CONTAINS META (FILE META AND INITIALIZED ACCUMULATORS FOR COMPARE META)

        //etThread.tracePoolTalliesF( tinP ) ;
        //etThread.traceF( tinP , T("calling tracePoolTalliesF / file meta is loaded") ) ;

        }
            THREADmODE2rESTORE
            while( cWorkers ) thirdC::dosSleepWinkIF( tinP ) ;
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        {

        }
            if( idPass == 1 ) stPathToYear.lockF( tinP ) ;

            while( ~hSwsPathToArchives ) ;
            }
                etThread.delF( tinP , pstt1PathToYear ) ;
                }
                    }
                        etThread.osThreadF( TaRG3fLAGScBtLS( tmCollectFileMetaF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cWorkers , (countT)&stPathToYear , idSlotPathToYear , (countT)&postzShort , (countT)pSwsMetaByShort ) ;
                        inc02AM( cWorkers ) ;
                        countT idSlotPathToYear = stPathToYear( psttc1 ) ;
                    {
                    else
                    }
                       }
                           BLAMMO ; //SHOULD BE IMPOSSIBLE
                           etThread.delF( tinP , psttPathToYear ) ;
                       {
                       if( !idSlotPathToYear )
                       stPathToYear.sinkF( tinP , idSlotPathToYear , psttPathToYear , flSTACKsINK_UNIQUE ) ;
                       ZE( countT , idSlotPathToYear ) ;

                       etThread.strMakeF( tinP , LF , psttPathToYear , psttc1 ) ; ___( psttPathToYear ) ;
                       ZE( strokeS* , psttPathToYear ) ;
                    {
                    if( idPass == 1 )
                {
                FORsTRINGSiN1( pstt1PathToYear )

                etThread.traceF( tinP , T("[pstt1PathToYear]:    ")+T(pstt1PathToYear) ) ;
                etThread.strConvertToLowerCaseF( tinP , pstt1PathToYear ) ;
                etThread.diskFindFileOrDirF( tinP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                patternC pat( tinP , etThread , tYearSlash , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                ZE( strokeS* , pstt1PathToYear ) ;

                etThread.traceF( tinP , T("[tPathToArchive]:    ")+tPathToArchive ) ;
                TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchiveP)+tSlash ;
                strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveNameP.downF( tinP , hSwsPathToArchives ) ;
            {
            do
            handleC hSwsPathToArchives( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

            }
                pSwsMetaByShort = new( 0 , tinP , LF ) switchStackC( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_SINKrEVERSE | flSTACKc_SINKiGNOREtABS , &postzShort , flSTACKc_BLOB | flSTACKc_ALLOWzE , cResultStructsNeeded * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ; ___( pSwsMetaByShort ) ;
                cResultStructsNeeded = 1 + cSlotsPathToYear / cResultsPerStruct ;
                cSlotsPathToYear = stPathToYear ;
            {
            if( idPass == 2 )
        {
        for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
        ZE( countT , cWorkers ) ;
        stackC stPathToYear( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
        ZE( switchStackC* , pSwsMetaByShort ) ;       // cbData IS NOT KNOWN UNTIL PASS 1 COMPLETES ; WILL BE CT'D IN PASS 2 USING THE THEN KNOWN NUMBER OF PATHS FOR THIS ARCHIVE NAME
        ZE( osTextT* , postzShort  ) ;
        ZE( countT   , cResultStructsNeeded ) ;
        ZE( countT   , cSlotsPathToYear     ) ;     //U:: THIS IS CALCULATED INCORRECTLY EXCEPT WHEN THERE IS ONLY WO YEAR.  RATHER THAN FIX IT, REDESIGN CODE TO PROCESS WO YEAR AT A TIME (OR USE A SEPARATE SWS FOR EACH YEAR AND DO IT IN PARALLEL).  SUCH A REDESIGN WILL ALSO MAKE IT EASIER TO THROTTLE PUSHING TO LIMIT THE NUMBER OF FLAVORS IN THE SWS, WHICH IS NECEWSSARY TO AVOID EXHAUSTING MEMORY SPACE

        etThread.traceF( tinP , T("executive [pattern]:    ")+tYearSlash ) ;
        etThread.delF( tinP , psttYearP ) ;
        TN( tYearSlash , "" ) ; tYearSlash = T(psttYearP)+T("/") ;

        TN( tPerTuck , "%" ) ;
        TN( tSlash , "/" ) ;
        TN( tb4    , "    " ) ;
        TN( tb , " " ) ;
    {

    switchStackC& swsPathToArchivesByArchiveNameP = *(switchStackC*)pTaskP->c4 ;
    strokeS*&     psttzArchiveP                   =     *(strokeS**)pTaskP->c3 ;
    strokeS*      psttYearP                       =       (strokeS*)pTaskP->c2 ;
    countT&       cExecutiveHealYearP             =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmExecutiveHealYearF )

DONE( tmCopyFileF )
}
    etThread.delF( tinP , psttFromP ) ;
    etThread.delF( tinP , psttToP   ) ;
    //etThread.traceF( tinP , T("deleting [psttTo,psttFrom]:    ")+TF2((countT)psttToP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)psttFromP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    }
        //etThread.diskCopyFileF( tinP , psttToP , psttFromP ) ;
        etThread.traceF( tinP , T("U:: not copying even though destination does not exist [long]:    ")+T(psttToP) ) ; //U:: 20221127@1758: REMOVE IN PRODUCTION AFTER HAVE CONFIDENCE OF CORRECT FUNCTION
    {
    else
    if( etThread.diskFileExistsF( tinP , psttToP ) ) etThread.traceF( tinP , T("U:: not copying because this destination file exists [long]:    ")+T(psttToP) ) ; //U:: 20221127@1758: REMOVE IN PRODUCTION AFTER HAVE CONFIDENCE OF CORRECT FUNCTION

    strokeS* psttFromP = (strokeS*)pTaskP->c2 ;
    strokeS* psttToP   = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmCopyFileF )


DONE( tmFeedFileWindowsF )
}
    }
        }
            }
                cbwInnerP = cbwInner ;
                pbwInnerP = pbwInner ;
            {
            else
            }
                break ;
                cbwInnerP = - 1 ;
            {
            if( ether || !pbwInner || !cbwInner )

            //etThread.traceF( tinP , T("get returned [(countT)pbwInner,pbwInner]:    ")+TF3((countT)pbwInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+T(pbwInner) ) ;
            //etThread.traceF( tinP , T("tmFeedFileWindowsF / called getF [idIn,pbwInner,cbwInner,tLongInner]                 :         ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF3((countT)pbwInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+TF3(cbwInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+tb4+tLongInner ) ;
            RETRY( fwsInner.getF( tinP , pbwInner , cbwInner ) )
            //etThread.traceF( tinP , T("tmFeedFileWindowsF / calling getF [idIn,tLongInner]                 :         ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
            ZE( countT , cbwInner ) ;
            ZE( byteT* , pbwInner ) ;

            else        while( !ether && cbwInnerP ) thirdC::dosSleepWinkIF( tinP ) ;
            if( bWoth ) bWoth = 0 ;
        {
        while( !ether )
        boolT bWoth = 1 ;

        fileWindowsC fwsInner( tinP , etThread , tLongInner ) ;
    {
    if( !POOP )

    //etThread.traceF( tinP , T("tmFeedFileWindowsF / + [idIn,tLongInner]                 :         ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
    TN( tLongInner , psttLongInnerP ) ; etThread.delF( tinP , psttLongInnerP ) ;
    TN( tb4 , "    " ) ;

    countT idIn = 1 + incv02AM( idInLath ) ;
    static countT idInLath ;

    __Z( psttLongInnerP ) ;
    __NZ( cbwInnerP ) ;
    __NZ( pbwInnerP ) ;

    strokeS* psttLongInnerP          = (strokeS*)pTaskP->c3 ;
    countT&  cbwInnerP               = *(countT*)pTaskP->c2 ;
    byteT*&  pbwInnerP               = *(byteT**)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmFeedFileWindowsF )

DONE( tmCollectFileMetaF )
}
    dec02AM( cWorkersP ) ;

    }
        etThread.traceF( tinP , T("ended archive pathToYear:    ")+tPathToYearP ) ;
        }
            while( ~hWalk ) ;
            }
                }
                    DEL( pInfoFile ) ;
                    }
                        swsMetaByShortP.ungrabF( tinP ) ;

                        new( 0 , tinP , (byteT*)pCursor , sizeof( fileMetaS ) ) fileMetaS( tinP , idSlotPathToYearP , time1Mod , time2Mod , cbUsed ) ;

                        pCursor += cResultStructsNeeded ;
                        for( countT offs = 0 ; offs < cResultStructsNeeded ; offs ++ ) new( 0 , tinP , (byteT*)( pCursor + offs ) , sizeof( imageCompareS ) ) imageCompareS ;
                        countT cResultStructsNeeded = 1 + cSlotsPathToYear / cResultsPerStruct ;
                        imageCompareS* pCursor = (imageCompareS*)&swsMetaByShortP[ 1 ] ;

                        //    postDebugLever = (osTextT*)tinP.pc Utility[ 1 ] ;
                        //if( idIn == 0x1b9 )
                        
                        if( idIn == 0x1b9 ) //tinP.pc Utility[ 0 ] -- ;    //U:: TO FIND A BUG
                        swsMetaByShortP << (byteT*)0 ;
                        if( idIn == 0x1b9 ) //tinP.pc Utility[ 0 ] ++ ;    //U:: TO FIND A BUG

                        //etThread.traceF( tinP , T("[idIn,postzShortP]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+T(postzShortP) ) ;
                        postzShortP = tShort ;
                        swsMetaByShortP.grabF( tinP , TAG( TAGiDnULL ) ) ;

                        //etThread.traceF( tinP , T("[idIn]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE) ) ;
                        countT idIn = 1 + incv02AM( idInLath ) ;
                        static countT idInLath ;

                        count04T cbUsed = pInfoFile->cbUsedHigh << sizeof( count02T ) * SB | pInfoFile->cbUsed ;

                        sCountT time2Mod = pInfoFile->timeWritten2 ;
                        countT  time1Mod = pInfoFile->timeWritten1 ;

                        }
                            etThread.traceF( tinP , T("[perTuck,idFile]:    ")+TF3(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2)+tb+tPerTuck+tb4+TF2(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            countT perTuck = ( idFile << 8 ) / cFiles ;
                        {
                        if( !( idFile % ( TUCK << 4 ) ) )

                        ++ idFile ;
                                                                   
                        }
                            etThread.delF( tinP , psttYearSlashShort ) ;
                            etThread.delF( tinP , psttPath ) ;
                            tYearSlashShort = T(psttYearSlashShort) ;
                            tPath  = T(psttPath) ;
                            etThread.strBisectF( tinP , psttPath , psttYearSlashShort , tFileName , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttYearSlashShort ) ;
                            ZE( strokeS* , psttYearSlashShort ) ;
                            ZE( strokeS* , psttPath ) ;
                        {
                        TN( tYearSlashShort , "" ) ;
                        TN( tPath  , "" ) ;

                        TN( tFileName , pInfoFile->psttIfoName ) ;
                    {
                    if( pInfoFile )
                    etThread.diskFileQueryF( tinP , pInfoFile , fi ) ; ___( pInfoFile ) ;
                    fileC fi( tinP , (strokeS*)tLong , ifcOPENaCCESS_R ) ;
                    ZE( infoFileS* , pInfoFile ) ;

                    TN( tLong , "" ) ; tLong = tPathToYearP+tShort ;

                    if( !tShort.csF( tinP ) ) { BLAMMO ; }      //SHOULD BE IMPOSSIBLE
                    //etThread.traceF( tinP , tShort ) ;
                    TN( tShort , (const byteT*)page ) ;
                {
                else
                if( !page ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE

                pageC page = jotShortFileNames[ idj ] ;

                countT idj = stIdJot.upF( tinP , hWalk ) ;
            {
            do
            handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , idFile ) ;
        {
        if( stIdJot )
        etThread.traceF( tinP , T("collecting file meta into sws, using stIdJot") ) ;

        //}
        //    while( ~hWalk ) ;
        //    }
        //        }
        //            //etThread.traceF( tinP , T((const byteT*)page) ) ;
        //        {
        //        else
        //        if( !page ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE
        //
        //        pageC page = jotShortFileNames[ idj ] ;
        //
        //        countT idj = stIdJot.upF( tinP , hWalk ) ;
        //    {
        //    do
        //    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        //{
        //if( stIdJot )
        //etThread.traceF( tinP , T("reading in sorted order, using stIdJot") ) ;

        etThread.traceF( tinP , T("counted files [cFiles,stIdJot]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)stIdJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        }
            while( !ether && ~hFindFile && !POOP ) ;
            }
                DEL( pInfoFile ) ;
                }
                    }
                        stIdJot.sinkF( tinP , countTC() , idJot , flSTACKsINK_null , subtractJottedOsTextF ) ;
                        countT idJot = jotShortFileNames.writeF( tinP , tShort , tShort.csF( tinP ) + 1 ) ;
                    {
                    if( tShort.csF( tinP ) )        // IF NOT A DIRECTORY
                                                               
                    }
                        etThread.delF( tinP , psttShort ) ;
                        etThread.delF( tinP , psttnu ) ;
                        tShort  = T(psttShort) ;
                        etThread.strBisectF( tinP , psttnu , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShort , "" ) ;
                {
                else cFiles ++ ;
                }
                    break ;
                    DEL( pInfoFile ) ;
                {
                if( !pInfoFile || !pInfoFile->psttIfoName )

                RETRYsCR( diskFindFileOrDirF( tinP , pInfoFile , hFindFile , tPathToYearP ) )
                ZE( infoFileS* , pInfoFile ) ;

                }
                    etThread.traceF( tinP , T("[cFiles]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( cFiles && !( cFiles % ( TUCK << 4 ) ) )
            {
            do
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            handleC hFindFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        {
        ZE( countT , cFiles ) ;
        stackC stIdJot( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKiGNOREtABS | flSTACKc_SINKrEVERSE ) ;
        jotC jotShortFileNames( tinP , "short.file.names" , flJOTc_WRITE | flJOTc_PRIVATE | flJOTc_DELETE | flJOTc_PURGEoNcT ) ;
        etThread.traceF( tinP , T("counting files") ) ;

        etThread.traceF( tinP , T("this thread's job: [volume,pathToYear]:    ")+tVolumeName+tb4+tPathToYearP ) ;

        //}
        //    etThread.delF( tinP , pstt1Words ) ;
        //    }
        //        else if( bArm                                               ) bArm -- ;
        //        else if( !etThread.strCompareF( tinP , psttc1 , tArchives ) ) bArm = 2 ;
        //             if( bArm == 1                                          ) tYear = T(psttc1) ;
        //    {
        //    FORsTRINGSiN1( pstt1Words )
        //    TN( tArchives , "ipdos.archives" ) ;
        //    ZE( boolT , bArm ) ;
        //    etThread.strWordsF( tinP , pstt1Words , tPathToYearP , sttq , T("/") ) ; ___( pstt1Words ) ;
        //    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        //    ZE( strokeS* , pstt1Words ) ;
        //{
        //TN( tYear , "" ) ;

        }
            DEL( pInfoDisk ) ;
            tVolumeName = T(pInfoDisk->psttVolumeName) ;
            etThread.strConvertToLowerCaseF( tinP , pInfoDisk->psttVolumeName ) ;
            etThread.delF( tinP , psttDisk ) ;
            etThread.diskInfoF( tinP , pInfoDisk , psttDisk ) ; ___( pInfoDisk ) ;
            ZE( infoDiskS* , pInfoDisk ) ;

            etThread.strSubstringF( tinP , psttDisk , idf , idl , tPathToYearP ) ; ___( psttDisk ) ;
            countT idl = 5 ;
            countT idf = 1 ;
            ZE( strokeS* , psttDisk ) ;
        {
        TN( tVolumeName , "" ) ;

        TN( tPathToYearP , (strokeS*)stPathToYearP[ idSlotPathToYearP ] ) ;
        TN( tPerTuck , "%" ) ;
        TN( tDot , "." ) ;
        TN( tb4 , "    " ) ;
        TN( tb , " " ) ;
        const countT  cSlotsPathToYear = stPathToYearP ;
    {

    switchStackC& swsMetaByShortP          = *(switchStackC*)pTaskP->c5 ;
    osTextT*&     postzShortP              =     *(osTextT**)pTaskP->c4 ;
    countT        idSlotPathToYearP        =                 pTaskP->c3 ;
    stackC&       stPathToYearP            =       *(stackC*)pTaskP->c2 ;
    countT&       cWorkersP                =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmCollectFileMetaF )

#endif
}

{
//CODEmINE:
#if defined( NEVERdEFINED )

}
    return sgn ;

    }
        ether.delF( tinP , post1Copy ) ;

        sgn = thirdC::c_strcmpIF( tinP , post1Copy , post2 ) ; ;
        //ether.traceF( tinP , T("subtract [post1,post2]:    ")+T(post1Copy)+T("    ")+T(post2) ) ;

        const osTextT* post2 = page2 ;
        pageC page2 = jotC::readIF( tinP , c2P ) ;

        }
            thirdC::c_memcpyIF( tinP , post1Copy , post1 , cost1 ) ;    
            ether.newF( tinP , LF , post1Copy , cost1 ) ; ___( post1Copy ) ;
            countT         cost1 = page1 ;
            const osTextT* post1 = page1 ;
            pageC page1 = jotC::readIF( tinP , c1P ) ;
        {
        ZE( osTextT* , post1Copy ) ;

        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )
    ZE( sCountT , sgn ) ;

    }
    {
    IFbEcAREFUL
{
/*1*/countT subtractJottedOsTextF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    return *pfr1 - *pfr2 ;

    fileMetaS* pfr2 = (fileMetaS*)c2P ;
    fileMetaS* pfr1 = (fileMetaS*)c1P ;
{
/*1*/countT subtractFileMetaF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    tinP.pEther->traceF( tinP , T(psttP)+T(" [bitsResult]:    ")+TF4(bitsResult,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
{
voidT imageCompareS::traceF( tinS& tinP , const strokeS* const psttP )

}
    //traceF( tinP , T("ct      :    ") ) ;
    TINSL
{
bitsResult( BITSrESULT_UNKNOWN )
imageCompareS::imageCompareS( voidT ) :

NEWdELcLASS( 2 , imageCompareS ) ;

}
    return tinP.pEther->memCompareF( tinP , (byteT*)this , (byteT*)&frP , sizeof( countT ) + sizeof( count04T ) ) ;    //CS:CODEsYNC 1 1
    TINSL
{
sCountT fileMetaS::operator -( const fileMetaS& frP ) const

}
    tinP.pEther->traceF( tinP , T(psttP)+T(" [timeModRounded,timeMod,cbUsed,cVotes,idSlotPathToYear,path]:    ")+TF3(timeModRounded,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T("    ")+TT(time1Mod,time2Mod)+T("    ")+TT(((countT*)&cbUsed)[0],((countT*)&cbUsed)[1])+T("    ")+TF2(cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idSlotPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((strokeS*)stPathToYearP[idSlotPathToYear]) ) ;
{
voidT fileMetaS::traceF( tinS& tinP , stackC& stPathToYearP , const strokeS* const psttP )

}
    timeModRounded = *(countT*)( (byteT*)pc2 + 3 ) + bRoundUp ;
    countT pc2[ 2 ] = { time1Mod , time2Mod } ;

    boolT bRoundUp = !!( ( time1Mod & 0xffffff ) > 0x800000 ) ;

        { BLAMMO ; }
    if( !idSlotPathToYear )
{
idSlotPathToYear( idSlotPathToYearP )
cVotes( 0 ) ,
time2Mod( time2ModP ) ,
time1Mod( time1ModP ) ,
cbUsed( cbUsedP ) ,
timeModRounded( 0 ) ,
fileMetaS::fileMetaS( tinS& tinP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) :

NEWdELcLASS( 1 , fileMetaS ) ;

osTextT* postDebugLever ;

const countT cResultsPerStruct = sizeof( countT ) * SB / 2 ;     // 2 BITS ARE USED TO STORE A RESULT, SO 4 RESULTS FIT INTO A BYTE AND 01 RESULTS FIT INTO A count02T ; MY CODE SHOULD BE WRITTEN WITHOUT ASSUMING countT IS count02T

;
}
    voidT traceF( tinS& tinP , const strokeS* const psttP = 0 ) ;
    inline sCountT operator -( imageCompareS& picP ) { return bitsResult - picP.bitsResult ; }
    imageCompareS( voidT ) ;
    NEWdELcLASSpROTOS

    countT bitsResult ;
{
struct imageCompareS

;
}
    sCountT operator -( const fileMetaS& frP ) const ;
    voidT traceF( tinS& tinP , stackC& stPathToYearP , const strokeS* const psttP = 0 ) ;
    fileMetaS( tinS& tinP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) ;
    NEWdELcLASSpROTOS

    countT   idSlotPathToYear ;
    countT   cVotes ;
    sCountT  time2Mod ;
    countT   time1Mod ;
    count04T cbUsed ;
    countT   timeModRounded ;   //CS:CODEsYNC 1 1
{
struct fileMetaS

#define BITSrESULT_ALLbITS        3
#define BITSrESULT_EQUAL          2
#define BITSrESULT_NOTeQUAL       1
#define BITSrESULT_UNKNOWN        0

//OBSOLETES 7e0
//OBSOLETED BY 7e3

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_HEALaRCHIVES" )/*1*/
/**/
*/
 this adam uses a jotC to sort short filenames, but does not batch them
  consume flavors as they are processed
  pause loading of the sws when cFlavors == max and resume when cFlavors drops to min
 approach
using a switchStackC flavor for each distinct short filename is expensive in memory consumption
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
