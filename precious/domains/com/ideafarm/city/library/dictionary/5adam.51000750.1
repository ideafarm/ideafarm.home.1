
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tinBaseP ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tinBaseP , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        }
            swProtocol.freeAllF( tinBaseP ) ;
            }
                etThread.delF( tinBaseP , psttProtocol ) ;
                strokeS*& psttProtocol = (strokeS*&)(countT&)swProtocol ;
                psttzLeverProtocol = (strokeS*)swProtocol.leverF( tinBaseP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
        countT cFlavors = swProtocol.cFlavorsF( tinBaseP ) ;
    {

    }
        ++ s ; ether.osSleepF( tinBaseP , TOCK << 4 ) ;
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

        while( !ether && ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                }
                    etThread.traceF( tinBaseP , (!F(flagsFail)?T("aok"):T("flagsFail:")+TF2(flagsFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)) ) ;

                    }
                        }
                            }
                                flagsFail |= flFAIL_COULDnOTzAPsENTfILE ;
                                POOPR
                            {
                            if( POOP )
                            ((tinFullS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tWhere+tShort ) ;
                        {
                        if( !bFailPermanent && !( F(flagsFail) ) )

                        SCOOPS
                    {
                    IFsCRATCH                               //20201010@1520: ADDED WITHOUT ANALYSIS TO PREVENT ACCUMULATION OF FILES

                    }
                        }
                            flagsFail |= flFAIL_COULDnOTmOVEfILE ;
                            POOPR
                        {
                        if( POOP )
                        ((tinFullS&)tinBaseP).pEtScratch->diskMoveFileOrDirF( tinBaseP , tWhere+tShort , tIfoName ) ;

                        SCOOPS
                    {
                    IFsCRATCH

                    ;
                            : tSent
                            ? tNotSent
                        : F(flagsFail)
                        ? tNotSentAbandoned

                    TN( tWhere , "" ) ; tWhere = bFailPermanent

                    etThread.traceF( tinBaseP , T("moving the file") ) ;

                    }
                        flagsFail |= flFAIL_COULDnOTgETsHORTfILEnAME ;
                        POOPR
                    {
                    if( POOP )

                    etThread.traceF( tinBaseP , T("cleaning up 3") ) ;

                    }
                        etThread.traceF( tinBaseP , T("unknown error") ) ;
                        flagsFail |= flFAIL_UNKNOWNeRROR ;
                        POOPR
                    {
                    if( POOP )
                    etThread.traceF( tinBaseP , T("cleaning up 2") ) ;

                    }
                        stBc.purgeF( tinBaseP ) ;
                        stCc.purgeF( tinBaseP ) ;
                        stTo.purgeF( tinBaseP ) ;

                        etThread.delF( tinBaseP , psttFileBody ) ;

                        etThread.traceF( tinBaseP , T("cleaning up 1") ) ;
                        etThread( tinBaseP , pStkEmailRelay ) ;
                        etThread.delF( tinBaseP , psttHost ) ;
                        etThread.delF( tinBaseP , psttFrom ) ;
                        }
                            }
                                }
                                    etThread.traceF( tinBaseP , T("end of handling list ")+TF2(offs,flFORMAT_NObIGITvALUES) ) ;
                                    }
                                        while( ~hWalk ) ;
                                        }
                                            etThread.traceF( tinBaseP , T("end of recipient \"")+T(psttr)+T("\"") ) ;
                                            etThread.delF( tinBaseP , psttBccLine ) ;

                                            //etThread.traceF( tinBaseP , T("destroyed socket") ) ;
                                            }
                                                //etThread.traceF( tinBaseP , T("destroying socket") ) ;
                                                }
                                                    break ;
                                                    etThread.delF( tinBaseP , psttBccLine ) ;
                                                    etThread.traceF( tinBaseP , T("writing quit: failed") ) ;
                                                    flagsFail |= flFAIL_QUITcOMMANDrEJECTED ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                sockc.verifyReplyF( tinBaseP , 221 ) ;
                                                sockc.writeF( tinBaseP , (osTextT*)tSay ) ;
                                                etThread.traceF( tinBaseP , T("[tSay]: ")+tSay ) ;
                                                tSay = T("quit\r\n") ;

                                                //}
                                                //    break ;
                                                //
                                                //    }
                                                //        etThread.boxPutF( tinBaseP , T("//smtp/" ifcEMAIL_MAILoUT "/")+T(psttFrom) , tReply , tReply.csF( tinBaseP ) ) ;
                                                //
                                                //        ) ;
                                                //
                                                //            "Your email was sent.\r\n"
                                                //            "\r\n"
                                                //            "Subject: Your email was sent\r\n"
                                                //
                                                //        TN( tReply ,
                                                //    {
                                                //    //NOTIFY from THAT EMAIL WAS SENT
                                                //    CONoUTrAW( T("an email was sent.  notifying \"")+T(psttFrom)+T("\"\r\n") ) ;
                                                //{
                                                //else if( etThread.strCompareF( tinBaseP , psttFrom , T(ifcEMAIL_MAILoUT) ) )
                                                //THIS CAN CYCLE INFINITELY

                                                }
                                                    break ;
                                                    etThread.delF( tinBaseP , psttBccLine ) ;

                                                    //}
                                                    //    etThread.boxPutF( tinBaseP , T("//smtp/" ifcEMAIL_MAILoUT "/")+T(psttFrom) , tReply , tReply.csF( tinBaseP ) ) ;
                                                    //
                                                    //    ) ;
                                                    //
                                                    //        "       will avoid a bug in the censoring software.)\r\n"
                                                    //        "       the brackets so that they appear as \"[ ]\".  (Adding the space between the brackets\r\n"
                                                    //        "    2. If your email contains a '[' followed immediately by a ']', put a space between\r\n"
                                                    //        "\r\n"
                                                    //        "    1. Remove all references to web sites that might be listed as spamming sites.\r\n"
                                                    //        "\r\n"
                                                    //        "Tips:\r\n"
                                                    //        "\r\n"
                                                    //        "Please resend your email after editing it to avoid this \"no spam\" censoring.\r\n"
                                                    //        "\r\n"
                                                    //        "recipient.\r\n"
                                                    //        "It thinks that your note is spam, so is refusing to relay it to your intended\r\n"
                                                    //        "That relay combats spam by refusing to handle items that appeaer to be spam.\r\n"
                                                    //        "\r\n"
                                                    //        "    k2smtpout.secureserver.net\r\n"
                                                    //        "\r\n"
                                                    //        "Email sent by the IDEAFARM.COM email server is relayed through\r\n"
                                                    //        "\r\n"
                                                    //        "Subject: Your email could not be sent\r\n"
                                                    //
                                                    //    TN( tReply ,
                                                    //    CONoUTrAW( T("could not send; notifying\"")+T(psttFrom)+T("\"\r\n") ) ;
                                                    //{
                                                    //SEND A REJECTED NOTICE TO from

                                                    }
                                                        }
                                                            __( logBodySnipFromFileF( tinBaseP , etThread , psttc1 ) ) ;      //20190929@1526: psttc1 WITHOUT ANALYSIS
                                                        {
                                                        FORsTRINGSiN1( psttFileBody )
                                                    {
                                                    else
                                                    if( !ISsTRINGoFsTRINGS( psttFileBody ) ) { __( logBodySnipFromFileF( tinBaseP , etThread , psttFileBody ) ) ; }

                                                    }
                                                        CONoUTrAW( tHeaders ) ;
                                                        TN( tHeaders , "" ) ; tHeaders = (!bIncoming?tFrToCcOutgoing:tFrToCcIncoming)+T(psttBccLine) ;
                                                    {
                                                    //LOG THE DATA

                                                    bFailPermanent = 1 ;
                                                    flagsFail |= flFAIL_BODYrEJECTED ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                sockc.verifyReplyF( tinBaseP , 250 ) ; //WILL FAIL IF ANTISPAM RELAYER REFUSES DATA BECAUSE IT CONTAINS REFERENCE TO BLACKLISTED (SPAMMER) WEB SITE
                                                }
                                                    sockc.writeF( tinBaseP , "\r\n.\r\n" , 5 ) ;

                                                    }
                                                       break ;
                                                       etThread.delF( tinBaseP , psttBccLine ) ;
                                                       etThread.traceF( tinBaseP , T("call to writeBodySnipFromFileF failed [psttFileBody]: ")+T(psttFileBody) ) ;
                                                       POOPR
                                                    {
                                                    if( POOP )

                                                    }
                                                        }
                                                            }
                                                                break ;
                                                                etThread.delF( tinBaseP , psttBccLine ) ;
                                                                etThread.traceF( tinBaseP , T("call to writeBodySnipFromFileF failed [psttc1]: ")+T(psttc1) ) ;
                                                                POOPR
                                                            {
                                                            if( POOP )
                                                            __( writeBodySnipFromFileF( tinBaseP , etThread , sockc , psttc1 , flagsFail ) ) ;      //20190929@1526: psttc1 WITHOUT ANALYSIS
                                                        {
                                                        FORsTRINGSiN1( psttFileBody )
                                                    {
                                                    else
                                                    if( !ISsTRINGoFsTRINGS( psttFileBody ) ) { __( writeBodySnipFromFileF( tinBaseP , etThread , sockc , psttFileBody , flagsFail ) ) ; }

                                                    }
                                                        sockc.writeF( tinBaseP , (osTextT*)tHeaders , tHeaders.csF( tinBaseP ) ) ;
                                                        etThread.traceF( tinBaseP , T("[tHeaders]: ")+tHeaders ) ;
                                                        TN( tHeaders , "" ) ; tHeaders = (!bIncoming?tFrToCcOutgoing:tFrToCcIncoming)+T(psttBccLine) ;
                                                    {
                                                {

                                                }
                                                    break ;
                                                    etThread.delF( tinBaseP , psttBccLine ) ;
                                                    etThread.traceF( tinBaseP , T("writing data cmd: failed") ) ;
                                                    flagsFail |= flFAIL_DATAcOMMANDrREJECTED ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                sockc.verifyReplyF( tinBaseP , 354 ) ;
                                                sockc.writeF( tinBaseP , (osTextT*)tSay ) ;
                                                etThread.traceF( tinBaseP , T("[tSay]: ")+tSay ) ;
                                                tSay = T("data\r\n") ;

                                                }
                                                    break ;
                                                    etThread.delF( tinBaseP , psttBccLine ) ;
                                                    etThread.traceF( tinBaseP , T("writing rcpt to: failed") ) ;
                                                    flagsFail |= flFAIL_RCPTtOrEJECTED ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                sockc.verifyReplyF( tinBaseP , 250 ) ;
                                                sockc.writeF( tinBaseP , (osTextT*)tSay ) ;
                                                etThread.traceF( tinBaseP , T("[tSay]: ")+tSay ) ;
                                                tSay = T("rcpt to:<")+T(psttr)+T(">\r\n") ;

                                                }
                                                    break ;
                                                    etThread.delF( tinBaseP , psttBccLine ) ;
                                                    etThread.traceF( tinBaseP , T("mail from: failed") ) ;
                                                    flagsFail |= flFAIL_MAILfROMrEJECTED ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                sockc.verifyReplyF( tinBaseP , 250 ) ;
                                                sockc.writeF( tinBaseP , (osTextT*)tSay ) ;
                                                etThread.traceF( tinBaseP , T("[tSay]: ")+tSay ) ;
                                                tSay = T("mail from:<")+T(psttFrom)+T(">\r\n") ;

                                                }
                                                    }
                                                        break ;
                                                        etThread.delF( tinBaseP , psttBccLine ) ;
                                                        etThread.traceF( tinBaseP , T("credentials rejected") ) ;
                                                        flagsFail |= flFAIL_STARTtlsrEJECTED ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    sockc.verifyReplyF( tinBaseP , 235 ) ;
                                                    sockc.writeF( tinBaseP , (osTextT*)tSay ) ;
                                                    etThread.traceF( tinBaseP , T("[tSay]: ")+tSay ) ;
                                                    tSay = tPassword+T("\r\n") ;

                                                    }
                                                        break ;
                                                        etThread.delF( tinBaseP , psttBccLine ) ;
                                                        etThread.traceF( tinBaseP , T("credentials rejected") ) ;
                                                        flagsFail |= flFAIL_STARTtlsrEJECTED ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    sockc.verifyReplyF( tinBaseP , 334 ) ;
                                                    sockc.writeF( tinBaseP , (osTextT*)tSay ) ;
                                                    etThread.traceF( tinBaseP , T("[tSay]: ")+tSay ) ;
                                                    tSay = tUser+T("\r\n") ;

                                                    }
                                                        break ;
                                                        etThread.delF( tinBaseP , psttBccLine ) ;
                                                        etThread.traceF( tinBaseP , T("auth login rejected") ) ;
                                                        flagsFail |= flFAIL_STARTtlsrEJECTED ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    sockc.verifyReplyF( tinBaseP , 334 ) ;
                                                    sockc.writeF( tinBaseP , (osTextT*)tSay ) ;
                                                    etThread.traceF( tinBaseP , T("[tSay]: ")+tSay ) ;
                                                    //tSay = T("auth login ")+tUser+T("\r\n")+tPassword+T("\r\n") ;
                                                    tSay = T("auth login\r\n") ;
                                                {
                                                if( tUser.csF( tinBaseP ) )

//sockc.verifyReplyF( tinBaseP , 334 ) ;
//sockc.writeF( tinBaseP , (osTextT*)tSay ) ;
//tSay = T("auth login\r\n")+tUser+T("\r\n")+tPassword+T("\r\n") ;
//U::TO FIND A BUG

#endif
                                                }
//#endif
                                                    }
                                                        break ;
                                                        etThread.delF( tinBaseP , psttBccLine ) ;
                                                        etThread.traceF( tinBaseP , T("hello rejected: ")+tHelloVerb+T(" ")+tHelloMyName ) ;
                                                        flagsFail |= flFAIL_HELLOrEJECTED ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    sockc.verifyReplyF( tinBaseP , 250 ) ;
                                                    sockc.writeF( tinBaseP , (osTextT*)( tHelloVerb+T(" ")+tHelloMyName+T("\r\n") ) ) ;
//#if defined( NEVERdEFINED )

                                                    sockc.shakeHandsAsClientF( tinBaseP ) ;

                                                    }
                                                        break ;
                                                        etThread.delF( tinBaseP , psttBccLine ) ;
                                                        etThread.traceF( tinBaseP , T("starttls rejected") ) ;
                                                        flagsFail |= flFAIL_STARTtlsrEJECTED ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    sockc.verifyReplyF( tinBaseP , 220 ) ;
                                                    sockc.writeF( tinBaseP , (osTextT*)tSay ) ;
                                                    etThread.traceF( tinBaseP , T("[tSay]: ")+tSay ) ;
                                                    tSay = T("starttls\r\n") ;
                                                {
                                                if( bTls )
#if defined( NEVERdEFINED )

//U::20240209@1700: CLEAN THIS CODE UP; CONSIDER REMOVING SUPPORT FOR STARTTLS AND JUST REQUIRING ALL SMTP PEERS TO SUPPORT TLS CONNECTIONS
//U::20240209@1700: THIS MESS IS BECAUSE MAILGUN APPEARS TO NO LONGER SUPPORT STARTTLS ; THIS CODE WORKS WITH MAILGUN IF, AND ONLY IF, PORT 1d1 (465_9) IS SPECIFIED WITHIN THE soulC OBJECT ; EXAMPLE: etThread.boxPutF( tinBaseP , T("smtp.mailgun.org[admin]/1d1/smtp/fooey@admin.ideafarm.com/wo@ideafarm.com") , T("Subject: parameter 1\r\n\r\nparameter 2") ) ;


#endif
                                                }
                                                    break ;
                                                    etThread.delF( tinBaseP , psttBccLine ) ;
                                                    etThread.traceF( tinBaseP , T("hello rejected: ")+tHelloVerb+T(" ")+tHelloMyName ) ;
                                                    flagsFail |= flFAIL_HELLOrEJECTED ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                sockc.verifyReplyF( tinBaseP , 250 ) ;
                                                sockc.writeF( tinBaseP , (osTextT*)tSay ) ;
                                                etThread.traceF( tinBaseP , T("[tSay]: ")+tSay ) ;

                                                //}
                                                //    break ;
                                                //    etThread.delF( tinBaseP , psttBccLine ) ;
                                                //    etThread.traceF( tinBaseP , T("hello accepted: ")+tHelloVerb+T(" ")+tHelloMyName ) ;
                                                //    flagsFail |= flFAIL_HELLOaCCEPTED ;
                                                //    POOPR
                                                //{
                                                //if( POOP )
                                                //sockc.verifyReplyF( tinBaseP , 502 ) ;
                                                //sockc.writeF( tinBaseP , (osTextT*)tSay ) ;
                                                //etThread.traceF( tinBaseP , T("[tSay]: ")+tSay ) ;
#if defined( NEVERdEFINED )
                                                TN( tSay , "" ) ; tSay = ( tHelloVerb+T(" ")+tHelloMyName+T("\r\n") ) ;

                                                }
                                                    break ;
                                                    etThread.delF( tinBaseP , psttBccLine ) ;
                                                    etThread.traceF( tinBaseP , T("connecting: failed") ) ;
                                                    flagsFail |= flFAIL_COULDnOTcONNECT ;
                                                    POOPR
                                                {
                                                if( POOP )

                                                sockc.verifyReplyF( tinBaseP , 220 ) ;
                                                sockc.connectF( tinBaseP , idPort , hidServer ) ;
                                                etThread.traceF( tinBaseP , T("connecting to port ")+TF4(idPort,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;

                                                }
                                                    etThread.delF( tinBaseP , pstt1w ) ;
                                                    }
                                                        if( !bOk ) break ;
                                                        }
                                                            }
                                                                }
                                                                    }
                                                                        break ;
                                                                        }
                                                                            }
                                                                                break ;
                                                                                tPassword = T(psttc1) ;
                                                                            {
                                                                            case 9 :
                                                                            }
                                                                                break ;
                                                                                tUser = T(psttc1) ;
                                                                            {
                                                                            case 8 :
                                                                            }
                                                                                break ;

                                                                                }
                                                                                    bOk = 0 ;
                                                                                    etThread.traceF( tinBaseP , T("unexpected  (expected \"login\")") ) ;
                                                                                {
                                                                                if( etThread.strCompareF( tinBaseP , psttc1 , T("login") ) )
                                                                            {
                                                                            case 7 :
                                                                            }
                                                                                break ;

                                                                                }
                                                                                    bOk = 0 ;
                                                                                    etThread.traceF( tinBaseP , T("unexpected  (expected \"auth\")") ) ;
                                                                                {
                                                                                if( etThread.strCompareF( tinBaseP , psttc1 , T("auth") ) )
                                                                            {
                                                                            case 6 :
                                                                            }
                                                                                break ;

                                                                                else bTls = 1 ;
                                                                                }
                                                                                    bOk = 0 ;
                                                                                    etThread.traceF( tinBaseP , T("unexpected  (expected \"starttls\")") ) ;
                                                                                {
                                                                                if( etThread.strCompareF( tinBaseP , psttc1 , T("starttls") ) )
                                                                            {
                                                                            case 5 :
                                                                            }
                                                                                break ;
                                                                                tHelloMyName = T(psttc1) ;
                                                                            {
                                                                            case 4 :
                                                                            }
                                                                                break ;

                                                                                else tHelloVerb = T("ehlo") ;
                                                                                }
                                                                                    bOk = 0 ;
                                                                                    etThread.traceF( tinBaseP , T("unexpected  (expected \"ehlo\")") ) ;
                                                                                {
                                                                                if( etThread.strCompareF( tinBaseP , psttc1 , T("ehlo") ) )
                                                                            {
                                                                            case 3 :
                                                                        {
                                                                        switch( idw )
                                                                    {
                                                                    case 1 :
                                                                {
                                                                switch( idFormat )
                                                            {
                                                            default :
                                                            }
                                                                break ;
                                                                else idFormat = 1 ;
                                                                }
                                                                    bOk = 0 ;
                                                                    etThread.traceF( tinBaseP , T("unexpected  (expected \"1\")") ) ;
                                                                {
                                                                if( etThread.strCompareF( tinBaseP , psttc1 , T("1") ) )
                                                            {
                                                            case 2 :
                                                            }
                                                                break ;
                                                                }
                                                                    bOk = 0 ;
                                                                    etThread.traceF( tinBaseP , T("unexpected  (expected \"format\")") ) ;
                                                                {
                                                                if( etThread.strCompareF( tinBaseP , psttc1 , T("format") ) )
                                                            {
                                                            case 1 :
                                                        {
                                                        switch( ++ idw )
                                                        etThread.traceF( tinBaseP , T("protocol word: ")+T(psttc1) ) ;
                                                    {
                                                    FORsTRINGSiN1( pstt1w )
                                                    boolT bOk = 1 ;
                                                    ZE( countT , idw ) ;
                                                    etThread.strWordsF( tinBaseP , pstt1w , tProtocol , sttq ) ; ___( pstt1w ) ;
                                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                    ZE( strokeS* , pstt1w ) ;
                                                    ZE( countT , idFormat ) ;
                                                {
                                                if( tProtocol.csF( tinBaseP ) )
                                                TN( tPassword , "" ) ;
                                                TN( tUser , "" ) ;
                                                ZE( boolT , bTls ) ;
                                                TN( tHelloMyName , "factory1@internal.ideafarm.com" ) ;
                                                TN( tHelloVerb   , "helo" ) ;

                                                }
                                                    etThread.delF( tinBaseP , psttServer ) ;
                                                    etThread.traceF( tinBaseP , T("[psttServer,hidServer,tProtocol]:    ")+T(psttServer)+T("    ")+T(hidServer)+T("    ")+tProtocol ) ;

                                                    }
                                                        tProtocol = T(psttzProtocol) ;
                                                        strokeS* psttzProtocol = (strokeS*)(countT&)swProtocol ;
                                                        psttzLeverProtocol = psttServer ;
                                                    {
                                                    else if( swProtocol.idSlotOfLeverF( tinBaseP , (countT)psttServer ) )
                                                    }
                                                        etThread.traceF( tinBaseP , T("override [tProtocol]: ")+tProtocol ) ;
                                                        tProtocol = tProtocolOverride ;
                                                    {
                                                    if( tProtocolOverride.csF( tinBaseP ) )

                                                    hidServer = socketC::nicNameIF( tinBaseP , *((tinFullS&)tinBaseP).pEtScratch , psttServer ) ;

                                                    }
                                                        break ;
                                                        etThread.delF( tinBaseP , psttServer ) ;
                                                        etThread.traceF( tinBaseP , T("unauthorized smtp relay server: ")+T(psttServer) ) ;
                                                        flagsFail |= flFAIL_UNAUTHORIZEDrELAYsERVER ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    __Z( bOk ) ;

                                                    }
                                                        }
                                                            }
                                                                break ;
                                                                etThread.traceF( tinBaseP , T("authorized [psttServer]: ")+T(psttServer) ) ;
                                                                bOk = 1 ;
                                                            {
                                                            if( !etThread.strCompareF( tinBaseP , psttc1 , psttServer ) )
                                                        {
                                                        FORsTRINGSiN1( psttz1 )
                                                        strokeS* psttz1 = t1ListSmtpRelayServers ;
                                                    {
                                                    ZE( boolT , bOk ) ;

                                                    etThread.traceF( tinBaseP , T("[psttServer]: ")+T(psttServer) ) ;

                                                    etThread.delF( tinBaseP , psttMxExclude ) ;
                                                    etThread.delF( tinBaseP , psttRelayServer ) ;
                                                    }
                                                        etThread.delF( tinBaseP , psttMxName ) ;
                                                        else                                                                                                                               { ((tinFullS&)tinBaseP).pEtScratch->strMakeF(     tinBaseP , LF , psttServer , psttRelayServer                   ) ; ___( psttServer ) ; }
                                                        if( !psttRelayServer || !psttRelayServer->idAdam || ( psttMxExclude && !((tinFullS&)tinBaseP).pEtScratch->strCompareF( tinBaseP , psttMxExclude , psttMxName ) ) ) { ((tinFullS&)tinBaseP).pEtScratch->dnsNicNamesF( tinBaseP , psttServer , psttMxName , ifcIDtYPEdNSqUERY_MX ) ; ___( psttServer ) ; }

                                                        ((tinFullS&)tinBaseP).pEtScratch->strWordF( tinBaseP , psttMxName , psttr , sttq , strokeS('@') , -1 ) ; ___( psttMxName ) ;
                                                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                                        ZE( strokeS* , psttMxName ) ;
                                                    {
                                                    ZE( strokeS* , psttServer ) ;

                                                    }
                                                        //CONoUTrAW( T("mx exclude  : \"")+T(psttMxExclude)+T("\"\r\n") ) ;
                                                        //CONoUTrAW( T("relay server: \"")+T(psttRelayServer)+T("\"\r\n") ) ;
                                                        //etThread.delF( tinBaseP , psttSetting ) ;
                                                        //}
                                                        //    etThread.delF( tinBaseP , pstt1l ) ;
                                                        //    }
                                                        //        else break ;
                                                        //        else if( !psttMxExclude   ) { ((tinFullS&)tinBaseP).pEtScratch->strMakeF( tinBaseP , LF , psttMxExclude   , tIfoName ) ; ___( psttMxExclude   ) ; }
                                                        //             if( !psttRelayServer ) { ((tinFullS&)tinBaseP).pEtScratch->strMakeF( tinBaseP , LF , psttRelayServer , tIfoName ) ; ___( psttRelayServer ) ; }
                                                        //    {
                                                        //    FORsTRINGSiN1( pstt1l )
                                                        //    ((tinFullS&)tinBaseP).pEtScratch->strWordsOldF( tinBaseP , pstt1l , psttSetting , sttq , T("\r\n") ) ; ___( pstt1l ) ;
                                                        //    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                                        //    ZE( strokeS* , pstt1l ) ;
                                                        //{
                                                        //if( psttSetting )
                                                        //((tinFullS&)tinBaseP).pEtScratch->boxGetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF( tinBaseP , psttSetting , T("///d/ideafarm.home.")+TF1(etherC::ifc_idHomeIdisk_IF())+T(".setting.keyValue.smtprelay") ) ; ___( psttSetting ) ;
                                                        //U:: 20190728@1932:  REWRITE TO USE A SETTING RATHER THAN HARDCODE

                                                        ((tinFullS&)tinBaseP).pEtScratch->strMakeF( tinBaseP , LF , psttRelayServer , psttHost ) ; ___( psttRelayServer ) ;

                                                        ZE( strokeS* , psttSetting ) ;
                                                    {
                                                    ZE( strokeS* , psttMxExclude ) ;
                                                    ZE( strokeS* , psttRelayServer ) ;
                                                {
                                                TN( tProtocol , "" ) ;
                                                nicNameC hidServer ;

                                                socketC sockc( tinBaseP , *((tinFullS&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL /*| flSOCKETc_CRYPTfOREIGNsSLdEFERhANDSHAKE*/ , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

                                                countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                countT timeAllowedConnected = TICK >> 2 ;
                                                //countT idleTimeAllowedWrite = TOCK * 0x10 ;
                                                //countT idleTimeAllowedRead  = TOCK * 0x10 ;

                                                }
                                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , psttBccLine , T(">\r\n") ) ;
                                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , psttBccLine , psttr ) ;
                                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , psttBccLine , T("Bcc" ": <") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ 3 + psttr->idAdam ) ; ___( psttBccLine ) ;
                                                {
                                                if( offs == 2 )

                                                }
                                                    while( ~hWalk ) ;
                                                    }
                                                        }
                                                            break ;
                                                            bIncoming = 1 ;
                                                        {
                                                        if( !((tinFullS&)tinBaseP).pEtScratch->strCompareF( tinBaseP , psttr , psttw ) )
                                                        strokeS* psttw = (strokeS*)pStkEmailRelay->downF( tinBaseP , hWalk ) ;
                                                    {
                                                    do
                                                    handleC hWalk( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                {
                                                if( *pStkEmailRelay )
                                                ZE( boolT , bIncoming ) ;

                                                SCOOPS
                                            {
                                            IFsCRATCH
                                            ZE( strokeS* , psttBccLine ) ;

                                            etThread.traceF( tinBaseP , T("beginning of recipient \"")+T(psttr)+T("\"") ) ;
                                            strokeS* psttr = (strokeS*)ppzStk[ offs ]->downF( tinBaseP , hWalk ) ;
                                        {
                                        do
                                        handleC hWalk( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    if( *ppzStk[ offs ] )
                                    etThread.traceF( tinBaseP , T("beginning of handling ")+TF2(*ppzStk[offs],flFORMAT_NObIGITvALUES)+T(" recipients for list ")+TF2(offs,flFORMAT_NObIGITvALUES) ) ;
                                {
                                for( countT offs = 0 ; offs < 3 && !flagsFail ; offs ++ )
                                stackC* ppzStk[] = { &stTo , &stCc , &stBc } ;
                            {
                            if( !( F(flagsFail) & flFAIL_DURINGpARSING ) )

                            }
                                }
                                    flagsFail |= flFAIL_DURINGpARSING ;
                                    POOPR
                                {
                                if( POOP )

                                }
                                    etThread.delF( tinBaseP , psttFrToCc ) ;
                                    *pptFrToCc[ offc ] = T(psttFrToCc) ;

                                    }
                                        }
                                            }
                                                while( ~hWalk ) ;
                                                }
                                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , psttFrToCc , T(">\r\n") ) ;
                                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , psttFrToCc , psttw ) ;
                                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , psttFrToCc , T(!off?"To: <":"Cc" ": <") ) ;
                                                    strokeS* psttw = (strokeS*)ppzStk[ off ]->downF( tinBaseP , hWalk ) ;
                                                {
                                                do
                                                handleC hWalk( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            {
                                            if( *ppzStk[ off ] )
                                        {
                                        for( countT off = 0 ; off < 2 ; off ++ )
                                        stackC* ppzStk[] = { &stTo , &stCc } ;
                                    {

                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , psttFrToCc , T(">\r\n") ) ;
                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , psttFrToCc , psttFrom ) ;
                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , psttFrToCc , T("<") ) ;
                                    if( csttName ) ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , psttFrToCc , T("\"")+tName+T("\" ") ) ;
                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , psttFrToCc , T("From: ") ) ;
                                    ((tinFullS&)tinBaseP).pEtScratch->strMakeF( tinBaseP , LF , psttFrToCc , 0 , cstta ) ; ___( psttFrToCc ) ;

                                    const countT cstta = csttFrToCc + cFrToCcLines * 0x10 + csttName ; //0x10 IS MORE THAN NEEDED (0xa)

                                    const countT csttName = !tName.csF( tinBaseP ) ? 0 : tName.csF( tinBaseP ) + 3 ;
                                    textC& tName = !offc ? tNameOut : tNameIn ;

                                    ZE( strokeS* , psttFrToCc ) ;
                                {
                                for( countT offc = 0 ; offc <= 1 ; offc ++ )
                                textC* pptFrToCc[] = { &tFrToCcOutgoing , &tFrToCcIncoming } ;

                                //}
                                //    ((tinFullS&)tinBaseP).pEtScratch->strMakeF( tinBaseP , LF , psttFrom , T("hello@ideafarm.com") ) ; ___( psttFrom ) ;
                                //    ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , psttFrom ) ;
                                //{
                                //if( !((tinFullS&)tinBaseP).pEtScratch->strCompareF( tinBaseP , psttFrom , T(ifcEMAIL_HELLO) ) )
                                //SUPPORT FOR hello@ideafarm.com COMMENTED OUT DUE TO DECISION TO NOT PROVIDE ANY FUNCTIONALITY TO ANONYMOUS INTERNET USERS
                                //CS:CODEsYNC: b750104 3a50104
                                //MAPPING GLOBAL ALIASES

                                SCOOPS
                            {
                            IFsCRATCH
                            TN( tFrToCcIncoming , "" ) ;
                            TN( tFrToCcOutgoing , "" ) ;

                            }
                                }
                                    }
                                        }
                                            *pStkEmailRelay << psttw ;
                                            *info.pStkEmailRelay >> psttw ; ___( psttw ) ;
                                            ZE( strokeS* , psttw ) ;
                                        {
                                        if( info.pStkEmailRelay ) while( *info.pStkEmailRelay )

                                        tNameOut = T(info.psttNameOut) ;
                                        tNameIn  = T(info.psttNameIn) ;

                                        subaccountS info( tinBaseP , etThread , cPassAccount , cPassSubaccount , flSUBACCOUNT_QUERYeMAILrELAY | flSUBACCOUNT_QUERYnAMEiN | flSUBACCOUNT_QUERYnAMEoUT ) ;
                                    {

                                    }
                                        etThread.delF( tinBaseP , psttw ) ;
                                        tEmailOwner = T(psttw) ;
                                        queryEmailFromIdAccountF( tinBaseP , psttw , cPassAccount ) ; ___( psttw ) ;
                                        ZE( strokeS* , psttw ) ;
                                    {
                                {
                                if( cPassAccount && cPassSubaccount )

                                }
                                    etThread.delF( tinBaseP , psttw ) ;
                                    }
                                        etThread.delF( tinBaseP , pstt1w ) ;
                                        }
                                            }
                                                }
                                                    break ;
                                                    }
                                                        }
                                                            if( idWord ++ == 4 ) break ;

                                                            else { __( ((tinFullS&)tinBaseP).pEtScratch->strCompareF( tinBaseP , psttc2 , T("doubleblind") ) ) ; }
                                                            }
                                                                if( pco ) *pco = ((tinFullS&)tinBaseP).pEtScratch->strDigitsToSCountF( tinBaseP , psttc2 , 36 ) ;

                                                                }
                                                                    case 3 : { pco = &cPassAccount    ; break ; }
                                                                    case 2 : { pco = &cPassSubaccount ; break ; }
                                                                {
                                                                switch( idWord )
                                                                ZE( countT* , pco ) ;

                                                                }
                                                                    break ;
                                                                    POOPR
                                                                {
                                                                if( POOP )
                                                                __( !((tinFullS&)tinBaseP).pEtScratch->strIsDigitsF( tinBaseP , psttc2 , 36 ) ) ;                           // REJECT IF NOT ALL DIGITS
                                                            {
                                                            if( idWord <= 3 )
                                                        {
                                                        FORsTRINGSiN2( pstt1w )

                                                        countT idWord = 6 - cWords ; // 1 OR 2
                                                    {
                                                    else
                                                    if( POOP ) POOPR

                                                    __( cWords > 5 ) ;
                                                    __( cWords < 4 ) ;
                                                {
                                                case 1 : // [idItem].fdee86.trswwh1.doubleblind.1
                                            {
                                            switch( idFormat )

                                            }
                                                if( BlATHsTRING1 ) idFormat = ((tinFullS&)tinBaseP).pEtScratch->strDigitsToSCountF( tinBaseP , tIfoName , 36 ) ;
                                            {
                                            FORsTRINGSiN1( pstt1w )
                                        {
                                        if( pstt1w )
                                        const countT cWords = ((tinFullS&)tinBaseP).pEtScratch->strWordsOldF( tinBaseP , pstt1w , psttw , sttq , T(".") ) ; ___( pstt1w ) ;
                                        ZE( strokeS* , pstt1w ) ;
                                    {
                                    else if( psttw && psttw->idAdam )
                                    if( POOP ) POOPR
                                    ((tinFullS&)tinBaseP).pEtScratch->strSubstringF( tinBaseP , psttw , idf , sttq , S1C('@') , psttFrom ) ; ___( psttw ) ;
                                    countT idf = 1 ;
                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                    ZE( strokeS* , psttw ) ;

                                    SCOOPS
                                {
                                IFsCRATCH

                                ZE( countT , idFormat        ) ; // 4
                                ZE( countT , cPassAccount    ) ; // 3
                                ZE( countT , cPassSubaccount ) ; // 2
                            {
                            TN( tNameIn , "" ) ;
                            TN( tNameOut , "" ) ;
                        {
                        if( pStkEmailRelay )
                        etThread( tinBaseP , pStkEmailRelay , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkEmailRelay ) ;
                        ZE( stackC* , pStkEmailRelay ) ;
                        TN( tEmailOwner , "" ) ;
                        //PARSE psttFrom AND LOOKUP ACCOUNT OWNER NAME

                        ////else { //CONoUTrAW( "bad news, bro! psttFileBody is null or short\r\n" ) ; }
                        //}
                        //    //etThread.delF( tinBaseP , psttDump ) ;
                        //    //CONoUTrAW( T("****DUMPbEGIN\r\n")+T(psttDump)+T("\r\n****DUMPeND\r\n") ) ;
                        //    //etThread.strDumpIF( tinBaseP , psttDump , (byteT*)psttFileBody , sizeof( strokeS ) * ( CSpREFIX * 2 + 1 ) , flSTRdUMP_null , sizeof( strokeS ) , sizeof( countT ) ) ; ___( psttDump ) ;
                        //    //ZE( strokeS* , psttDump ) ;
                        //
                        //    //CONoUTrAW3( "ISsTRINGoFsTRINGS evaluates to " , ISsTRINGoFsTRINGS( psttFileBody ) , "\r\n" ) ;
                        //    //else                                                      { //CONoUTrAW( "STRING OF STRINGS? NO!\r\n" ) ; }
                        //    //if( psttFileBody[ CSpREFIX ].idCaste == sc_PREFIXlENGTH ) { //CONoUTrAW( "STRING OF STRINGS? yes\r\n" ) ; }
                        //{
                        //if( psttFileBody && psttFileBody->idAdam > CSpREFIX )

                        sIn >> psttFileBody ; ___( psttFileBody ) ;
                        ZE( strokeS* , psttFileBody ) ;

                        }
                            }
                                }
                                    }
                                        *ppzStk[ off ] << psttw ; psttw = 0 ;
                                        if( off < 2 ) csttFrToCc += psttw->idAdam ;
                                    {
                                    if( psttw )
                                    }
                                        case 2 : { etThread.traceF( tinBaseP , T("Bc" ": \"")+T(psttw)+T("\"\r\n") ) ; break ; }
                                        case 1 : { etThread.traceF( tinBaseP , T("Cc" ": \"")+T(psttw)+T("\"\r\n") ) ; break ; }
                                        case 0 : { etThread.traceF( tinBaseP , T("To: \"")   +T(psttw)+T("\"\r\n") ) ; break ; }
                                    {
                                    switch( off )
                                    sIn >> psttw ; ___( psttw ) ;
                                    ZE( strokeS* , psttw ) ;
                                {
                                while( cPlates -- )
                                if( off < 2 ) cFrToCcLines += cPlates ;
                                sIn >> cPlates ;
                                ZE( countT , cPlates ) ;
                            {
                            for( countT off = 0 ; off < 3 ; off ++ )
                            stackC* ppzStk[] = { &stTo , &stCc , &stBc } ;
                        {
                        countT csttFrToCc = psttFrom->idAdam ;
                        countT cFrToCcLines = 1 ;

                        sIn >> psttFrom ; ___( psttFrom ) ;
                        ZE( strokeS* , psttFrom ) ;

                        etThread.delF( tinBaseP , psttProtocolName ) ;
                        }
                            etThread.delF( tinBaseP , pstti ) ;
                            }
                                tProtocolOverride = T(pstti) ;
                                etThread.traceF( tinBaseP , T("protocol override [server, name, protocol]: ")+T(psttHost)+T("    ")+T(psttProtocolName)+T("    ")+T(pstti) ) ;
                            {
                            else
                            if( !pstti || !pstti->idAdam ) etThread.traceF( tinBaseP , T("not found [tKey]: ")+tKey ) ;
                            etThread.querySettingF( tinBaseP , pstti , tKey  ) ; ___( pstti ) ;
                            etThread.traceF( tinBaseP , T("query override protocol [tKey]: ")+tKey ) ;
                            TN( tKey , "" ) ; tKey = T("!ipdos.smtp.relay..")+T(psttHost)+T("..")+T(psttProtocolName) ;
                            ZE( strokeS* , pstti ) ;
                        {
                        if( psttProtocolName && psttProtocolName->idAdam )
                        TN( tProtocolOverride , "" ) ;

                        }
                            etThread.traceF( tinBaseP , T("after parsing [psttProtocolName]: ")+T(psttProtocolName) ) ;
                            etThread.traceF( tinBaseP , T("after parsing [psttHost]: ")+T(psttHost) ) ;
                            etThread.delF( tinBaseP , pstt1w ) ;
                            }
                                }
                                    break ;
                                    etThread.strMakeF( tinBaseP , LF , psttProtocolName , psttc1 ) ; ___( psttProtocolName ) ;
                                {
                                else
                                if( !psttHost ) { etThread.strMakeF( tinBaseP , LF , psttHost , psttc1 ) ; ___( psttHost ) ; }
                            {
                            FORsTRINGSiN1( pstt1w )
                            etThread.delF( tinBaseP , psttHost ) ;
                            etThread.strWordsF( tinBaseP , pstt1w , psttHost , sttq , T("[]") ) ; ___( pstt1w ) ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                            ZE( strokeS* , pstt1w ) ;
                            etThread.traceF( tinBaseP , T("parsing [psttHost]: ")+T(psttHost) ) ;
                        {
                        ZE( strokeS* , psttProtocolName ) ;

                        sIn >> idPort ;
                        ZE( countT , idPort ) ;

                        sIn >> psttHost ; ___( psttHost ) ;
                        ZE( strokeS* , psttHost ) ;
                    {
                    if( !( F(flagsFail) & flFAIL_COULDnOTgETsHADOW ) )
                    ZE( boolT , bFailPermanent ) ;

                    }
                        }
                            etThread.traceF( tinBaseP , TT(timeN1,timeN2)+T(" | could not get shadow of ")+T((strokeS*)tIfoName)+T(": ") ) ;
                            flagsFail |= flFAIL_COULDnOTgETsHADOW ;
                            POOPR ;
                        {
                        if( POOP )
                        ((tinFullS&)tinBaseP).pEtScratch->boxGetShadowF( tinBaseP , sIn , tIfoName ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    soulC sIn( tinBaseP , *((tinFullS&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) ) ;
                    IFsCRATCH{}

                    ZE( flagsT , flagsFail ) ;
                    etThread.traceF( tinBaseP , TT(timeN1,timeN2)+T(" | mailing out ")+T((strokeS*)tIfoName)+T(": ") ) ;

                    etThread.traceF( tinBaseP , tShort ) ;

                    }
                        etThread.delF( tinBaseP , psttShort ) ;
                        tShort = T(psttShort) ;
                        etThread.delF( tinBaseP , psttnu ) ;
                        etThread.strBisectF( tinBaseP , psttnu , psttShort , tIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShort , "" ) ;

                    TN( tIfoName , pInfo->psttIfoName ) ;
                {
                if( !bDir )

                const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirF( tinBaseP , pInfo , hFind , tToSend ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

        }
            while( !ether && ~hFind && !POOP ) ;
            }
                DEL( pInfo ) ;
                }
                    }
                        etThread.traceF( tinBaseP , tShort ) ;
                        etThread.diskMoveFileOrDirF( tinBaseP , tToSend+tShort , pInfo->psttIfoName ) ;

                        }
                            etThread.delF( tinBaseP , psttShort ) ;
                            tShort = T(psttShort) ;
                            etThread.delF( tinBaseP , psttnu ) ;
                            etThread.strBisectF( tinBaseP , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShort , "" ) ;
                    {
                    if( !bDir )

                    const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;

                    //TN( tIfoName , pInfo->psttIfoName ) ;
                {
                else
                }
                    break ;
                    DEL( pInfo ) ;
                {
                if( !pInfo || !pInfo->psttIfoName )

                etThread.diskFindFileOrDirF( tinBaseP , pInfo , hFind , tNotSent ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            do
            handleC hFind( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

            }
                }
                    }
                        etThread.delF( tinBaseP , pstti ) ;
                        }
                            psttProtocol = pstti ; pstti = 0 ;
                            strokeS*& psttProtocol = (strokeS*&)(countT&)swProtocol ;
                            psttzLeverProtocol = (strokeS*)psttc1 ;

                            etThread.traceF( tinBaseP , T("protocol [server, protocol]: ")+T(psttc1)+T("    ")+T(pstti) ) ;
                        {
                        if( pstti && pstti->idAdam )
                        etThread.querySettingF( tinBaseP , pstti , T("!ipdos.smtp.relay..")+T(psttc1)  ) ; ___( pstti ) ;
                        ZE( strokeS* , pstti ) ;

                        etThread.traceF( tinBaseP , T("[authorized smtp relay server]: ")+T(psttc1) ) ;
                    {
                    FORsTRINGSiN1( psttz1 )
                    strokeS* psttz1 = t1ListSmtpRelayServers ;
                {
                if( t1ListSmtpRelayServers.csF( tinBaseP ) )
                etThread.delF( tinBaseP , pstt1i ) ;
                }
                    etThread.delF( tinBaseP , pstti ) ;
                    }
                        t1ListSmtpRelayServers = T(pstt1i) ;
                        etThread.strWordsF( tinBaseP , pstt1i , pstti , sttq , T("/") ) ; ___( pstt1i ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    {
                    if( pstti && pstti->idAdam )
                    etThread.querySettingF( tinBaseP , pstti , T("!ipdos.smtp.relays")  ) ; ___( pstti ) ;
                    ZE( strokeS* , pstti ) ;
                {
                ZE( strokeS* , pstt1i ) ;
            {

            }
                }
                    swProtocol.freeAllF( tinBaseP ) ;
                    }
                        etThread.delF( tinBaseP , psttProtocol ) ;
                        strokeS*& psttProtocol = (strokeS*&)(countT&)swProtocol ;
                        psttzLeverProtocol = (strokeS*)swProtocol.leverF( tinBaseP , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                {
                countT cFlavors = swProtocol.cFlavorsF( tinBaseP ) ;
            {

            timeL2 = timeN2 ;
            timeL1 = timeN1 ;
        {
        if( timeE2 || timeE1 > TICK )

        etThread.osTimeSubtractF( tinBaseP , timeE1 , timeE2 , timeL1 , timeL2 ) ;
        sCountT timeE2 = timeN2 ;
        countT  timeE1 = timeN1 ;

        etThread.osTimeNowF( tinBaseP , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;
    {
    while( !ether && !etThread )
    switchC swProtocol( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverProtocol ) ;
    ZE( strokeS* , psttzLeverProtocol ) ;
    TN( t1ListSmtpRelayServers , "" ) ;
    ZE( sCountT , timeL2 ) ;
    ZE( countT  , timeL1 ) ;
    TN( tLeadingDoubleDot , "\r\n.." ) ;
    TN( tLeadingDot , "\r\n." ) ;
    TN( tDotRN , ".\r\n" ) ;
    stackC stBc( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stCc( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stTo( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    strokeS sSlash( '/' , sc_cFROMaSCII ) ;
    TN( tSlash , "/" ) ;
    TN( tStar , "*" ) ;
    //20190728@2139: COMMENTED OUT TO PUT THIS ADAM BACK INTO SERVICE WITHOUT OTHER LEGACY ADAMS:  etThread.osThreadAdamF( tinBaseP , ifcIDaDAM_ROOTfORMdATAeATER ) ;

    etThread.diskMakeDirIfNeededF( tinBaseP , tNotSentAbandoned ) ;
    etThread.diskMakeDirIfNeededF( tinBaseP , tNotSent ) ;
    etThread.diskMakeDirIfNeededF( tinBaseP , tSent ) ;
    etThread.diskMakeDirIfNeededF( tinBaseP , tToSend ) ;

    TN( tNotSentAbandoned , "" ) ; tNotSentAbandoned = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/email.notsentabandoned/") ;
    TN( tNotSent          , "" ) ; tNotSent          = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/email.notsent/") ;
    TN( tSent             , "" ) ; tSent             = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/email.sent/") ;
    TN( tToSend           , "" ) ; tToSend           = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/email.to.send/") ;

    const countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;

    }
        //}
        //    ++ s ; ether.osSleepF( tinBaseP , TOCK * 0x10 ) ; //TO AVOID LOADING SERVER DURING SYSTEM GEN
        //    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        //{

        //#endif

    //#endif
        }
            ether.ifcHireF( tinBaseP , T("ifcIDaDAM_ROOTmAILoUT") , bProcessAccessLogs ? ifcIDaDAM_ACCESSeVENTS2bOOKtOGETHER : ifcIDaDAM_CLOUD , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; // flHIRE_DISPLAYaUTO CAN BE COMMENTED OUT TO AVOID WDW FOR ROOT CLOUD INSTANCE WHICH IS USUALLY NOT INTERESTING

            etThread.traceF( tinBaseP , T("ROOTmAILoUT: [bProcessAccessLogs]:    ")+TF2(bProcessAccessLogs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tinBaseP , psttProcessAccessLogs ) ;
        //        bProcessAccessLogs = psttProcessAccessLogs && !etThread.strCompareF( tinBaseP , psttProcessAccessLogs , T("yes") ) ;
                ZE( strokeS* , psttProcessAccessLogs ) ; etThread.querySettingF( tinBaseP , psttProcessAccessLogs , T("!ipdos.process.access.logs")  ) ; ___( psttProcessAccessLogs ) ;
            {
            ZE( boolT , bProcessAccessLogs ) ;
        {
    //#if defined( NEVERdEFINED )
    //U:: ENABLE IN PRODUCTION (THIS WORKS BUT IS DISABLED TO FIND AN UNRELATED BUG)

        //#endif

        etThread.traceF( tinBaseP , T("debug 0") ) ;

        }
            }
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_ROOThEAL ;
                ether.ifcHireF( tinBaseP , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_HEALaRCHIVES , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                etThread.traceF( tinBaseP , T("ROOTmAILoUT: hiring ifcIDaDAM_HEALaRCHIVES") ) ;
            {
            else
            if( bNoHeal ) etThread.traceF( tinBaseP , T("ROOTmAILoUT: NOT hiring ifcIDaDAM_HEALaRCHIVES") ) ;

            //20240325@1619: HEALaRCHIVES IS ALWAYS LAUNCHED, AS MARKETING POLICY ("BARTERWARE")
            //20240320@2127: TO WORK AROUND A BUG, HEALaRCHIVES IS ONLY LAUNCHED WHEN EXPLICITLY COMMANDED
            //20221229@1429: HEALaRCHIVES IS ALWAYS LAUNCHED, AS MARKETING POLICY ("BARTERWARE")

            etThread.traceF( tinBaseP , T("ROOTmAILoUT: [bNoHeal]:    ")+TF2(bNoHeal,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tinBaseP , psttHeal ) ;
                bNoHeal = psttHeal && !etThread.strCompareF( tinBaseP , psttHeal , T("no") ) ;
                //((tinFullS&)tinBaseP).pc Utility[ 0 ] -- ; //U::
                ZE( strokeS* , psttHeal ) ; etThread.querySettingF( tinBaseP , psttHeal , T("!ipdos.heal")  ) ; ___( psttHeal ) ;
                //((tinFullS&)tinBaseP).pc Utility[ 0 ] ++ ; //U::
            {
            ZE( boolT , bNoHeal ) ;

            etThread.traceF( tinBaseP , T("debug 1") ) ;
        {

        //#if defined( NEVERdEFINED )

        etThread.traceF( tinBaseP , T("debug 2") ) ;

        }
            if( bServeSmtp ) ether.ifcHireF( tinBaseP , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_ROOTsMTPsERVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            etThread.traceF( tinBaseP , T("ROOTmAILoUT: [bServeSmtp]:    ")+TF2(bServeSmtp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            //20190730@0808: MOVED TO HERE BUT NOT TESTED.  IDEAFARM.COM CURRENTLY USES GOOGLE.COM'S SMTP SERVER TO RELAY OUTGOING EMAIL

            }
                etThread.delF( tinBaseP , psttServeSmtp ) ;
                bServeSmtp = psttServeSmtp && !etThread.strCompareF( tinBaseP , psttServeSmtp , T("yes") ) ;
                ZE( strokeS* , psttServeSmtp ) ; etThread.querySettingF( tinBaseP , psttServeSmtp , T("!ipdos.serve.smtp")  ) ; ___( psttServeSmtp ) ;
            {
            ZE( boolT , bServeSmtp ) ;
        {

        etThread.traceF( tinBaseP , T("debug 3") ) ;

        }
            }
                //U::homeS::homeIF().flagsAdams |= flHOMEsaDAMS_ROOTbANG ;

                //U::ether.ifcHireF( tinBaseP , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_GORILLAbANG , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                //U::ether.ifcHireF( tinBaseP , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_3BANG , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            {
            if( !bNoServeBang )
            etThread.traceF( tinBaseP , T("ROOTmAILoUT: [bNoServeBang]:    ")+TF2(bNoServeBang,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tinBaseP , psttServeBang ) ;
                bNoServeBang = psttServeBang && !etThread.strCompareF( tinBaseP , psttServeBang , T("no") ) ;
                ZE( strokeS* , psttServeBang ) ; etThread.querySettingF( tinBaseP , psttServeBang , T("!ipdos.serve.bang")  ) ; ___( psttServeBang ) ;
            {
            ZE( boolT , bNoServeBang ) ;
        {

        etThread.traceF( tinBaseP , T("debug 4") ) ;

        }
            }
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_RDPoPENhOUSE ;
                ether.ifcHireF( tinBaseP , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_REMOTEdESKTOPoPENhOUSE , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            {
            if( tPass.csF( tinBaseP ) )
            etThread.traceF( tinBaseP , T("ROOTmAILoUT: [bRdpOpenHouse]:    ")+T(tPass.csF(tinBaseP)?"yes":"no") ) ;

            }
                etThread.delF( tinBaseP , psttPass ) ;
                if( psttPass && psttPass->idAdam ) tPass = T(psttPass) ;
                ZE( strokeS* , psttPass ) ; etThread.querySettingF( tinBaseP , psttPass , T("!ipdos.barracuda.firewall.credentials64")  ) ; ___( psttPass ) ;
            {
            TN( tPass , "" ) ;
        {

        etThread.traceF( tinBaseP , T("debug 5") ) ;

    #endif
        }
            }
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_UDPfILEcATCHER ;
                ether.ifcHireF( tinBaseP , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_UDPfILErECEIVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                ether.ifcHireF( tinBaseP , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_UDPfILEcATCHER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            {
            if( bCatchUdpFiles )
            etThread.traceF( tinBaseP , T("ROOTmAILoUT: [bCatchUdpFiles]:    ")+TF2(bCatchUdpFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tinBaseP , psttCatchUdpFiles ) ;
                bCatchUdpFiles = !psttCatchUdpFiles || etThread.strCompareF( tinBaseP , psttCatchUdpFiles , T("no") ) ;
                ZE( strokeS* , psttCatchUdpFiles ) ; etThread.querySettingF( tinBaseP , psttCatchUdpFiles , T("!ipdos.catch.udp.files")  ) ; ___( psttCatchUdpFiles ) ;
            {
            ZE( boolT , bCatchUdpFiles ) ;
        {
    #if defined( NEVERdEFINED )

        etThread.traceF( tinBaseP , T("debug 6") ) ;

        }
            etThread.traceF( tinBaseP , T("debug 6.0") ) ;
            }
                etThread.traceF( tinBaseP , T("debug 6.1") ) ;
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_ROOThTTPsERVER ;
                etThread.traceF( tinBaseP , T("debug 6.2") ) ;
                ether.ifcHireF( tinBaseP , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_ROOThTTPsERVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                etThread.traceF( tinBaseP , T("debug 6.3") ) ;
            {
            if( bServeHttp )
            etThread.traceF( tinBaseP , T("debug 6.4") ) ;
            etThread.traceF( tinBaseP , T("ROOTmAILoUT: [bServeHttp]:    ")+TF2(bServeHttp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.traceF( tinBaseP , T("debug 6.5") ) ;
                etThread.delF( tinBaseP , psttServeHttp ) ;
                etThread.traceF( tinBaseP , T("debug 6.6") ) ;
                bServeHttp = psttServeHttp && !etThread.strCompareF( tinBaseP , psttServeHttp , T("yes") ) ;
                etThread.traceF( tinBaseP , T("debug 6.7") ) ;
                //((tinFullS&)tinBaseP).pc Utility[ 0 ] -- ; //U::
                ZE( strokeS* , psttServeHttp ) ; etThread.querySettingF( tinBaseP , psttServeHttp , T("!ipdos.serve.http")  ) ; ___( psttServeHttp ) ;
                //((tinFullS&)tinBaseP).pc Utility[ 0 ] ++ ; //U::
                etThread.traceF( tinBaseP , T("debug 6.8") ) ;
            {
            etThread.traceF( tinBaseP , T("debug 6.9") ) ;
            ZE( boolT , bServeHttp ) ;
            etThread.traceF( tinBaseP , T("debug 6.a") ) ;
        {

        etThread.traceF( tinBaseP , T("debug 7") ) ;

        #endif

        }
            if( bGorillaHttpReporter ) ether.ifcHireF( tinBaseP , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_GORILLAhTTPiDEAFARMcOMrEPORTER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            etThread.traceF( tinBaseP , T("ROOTmAILoUT: [bGorillaHttpReporter]:    ")+TF2(bGorillaHttpReporter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tinBaseP , psttGorillaHttpReporter ) ;
                bGorillaHttpReporter = psttGorillaHttpReporter && !etThread.strCompareF( tinBaseP , psttGorillaHttpReporter , T("yes") ) ;
                ZE( strokeS* , psttGorillaHttpReporter ) ; etThread.querySettingF( tinBaseP , psttGorillaHttpReporter , T("!ipdos.gorilla.http.reporter")  ) ; ___( psttGorillaHttpReporter ) ;
            {
            ZE( boolT , bGorillaHttpReporter ) ;
        {

        etThread.traceF( tinBaseP , T("debug 8") ) ;

        }
            if( bGorillaHttp ) ether.ifcHireF( tinBaseP , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_GORILLAhTTPiDEAFARMcOM , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            etThread.traceF( tinBaseP , T("ROOTmAILoUT: [bGorillaHttp]:    ")+TF2(bGorillaHttp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tinBaseP , psttGorillaHttp ) ;
                bGorillaHttp = psttGorillaHttp && !etThread.strCompareF( tinBaseP , psttGorillaHttp , T("yes") ) ;
                ZE( strokeS* , psttGorillaHttp ) ; etThread.querySettingF( tinBaseP , psttGorillaHttp , T("!ipdos.gorilla.http")  ) ; ___( psttGorillaHttp ) ;
            {
            ZE( boolT , bGorillaHttp ) ;
        {

        #if defined( NEVERdEFINED )

        //ether.ifcHireF( tinBaseP , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_UDPeCHO , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
        //etThread.traceF( tinBaseP , T("ROOTmAILoUT: hiring ifcIDaDAM_UDPeCHO") ) ;
        //U::20230611@1304: DISABLED TO UNCLUTTER STFU TRACE FILE.  UDPeCHO WORKS AND CAN BE ENABLED HERE FOR FURTHER TESTING AND DEVELOPMENT

        etThread.traceF( tinBaseP , T("debug 9") ) ;
    {
    if( !bSandbox )
    etThread.traceF( tinBaseP , T("debug [bSandbox]:    ")+TF2(bSandbox,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

bSandbox = 0 ;
    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;
{
if( pTaskP )
TASK( tmWorkF )

}
    return bFail ;
    }
        }
            }
                DEL( pInfo ) ;
                }
                    }
                        etherP.delF( tinBaseP , posti ) ;
                        }
                            etherP.strFuseF( tinBaseP , psttP , T(posti) ) ; ___( psttP ) ;
                            etherP.fileReadF( tinBaseP , posti , cToDo , hFileBody ) ;
                        {
                        if( posti )
                        etherP.newF( tinBaseP , LF , posti , costa ) ; ___( posti ) ;
                        ZE( osTextT* , posti ) ;
            
                        const countT costa = cToDo ;

                        if( cToDo > csttMaxP ) cToDo = csttMaxP ;

                        countT cToDo = pInfo->cbUsed ;
                        //CONoUTrAW3( "writing data: body file is " , pInfo->cbUsed , " bytes\r\n" ) ;
                    {
                    if( !bFail )
    
                    }
                        bFail = 1 ;
                        DEL( pInfo ) ;
                        //CONoUTrAW( "writing data: body file is too large\r\n" ) ;
                        POOPR
                    {
                    if( pInfo->cbUsedHigh )
                {
                if( !bFail && pInfo )
        
                }
                    bFail = 1 ;
                    //CONoUTrAW( "writing data: could not get info for body file\r\n" ) ;
                    POOPR
                {
                if( POOP )
                ((tinFullS&)tinBaseP).pEtScratch->diskFileQueryF( tinBaseP , pInfo , hFileBody ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            if( !bFail )
    
            }
                bFail = 1 ;
                //CONoUTrAW( "writing data: could not open the body file\r\n" ) ;
                POOPR
            {
            if( POOP )
            ((tinFullS&)tinBaseP).pEtScratch->fileOpenF( tinBaseP , hFileBody , countTC() , psttFileBodyP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
            handleC hFileBody( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            //CONoUTrAW( T("opening body file\r\n") ) ;

            SCOOPS
        {
        IFsCRATCH
    {
    else
    }
        bFail = 1 ;
    {
    else if( !etherP.diskFileExistsF( tinBaseP , psttFileBodyP ) )
    }
        }
            etherP.strMakeF( tinBaseP , LF , psttP , tBody ) ; ___( psttP ) ;
            etherP.delF( tinBaseP , psttb ) ;
            TN( tBody , "" ) ; tBody = T(psttb) ;
            etherP.strSubstringF( tinBaseP , psttb , idf , idl , psttFileBodyP ) ; ___( psttb ) ;
            ZE( countT , idl ) ;
            countT idf = tLit.csF( tinBaseP ) + 1 ;
            ZE( strokeS* , psttb ) ;
        {
        if( tLit.csF( tinBaseP ) < psttFileBodyP->idAdam )
    {
    if( 1 == etherP.strIdF( tinBaseP , tLit , psttFileBodyP ) )
    TN( tLit , "!literal:" ) ;

    ZE( boolT , bFail ) ;
    _IO_
{
boolT getBodySnipFromFileF( tinBaseS& tinBaseP , etherC& etherP , strokeS*& psttP , const strokeS* const psttFileBodyP , const countT csttMaxP = TOCK )

}
    return bFail ;
    }
        //U::CANNOT DO THIS HERE BECAUSE THERE MIGHT BE MUTLIPLE RECIPIENTS, EACH OF WHICH NEEDS THIS FILE TO EXIST: if( !bFail && etherP.diskFileExistsF( tinBaseP , psttFileBodyP ) ) etherP.boxZapF( tinBaseP , psttFileBodyP ) ;

        }
            }
                DEL( pInfo ) ;
                }
                    }
                        etherP.delF( tinBaseP , posti ) ;
                        }
                            }
                                }
                                    }
                                        }
                                            break ;
                                            if( bNew ) bNew = 0 ;
                                        {
                                        default :
                                        }
                                            break ;
                                            }
                                                //CONoUTrAW( "." ) ;
                                                bNew = 0 ;
                                            {
                                            if( bNew )
                                        {
                                        case '.' :
                                        }
                                            break ;
                                            if( !bNew ) bNew = 1 ;
                                        {
                                        case '\n' :
                                        case '\r' :
                                    {
                                    switch( posti[ offi ] )
                                    //CONoUTrAW( post2 ) ;
                                    osTextT post2[] = { posti[ offi ] , 0 } ;
                                {
                                for( countT offi = 0 ; offi < cNibble ; offi ++ )
            
                                cToDo -= cNibble ;
                                etherP.fileReadF( tinBaseP , posti , cNibble , hFileBody ) ;
                                countT cNibble = costa < cToDo ? costa : cToDo ;
                            {
                            while( cToDo )
                            boolT bNew = 1 ;
                        {
                        if( posti )
                        etherP.newF( tinBaseP , LF , posti , costa ) ; ___( posti ) ;
                        ZE( osTextT* , posti ) ;
            
                        const countT costa = TOCK < cToDo ? TOCK : cToDo ;
                        countT cToDo = pInfo->cbUsed ;
                        //CONoUTrAW3( "writing data: body file is " , pInfo->cbUsed , " bytes\r\n" ) ;
                    {
                    if( !bFail )
    
                    }
                        bFail = 1 ;
                        DEL( pInfo ) ;
                        //CONoUTrAW( "writing data: body file is too large\r\n" ) ;
                        POOPR
                    {
                    if( pInfo->cbUsedHigh )
                {
                if( !bFail && pInfo )
        
                }
                    bFail = 1 ;
                    //CONoUTrAW( "writing data: could not get info for body file\r\n" ) ;
                    POOPR
                {
                if( POOP )
                ((tinFullS&)tinBaseP).pEtScratch->diskFileQueryF( tinBaseP , pInfo , hFileBody ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            if( !bFail )
    
            }
                bFail = 1 ;
                //CONoUTrAW( "writing data: could not open the body file\r\n" ) ;
                POOPR
            {
            if( POOP )
            ((tinFullS&)tinBaseP).pEtScratch->fileOpenF( tinBaseP , hFileBody , countTC() , psttFileBodyP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
            handleC hFileBody( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            //CONoUTrAW( T("opening body file\r\n") ) ;

            SCOOPS
        {
        IFsCRATCH
    {
    else
    }
        bFail = 1 ;
    {
    else if( !etherP.diskFileExistsF( tinBaseP , psttFileBodyP ) )
    }
        }
            //CONoUTrAW( tBody ) ;
            etherP.delF( tinBaseP , psttb ) ;
            TN( tBody , "" ) ; tBody = T(psttb) ;
            etherP.strSubstringF( tinBaseP , psttb , idf , idl , psttFileBodyP ) ; ___( psttb ) ;
            ZE( countT , idl ) ;
            countT idf = tLit.csF( tinBaseP ) + 1 ;
            ZE( strokeS* , psttb ) ;
        {
        if( tLit.csF( tinBaseP ) < psttFileBodyP->idAdam )
        //CONoUTrAW( T("sending literal value\r\n") ) ;
    {
    if( 1 == etherP.strIdF( tinBaseP , tLit , psttFileBodyP ) )
    TN( tLit , "!literal:" ) ;

    //CONoUTrAW( T("processing body file \"")+T(psttFileBodyP)+T("\"\r\n") ) ;
    ZE( boolT , bFail ) ;
    _IO_
{
boolT logBodySnipFromFileF( tinBaseS& tinBaseP , etherC& etherP , const strokeS* const psttFileBodyP )

}
    return bFail ;

    }
        //U::CANNOT DO THIS HERE BECAUSE THERE MIGHT BE MUTLIPLE RECIPIENTS, EACH OF WHICH NEEDS THIS FILE TO EXIST: if( !bFail && etherP.diskFileExistsF( tinBaseP , psttFileBodyP ) ) etherP.boxZapF( tinBaseP , psttFileBodyP ) ;

        }
            }
                DEL( pInfo ) ;
                }
                    }
                        etherP.delF( tinBaseP , posti ) ;
                        }
                            }
                                }
                                    }
                                        }
                                            break ;
                                            if( bNew ) bNew = 0 ;
                                        {
                                        default :
                                        }
                                            break ;
                                            }
                                                sockP.writeF( tinBaseP , "." , 1 ) ;
                                                bNew = 0 ;
                                            {
                                            if( bNew )
                                        {
                                        case '.' :
                                        }
                                            break ;
                                            if( !bNew ) bNew = 1 ;
                                        {
                                        case '\n' :
                                        case '\r' :
                                    {
                                    switch( posti[ offi ] )
                                    sockP.writeF( tinBaseP , posti + offi , 1 ) ;
                                {
                                for( countT offi = 0 ; offi < cNibble ; offi ++ )
            
                                cToDo -= cNibble ;
                                etherP.fileReadF( tinBaseP , posti , cNibble , hFileBody ) ;
                                countT cNibble = costa < cToDo ? costa : cToDo ;
                            {
                            while( cToDo )
                            boolT bNew = 1 ;
                        {
                        if( posti )
                        etherP.newF( tinBaseP , LF , posti , costa ) ; ___( posti ) ;
                        ZE( osTextT* , posti ) ;
            
                        const countT costa = TOCK < cToDo ? TOCK : cToDo ;
                        countT cToDo = pInfo->cbUsed ;
                        //CONoUTrAW3( "writing data: body file is " , pInfo->cbUsed , " bytes\r\n" ) ;
                    {
                    if( !bFail )
    
                    }
                        bFail = 1 ;
                        DEL( pInfo ) ;
                        //CONoUTrAW( "writing data: body file is too large\r\n" ) ;
                        flagsFailP |= flFAIL_DATAbODYfILEtOOlARGE ;
                        POOPR
                    {
                    if( pInfo->cbUsedHigh )
                {
                if( !bFail && pInfo )
        
                }
                    bFail = 1 ;
                    //CONoUTrAW( "writing data: could not get info for body file\r\n" ) ;
                    flagsFailP |= flFAIL_DATAcANNOTgETbODYfILEiNFO ;
                    POOPR
                {
                if( POOP )
                ((tinFullS&)tinBaseP).pEtScratch->diskFileQueryF( tinBaseP , pInfo , hFileBody ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            if( !bFail )
    
            }
                bFail = 1 ;
                //CONoUTrAW( "writing data: could not open the body file\r\n" ) ;
                flagsFailP |= flFAIL_DATAcANNOToPENfILE ;
                POOPR
            {
            if( POOP )
            ((tinFullS&)tinBaseP).pEtScratch->fileOpenF( tinBaseP , hFileBody , countTC() , psttFileBodyP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
            handleC hFileBody( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            //CONoUTrAW( T("opening body file\r\n") ) ;

            SCOOPS
        {
        IFsCRATCH
    {
    else
    }
        bFail = 1 ;
        flagsFailP |= flFAIL_DATAfILEdOESnOTeXIST ;
    {
    else if( !etherP.diskFileExistsF( tinBaseP , psttFileBodyP ) )
    }
        }
            sockP.writeF( tinBaseP , (osTextT*)tBody , tBody.csF( tinBaseP ) ) ;
            etherP.delF( tinBaseP , psttb ) ;
            TN( tBody , "" ) ; tBody = T(psttb) ;
            etherP.strSubstringF( tinBaseP , psttb , idf , idl , psttFileBodyP ) ; ___( psttb ) ;
            ZE( countT , idl ) ;
            countT idf = tLit.csF( tinBaseP ) + 1 ;
            ZE( strokeS* , psttb ) ;
        {
        if( tLit.csF( tinBaseP ) < psttFileBodyP->idAdam )
        //CONoUTrAW( T("sending literal value\r\n") ) ;
    {
    if( 1 == etherP.strIdF( tinBaseP , tLit , psttFileBodyP ) )
    TN( tLit , "!literal:" ) ;

    etherP.traceF( tinBaseP , T("processing body file \"")+T(psttFileBodyP)+T("\"") ) ;
    ZE( boolT , bFail ) ;
{
boolT writeBodySnipFromFileF( tinBaseS& tinBaseP , etherC& etherP , socketC& sockP , const strokeS* const psttFileBodyP , flagsT& flagsFailP )

}
    }
        sIn >> psttP ; ___( psttP ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tinBaseP , sIn ) ;
        soulC sIn( tinBaseP , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tinBaseP , sOut ) ;
        sOut << cPassAccountSP ;
        sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKeMAILfROMiDaCCOUNT ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tinBaseP , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tinBaseP , homeS::homeIF().idPortListServerEmailIdAccount ) ;
        socketC sock( tinBaseP , *((tinFullS&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) ) ;

        SCOOPS
    {
    IFsCRATCH

    if( POOP ) return ;
    __NZ( psttP ) ;
    if( POOP ) return ;
{
voidT queryEmailFromIdAccountF( tinBaseS& tinBaseP , strokeS*& psttP , const countT cPassAccountSP )
//DUPLICATE CODE: b750104 3a50104

#define flFAIL_COULDnOTzAPsENTfILE                  0xe80000ff
#define flFAIL_STARTtlsrEJECTED                     0xe40000ff
#define flFAIL_UNAUTHORIZEDrELAYsERVER              0xe20000ff
#define flFAIL_DATAfILEdOESnOTeXIST                 0xe10000ff
#define flFAIL_DATAbODYfILEtOOlARGE                 0xe08000ff
#define flFAIL_DATAcANNOTgETbODYfILEiNFO            0xe04000ff
#define flFAIL_DATAcANNOToPENfILE                   0xe02000ff
#define flFAIL_COULDnOTmOVEfILE                     0xe01000ff
#define flFAIL_COULDnOTgETsHORTfILEnAME             0xe00800ff
#define flFAIL_UNKNOWNeRROR                         0xe00400ff
#define flFAIL_QUITcOMMANDrEJECTED                  0xe00200ff
#define flFAIL_BODYrEJECTED                         0xe00100ff
#define flFAIL_DATAcOMMANDrREJECTED                 0xe00080ff
#define flFAIL_RCPTtOrEJECTED                       0xe00040ff
#define flFAIL_MAILfROMrEJECTED                     0xe00020ff
#define flFAIL_HELLOaCCEPTED                        0xe00010ff
#define flFAIL_HELLOrEJECTED                        0xe00008ff
#define flFAIL_COULDnOTcONNECT                      0xe00004ff
#define flFAIL_DURINGpARSING                        0xe00002ff
#define flFAIL_COULDnOTgETsHADOW                    0xe00001ff

/*1*/WAKEhIDE( "ifcIDaDAM_ROOTmAILoUT" )/*1*/

/**/
*/
watches a directory containing email to send
/*

// 20190728@1946: EDIT TO MIGRATE FROM boxMenuF TO diskFindWothF
//OBSOLETES 5adam.5100059d.1

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

