
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        }
            swProtocol.freeAllF( tin0P ) ;
            }
                etThread.delF( tin0P , psttProtocol ) ;
                strokeS*& psttProtocol = (strokeS*&)(countT&)swProtocol ;
                psttzLeverProtocol = (strokeS*)swProtocol.leverF( tin0P , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        {
        countT cFlavors = swProtocol.cFlavorsF( tin0P ) ;
    {

    }
        ++ s ; ether.osSleepF( tin0P , TOCK << 4 ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        while( !ether && ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                }
                    /**/etThread.traceF( tin0P , (!F(flagsFail)?T("aok"):T("flagsFail:")+TF2(flagsFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)) ) ;

#endif
                    }
                        }
                            }
                                flagsFail |= flFAIL_COULDnOTzAPsENTfILE ;
                                POOPR
                            {
                            if( POOP )
                            ((tin1S&)tin0P).pEtScratch->boxZapF( tin0P , tWhere+tShort ) ;
                        {
                        if( !bFailPermanent && !( F(flagsFail) ) )

                        SCOOPS
                        _IO_
                    {
                    IFsCRATCHoK                               //20201010@1520: ADDED WITHOUT ANALYSIS TO PREVENT ACCUMULATION OF FILES
#if defined( NEVERdEFINED )
//U::TO FIND A BUG

                    }
                        }
                            flagsFail |= flFAIL_COULDnOTmOVEfILE ;
                            POOPR
                        {
                        if( POOP )
                        ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tWhere+tShort , tIfoName ) ;

                        SCOOPS
                    {
                    IFsCRATCHoK

                    ;
                            : tSent
                            ? tNotSent
                        : F(flagsFail)
                        ? tNotSentAbandoned

                    TN( tWhere , "" ) ; tWhere = bFailPermanent

                    /**/etThread.traceF( tin0P , T("moving the file") ) ;

                    }
                        flagsFail |= flFAIL_COULDnOTgETsHORTfILEnAME ;
                        POOPR
                    {
                    if( POOP )

                    /**/etThread.traceF( tin0P , T("cleaning up 3") ) ;

                    }
                        /**/etThread.traceF( tin0P , T("unknown error") ) ;
                        flagsFail |= flFAIL_UNKNOWNeRROR ;
                        POOPR
                    {
                    if( POOP )
                    /**/etThread.traceF( tin0P , T("cleaning up 2") ) ;

                    }
                        stBc.purgeF( tin0P ) ;
                        stCc.purgeF( tin0P ) ;
                        stTo.purgeF( tin0P ) ;

                        etThread.delF( tin0P , psttFileBody ) ;

                        /**/etThread.traceF( tin0P , T("cleaning up 1") ) ;
                        etThread( tin0P , pStkEmailRelay ) ;
                        etThread.delF( tin0P , psttHost ) ;
                        etThread.delF( tin0P , psttFrom ) ;
                        }
                            }
                                }
                                    /**/etThread.traceF( tin0P , T("end of handling list ")+TF2(offs,flFORMAT_NObIGITvALUES) ) ;
                                    }
                                        while( ~hWalk ) ;
                                        }
                                            /**/etThread.traceF( tin0P , T("end of recipient \"")+T(psttr)+T("\"") ) ;
                                            etThread.delF( tin0P , psttBccLine ) ;

                                            /**/etThread.traceF( tin0P , T("destroyed socket") ) ;
                                            }
                                                /**/etThread.traceF( tin0P , T("destroying socket") ) ;
                                                }
                                                    break ;
                                                    etThread.delF( tin0P , psttBccLine ) ;
                                                    /**/etThread.traceF( tin0P , T("writing quit: failed") ) ;
                                                    flagsFail |= flFAIL_QUITcOMMANDrEJECTED ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                sockc.verifyReplyF( tin0P , 221 ) ;
                                                sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                /**/etThread.traceF( tin0P , T("[tSay]: ")+tSay ) ;
                                                tSay = T("quit\r\n") ;

                                                //}
                                                //    break ;
                                                //
                                                //    }
                                                //        etThread.boxPutF( tin0P , T("//smtp/" ifcEMAIL_MAILoUT "/")+T(psttFrom) , tReply , tReply.csF( tin0P ) ) ;
                                                //
                                                //        ) ;
                                                //
                                                //            "Your email was sent.\r\n"
                                                //            "\r\n"
                                                //            "Subject: Your email was sent\r\n"
                                                //
                                                //        TN( tReply ,
                                                //    {
                                                //    //NOTIFY from THAT EMAIL WAS SENT
                                                //    CONoUTrAW( T("an email was sent.  notifying \"")+T(psttFrom)+T("\"\r\n") ) ;
                                                //{
                                                //else if( etThread.strCompareF( tin0P , psttFrom , T(ifcEMAIL_MAILoUT) ) )
                                                //THIS CAN CYCLE INFINITELY

                                                }
                                                    break ;
                                                    etThread.delF( tin0P , psttBccLine ) ;

                                                    //}
                                                    //    etThread.boxPutF( tin0P , T("//smtp/" ifcEMAIL_MAILoUT "/")+T(psttFrom) , tReply , tReply.csF( tin0P ) ) ;
                                                    //
                                                    //    ) ;
                                                    //
                                                    //        "       will avoid a bug in the censoring software.)\r\n"
                                                    //        "       the brackets so that they appear as \"[ ]\".  (Adding the space between the brackets\r\n"
                                                    //        "    2. If your email contains a '[' followed immediately by a ']', put a space between\r\n"
                                                    //        "\r\n"
                                                    //        "    1. Remove all references to web sites that might be listed as spamming sites.\r\n"
                                                    //        "\r\n"
                                                    //        "Tips:\r\n"
                                                    //        "\r\n"
                                                    //        "Please resend your email after editing it to avoid this \"no spam\" censoring.\r\n"
                                                    //        "\r\n"
                                                    //        "recipient.\r\n"
                                                    //        "It thinks that your note is spam, so is refusing to relay it to your intended\r\n"
                                                    //        "That relay combats spam by refusing to handle items that appeaer to be spam.\r\n"
                                                    //        "\r\n"
                                                    //        "    k2smtpout.secureserver.net\r\n"
                                                    //        "\r\n"
                                                    //        "Email sent by the IDEAFARM.COM email server is relayed through\r\n"
                                                    //        "\r\n"
                                                    //        "Subject: Your email could not be sent\r\n"
                                                    //
                                                    //    TN( tReply ,
                                                    //    CONoUTrAW( T("could not send; notifying\"")+T(psttFrom)+T("\"\r\n") ) ;
                                                    //{
                                                    //SEND A REJECTED NOTICE TO from

                                                    }
                                                        }
                                                            __( logBodySnipFromFileF( tin0P , etThread , psttc1 ) ) ;      //20190929@1526: psttc1 WITHOUT ANALYSIS
                                                        {
                                                        FORsTRINGSiN1( psttFileBody )
                                                    {
                                                    else
                                                    if( !ISsTRINGoFsTRINGS( psttFileBody ) ) { __( logBodySnipFromFileF( tin0P , etThread , psttFileBody ) ) ; }

                                                    }
                                                        CONoUTrAW( tHeaders ) ;
                                                        TN( tHeaders , "" ) ; tHeaders = (!bIncoming?tFrToCcOutgoing:tFrToCcIncoming)+T(psttBccLine) ;
                                                    {
                                                    //LOG THE DATA

                                                    bFailPermanent = 1 ;
                                                    flagsFail |= flFAIL_BODYrEJECTED ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                sockc.verifyReplyF( tin0P , 250 ) ; //WILL FAIL IF ANTISPAM RELAYER REFUSES DATA BECAUSE IT CONTAINS REFERENCE TO BLACKLISTED (SPAMMER) WEB SITE
                                                }
                                                    sockc.writeF( tin0P , "\r\n.\r\n" , 5 ) ;

                                                    }
                                                       break ;
                                                       etThread.delF( tin0P , psttBccLine ) ;
                                                       /**/etThread.traceF( tin0P , T("call to writeBodySnipFromFileF failed [psttFileBody]: ")+T(psttFileBody) ) ;
                                                       POOPR
                                                    {
                                                    if( POOP )

                                                    }
                                                        sockc.writeF( tin0P , (osTextT*)tBodyEpilog , tBodyEpilog.csF( tin0P ) ) ;
                                                        ) ;
                                                    
                                                            "--IdeaFarmMimeBoundary\r\n"
                                                            "\r\n"
                                                    
                                                        TN( tBodyEpilog ,
                                                    {
                                                    if( bMime )

                                                    }
                                                        }
                                                            }
                                                                break ;
                                                                etThread.delF( tin0P , psttBccLine ) ;
                                                                /**/etThread.traceF( tin0P , T("call to writeBodySnipFromFileF failed [psttc1]: ")+T(psttc1) ) ;
                                                                POOPR
                                                            {
                                                            if( POOP )
                                                            __( writeBodySnipFromFileF( tin0P , etThread , sockc , psttc1 , flagsFail ) ) ;      //20190929@1526: psttc1 WITHOUT ANALYSIS
                                                        {
                                                        FORsTRINGSiN1( psttFileBody )
                                                    {
                                                    else
                                                    if( !ISsTRINGoFsTRINGS( psttFileBody ) ) { __( writeBodySnipFromFileF( tin0P , etThread , sockc , psttFileBody , flagsFail ) ) ; }

                                                    }
                                                        sockc.writeF( tin0P , (osTextT*)tMimeHeaders , tMimeHeaders.csF( tin0P ) ) ;
                                                        TN( tMimeHeaders , "MIME-Version: 1.0\r\nContent-Type: multipart/mixed; boundary=\"IdeaFarmMimeBoundary\"\r\n" ) ;
                                                    {
                                                    if( bMime )

                                                    }
                                                        sockc.writeF( tin0P , (osTextT*)tHeaders , tHeaders.csF( tin0P ) ) ;
                                                        /**/etThread.traceF( tin0P , T("[tHeaders]: ")+tHeaders ) ;
                                                        TN( tHeaders , "" ) ; tHeaders = (!bIncoming?tFrToCcOutgoing:tFrToCcIncoming)+T(psttBccLine) ;
                                                    {
                                                {

                                                }
                                                    break ;
                                                    etThread.delF( tin0P , psttBccLine ) ;
                                                    /**/etThread.traceF( tin0P , T("writing data cmd: failed") ) ;
                                                    flagsFail |= flFAIL_DATAcOMMANDrREJECTED ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                sockc.verifyReplyF( tin0P , 354 ) ;
                                                sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                /**/etThread.traceF( tin0P , T("[tSay]: ")+tSay ) ;
                                                tSay = T("data\r\n") ;

                                                }
                                                    break ;
                                                    etThread.delF( tin0P , psttBccLine ) ;
                                                    /**/etThread.traceF( tin0P , T("writing rcpt to: failed") ) ;
                                                    flagsFail |= flFAIL_RCPTtOrEJECTED ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                sockc.verifyReplyF( tin0P , 250 ) ;
                                                sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                /**/etThread.traceF( tin0P , T("[tSay]: ")+tSay ) ;
                                                tSay = T("rcpt to:<")+T(psttr)+T(">\r\n") ;

                                                }
                                                    break ;
                                                    etThread.delF( tin0P , psttBccLine ) ;
                                                    /**/etThread.traceF( tin0P , T("mail from: failed") ) ;
                                                    flagsFail |= flFAIL_MAILfROMrEJECTED ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                sockc.verifyReplyF( tin0P , 250 ) ;
                                                sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                /**/etThread.traceF( tin0P , T("[tSay]: ")+tSay ) ;
                                                tSay = T("mail from:<")+T(psttFrom)+T(">\r\n") ;

                                                }
                                                    }
                                                        break ;
                                                        etThread.delF( tin0P , psttBccLine ) ;
                                                        /**/etThread.traceF( tin0P , T("credentials (password) rejected") ) ;
                                                        flagsFail |= flFAIL_STARTtlsrEJECTED ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    sockc.verifyReplyF( tin0P , 235 ) ;
                                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                    /**/etThread.traceF( tin0P , T("[tSay]: ")+tSay ) ;
                                                    tSay = tPassword+T("\r\n") ;

                                                    }
                                                        break ;
                                                        etThread.delF( tin0P , psttBccLine ) ;
                                                        /**/etThread.traceF( tin0P , T("credentials (user) rejected") ) ;
                                                        flagsFail |= flFAIL_STARTtlsrEJECTED ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    sockc.verifyReplyF( tin0P , 334 ) ;
                                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                    /**/etThread.traceF( tin0P , T("[tSay]: ")+tSay ) ;
                                                    tSay = tUser+T("\r\n") ;

                                                    }
                                                        break ;
                                                        etThread.delF( tin0P , psttBccLine ) ;
                                                        /**/etThread.traceF( tin0P , T("auth login rejected") ) ;
                                                        flagsFail |= flFAIL_STARTtlsrEJECTED ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    sockc.verifyReplyF( tin0P , 334 ) ;
                                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                    /**/etThread.traceF( tin0P , T("[tSay]: ")+tSay ) ;
                                                    //tSay = T("auth login ")+tUser+T("\r\n")+tPassword+T("\r\n") ;
                                                    tSay = T("auth login\r\n") ;
                                                {
                                                if( tUser.csF( tin0P ) )

//sockc.verifyReplyF( tin0P , 334 ) ;
//sockc.writeF( tin0P , (osTextT*)tSay ) ;
//tSay = T("auth login\r\n")+tUser+T("\r\n")+tPassword+T("\r\n") ;
//U::TO FIND A BUG

//#endif
                                                }
//#endif
                                                    }
                                                        break ;
                                                        etThread.delF( tin0P , psttBccLine ) ;
                                                        /**/etThread.traceF( tin0P , T("hello rejected: ")+tHelloVerb+T(" ")+tHelloMyName ) ;
                                                        flagsFail |= flFAIL_HELLOrEJECTED ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    sockc.verifyReplyF( tin0P , 250 ) ;
                                                    sockc.writeF( tin0P , (osTextT*)( tHelloVerb+T(" ")+tHelloMyName+T("\r\n") ) ) ;
//#if defined( NEVERdEFINED )

                                                    sockc.shakeHandsAsClientF( tin0P ) ;

                                                    }
                                                        break ;
                                                        etThread.delF( tin0P , psttBccLine ) ;
                                                        /**/etThread.traceF( tin0P , T("starttls rejected") ) ;
                                                        flagsFail |= flFAIL_STARTtlsrEJECTED ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    sockc.verifyReplyF( tin0P , 220 ) ;
                                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                    /**/etThread.traceF( tin0P , T("[tSay]: ")+tSay ) ;
                                                    tSay = T("starttls\r\n") ;
                                                {
                                                if( bTls )
//#if defined( NEVERdEFINED )

//U::20241123@0626: MORE EXPERIMENTING TO GET A DIFFERENT SERVER TO WORK
//U::20240209@1700: CLEAN THIS CODE UP; CONSIDER REMOVING SUPPORT FOR STARTTLS AND JUST REQUIRING ALL SMTP PEERS TO SUPPORT TLS CONNECTIONS
//U::20240209@1700: THIS MESS IS BECAUSE MAILGUN APPEARS TO NO LONGER SUPPORT STARTTLS ; THIS CODE WORKS WITH MAILGUN IF, AND ONLY IF, PORT 1d1 (465_9) IS SPECIFIED WITHIN THE soulC OBJECT ; EXAMPLE: etThread.boxPutF( tin0P , T("smtp.mailgun.org[admin]/1d1/smtp/fooey@admin.ideafarm.com/wo@ideafarm.com") , T("Subject: parameter 1\r\n\r\nparameter 2") ) ;


//#endif
                                                }
                                                    break ;
                                                    etThread.delF( tin0P , psttBccLine ) ;
                                                    /**/etThread.traceF( tin0P , T("hello rejected: ")+tHelloVerb+T(" ")+tHelloMyName ) ;
                                                    flagsFail |= flFAIL_HELLOrEJECTED ;
                                                    POOPR
                                                {
                                                if( POOP )
                                                sockc.verifyReplyF( tin0P , 250 ) ;
                                                sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                /**/etThread.traceF( tin0P , T("[tSay]: ")+tSay ) ;

                                                //}
                                                //    break ;
                                                //    etThread.delF( tin0P , psttBccLine ) ;
                                                //    /**/etThread.traceF( tin0P , T("hello accepted: ")+tHelloVerb+T(" ")+tHelloMyName ) ;
                                                //    flagsFail |= flFAIL_HELLOaCCEPTED ;
                                                //    POOPR
                                                //{
                                                //if( POOP )
                                                //sockc.verifyReplyF( tin0P , 502 ) ;
                                                //sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                /**/etThread.traceF( tin0P , T("[tSay]: ")+tSay ) ;
//#if defined( NEVERdEFINED )
                                                TN( tSay , "" ) ; tSay = ( tHelloVerb+T(" ")+tHelloMyName+T("\r\n") ) ;

                                                }
                                                    break ;
                                                    etThread.delF( tin0P , psttBccLine ) ;
                                                    /**/etThread.traceF( tin0P , T("connecting: failed") ) ;
                                                    flagsFail |= flFAIL_COULDnOTcONNECT ;
                                                    POOPR
                                                {
                                                if( POOP )

                                                sockc.verifyReplyF( tin0P , 220 ) ;
                                                sockc.connectF( tin0P , idPort , hidServer ) ;
                                                /**/etThread.traceF( tin0P , T("connecting to port ")+TF4(idPort,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;

                                                }
                                                    etThread.delF( tin0P , pstt1w ) ;
                                                    }
                                                        if( !bOk ) break ;
                                                        }
                                                            }
                                                                }
                                                                    }
                                                                        break ;
                                                                        }
                                                                            }
                                                                                break ;
                                                                                tPassword = T(psttc1) ;
                                                                            {
                                                                            case 9 :
                                                                            }
                                                                                break ;
                                                                                tUser = T(psttc1) ;
                                                                            {
                                                                            case 8 :
                                                                            }
                                                                                break ;

                                                                                }
                                                                                    bOk = 0 ;
                                                                                    /**/etThread.traceF( tin0P , T("unexpected  (expected \"login\")") ) ;
                                                                                {
                                                                                if( etThread.strCompareF( tin0P , psttc1 , T("login") ) )
                                                                            {
                                                                            case 7 :
                                                                            }
                                                                                break ;

                                                                                }
                                                                                    bOk = 0 ;
                                                                                    /**/etThread.traceF( tin0P , T("unexpected  (expected \"auth\")") ) ;
                                                                                {
                                                                                if( etThread.strCompareF( tin0P , psttc1 , T("auth") ) )
                                                                            {
                                                                            case 6 :
                                                                            }
                                                                                break ;

                                                                                else bTls = 1 ;
                                                                                }
                                                                                    bOk = 0 ;
                                                                                    /**/etThread.traceF( tin0P , T("unexpected  (expected \"starttls\")") ) ;
                                                                                {
                                                                                if( etThread.strCompareF( tin0P , psttc1 , T("starttls") ) )
                                                                            {
                                                                            case 5 :
                                                                            }
                                                                                break ;
                                                                                tHelloMyName = T(psttc1) ;
                                                                            {
                                                                            case 4 :
                                                                            }
                                                                                break ;

                                                                                else tHelloVerb = T("ehlo") ;
                                                                                }
                                                                                    bOk = 0 ;
                                                                                    /**/etThread.traceF( tin0P , T("unexpected  (expected \"ehlo\")") ) ;
                                                                                {
                                                                                if( etThread.strCompareF( tin0P , psttc1 , T("ehlo") ) )
                                                                            {
                                                                            case 3 :
                                                                        {
                                                                        switch( idw )
                                                                    {
                                                                    case 1 :
                                                                {
                                                                switch( idFormat )
                                                            {
                                                            default :
                                                            }
                                                                break ;
                                                                else idFormat = 1 ;
                                                                }
                                                                    bOk = 0 ;
                                                                    /**/etThread.traceF( tin0P , T("unexpected  (expected \"1\")") ) ;
                                                                {
                                                                if( etThread.strCompareF( tin0P , psttc1 , T("1") ) )
                                                            {
                                                            case 2 :
                                                            }
                                                                break ;
                                                                }
                                                                    bOk = 0 ;
                                                                    /**/etThread.traceF( tin0P , T("unexpected  (expected \"format\")") ) ;
                                                                {
                                                                if( etThread.strCompareF( tin0P , psttc1 , T("format") ) )
                                                            {
                                                            case 1 :
                                                        {
                                                        switch( ++ idw )
                                                        /**/etThread.traceF( tin0P , T("protocol word: ")+T(psttc1) ) ;
                                                    {
                                                    FORsTRINGSiN1( pstt1w )
                                                    boolT bOk = 1 ;
                                                    ZE( countT , idw ) ;
                                                    etThread.strWordsF( tin0P , pstt1w , tProtocol , sttq ) ; ___( pstt1w ) ;
                                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                    ZE( strokeS* , pstt1w ) ;
                                                    ZE( countT , idFormat ) ;
                                                {
                                                if( tProtocol.csF( tin0P ) )
                                                TN( tPassword , "" ) ;
                                                TN( tUser , "" ) ;
                                                ZE( boolT , bTls ) ;
                                                TN( tHelloMyName , "factory1@internal.ideafarm.com" ) ;
                                                TN( tHelloVerb   , "helo" ) ;

                                                }
                                                    etThread.delF( tin0P , psttServer ) ;
                                                    /**/etThread.traceF( tin0P , T("[psttServer,hidServer,tProtocol]:    ")+T(psttServer)+T("    ")+T(hidServer)+T("    ")+tProtocol ) ;

                                                    }
                                                        tProtocol = T(psttzProtocol) ;
                                                        strokeS* psttzProtocol = (strokeS*)(countT&)swProtocol ;
                                                        psttzLeverProtocol = psttServer ;
                                                    {
                                                    else if( swProtocol.idSlotOfLeverF( tin0P , (countT)psttServer ) )
                                                    }
                                                        /**/etThread.traceF( tin0P , T("override [tProtocol]: ")+tProtocol ) ;
                                                        tProtocol = tProtocolOverride ;
                                                    {
                                                    if( tProtocolOverride.csF( tin0P ) )

                                                    hidServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , psttServer ) ;

                                                    }
                                                        break ;
                                                        etThread.delF( tin0P , psttServer ) ;
                                                        /**/etThread.traceF( tin0P , T("unauthorized smtp relay server: ")+T(psttServer) ) ;
                                                        flagsFail |= flFAIL_UNAUTHORIZEDrELAYsERVER ;
                                                        POOPR
                                                    {
                                                    if( POOP )
                                                    __Z( bOk ) ;

                                                    }
                                                        }
                                                            }
                                                                break ;
                                                                /**/etThread.traceF( tin0P , T("authorized [psttServer]: ")+T(psttServer) ) ;
                                                                bOk = 1 ;
                                                            {
                                                            if( !etThread.strCompareF( tin0P , psttc1 , psttServer ) )
                                                        {
                                                        FORsTRINGSiN1( psttz1 )
                                                        strokeS* psttz1 = t1ListSmtpRelayServers ;
                                                    {
                                                    ZE( boolT , bOk ) ;

                                                    /**/etThread.traceF( tin0P , T("[psttServer]: ")+T(psttServer) ) ;

                                                    etThread.delF( tin0P , psttMxExclude ) ;
                                                    etThread.delF( tin0P , psttRelayServer ) ;
                                                    }
                                                        etThread.delF( tin0P , psttMxName ) ;
                                                        else                                                                                                                               { ((tin1S&)tin0P).pEtScratch->strMakeF(     tin0P , LF , psttServer , psttRelayServer                   ) ; ___( psttServer ) ; }
                                                        if( !psttRelayServer || !psttRelayServer->idAdam || ( psttMxExclude && !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttMxExclude , psttMxName ) ) ) { ((tin1S&)tin0P).pEtScratch->dnsNicNamesF( tin0P , psttServer , psttMxName , ifcIDtYPEdNSqUERY_MX ) ; ___( psttServer ) ; }

                                                        ((tin1S&)tin0P).pEtScratch->strWordF( tin0P , psttMxName , psttr , sttq , strokeS('@') , -1 ) ; ___( psttMxName ) ;
                                                        strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                                        ZE( strokeS* , psttMxName ) ;
                                                    {
                                                    ZE( strokeS* , psttServer ) ;

                                                    }
                                                        //CONoUTrAW( T("mx exclude  : \"")+T(psttMxExclude)+T("\"\r\n") ) ;
                                                        //CONoUTrAW( T("relay server: \"")+T(psttRelayServer)+T("\"\r\n") ) ;
                                                        //etThread.delF( tin0P , psttSetting ) ;
                                                        //}
                                                        //    etThread.delF( tin0P , pstt1l ) ;
                                                        //    }
                                                        //        else break ;
                                                        //        else if( !psttMxExclude   ) { ((tin1S&)tin0P).pEtScratch->strMakeF( tin0P , LF , psttMxExclude   , tIfoName ) ; ___( psttMxExclude   ) ; }
                                                        //             if( !psttRelayServer ) { ((tin1S&)tin0P).pEtScratch->strMakeF( tin0P , LF , psttRelayServer , tIfoName ) ; ___( psttRelayServer ) ; }
                                                        //    {
                                                        //    FORsTRINGSiN1( pstt1l )
                                                        //    ((tin1S&)tin0P).pEtScratch->strWordsOldF( tin0P , pstt1l , psttSetting , sttq , T("\r\n") ) ; ___( pstt1l ) ;
                                                        //    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                                        //    ZE( strokeS* , pstt1l ) ;
                                                        //{
                                                        //if( psttSetting )
                                                        //((tin1S&)tin0P).pEtScratch->boxGetShadow::20141115@1937::MIGRATE:TO:USE:SETTINGS.BIT.TREE::SettingF( tin0P , psttSetting , T("///d/ideafarm.home.")+TF1(etherC::ifc_idHomeIdisk_IF())+T(".setting.keyValue.smtprelay") ) ; ___( psttSetting ) ;
                                                        //U:: 20190728@1932:  REWRITE TO USE A SETTING RATHER THAN HARDCODE

                                                        ((tin1S&)tin0P).pEtScratch->strMakeF( tin0P , LF , psttRelayServer , psttHost ) ; ___( psttRelayServer ) ;

                                                        ZE( strokeS* , psttSetting ) ;
                                                    {
                                                    ZE( strokeS* , psttMxExclude ) ;
                                                    ZE( strokeS* , psttRelayServer ) ;
                                                {
                                                TN( tProtocol , "" ) ;
                                                nicNameC hidServer ;

                                                socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL | flSOCKETc_CRYPTfOREIGNsSLdEFERhANDSHAKE , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

                                                countT idleTimeAllowedWrite = TICK << 4 ;
                                                countT idleTimeAllowedRead  = TICK << 4 ;
                                                countT timeAllowedConnected = TICK << 4 ;   // WO IFC HOUR (ABOUT 90_9 FOREIGN MINUTES)

                                                //countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                //countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                //countT timeAllowedConnected = TICK >> 2 ;
                                                //THESE TIMEOUTS DON'T WORK WHEN THE EMAIL IS LARGE (DUE TO ATTACHMENTS)

                                                //countT idleTimeAllowedWrite = TOCK * 0x10 ;
                                                //countT idleTimeAllowedRead  = TOCK * 0x10 ;

                                                }
                                                    ((tin1S&)tin0P).pEtScratch->strFuseF( tin0P , psttBccLine , T(">\r\n") ) ;
                                                    ((tin1S&)tin0P).pEtScratch->strFuseF( tin0P , psttBccLine , psttr ) ;
                                                    ((tin1S&)tin0P).pEtScratch->strFuseF( tin0P , psttBccLine , T("Bcc" ": <") , 0 , 0 , strokeS() , 0 , 0 , /*U::SOUL?*/ 3 + psttr->idAdam ) ; ___( psttBccLine ) ;
                                                {
                                                if( offs == 2 )

                                                }
                                                    while( ~hWalk ) ;
                                                    }
                                                        }
                                                            break ;
                                                            bIncoming = 1 ;
                                                        {
                                                        if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttr , psttw ) )
                                                        strokeS* psttw = (strokeS*)pStkEmailRelay->downF( tin0P , hWalk ) ;
                                                    {
                                                    do
                                                    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                {
                                                if( *pStkEmailRelay )
                                                ZE( boolT , bIncoming ) ;

                                                SCOOPS
                                            {
                                            IFsCRATCHoK
                                            ZE( strokeS* , psttBccLine ) ;

                                            /**/etThread.traceF( tin0P , T("beginning of recipient \"")+T(psttr)+T("\"") ) ;
                                            strokeS* psttr = (strokeS*)ppzStk[ offs ]->downF( tin0P , hWalk ) ;
                                        {
                                        do
                                        handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    if( *ppzStk[ offs ] )
                                    /**/etThread.traceF( tin0P , T("beginning of handling ")+TF2(*ppzStk[offs],flFORMAT_NObIGITvALUES)+T(" recipients for list ")+TF2(offs,flFORMAT_NObIGITvALUES) ) ;
                                {
                                for( countT offs = 0 ; offs < 3 && !flagsFail ; offs ++ )
                                stackC* ppzStk[] = { &stTo , &stCc , &stBc } ;
                                _IO_
                            {
                            if( !( F(flagsFail) & flFAIL_DURINGpARSING ) )

                            }
                                }
                                    flagsFail |= flFAIL_DURINGpARSING ;
                                    POOPR
                                {
                                if( POOP )

                                }
                                    etThread.delF( tin0P , psttFrToCc ) ;
                                    *pptFrToCc[ offc ] = T(psttFrToCc) ;

                                    }
                                        }
                                            }
                                                while( ~hWalk ) ;
                                                }
                                                    ((tin1S&)tin0P).pEtScratch->strFuseF( tin0P , psttFrToCc , T(">\r\n") ) ;
                                                    ((tin1S&)tin0P).pEtScratch->strFuseF( tin0P , psttFrToCc , psttw ) ;
                                                    ((tin1S&)tin0P).pEtScratch->strFuseF( tin0P , psttFrToCc , T(!off?"To: <":"Cc" ": <") ) ;
                                                    strokeS* psttw = (strokeS*)ppzStk[ off ]->downF( tin0P , hWalk ) ;
                                                {
                                                do
                                                handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            {
                                            if( *ppzStk[ off ] )
                                        {
                                        for( countT off = 0 ; off < 2 ; off ++ )
                                        stackC* ppzStk[] = { &stTo , &stCc } ;
                                    {

                                    ((tin1S&)tin0P).pEtScratch->strFuseF( tin0P , psttFrToCc , T(">\r\n") ) ;
                                    ((tin1S&)tin0P).pEtScratch->strFuseF( tin0P , psttFrToCc , psttFrom ) ;
                                    ((tin1S&)tin0P).pEtScratch->strFuseF( tin0P , psttFrToCc , T("<") ) ;
                                    if( csttName ) ((tin1S&)tin0P).pEtScratch->strFuseF( tin0P , psttFrToCc , T("\"")+tName+T("\" ") ) ;
                                    ((tin1S&)tin0P).pEtScratch->strFuseF( tin0P , psttFrToCc , T("From: ") ) ;
                                    ((tin1S&)tin0P).pEtScratch->strMakeF( tin0P , LF , psttFrToCc , 0 , cstta ) ; ___( psttFrToCc ) ;

                                    const countT cstta = csttFrToCc + cFrToCcLines * 0x10 + csttName ; //0x10 IS MORE THAN NEEDED (0xa)

                                    const countT csttName = !tName.csF( tin0P ) ? 0 : tName.csF( tin0P ) + 3 ;
                                    textC& tName = !offc ? tNameOut : tNameIn ;

                                    ZE( strokeS* , psttFrToCc ) ;
                                {
                                for( countT offc = 0 ; offc <= 1 ; offc ++ )
                                textC* pptFrToCc[] = { &tFrToCcOutgoing , &tFrToCcIncoming } ;

                                //}
                                //    ((tin1S&)tin0P).pEtScratch->strMakeF( tin0P , LF , psttFrom , T("hello@ideafarm.com") ) ; ___( psttFrom ) ;
                                //    ((tin1S&)tin0P).pEtScratch->delF( tin0P , psttFrom ) ;
                                //{
                                //if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttFrom , T(ifcEMAIL_HELLO) ) )
                                //SUPPORT FOR hello@ideafarm.com COMMENTED OUT DUE TO DECISION TO NOT PROVIDE ANY FUNCTIONALITY TO ANONYMOUS INTERNET USERS
                                //CS:CODEsYNC: b750104 3a50104
                                //MAPPING GLOBAL ALIASES

                                SCOOPS
                                _IO_
                            {
                            IFsCRATCHoK
                            TN( tFrToCcIncoming , "" ) ;
                            TN( tFrToCcOutgoing , "" ) ;

                            }
                                }
                                    }
                                        }
                                            *pStkEmailRelay << psttw ;
                                            *info.pStkEmailRelay >> psttw ; ___( psttw ) ;
                                            ZE( strokeS* , psttw ) ;
                                        {
                                        if( info.pStkEmailRelay ) while( *info.pStkEmailRelay )

                                        tNameOut = T(info.psttNameOut) ;
                                        tNameIn  = T(info.psttNameIn) ;

                                        subaccountS info( tin0P , etThread , cPassAccount , cPassSubaccount , flSUBACCOUNT_QUERYeMAILrELAY | flSUBACCOUNT_QUERYnAMEiN | flSUBACCOUNT_QUERYnAMEoUT ) ;
                                    {

                                    }
                                        etThread.delF( tin0P , psttw ) ;
                                        tEmailOwner = T(psttw) ;
                                        queryEmailFromIdAccountF( tin0P , psttw , cPassAccount ) ; ___( psttw ) ;
                                        ZE( strokeS* , psttw ) ;
                                    {
                                {
                                if( cPassAccount && cPassSubaccount )

                                }
                                    etThread.delF( tin0P , psttw ) ;
                                    }
                                        etThread.delF( tin0P , pstt1w ) ;
                                        }
                                            }
                                                }
                                                    break ;
                                                    }
                                                        }
                                                            if( idWord ++ == 4 ) break ;

                                                            else { __( ((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , psttc2 , T("doubleblind") ) ) ; }
                                                            }
                                                                if( pco ) *pco = ((tin1S&)tin0P).pEtScratch->strDigitsToSCountF( tin0P , psttc2 , 36 ) ;

                                                                }
                                                                    case 3 : { pco = &cPassAccount    ; break ; }
                                                                    case 2 : { pco = &cPassSubaccount ; break ; }
                                                                {
                                                                switch( idWord )
                                                                ZE( countT* , pco ) ;

                                                                }
                                                                    break ;
                                                                    POOPR
                                                                {
                                                                if( POOP )
                                                                __( !((tin1S&)tin0P).pEtScratch->strIsDigitsF( tin0P , psttc2 , 36 ) ) ;                           // REJECT IF NOT ALL DIGITS
                                                            {
                                                            if( idWord <= 3 )
                                                        {
                                                        FORsTRINGSiN2( pstt1w )

                                                        countT idWord = 6 - cWords ; // 1 OR 2
                                                    {
                                                    else
                                                    if( POOP ) POOPR

                                                    __( cWords > 5 ) ;
                                                    __( cWords < 4 ) ;
                                                {
                                                case 1 : // [idItem].fdee86.trswwh1.doubleblind.1
                                            {
                                            switch( idFormat )

                                            }
                                                if( BlATHsTRING1 ) idFormat = ((tin1S&)tin0P).pEtScratch->strDigitsToSCountF( tin0P , tIfoName , 36 ) ;
                                            {
                                            FORsTRINGSiN1( pstt1w )
                                        {
                                        if( pstt1w )
                                        const countT cWords = ((tin1S&)tin0P).pEtScratch->strWordsOldF( tin0P , pstt1w , psttw , sttq , T(".") ) ; ___( pstt1w ) ;
                                        ZE( strokeS* , pstt1w ) ;
                                    {
                                    else if( psttw && psttw->idAdam )
                                    if( POOP ) POOPR
                                    ((tin1S&)tin0P).pEtScratch->strSubstringF( tin0P , psttw , idf , sttq , S1C('@') , psttFrom ) ; ___( psttw ) ;
                                    countT idf = 1 ;
                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                    ZE( strokeS* , psttw ) ;

                                    SCOOPS
                                {
                                IFsCRATCHoK

                                ZE( countT , idFormat        ) ; // 4
                                ZE( countT , cPassAccount    ) ; // 3
                                ZE( countT , cPassSubaccount ) ; // 2
                            {
                            TN( tNameIn , "" ) ;
                            TN( tNameOut , "" ) ;
                            _IO_
                        {
                        if( pStkEmailRelay )
                        etThread( tin0P , pStkEmailRelay , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ; ___( pStkEmailRelay ) ;
                        ZE( stackC* , pStkEmailRelay ) ;
                        TN( tEmailOwner , "" ) ;
                        //PARSE psttFrom AND LOOKUP ACCOUNT OWNER NAME

                        ////else { //CONoUTrAW( "bad news, bro! psttFileBody is null or short\r\n" ) ; }
                        //}
                        //    //etThread.delF( tin0P , psttDump ) ;
                        //    //CONoUTrAW( T("****DUMPbEGIN\r\n")+T(psttDump)+T("\r\n****DUMPeND\r\n") ) ;
                        //    //etThread.strDumpIF( tin0P , psttDump , (byteT*)psttFileBody , sizeof( strokeS ) * ( CSpREFIX * 2 + 1 ) , flSTRdUMP_null , sizeof( strokeS ) , sizeof( countT ) ) ; ___( psttDump ) ;
                        //    //ZE( strokeS* , psttDump ) ;
                        //
                        //    //CONoUTrAW3( "ISsTRINGoFsTRINGS evaluates to " , ISsTRINGoFsTRINGS( psttFileBody ) , "\r\n" ) ;
                        //    //else                                                      { //CONoUTrAW( "STRING OF STRINGS? NO!\r\n" ) ; }
                        //    //if( psttFileBody[ CSpREFIX ].idCaste == sc_PREFIXlENGTH ) { //CONoUTrAW( "STRING OF STRINGS? yes\r\n" ) ; }
                        //{
                        //if( psttFileBody && psttFileBody->idAdam > CSpREFIX )

                        }
                            etThread.delF( tin0P , psttCmd ) ;
                            }
                                }
                                    etThread.traceF( tin0P , T("i will insert MIME headers.  The body must contain MIME sections delimited by \"IdeaFarmMimeBoundary\"") ) ;
                                    bMime = 1 ;
                                {
                                if( !etThread.strCompareF( tin0P , psttCmd , T("!mime") ) )
                            {
                            if( psttCmd )
                            sIn >> psttCmd ; ___( psttCmd ) ;
                            ZE( strokeS* , psttCmd ) ;
                            _IO_
                        {
                        else while( sIn )                                        //20251222@1836: ADDED TO SUPPORT OPTIONAL COMMANDS
                        if( !sIn ) etThread.traceF( tin0P , T("i will not insert MIME headers since no commands were pushed into the input soulC.") ) ;
                        ZE( boolT , bMime ) ;

                        sIn >> psttFileBody ; ___( psttFileBody ) ;
                        ZE( strokeS* , psttFileBody ) ;

                        }
                            }
                                }
                                    }
                                        *ppzStk[ off ] << psttw ; psttw = 0 ;
                                        if( off < 2 ) csttFrToCc += psttw->idAdam ;
                                    {
                                    if( psttw )
                                    }
                                        case 2 : { /*etThread.traceF( tin0P , T("Bc" ": \"")+T(psttw)+T("\"\r\n") ) ;*/ break ; }
                                        case 1 : { /*etThread.traceF( tin0P , T("Cc" ": \"")+T(psttw)+T("\"\r\n") ) ;*/ break ; }
                                        case 0 : { /*etThread.traceF( tin0P , T("To: \"")   +T(psttw)+T("\"\r\n") ) ;*/ break ; }
                                    {
                                    switch( off )
                                    sIn >> psttw ; ___( psttw ) ;
                                    ZE( strokeS* , psttw ) ;
                                {
                                while( cPlates -- )
                                if( off < 2 ) cFrToCcLines += cPlates ;
                                sIn >> cPlates ;
                                ZE( countT , cPlates ) ;
                            {
                            for( countT off = 0 ; off < 3 ; off ++ )
                            stackC* ppzStk[] = { &stTo , &stCc , &stBc } ;
                            _IO_
                        {
                        countT csttFrToCc = psttFrom->idAdam ;
                        countT cFrToCcLines = 1 ;

                        sIn >> psttFrom ; ___( psttFrom ) ;
                        ZE( strokeS* , psttFrom ) ;

                        etThread.delF( tin0P , psttProtocolName ) ;
                        }
                            etThread.delF( tin0P , pstti ) ;
                            }
                                tProtocolOverride = T(pstti) ;
                                /**/etThread.traceF( tin0P , T("protocol override [server, name, protocol]: ")+T(psttHost)+T("    ")+T(psttProtocolName)+T("    ")+T(pstti) ) ;
                            {
                            else
                            if( !pstti || !pstti->idAdam ) /*;*/etThread.traceF( tin0P , T("not found [tKey]: ")+tKey ) ;
                            etThread.querySettingF( tin0P , pstti , tKey  ) ; ___( pstti ) ;
                            /**/etThread.traceF( tin0P , T("query override protocol [tKey]: ")+tKey ) ;
                            TN( tKey , "" ) ; tKey = T("!ipdos.smtp.relay..")+T(psttHost)+T("..")+T(psttProtocolName) ;
                            ZE( strokeS* , pstti ) ;
                            _IO_
                        {
                        if( psttProtocolName && psttProtocolName->idAdam )
                        TN( tProtocolOverride , "" ) ;

                        }
                            /**/etThread.traceF( tin0P , T("after parsing [psttProtocolName]: ")+T(psttProtocolName) ) ;
                            /**/etThread.traceF( tin0P , T("after parsing [psttHost]: ")+T(psttHost) ) ;
                            etThread.delF( tin0P , pstt1w ) ;
                            }
                                }
                                    break ;
                                    etThread.strMakeF( tin0P , LF , psttProtocolName , psttc1 ) ; ___( psttProtocolName ) ;
                                {
                                else
                                if( !psttHost ) { etThread.strMakeF( tin0P , LF , psttHost , psttc1 ) ; ___( psttHost ) ; }
                            {
                            FORsTRINGSiN1( pstt1w )
                            etThread.delF( tin0P , psttHost ) ;
                            etThread.strWordsF( tin0P , pstt1w , psttHost , sttq , T("[]") ) ; ___( pstt1w ) ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                            ZE( strokeS* , pstt1w ) ;
                            /**/etThread.traceF( tin0P , T("parsing [psttHost]: ")+T(psttHost) ) ;
                        {
                        ZE( strokeS* , psttProtocolName ) ;

                        sIn >> idPort ;
                        ZE( countT , idPort ) ;

                        sIn >> psttHost ; ___( psttHost ) ;
                        ZE( strokeS* , psttHost ) ;
                        _IO_
                    {
                    if( !( F(flagsFail) & flFAIL_COULDnOTgETsHADOW ) )
                    ZE( boolT , bFailPermanent ) ;

                    }
                        }
                            etThread.traceF( tin0P , T("!exception / ")+TT(timeN1,timeN2)+T(" | could not get shadow of ")+T((strokeS*)tIfoName)+T(": ") ) ;
                            flagsFail |= flFAIL_COULDnOTgETsHADOW ;
                            POOPR ;
                        {
                        if( POOP )
                        ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , sIn , tIfoName ) ;
                        SCOOPS
                    {
                    IFsCRATCHoK
                    soulC sIn( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
                    IFsCRATCHoK{}

                    ZE( flagsT , flagsFail ) ;
                    /**/etThread.traceF( tin0P , TT(timeN1,timeN2)+T(" | mailing out ")+T((strokeS*)tIfoName)+T(": ") ) ;

                    /**/etThread.traceF( tin0P , tShort ) ;

                    }
                        etThread.delF( tin0P , psttShort ) ;
                        tShort = T(psttShort) ;
                        etThread.delF( tin0P , psttnu ) ;
                        etThread.strBisectF( tin0P , psttnu , psttShort , tIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShort , "" ) ;

                    TN( tIfoName , pInfo->psttIfoName ) ;
                {
                if( !bDir )

                const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
                _IO_
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirF( tin0P , pInfo , hFind , tToSend ) ;
            ZE( infoFileS* , pInfo ) ;
            _IO_
        {
        do
        handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

        }
            while( !ether && ~hFind && !POOP ) ;
            }
                DEL( pInfo ) ;
                }
                    }
                        /**/etThread.traceF( tin0P , tShort ) ;
                        etThread.diskMoveFileOrDirF( tin0P , tToSend+tShort , pInfo->psttIfoName ) ;

                        }
                            etThread.delF( tin0P , psttShort ) ;
                            tShort = T(psttShort) ;
                            etThread.delF( tin0P , psttnu ) ;
                            etThread.strBisectF( tin0P , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShort , "" ) ;
                    {
                    if( !bDir )

                    const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;

                    //TN( tIfoName , pInfo->psttIfoName ) ;
                {
                else
                }
                    break ;
                    DEL( pInfo ) ;
                {
                if( !pInfo || !pInfo->psttIfoName )

                etThread.diskFindFileOrDirF( tin0P , pInfo , hFind , tNotSent ) ;
                ZE( infoFileS* , pInfo ) ;
                _IO_
            {
            do
            handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

            }
                }
                    }
                        etThread.delF( tin0P , pstti ) ;
                        }
                            psttProtocol = pstti ; pstti = 0 ;
                            strokeS*& psttProtocol = (strokeS*&)(countT&)swProtocol ;
                            psttzLeverProtocol = (strokeS*)psttc1 ;

                            //etThread.trace F( tin0P , T("protocol [server, protocol]: ")+T(psttc1)+T("    ")+T(pstti) ) ;
                        {
                        if( pstti && pstti->idAdam )
                        etThread.querySettingF( tin0P , pstti , T("!ipdos.smtp.relay..")+T(psttc1)  ) ; ___( pstti ) ;
                        ZE( strokeS* , pstti ) ;

                        //etThread.trace F( tin0P , T("[authorized smtp relay server]: ")+T(psttc1) ) ;
                    {
                    FORsTRINGSiN1( psttz1 )
                    strokeS* psttz1 = t1ListSmtpRelayServers ;
                {
                if( t1ListSmtpRelayServers.csF( tin0P ) )
                etThread.delF( tin0P , pstt1i ) ;
                }
                    etThread.delF( tin0P , pstti ) ;
                    }
                        t1ListSmtpRelayServers = T(pstt1i) ;
                        etThread.strWordsF( tin0P , pstt1i , pstti , sttq , T("/") ) ; ___( pstt1i ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    {
                    if( pstti && pstti->idAdam )
                    etThread.querySettingF( tin0P , pstti , T("!ipdos.smtp.relays")  ) ; ___( pstti ) ;
                    ZE( strokeS* , pstti ) ;
                {
                ZE( strokeS* , pstt1i ) ;
                _IO_
            {

            }
                }
                    swProtocol.freeAllF( tin0P ) ;
                    }
                        etThread.delF( tin0P , psttProtocol ) ;
                        strokeS*& psttProtocol = (strokeS*&)(countT&)swProtocol ;
                        psttzLeverProtocol = (strokeS*)swProtocol.leverF( tin0P , idf ) ;
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                {
                countT cFlavors = swProtocol.cFlavorsF( tin0P ) ;
                _IO_
            {

            timeL2 = timeN2 ;
            timeL1 = timeN1 ;
            _IO_
        {
        if( timeE2 || timeE1 > TICK )

        etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeL1 , timeL2 ) ;
        sCountT timeE2 = timeN2 ;
        countT  timeE1 = timeN1 ;

        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;
        _IO_
    {
    while( !ether && !etThread )
    switchC swProtocol( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverProtocol ) ;
    ZE( strokeS* , psttzLeverProtocol ) ;
    TN( t1ListSmtpRelayServers , "" ) ;
    ZE( sCountT , timeL2 ) ;
    ZE( countT  , timeL1 ) ;
    TN( tLeadingDoubleDot , "\r\n.." ) ;
    TN( tLeadingDot , "\r\n." ) ;
    TN( tDotRN , ".\r\n" ) ;
    stackC stBc( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stCc( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC stTo( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    strokeS sSlash( '/' , sc_cFROMaSCII ) ;
    TN( tSlash , "/" ) ;
    TN( tStar , "*" ) ;
    //20190728@2139: COMMENTED OUT TO PUT THIS ADAM BACK INTO SERVICE WITHOUT OTHER LEGACY ADAMS:  etThread.osThreadAdamF( tin0P , ifcIDaDAM_ROOTfORMdATAeATER ) ;

    etThread.diskMakeDirIfNeededF( tin0P , tNotSentAbandoned ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tNotSent ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tSent ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tToSend ) ;

    TN( tNotSentAbandoned , "" ) ; tNotSentAbandoned = T("///ideafarm/ephemeral/ipdos/email.notsentabandoned/") ;
    TN( tNotSent          , "" ) ; tNotSent          = T("///ideafarm/ephemeral/ipdos/email.notsent/") ;
    TN( tSent             , "" ) ; tSent             = T("///ideafarm/ephemeral/ipdos/email.sent/") ;
    TN( tToSend           , "" ) ; tToSend           = T("///ideafarm/ephemeral/ipdos/email.to.send/") ;

    const countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;

    ether.osSleepF( tin0P , TIMEnAPdURINGsERVICEsTARTUP ) ;

    }
        //}
        //    ++ s ; ether.osSleepF( tin0P , TOCK * 0x10 ) ; //TO AVOID LOADING SERVER DURING SYSTEM GEN
        //    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        //{

        //#endif

    //#endif
        }
            ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , bProcessAccessLogs ? ifcIDaDAM_ACCESSeVENTS2bOOKtOGETHER : ifcIDaDAM_CLOUD , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; // flHIRE_DISPLAYaUTO CAN BE COMMENTED OUT TO AVOID WDW FOR ROOT CLOUD INSTANCE WHICH IS USUALLY NOT INTERESTING

            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bProcessAccessLogs]:    ")+TF2(bProcessAccessLogs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttProcessAccessLogs ) ;
        //        bProcessAccessLogs = psttProcessAccessLogs && !etThread.strCompareF( tin0P , psttProcessAccessLogs , T("yes") ) ;
                ZE( strokeS* , psttProcessAccessLogs ) ; etThread.querySettingF( tin0P , psttProcessAccessLogs , T("!ipdos.process.access.logs")  ) ; ___( psttProcessAccessLogs ) ;
            {
            ZE( boolT , bProcessAccessLogs ) ;
            _IO_
        {
    //#if defined( NEVERdEFINED )
    //U:: ENABLE IN PRODUCTION (THIS WORKS BUT IS DISABLED TO FIND AN UNRELATED BUG)

        //#endif

        //etThread.trace F( tin0P , T("debug 0") ) ;

        }
            }
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_ROOThEAL ;
                ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_HEALaRCHIVES , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                /**/etThread.traceF( tin0P , T("ROOTmAILoUT: hiring ifcIDaDAM_HEALaRCHIVES") ) ;
            {
            else
            if( bNoHeal ) /*;*/etThread.traceF( tin0P , T("ROOTmAILoUT: NOT hiring ifcIDaDAM_HEALaRCHIVES") ) ;

            //20240325@1619: HEALaRCHIVES IS ALWAYS LAUNCHED, AS MARKETING POLICY ("BARTERWARE")
            //20240320@2127: TO WORK AROUND A BUG, HEALaRCHIVES IS ONLY LAUNCHED WHEN EXPLICITLY COMMANDED
            //20221229@1429: HEALaRCHIVES IS ALWAYS LAUNCHED, AS MARKETING POLICY ("BARTERWARE")

            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bNoHeal]:    ")+TF2(bNoHeal,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttHeal ) ;
                bNoHeal = psttHeal && !etThread.strCompareF( tin0P , psttHeal , T("no") ) ;
                //((tin1S&)tin0P).pc Utility[ 0 ] -- ; //U::
                ZE( strokeS* , psttHeal ) ; etThread.querySettingF( tin0P , psttHeal , T("!ipdos.heal")  ) ; ___( psttHeal ) ;
                //((tin1S&)tin0P).pc Utility[ 0 ] ++ ; //U::
            {
            ZE( boolT , bNoHeal ) ;

            //etThread.trace F( tin0P , T("debug 1") ) ;
            _IO_
        {

        //#if defined( NEVERdEFINED )

        //etThread.trace F( tin0P , T("debug 2") ) ;

        }
            if( bServeSmtp ) ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_ROOTsMTPsERVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bServeSmtp]:    ")+TF2(bServeSmtp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            //20190730@0808: MOVED TO HERE BUT NOT TESTED.  IDEAFARM.COM CURRENTLY USES GOOGLE.COM'S SMTP SERVER TO RELAY OUTGOING EMAIL

            }
                etThread.delF( tin0P , psttServeSmtp ) ;
                bServeSmtp = psttServeSmtp && !etThread.strCompareF( tin0P , psttServeSmtp , T("yes") ) ;
                ZE( strokeS* , psttServeSmtp ) ; etThread.querySettingF( tin0P , psttServeSmtp , T("!ipdos.serve.smtp")  ) ; ___( psttServeSmtp ) ;
            {
            ZE( boolT , bServeSmtp ) ;
            _IO_
        {

        //etThread.trace F( tin0P , T("debug 3") ) ;

        }
            }
                //U::homeS::homeIF().flagsAdams |= flHOMEsaDAMS_ROOTbANG ;

                //U::ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_GORILLAbANG , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                //U::ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_3BANG , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            {
            if( !bNoServeBang )
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bNoServeBang]:    ")+TF2(bNoServeBang,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttServeBang ) ;
                bNoServeBang = psttServeBang && !etThread.strCompareF( tin0P , psttServeBang , T("no") ) ;
                ZE( strokeS* , psttServeBang ) ; etThread.querySettingF( tin0P , psttServeBang , T("!ipdos.serve.bang")  ) ; ___( psttServeBang ) ;
            {
            ZE( boolT , bNoServeBang ) ;
            _IO_
        {

        //etThread.trace F( tin0P , T("debug 4") ) ;

        }
            }
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_RDPoPENhOUSE ;
                ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_REMOTEdESKTOPoPENhOUSE , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            {
            if( tPass.csF( tin0P ) )
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bRdpOpenHouse]:    ")+T(tPass.csF(tin0P)?"yes":"no") ) ;

            }
                etThread.delF( tin0P , psttPass ) ;
                if( psttPass && psttPass->idAdam ) tPass = T(psttPass) ;
                ZE( strokeS* , psttPass ) ; etThread.querySettingF( tin0P , psttPass , T("!ipdos.barracuda.firewall.credentials64")  ) ; ___( psttPass ) ;
            {
            TN( tPass , "" ) ;
            _IO_
        {

        //etThread.trace F( tin0P , T("debug 5") ) ;

    #endif
        }
            }
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_UDPfILEcATCHER ;
                ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_UDPfILErECEIVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_UDPfILEcATCHER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            {
            if( bCatchUdpFiles )
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bCatchUdpFiles]:    ")+TF2(bCatchUdpFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttCatchUdpFiles ) ;
                bCatchUdpFiles = !psttCatchUdpFiles || etThread.strCompareF( tin0P , psttCatchUdpFiles , T("no") ) ;
                ZE( strokeS* , psttCatchUdpFiles ) ; etThread.querySettingF( tin0P , psttCatchUdpFiles , T("!ipdos.catch.udp.files")  ) ; ___( psttCatchUdpFiles ) ;
            {
            ZE( boolT , bCatchUdpFiles ) ;
            _IO_
        {
    #if defined( NEVERdEFINED )

        //etThread.trace F( tin0P , T("debug 6") ) ;

        }
            }
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_ICISbOT ;

                ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_ICISbOT , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            {
            if( bICISBot )
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bICISBot]:    ")+TF2(bICISBot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttBot ) ;
                bICISBot = psttBot && !etThread.strCompareF( tin0P , psttBot , T("yes") ) ;
                ZE( strokeS* , psttBot ) ; etThread.querySettingF( tin0P , psttBot , T("!ipdos.icis.bot")  ) ; ___( psttBot ) ;
            {
            ZE( boolT , bICISBot ) ;
            _IO_
        {

        }
            }
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_WELCOMER ;

                ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_WELCOMER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            {
            if( bWelcomer )
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bWelcomer]:    ")+TF2(bWelcomer,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttEat ) ;
                bWelcomer = psttEat && !etThread.strCompareF( tin0P , psttEat , T("yes") ) ;
                ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.hire.welcomer")  ) ; ___( psttEat ) ;
            {
            ZE( boolT , bWelcomer ) ;
            _IO_
        {

        }
            }
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_DNS ;

                ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_DNS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            {
            if( bDns )
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bDns]:    ")+TF2(bDns,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttEat ) ;
                bDns = psttEat && !etThread.strCompareF( tin0P , psttEat , T("yes") ) ;
                ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.hire.dns")  ) ; ___( psttEat ) ;
            {
            ZE( boolT , bDns ) ;
            _IO_
        {

        }
            }
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_ADMINISTRATOR ;

                ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_ADMINISTRATOR , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            {
            if( bAdministrator )
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bAdministrator]:    ")+TF2(bAdministrator,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttEat ) ;
                bAdministrator = psttEat && !etThread.strCompareF( tin0P , psttEat , T("yes") ) ;
                ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.hire.administrator")  ) ; ___( psttEat ) ;
            {
            ZE( boolT , bAdministrator ) ;
            _IO_
        {

        }
            }
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_FILEwEBHOOKnOTICES ;

                ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_WEBhOOKnOTICEfILER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            {
            if( bFileWebhookNotices )
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bFileWebhookNotices]:    ")+TF2(bFileWebhookNotices,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttEat ) ;
                bFileWebhookNotices = psttEat && !etThread.strCompareF( tin0P , psttEat , T("yes") ) ;
                ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.file.webhook.notices")  ) ; ___( psttEat ) ;
            {
            ZE( boolT , bFileWebhookNotices ) ;
            _IO_
        {

        }
            //etThread.trace F( tin0P , T("debug 6.0") ) ;
            }
                //etThread.trace F( tin0P , T("debug 6.1") ) ;
                homeS::homeIF().flagsAdams |= flHOMEsaDAMS_ROOThTTPsERVER ;
                //etThread.trace F( tin0P , T("debug 6.2") ) ;
                ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_ROOThTTPsERVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                //etThread.trace F( tin0P , T("debug 6.3") ) ;
                _IO_
            {
            if( bServeHttp )
            //etThread.trace F( tin0P , T("debug 6.4") ) ;
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bServeHttp]:    ")+TF2(bServeHttp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                //etThread.trace F( tin0P , T("debug 6.5") ) ;
                etThread.delF( tin0P , psttServeHttp ) ;
                //etThread.trace F( tin0P , T("debug 6.6") ) ;
                bServeHttp = psttServeHttp && !etThread.strCompareF( tin0P , psttServeHttp , T("yes") ) ;
                //etThread.trace F( tin0P , T("debug 6.7") ) ;
                //((tin1S&)tin0P).pc Utility[ 0 ] -- ; //U::
                ZE( strokeS* , psttServeHttp ) ; etThread.querySettingF( tin0P , psttServeHttp , T("!ipdos.serve.http")  ) ; ___( psttServeHttp ) ;
                //((tin1S&)tin0P).pc Utility[ 0 ] ++ ; //U::
                //etThread.trace F( tin0P , T("debug 6.8") ) ;
                _IO_
            {
            //etThread.trace F( tin0P , T("debug 6.9") ) ;
            ZE( boolT , bServeHttp ) ;
            //etThread.trace F( tin0P , T("debug 6.a") ) ;
            _IO_
        {

        //etThread.trace F( tin0P , T("debug 7") ) ;

        #endif

        }
            if( bGorillaHttpReporter ) ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_GORILLAhTTPiDEAFARMcOMrEPORTER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bGorillaHttpReporter]:    ")+TF2(bGorillaHttpReporter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttGorillaHttpReporter ) ;
                bGorillaHttpReporter = psttGorillaHttpReporter && !etThread.strCompareF( tin0P , psttGorillaHttpReporter , T("yes") ) ;
                ZE( strokeS* , psttGorillaHttpReporter ) ; etThread.querySettingF( tin0P , psttGorillaHttpReporter , T("!ipdos.gorilla.http.reporter")  ) ; ___( psttGorillaHttpReporter ) ;
            {
            ZE( boolT , bGorillaHttpReporter ) ;
            _IO_
        {

        //etThread.trace F( tin0P , T("debug 8") ) ;

        }
            if( bGorillaHttp ) ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_GORILLAhTTPiDEAFARMcOM , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bGorillaHttp]:    ")+TF2(bGorillaHttp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttGorillaHttp ) ;
                bGorillaHttp = psttGorillaHttp && !etThread.strCompareF( tin0P , psttGorillaHttp , T("yes") ) ;
                ZE( strokeS* , psttGorillaHttp ) ; etThread.querySettingF( tin0P , psttGorillaHttp , T("!ipdos.gorilla.http")  ) ; ___( psttGorillaHttp ) ;
            {
            ZE( boolT , bGorillaHttp ) ;
            _IO_
        {

        #if defined( NEVERdEFINED )

        }
            if( bHire ) ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_QUERYsTRIPEeVENTS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bHire]:    ")+TF2(bHire,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttv ) ;
                bHire = psttv && !etThread.strCompareF( tin0P , psttv , T("yes") ) ;
                ZE( strokeS* , psttv ) ; etThread.querySettingF( tin0P , psttv , T("!ipdos.query.stripe.events")  ) ; ___( psttv ) ;
            {
            ZE( boolT , bHire ) ;
            _IO_
        {

        }
            if( bGorillaWebhooks ) ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_GORILLAwEBHOOKS , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bGorillaWebhooks]:    ")+TF2(bGorillaWebhooks,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                etThread.delF( tin0P , psttGorillaWebhooks ) ;
                bGorillaWebhooks = psttGorillaWebhooks && !etThread.strCompareF( tin0P , psttGorillaWebhooks , T("yes") ) ;
                ZE( strokeS* , psttGorillaWebhooks ) ; etThread.querySettingF( tin0P , psttGorillaWebhooks , T("!ipdos.gorilla.webhooks")  ) ; ___( psttGorillaWebhooks ) ;
            {
            ZE( boolT , bGorillaWebhooks ) ;
            _IO_
        {

        }
            if( bDo ) ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_IDEAnETiPV6 , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            /**/etThread.traceF( tin0P , T("ROOTmAILoUT: [bDo]:    ")+TF2(bDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        
            }
                etThread.delF( tin0P , psttDo ) ;
                bDo = psttDo && !etThread.strCompareF( tin0P , psttDo , T("yes") ) ;
                ZE( strokeS* , psttDo ) ; etThread.querySettingF( tin0P , psttDo , T("!ipdos.random.ipv6.ideanet")  ) ; ___( psttDo ) ;
            {
            ZE( boolT , bDo ) ;
        {

        //ether.ifcHireF( tin0P , T("ifcIDaDAM_ROOTmAILoUT") , ifcIDaDAM_UDPeCHO , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
        /**/etThread.traceF( tin0P , T("ROOTmAILoUT: hiring ifcIDaDAM_UDPeCHO") ) ;
        //U::20230611@1304: DISABLED TO UNCLUTTER STFU TRACE FILE.  UDPeCHO WORKS AND CAN BE ENABLED HERE FOR FURTHER TESTING AND DEVELOPMENT

        //etThread.trace F( tin0P , T("debug 9") ) ;
        _IO_
    {
    if( !bSandbox )
    //etThread.trace F( tin0P , T("debug [bSandbox]:    ")+TF2(bSandbox,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    //bSandbox = 0 ;
    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE    ) ;
    thirdC::dosPriorityProcessIF(      tin0P , ifcTHREADpRIORITY_LAZIEST ) ;
    _IO_
{
if( pTaskP )
TASK( tmWorkF )

}
    return bFail ;
    }
        }
            }
                DEL( pInfo ) ;
                }
                    }
                        etherP.delF( tin0P , posti ) ;
                        }
                            etherP.strFuseF( tin0P , psttP , T(posti) ) ; ___( psttP ) ;
                            etherP.fileReadF( tin0P , posti , cToDo , hFileBody ) ;
                        {
                        if( posti )
                        etherP.newF( tin0P , LF , posti , costa ) ; ___( posti ) ;
                        ZE( osTextT* , posti ) ;
            
                        const countT costa = cToDo ;

                        if( cToDo > csttMaxP ) cToDo = csttMaxP ;

                        countT cToDo = pInfo->cbUsed ;
                        //CONoUTrAW3( "writing data: body file is " , pInfo->cbUsed , " bytes\r\n" ) ;
                        _IO_
                    {
                    if( !bFail )
    
                    }
                        bFail = 1 ;
                        DEL( pInfo ) ;
                        //CONoUTrAW( "writing data: body file is too large\r\n" ) ;
                        POOPR
                    {
                    if( pInfo->cbUsedHigh )
                    _IO_
                {
                if( !bFail && pInfo )
        
                }
                    bFail = 1 ;
                    //CONoUTrAW( "writing data: could not get info for body file\r\n" ) ;
                    POOPR
                {
                if( POOP )
                ((tin1S&)tin0P).pEtScratch->diskFileQueryF( tin0P , pInfo , hFileBody ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            if( !bFail )
    
            }
                bFail = 1 ;
                //CONoUTrAW( "writing data: could not open the body file\r\n" ) ;
                POOPR
            {
            if( POOP )
            ((tin1S&)tin0P).pEtScratch->fileOpenF( tin0P , hFileBody , countTC() , psttFileBodyP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
            handleC hFileBody( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            //CONoUTrAW( T("opening body file\r\n") ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        _IO_
    {
    else
    }
        bFail = 1 ;
    {
    else if( !etherP.diskFileExistsF( tin0P , psttFileBodyP ) )
    }
        }
            etherP.strMakeF( tin0P , LF , psttP , tBody ) ; ___( psttP ) ;
            etherP.delF( tin0P , psttb ) ;
            TN( tBody , "" ) ; tBody = T(psttb) ;
            etherP.strSubstringF( tin0P , psttb , idf , idl , psttFileBodyP ) ; ___( psttb ) ;
            ZE( countT , idl ) ;
            countT idf = tLit.csF( tin0P ) + 1 ;
            ZE( strokeS* , psttb ) ;
            _IO_
        {
        if( tLit.csF( tin0P ) < psttFileBodyP->idAdam )
        _IO_
    {
    if( 1 == etherP.strIdF( tin0P , tLit , psttFileBodyP ) )
    TN( tLit , "!literal:" ) ;

    ZE( boolT , bFail ) ;
    _IO_
{
boolT getBodySnipFromFileF( tin0S& tin0P , etherC& etherP , strokeS*& psttP , const strokeS* const psttFileBodyP , const countT csttMaxP = TOCK )

}
    return bFail ;
    }
        //U::CANNOT DO THIS HERE BECAUSE THERE MIGHT BE MUTLIPLE RECIPIENTS, EACH OF WHICH NEEDS THIS FILE TO EXIST: if( !bFail && etherP.diskFileExistsF( tin0P , psttFileBodyP ) ) etherP.boxZapF( tin0P , psttFileBodyP ) ;

        }
            }
                DEL( pInfo ) ;
                }
                    }
                        etherP.delF( tin0P , posti ) ;
                        }
                            }
                                }
                                    }
                                        }
                                            break ;
                                            if( bNew ) bNew = 0 ;
                                        {
                                        default :
                                        }
                                            break ;
                                            }
                                                //CONoUTrAW( "." ) ;
                                                bNew = 0 ;
                                            {
                                            if( bNew )
                                        {
                                        case '.' :
                                        }
                                            break ;
                                            if( !bNew ) bNew = 1 ;
                                        {
                                        case '\n' :
                                        case '\r' :
                                    {
                                    switch( posti[ offi ] )
                                    //CONoUTrAW( post2 ) ;
                                    osTextT post2[] = { posti[ offi ] , 0 } ;
                                {
                                for( countT offi = 0 ; offi < cNibble ; offi ++ )
            
                                cToDo -= cNibble ;
                                etherP.fileReadF( tin0P , posti , cNibble , hFileBody ) ;
                                countT cNibble = costa < cToDo ? costa : cToDo ;
                                _IO_
                            {
                            while( cToDo )
                            boolT bNew = 1 ;
                        {
                        if( posti )
                        etherP.newF( tin0P , LF , posti , costa ) ; ___( posti ) ;
                        ZE( osTextT* , posti ) ;
            
                        const countT costa = TOCK < cToDo ? TOCK : cToDo ;
                        countT cToDo = pInfo->cbUsed ;
                        //CONoUTrAW3( "writing data: body file is " , pInfo->cbUsed , " bytes\r\n" ) ;
                        _IO_
                    {
                    if( !bFail )
    
                    }
                        bFail = 1 ;
                        DEL( pInfo ) ;
                        //CONoUTrAW( "writing data: body file is too large\r\n" ) ;
                        POOPR
                    {
                    if( pInfo->cbUsedHigh )
                    _IO_
                {
                if( !bFail && pInfo )
        
                }
                    bFail = 1 ;
                    //CONoUTrAW( "writing data: could not get info for body file\r\n" ) ;
                    POOPR
                {
                if( POOP )
                ((tin1S&)tin0P).pEtScratch->diskFileQueryF( tin0P , pInfo , hFileBody ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
                _IO_
            {
            if( !bFail )
    
            }
                bFail = 1 ;
                //CONoUTrAW( "writing data: could not open the body file\r\n" ) ;
                POOPR
            {
            if( POOP )
            ((tin1S&)tin0P).pEtScratch->fileOpenF( tin0P , hFileBody , countTC() , psttFileBodyP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
            handleC hFileBody( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            //CONoUTrAW( T("opening body file\r\n") ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        _IO_
    {
    else
    }
        bFail = 1 ;
    {
    else if( !etherP.diskFileExistsF( tin0P , psttFileBodyP ) )
    }
        }
            //CONoUTrAW( tBody ) ;
            etherP.delF( tin0P , psttb ) ;
            TN( tBody , "" ) ; tBody = T(psttb) ;
            etherP.strSubstringF( tin0P , psttb , idf , idl , psttFileBodyP ) ; ___( psttb ) ;
            ZE( countT , idl ) ;
            countT idf = tLit.csF( tin0P ) + 1 ;
            ZE( strokeS* , psttb ) ;
        {
        if( tLit.csF( tin0P ) < psttFileBodyP->idAdam )
        //CONoUTrAW( T("sending literal value\r\n") ) ;
        _IO_
    {
    if( 1 == etherP.strIdF( tin0P , tLit , psttFileBodyP ) )
    TN( tLit , "!literal:" ) ;

    //CONoUTrAW( T("processing body file \"")+T(psttFileBodyP)+T("\"\r\n") ) ;
    ZE( boolT , bFail ) ;
    _IO_
{
boolT logBodySnipFromFileF( tin0S& tin0P , etherC& etherP , const strokeS* const psttFileBodyP )

}
    return bFail ;

    }
        //U::CANNOT DO THIS HERE BECAUSE THERE MIGHT BE MUTLIPLE RECIPIENTS, EACH OF WHICH NEEDS THIS FILE TO EXIST: if( !bFail && etherP.diskFileExistsF( tin0P , psttFileBodyP ) ) etherP.boxZapF( tin0P , psttFileBodyP ) ;

        }
            }
                DEL( pInfo ) ;
                }
                    }
                        }
                            etherP.traceF( tin0P , T("!exception / write failed while writing body") ) ;
                            flagsFailP |= flFAIL_DATAbODYfILEtOOlARGEoRwRITEfAILED ;
                            POOPR
                        {
                        if( POOP )

                        etherP.delF( tin0P , posti ) ;
                        }
                            }
                                }
                                    }
                                        }
                                            break ;
                                            if( bNew ) bNew = 0 ;
                                        {
                                        default :
                                        }
                                            break ;
                                            }
                                                sockP.writeF( tin0P , "." , 1 ) ;
                                                bNew = 0 ;
                                            {
                                            if( bNew )
                                        {
                                        case '.' :
                                        }
                                            break ;
                                            if( !bNew ) bNew = 1 ;
                                        {
                                        case '\n' :
                                        case '\r' :
                                    {
                                    switch( posti[ offi ] )
                                    sockP.writeF( tin0P , posti + offi , 1 ) ;
                                    _IO_
                                {
                                for( countT offi = 0 ; offi < cNibble ; offi ++ )
            
                                cToDo -= cNibble ;
                                etherP.fileReadF( tin0P , posti , cNibble , hFileBody ) ;
                                countT cNibble = costa < cToDo ? costa : cToDo ;
                                _IO_
                            {
                            while( !POOP && cToDo )
                            boolT bNew = 1 ;
                            _IO_
                        {
                        if( posti )
                        etherP.newF( tin0P , LF , posti , costa ) ; ___( posti ) ;
                        ZE( osTextT* , posti ) ;
            
                        const countT costa = TOCK < cToDo ? TOCK : cToDo ;
                        countT cToDo = pInfo->cbUsed ;
                        etherP.traceF( tin0P , T("writing data: body file is ")+TF2(pInfo->cbUsed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" bytes") ) ;
                        _IO_
                    {
                    if( !bFail )
    
                    }
                        bFail = 1 ;
                        DEL( pInfo ) ;
                        etherP.traceF( tin0P , T("!exception / writing data: body file is too large") ) ;
                        flagsFailP |= flFAIL_DATAbODYfILEtOOlARGEoRwRITEfAILED ;
                        POOPR
                        _IO_
                    {
                    if( POOP )
                    __NZ( pInfo->cbUsedHigh ) ;
                    _IO_
                {
                if( !bFail && pInfo )
        
                }
                    bFail = 1 ;
                    etherP.traceF( tin0P , T("!exception / writing data: could not get info for body file") ) ;
                    flagsFailP |= flFAIL_DATAcANNOTgETbODYfILEiNFO ;
                    POOPR
                    _IO_
                {
                if( POOP )
                ((tin1S&)tin0P).pEtScratch->diskFileQueryF( tin0P , pInfo , hFileBody ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
                _IO_
            {
            if( !bFail )
    
            }
                bFail = 1 ;
                etherP.traceF( tin0P , T("!exception / writing data: could not open the body file") ) ;
                flagsFailP |= flFAIL_DATAcANNOToPENfILE ;
                POOPR
                _IO_
            {
            if( POOP )
            ((tin1S&)tin0P).pEtScratch->fileOpenF( tin0P , hFileBody , countTC() , psttFileBodyP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
            handleC hFileBody( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            etherP.traceF( tin0P , T("opening body file") ) ;

            SCOOPS    //U::  <-------------------------- DT'OR OF THIS scoopC INSTANCE DETECTS IMPOTENT etScratch
            _IO_
        {
        IFsCRATCHoK
        _IO_
    {
    else
    }
        bFail = 1 ;
        flagsFailP |= flFAIL_DATAfILEdOESnOTeXIST ;
        _IO_
    {
    else if( !etherP.diskFileExistsF( tin0P , psttFileBodyP ) )
    }
        }
            sockP.writeF( tin0P , (osTextT*)tBody , tBody.csF( tin0P ) ) ;
            etherP.delF( tin0P , psttb ) ;
            TN( tBody , "" ) ; tBody = T(psttb) ;
            etherP.strSubstringF( tin0P , psttb , idf , idl , psttFileBodyP ) ; ___( psttb ) ;
            ZE( countT , idl ) ;
            countT idf = tLit.csF( tin0P ) + 1 ;
            ZE( strokeS* , psttb ) ;
            _IO_
        {
        if( tLit.csF( tin0P ) < psttFileBodyP->idAdam )
        //CONoUTrAW( T("sending literal value\r\n") ) ;
        _IO_
    {
    if( 1 == etherP.strIdF( tin0P , tLit , psttFileBodyP ) )
    TN( tLit , "!literal:" ) ;

    //etherP.traceF( tin0P , T("processing body file \"")+T(psttFileBodyP)+T("\"") ) ;
    ZE( boolT , bFail ) ;
    _IO_
{
boolT writeBodySnipFromFileF( tin0S& tin0P , etherC& etherP , socketC& sockP , const strokeS* const psttFileBodyP , flagsT& flagsFailP )

}
    }
        sIn >> psttP ; ___( psttP ) ;
    
        __( idFormat - 1 ) ;
        sIn >> idFormat ;
        ZE( countT , idFormat ) ;
    
        __( finger - FINGERnEG_LISTsERVERrEPLY ) ;
        sIn >> finger ;
        ZE( countT , finger ) ;
    
        sock.readF( tin0P , sIn ) ;
        soulC sIn( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
    
        sock.writeF( tin0P , sOut ) ;
        sOut << cPassAccountSP ;
        sOut << (countT)ifcIDcMDlISTsERVEReMAILiDaCCOUNT_ASKeMAILfROMiDaCCOUNT ;
        sOut << (countT)1 ;
        sOut << (countT)FINGERnEG_LISTsERVERcMD ;
        soulC sOut( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
    
        sock.connectF( tin0P , homeS::homeIF().idPortListServerEmailIdAccount ) ;
        socketC sock( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;

        SCOOPS
        _IO_
    {
    IFsCRATCHoK

    if( POOP ) return ;
    __NZ( psttP ) ;
    if( POOP ) return ;
    _IO_
{
voidT queryEmailFromIdAccountF( tin0S& tin0P , strokeS*& psttP , const countT cPassAccountSP )
//DUPLICATE CODE: b750104 3a50104

#define flFAIL_COULDnOTzAPsENTfILE                  0xe80000ff
#define flFAIL_STARTtlsrEJECTED                     0xe40000ff
#define flFAIL_UNAUTHORIZEDrELAYsERVER              0xe20000ff
#define flFAIL_DATAfILEdOESnOTeXIST                 0xe10000ff
#define flFAIL_DATAbODYfILEtOOlARGEoRwRITEfAILED    0xe08000ff
#define flFAIL_DATAcANNOTgETbODYfILEiNFO            0xe04000ff
#define flFAIL_DATAcANNOToPENfILE                   0xe02000ff
#define flFAIL_COULDnOTmOVEfILE                     0xe01000ff
#define flFAIL_COULDnOTgETsHORTfILEnAME             0xe00800ff
#define flFAIL_UNKNOWNeRROR                         0xe00400ff
#define flFAIL_QUITcOMMANDrEJECTED                  0xe00200ff
#define flFAIL_BODYrEJECTED                         0xe00100ff
#define flFAIL_DATAcOMMANDrREJECTED                 0xe00080ff
#define flFAIL_RCPTtOrEJECTED                       0xe00040ff
#define flFAIL_MAILfROMrEJECTED                     0xe00020ff
#define flFAIL_HELLOaCCEPTED                        0xe00010ff
#define flFAIL_HELLOrEJECTED                        0xe00008ff
#define flFAIL_COULDnOTcONNECT                      0xe00004ff
#define flFAIL_DURINGpARSING                        0xe00002ff
#define flFAIL_COULDnOTgETsHADOW                    0xe00001ff

/*1*/WAKEhIDE( "ifcIDaDAM_ROOTmAILoUT" )/*1*/

/**/
*/
watches a directory containing email to send
/*

// 20190728@1946: EDIT TO MIGRATE FROM boxMenuF TO diskFindWothF
//OBSOLETES 5adam.5100059d.1

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

