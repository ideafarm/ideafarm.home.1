
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etherC::loafIF( tin0P ) ; // THIS IS TO PREVENT AN EARLY, INTENTIONAL QUIT FROM TRIGGERING GLASS2 EXCEPTION REPORTS

    thirdC::osProcessIdPhaseAdamIF( tin0P , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

    etThread.osThreadSwitchingDesireF( tin0P , idDesireSave ) ;

    etThread.delF( tin0P , psttNapCommand ) ;
    }
        else etThread.traceF( tin0P , T("cloud administration suppressed because some required settings were not found") ) ;
        }
            }
                }
                    }
                        }
                            etThread.traceF( tin0P , T("cloud: step: [idStepSoil]:    ")+TF2(idStep,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            countT idStep = 1 + incv02AM( home.idStepSoil ) ;
                        {
                        if( waitStepModulo >= 2 )

                        }
                            etThread.traceF( tin0P , T("cloud: napped  [time1Nap]:    ")+TF2(time1Nap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            ether.osSleepF( tin0P , time1Nap ) ;
                            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                            etThread.traceF( tin0P , T("cloud: napping [time1Nap]:    ")+TF2(time1Nap,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        if( time1Nap && !ether )

                        if( bFail ) time1Nap = TOCK << 4 ;
                    {
                    if( !etPrime )

                    }
                        if( bRestoreTracing ) thirdC::third_flagsModeAdam1I_IF( tin0P ) &= ~( F(flADAMmODE1_NOtRACING) ) ;
                        etThread.traceF( tin0P , bFail ? tAborted : tEnded ) ;

                        }
                            etThread.traceF( tin0P , T("cloud administration cycle ending") ) ;

                            }
                                etThread.traceF( tin0P , T("cloud administration cycle could not be completed") ) ;
                                bFail = 1 ;
                                POOPR
                            {
                            if( POOP )

                            etThread.osThreadSwitchingDesireF( tin0P , idDesireSave ) ;
                            cloudC cloudRax( tin0P , tName , idDoIfDiffer , flagsCloud , idCloud , T(cloudSpec.postBuilding) , T(cloudSpec.postUser) , T(cloudSpec.postPassword) , T(cloudSpec.postRemote) , T(cloudSpec.postLocal) , T(cloudSpec.postLike) , etThread.strDigitsToSCountF( tin0P , T(cloudSpec.postCbMin) ) , etThread.strDigitsToSCountF( tin0P , T(cloudSpec.postCbMax) ) , etThread.strDigitsToSCountF( tin0P , T(cloudSpec.postDelTries) ) , F(flagsCloud) & flCLOUDc_REMOTEiSmASTER ? cloudUpdateLocalCBF : cloudUpdateRemoteCBF , pcArgUpdate , F(flagsCloud) & flCLOUDc_REMOTEiSmASTER ? cloudNixLocalCBF : cloudNixRemoteCBF , pcArgNix , T(cloudSpec.postMoveLocalToAfter) , T(cloudSpec.postHireAdamAfter) ) ;

                            }
                                etThread.traceF( tin0P , T("warning: cloud name truncated to length 03:  ")+tName ) ;
                                etThread.delF( tin0P , psttn ) ;
                                tName = T(psttn) ;
                                etThread.strSubstringF( tin0P , psttn , idf , idl , tName ) ; ___( psttn ) ;
                                countT idl = 0x30 ;
                                countT idf = 1 ;
                                ZE( strokeS* , psttn ) ;
                            {
                            if( tName.csF( tin0P ) > 0x30 )
                        {
                        _IO_
                        etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZY ) ;
                        countT idDesireSave = etThread.osThreadSwitchingDesireF( tin0P ) ;

                        //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                        if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postVerifyLocalList , "no" ) ) flagsCloud |= flCLOUDc_DOnOTvERIFYlOCALlIST ;
                        //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                        if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postRenameToHash , "yes" ) ) flagsCloud |= flCLOUDc_RENAMEtOhASH ;
                        //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                        if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postCopy , "no"     ) ) flagsCloud |= flCLOUDc_NOcOPY ;
                        //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                        if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postGhost   , "yes"      ) ) flagsCloud |= flCLOUDc_GHOST ;
                        //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                        if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postDelete  , "notexist" ) ) flagsCloud |= flCLOUDc_DELETEiFmASTERnOTeXIST ;
                        if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postDelete  , "exist"    ) ) flagsCloud |= flCLOUDc_DELETEiFmASTEReXIST ;
                        //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                        if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postMaster  , "remote"   ) ) flagsCloud |= flCLOUDc_REMOTEiSmASTER ;
                        //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                        if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postNetwork , "internal" ) ) flagsCloud |= flCLOUDc_USEiNTERNALlAN ;

                        //etThread.traceF( tin0P , T("debug [flagsCloud]: ")+TF3(flagsCloud,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                        flagsT flagsCloud = flagsCt ;

                        TN( tName , cloudSpec.postName ) ;

                        etThread.traceF( tin0P , T("cloud administration begun / initial administration routine / starting") ) ;

                        //etThread.disk FixBadFileNamesF( tin0P , T(cloudSpec.postLocal) , flETHERfIXnAMES_RECURSE ) ; // JUST IN CASE AN INVALID FILE NAME GOT IN
                        //etThread.traceF( tin0P , T("cloud administration cycle begun / renaming files to eliminate invalid characters") ) ;

                        }
                            }
                                thirdC::third_flagsModeAdam1I_IF( tin0P ) |= flADAMmODE1_NOtRACING ;
                                bRestoreTracing = 1 ;
                            {
                            if( !( F(thirdC::third_flagsModeAdam1I_IF(tin0P)) & flADAMmODE1_NOtRACING ) )

                            }
                                etThread.traceF( tin0P , T("tracing will be suppressed for this adam while the cloudC instance exists, because the cloud specification requests this") ) ;
                                bDone = 1 ;
                            {
                            if( !bDone )
                            static boolT bDone ;
                        {
                        if( !thirdC::c_strcmpIF( tin0P , cloudSpec.postTrace , "no" ) )
                        ZE( boolT , bRestoreTracing ) ;
                    {
                    ZE( boolT , bFail ) ;

                    }
                        }
                            etThread.traceF( tin0P , T("cloud: step: [idStepSoil]:    ")+TF2(idStep,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            countT idStep = 1 + incv02AM( home.idStepSoil ) ;

                            ether.traceF( tin0P , T(bNapped?"cloudC: waitstep: waiting ended [idStepSoil,waitStepModulo,waitStepRemainder]:    ":"cloudC: waitstep: did not wait  [idStepSoil,waitStepModulo,waitStepRemainder]:    ")+TF2(home.idStepSoil,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepModulo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepRemainder,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        {
                        if( !etPrime )

                        }
                            ++ s ; etPrime.osSleepF( tin0P , TOCK ) ;

                            }
                                bNapped = 1 ;
                                ether.traceF( tin0P , T("cloudC: waitstep: waiting begun [idStepSoil,waitStepModulo,waitStepRemainder]:    ")+TF2(home.idStepSoil,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepModulo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(waitStepRemainder,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            if( !bNapped )
                        {
                        while( !etPrime && home.idStepSoil % waitStepModulo != waitStepRemainder )

                        ZE( boolT , bNapped ) ;
                        TN( tb4 , "    " ) ;

                        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                    {
                    if( !etPrime && waitStepModulo >= 2 )

                    #endif
                    }
                        break ;
                        etThread.traceF( tin0P , T("CLOUD: quitting because this home no longer has PAID privileges") ) ;
                    {
                    )
                        !( F(home.flags) & flHOMEs_IDEAFARMcLOUDiSgONE )
                        &&
                        !( F(home.flags) & flHOMEs_PAIDpRIVILEGES )
                    (
                    if
                    #if defined( NEVERdEFINED )
                {
                while( !etPrime && !ether && !etThread )

                SCOOPS
            {
            IFsCRATCHoK

            etherC& etPrime = etherC::etPrimeIF( tin0P ) ;
            homeS& home = homeS::homeIF() ;

            else                      etThread.traceF( tin0P , T("after each successful cloud administration cycle, i will nap for ")+TF2(time1Nap>>0x10,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" tock before beginning a new cycle") ) ;
            if( waitStepModulo >= 2 ) etThread.traceF( tin0P , T("before beginning each cloud administration cycle, i will wait for home.idStepSoil % ")+TF2(waitStepModulo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" to be ")+TF2(waitStepRemainder,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" and i will increment home.idStepSoil before and after each cycle") ) ;

            TN( tEnded   , "" ) ; tEnded = T("cloud administration cycle ended ; napping for ")+TF2(time1Nap>>0x10,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" tock") ;
            TN( tAborted , "cloud administration cycle aborted ; napping for 01 tock" ) ;

            ;
                    : TICK << 4                                                                     // ELSE                                           THE NAP SPECIFICATION DEFAULTS TO WO HOUR
                    ? 0                                                                             // IF I AM PARTICIPATING IN A STEPPING GROUP THEN THE NAP SPECIFICATION DEFAULTS TO 0
                : waitStepModulo >= 2
                ? etThread.strDigitsToSCountF( tin0P , T(cloudSpec.postNapTocks) ) << 0x10
            countT time1Nap = *cloudSpec.postNapTocks

            countT waitStepRemainder = etThread.strDigitsToSCountF( tin0P , T(cloudSpec.postWaitStepRemainder) ) ;
            countT waitStepModulo    = etThread.strDigitsToSCountF( tin0P , T(cloudSpec.postWaitStepModulo   ) ) ;
        {
        if( idCloud && *cloudSpec.postUser && *cloudSpec.postPassword && *cloudSpec.postRemote && *cloudSpec.postName && *cloudSpec.postLocal && *cloudSpec.postBuilding )

        }
            else if( !etThread.strCompareF( tin0P , T(cloudSpec.postIfDiffer) , T("replace") ) ) idDoIfDiffer = ifcIDdOcLOUDiFdIFFER_REPLACE ;
            else if( !etThread.strCompareF( tin0P , T(cloudSpec.postIfDiffer) , T("report" ) ) ) idDoIfDiffer = ifcIDdOcLOUDiFdIFFER_REPORT  ;
                 if( !etThread.strCompareF( tin0P , T(cloudSpec.postIfDiffer) , T("nothing") ) ) idDoIfDiffer = ifcIDdOcLOUDiFdIFFER_NOTHING ;
        {
        if( *cloudSpec.postIfDiffer )

        countT       idDoIfDiffer = ifcIDdOcLOUDiFdIFFER_REPORT ;

        //etThread.traceF( tin0P , T("debug [flagsCt]: ")+TF3(flagsCt,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
        /*const*/ flagsT flagsCt      = flCLOUDc_null ;

        countT pcArgNix[] = { (countT)&cloudSpec } ;
        countT pcArgUpdate[]    = { (countT)&cloudSpec } ;

        if( *cloudSpec.postId && !etThread.strCompareF( tin0P , T(cloudSpec.postId) , T("rackspace.com") ) ) idCloud = ifcIDcLOUD_RACKSPACE ;
        ZE( countT , idCloud ) ;

        cloudSpec.sayF( tin0P , etThread ) ;

        cloudSpecsS& cloudSpec = *(cloudSpecsS*)(byteT*)napSpec ;

        napkinC napSpec( tin0P , TAG( TAGiDnULL ) , T(psttNapCommand) , 0 , sizeof( cloudSpecsS ) , ifcOPENsHAREDmEMORYhOW_nFeO ) ;

        etThread.traceF( tin0P , T("command received: ")+T(psttNapCommand) ) ;
    {
    else
    }
        }
            while( !ether ) { ++ s ; ether.osSleepF( tin0P , TOCK ) ; } // REMAIN ALIVE SO THAT THE PROCESSES THAT I LAUNCH REMAIN ATTACHED TO THE PROCESS TREE GROWING FROM THE IPDOS (TM) SERVICE PROCESS
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        {
        if( cClouds )

        }
            while( !ether && napSpec.cRefF() == 1 ) { ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ; }
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

            etThread.traceF( tin0P , T("hired  myself 3") ) ;
            etThread.ifcHireF( tin0P , T("ifcIDaDAM_CLOUD") , 0 , tArgKeyName+T(" \"")+T(pSpec->postName)+T("\" ")+tArgKeyCloudSpec+tb+tNapSpecName , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            etThread.traceF( tin0P , T("hiring myself 3") ) ;
            cClouds ++ ;

            pSpec->sayF( tin0P , etThread ) ;

            napSpec.formattingIsDoneF( tin0P ) ;
            cloudSpecsS* pSpec = new( 0 , tin0P , &napSpec ) cloudSpecsS( tin0P , etThread , T("IdeaFarm (tm) Precious (c) Wo'O Ideafarm") , "IAD"         , 0           , "rackspace.com" , 0             , "///ideafarm/precious.zipped/" , tPassword     , "ideafarm.home.1.precious.zip.disclose" , tUser     , "notexist"  , "1"           , "remote"    , 0            , "0008"        , "yes"          , "no"       , "0"                 , "0"                    , ""        , 0          , 0          , "no"       , "yes"     , "no"              , ""                    , ""                   , ""                 ) ; ___( pSpec ) ;
                                                         // cloudSpecsS( tin0P , etherP   , psttNameP                                     , postBuildingP , postDesireP , postIdP         , postIfDifferP , postLocalP                     , postPasswordP , postRemoteP                             , postUserP , postDeleteP , postDelTriesP , postMasterP , postNetworkP , postNapTocksP , postAllOrNoneP , postGhostP , postWaitStepModuloP , postWaitStepRemainderP , postLikeP , postCbMinP , postCbMaxP , postTraceP , postCopyP , postRenameToHashP , postMoveLocalToAfterP , postVerifyLocalListP , postHireAdamAfterP ) ;
                                                                                                                                                                                                                                                                                                                                                 /*0001 TOCKS = 1 HOUR (90 FOREIGN MINUTES)*/
            //secretPreciousF( tin0P , etThread , tUser , tPassword ) ;
            TN( tPassword , "61da6f0c899b46f2aed77fca1d1276c4" ) ;
            TN( tUser , "public.precious.reader" ) ;

            napkinC napSpec( tin0P , TAG( TAGiDnULL ) , tNapSpecName , 0 , sizeof( cloudSpecsS ) , ifcOPENsHAREDmEMORYhOW_nCeF ) ;
            etThread.traceF( tin0P , T("constructing cloud spec napkin with name: ")+tNapSpecName ) ;

            }
                etThread.delF( tin0P , psttu ) ;
                tNapSpecName = T("cloud.napSpec.")+T(psttu) ;
                etThread.strUniqueF( tin0P , psttu ) ; ___( psttu ) ;
                ZE( strokeS* , psttu ) ;
            {
            TN( tNapSpecName , "" ) ;

            etThread.traceF( tin0P , T("cloud: IdeaFarm (tm) Precious Disclosure (c) Wo'O Ideafarm") ) ;
            if( bForcePrecious ) etThread.traceF( tin0P , T("cloud: settings indicate that precious is to be forced") ) ;
        {
        else
        }
            etThread.traceF( tin0P , T("cloud: IdeaFarm (tm) Precious (source code) will be suppressed [reasons]:    ")+tReasons ) ;

            if( bExeDllPublisher                               ) tReasons += T("\"this home publishes exedll.1\"") ;
            if( idComputer == idComputerCraftworkMaster        ) tReasons += T(tReasons.csF(tin0P)?"    \"this home is on a development computer\"":"\"this home is on a development computer\"") ;
            if( bSuppressPrecious                              ) tReasons += T("\"settings indicate that precious is to be suppressed\"") ;
            TN( tReasons , "" ) ;
        {
        if( bSuppressPrecious || ( !bForcePrecious && ( bExeDllPublisher || idComputer == idComputerCraftworkMaster ) ) ) // DISABLE PRECIOUS IF DEVELOPMENT MACHINE
        // PRECIOUS (SOURCE AND BUILD) DISCLOSURE: COPYRIGHTED OPEN SOURCE

        }
            while( !ether && napSpec.cRefF() == 1 ) { ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ; }
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

            etThread.traceF( tin0P , T("hired  myself 2") ) ;
            etThread.ifcHireF( tin0P , T("ifcIDaDAM_CLOUD") , 0 , tArgKeyName+T(" \"")+T(pSpec->postName)+T("\" ")+tArgKeyCloudSpec+tb+tNapSpecName , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            etThread.traceF( tin0P , T("hiring myself 2") ) ;
            cClouds ++ ;

            pSpec->sayF( tin0P , etThread ) ;

            napSpec.formattingIsDoneF( tin0P ) ;
            cloudSpecsS* pSpec = new( 0 , tin0P , &napSpec ) cloudSpecsS( tin0P , etThread , T("IPDOS (tm) automatic update") , "IAD"         , 0           , "rackspace.com" , 0             , "///ideafarm/ephemeral/domains/com/ideafarm/city/park/exedll/1/" , tPassword     , "exedll.1"  , tUser     , "notexist"  , "1"           , "remote"    , 0            , "0004"        , "yes"          , "no"       , "0"                 , "0"                    , ""        , 0          , 0          , "no"       , "yes"     , "no"              , ""                    , ""                   , ""                 ) ; ___( pSpec ) ;
                                                          // cloudSpecsS( tin0P , etherP   , psttNameP                        , postBuildingP , postDesireP , postIdP         , postIfDifferP , postLocalP                                                       , postPasswordP , postRemoteP , postUserP , postDeleteP , postDelTriesP , postMasterP , postNetworkP , postNapTocksP , postAllOrNoneP , postGhostP , postWaitStepModuloP , postWaitStepRemainderP , postLikeP , postCbMinP , postCbMaxP , postTraceP , postCopyP , postRenameToHashP , postMoveLocalToAfterP , postVerifyLocalListP , postHireAdamAfterP ) ;

            //secretAutoUpdateF( tin0P , etThread , tUser , tPassword ) ;
            TN( tPassword , "4c41b9f802fa49849a16575dc001deb4" ) ;
            TN( tUser , "ipdos.update.client" ) ;   //A:ASSUME: THIS USER ACCOUNT ONLY HAS READ-ONLY ACCESS TO RACKSPACE CLOUD FILES

            napkinC napSpec( tin0P , TAG( TAGiDnULL ) , tNapSpecName , 0 , sizeof( cloudSpecsS ) , ifcOPENsHAREDmEMORYhOW_nCeF ) ;
            etThread.traceF( tin0P , T("constructing cloud spec napkin with name: ")+tNapSpecName ) ;

            }
                etThread.delF( tin0P , psttu ) ;
                tNapSpecName = T("cloud.napSpec.")+T(psttu) ;
                etThread.strUniqueF( tin0P , psttu ) ; ___( psttu ) ;
                ZE( strokeS* , psttu ) ;
            {
            TN( tNapSpecName , "" ) ;

            // IT IS THE REFERENCES IN THE FILES IN "master" THAT DETERMINE WHICH FILE IN "hover" IS LAUNCHED WHEN LAUNCHING THE PROCESS FOR AN ADAM
            // THE REASON FOR THE REQUIREMENT IS THAT EVERY FILE IN "hover" THAT IS REFERENCED BY A FILE IN "master" MUST EXIST
            // THIS IS ASSURED AS LONG AS THE BASE OPERATING SYSTEM COLLATES "hover" BEFORE "master"
            // IT IS CRITICAL THAT THE "hover" DIRECTORY BE PROCESSED BEFORE THE "master" DIRECTORY, BOTH WHEN THE DEVELOPMENT COMPUTER PUBLISHES AND WHEN A CLIENT UPDATES ITSELF

            etThread.traceF( tin0P , T("cloud: IPDOS (tm) automatic update") ) ;
            if( bForceAutoUpdate ) etThread.traceF( tin0P , T("cloud: settings indicate that automatic update is to be forced") ) ;
        {
        else
        }
            etThread.traceF( tin0P , T("cloud: IPDOS (tm) automatic update will be suppressed [reasons]:    ")+tReasons ) ;

            if( bSuppressAutoUpdate                            ) tReasons += T(tReasons.csF(tin0P)?"    \"this home is configured to suppress automatic update\"":"\"this home is configured to suppress automatic update\"") ;
            if( idComputer == idComputerCraftworkMaster        ) tReasons += T(tReasons.csF(tin0P)?"    \"this home is on a development computer\"":"\"this home is on a development computer\"") ;
            if( bExeDllPublisher                               ) tReasons += T("\"this home publishes exedll.1\"") ;
            TN( tReasons , "" ) ;
        {
        if( bSuppressAutoUpdate || ( !bForceAutoUpdate && ( bExeDllPublisher || idComputer == idComputerCraftworkMaster ) ) ) // DISABLE AUTO UPDATE IF DEVELOPMENT MACHINE

        countT idComputerCraftworkMaster = IDcOMPUTER_IPDOSmASTERcRAFTWORK ;

        }
            etThread.delF( tin0P , psttForceAutoUpdate ) ;
            bForceAutoUpdate = psttForceAutoUpdate && !etThread.strCompareF( tin0P , psttForceAutoUpdate , T("yes") ) ;
            ZE( strokeS* , psttForceAutoUpdate ) ; etThread.querySettingF( tin0P , psttForceAutoUpdate , T("!ipdos.force.auto.update")  ) ; ___( psttForceAutoUpdate ) ;
        {
        ZE( boolT , bForceAutoUpdate ) ;

        }
            etThread.delF( tin0P , psttSuppressAutoUpdate ) ;
            bSuppressAutoUpdate = psttSuppressAutoUpdate && !etThread.strCompareF( tin0P , psttSuppressAutoUpdate , T("yes") ) ;
            ZE( strokeS* , psttSuppressAutoUpdate ) ; etThread.querySettingF( tin0P , psttSuppressAutoUpdate , T("!ipdos.suppress.auto.update")  ) ; ___( psttSuppressAutoUpdate ) ;
        {
        ZE( boolT , bSuppressAutoUpdate ) ;

        }
            etThread.delF( tin0P , psttForcePrecious ) ;
            bForcePrecious = psttForcePrecious && !etThread.strCompareF( tin0P , psttForcePrecious , T("yes") ) ;
            ZE( strokeS* , psttForcePrecious ) ; etThread.querySettingF( tin0P , psttForcePrecious , T("!ipdos.force.precious")  ) ; ___( psttForcePrecious ) ;
        {
        ZE( boolT , bForcePrecious ) ;

        }
            etThread.delF( tin0P , psttSuppressPrecious ) ;
    bSuppressPrecious = 1 ;
            bSuppressPrecious = psttSuppressPrecious && !etThread.strCompareF( tin0P , psttSuppressPrecious , T("yes") ) ;
            ZE( strokeS* , psttSuppressPrecious ) ; etThread.querySettingF( tin0P , psttSuppressPrecious , T("!ipdos.suppress.precious")  ) ; ___( psttSuppressPrecious ) ;
        {
        ZE( boolT , bSuppressPrecious ) ;

        countT idComputer = etThread.diskIdF( tin0P , T("///c") ) ;

        }
            while( !ether && napSpec.cRefF() == 1 ) { ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ; }
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

            etThread.traceF( tin0P , T("hired  myself 1") ) ;
            etThread.ifcHireF( tin0P , T("ifcIDaDAM_CLOUD") , 0 , tArgKeyName+T(" \"")+T(pSpec->postName)+T("\" ")+tArgKeyCloudSpec+tb+tNapSpecName , flHIRE_DISPLAYaUTO , nicNameC() ) ;
            etThread.traceF( tin0P , T("hiring myself 1") ) ;
            cClouds ++ ;

            pSpec->sayF( tin0P , etThread ) ;

            if( !thirdC::c_strcmpIF( tin0P , pSpec->postRemote , "exedll.1" ) ) bExeDllPublisher = 1 ;

            THREADmODE1rESTORE
            }
                etThread.delF( tin0P , psttk ) ;
                pSpec->cloudSpecsS::setF( tin0P , etThread , psttzLeverCloud , psttk ) ;
                //etThread.traceF( tin0P , T("  key: ")+T(psttk) ) ;
                swsSettings >> psttk ;
                ZE( strokeS* , psttk ) ;
            {
            while( swsSettings )
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

            napSpec.formattingIsDoneF( tin0P ) ; // *pSpec IS NOT COMPLETELY FORMATTED YET, BUT DEFERRING THIS LINE WOULD CAUSE THE MONOTONIC GRABBING RULE TO BE VIOLATED BECAUSE TELEMETRY CAN BE WRITTEN DURING THE CALL TO cloudSpecsS::setF
            cloudSpecsS* pSpec = new( 0 , tin0P , &napSpec ) cloudSpecsS( tin0P , etThread , psttzLeverCloud ) ; ___( pSpec ) ;

            napkinC napSpec( tin0P , TAG( TAGiDnULL ) , tNapSpecName , 0 , sizeof( cloudSpecsS ) , ifcOPENsHAREDmEMORYhOW_nCeF ) ;
            etThread.traceF( tin0P , T("constructing cloud spec napkin with name: ")+tNapSpecName ) ;

            }
                etThread.delF( tin0P , psttu ) ;
                tNapSpecName = T("cloud.napSpec.")+T(psttu) ;
                etThread.strUniqueF( tin0P , psttu ) ; ___( psttu ) ;
                ZE( strokeS* , psttu ) ;
            {
            TN( tNapSpecName , "" ) ;

            etThread.traceF( tin0P , T("cloud: ")+T(psttzLeverCloud) ) ;
            psttzLeverCloud = (strokeS*)swsSettings.leverF( tin0P , idf ) ;
        {
        for( countT idf = 1 ; !ether && idf <= cFlavors ; idf ++ )
        TN( tb , " " ) ;
        ZE( boolT , bExeDllPublisher ) ;
        etThread.traceF( tin0P , T("launching a cloud administrator process for each cloud [cClouds]: ")+TF2(cFlavors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        countT cFlavors = swsSettings.cFlavorsF( tin0P ) ;
        ZE( countT , cClouds ) ;
        ZE( boolT  , bQuit   ) ;

        etThread.walkSettingsF( tin0P , pbBuffer , sizeof pbBuffer , countTC() , myCBF , pcArg ) ;
        countT pcArg[] = { 0 , (countT)&psttzLeverCloud , (countT)&swsSettings } ;

        switchStackC swsSettings( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzLeverCloud , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
        ZE( strokeS* , psttzLeverCloud ) ;
    {
    else*/ if( !psttNapCommand )
    etThread.traceF( tin0P , T("CLOUD: doing nothing since this home does not have PAID privileges") ) ;
    )
        !( F(home.flags) & flHOMEs_IDEAFARMcLOUDiSgONE )
        &&
        !( F(home.flags) & flHOMEs_PAIDpRIVILEGES )
    (
    if
    /*

    homeS& home = homeS::homeIF() ;

    }
        }
            }
                etThread.strMakeF( tin0P , LF , psttNapCommand , psttc1 ) ; ___( psttNapCommand ) ;
                bArmed = 0 ;
            {
            else if( bArmed )
            if( !etThread.strCompareF( tin0P , psttc1 , tArgKeyCloudSpec ) ) bArmed = 1 ;
            etThread.traceF( tin0P , T("param: ")+T(psttc1) ) ;
        {
        FORsTRINGSiN1( pstt1Param )
        ZE( boolT , bArmed ) ;
        strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tin0P ) ;
    {
    TN( tArgKeyCloudSpec , "!napCloudSpec" ) ;
    ZE( strokeS* , psttNapCommand ) ;

    TN( tArgKeyName , "!name" ) ;

    const countT idDesireSave = etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIER ) ;

    thirdC::osProcessIdPhaseAdamIF( tin0P , ifcIDpHASEhANDOFFoLD_WORKING ) ;
{
if( pTaskP )
TASK( tmWorkF )

// 
// TIME THAT YOU OPEN A SOIL (TM) FILE, TELL WINDOWS WHAT FILE YOU WANT TO USE WHENEVER OPENING A SOIL (TM) FILE.
// TO INSPECT OR EDIT A SOIL (TM) FILE, OPEN IT WITH A NORMAL TEXT EDITOR (SUCH AS NOTEPAD.EXE ON WINDOWS).  THE FIRST
// IF THE FILE IS REJECTED, IT WILL BE ACCOMPANIED WITH ANOTHER ASCII PLAIN TEXT FILE THAT CONTAINS ERROR INFORMATION
// 
//     ///ideafarm.home.1/IdeaFarm (tm)/SYSTEM/1.3. Pick Up Rejected SOIL (tm) Text Files Here/
// 
//     ///ideafarm.home.1/IdeaFarm (tm)/SYSTEM/1.4. Pick Up Completed SOIL (tm) Text Files Here/
// 
// WITHIN A MINUTE OR OO, THE FILE WILL BE MOVED INTO WO OF OO FOLDERS:
// 
//     ///ideafarm.home.1/IdeaFarm (tm)/SYSTEM/1.2. SOIL (tm) Text Files Being Eaten/
// 
// WHEN YOU DO THAT, THE FILE WILL DISAPPEAR IMMEDIATELY BECAUSE IT HAS BEEN MOVED TO ANOTHER FOLDER:
// 
//     ///ideafarm.home.1/IdeaFarm (tm)/SYSTEM/1.1. Drop a Copy of SOIL (tm) Text Files Here/
// 
// A PARTICULAR FOLDER WITHIN THE IPDOS (tm) HOME FOLDER.  THE PARTICULAR FOLDER IS:
// OF EACH OF THESE FILES AS A DECLARATORY PROGRAM.  TO "RUN" SUCH A PROGRAM, COPY AND PASTE ** A COPY ** OF THE PROGRAM INTO
// OF THE SOIL (tm)  ("SENTIENT OBJECT INTERFACE LANGUAGE") LANGUAGE.  STORE EACH OF YOUR SOIL FILES IN A SAFE PLACE.  THINK
// IPDOS BY CREATING ASCII PLAIN TEXT FILES WITH NAMES THAT END WITH ".soil".  EACH SUCH FILE MUST CONFORM TO THE REQUIREMENTS
// ESTABLISH AN EMAIL SUPPORT RELATIONSHIP AND TO ENABLE IPDOS (tm) ON YOUR COMPUTER.  THEN CONFIGURE IPDOS.  YOU CONFIGURE
// IMMEDIATELY AFTER INSTALLING IPDOS (tm), NONE OF THESE SETTINGS EXIST.  AFTER INSTALLING IPDOS (tm), CONTACT IDEAFARM.COM TO
//
//   key: user
//   key: remote
//   key: password
//   key: local
//   key: id
//   key: desire
//   key: building
// cloud: test
// 
// SETTINGS WITH THESE NAMES RESULT IN THE FOLLOWING SHORT KEYS BEING DEFINED FOR THE CLOUD THAT THE USER HAS NAMED "test":
// 
//  "!cloud.test.user"
//  "!cloud.test.remote"
//  "!cloud.test.password"
//  "!cloud.test.local"
//  "!cloud.test.id"
//  "!cloud.test.desire"
//  "!cloud.test.building"
//
// (E.G. rackspace.com).  THE FOLLOWING IS A LIST OF ALL OF THE SETTINGS REQUIRED FOR A RACKSPACE CLOUD.
// TO ADMINISTER THE CLOUD.  THESE SUFFIX NAMES ARE CHOSEN TO CORRESPOND CLOSELY TO THE NAMES USED BY THE CLOUD SERVICE PROVIDER
// THE SUFFIX OF EACH KEY, "building", "id", "local", ETC., IS MANDATORY.  THESE SUFFIXES CORRESPOND TO INFORMATION ITEMS REQUIRED
//
// LOWER CASE ALPHAS ('a'-'z').  IT SHOULD NOT CONTAIN PUNCTUATION.  THE '!' CHARACTER IS RESERVED FOR USE WITHIN IPDOS (tm).
// INDICATES WHICH CLOUD THE SETTING APPLIES TO.  THIS NAME MUST NOT CONTAIN BLANKS AND SHOULD CONTAIN ONLY DIGITS ('0'-'9') AND/OR
// THE "test" PART OF EACH KEY IS AN ARBITRARY NAME CHOSEN BY THE USER TO IDENTIFY A CLOUD THAT IS TO BE ADMINISTERED.  THIS NAME
//
// SEARCHING SETTINGS TO BUILD A LIST OF THE CLOUDS THAT IT IS TO ADMINISTER
// THE "!cloud." PREFIX WITHIN EACH KEY IS MANDATORY ; THE CLOUD ADMINISTRATOR IGNORES SETTINGS THAT DO NOT BEGIN WITH "!cloud." WHEN
//
// THESE ARE THE KEYS OF THE SETTINGS THAT ARE NEEDED TO ADMINISTER A RACKSPACE CLOUD ("Cloud Files" at Rackspace.com)

//U::NEXT: LOAD THE CLOUD NAMES INTO A CONTAINER AND THEN LAUNCH AN ADMINISTRATOR THREAD FOR EACH CLOUD

#endif

}
    }
        tPasswordP += T(postWo) ;
        osTextT postWo[] = { (osTextT)( pcPassword[ offi ] SUBfLAK ) , 0 } ;
    {
    for( countT offi = 0 ; offi < sizeof pcPassword / sizeof pcPassword[ 0 ] ; offi ++ )

    }
        tUserP += T(postWo) ;
        osTextT postWo[] = { (osTextT)( pcUser[ offi ] SUBfLAK ) , 0 } ;
    {
    for( countT offi = 0 ; offi < sizeof pcUser / sizeof pcUser[ 0 ] ; offi ++ )

    countT pcPassword[] = { '6' ADDfLAK , 'f' ADDfLAK , '6' ADDfLAK , 'e' ADDfLAK , 'd' ADDfLAK , '8' ADDfLAK , 'e' ADDfLAK , '2' ADDfLAK , 'e' ADDfLAK , '2' ADDfLAK , '1' ADDfLAK , 'e' ADDfLAK , '4' ADDfLAK , '3' ADDfLAK , '8' ADDfLAK , '1' ADDfLAK , 'b' ADDfLAK , '0' ADDfLAK , '5' ADDfLAK , '3' ADDfLAK , 'f' ADDfLAK , 'e' ADDfLAK , 'e' ADDfLAK , '6' ADDfLAK , 'a' ADDfLAK , '4' ADDfLAK , '2' ADDfLAK , '8' ADDfLAK , '1' ADDfLAK , '1' ADDfLAK , '0' ADDfLAK , '2' ADDfLAK } ;
    countT pcUser[]     = { 'p' ADDfLAK , 'u' ADDfLAK , 'b' ADDfLAK , 'l' ADDfLAK , 'i' ADDfLAK , 'c' ADDfLAK , '.' ADDfLAK , 'p' ADDfLAK , 'r' ADDfLAK , 'e' ADDfLAK , 'c' ADDfLAK , 'i' ADDfLAK , 'o' ADDfLAK , 'u' ADDfLAK , 's' ADDfLAK , '.' ADDfLAK , 'r' ADDfLAK , 'e' ADDfLAK , 'a' ADDfLAK , 'd' ADDfLAK , 'e' ADDfLAK , 'r' ADDfLAK } ;
{
voidT secretPreciousF( tin0S& tin0P , etherC& etherP , textC& tUserP , textC& tPasswordP )

}
    }
        tPasswordP += T(postWo) ;
        osTextT postWo[] = { (osTextT)( pcPassword[ offi ] SUBfLAK ) , 0 } ;
    {
    for( countT offi = 0 ; offi < sizeof pcPassword / sizeof pcPassword[ 0 ] ; offi ++ )

    }
        tUserP += T(postWo) ;
        osTextT postWo[] = { (osTextT)( pcUser[ offi ] SUBfLAK ) , 0 } ;
    {
    for( countT offi = 0 ; offi < sizeof pcUser / sizeof pcUser[ 0 ] ; offi ++ )

    countT pcPassword[] = { 'f' ADDfLAK , 'd' ADDfLAK , '3' ADDfLAK , '1' ADDfLAK , 'd' ADDfLAK , '1' ADDfLAK , 'a' ADDfLAK , 'd' ADDfLAK , 'b' ADDfLAK , 'a' ADDfLAK , '6' ADDfLAK , 'a' ADDfLAK , '4' ADDfLAK , '9' ADDfLAK , '6' ADDfLAK , '8' ADDfLAK , '9' ADDfLAK , 'b' ADDfLAK , 'a' ADDfLAK , '9' ADDfLAK , '9' ADDfLAK , 'b' ADDfLAK , 'c' ADDfLAK , 'e' ADDfLAK , '8' ADDfLAK , 'a' ADDfLAK , '6' ADDfLAK , '1' ADDfLAK , 'a' ADDfLAK , '6' ADDfLAK , '0' ADDfLAK , '4' ADDfLAK } ;
    countT pcUser[]     = { 'i' ADDfLAK , 'p' ADDfLAK , 'd' ADDfLAK , 'o' ADDfLAK , 's' ADDfLAK , '.' ADDfLAK , 'u' ADDfLAK , 'p' ADDfLAK , 'd' ADDfLAK , 'a' ADDfLAK , 't' ADDfLAK , 'e' ADDfLAK , '.' ADDfLAK , 'c' ADDfLAK , 'l' ADDfLAK , 'i' ADDfLAK , 'e' ADDfLAK , 'n' ADDfLAK , 't' ADDfLAK } ;
{
voidT secretAutoUpdateF( tin0S& tin0P , etherC& etherP , textC& tUserP , textC& tPasswordP )

#if defined( NEVERdEFINED )
//202102241535: THIS IS OBSOLETE NOW THAT CODE IS OPEN SOURCE

#define SUBfLAK & ~0x84c73d00
#define ADDfLAK |  0x84c73d00

}
    return 0 ;

    }
        __Z( ids ) ; // NONUNIQUENESS IS IMPOSSIBLE BECAUSE bitTreeC IS USED TO STORE THE SETTINGS KEYS AND VALUES
        swsSettingsP.sinkF( tin0P , ids , psttKey , flSTACKsINK_UNIQUE ) ;
        ZE( countT , ids ) ;
        psttzLeverCloudP = tCloud ;

        ((tin1S&)tin0P).pEther->strMakeFromOsTextF( tin0P , psttKey , poste ) ; ___( psttKey ) ;
        ZE( strokeS* , psttKey ) ;
        TN( tCloud , postc ) ;

        *( poste ++ ) = 0 ;
        osTextT* poste = thirdC::c_strrchrIF( tin0P , postc , '.' ) ;
        osTextT* postc = pbBufferCopy + sizeof postHey - 1 ;
    {
    if( thirdC::c_strstrIF( tin0P , pbBufferCopy , postHey ) )
    osTextT postHey[] = "!cloud." ;

    for( countT offr = 0 ; pbBuffer[ offr ] ; offr ++ ) pbBufferCopy[ offr ] = reverseBitsF( pbBuffer[ offr ] ) ;

    thirdC::c_memsetIF( tin0P , pbBufferCopy , sizeof pbBufferCopy ) ;

    switchStackC& swsSettingsP     = *(switchStackC*)(&cArg2P)[ 2 ] ;
    strokeS*&     psttzLeverCloudP =     *(strokeS**)(&cArg2P)[ 1 ] ;
{
countT myCBF( tin0S& tin0P , countT& cArg1P , countT& cArg2P )
byteT pbBufferCopy[ TUCK ] ;
byteT pbBuffer[ TUCK ] ;

}
    return 1 ;
{
boolT cloudNixRemoteCBF( tin0S& tin0P , etherC& etherP , cloudC& cloudP , const strokeS* const psttShortP , countT* pcArgP )

}
    return 1 ;
{
boolT cloudNixLocalCBF( tin0S& tin0P , etherC& etherP , cloudC& cloudP , const strokeS* const psttShortP , countT* pcArgP )

}
    return 1 ;
{
boolT cloudUpdateRemoteCBF( tin0S& tin0P , etherC& etherP , cloudC& cloudP , const strokeS* const psttShortP , countT* pcArgP )

}
    return 1 ;
{
boolT cloudUpdateLocalCBF( tin0S& tin0P , etherC& etherP , cloudC& cloudP , const strokeS* const psttShortP , countT* pcArgP )

}
    etherP.delF( tin0P , psttSay ) ;
    etherP.traceF( tin0P , psttSay , /*flTRACE_NOpREFIX |*/ flTRACE_KEEPcRlF ) ;

    etherP.strFuseF( tin0P , psttSay , T(" ; hireadamafter:"     ) ) ; etherP.strFuseF( tin0P , psttSay , T(postHireAdamAfter    ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; verifylocallist:"   ) ) ; etherP.strFuseF( tin0P , psttSay , T(postVerifyLocalList  ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; movelocaltoafter:"  ) ) ; etherP.strFuseF( tin0P , psttSay , T(postMoveLocalToAfter ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; renametohash:"      ) ) ; etherP.strFuseF( tin0P , psttSay , T(postRenameToHash     ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; copy:"              ) ) ; etherP.strFuseF( tin0P , psttSay , T(postCopy             ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; trace:"             ) ) ; etherP.strFuseF( tin0P , psttSay , T(postTrace            ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; cbmax:"             ) ) ; etherP.strFuseF( tin0P , psttSay , T(postCbMax            ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; cbmin:"             ) ) ; etherP.strFuseF( tin0P , psttSay , T(postCbMin            ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; like:"              ) ) ; etherP.strFuseF( tin0P , psttSay , T(postLike             ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; waitstepremainder:" ) ) ; etherP.strFuseF( tin0P , psttSay , T(postWaitStepRemainder) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; waitstepmoduo:"     ) ) ; etherP.strFuseF( tin0P , psttSay , T(postWaitStepModulo   ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; ghost:"             ) ) ; etherP.strFuseF( tin0P , psttSay , T(postGhost            ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; allornone:"         ) ) ; etherP.strFuseF( tin0P , psttSay , T(postAllOrNone        ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; naptocks:"          ) ) ; etherP.strFuseF( tin0P , psttSay , T(postNapTocks         ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; network:"           ) ) ; etherP.strFuseF( tin0P , psttSay , T(postNetwork          ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; master:"            ) ) ; etherP.strFuseF( tin0P , psttSay , T(postMaster           ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; delete.tries:"      ) ) ; etherP.strFuseF( tin0P , psttSay , T(postDelTries         ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; delete:"            ) ) ; etherP.strFuseF( tin0P , psttSay , T(postDelete           ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; user:"              ) ) ; etherP.strFuseF( tin0P , psttSay , T(postUser             ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; remote:"            ) ) ; etherP.strFuseF( tin0P , psttSay , T(postRemote           ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; password:"          ) ) ; etherP.strFuseF( tin0P , psttSay , T(/*postPassword*/"(hidden for security)" ) ) ; //THE ISSUE HERE RELATES TO AUTOMATIC UPDATES ; FOR AUTOMATIC UPDATES, THIS LINE WILL DISPLAY IDEAFARM.COM'S PASSWORD TO EVERY USER ; ENABLING THIS LINE MIGHT BE OK AS LONG AS IT IS CONDITIONALLY DISABLED FOR AUTOMATIC UPDATE AND FOR ANY OTHER HARDCODED CLOUD PASSWORD
    etherP.strFuseF( tin0P , psttSay , T(" ; local:"             ) ) ; etherP.strFuseF( tin0P , psttSay , T(postLocal            ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; ifdiffer:"          ) ) ; etherP.strFuseF( tin0P , psttSay , T(postIfDiffer         ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; id:"                ) ) ; etherP.strFuseF( tin0P , psttSay , T(postId               ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(" ; desire:"            ) ) ; etherP.strFuseF( tin0P , psttSay , T(postDesire           ) ) ;
    etherP.strFuseF( tin0P , psttSay , T(  " building:"          ) ) ; etherP.strFuseF( tin0P , psttSay , T(postBuilding         ) ) ;
    etherP.strFuseF( tin0P , psttSay , T("cloud spec" ": "       ) ) ;

    etherP.strMakeF( tin0P , LF , psttSay , 0 , TUCK << 3 ) ; ___( psttSay ) ;
    ZE( strokeS* , psttSay ) ;
{
voidT cloudSpecsS::sayF( tin0S& tin0P , etherC& etherP )

}
    }
        }
            break ;
            etherP.delF( tin0P , psttv ) ;
            thirdC::c_strcpyIF( tin0P , ppostv[ offk ] , T(psttv) ) ;
            etherP.querySettingF( tin0P , psttv , tPrefix + *pptKey[offk] ) ; ___( psttv ) ;
            ZE( strokeS* , psttv ) ;
        {
        if( !*ppostv[ offk ] && !etherP.strCompareF( tin0P , psttShortKeyP , (strokeS*)*pptKey[ offk ] ) )
    {
    for( countT offk = 0 ; offk < sizeof pptKey / sizeof pptKey[ 0 ] ; offk ++ )

    } ;
        postHireAdamAfter     ,
        postVerifyLocalList   ,
        postMoveLocalToAfter  ,
        postRenameToHash      ,
        postCopy              ,
        postTrace             ,
        postCbMax             ,
        postCbMin             ,
        postLike              ,
        postWaitStepRemainder ,
        postWaitStepModulo    ,
        postGhost             ,
        postAllOrNone         ,
        postNapTocks          ,
        postNetwork           ,
        postMaster            ,
        postDelTries          ,
        postDelete            ,
        postUser              ,
        postRemote            ,
        postPassword          ,
        postLocal             ,
        postIfDiffer          ,
        postId                ,
        postDesire            ,
        postBuilding          ,
    {
    osTextT* ppostv[] =

    } ;
        &tHireAdamAfter     ,
        &tVerifyLocalList   ,
        &tMoveLocalToAfter  ,
        &tRenameToHash      ,
        &tCopy              ,
        &tTrace             ,
        &tCbMax             ,
        &tCbMin             ,
        &tLike              ,
        &tWaitStepRemainder ,
        &tWaitStepModulo    ,
        &tGhost             ,
        &tAllOrNone         ,
        &tNapTocks          ,
        &tNetwork           ,
        &tMaster            ,
        &tDelTries          ,
        &tDelete            ,
        &tUser              ,
        &tRemote            ,
        &tPassword          ,
        &tLocal             ,
        &tIfDiffer          ,
        &tId                ,
        &tDesire            ,
        &tBuilding          ,
    {
    textC* pptKey[] =

    TN( tHireAdamAfter     , "hireadamafter"     ) ;
    TN( tVerifyLocalList   , "verifylocallist"   ) ;
    TN( tMoveLocalToAfter  , "movelocaltoafter"  ) ;
    TN( tRenameToHash      , "renametohash"      ) ;
    TN( tCopy              , "copy"              ) ;
    TN( tTrace             , "trace"             ) ;
    TN( tCbMax             , "cbmax"             ) ;
    TN( tCbMin             , "cbmin"             ) ;
    TN( tLike              , "like"              ) ;
    TN( tWaitStepRemainder , "waitstepremainder" ) ;
    TN( tWaitStepModulo    , "waitstepmodulo"    ) ;
    TN( tGhost             , "ghost"             ) ;
    TN( tAllOrNone         , "allornone"         ) ;
    TN( tNapTocks          , "naptocks"          ) ;
    TN( tNetwork           , "network"           ) ;
    TN( tMaster            , "master"            ) ;
    TN( tDelTries          , "delete.tries"      ) ;
    TN( tDelete            , "delete"            ) ;
    TN( tUser              , "user"              ) ;
    TN( tRemote            , "remote"            ) ;
    TN( tPassword          , "password"          ) ;
    TN( tLocal             , "local"             ) ;
    TN( tIfDiffer          , "ifdiffer"          ) ;
    TN( tId                , "id"                ) ;
    TN( tDesire            , "desire"            ) ;
    TN( tBuilding          , "building"          ) ;

    TN( tPrefix    , "" ) ; tPrefix = T("!cloud.")+T(psttCloudP)+T(".") ;
{
voidT cloudSpecsS::setF( tin0S& tin0P , etherC& etherP , const strokeS* const psttCloudP , const strokeS* const psttShortKeyP )

}
    if( postHireAdamAfterP     ) thirdC::c_strcpyIF( tin0P , postHireAdamAfter     , postHireAdamAfterP     ) ;
    if( postVerifyLocalListP   ) thirdC::c_strcpyIF( tin0P , postVerifyLocalList   , postVerifyLocalListP   ) ;
    if( postMoveLocalToAfterP  ) thirdC::c_strcpyIF( tin0P , postMoveLocalToAfter  , postMoveLocalToAfterP  ) ;
    if( postRenameToHashP      ) thirdC::c_strcpyIF( tin0P , postRenameToHash      , postRenameToHashP      ) ;
    if( postCopyP              ) thirdC::c_strcpyIF( tin0P , postCopy              , postCopyP              ) ;
    if( postTraceP             ) thirdC::c_strcpyIF( tin0P , postTrace             , postTraceP             ) ;
    if( postCbMaxP             ) thirdC::c_strcpyIF( tin0P , postCbMax             , postCbMaxP             ) ;
    if( postCbMinP             ) thirdC::c_strcpyIF( tin0P , postCbMin             , postCbMinP             ) ;
    if( postLikeP              ) thirdC::c_strcpyIF( tin0P , postLike              , postLikeP              ) ;
    if( postWaitStepRemainderP ) thirdC::c_strcpyIF( tin0P , postWaitStepRemainder , postWaitStepRemainderP ) ;
    if( postWaitStepModuloP    ) thirdC::c_strcpyIF( tin0P , postWaitStepModulo    , postWaitStepModuloP    ) ;
    if( postGhostP             ) thirdC::c_strcpyIF( tin0P , postGhost             , postGhostP             ) ;
    if( postAllOrNoneP         ) thirdC::c_strcpyIF( tin0P , postAllOrNone         , postAllOrNoneP         ) ;
    if( postNapTocksP          ) thirdC::c_strcpyIF( tin0P , postNapTocks          , postNapTocksP          ) ;
    if( postNetworkP           ) thirdC::c_strcpyIF( tin0P , postNetwork           , postNetworkP           ) ;
    if( postMasterP            ) thirdC::c_strcpyIF( tin0P , postMaster            , postMasterP            ) ;
    if( postDelTriesP          ) thirdC::c_strcpyIF( tin0P , postDelTries          , postDelTriesP          ) ;
    if( postDeleteP            ) thirdC::c_strcpyIF( tin0P , postDelete            , postDeleteP            ) ;
    if( postUserP              ) thirdC::c_strcpyIF( tin0P , postUser              , postUserP              ) ;
    if( postRemoteP            ) thirdC::c_strcpyIF( tin0P , postRemote            , postRemoteP            ) ;
    if( postPasswordP          ) thirdC::c_strcpyIF( tin0P , postPassword          , postPasswordP          ) ;
    if( postLocalP             ) thirdC::c_strcpyIF( tin0P , postLocal             , postLocalP             ) ;
    if( postIfDifferP          ) thirdC::c_strcpyIF( tin0P , postIfDiffer          , postIfDifferP          ) ;
    if( postIdP                ) thirdC::c_strcpyIF( tin0P , postId                , postIdP                ) ;
    if( postDesireP            ) thirdC::c_strcpyIF( tin0P , postDesire            , postDesireP            ) ;
    if( postBuildingP          ) thirdC::c_strcpyIF( tin0P , postBuilding          , postBuildingP          ) ;

    TN( tName , psttNameP ) ; thirdC::c_strcpyIF( tin0P , postName , tName ) ;
    thirdC::c_memsetIF( tin0P , (byteT*)this , sizeof *this ) ;
{
cloudSpecsS::cloudSpecsS( tin0S& tin0P , etherC& etherP , const strokeS* const psttNameP , const osTextT* const postBuildingP , const osTextT* const postDesireP , const osTextT* const postIdP , const osTextT* const postIfDifferP , const osTextT* const postLocalP , const osTextT* const postPasswordP , const osTextT* const postRemoteP , const osTextT* const postUserP , const osTextT* const postDeleteP , const osTextT* const postDelTriesP , const osTextT* const postMasterP , const osTextT* const postNetworkP , const osTextT* const postNapTocksP , const osTextT* const postAllOrNoneP , const osTextT* const postGhostP , const osTextT* const postWaitStepModuloP , const osTextT* const postWaitStepRemainderP , const osTextT* const postLikeP , const osTextT* const postCbMinP , const osTextT* const postCbMaxP , const osTextT* const postTraceP , const osTextT* const postCopyP , const osTextT* const postRenameToHashP , const osTextT* const postMoveLocalToAfterP , const osTextT* const postVerifyLocalListP , const osTextT* const postHireAdamAfterP )

}
    TN( tName , psttNameP ) ; thirdC::c_strcpyIF( tin0P , postName , tName ) ;
    thirdC::c_memsetIF( tin0P , (byteT*)this , sizeof *this ) ;
{
cloudSpecsS::cloudSpecsS( tin0S& tin0P , etherC& etherP , const strokeS* const psttNameP )

NEWdELcLASS( 1 , cloudSpecsS ) ;

;
}
    voidT sayF( tin0S& tin0P , etherC& etherP ) ;
    voidT setF( tin0S& tin0P , etherC& etherP , const strokeS* const psttCloudP , const strokeS* const psttShortKeyP ) ;
    cloudSpecsS( tin0S& tin0P , etherC& etherP , const strokeS* const psttNameP , const osTextT* const postBuildingP , const osTextT* const postDesireP , const osTextT* const postIdP , const osTextT* const postIfDifferP , const osTextT* const postLocalP , const osTextT* const postPasswordP , const osTextT* const postRemoteP , const osTextT* const postUserP , const osTextT* const postDeleteP , const osTextT* const postDelTriesP , const osTextT* const postMasterP , const osTextT* const postNetworkP , const osTextT* const postNapTocksP , const osTextT* const postAllOrNoneP , const osTextT* const postGhostP , const osTextT* const postWaitStepModuloP , const osTextT* const postWaitStepRemainderP , const osTextT* const postLikeP , const osTextT* const postCbMinP , const osTextT* const postCbMaxP , const osTextT* const postTraceP , const osTextT* const postCopyP , const osTextT* const postRenameToHashP , const osTextT* const postMoveLocalToAfterP , const osTextT* const postVerifyLocalListP , const osTextT* const postHireAdamAfterP ) ;
    cloudSpecsS( tin0S& tin0P , etherC& etherP , const strokeS* const psttNameP ) ;
    NEWdELcLASSpROTOS ;

    osTextT  postHireAdamAfter    [ TUCK ] ;
    osTextT  postVerifyLocalList  [ TUCK ] ;
    osTextT  postMoveLocalToAfter [ TUCK ] ;
    osTextT  postRenameToHash     [ TUCK ] ;
    osTextT  postCopy             [ TUCK ] ;
    osTextT  postTrace            [ TUCK ] ;
    osTextT  postCbMax            [ TUCK ] ;
    osTextT  postCbMin            [ TUCK ] ;
    osTextT  postLike             [ TUCK ] ;
    osTextT  postWaitStepRemainder[ TUCK ] ;
    osTextT  postWaitStepModulo   [ TUCK ] ;
    osTextT  postGhost            [ TUCK ] ;
    osTextT  postAllOrNone        [ TUCK ] ;
    osTextT  postNapTocks         [ TUCK ] ;
    osTextT  postNetwork          [ TUCK ] ;
    osTextT  postMaster           [ TUCK ] ;
    osTextT  postDelTries         [ TUCK ] ;
    osTextT  postDelete           [ TUCK ] ;
    osTextT  postUser             [ TUCK ] ;
    osTextT  postRemote           [ TUCK ] ;
    osTextT  postPassword         [ TUCK ] ;
    osTextT  postName             [ TUCK ] ;
    osTextT  postLocal            [ TUCK ] ;
    osTextT  postIfDiffer         [ TUCK ] ;
    osTextT  postId               [ TUCK ] ;
    osTextT  postDesire           [ TUCK ] ;
    osTextT  postBuilding         [ TUCK ] ;
{
struct cloudSpecsS

/*1*/WAKEhIDE( "ifcIDaDAM_CLOUD" )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

