
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#undef MYaLLOC

}
    }
        *(flagsT*)&flagsCtBook &= ~( F(flBOOKc_RESETcREFoNcT) ) ;
        touchAllBooksF( tin0P , &bnu ) ;
        ZE( boolT , bnu ) ;
    {
    if( !POOP && ((tin1S&)tin0P).pPoolUse && F(flagsP) & flBOOKSc_RESETcREFoNcT )

    THREADmODE3rESTORE

    //CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal4S::_processGlobal4I_IF().heap.cNewF()-processGlobal4S::_processGlobal4I_IF().heap.cDelF() , "    \r\n" ) ;

    //if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->trace F( tin0P , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": ")+T(postShort)+T(": ")+T("ct - [offBookBackNow,CbOOKsLOTS]:    ")+TF2(offBookBackNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(CbOOKsLOTS,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG

    }
        else if( this == &processGlobal4I.bksWords ) processGlobal2I.flCt |= flCTdTg_bksWords        ;
        else if( this == &processGlobal4I.bksWord  ) processGlobal2I.flCt |= flCTdTg_bksWord         ;
        }
#endif
            THREADmODE4rESTORE
            processGlobal4I.bkTelemetryAppEarlyLate.purgeF( tin0P ) ;
            writeF( tin0P , pbi , cbi , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ELSEfILLtOeND , 0 ) ;

            //}
            //    etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
            //
            //    OStEXTC(  ostoSay , cbi , 0 ) ;
            //    OStEXTAK( ostoSay , "booksC: pouring early application telemetry [cbi]:    " ) ;
            //    OStEXT(   ostoSay , TUCK << 1 ) ;
            //{

            processGlobal4I.bkTelemetryAppEarlyLate.readF( tin0P , pbi , cbi , offi ) ;      //U:: THIS STUDY IS LOW PRIORITY BECAUSE THE PENDING BUFFER DOES NOT YET EXIST AND 0 TELEMETRY IS POURED
            THREADmODE4oN( flTHREADmODE4_DOnOTfLUSHpENDINGaPPtELEMETRY ) ;                  //U:: WARRANTS FURTHER STUDY AND CRAFTWORK ; THE GOAL IS TO PREVENT OUT OF ORDER APP TELEMETRY DO TO APP TELEMETRY GENERATED DURING THIS POUR OPERATION
            ZE( countT , offi ) ;
            countT cbi = - 1 ;
            ZE( const byteT* , pbi  ) ;

            processGlobal2I.flCt |= flCTdTg_bksTelemetryApp ;
#if defined( NEVERdEFINED )
//U::TO FIND A BUG
        {
        else if( this == &processGlobal4I.bksTelemetryApp )
        }
            processGlobal4I.bkTelemetrySysEarlyLate.purgeF( tin0P ) ;
            writeF( tin0P , pbi , cbi , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ELSEfILLtOeND , 0 ) ;

            //}
            //    etherC::etRockIF( tin0P ).traceF( tin0P , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
            //
            //    OStEXTC(  ostoSay , cbi , 0 ) ;
            //    OStEXTAK( ostoSay , "booksC: pouring early system telemetry [cbi]:    " ) ;
            //    OStEXT(   ostoSay , TUCK << 1 ) ;
            //{

            processGlobal4I.bkTelemetrySysEarlyLate.readF( tin0P , pbi , cbi , offi ) ;
            ZE( countT , offi ) ;
            countT cbi = - 1 ;
            ZE( const byteT* , pbi  ) ;

            processGlobal2I.flCt |= flCTdTg_bksTelemetrySys ;
        {
        if( this == &processGlobal4I.bksTelemetrySys )
    
        if( PCPiDbOOKnOW[ 0 ] == 1 && PCPiDbOOKnOW[ 1 ] == 1 ) ((bookHeadS&)BOOKnOW).flags |= flBOOKhEADs_PRIORbOOKnOTcONTINUEDhERE ;

        NEWbOOK2sETfLAG
        THREADmODE3rESTORE
        new( 0 , tin0P , PBbOOKbACKnOW , SIZEOF_bookC ) bookC( tin0P , idLineCtP , idiFileCtP , pbBitsCtP , postBookNameScratch , idStateSpace , flagsCtBook , F(flagsCtBook) & flBOOKc_WRITER ? cbBodyNew : 0 , bFill , idMemorySpace ) ;
        THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
        NEWbOOK1bLAMMOiFcT
    {
    if( !POOP )

    if( pbQuitP && *pbQuitP ) { __1 ; }     //20210707@1320: ADDED BECAUSE NOW setBookNameIdF WILL RETURN ON *pbQuit EVEN IF NO BOOK FILES EXIST

    //CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal4S::_processGlobal4I_IF().heap.cNewF()-processGlobal4S::_processGlobal4I_IF().heap.cDelF() , "    called setBookNameIdF\r\n" ) ;
    setBookNameIdF( tin0P , F(flagsCt) & flBOOKSc_PURGEoNcT ? flBOOKScsELECT_PURGE : flBOOKScsELECT_null , 0 , pbQuitP ) ;
    //CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal4S::_processGlobal4I_IF().heap.cNewF()-processGlobal4S::_processGlobal4I_IF().heap.cDelF() , "    \r\n" ) ;

    //if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->trace F( tin0P , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": ")+T(postShort)+T(": ")+T("ct [offBookBackNow]: ")+TF2(offBookBackNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(": ct / incremented") ) ; //U:: TO FIND A BUG
    offBookBackNow ++ ;

    }
        //CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal4S::_processGlobal4I_IF().heap.cNewF()-processGlobal4S::_processGlobal4I_IF().heap.cDelF() , "    psttFindLike\r\n" ) ;
        }
            }
                ((tin1S&)tin0P).pEther->strMakeF( tin0P , LF , psttFindLike , tLike ) ; ___( psttFindLike ) ;

                ;
                    :                                                                                                                                                                                                                                                           T(postShort)+T(".booksC.1.book.*.bookC")
                    ? T(thirdC::postUserNameIF())+T(".")+TF3(idMemorySpace?idMemorySpace:((tin1S&)tin0P).pag1->idMemorySpace,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(".")+TF2(idStateSpace,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(".")+T(postShort)+T(".booksC.1.book.*.bookC")
                tLike += !( F(flagsCt) & flBOOKSc_NOsHORTfILENAMEpREFIX )

                TN( tLike , iffn ) ;

                ifFileNameC iffn( tin0P , *((tin1S&)tin0P).pEther , postPath ) ;
            {
            else
            }
                ((tin1S&)tin0P).pEther->strMakeF( tin0P , LF , psttFindLike , tLike ) ; ___( psttFindLike ) ;
                tLike += T("/ideafarm/ipdos/memorySpaces/")+T(thirdC::postUserNameIF())+T("/")+TfORsTRING(idMemorySpace?idMemorySpace:((tin1S&)tin0P).pag1->idMemorySpace)+T("/stateSpaces/")+TfORsTRING(idStateSpace)+T("/")+T(postShort)+T(".booksC.1.book.*.bookC") ;
                TN( tLike , "///ideafarm/ephemeral/backed.up.daily/domains/com" ) ;
            {
            if( !*postPath )
        {
        if( !( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE ) )
        //CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal4S::_processGlobal4I_IF().heap.cNewF()-processGlobal4S::_processGlobal4I_IF().heap.cDelF() , "    \r\n" ) ;

        thirdC::c_memsetIF( tin0P , pbNapReadCursor , sizeof pbNapReadCursor ) ; // WOTH COUNT: MUST BE 0 IFF CURSOR NAPKIN IS NOT CT    //A:ASSUME: napkinC IMAGE ALWAYS BEGINS WITH A NONZE countT VALUE

        }
            thirdC::c_memsetIF( tin0P , *(byteT**)&ppcpIdBook[ offb ] , cbaIdBook ) ;
        {
        for( countT offb = 0 ; offb < CbOOKsLOTS ; offb ++ )

        }
            }
                *(byteT**)&ppcpIdBook[ offb ] = processGlobal4I.heap.newF( tin0P , idLineCtP , idiFileCtP , cbaIdBook ) ;
            {
            for( countT offb = 0 ; offb < CbOOKsLOTS ; offb ++ )

            thirdC::c_memsetIF( tin0P , *(byteT**)&ppcpIdBook , cbaPointers ) ;
            thirdC::c_memsetIF( tin0P , pbFlagsiBookBackCt    , cbaFlags    ) ;

            *(byteT**)&ppcpIdBook          = processGlobal4I.heap.newF( tin0P , idLineCtP , idiFileCtP , cbaPointers   ) ;
            *(byteT**)&pcpIdBookScratchMax = processGlobal4I.heap.newF( tin0P , idLineCtP , idiFileCtP , cbaIdBook     ) ;
            *(byteT**)&pcpIdBookScratchMin = processGlobal4I.heap.newF( tin0P , idLineCtP , idiFileCtP , cbaIdBook     ) ;
            *(byteT**)&pcpIdBookScratch1   = processGlobal4I.heap.newF( tin0P , idLineCtP , idiFileCtP , cbaIdBook     ) ;
            pbFlagsiBookBackCt             = processGlobal4I.heap.newF( tin0P , idLineCtP , idiFileCtP , cbaFlags      ) ;
            pbBookBack                     = processGlobal4I.heap.newF( tin0P , idLineCtP , idiFileCtP , cbaBooks      ) ;
            postBookNameScratch            = processGlobal4I.heap.newF( tin0P , idLineCtP , idiFileCtP , costaBookName ) ;

            byteT* const pbe = pbc + cbBooksNoPuseBackP ;
            byteT*       pbc = pbBooksNoPuseBackP ;
        {

        countT costaBookName = costaName + TUCK ; //U:: REPLACE "TUCK" WITH ACTUAL NEEDED
        countT costaName     = 1 + thirdC::c_strlenIF( tin0P , postShortOrLongP )     ;
        countT cbaFlags      = 1 + ( CbOOKsLOTS ) / SB ;
        countT cbaBooks      = ( CbOOKsLOTS ) * SIZEOF_bookC       ;
        countT cbaPointers   = ( CbOOKsLOTS ) * sizeof( countT* )  ;
        countT cbaIdBook     = ccMaxIdBook * sizeof( countT )     ;
    {

    //CONoUTrAW3( "[heap.cNew-cDel]:    " , processGlobal4S::_processGlobal4I_IF().heap.cNewF()-processGlobal4S::_processGlobal4I_IF().heap.cDelF() , "    \r\n" ) ;

    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP | flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )

    }

        }
            __( thirdC::c_strchrIF( tin0P , postShort , ':' ) ) ;
            __( thirdC::c_strchrIF( tin0P , postShort , '\\' ) ) ;
        {
        if( *postShort )

        else if( thirdC::c_strlenIF( tin0P , postShortOrLongP ) + 1 < sizeof( postShort ) ) thirdC::c_strcpyIF( tin0P , postShort , postShortOrLongP ) ;
        }
            }
                else *postPath = 0 ;
                }
                    postPath[ costPath ] = 0 ;
                    thirdC::c_memcpyIF( tin0P , postPath , postShortOrLongP , costPath ) ;
                {
                if( costPath < sizeof postPath )

                countT costPath = postc - postShortOrLongP ;

                else                                                               *postShort = 0 ;
                if( thirdC::c_strlenIF( tin0P , postc ) + 1 < sizeof( postShort ) ) thirdC::c_strcpyIF( tin0P , postShort , postc ) ;
                postc ++ ;
            {
            if( postc )
            osTextT* postc = thirdC::c_strrchrIF( tin0P , postShortOrLongP , '\\' ) ;
        {
        )
            postShortOrLongP[ 2 ] == '\\'
            &&
            postShortOrLongP[ 0 ] <= 'z'
            &&
            postShortOrLongP[ 0 ] >= 'a'
            &&
            postShortOrLongP[ 1 ] == ':'
            &&
            postShortOrLongP
        (
        if                                              //IF LONG

        thirdC::c_memsetIF( tin0P , postFindLike , sizeof postFindLike ) ;
        thirdC::c_memsetIF( tin0P , postPath     , sizeof postPath     ) ;
        thirdC::c_memsetIF( tin0P , postShort    , sizeof postShort    ) ;
    {

    _IO_

    }
        if( POOP ) return ;
        __( idMemorySpaceP && !( F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tin0P ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tin0P ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;

        //20240330@1559: ADDED flBOOKSc_PURGEoNcTiFcLOAK
        //U:: DESIGN PROBLEM: INSTANCE SHARED BY MULTIPLE PROCESSES CANNOT PURGEoNcT: __NZ( F(flagsCt) & flBOOKSc_CYCLE && !( F(flagsCt) & flBOOKSc_PURGEoNcT ) ) ;

        __NZ( cbP && !( F(flagsP) & flBOOKSc_WRITER ) ) ;
        FV( flBOOKSc , flagsP ) ;
        }
            __Z( idStateSpaceP ) ; // !idStateSpaceP CAN BE ALLOWED IF THERE IS EVER A REASON TO DO SO, BUT THIS WOULD BE AN ODD APPLICATION BECAUSE THE CLIENT READER WOULD NEED TO KEEP UP WITH THE SERVER WRITER ; IF A SERVER WRITER FINISHED WRITING A bookC BEFORE THE CLIENT READER STARTED READING IT, THE DATA IN THE bookC WOULD BE LOST
        {
        else
        }
            __( CbOOKsLOTS > 2 ) ;
            __Z( cbBooksNoPuseBackP ) ;
            __Z( pbBooksNoPuseBackP ) ;
            __( !postShortOrLongP != !idStateSpaceP ) ;  //INSTANCES WITHOUT BACKING FILES MUST BE UNNAMED; THIS RESTRICTION CAN BE REMOVED ONCE I AM EDITED TO ENUMERATE SHARED MEMORY OBJECTS RATHER THAN BACKING FILES
            __( ((tin1S&)tin0P).glass.idThread != 1 ) ; //I WILL USE STATIC STORAGE SO WILL NOT BE THREAD SAFE; INTENDED ONLY FOR CT/DT OF INSTANCES IN STATIC STORAGE
        {
        if( F(flagsCt) & flBOOKSc_DOnOTuSEpUSE )
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP

    //CONJ: THE CYCLING ISSUE IS ONLY FOR CONSTRUCTION; WRITING IS ALREADY SERIALIZED SO SHOULD WORK OK.  THIS SUGGESTS THAT SERIALIZING CONSTRUCTION WITH WRITING MIGHT SUFFICE
    //NOTE: SINGLE THREADED CYCLING WORKS AOK FOR ANY CbOOKsLOTS VALUE
    //CONJ: THE CURRENT CODE (20160621@1450) WILL WORK AOK FOR SHARED CYCLING AS LONG AS CbOOKsLOTS IS 1
    //FOR CYCLING, MULTITHREADING AND SHARING BY MULTIPLE WRITING PROCESSES NEEDS TO BE THOUGHT ABOUT
    //FOR CYCLING, offbookBackNow MUST BE SET TO POINT TO THE BOOK THAT CURRENTLY CONTAINS THE MOST RECENT WRITING
    //FOR CYCLING, ALL EXISTING FILES MUST BE OPENED.  THIS IS NOT CURRENTLY DONE
    //U:: CYCLING IS CURRENTLY NOT SUPPORTED CORRECTLY WHEN CbOOKsLOTS IS NOT 1

    //if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->trace F( tin0P , TF3((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(": ")+T(postShort)+T(": ")+T("ct + [offBookBackNow,CbOOKsLOTS]:    ")+TF2(offBookBackNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(CbOOKsLOTS,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG
{
bFill( bFillP )
psttFindLike( 0 ) ,
ppcpIdBook( 0 ) ,
cKeepInactive( cKeepInactiveP ) ,
grabBookNow( tin0P , idLineCtP , idiFileCtP , pbBitsCtP , flGRABc_NOTjEALOUS | flGRABc_SNEAKYlOVER | flGRABc_SHARElAYER , ifcIDgRABlAYER_bBOOKSc ) , // flGRABc_SHARElAYER: NEEDED BECAUSE booksC::writeF CAN CALL ITSELF RECURSIVELY DUE TO TELEMETRY WHEN CHANGING bookC INSTANCES
idMemorySpace( idMemorySpaceP ) ,
idStateSpace( idStateSpaceP ) ,
cbBodyNew( cbP ) ,
postBookNameScratch( 0 ) ,
) ,
    ( F(flagsP) & flBOOKSc_NOsHORTfILENAMEpREFIX      ? flBOOKc_NOsHORTfILENAMEpREFIX      : flBOOKc_null )
    ( F(flagsP) & flBOOKSc_RESETcREFoNcT              ? flBOOKc_RESETcREFoNcT              : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_DOnOTsERIALIZEnAPKINS      ? flBOOKc_DOnOTsERIALIZEnAPKIN       : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_LOCK                       ? flBOOKc_LOCK                       : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_DOnOTiNITIALIZEdATA        ? flBOOKc_DOnOTiNITIALIZEdATA        : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_USEgRABmEMORYsPACEoVERRIDE ? flBOOKc_USEgRABmEMORYsPACEoVERRIDE : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_DOnOTrEGISTERfILE          ? flBOOKc_DOnOTrEGISTERfILE          : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_DOnOTuSEpUSE               ? flBOOKc_DOnOTuSEpUSE               : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_WRITER                     ? flBOOKc_WRITER                     : flBOOKc_null ) |
    ( F(flagsP) & flBOOKSc_DELETE                     ? flBOOKc_DELETE                     : flBOOKc_null ) |
(
flagsCtBook
flagsCt( F(flagsP) & flBOOKSc_PURGEoNcTiFcLOAK && processGlobal1I.idAdamRoot == ifcIDaDAM_CLOAK ? flagsP | flBOOKSc_PURGEoNcT : flagsP ) ,
offBookBackNow( - 1 ) ,
pbFlagsiBookBackCt( 0 ) ,
pbBookBack( 0 ) ,
pcpIdBookScratchMax( 0 ) ,
pcpIdBookScratchMin( 0 ) ,
pcpIdBookScratch1(    0 ) ,
ccMaxIdBook( TUCK >> 5 ) , //20190116@0943: REDUCED FROM TUCK TO TUCK >> 5 IN ORDER TO CONSERVE heapC USAGE; AS OF THIS WRITING SOME CODE SUPPORTS LENGTHS > 1 COUNT BUT OTHER CODE LIMITS NAME TO A SINGLE COUNT
poop( flPOOP_null ) ,   //20210707@1329: CHANGED FROM "SMELLY" ; CONSTRUCTING CODE NOW MUST TEST WHETHER *this IS IMPOTENT BEFORE USING ; THIS CHANGE WAS MADE TO ALLOW tmEatTelemetryF TO TERMINATE FOR MEMORY SPACES THAT HAVE NO booksC FILES ; IMPACT ON OTHER CODE WAS NOT ANALYZED
/*1*/booksC::booksC( tin0S& tin0P , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postShortOrLongP , const countT idStateSpaceP , const flagsT flagsP , const countT cbP , const countT cKeepInactiveP , const byteT bFillP , byteT* const pbBooksNoPuseBackP , const countT cbBooksNoPuseBackP , const countT idMemorySpaceP , const boolT* pbQuitP ) :/*1*/

#define MYaLLOC(lvalueP,cbP) { if( pbc + cbP > pbe ) { BLAMMO ; } else { (lvalueP) = pbc ; pbc += (cbP) ; } }

/**/
*/
   if constructor quits then the instance will become impotent
  if not 0 then constructor will quit waiting for a backing file to appear when *pbQuitP becomes nonze
  if 0 then constructor will not return until it has seen at least wo backing file
  if not 0 then points to boolT
  can be 0
  affects only construction
 pbQuitP
 cbBooksNoPuseBackP
  this backing memory is use if, and only if, flBOOKSc_DOnOTuSEpUSE
 pbBooksNoPuseBackP
 cKeepInactiveP
 cbP
 flagsP
  if 0 then instance does not persist after lath referencing process ends
  can be 0
 idStateSpaceP
  coding style: network drives should be avoided unless you understand the limitations of using memory mapping on networked files (e.g. lack of coherence)
   illegal:          "\folder1\folder2\folder3\bksFoo"
   example: long:  "c:\folder1\folder2\folder3\bksFoo"
   example: short: "bksFoo"
  this is either a short file name or a fully qualified long filename
    document the requirement in a comment
    use a string literal whenever feasible
   coding conformance
  if flBOOKSc_DOnOTuSEpUSE then postP must point to storage that will remain defined for the life of the instance
  if not 0 then idStateSpaceP must also not be 0
  if 0 then idStateSpaceP must also be 0
  can be 0
 postShortOrLongP
 pbBitsCtP
 idiFileCtP
 idLineCtP
 tin0P
arguments
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

