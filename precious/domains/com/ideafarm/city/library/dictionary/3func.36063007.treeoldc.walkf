
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    grab.ungrabF( tinBaseP ) ;

    }
        idLevelP = 0 ;
        (*pCallBackFP)( tinBaseP , ether , ifcIDtYPEtREEwALKcb_END , flagsP , handleP , 0 , idLevelP , cArgP ) ;
    {
    if( idLevelP == 1 )

    }

        }
            //MUST NOT REFER TO pHere AFTER ifcIDtYPEtREEwALKcb_BRANCHbEGIN CALBACK CAUSE CALLBACK MIGHT HAVE DELETED THE BRANCH HEADER
            (*pCallBackFP)( tinBaseP , ether , !bReverse ? ifcIDtYPEtREEwALKcb_BRANCHeND : ifcIDtYPEtREEwALKcb_BRANCHbEGIN , flagsP , handleP , (byteT*)( pHere + !bHeaders ) , !!bHeaders * sizeof( branchHeaderOldS ) + cbd , cArgP ) ;
    
            }
                idLevelP -- ;
                }
                    if( pPreserve ) swsk[ idklhSave ] ;

                    (*pCallBackFP)( tinBaseP , ether , ifcIDtYPEtREEwALKcb_WIFEeND , flagsP , handleP , (byteT*)pHere->psttLeverKids , idLevelP , cArgP ) ;
                    }
                        while( !swsk.third && !bQuitP && ~hWalk ) ;
                        }
                            walkF( tinBaseP , hTreeWalk , bQuitP , idLevelP , pCallBackFP , cArgP , flagsP ) ;
                            hTreeWalk.osF( ifcIDtYPEhANDLE_TREEwALK , c_pKid ) ;
                            handleC hTreeWalk( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_TREEwALK ) ;
                            countT c_pKid = (countT)&( bReverse ? swsk.downF( tinBaseP , hWalk ) : swsk.upF( tinBaseP , hWalk ) ) ;
                        {
                        do
                        handleC hWalk( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( swsk )
                    (*pCallBackFP)( tinBaseP , ether , ifcIDtYPEtREEwALKcb_WIFEbEGIN , flagsP , handleP , (byteT*)pHere->psttLeverKids , idLevelP , cArgP ) ;

                    if( pPreserve ) ((stackC&)swsk).pPlateF( tinBaseP , idklhSave ) ;
                    ZE( countT , idklhSave ) ;
                    psttLeverKidsShared = pHere->psttLeverKids = (strokeS*)swsk.leverF( tinBaseP , idf ) ;
                {
                for( countT idf = 1 ; !bQuitP && idf <= cFlavors ; idf ++ )
                countT cFlavors = swsk.cFlavorsF( tinBaseP ) ;
                idLevelP ++ ;
    
                switchStackC& swsk = *pHere->pSwsKids ;
            {
            if( pHere->pSwsKids )

            (*pCallBackFP)( tinBaseP , ether , !bReverse ? ifcIDtYPEtREEwALKcb_BRANCHbEGIN : ifcIDtYPEtREEwALKcb_BRANCHeND , flagsP , handleP , (byteT*)( pHere + !bHeaders ) , !!bHeaders * sizeof( branchHeaderOldS ) + cbd , cArgP ) ;
        {
        if( pHere )
        branchHeaderOldS* pHere = (branchHeaderOldS*)handleP.osF( ifcIDtYPEhANDLE_TREEwALK ) ;
        if( !handleP ) handleP.osF( ifcIDtYPEhANDLE_TREEwALK , (countT)pCursor ) ;
        boolT pPreserve = F(flagsP) & flTREEwALK_PRESERVElATHrEF ;
        boolT bHeaders  = F(flagsP) & flTREEwALK_HEADERS ;
        boolT bReverse  = F(flagsP) & flTREEwALK_REVERSE ;
    {
    if( pCursor )
    PcURSOR

    }
        (*pCallBackFP)( tinBaseP , ether , ifcIDtYPEtREEwALKcb_BEGIN , flagsP , handleP , 0 , idLevelP , cArgP ) ;
        idLevelP = 1 ;
    {
    if( !idLevelP )

    *sw_pCursor.pLeverLathRefF( tinBaseP ) = cLeverCursor ;
    grab.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

    }
        if( POOP ) return ;
        FV( flTREEwALK , flagsP ) ;
        __Z( pCallBackFP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL

    //0 IMPLIES WALK THE pCursor BRANCH
    //ASSUME: handleP IS EITHER 0 OR POINTS TO THE branchHeaderOldS OBJECT WHOSE KIDS ARE TO BE WALKED
{
/*1*/voidT treeOldC::walkF( tinBaseS& tinBaseP , handleC& handleP , const boolT& bQuitP , countT& idLevelP , treeOldCBFT pCallBackFP , countT& cArgP , const flagsT flagsP )/*1*/

/**/
*/
  must not be 0
 pCallBackFP
 bHeadersP
 bReverseP
 cArgP
  must be 0 except when i call myself
 idLevelP
 bQuitP
 handleP
 tinBaseP
arguments
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

