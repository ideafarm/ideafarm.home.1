
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK >> 2 ) ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        }
            sgnDone_tmServeHttpF.waitF( tin0P ) ;
            }
                FIREmYSELF

                etThread.traceF( tin0P , T("I am no longer serving web pages.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;

                }
                    ++ s ; etThread.osSleepF( tin0P , TUCK >> 6 ) ;

                    }
                        }
                            etThread.delF( tin0P , posti ) ;
                            }
                                etRock.traceF( tin0P , T("stomp! FAIL [idStomp,cFail,rc]:    ")+TF2(cStomp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(++cStompFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM ) ;
                                POOPRqUIET
                                countT rc = POOP ;
                            {
                            else
                            if( !POOP ) etRock.traceF( tin0P , T("stomp! aok [idStomp]:    ")+TF2(cStomp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM ) ;
                            ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , tUrl , 1 ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;
                            etRock.traceF( tin0P , T("stomp! begin [idStomp,url]:    ")+TF2(cStomp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tUrl , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM  ) ;
                            SCOOPS
                            _IO_
                        {
                        IFsCRATCHoK
                        cStomp ++ ;

                        TN( tUrl , "" ) ; tUrl  = TF3(pcHash[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+TF3(pcHash[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(".ideanet.ideafarm.com//http/ideanet/gorilla.html") ;
                        countT* pcHash = (countT*)&hashNow ;
                        //CS:CODEsYNC: 510008c0 33000116
                    {
                    if( bGorilla && !( cSkipStomp && cSkipStomp -- ) && !( idPass % ( TUCK >> 2 ) ) )

                    }
                        etThread.traceF( tin0P , T("[time,ipv6]:    ")+TT(timeN1,timeN2)+tb4+tIpv6Now , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX ) ;

                        tIpv6Now = T(nnNow) ;
                        nicNameC nnNow = sub.nnF( tin0P , hashNow , minute ) ;
                        hashNow = 0 ;

                        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                        ZE( sCountT , timeN2 ) ;
                        ZE( countT  , timeN1 ) ;
                        minuteLath = minute ;
                    {
                    if( minuteLath != minute )                          // A:ASSUME: THE LIFETIME OF EACH ipv6 ADDRESS IS GREATER THAN RE MINUTES, SO THAT THE ipv6 OF THE LATH MINUTE WILL CONTINUE TO BE VALID WELL AFTER I NO LONGER OBTAIN ITS VALUE
                    countT minute = ( timeN1 >> 0x14 ) - 1 ;            // USE THE PRIOR MINUTE (TO AVOID RACING WITH THE WEB SERVER)

                    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT  , timeN1 ) ;

                    }
                        countT rc = (countT)ShellExecuteA( 0 , 0 , "http://[::1]/ideanet" , 0 , 0 , SW_SHOW ) ;     //U:: MOVE SUPPORT FOR THIS INTO thirdC etherC
                    {
                    if( cSkipPage && !( -- cSkipPage ) )

                    ++ idPass ;
                {
                while( !bHeardEnterKey && idStatusHttpService <= ifcIDsTATUShTTPsERVICE_READY )
                ZE( countT , idPass ) ;
                countT cSkipStomp = TUCK >> 4 ;
                countT cSkipPage  = TUCK >> 5 ;
                ZE( countT , cStompFail ) ;
                ZE( countT , cStomp     ) ;

                ZE( countT , idEpoch    ) ;
                ZE( countT , minuteLath ) ;
                TN( tb4 , "    " ) ;

                etThread.traceF( tin0P , T("Press the Enter key, and I will stop serving web pages, which will disable your access to IdeaNet (tm):    ") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                etThread.osThreadF( TaRG2cBsTACK( tmHearF , TICK >> 2 ) , (countT)&bHeardEnterKey ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
                ZE( boolT , bHeardEnterKey ) ;

                etThread.traceF( tin0P , T("I am ready to serve web pages.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
            {
            else
            }
                etThread.traceF( tin0P , T("I cannot serve web pages, likely because there is already an http server running on this computer.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
                bAborted = 1 ;
            {
            if( idStatusHttpService > ifcIDsTATUShTTPsERVICE_READY )

            }
                ++ s ; ether.osSleepF( tin0P ) ;
            {
            while( idStatusHttpService < ifcIDsTATUShTTPsERVICE_READY )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

            etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmServeHttpF , sgnDone_tmServeHttpF , CBsTACKmIN << 2 ) , (countT)&idStatusHttpService , (countT)&tIpv6Now , (countT)&hashNow , (countT)&idBook , (countT)&idSub ) ;
            signC sgnDone_tmServeHttpF( tin0P , TAG( TAGiDnULL ) ) ;

            ZE( count04T , hashNow ) ;
            TN( tIpv6Now , ""      ) ;
            ZE( countT , idStatusHttpService ) ;
        {
        ZE( boolT , bAborted ) ;

        etThread.delF( tin0P , psttUnwanted ) ;
        etThread.delF( tin0P , psttWanted ) ;
        etThread.strHearF( tin0P , psttWanted , psttUnwanted , 0 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;

        ) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

            "\r\nThis is safe, because I will ignore requests that come from any computers other than yours:    "
            "\r\nPress the Enter key, and then, when prompted, tell Windows to allow me to serve web pages (to you)."
            "IdeaFarm (tm) IdeaNet (tm) is a subscribers-only World Wide Web system within the public Internet system."

        etThread.traceF( tin0P , T(

        countT idSub  = 1 ;
        countT idBook = 1 ;

        ZE( strokeS* , psttUnwanted ) ;
        ZE( strokeS* , psttWanted ) ;

        }
            }
                if( !etThread.strCompareF( tin0P , psttc1 , tHeyGorilla ) ) bGorilla = 1 ;
                etThread.traceF( tin0P , T("[parameter]:    ")+T(psttc1) ) ;
            {
            FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tin0P ) )
            TN( tHeyGorilla , "!gorilla" ) ;
        {
        ZE( boolT , bGorilla ) ;

        }
            etThread.traceF( tin0P , T("This file gives you free access to Book 1.  For Book 1, you are subscriber number [idSub]:    ")+TF2(idSub,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n    Subscription id's are dispensed serially, starting with 1.\r\n    Subscribers with low id numbers will be given VIP privileges as the system grows,\r\n    in appreciation for their role as founders.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

            etThread.traceF( tin0P , T("This file is your personal key for access to the IdeaFarm (tm) IdeaNet (tm) Book Publishing System.\r\n    Do not share this file with others.  Abuse will result in suspension or termination of your access.\r\n    You may use this key only if you are the owner of [email]:    ")+tEmail , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

            countT              idSub  = sub ;
            TN( tEmail , "" ) ; tEmail = sub ;

            sub.traceF( tin0P ) ;

            sub << soulSub ;

            etThread.delF( tin0P , pbs ) ;
            soulSub.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_byteTptr , pbs , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
            soulC soulSub( tin0P , etThread , TAG( TAGiDnULL ) ) ;

            etThread.strUnDumpF( tin0P , pbs , cbs , T(postSoulSubDump) ) ; ___( pbs ) ;
            ZE( countT , cbs ) ;
            ZE( byteT* , pbs ) ;
        {
        ideaNetSubscriptionC sub( tin0P , etThread ) ;

        TN( tY , "y" ) ;
        TN( tb4 , "    " ) ;
    {
    else
    if( !LoadStringA( 0 , 101 , postSoulSubDump , sizeof postSoulSubDump ) ) etThread.traceF( tin0P , T("Either this file is not configured (for your email address), or it is corrupted.  Please discard it and obtain a fresh copy by (re)registering your email address at http://ideafarm.com .") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
{
if( pTaskP )
TASK( tmWorkF )

osTextT postSoulSubDump[ TUCK << 4 ] ;

DONE( tmHearF )
}
    bHeardEnterKeyP = 1 ;

    etThread.delF( tin0P , psttUnwanted ) ;
    etThread.delF( tin0P , psttWanted ) ;
    etThread.strHearF( tin0P , psttWanted , psttUnwanted , 0 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;
    ZE( strokeS* , psttUnwanted ) ;
    ZE( strokeS* , psttWanted ) ;

    boolT& bHeardEnterKeyP = *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmHearF )

DONE( tmServeHttpF )
}
    //THREADmODE2rESTORE0( flagsSave )
    }
        //THREADmODE2oN0( flTHREADmODE2_UNLOCKpOOLiDENTITY )
        //THREADmODE2sAVE0( flagsSave )

        }
            etThread.traceF( tin0P , T("cleaning up") ) ;
            }
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
            {
            while( !ether && idStatusHttpServiceP <= ifcIDsTATUShTTPsERVICE_READY )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            etThread.traceF( tin0P , T("loafing") ) ;

            httpServerC serverU( tin0P , arg1U , arg2 , &cache ) ;
        {

        cacheC cache( tin0P , etThread ) ;
        httpServerC_arg2S arg2 ;
        httpServerC_arg1S arg1U( TAG( TAGiDnULL ) , etThread , cArgApp , idStatusHttpServiceP , ifcIDpORT_HTTP  , flSOCKETc_null , T("World Wide Web") ) ;

        countT cArgApp = (countT)&c9p ;
        count9S c9p( (countT)&tIpv6NowP , (countT)&hashNowP , (countT)&idBookP , (countT)&idSubP ) ;
    {
    ZE( flagsT , flagsSave ) ;

    countT&   idSubP               =   *(countT*)pTaskP->c5 ;
    countT&   idBookP              =   *(countT*)pTaskP->c4 ;
    count04T& hashNowP             = *(count04T*)pTaskP->c3 ;
    textC&    tIpv6NowP            =    *(textC*)pTaskP->c2 ;
    countT&   idStatusHttpServiceP =   *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmServeHttpF )

// LIKE 8bc BUT DNS SERVER REPLACED WITH HTTP SERVER
// OBSOLETES: 8bc_

/*1*/WAKEhIDE( "ifcIDaDAM_IDEAnET" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
