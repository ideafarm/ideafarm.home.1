
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

/**/etRock.traceF( tin0P , T("\r\nA0\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK >> 2 ) ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

etherC& etRock = etherC::etRockIF( tin0P ) ;

TODO

DONE( tmWorkF )
}
    /**/etRock.traceF( tin0P , T("\r\nB0\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
    }
        }
            //etRock.traceF( tin0P , T("\r\nwaited for sgnDone_tmServeHttpF.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
            sgnDone_tmServeHttpF.waitF( tin0P ) ;
            //etRock.traceF( tin0P , T("\r\nwaiting for sgnDone_tmServeHttpF.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
            
            }
                FIREmYSELF

                etRock.traceF( tin0P , T("\r\nI am no longer serving web pages.\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;

                }
                    ++ s ; etThread.osSleepF( tin0P , TUCK >> 6 ) ;

                    }
                        if( rc <= 32 ) etRock.traceF( tin0P , T("I was not able to open your browser [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                        countT rc = (countT)ShellExecuteA( 0 , 0 , "http://[::1]/ideanet/0/root/3/root.html" , 0 , 0 , SW_SHOW ) ;     //U:: MOVE SUPPORT FOR THIS INTO thirdC etherC
                        // "If the function succeeds, it returns a value greater than 32."  (https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutea)

                        etRock.traceF( tin0P , T("Opening your browser...\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                    {
                    #endif
                        if( idPass == 1 )
                    #else
                        if( bWasDown && bUpControl && bUpData )
                    #if !defined( DUMMYsUB )

                    }
                        #endif
                            }
                                }
                                    etThread.delF( tin0P , posti ) ;
                                    }
                                        }
                                            //etRock.traceF( tin0P , TT(timeN1,timeN2)+T(" reset tim1Signature to 0") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX ) ;
                                            time1Signature = 0 ;
                                            etRock.traceF( tin0P , TTF(timeN1,timeN2)+T(bUpControl?"    The DATA channel just went DOWN, but the control channel is still up.":"    The DATA channel just went DOWN, and the control channel is still down.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM|flTRACE_NOpREFIX ) ;
                                            bUpData = 0 ;
                                        {
                                        if( bUpData )
                                        //etRock.traceF( tin0P , T("stomp! (data)    FAIL [idStompData   ,cFail,rc]:    ")+TF2(cStompData,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(++cStompDataFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM ) ;
                                        POOPRqUIET
                                        countT rc = POOP ;
                                    {
                                    else
                                    }
                                        }
                                            etRock.traceF( tin0P , TTF(timeN1,timeN2)+T(bUpControl?"    The DATA channel just came UP, so both control and data are up.":"    The DATA channel just came UP, but the control channel is still down.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM|flTRACE_NOpREFIX ) ;
                                            bUpData = 1 ;
                                        {
                                        if( !bUpData )
                                        //etRock.traceF( tin0P , T("stomp! (data)    aok [idStompData   ]:    ")+TF2(cStompData,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM ) ;
                                    {
                                    if( !POOP )
                                    ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , tUse , 1 ) ; ___( posti ) ;
                                    ZE( countT   , costi ) ;
                                    ZE( osTextT* , posti ) ;
                                    //etRock.traceF( tin0P , T("stomp! (data)    begin [idStompData   ,url]:    ")+TF2(cStompData,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tUse , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM  ) ;
                                    SCOOPS
                                    _IO_
                                {
                                IFsCRATCHoK
                                cStompData ++ ;

                                TN( tUse , "" ) ; tUse = F(flagsMode) & flIDEAnETeXE_USEdNS ? tRequestDomain : tRequestAddress ;

                                TN( tRequestAddress , "" ) ; tRequestAddress = tIpv6NowData+T("//http/ideanet/gorilla.html") ;

                                ;

                                    +T(".ideanet.ideafarm.com//http/ideanet/gorilla.html")
                                    +TF3(ipv6FieldsData.hostRandom ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)
                                    +TF3(ipv6FieldsData.idSub      ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tUnderScore
                                    +TF3(ipv6FieldsData.epoch     ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tUnderScore
                                     TF3(ipv6FieldsData.routeRandom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tUnderScore

                                TN( tRequestDomain , "" ) ; tRequestDomain =

                                // THE FIELD VALUES IN THE DOMAIN NAME USE FOREIGN BIGIT ORDERING SO THAT EACH CAN BE EASILY COMPARED WITH THE nicNameC VALUE REPRESENTED IN 11:22:33:44:55:66:77:88 FORMAT
                            {
                            // DATA

                            }
                                }
                                    etThread.delF( tin0P , posti ) ;
                                    }
                                        }
                                            //etRock.traceF( tin0P , TT(timeN1,timeN2)+T(" reset tim1Signature to 0") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX ) ;
                                            time1Signature = 0 ;
                                            etRock.traceF( tin0P , TTF(timeN1,timeN2)+T(bUpData?"    The CONTROL channel just went DOWN, but the data channel is still up.":"    The CONTROL channel just went DOWN, and the data channel is still down.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM|flTRACE_NOpREFIX ) ;
                                            bUpControl = 0 ;
                                        {
                                        if( bUpControl )
                                        //etRock.traceF( tin0P , T("stomp! (control) FAIL [idStompControl,cFail,rc]:    ")+TF2(cStompControl,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(++cStompControlFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM ) ;
                                        POOPRqUIET
                                        countT rc = POOP ;
                                    {
                                    else
                                    }
                                        }
                                            etRock.traceF( tin0P , TTF(timeN1,timeN2)+T(bUpData?"    The CONTROL channel just came UP, so both control and data are up.":"    The CONTROL channel just came UP, but the data channel is still down.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM|flTRACE_NOpREFIX ) ;
                                            bUpControl = 1 ;
                                        {
                                        if( !bUpControl )
                                        //etRock.traceF( tin0P , T("stomp! (control) aok [idStompControl]:    ")+TF2(cStompControl,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM ) ;
                                    {
                                    if( !POOP )
                                    ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , tUse , 1 ) ; ___( posti ) ;
                                    ZE( countT   , costi ) ;
                                    ZE( osTextT* , posti ) ;
                                    //etRock.traceF( tin0P , T("stomp! (control) begin [idStompControl,url]:    ")+TF2(cStompControl,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tUse , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM  ) ;
                                    SCOOPS
                                    _IO_
                                {
                                IFsCRATCHoK
                                cStompControl ++ ;

                                TN( tUse , "" ) ; tUse = F(flagsMode) & flIDEAnETeXE_USEdNS ? tRequestDomain : tRequestAddress ;

                                TN( tRequestAddress , "" ) ; tRequestAddress = tIpv6NowControl+T("//http/ideanet/control/gorilla.html") ;

                                ;

                                    +T(".ideanet.ideafarm.com//http/ideanet/control/gorilla.html")
                                    +TF3(ipv6FieldsControl.hostRandom ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)
                                    +TF3(ipv6FieldsControl.idSub      ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tUnderScore
                                    +TF3(ipv6FieldsControl.epoch     ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tUnderScore
                                     TF3(ipv6FieldsControl.routeRandom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tUnderScore

                                TN( tRequestDomain , "" ) ; tRequestDomain =

                                // THE FIELD VALUES IN THE DOMAIN NAME USE FOREIGN BIGIT ORDERING SO THAT EACH CAN BE EASILY COMPARED WITH THE nicNameC VALUE REPRESENTED IN 11:22:33:44:55:66:77:88 FORMAT
                            {
                            // CONTROL
                        #if !defined( DUMMYsUB )
                    {
                    )
                        //!( idPass % ( TUCK >> 4 ) )
                        //&&
                        )
                            ( cTestRequestsPending && decv02AM( cTestRequestsPending ) )
                            ||
                            !( F(flagsMode) & flIDEAnETeXE_METERED )
                            ||
                            !bUpData
                            ||
                            !bUpControl
                        (
                        &&
                        !( cSkipStomp && cSkipStomp -- )
                    (
                    if

                    }
                        //etRock.traceF( tin0P , TT(timeN1,timeN2)+ T(" [ipv6Control,ipv6Data]:    ")+tIpv6NowControl+tb4+tIpv6NowData , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX ) ;

                        }
                            //etRock.traceF( tin0P , TT(timeN1,timeN2)+T(" set [tim1Signature,perTuckSignature]:    ")+TF2(time1Signature,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)perTuckSignature,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX ) ;

                            ) ;
                                / TUCK
                                )
                                    (count04T)time1PerEpoch * EPOCHSsIGNATUREmAX * perTuckSignature
                                (
                            (
                            time1Signature = (countT)

                            count04T perTuckSignature = ipv6FieldsControl.hostRandom % TUCK ;

                            // THE RANDOMNESS OF THE LENGTH OF THE SIGNATURE TIME ADJUSTMENT CREATES A SIGNATURE THAT CAN BE USED TO IDENTIFY AN ATTACKER WHO IS SNIFFING HIS WIRE TO DISCOVER THE PREFIX TO ATTACK
                            // DISCRETE STEPS SO THAT THE SEQUENCE OF time1Signature VALUES WILL BE QUASI UNIQUE FOR EACH SUBSCRIBER, SO CAN SERVE AS A SIGNATURE FOR IDENTIFYING A SUBSCRIBER ATTACKER
                        {
                        else
                        }
                            //etRock.traceF( tin0P , TT(timeN1,timeN2)+T(" reset tim1Signature to 0") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX ) ;
                            time1Signature = 0 ;
                        {
                        if( !bUpControl || !bUpData )

                        tIpv6NowData    = T(nnNowData   ) ;                                                                             // P:PERSONALITY: SUBSCRIBER ATTACKER CANNOT FULLY USE HIS WIRE WITHOUT LEAVING HIS SIGNATURE ON THE ATTACK
                        tIpv6NowControl = T(nnNowControl) ;
                        #endif
                            nicNameC nnNowData    ;
                            nicNameC nnNowControl ;
                        #else
                            nicNameC nnNowData    = sub.nnF( tin0P , epochUse , ipv6FieldsData                             ) ;
                            nicNameC nnNowControl = sub.nnF( tin0P , epochUse , ipv6FieldsControl , ifcIDtYPErOUTE_CONTROL ) ;
                        #if !defined( DUMMYsUB )

                        ipv6FieldsData    = 0 ;
                        ipv6FieldsControl = 0 ;

                        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                        ZE( sCountT , timeN2 ) ;
                        ZE( countT  , timeN1 ) ;
                        epochUseLath = epochUse ;
                    {
                    if( epochUseLath != epochUse )

                    countT epochUse = ( ( timeN1 - time1Signature ) >> BITSsHIFTiDEAnETePOCH ) - EPOCHSaLLOWEDfORbGPpROPOGATION ;

                    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT  , timeN1 ) ;

                    const boolT bWasDown = !bUpControl || !bUpData ;

                    ++ idPass ;
                {
                while( idStatusHttpService <= ifcIDsTATUShTTPsERVICE_READY && !( F(flagsMode) & flIDEAnETeXE_QUIT ) )
                ZE( countT , time1Signature ) ;
                const countT time1PerEpoch = 1 << BITSsHIFTiDEAnETePOCH ;
                ZE( countT , idPass ) ;
                ZE( boolT  , bUpData    ) ;
                ZE( boolT  , bUpControl ) ;
                countT cSkipStomp = TUCK >> 4 ;
                countT cSkipPage  = TUCK >> 5 ;
                ZE( countT , cStompDataFail    ) ;
                ZE( countT , cStompControlFail ) ;
                ZE( countT , cStompData        ) ;
                ZE( countT , cStompControl     ) ;

                ZE( countT , idEpoch      ) ;
                ZE( countT , epochUseLath ) ;
                TN( tUnderScore , "_" ) ;
                TN( tb4 , "    " ) ;

                }
                    }
                        etRock.traceF( tin0P , T("I am ready to serve web pages (only to you).  Enter the 'b' command to begin.\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
                        bWoth = 0 ;
                    {
                    if( bWoth )

                    ++ s ; ether.osSleepF( tin0P , TOCK >> 1 ) ;                //GIVE tmHearF TIME TO START LISTENING, BECAUSE I DON'T REMEMBER WHAT IT DOES WITH KEYSTROKES MADE BEFORE IT STARTS WORKING
                {
                while( !ether && !( F(flagsMode) & flIDEAnETeXE_BEGIN ) )
                boolT bWoth = 1 ;
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                etThread.osThreadF( TaRG2cBsTACK( tmHearF , CBsTACKmIN << 2 ) , (countT)&flagsMode , (countT)&cTestRequestsPending ) ;
            {
            else
            }
                etRock.traceF( tin0P , T("I cannot serve web pages, likely because there is already an http server running on this computer.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
                bAborted = 1 ;
            {
            if( idStatusHttpService > ifcIDsTATUShTTPsERVICE_READY )

            }
                ++ s ; ether.osSleepF( tin0P ) ;
            {
            while( idStatusHttpService < ifcIDsTATUShTTPsERVICE_READY )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

            etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmServeHttpF , sgnDone_tmServeHttpF , CBsTACKmIN << 2 ) , (countT)&idStatusHttpService , (countT)&tIpv6NowControl , (countT)&tIpv6NowData , (countT)&ipv6FieldsControl , (countT)&ipv6FieldsData , (countT)&flagsMode ) ;
            signC sgnDone_tmServeHttpF( tin0P , TAG( TAGiDnULL ) ) ;

            ZE( countT , cTestRequestsPending ) ;
            flagsT flagsMode = flIDEAnETeXE_METERED ;
            //flagsT flagsMode = flIDEAnETeXE_USEdNS | flIDEAnETeXE_METERED ;
            ideaNetIpv6FieldsS ipv6FieldsData    ;
            ideaNetIpv6FieldsS ipv6FieldsControl ;
            TN( tIpv6NowData    , "" ) ;
            TN( tIpv6NowControl , "" ) ;
            ZE( countT , idStatusHttpService ) ;
            etRock.traceF( tin0P , T("\r\nPreparing to serve pages to you...\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
        {
        if( !bQuitEarly )
        ZE( boolT , bAborted ) ;

        etThread.delF( tin0P , psttUnwanted ) ;
        etThread.delF( tin0P , psttWanted ) ;
        boolT bQuitEarly = etThread.strCompareF( tin0P , psttWanted , T("ok") ) ;
        etThread.strHearF( tin0P , psttWanted , psttUnwanted , 2 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;

        ) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

            "\r\n  tell Windows to allow this:  "
            "\r\n  other computers.  Press the Enter key now to quit.  Or, enter \"ok\" to continue, and then, when prompted,"
            "\r\n  I will serve web pages, but only to you.  This is safe, because I will ignore requests that come from"
            "\r\nIdeaFarm (tm) IdeaNet (tm) is a subscribers-only World Wide Web system within the public Internet system."

        etRock.traceF( tin0P , T(

        countT idSub  = 1 ;
        countT idBook = 1 ;

        ZE( strokeS* , psttUnwanted ) ;
        ZE( strokeS* , psttWanted ) ;

        }
            etRock.traceF( tin0P , T("\r\nThis file gives you access to Book 1.  For Book 1, you are subscriber number ")+TF2(idSub,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(".  Subscription id's\r\n  are dispensed serially, starting with 1.  Subscribers with low id numbers will be given\r\n  VIP privileges as the system grows, in appreciation for their role as founders.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

            etRock.traceF( tin0P , T("\r\nThis file is your personal key for access to the IdeaFarm (tm) IdeaNet (tm) Knowlege Tree Book Distribution System.\r\n  Do not share this file with others.  Abuse will result in suspension or termination of your access (without refund).  You may use this key\r\n  only if you are the owner of email address ")+tEmail+T(" .") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

            countT              idSub  = sub ;
            TN( tEmail , "" ) ; tEmail = sub ;

            sub.traceF( tin0P ) ;

            #endif
                sub << soulSub ;

                etThread.delF( tin0P , pbs ) ;
                soulSub.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_byteTptr , pbs , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                soulC soulSub( tin0P , etThread , TAG( TAGiDnULL ) ) ;

                etThread.strUnDumpF( tin0P , pbs , cbs , T(postSoulSubDump) ) ; ___( pbs ) ;
                ZE( countT , cbs ) ;
                ZE( byteT* , pbs ) ;
            #if !defined( DUMMYsUB )
        {
        ideaNetSubscriptionC sub( tin0P , etThread ) ;

        TN( tY , "y" ) ;
        TN( tb4 , "    " ) ;
    {
    #endif
        else
        if( !LoadStringA( 0 , 101 , postSoulSubDump , sizeof postSoulSubDump ) ) etRock.traceF( tin0P , T("Either this file is not configured (for your email address), or it is corrupted.  Please discard it and obtain a fresh copy by (re)registering your email address at http://ideafarm.com .") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    #if !defined( DUMMYsUB )

    etherC& etRock = etherC::etRockIF( tin0P ) ;
{
if( pTaskP )
TASK( tmWorkF )

osTextT postSoulSubDump[ TUCK << 4 ] ;

DONE( tmHearF )
}
    /**/etRock.traceF( tin0P , T("\r\nD0\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
    }
        etThread.delF( tin0P , psttUnwanted ) ;
        etThread.delF( tin0P , psttWanted   ) ;

        etRock.traceF( tin0P , tModesNow , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        tModesNow += tcrlf ;
        tModesNow += tb + ( F(flagsModeP) & flIDEAnETeXE_METERED ? tModeMetered : tModeFree    ) ;
        tModesNow +=        F(flagsModeP) & flIDEAnETeXE_USEdNS  ? tModeName    : tModeAddress   ;
        TN( tModesNow , "Current modes:    " ) ;
        //CS:CODEsYNC: 510008c0 510008c0

        else                                                            {                                                    etRock.traceF( tin0P , tHelp                                                                                                                                              , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ; }
        else if( !etThread.strCompareF( tin0P , T("t") , psttWanted ) ) { boolT bDo = F(flagsModeP) & flIDEAnETeXE_METERED ; if( bDo ) inc02AM( cTestRequestsPendingP ) ; etRock.traceF( tin0P , T(bDo?"I will test my connectivity with IdeaNet (tm).\r\n":"Ignored because I am in free mode.\r\n" ) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ; }
        else if( !etThread.strCompareF( tin0P , T("n") , psttWanted ) ) {       flagsModeP |=      flIDEAnETeXE_USEdNS     ; etRock.traceF( tin0P , T("I will use \"name mode\" (https).\r\n"              )                                                                                           , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ; }
        else if( !etThread.strCompareF( tin0P , T("m") , psttWanted ) ) {       flagsModeP |=      flIDEAnETeXE_METERED    ; etRock.traceF( tin0P , T("I will limit my use of data transmission.\r\n"      )                                                                                           , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ; }
        else if( !etThread.strCompareF( tin0P , T("f") , psttWanted ) ) {       flagsModeP &= ~( F(flIDEAnETeXE_METERED) ) ; etRock.traceF( tin0P , T("I will use data transmission freely.\r\n"           )                                                                                           , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ; }
        else if( !etThread.strCompareF( tin0P , T("b") , psttWanted ) ) {       flagsModeP |=      flIDEAnETeXE_BEGIN      ; etRock.traceF( tin0P , T("Synchronizing...\r\n"                               )                                                                                           , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ; }
        else if( !etThread.strCompareF( tin0P , T("a") , psttWanted ) ) {       flagsModeP &= ~( F(flIDEAnETeXE_USEdNS) )  ; etRock.traceF( tin0P , T("I will use \"address mode\" (http).\r\n"            )                                                                                           , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ; }
             if( !psttWanted || !psttWanted->idAdam                   ) { FIREmYSELF }

        //etRock.traceF( tin0P , T("[psttUnwanted]:    ")+T(psttUnwanted) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        //etRock.traceF( tin0P , T("[psttWanted]:      ")+T(psttWanted  ) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        etThread.strHearF( tin0P , psttWanted , psttUnwanted , 1 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;
        ZE( strokeS* , psttUnwanted ) ;
        ZE( strokeS* , psttWanted   ) ;
    {
    while( !ether && !( F(flagsModeP) & flIDEAnETeXE_QUIT ) )

    etRock.traceF( tin0P , tHelp , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
 
    ) ;

        "Press the 'Enter' key, preceded by 'h' or any other keystrokes, to view this help.\r\n"
        "Press the 'Enter' key, preceded by no keystrokes, to \"fire\" me (to close/end this program).\r\n"
        "\r\n"
        "  't' : Test the connection channels.\r\n"
        "  'n' : Use \"name mode\" (https).  (Most of the data passing between you and the server is encrypted.)\r\n"
        "  'm' : Use \"metered mode\".  (Use this mode if you pay for data communication or if data transmission is limited.)\r\n"
        "  'h' : Display this help information.\r\n"
        "  'f' : Use \"free mode\".  (Use this mode if your connection has free and unlimited data.)\r\n"
        "  'a' : Use \"address mode\" (http).  No data is encrypted.  More robust against system attack, because the domain name system is not needed.\r\n"
        "\r\n"
        "  Case matters; 'X' denotes cap X, while 'x' denotes x.  (Do not key the single quotes.)\r\n"
        "While I am working, you can enter commands by pressing the 'Enter' key after pressing and releasing wo of the following keys.\r\n"

    TN( tHelp ,

    etRock.traceF( tin0P , tModesNow , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    tModesNow += tcrlf ;
    tModesNow += tb + ( F(flagsModeP) & flIDEAnETeXE_METERED ? tModeMetered : tModeFree    ) ;
    tModesNow +=        F(flagsModeP) & flIDEAnETeXE_USEdNS  ? tModeName    : tModeAddress   ;
    TN( tModesNow , "Current modes:    " ) ;
    //CS:CODEsYNC: 510008c0 510008c0

    TN( tcrlf        , "\r\n" ) ;
    TN( tb           , " " ) ;
    TN( tModeName    , "name"    ) ;
    TN( tModeMetered , "metered" ) ;
    TN( tModeFree    , "free"    ) ;
    TN( tModeAddress , "address" ) ;
    etherC& etRock     = etherC::etRockIF( tin0P ) ;

    countT& cTestRequestsPendingP = *(countT*)pTaskP->c2 ;
    flagsT& flagsModeP            = *(flagsT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmHearF )

DONE( tmServeHttpF )
}
    /**/etRock.traceF( tin0P , T("\r\nE0\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
    //THREADmODE2rESTORE0( flagsSave )
    //etRock.traceF( tin0P , T("\r\ntmServeHttpF cleaned up.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
    }
        /**/etRock.traceF( tin0P , T("\r\nE1\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
        //THREADmODE2oN0( flTHREADmODE2_UNLOCKpOOLiDENTITY )
        //THREADmODE2sAVE0( flagsSave )

        //etRock.traceF( tin0P , T("\r\ntmServeHttpF destroyed server instance.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
        }
            //etRock.traceF( tin0P , T("\r\ntmServeHttpF destroying server instance.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
            /**/etRock.traceF( tin0P , T("\r\nE2\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;

            }
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
            {
            while( !ether && idStatusHttpServiceP <= ifcIDsTATUShTTPsERVICE_READY )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            etRock.traceF( tin0P , T("loafing") ) ;

            httpServerC serverU( tin0P , arg1U , arg2 , &cache ) ;
        {

        cacheC cache( tin0P , etThread ) ;
        httpServerC_arg2S arg2 ;
        httpServerC_arg1S arg1U( TAG( TAGiDnULL ) , etThread , cArgApp , idStatusHttpServiceP , ifcIDpORT_HTTP  , flSOCKETc_null , T("World Wide Web") , 1 ) ;

        countT cArgApp = (countT)&c9p ;
        count9S c9p( (countT)&tIpv6NowControlP , (countT)&tIpv6NowDataP , (countT)&ipv6FieldsControlP , (countT)&ipv6FieldsDataP , (countT)&flagsModeP ) ;
    {
    ZE( flagsT , flagsSave ) ;

    etherC& etRock = etherC::etRockIF( tin0P ) ;

    flagsT&             flagsModeP           =             *(flagsT*)pTaskP->c6 ;
    ideaNetIpv6FieldsS& ipv6FieldsDataP      = *(ideaNetIpv6FieldsS*)pTaskP->c5 ;
    ideaNetIpv6FieldsS& ipv6FieldsControlP   = *(ideaNetIpv6FieldsS*)pTaskP->c4 ;
    textC&              tIpv6NowDataP        =              *(textC*)pTaskP->c3 ;
    textC&              tIpv6NowControlP     =              *(textC*)pTaskP->c2 ;
    countT&             idStatusHttpServiceP =             *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmServeHttpF )

// LIKE 8bc BUT DNS SERVER REPLACED WITH HTTP SERVER
// OBSOLETES: 8bc_

//#define DUMMYsUB
//ENABLE THIS LINE FOR DEBUGGING (USES DUMMY SUBSCRIPTION RATHER THAN A RESOURCE)

/*1*/WAKEhIDE( "ifcIDaDAM_IDEAnET" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
