
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK >> 2 ) ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        }
            sgnDone_tmServeHttpF.waitF( tin0P ) ;
            }
                FIREmYSELF

                etThread.traceF( tin0P , T("\r\nI am no longer serving web pages.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;

                }
                    ++ s ; etThread.osSleepF( tin0P , TUCK >> 6 ) ;

                    }
                        }
                            etThread.delF( tin0P , posti ) ;
                            }
                                etRock.traceF( tin0P , T("stomp! FAIL [idStomp,cFail,rc]:    ")+TF2(cStomp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(++cStompFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM ) ;
                                POOPRqUIET
                                countT rc = POOP ;
                            {
                            else
                            if( !POOP ) etRock.traceF( tin0P , T("stomp! aok [idStomp]:    ")+TF2(cStomp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM ) ;
                            ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , tUse , 1 ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;
                            etRock.traceF( tin0P , T("stomp! begin [idStomp,url]:    ")+TF2(cStomp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tUse , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM  ) ;
                            SCOOPS
                            _IO_
                        {
                        IFsCRATCHoK
                        cStomp ++ ;

                        TN( tUse , "" ) ; tUse = F(flagsMode) & flIDEAnETeXE_HTTPS ? tRequestDomain : tRequestAddress ;

                        TN( tRequestAddress , ""        ) ; tRequestAddress = tIpv6Now                                                                                                                                                                                                      +T("//http/ideanet/gorilla.html") ;

                        ;

                            +T(".ideanet.ideafarm.com//http/ideanet/gorilla.html")
                            +TF3(ipv6Fields.hostRandom ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)
                            +TF3(ipv6Fields.idSub      ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tUnderScore
                            +TF3(ipv6Fields.minute     ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tUnderScore
                             TF3(ipv6Fields.routeRandom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tUnderScore

                        TN( tRequestDomain , "" ) ; tRequestDomain =

                        // THE FIELD VALUES IN THE DOMAIN NAME USE FOREIGN BIGIT ORDERING SO THAT EACH CAN BE EASILY COMPARED WITH THE nicNameC VALUE REPRESENTED IN 11:22:33:44:55:66:77:88 FORMAT

                        //TN( tUrl , "" ) ; tUrl  = TF3(pcIdHost[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+TF3(pcIdHost[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(".ideanet.ideafarm.com//http/ideanet/gorilla.html") ;
                        countT* pcIdHost = (countT*)&ipv6Fields ;
                        //CS:CODEsYNC: 510008c0 33000116
                    {
                    if( bGorilla && !( cSkipStomp && cSkipStomp -- ) && !( idPass % ( TUCK >> 2 ) ) )

                    }
                        //etThread.traceF( tin0P , T("[time,ipv6]:    ")+TT(timeN1,timeN2)+tb4+tIpv6Now , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX ) ;

                        tIpv6Now = T(nnNow) ;
                        nicNameC nnNow = sub.nnF( tin0P , minute , ipv6Fields ) ;
                        ipv6Fields = 0 ;

                        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                        ZE( sCountT , timeN2 ) ;
                        ZE( countT  , timeN1 ) ;
                        minuteLath = minute ;
                    {
                    if( minuteLath != minute )
                    countT minute = ( ( timeN1 - 2 * TOCK ) >> 0x14 ) ;         //U:: "2 * TOCK": ALLOW 2 TOCKS FOR THE BGP SYSTEM TO ESTABLISH CONNECTIVITY USING EACH NEW PREFIX BETWEEN ME (CLIENT) AND THE SERVER

                    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT  , timeN1 ) ;

                    }
                          if( rc <= 32 ) etThread.traceF( tin0P , T("I was not able to open your browser [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                          countT rc = (countT)ShellExecuteA( 0 , 0 , "http://[::1]/ideanet" , 0 , 0 , SW_SHOW ) ;     //U:: MOVE SUPPORT FOR THIS INTO thirdC etherC
                          // "If the function succeeds, it returns a value greater than 32."  (https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecutea)

                          etThread.traceF( tin0P , T("Opening your browser...\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                    {
                    if( cSkipPage && !( -- cSkipPage ) )

                    ++ idPass ;
                {
                while( idStatusHttpService <= ifcIDsTATUShTTPsERVICE_READY && !( F(flagsMode) & flIDEAnETeXE_QUIT ) )
                ZE( countT , idPass ) ;
                countT cSkipStomp = TUCK >> 4 ;
                countT cSkipPage  = TUCK >> 5 ;
                ZE( countT , cStompFail ) ;
                ZE( countT , cStomp     ) ;

                ZE( countT , idEpoch    ) ;
                ZE( countT , minuteLath ) ;
                TN( tUnderScore , "_" ) ;
                TN( tb4 , "    " ) ;

                }
                    }
                        etThread.traceF( tin0P , T("I am ready to serve web pages (only to you).  Enter the 'b' command to begin.\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
                        bWoth = 0 ;
                    {
                    if( bWoth )

                    ++ s ; ether.osSleepF( tin0P , TOCK >> 1 ) ;                //GIVE tmHearF TIME TO START LISTENING, BECAUSE I DON'T REMEMBER WHAT IT DOES WITH KEYSTROKES MADE BEFORE IT STARTS WORKING
                {
                while( !ether && !( F(flagsMode) & flIDEAnETeXE_BEGIN ) )
                boolT bWoth = 1 ;
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                etThread.osThreadF( TaRG2cBsTACK( tmHearF , TICK >> 2 ) , (countT)&flagsMode ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
            {
            else
            }
                etThread.traceF( tin0P , T("I cannot serve web pages, likely because there is already an http server running on this computer.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
                bAborted = 1 ;
            {
            if( idStatusHttpService > ifcIDsTATUShTTPsERVICE_READY )

            }
                ++ s ; ether.osSleepF( tin0P ) ;
            {
            while( idStatusHttpService < ifcIDsTATUShTTPsERVICE_READY )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

            etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmServeHttpF , sgnDone_tmServeHttpF , CBsTACKmIN << 2 ) , (countT)&idStatusHttpService , (countT)&tIpv6Now , (countT)&ipv6Fields , (countT)&flagsMode ) ;
            signC sgnDone_tmServeHttpF( tin0P , TAG( TAGiDnULL ) ) ;

            flagsT flagsMode = flIDEAnETeXE_null ;
            ideaNetIpv6FieldsS ipv6Fields ;
            TN( tIpv6Now , ""      ) ;
            ZE( countT , idStatusHttpService ) ;
            etThread.traceF( tin0P , T("\r\nPreparing to serve pages to you...\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
        {
        if( !bQuitEarly )
        ZE( boolT , bAborted ) ;

        etThread.delF( tin0P , psttUnwanted ) ;
        etThread.delF( tin0P , psttWanted ) ;
        boolT bQuitEarly = etThread.strCompareF( tin0P , psttWanted , T("ok") ) ;
        etThread.strHearF( tin0P , psttWanted , psttUnwanted , 2 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;

        ) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

            "\r\n  tell Windows to allow this:  "
            "\r\n  other computers.  Press the Enter key now to quit.  Or, enter \"ok\" to continue, and then, when prompted,"
            "\r\n  I will serve web pages, but only to you.  This is safe, because I will ignore requests that come from"
            "\r\nIdeaFarm (tm) IdeaNet (tm) is a subscribers-only World Wide Web system within the public Internet system."

        etThread.traceF( tin0P , T(

        countT idSub  = 1 ;
        countT idBook = 1 ;

        ZE( strokeS* , psttUnwanted ) ;
        ZE( strokeS* , psttWanted ) ;

        }
            etThread.traceF( tin0P , T("\r\nThis file gives you access to Book 1.  For Book 1, you are subscriber number ")+TF2(idSub,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(".  Subscription id's\r\n  are dispensed serially, starting with 1.  Subscribers with low id numbers will be given\r\n  VIP privileges as the system grows, in appreciation for their role as founders.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

            etThread.traceF( tin0P , T("\r\nThis file is your personal key for access to the IdeaFarm (tm) IdeaNet (tm) Book Publishing System.\r\n  Do not share this file with others.  Abuse will result in suspension or termination of your access.\r\n  You may use this key only if you are the owner of email address ")+tEmail , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

            countT              idSub  = sub ;
            TN( tEmail , "" ) ; tEmail = sub ;

            sub.traceF( tin0P ) ;

            sub << soulSub ;

            etThread.delF( tin0P , pbs ) ;
            soulSub.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_byteTptr , pbs , 0 , 0 , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
            soulC soulSub( tin0P , etThread , TAG( TAGiDnULL ) ) ;

            etThread.strUnDumpF( tin0P , pbs , cbs , T(postSoulSubDump) ) ; ___( pbs ) ;
            ZE( countT , cbs ) ;
            ZE( byteT* , pbs ) ;
        {
        ideaNetSubscriptionC sub( tin0P , etThread ) ;

        TN( tY , "y" ) ;
        TN( tb4 , "    " ) ;
    {
    else
    if( !LoadStringA( 0 , 101 , postSoulSubDump , sizeof postSoulSubDump ) ) etThread.traceF( tin0P , T("Either this file is not configured (for your email address), or it is corrupted.  Please discard it and obtain a fresh copy by (re)registering your email address at http://ideafarm.com .") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

    }
        }
            if( !etThread.strCompareF( tin0P , psttc1 , tHeyGorilla ) ) bGorilla = 1 ;
            etThread.traceF( tin0P , T("[parameter]:    ")+T(psttc1) ) ;
        {
        FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tin0P ) )
        TN( tHeyGorilla , "!gorilla" ) ;
    {
    ZE( boolT , bGorilla ) ;
{
if( pTaskP )
TASK( tmWorkF )

osTextT postSoulSubDump[ TUCK << 4 ] ;

DONE( tmHearF )
}
    }
        etThread.delF( tin0P , psttUnwanted ) ;
        etThread.delF( tin0P , psttWanted   ) ;

        else                                                            {                                            etThread.traceF( tin0P , tHelp                                      , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ; }
        else if( !etThread.strCompareF( tin0P , T("f") , psttWanted ) ) { flagsModeP &= ~( F(flIDEAnETeXE_HTTPS) ) ; etThread.traceF( tin0P , T("I will use \"fast mode\" (http).\r\n" ) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ; }
        else if( !etThread.strCompareF( tin0P , T("s") , psttWanted ) ) { flagsModeP |=      flIDEAnETeXE_HTTPS    ; etThread.traceF( tin0P , T("I will use \"slow mode\" (https).\r\n") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ; }
        else if( !etThread.strCompareF( tin0P , T("b") , psttWanted ) ) { flagsModeP |=      flIDEAnETeXE_BEGIN    ; etThread.traceF( tin0P , T("Synchronizing...\r\n"                 ) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ; }
             if( !psttWanted || !psttWanted->idAdam                   ) { FIREmYSELF }

        //etThread.traceF( tin0P , T("[psttUnwanted]:    ")+T(psttUnwanted) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        //etThread.traceF( tin0P , T("[psttWanted]:      ")+T(psttWanted  ) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        etThread.strHearF( tin0P , psttWanted , psttUnwanted , 1 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;
        ZE( strokeS* , psttUnwanted ) ;
        ZE( strokeS* , psttWanted   ) ;
    {
    while( !ether && !( F(flagsModeP) & flIDEAnETeXE_QUIT ) )

    etThread.traceF( tin0P , tHelp , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
 
    ) ;

        "Press the 'Enter' key, preceded by 'h' or any other keystrokes, to view this help.\r\n"
        "Press the 'Enter' key, preceded by no keystrokes, to \"fire\" me (to end this program).\r\n"
        "\r\n"
        "  'f' : Use \"fast mode\" (http).  No data is encrypted.  Fast because the domain name system is not needed.\r\n"
        "  's' : Use \"slow mode\" (https).  (Most of the data passing between you and the server is encrypted.)\r\n"
        "\r\n"
        "  Case matters; 'X' denotes cap X, while 'x' denotes x.  (Do not key the single quotes.)\r\n"
        "While I am working, you can enter commands by pressing the 'Enter' key after pressing and releasing wo of the following keys.\r\n"

    TN( tHelp ,

    flagsT& flagsModeP = *(flagsT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmHearF )

DONE( tmServeHttpF )
}
    //THREADmODE2rESTORE0( flagsSave )
    }
        //THREADmODE2oN0( flTHREADmODE2_UNLOCKpOOLiDENTITY )
        //THREADmODE2sAVE0( flagsSave )

        }
            etThread.traceF( tin0P , T("cleaning up") ) ;
            }
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
            {
            while( !ether && idStatusHttpServiceP <= ifcIDsTATUShTTPsERVICE_READY )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            etThread.traceF( tin0P , T("loafing") ) ;

            httpServerC serverU( tin0P , arg1U , arg2 , &cache ) ;
        {

        cacheC cache( tin0P , etThread ) ;
        httpServerC_arg2S arg2 ;
        httpServerC_arg1S arg1U( TAG( TAGiDnULL ) , etThread , cArgApp , idStatusHttpServiceP , ifcIDpORT_HTTP  , flSOCKETc_null , T("World Wide Web") , 1 ) ;

        countT cArgApp = (countT)&c9p ;
        count9S c9p( (countT)&tIpv6NowP , (countT)&ipv6FieldsP , (countT)&flagsModeP ) ;
    {
    ZE( flagsT , flagsSave ) ;

    flagsT&             flagsModeP           =             *(flagsT*)pTaskP->c4 ;
    ideaNetIpv6FieldsS& ipv6FieldsP          = *(ideaNetIpv6FieldsS*)pTaskP->c3 ;
    textC&              tIpv6NowP            =              *(textC*)pTaskP->c2 ;
    countT&             idStatusHttpServiceP =             *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmServeHttpF )

// LIKE 8bc BUT DNS SERVER REPLACED WITH HTTP SERVER
// OBSOLETES: 8bc_

/*1*/WAKEhIDE( "ifcIDaDAM_IDEAnET" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
