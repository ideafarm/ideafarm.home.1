
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK >> 2 ) ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

#endif
}
//    bFail = WSACleanup() ;

    if( bFail ) ;

    bFail = bind( osh , (sockaddr*)&info2 , sizeof info2 ) ;

    info2.sin6_port   = (short)htons( 0x00000035 ) ;
    info2.sin6_family = AF_INET6 ;
    static sockaddr_in6 info2 ;

    unsigned osh = socket( PF_INET6 , SOCK_DGRAM , 0 ) ;

    }
//        bFail = WSAStartup( 0x0202 , &info1 ) ;
//        WSADATA info1 ;
    {

    int bFail = 0 ;
{
#if defined( NEVERdEFINED )

TODO

DONE( tmWorkF )
}
    }
        sgnDone_tmServeHttpF.waitF( tin0P ) ;
        }
            FIREmYSELF

            etThread.traceF( tin0P , T("I am no longer serving web pages.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;

            }
                ++ s ; etThread.osSleepF( tin0P , TUCK >> 6 ) ;

                }
                    //etThread.traceF( tin0P , T("[time,ipv6]:    ")+TT(timeN1,timeN2)+tb4+T(nnNow) , flTRACE_NOpREFIX ) ;
                    nicNameC nnNow = sub.nnF( tin0P , minute ) ;

                    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT  , timeN1 ) ;

                    minuteLath = minute ;
                {
                if( minuteLath != minute )                          // A:ASSUME: THE LIFETIME OF EACH ipv6 ADDRESS IS GREATER THAN RE MINUTES, SO THAT THE ipv6 OF THE LATH MINUTE WILL CONTINUE TO BE VALID WELL AFTER I NO LONGER OBTAIN ITS VALUE
                countT minute = ( timeN1 >> 0x14 ) - 1 ;            // USE THE PRIOR MINUTE

                etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT  , timeN1 ) ;
            {
            while( !bHeardEnterKey && idStatusHttpService <= ifcIDsTATUShTTPsERVICE_READY )
            ZE( countT , minuteLath ) ;

            ideaNetSubscriptionC sub( tin0P , etThread , 1 , 1 , tSecret ) ; ___( pSubP ) ;

            TN( tSecret , "308f" "c905" "2f7e" "f879" "38b0" "e553" "4095" "944f" "1c0b" "88e5" ) ;         //CODED THIS WAY TO AVOID TRIGGERING GITGUARDIAN ; THIS IS A SECRET BUT ONLY FOR TESTING ; NO HARM CAN COME FROM DISCLOSURE
            TN( tb4 , "    " ) ;

            etThread.traceF( tin0P , T("Press the Enter key, and I will stop serving web pages, which will disable your access to IdeaNet (tm):    ") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.osThreadF( TaRG2cBsTACK( tmHearF , TICK >> 2 ) , (countT)&bHeardEnterKey ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
            ZE( boolT , bHeardEnterKey ) ;

            etThread.traceF( tin0P , T("I am ready to serve web pages.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
        {
        else
        }
            etThread.traceF( tin0P , T("I cannot serve web pages, likely because there is already an http server running on this computer.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
            bAborted = 1 ;
        {
        if( idStatusHttpService > ifcIDsTATUShTTPsERVICE_READY )

        }
            ++ s ; ether.osSleepF( tin0P ) ;
        {
        while( idStatusHttpService < ifcIDsTATUShTTPsERVICE_READY )
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmServeHttpF , sgnDone_tmServeHttpF , CBsTACKmIN << 2 ) , (countT)&idStatusHttpService ) ;
        signC sgnDone_tmServeHttpF( tin0P , TAG( TAGiDnULL ) ) ;
        ZE( countT , idStatusHttpService ) ;
    {
    ZE( boolT , bAborted ) ;

    etThread.delF( tin0P , psttUnwanted ) ;
    etThread.delF( tin0P , psttWanted ) ;
    etThread.strHearF( tin0P , psttWanted , psttUnwanted , 0 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;

    ) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

        "\r\nThis is safe, because I will ignore requests that come from any computers other than yours:    "
        "\r\nPress the Enter key, and then, when prompted, tell Windows to allow me to serve web pages (to you)."
        "IdeaFarm (tm) IdeaNet (tm) is a subscribers-only World Wide Web system within the public Internet system."

    etThread.traceF( tin0P , T(

    ZE( strokeS* , psttUnwanted ) ;
    ZE( strokeS* , psttWanted ) ;

    TN( tY , "y" ) ;

        etThread.delF( tin0P , psttBrowser ) ;
        //etThread.traceF( tin0P , psttBrowser ) ;
        etThread.osHttpViewerF( tin0P , psttBrowser ) ; ___( psttBrowser ) ;
        ZE( strokeS* , psttBrowser ) ;
{
if( pTaskP )
TASK( tmWorkF )

DONE( tmHearF )
}
    bHeardEnterKeyP = 1 ;

    etThread.delF( tin0P , psttUnwanted ) ;
    etThread.delF( tin0P , psttWanted ) ;
    etThread.strHearF( tin0P , psttWanted , psttUnwanted , 0 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;
    ZE( strokeS* , psttUnwanted ) ;
    ZE( strokeS* , psttWanted ) ;

    boolT& bHeardEnterKeyP = *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmHearF )

DONE( tmServeHttpF )
}
    THREADmODE2rESTORE0( flagsSave )
    }
        THREADmODE2oN0( flTHREADmODE2_UNLOCKpOOLiDENTITY )
        THREADmODE2sAVE0( flagsSave )

        }
            etThread.traceF( tin0P , T("cleaning up") ) ;
            }
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
            {
            while( !ether && idStatusHttpServiceP <= ifcIDsTATUShTTPsERVICE_READY )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            etThread.traceF( tin0P , T("loafing") ) ;

            //U::        while( cDo -- ) etThread.osThreadF( TaRG1( tmUpdateCacheF ) ) ;
            countT cDo = 2 ;                                                // CS:CODEsYNC: 5100057b 5100057b

//            httpServerC serverS( tin0P , arg1S , arg2 , &cache ) ;
            httpServerC serverU( tin0P , arg1U , arg2 , &cache ) ;
        {

        else
        }
            etThread.traceF( tin0P , T("cleaning up") ) ;
            }
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
            {
            while( !ether && idStatusHttpServiceP <= ifcIDsTATUShTTPsERVICE_READY )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            etThread.traceF( tin0P , T("loafing") ) ;

            //U::        while( cDo -- ) etThread.osThreadF( TaRG1( tmUpdateCacheF ) ) ;
            countT cDo = 2 ;                                                // CS:CODEsYNC: 5100057b 5100057b

            httpServerC serverU( tin0P , arg1U , arg2 , &cache ) ;
        {
        if( F(processGlobal2S::_processGlobal2I_IF()._thirdC_flagsProcessState) & flPROCESSsTATE_EXEcONTAINSbASEaNDaDAM )
        //U::COMMENT OUT THIS BLOCK OF CODE IN PRODUCTION ; (THIS IS USED FOR TESTING OF CODE THAT WILL BE USED IN IDEANET.EXE)

        //20251029@1450: ENABLED BECAUSE GORILLA USES HTTP
        //20251017@1048: DISABLED BECAUSE CERTBOT NO LONGER USED AND dns-01 IS NOW USED TO PROVE CONTROL OVER THE hidden.ideafarm.com DOMAIN (TO GET A WILDCARD CERTIFICATE FOR THAT DOMAIN)
        //20241122@1004: ENABLED SO THAT CERTBOT CAN RENEW
        //20240210@2035: DISABLED FOR SECURITY (FACTORY1 USES HTTPS AND ONLY TO RECEIVE NOTICES FROM Stripe)

        cacheC cache( tin0P , etThread ) ;

        arg2.pnnAllowedStripe = &nnAllowed ;

        //U:: ENABLE AFTER REWRITE DATABASE SUBSYSTEMS FOR BILLING:: arg2.pHttpFreshenCacheCBF = httpFreshenCacheCBF ;
        httpServerC_arg2S arg2 ;
        httpServerC_arg1S arg1S( TAG( TAGiDnULL ) , etThread , cArgApp , idStatusHttpServiceP , ifcIDpORT_HTTPS , flSOCKETc_CRYPTfOREIGNsSL | flSOCKETc_CRYPTfOREIGNsSLdEFERhANDSHAKE , T("World Wide Web Secured") ) ;    //ifcDrivenServerF WILL DO HANDSHAKE AFTER IT DECIDES TO NOT SILENTLY CLOSE THE CONNECTION ; THIS IS TO PREVENT MALICIOUS PEERS FROM EXPLOITING THE SHIT WITHIN OpenSSL
        httpServerC_arg1S arg1U( TAG( TAGiDnULL ) , etThread , cArgApp , idStatusHttpServiceP , ifcIDpORT_HTTP  , flSOCKETc_null                                                      , T("World Wide Web") ) ;

        //etThread.osThreadF( TaRG1( tmDisplayStatus ) , (countT)&idStatusHttpServiceP ) ;

        countT cArgApp = (countT)&c9p ;
        count9S c9p( 0 ) ;

        //THREADmODE2rESTORE0( flagsSave )
        //puseC puse( tin0P , ifcIDpOOL_ADAMtEMP ) ;
        //puseC pusePeanut( tin0P , "list.lath.peanut" , flPOOLc_null , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
        //THREADmODE2oN0( flTHREADmODE2_UNLOCKpOOLiDENTITY )
        //THREADmODE2sAVE0( flagsSave )
        //20120901: COMMENTED OUT TO GET THIS TO WORK
    {
    ZE( flagsT , flagsSave ) ;

    nicNamesAllowedStripeWebHookNotificationsC nnAllowed( tin0P , etThread , ether , TICK << 4 ) ;      // "<< 4" IN PRODUCTION

    }
        etThread.delF( tin0P , psttEat ) ;
        if( psttEat ) bAllowAllDomains = !etThread.strCompareF( tin0P , psttEat , T("yes") ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , tSettingKey  ) ; ___( psttEat ) ;
        TN( tSettingKey , "!ipdos.http.allow.all.domains" ) ;
        _IO_
    {
    ZE( boolT , bAllowAllDomains ) ;

    //etThread.osThreadF( TaRG1( tmPopOpenPortF ) ) ;

//    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE ) ;
//    thirdC::dosPriorityProcessIF(      tin0P , ifcTHREADpRIORITY_RUDE ) ; // "RUDE" SO THAT I RESPOND TO GORILLA WITH CONSISTENT "REAL TIME" SPEED ; THIS CREATES AN ATTACK SURFACE ; CPU SPINNING *MUST* BE PREVENTED (IMPOTENCE CPU SPIN BUGS, DDOS HTTP FLOOD ATTACKS)

    countT& idStatusHttpServiceP = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmServeHttpF )

DONE( tmDisplayStatus )
}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
        etThread.traceF( tin0P , tSay1+TF2(idStatusHttpServiceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX ) ;
    {
    while( !ether && idStatusHttpServiceP <= ifcIDsTATUShTTPsERVICE_READY )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    TN( tSay1 , "\rlocal loopback http server status:    " ) ;

    const countT& idStatusHttpServiceP = *(const countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmDisplayStatus )

#endif
        }

        {
        if( bFirefox )

        etThread.delF( tin0P , psttUnwanted ) ;
        etThread.delF( tin0P , psttWanted ) ;
        boolT bFirefox = !etThread.strCompareF( tin0P , psttWanted , tY ) ;
        etThread.strConvertToLowerCaseF( tin0P , psttWanted ) ;
        etThread.strHearF( tin0P , psttWanted , psttUnwanted , 1 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;
        etThread.traceF( tin0P , T("Is Firefox your default browser on this computer? ('y' or 'n'):    ") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;

        etThread.osHttpViewF( tin0P , T("about:config?dnsCache") , 0 ) ;

        etThread.delF( tin0P , psttBrowser ) ;
        etThread.traceF( tin0P , psttBrowser ) ;
        etThread.osHttpViewerF( tin0P , psttBrowser ) ; ___( psttBrowser ) ;
        ZE( strokeS* , psttBrowser ) ;
#if defined( NEVERdEFINED )

// LIKE 8bc BUT DNS SERVER REPLACED WITH HTTP SERVER

//OBSOLETES: 8bc_

//OBSOLETED BY: 8c0_

/*1*/WAKEhIDE( "ifcIDaDAM_IDEAnET" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
