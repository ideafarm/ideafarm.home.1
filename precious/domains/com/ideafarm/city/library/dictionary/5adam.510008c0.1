
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK >> 2 ) ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        sgnDone_tmServeHttpF.waitF( tin0P ) ;
        }
            FIREmYSELF

            etThread.traceF( tin0P , T("I am no longer serving web pages.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;

            }
                ++ s ; etThread.osSleepF( tin0P , TUCK >> 6 ) ;

                }
                    }
                        etThread.delF( tin0P , posti ) ;
                        }
                            etRock.traceF( tin0P , T("stomp! end [idStomp,cFail]:    ")+TF2(cStomp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(++cStompFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            POOPRqUIET
                        {
                        else
                        if( !POOP ) etRock.traceF( tin0P , T("stomp! aok [idStomp]:    ")+TF2(cStomp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , tUrl , 1 , 0 , 0 , flOPENdETAILS_null , flBOXcgETf_HTTPdOnOTpREPENDhEADER | flBOXcgETf_TRACEeXCEPTIONS , tUrl , tUrl.csF( tin0P ) ) ; ___( posti ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;
                        etRock.traceF( tin0P , T("stomp! begin [idStomp]:    ")+TF2(cStomp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        SCOOPS
                        _IO_
                    {
                    IFsCRATCHoK
                    cStomp ++ ;

                    TN( tUrl , "" ) ; tUrl  = T("http://")+TF3(pcHash[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+TF3(pcHash[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T("-1-1.ideanet.ideafarm.com/") ;
                    countT* pcHash = (countT*)&hashNow ;
                    //CS:CODEsYNC: 510008c0 33000116
                {
                if( bGorilla )

                }
                    etThread.traceF( tin0P , T("[time,ipv6]:    ")+TT(timeN1,timeN2)+tb4+tIpv6Now , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX ) ;

                    tIpv6Now = T(nnNow) ;
                    nicNameC nnNow = sub.nnF( tin0P , hashNow , minute ) ;
                    hashNow = 0 ;

                    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                    ZE( sCountT , timeN2 ) ;
                    ZE( countT  , timeN1 ) ;

                    }
                        countT rc = (countT)ShellExecuteA( 0 , 0 , "http://[::1]/ideanet" , 0 , 0 , SW_SHOW ) ;     //U:: MOVE SUPPORT FOR THIS INTO thirdC etherC
                    {
                    if( ++ idEpoch == 2 )       // 2 IS PROBABLY SUFFICIENT ; IF I LAUNCH THE PAGE RIGHT AWAY, ITS IPV6 ADDRESS MIGHT NOT YET EXIST (THIS HAS BEEN OBSERVED) ; CONJ: THE IPV6 ADDRESS EXISTS ON WEB1 BUT ROUTER DOES NOT YET KNOW ABOUT IT ; THE REASON THAT A DELAY IS HELPFUL IS A MYSTERY
                    minuteLath = minute ;
                {
                if( minuteLath != minute )                          // A:ASSUME: THE LIFETIME OF EACH ipv6 ADDRESS IS GREATER THAN RE MINUTES, SO THAT THE ipv6 OF THE LATH MINUTE WILL CONTINUE TO BE VALID WELL AFTER I NO LONGER OBTAIN ITS VALUE
                countT minute = ( timeN1 >> 0x14 ) - 1 ;            // USE THE PRIOR MINUTE (TO AVOID RACING WITH THE WEB SERVER)

                etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT  , timeN1 ) ;
            {
            while( !bHeardEnterKey && idStatusHttpService <= ifcIDsTATUShTTPsERVICE_READY )
            ZE( countT , cStompFail ) ;
            ZE( countT , cStomp     ) ;

            ZE( countT , idEpoch    ) ;
            ZE( countT , minuteLath ) ;

            ideaNetSubscriptionC sub( tin0P , etThread , idBook , idSub , tSecret ) ; ___( pSubP ) ;

            TN( tSecret , "bc2a" "79d2" "dc3d" "4462" "c587" "603e" "c576" "5563" "dd57" "181f" ) ;         //CS:CODEsYNC: 510008c0 510008af
            //CODED THIS WAY TO AVOID TRIGGERING GITGUARDIAN ; THIS IS A SECRET BUT ONLY FOR TESTING ; NO HARM CAN COME FROM DISCLOSURE

            TN( tb4 , "    " ) ;

            etThread.traceF( tin0P , T("Press the Enter key, and I will stop serving web pages, which will disable your access to IdeaNet (tm):    ") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.osThreadF( TaRG2cBsTACK( tmHearF , TICK >> 2 ) , (countT)&bHeardEnterKey ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
            ZE( boolT , bHeardEnterKey ) ;

            etThread.traceF( tin0P , T("I am ready to serve web pages.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
        {
        else
        }
            etThread.traceF( tin0P , T("I cannot serve web pages, likely because there is already an http server running on this computer.") , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;
            bAborted = 1 ;
        {
        if( idStatusHttpService > ifcIDsTATUShTTPsERVICE_READY )

        }
            ++ s ; ether.osSleepF( tin0P ) ;
        {
        while( idStatusHttpService < ifcIDsTATUShTTPsERVICE_READY )
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmServeHttpF , sgnDone_tmServeHttpF , CBsTACKmIN << 2 ) , (countT)&idStatusHttpService , (countT)&tIpv6Now , (countT)&hashNow , (countT)&idBook , (countT)&idSub ) ;
        signC sgnDone_tmServeHttpF( tin0P , TAG( TAGiDnULL ) ) ;

        ZE( count04T , hashNow ) ;
        TN( tIpv6Now , ""      ) ;
        ZE( countT , idStatusHttpService ) ;
    {
    ZE( boolT , bAborted ) ;

    etThread.delF( tin0P , psttUnwanted ) ;
    etThread.delF( tin0P , psttWanted ) ;
    etThread.strHearF( tin0P , psttWanted , psttUnwanted , 0 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;

    ) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

        "\r\nThis is safe, because I will ignore requests that come from any computers other than yours:    "
        "\r\nPress the Enter key, and then, when prompted, tell Windows to allow me to serve web pages (to you)."
        "IdeaFarm (tm) IdeaNet (tm) is a subscribers-only World Wide Web system within the public Internet system."

    etThread.traceF( tin0P , T(

    countT idSub  = 1 ;
    countT idBook = 1 ;

    ZE( strokeS* , psttUnwanted ) ;
    ZE( strokeS* , psttWanted ) ;

    TN( tY , "y" ) ;
    TN( tb4 , "    " ) ;

    }
        }
            if( !etThread.strCompareF( tin0P , psttc1 , tHeyGorilla ) ) bGorilla = 1 ;
            etThread.traceF( tin0P , T("[parameter]:    ")+T(psttc1) ) ;
        {
        FORsTRINGSiN1( etThread.ether_pstt1_processParametersI_F( tin0P ) )
        TN( tHeyGorilla , "!gorilla" ) ;
    {
    ZE( boolT , bGorilla ) ;
{
if( pTaskP )
TASK( tmWorkF )

DONE( tmHearF )
}
    bHeardEnterKeyP = 1 ;

    etThread.delF( tin0P , psttUnwanted ) ;
    etThread.delF( tin0P , psttWanted ) ;
    etThread.strHearF( tin0P , psttWanted , psttUnwanted , 0 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;
    ZE( strokeS* , psttUnwanted ) ;
    ZE( strokeS* , psttWanted ) ;

    boolT& bHeardEnterKeyP = *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmHearF )

DONE( tmServeHttpF )
}
    THREADmODE2rESTORE0( flagsSave )
    }
        THREADmODE2oN0( flTHREADmODE2_UNLOCKpOOLiDENTITY )
        THREADmODE2sAVE0( flagsSave )

        }
            etThread.traceF( tin0P , T("cleaning up") ) ;
            }
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
            {
            while( !ether && idStatusHttpServiceP <= ifcIDsTATUShTTPsERVICE_READY )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            etThread.traceF( tin0P , T("loafing") ) ;

            //U::        while( cDo -- ) etThread.osThreadF( TaRG1( tmUpdateCacheF ) ) ;
            countT cDo = 2 ;                                                // CS:CODEsYNC: 5100057b 5100057b

            httpServerC serverU( tin0P , arg1U , arg2 , &cache ) ;
        {

        else
        }
            etThread.traceF( tin0P , T("cleaning up") ) ;
            }
                ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
            {
            while( !ether && idStatusHttpServiceP <= ifcIDsTATUShTTPsERVICE_READY )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            etThread.traceF( tin0P , T("loafing") ) ;

            //U::        while( cDo -- ) etThread.osThreadF( TaRG1( tmUpdateCacheF ) ) ;
            countT cDo = 2 ;                                                // CS:CODEsYNC: 5100057b 5100057b

            httpServerC serverU( tin0P , arg1U , arg2 , &cache ) ;
        {
        if( F(processGlobal2S::_processGlobal2I_IF()._thirdC_flagsProcessState) & flPROCESSsTATE_EXEcONTAINSbASEaNDaDAM )
        //U::COMMENT OUT THIS BLOCK OF CODE IN PRODUCTION ; (THIS IS USED FOR TESTING OF CODE THAT WILL BE USED IN IDEANET.EXE)

        //20251029@1450: ENABLED BECAUSE GORILLA USES HTTP
        //20251017@1048: DISABLED BECAUSE CERTBOT NO LONGER USED AND dns-01 IS NOW USED TO PROVE CONTROL OVER THE hidden.ideafarm.com DOMAIN (TO GET A WILDCARD CERTIFICATE FOR THAT DOMAIN)
        //20241122@1004: ENABLED SO THAT CERTBOT CAN RENEW
        //20240210@2035: DISABLED FOR SECURITY (FACTORY1 USES HTTPS AND ONLY TO RECEIVE NOTICES FROM Stripe)

        cacheC cache( tin0P , etThread ) ;

        arg2.pnnAllowedStripe = &nnAllowed ;

        //U:: ENABLE AFTER REWRITE DATABASE SUBSYSTEMS FOR BILLING:: arg2.pHttpFreshenCacheCBF = httpFreshenCacheCBF ;
        httpServerC_arg2S arg2 ;
        httpServerC_arg1S arg1S( TAG( TAGiDnULL ) , etThread , cArgApp , idStatusHttpServiceP , ifcIDpORT_HTTPS , flSOCKETc_CRYPTfOREIGNsSL | flSOCKETc_CRYPTfOREIGNsSLdEFERhANDSHAKE , T("World Wide Web Secured") ) ;    //ifcDrivenServerF WILL DO HANDSHAKE AFTER IT DECIDES TO NOT SILENTLY CLOSE THE CONNECTION ; THIS IS TO PREVENT MALICIOUS PEERS FROM EXPLOITING THE SHIT WITHIN OpenSSL
        httpServerC_arg1S arg1U( TAG( TAGiDnULL ) , etThread , cArgApp , idStatusHttpServiceP , ifcIDpORT_HTTP  , flSOCKETc_null                                                      , T("World Wide Web") ) ;

        //etThread.osThreadF( TaRG1( tmDisplayStatus ) , (countT)&idStatusHttpServiceP ) ;

        countT cArgApp = (countT)&c9p ;
        count9S c9p( (countT)&tIpv6NowP , (countT)&hashNowP , (countT)&idBookP , (countT)&idSubP ) ;

        //THREADmODE2rESTORE0( flagsSave )
        //puseC puse( tin0P , ifcIDpOOL_ADAMtEMP ) ;
        //puseC pusePeanut( tin0P , "list.lath.peanut" , flPOOLc_null , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
        //THREADmODE2oN0( flTHREADmODE2_UNLOCKpOOLiDENTITY )
        //THREADmODE2sAVE0( flagsSave )
        //20120901: COMMENTED OUT TO GET THIS TO WORK
    {
    ZE( flagsT , flagsSave ) ;

    nicNamesAllowedStripeWebHookNotificationsC nnAllowed( tin0P , etThread , ether , TICK << 4 ) ;      // "<< 4" IN PRODUCTION

    }
        etThread.delF( tin0P , psttEat ) ;
        if( psttEat ) bAllowAllDomains = !etThread.strCompareF( tin0P , psttEat , T("yes") ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , tSettingKey  ) ; ___( psttEat ) ;
        TN( tSettingKey , "!ipdos.http.allow.all.domains" ) ;
        _IO_
    {
    ZE( boolT , bAllowAllDomains ) ;

    //etThread.osThreadF( TaRG1( tmPopOpenPortF ) ) ;

//    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE ) ;
//    thirdC::dosPriorityProcessIF(      tin0P , ifcTHREADpRIORITY_RUDE ) ; // "RUDE" SO THAT I RESPOND TO GORILLA WITH CONSISTENT "REAL TIME" SPEED ; THIS CREATES AN ATTACK SURFACE ; CPU SPINNING *MUST* BE PREVENTED (IMPOTENCE CPU SPIN BUGS, DDOS HTTP FLOOD ATTACKS)

    countT&   idSubP               =   *(countT*)pTaskP->c5 ;
    countT&   idBookP              =   *(countT*)pTaskP->c4 ;
    count04T& hashNowP             = *(count04T*)pTaskP->c3 ;
    textC&    tIpv6NowP            =    *(textC*)pTaskP->c2 ;
    countT&   idStatusHttpServiceP =   *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmServeHttpF )

#endif
    DONE( tmDisplayStatus )
    }
        }
            ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
            etThread.traceF( tin0P , tSay1+TF2(idStatusHttpServiceP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) , flTRACE_IGNOREpROCESSsTATEeXEcONTAINSbASEaNDaDAM | flTRACE_NOpREFIX ) ;
        {
        while( !ether && idStatusHttpServiceP <= ifcIDsTATUShTTPsERVICE_READY )
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        TN( tSay1 , "\rlocal loopback http server status:    " ) ;

        const countT& idStatusHttpServiceP = *(const countT*)pTaskP->c1 ;
    {
    if( pTaskP && pTaskP->c1 )
    TASK( tmDisplayStatus )
#if defined( NEVERdEFINED )

#endif
        }

        {
        if( bFirefox )

        etThread.delF( tin0P , psttUnwanted ) ;
        etThread.delF( tin0P , psttWanted ) ;
        boolT bFirefox = !etThread.strCompareF( tin0P , psttWanted , tY ) ;
        etThread.strConvertToLowerCaseF( tin0P , psttWanted ) ;
        etThread.strHearF( tin0P , psttWanted , psttUnwanted , 1 ) ; ___( psttWanted ) ; ___( psttUnwanted ) ;
        etThread.traceF( tin0P , T("Is Firefox your default browser on this computer? ('y' or 'n'):    ") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;

        etThread.osHttpViewF( tin0P , T("about:config?dnsCache") , 0 ) ;

        etThread.delF( tin0P , psttBrowser ) ;
        etThread.traceF( tin0P , psttBrowser ) ;
        etThread.osHttpViewerF( tin0P , psttBrowser ) ; ___( psttBrowser ) ;
        ZE( strokeS* , psttBrowser ) ;
#if defined( NEVERdEFINED )

// LIKE 8bc BUT DNS SERVER REPLACED WITH HTTP SERVER

//OBSOLETES: 8bc_

//OBSOLETED BY: 8c0_

/*1*/WAKEhIDE( "ifcIDaDAM_IDEAnET" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
