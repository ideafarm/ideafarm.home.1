
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
        if( F(flags) & flSOCKETc_CRYPTfOREIGNsSL && !( F(flags) & flSOCKETc_CRYPTfOREIGNsSLdEFERhANDSHAKE ) ) shakeHandsAsClientF( tin0P ) ;
    
        if( timeAllowedConnected ) FRESHtIMEaTOMIC( *pEther , timeConnected.time1 , timeConnected.time2 )
    
        }
            //CONoUTrAW( " connected in the clear\r\n" ) ;
            //CONoUTrAW( ((tin9S&)tin0P).postThreadName ) ;
            bWrite.ungrabF( tin0P ) ;
            bRead.ungrabF( tin0P ) ;
        {
        else
        }
            bWrite.ungrabF( tin0P ) ;
            bRead.ungrabF( tin0P ) ;
            pEther->cioMakeKeyF( tin0P , pczKeyTopSecret , idbKEYtYPE_PIN , idbKEYpINtYPE_SOCKETcONNECTION ) ; ___( pczKeyTopSecret ) ;
            __NZ( pczKeyTopSecret ) ;
            //CONoUTrAW( "CONNECTED IN TOP SECRET MODE\r\n" ) ;
        {
        if( F(flags) & flSOCKETc_TOPsECRET )
    
        }
            myNameF( tin0P , idPortMe , idh ) ;
            nicNameC idh ;
            idPortMe = 0 ;
        {
    
        nnPeer = nicNameP ;
        THREADmODE2rESTORE
        pEther->sockConnectF( tin0P , handle , idPort , nicNameP , cTriesP , time1P , time2P ) ;
        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
    
        bRead.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        bWrite.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    
        }
            //pEther->strokeF( tin0P , T("the chat server told me to connect to port ")+TF1(idPort)+T("\r\n") ) ;
    
            souli >> idPort ;
            __( idReply - ifcIDcMDsESSION_NEWsOCKETrEPLY ) ;
            souli >> idReply ;
            ZE( countT , idReply ) ;
            sChat.readF( tin0P , souli ) ;
            soulC souli( tin0P , TAG( TAGiDnULL ) ) ;
    
            sChat.writeF( tin0P , soulo ) ;
            soulC soulo( tin0P , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_NEWsOCKET ) ;
    
            sChat.connectF( tin0P , ifcPORToLD2_CHAT , nicNameP ) ;
            socketC sChat( tin0P , *pEther , TAG( TAGiDnULL ) ) ;
        {
        if( !idPort )
        countT idPort = idPortP ;
    
        }
            }
                }
                    break ;
                    CONoUTrAW9( "" , ((tin9S&)tin0P).pag1->idAdam , "/connectF: mapping connection to  " , *(const countT*)nicNameP , " port " , pMap->pPort[ offp ].idPortSpecified , " to port " , pMap->pPort[ offp ].idPortActual , "\r\n" ) ;
                    idPortP =  pMap->pPort[ offp ].idPortActual ; //U::RACE: MIGHT STILL BE ZE
                {
                if( idPortP == pMap->pPort[ offp ].idPortSpecified )
            {
            for( countT offp = 0 ; offp < cSlots ; offp ++ )
            const countT cSlots = sizeof pMap->pPort / sizeof pMap->pPort[ 0 ] ;
        {
        if( pMap )
    
        }
            if( !cToDo || F(pMap->flagsHome) & flIPmAPhOMEs_NOmAPPING ) pMap = 0 ;
    
            }
                cToDo -- ;
                pMap ++ ;
                if( pMap->nnHome == nicNameP ) break ;
            {
            while( cToDo )
            countT cToDo = CiPmAPhOME ;
            pMap = (ipMapHomeS*)(byteT*)processGlobal8I._socketC_napIpMapHome ;
        {
        if( nicNameP )
        ZE( ipMapHomeS* , pMap ) ;
    
        _IO_
    
        }
            }
                return ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL    
        SCOOPP
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/voidT socketC::connectF( tin0S& tin0P , countT idPortP , const nicNameC nicNameP , countT cTriesP , const countT time1P , const sCountT time2P )/*1*/

/**/
*/
 time2P
 time1P
 cTriesP
  if 0 then the local host is implied
  can be 0
 nicNameP
  if 0 then will connect to a port specified by the port ifcPORToLD2_CHAT server of nicNameP
  can be 0
 idPortP
 tin0P
arguments
most applications should only specify the tin0P argument
the peer socket must be listening for new clients
connects to a peer socket
  \<A HREF=\"5.8420104.1.1.0.html\"\>8420104:  WAKEsHOW( "example.simplest.func.1070007.socketC.connectF" )\</A\>
 simplest
examples
\<A HREF=\"5.1070007.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$connectF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

