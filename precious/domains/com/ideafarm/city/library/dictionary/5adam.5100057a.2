
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return *this ;

    }
        else { ether.strMakeF( tin0P , LF , psttEmail , datum.psttEmail ) ; ___( psttEmail ) ; }
        }
            }
                ether.delF( tin0P , psttd ) ;
                ether.strMakeF( tin0P , LF , psttEmail , T(psttd)+T("\r\n")+T(datum.psttEmail) ) ; ___( psttEmail ) ;
                strokeS* psttd = psttEmail ; psttEmail = 0 ;
            {
            if( ether.strCompareF( tin0P , psttEmail , datum.psttEmail ) )
        {
        if( psttEmail )
    {
    if( datum.psttEmail )

    if( !psttZip ) { ether.strMakeF( tin0P , LF , psttZip , datum.psttZip ) ; ___( psttZip ) ; }
    const datumEmailZipC& datum = *(datumEmailZipC*)&plateP ;
    TINSL
{
plateC& datumEmailZipC::operator +=( plateC& plateP )

}
    return psttRpt ;

    ether.strMakeF( tin0P , LF , psttRpt , psttEmail ) ; ___( psttRpt ) ;

    ether.delF( tin0P , psttRpt ) ; //U::RECALC ONLY IF STALE
    TINSL
{
datumEmailZipC::operator const strokeS*( voidT )

}
    }
        }
            ether.delF( tin0P , psttk ) ;

            }
                soulP >> *ppsttv ;
                ether.delF( tin0P , *ppsttv ) ;
            {
            if( ppsttv )

            else if( !ether.strCompareF( tin0P , psttk , T("zip"     ) ) ) { ppsttv = &psttZip      ; }
            else if( !ether.strCompareF( tin0P , psttk , T("note"    ) ) ) { ppsttv = &psttNote     ; }
            else if( !ether.strCompareF( tin0P , psttk , T("language") ) ) { ppsttv = &psttLanguage ; }
            else if( !ether.strCompareF( tin0P , psttk , T("email"   ) ) ) { ppsttv = &psttEmail    ; }
                 if( !ether.strCompareF( tin0P , psttk , T("country" ) ) ) { ppsttv = &psttOldCountry  ; }
            ZE( strokeS** , ppsttv ) ;
        {
        else
        if( !psttk ) soulP >> psttk ;
    {
    while( soulP )
    ZE( strokeS* , psttk ) ;
{
psttZip( 0 )
psttNote( 0 ) ,
psttLanguage( 0 ) ,
psttEmail( 0 ) ,
psttOldCountry( 0 ) ,
psttRpt( 0 ) ,
ether( etherP ) ,
datumEmailZipC::datumEmailZipC( tin0S& tin0P , etherC& etherP , soulC& soulP ) :

}
{
psttZip( 0 )
psttNote( 0 ) ,
psttLanguage( 0 ) ,
psttEmail( 0 ) ,
psttOldCountry( 0 ) ,
psttRpt( 0 ) ,
ether( *((tin123S&)tin0P).pEther ) ,
datumEmailZipC::datumEmailZipC( tin0S& tin0P ) :

}
    return scSgn ;

    }
        }
            break ;
            COMPARE( psttEmail )
        {
        case idMODEeMAILzIPsORT_EAIL :
        }
            break ;
            COMPARE( psttZip )
        {
        case idMODEeMAILzIPsORT_ZIP :
        }
            break ;
            if( !scSgn ) COMPARE( psttNote )
            if( !scSgn ) COMPARE( psttZip )
            COMPARE( psttEmail )
        {
        case idMODEeMAILzIPsORT_eMAILzIPnOTE :
        }
            break ;
            if( !scSgn ) COMPARE( psttNote )
            if( !scSgn ) COMPARE( psttEmail )
            COMPARE( psttZip )
        {
        case idMODEeMAILzIPsORT_ZIPeMAILnOTE :
    {
    switch( idSortMode )
    ZE( sCountT , scSgn ) ;

    TINSL
    datumEmailZipC& datum = *(datumEmailZipC*)&plateP ;
{
sCountT datumEmailZipC::operator -( const plateC& plateP ) const

}
    return *this ;

    SETsTRING( psttZip )
    SETsTRING( psttNote )
    SETsTRING( psttLanguage )
    SETsTRING( psttEmail )
    SETsTRING( psttOldCountry )
    SETsTRING( psttRpt )

    datumEmailZipC& datum = *(datumEmailZipC*)&plateP ;
    TINSL
{
plateC& datumEmailZipC::operator =( plateC& plateP )

}
    ether.delF( tin0P , psttZip ) ;
    ether.delF( tin0P , psttNote ) ;
    ether.delF( tin0P , psttLanguage ) ;
    ether.delF( tin0P , psttEmail ) ;
    ether.delF( tin0P , psttOldCountry ) ;
    ether.delF( tin0P , psttRpt ) ;
    TINSL
{
datumEmailZipC::~datumEmailZipC( voidT )

}
    return *this ;
{
plateC& datumEmailZipC::operator >>( soulC& sP )

}
    return new( 0 , tin0P , idLineP , idiFileP ) datumEmailZipC( tin0P ) ;
{
datumEmailZipC* datumEmailZipC::newF( tin0S& tin0P , const countT idLineP , const countT idiFileP , p oolC& poolOldSetOldP )

NEWdELcLASS( 1 , datumEmailZipC )

}
    idSortMode = idSortModeP ;
{
voidT datumEmailZipC::setModeF( const countT idSortModeP )

countT datumEmailZipC::idSortMode = idMODEeMAILzIPsORT_eMAILzIPnOTE ;


#include postADAMhEADER

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

