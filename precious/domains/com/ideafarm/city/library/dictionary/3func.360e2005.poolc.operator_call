
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

#endif
    }
        }
            }
                break ;
                //if( !*guts.ppSlots[ offs ] ) { DELzOMBIE( guts.ppSlots[ offs ] ) ; }
            {
            if( !pbP )
            (*guts.ppSlots[ offs ])( tinP , pbP ) ;
        {
        if( guts.ppSlots[ offs ] )
    {
    for( countT offs = guts.expCbDropMin ; offs <= guts.expCbDropMax ; offs ++ )
#if defined( NEVERdEFINED )
//U:: OBSOLETED BY ADDITION OF DROP HEADER ; THIS WAS AT THE END OF THE DEF


}
    }
        if( pbP ) { BLAMMO ; }

        }
            //if( !pbP && offs - offsTry ) { BLAMMOiD( offs - offsTry ) ; }

            //}
            //    pEtRock->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
            //
            //    }
            //        OStEXTC(  ostoSay , offsTry , 0 ) ;
            //        OStEXTAK( ostoSay , "    " ) ;
            //    {
            //    if( !pbP )
            //    OStEXTC(  ostoSay , offs , 0 ) ;
            //    OStEXTAK( ostoSay , "    " ) ;
            //    OStEXTC(  ostoSay , mask , 0 ) ;
            //    OStEXTAK( ostoSay , "    " ) ;
            //    OStEXTC(  ostoSay , dropHeader , '0' ) ;
            //    OStEXTAK( ostoSay , "    " ) ;
            //    OStEXTC(  ostoSay , guts.expCbDropMin , 0 ) ;
            //    OStEXTAK( ostoSay , "    " ) ;
            //    OStEXTC(  ostoSay , guts.cBitsExpCbDrop , 0 ) ;
            //    OStEXTA( ostoSay , !pbP ? "poolC::operator (): trying harder succeeded [cBitsExpCbDrop,expCbDropMin,dropHeader,mask,offs,offsTry]:    " : "poolC::operator (): trying harder failed [cBitsExpCbDrop,expCbDropMin,dropHeader,mask,offs]:    " ) ;
            //    OStEXT( ostoSay , TUCK << 1 ) ;
            //{
            //if( pEtRock )

            }
                }
                    if( !pbP ) break ;
                    (*guts.ppSlots[ offsTry ])( tinP , pbP ) ;
                {
                if( guts.ppSlots[ offsTry ] )
            {
            for( offsTry = 0 ; offsTry < CsLOTsIZESmAX ; offsTry ++ )
            ZE( countT , offsTry ) ;

            //}
            //    pEtRock->traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
            //
            //    OStEXTA( ostoSay , "poolC::operator (): trying harder" ) ;
            //    OStEXT( ostoSay , TUCK << 0 ) ;
            //{
            //if( pEtRock )
            //etherC* pEtRock = &etherC::etRockIF( tinP ) ;
        {
#endif
        else
        }
            (*guts.ppSlots[ offs ])( tinP , pbP ) ;

            //if( offs == 0x18 ) etherC::etRockIF( tinP ).traceF( tinP , T("-------- DELETE") ) ; //U::20140808@1936: TO FIND A BUG
            if( !guts.ppSlots[ offs ] ) { BLAMMO ; }
            if( c_this && F(guts.flagsCt) & flPOOLc_READoNLY ) { BLAMMO ; }
            countT c_this = (countT)this ;
        {
        if( bDropHeader && !( F(tinP.flagsThreadMode4) & flTHREADmODE4_POOLdELtRYhARDERaNDtRACE ) )
#if defined( NEVERdEFINED )

        //}
        //    CONoUTrAW7( "[dropHeader,mask,offs]:    " , dropHeader , "    " , mask , "    " , offs , "\r\n" ) ;
        //{
        //if( bChatter )

        countT offs = bDropHeader ? guts.expCbDropMin + ( dropHeader & mask ) : 0 ;
        countT mask = ( 1 << guts.cBitsExpCbDrop ) - 1 ;

        if( bDropHeader && dropHeader == getNegAM( FINGERnEG_dropHeaderInitialize ) ) { BLAMMOiD( pbP ) ; }
        countT dropHeader = bDropHeader ? ((countT*)pbP)[ - 1 ] : 0 ;

        }
            if( dropSeparator != getNegAM( FINGERnEG_dropSeparator ) ) { BLAMMOiD( dropSeparator ) ; }
            countT& dropSeparator = ((countT*)pbP)[ - 1 - bDropHeader ] ;
        {
        if( face.cbDropSeparator == sizeof( countT ) )

        if( pbP < processGlobal1I.pbAddressMin || pbP > processGlobal1I.pbAddressMax ) { BLAMMOiD( pbP ) ; }

*(countT*)&bDropHeader = 1 ;
        const boolT bDropHeader = !( F(face.flagsPoolFormat ) & flPOOLfORMAT_NOdROPhEADERS ) ;
    {
    else if( pbP )
    }
        if( pbP ) { BLAMMO ; }
        processGlobal4I.heap.delF( tinP , pbP ) ;
    {
    if( processGlobal1I.pbHeap <= pbP && pbP < processGlobal1I.pbHeapEnd )
    //20201106@1436: WITHOUT ANALYSIS, CHANGED "< pbP" to "<= pbP"

    //I CAN BE CALLED WHEN this IS NULL, AND I MUST BEHAVE OK

    //_IO_
    //SPEED OPTIMIZATION: THIS _IO_ WOULD HAVE THE #5 HIGHEST FREQUENCY OF CALLS

    //}
    //    if( ppSlotsDebug ) ;
    //                    ppSlotsDebug = guts.ppSlots ;
    //    static slotsC** ppSlotsDebug                ;
    //
    //    CONoUTrAW( "\r\n" ) ;
    //    CONoUTrAW( postNameF( tinP ) ) ;
    //    CONoUTrAW( "\r\n" ) ;
    //{
    //if( bChatter )

    //boolT bChatter = !!tinP.pc Utility[ 0 ] ;
{
/*1*/voidT poolC::operator ()( tinS& tinP , byteT*& pbP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

