
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.osSuspendF( tinP ) ;
etThread.traceF( tinP , T("waited for all kids to die") ) ;
WAITuNTILaLMOSTaLONE( 1 ) ;
etThread.traceF( tinP , T("waiting for all kids to die") ) ;

etThread.delF( tinP , pstt1YearPath ) ;
}
    }
        etThread.osThreadF( TaRG3fLAGScBtLS( tmRefreshYearF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)psttPath ) ;
        etThread.strMakeF( tinP , LF , psttPath , psttc1 ) ; ___( psttPath ) ;
        ZE( strokeS* , psttPath ) ;
    {
    FORsTRINGSiN1( pstt1YearPath )
{
if( pstt1YearPath && pstt1YearPath->idAdam )

etThread.strConvertToLowerCaseF( tinP , pstt1YearPath ) ;
etThread.diskFindFileOrDirF( tinP , pstt1YearPath , tLike , &pat ) ; ___( pstt1YearPath ) ;
patternC pat( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
TN( tPattern , "?" "?" "?" "?" "/" ) ;                                                              //20221118@1747: "????/" PROUCES A COMPILER ERROR INVOLVING TRIGRAPH
TN( tLike , "///?/archive/" ) ;
ZE( strokeS* , pstt1YearPath ) ;

TODO

DONE( tmRefreshYearF )
}
    etThread.traceF( tinP , T("ended archive year path:    ")+tYearPathP ) ;

    while( !ether && ~hFindOuter && !POOP ) ;
    }
        DEL( pInfoOuter ) ;
        }
            }
                etThread.boxPutF( tinP , tFileHistory , tHistory , tHistory.csF( tinP ) ) ;
                tHistory += TF3(time2N,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot+TF3(time1N,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+tRecord+tCrlf ;
                etThread.osTimeNowF( tinP , time1N , time2N ) ;
                ZE( sCountT , time2N ) ;
                ZE( countT , time1N ) ;
                etThread.traceF( tinP , T(bNoHistory?"no fileset history:    ":"fileset change detected:    ")+tShorter+T("*") ) ;
            {
            if( bChanged )

            }
                }
                    etThread.delF( tinP , pstt1Lines ) ;
                    }
                        }
                            bChanged = !etThread.strIdF( tinP , tRecord , psttc1 ) ;
                            //etThread.traceF( tinP , T("to new record:                                          ")+tRecord ) ;
                            //etThread.traceF( tinP , T("comparing lath line of history:    ")+T(psttc1) ) ;
                        {
                        if( BlATHsTRING( 1 ) )
                    {
                    FORsTRINGSiN1( pstt1Lines )
                    etThread.strWordsF( tinP , pstt1Lines , tHistory , sttq , tCrlf ) ; ___( pstt1Lines ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , pstt1Lines ) ;

                    bNoHistory = bChanged = 0 ;
                {
                if( tHistory.csF( tinP ) )
                ZE( strokeS* , psttLathLine ) ;
            {
            boolT bNoHistory = 1 ;
            boolT bChanged = 1 ;

            }
                etThread.delF( tinP , postiHistory ) ;
                else       tHistory = T(postiHistory) ;
                if( POOP ) { POOPRqUIET }
                tinP.pEtScratch->boxGetShadowF( tinP , postiHistory , costiHistory , tFileHistory , 1 ) ; ___( postiHistory ) ;
                ZE( countT   , costiHistory ) ;
                ZE( osTextT* , postiHistory ) ;
                SCOOPS
            {
            IFsCRATCH
            TN( tFileHistory , "" ) ; tFileHistory = tPath + tShorter + tMetaDigestHistory ;
            TN( tHistory , "" ) ;

            RETRYsCR( fileWriteF( tinP , fiDigest , tCrlf , tCrlf.csF( tinP ) ) )
            RETRYsCR( fileWriteF( tinP , fiDigest , tShorterSansDot , tShorterSansDot.csF( tinP ) + 1 ) )        // TERMINATING NULL FOR HUMAN CONVENIENCE ; NOT NEEDED SINCE LENGTH CAN BE CALCULATED
            RETRYsCR( fileWriteF( tinP , fiDigest , (byteT*)&digest , sizeof digest ) )

            digest.costaFilesetPrefix = tShorterSansDot.csF( tinP ) + 1 + tCrlf.csF( tinP ) ;                   // tCrlf FOR HUMAN READABILITY OF THE BINARY FILE
            thirdC::c_memcpyIF( tinP , (byteT*)digest.pcHashMeta , (byteT*)pcHashMeta , sizeof digest.pcHashMeta ) ;
            thirdC::c_memcpyIF( tinP , (byteT*)digest.pcHashData , (byteT*)pcHashData , sizeof digest.pcHashData ) ;
            digest.cbMeta = cbDoneMeta ;
            digest.cbData = cbDoneData ;
            digest.time2Data = pInfoOuter->timeWritten2 ;
            digest.time1Data = pInfoOuter->timeWritten1 ;
            archiveDigestS digest ;

            }
                }
                    etThread.delF( tinP , posti ) ;

                    }
                        etThread.boxPutF( tinP , tFileOut , postRecord , costRecord ) ;
                        etThread.traceF( tinP , T("writing record [file]:    ")+tFileOut ) ;
                    {
                    if( !posti || costi != costRecord || etThread.memCompareF( tinP , posti , postRecord , costRecord ) )

                    if( POOP ) { POOPRqUIET }
                    tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , tFileOut , 1 ) ; ___( posti ) ;
                    ZE( countT   , costi ) ;
                    ZE( osTextT* , posti ) ;
                    
                    SCOOPS
                {
                IFsCRATCH

                TN( tFileOut , "" ) ; tFileOut = tPath + tShorter + tMetaDigest ;
            {

            const countT   costRecord = tRecord.csF( tinP ) ;
            const osTextT* postRecord = tRecord ;
            TN( tRecord , "" ) ; tRecord = tTimeData + tb4 + tFileSizeData + tb4 + tHashData + tb4 + tFileSizeMeta + tb4 + tHashMeta ;

            TN( tFileSizeMeta , "" ) ; tFileSizeMeta = TF3(pcDoneMeta[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb+TF3(pcDoneMeta[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ;
            const count02T* pcDoneMeta = (count02T*)&cbDoneMeta ;

            TN( tFileSizeData , "" ) ; tFileSizeData = TF3(pcDoneData[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb+TF3(pcDoneData[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ;
            const count02T* pcDoneData = (count02T*)&cbDoneData ;

            TN( tTimeData , "" ) ; tTimeData = TF3(pInfoOuter->timeWritten2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot+TF3(pInfoOuter->timeWritten1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;

            etThread.delF( tinP , psttHashMeta ) ;
            TN( tHashMeta , psttHashMeta ) ;
            hasherMeta.queryStringF( tinP , psttHashMeta ) ; ___( psttHashMeta ) ;
            ZE( strokeS* , psttHashMeta ) ;

            hasherMeta.queryF( tinP , (byteT*)pcHashMeta , sizeof pcHashMeta ) ;
            count02T pcHashMeta[ 4 ] ;

            }
                while( !ether && ~hFindInner && !POOP ) ;
                }
                    DEL( pInfoInner ) ;
                    }
                        }
                            }
                                }
                                    cbDoneMeta += cbw ;
                                    hasherMeta.eatF( tinP , pbw , cbw ) ;
                                {
                                else
                                if( !pbw || !cbw ) break ;

                                RETRY( fwsIn.getF( tinP , pbw , cbw ) )
                                ZE( countT , cbw ) ;
                                ZE( byteT* , pbw ) ;
                            {
                            while( !ether )

                            fileWindowsC fwsIn( tinP , etThread , tFileNameMeta ) ;

                            //etThread.traceF( tinP , tb4+tFileNameMeta ) ;
                            TN( tFileNameMeta , pInfoInner->psttIfoName ) ;
                        {
                        )
                            //&& !etThread.strIdF( tinP , tMetaDigestHistory , pInfoInner->psttIfoName )            THIS LINE IS REDUNDANT IF tMetaDigestHistory CONTAINS tMetaDigest
                                 !etThread.strIdF( tinP , tMetaDigest        , pInfoInner->psttIfoName )
                        (
                        if
                    {
                    else
                    }
                        break ;
                        DEL( pInfoInner ) ;
                    {
                    if( !pInfoInner || !pInfoInner->psttIfoName )

                    RETRYsCR( diskFindFileOrDirF( tinP , pInfoInner , hFindInner , tYearPathP , &patInner ) )
                    ZE( infoFileS* , pInfoInner ) ;
                {
                do
                handleC hFindInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                patternC patInner( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                TN( tPattern , "" ) ; tPattern = tShorter+T("meta.*") ;
            {
            ZE( count04T , cbDoneMeta ) ;
            hasherC hasherMeta( tinP , etThread ) ;

            }
                etThread.delF( tinP , psttnu ) ;
                etThread.delF( tinP , psttShorter ) ;
                }
                    etThread.delF( tinP , psttShorterSansDot ) ;
                    tShorterSansDot = T(psttShorterSansDot) ;
                    etThread.strSubstringF( tinP , psttShorterSansDot , idf , idl , psttShorter ) ; ___( psttShorterSansDot ) ;
                    ZE( strokeS* , psttShorterSansDot ) ;
                    countT idl = tShorter.csF( tinP ) - 1 ;
                    countT idf = 1 ;
                {
                if( tShorter.csF( tinP ) > 1 )

                tShorter  = T(psttShorter) ;
                etThread.strBisectF( tinP , psttShorter , psttnu , tShort , T(".") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttShorter ) ; ___( psttnu ) ;
                ZE( strokeS* , psttnu ) ;
                ZE( strokeS* , psttShorter ) ;
            {
            TN( tShorterSansDot , "" ) ;
            TN( tShorter  , "" ) ;

            }
                etThread.delF( tinP , psttShort ) ;
                etThread.delF( tinP , psttPath ) ;
                tShort = T(psttShort) ;
                tPath  = T(psttPath) ;
                etThread.strBisectF( tinP , psttPath , psttShort , tFileNameData , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttPath ) ;
            {
            TN( tShort , "" ) ;
            TN( tPath  , "" ) ;

            etThread.delF( tinP , psttHashData ) ;
            TN( tHashData , psttHashData ) ;
            hasherData.queryStringF( tinP , psttHashData ) ; ___( psttHashData ) ;
            ZE( strokeS* , psttHashData ) ;

            hasherData.queryF( tinP , (byteT*)pcHashData , sizeof pcHashData ) ;
            count02T pcHashData[ 4 ] ;

            }
                }
                    }
                        cbDoneData += cbw ;
                        hasherData.eatF( tinP , pbw , cbw ) ;
                    {
                    else
                    if( !pbw || !cbw ) break ;

                    RETRY( fwsIn.getF( tinP , pbw , cbw ) )
                    ZE( countT , cbw ) ;
                    ZE( byteT* , pbw ) ;
                {
                while( !ether )

                fileWindowsC fwsIn( tinP , etThread , tFileNameData ) ;
            {
            ZE( count04T , cbDoneData ) ;
            hasherC hasherData( tinP , etThread ) ;

            etThread.traceF( tinP , TF4(++idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0x10,0xa)+tb4+tFileNameData ) ;
            TN( tFileNameData , pInfoOuter->psttIfoName ) ;
        {
        else
        }
            break ;
            DEL( pInfoOuter ) ;
        {
        if( !pInfoOuter || !pInfoOuter->psttIfoName )

        RETRYsCR( diskFindFileOrDirF( tinP , pInfoOuter , hFindOuter , tYearPathP , &patOuter ) )
        ZE( infoFileS* , pInfoOuter ) ;
    {
    do
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    handleC hFindOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    ZE( countT , idFile ) ;

    patternC patOuter( tinP , etThread , tPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
    TN( tPattern , "*.data.*" ) ;
    TN( tMetaDigestHistory , "meta.digesthistory" ) ;
    TN( tMetaDigest , "meta.digest" ) ;
    TN( tDot , "." ) ;
    TN( tb4 , "    " ) ;
    TN( tb , " " ) ;
    TN( tCrlf , "\r\n" ) ;

    fileC fiDigest( tinP , (strokeS*)tFileNameDigest , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
    etThread.traceF( tinP , T("[digest]:    ")+tFileNameDigest ) ;
    TN( tFileNameDigest , "" ) ; tFileNameDigest = T("///ideafarm/tmp/archive.digests/")+tVolumeName+T(".")+tYear+T(".digest") ;

    etThread.traceF( tinP , T("[year]:    ")+tYear ) ;
    }
        etThread.delF( tinP , pstt1Words ) ;
        }
            else if( !etThread.strCompareF( tinP , psttc1 , tArchive ) ) bArm = 1 ;
                 if( bArm                                              ) tYear = T(psttc1) ;
        {
        FORsTRINGSiN1( pstt1Words )
        TN( tArchive , "archive" ) ;
        ZE( boolT , bArm ) ;
        etThread.strWordsF( tinP , pstt1Words , tYearPathP , sttq , T("/") ) ; ___( pstt1Words ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , pstt1Words ) ;
    {
    TN( tYear , "" ) ;

    etThread.traceF( tinP , T("[volumeName]:    ")+tVolumeName ) ;
    }
        DEL( pInfoDisk ) ;
        tVolumeName = T(pInfoDisk->psttVolumeName) ;
        etThread.strConvertToLowerCaseF( tinP , pInfoDisk->psttVolumeName ) ;
        etThread.delF( tinP , psttDisk ) ;
        etThread.diskInfoF( tinP , pInfoDisk , psttDisk ) ; ___( pInfoDisk ) ;
        ZE( infoDiskS* , pInfoDisk ) ;

        etThread.strSubstringF( tinP , psttDisk , idf , idl , tYearPathP ) ; ___( psttDisk ) ;
        countT idl = 5 ;
        countT idf = 1 ;
        ZE( strokeS* , psttDisk ) ;
    {
    TN( tVolumeName , "" ) ;

    etThread.traceF( tinP , T("begun archive year path:    ")+tYearPathP ) ;     //EXAMPLE: "///c/archive/1999/"

    etThread.delF( tinP , psttPathP ) ;
    TN( tYearPathP , psttPathP ) ;

    strokeS* psttPathP = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmRefreshYearF )


//CRAFTWORK ABORTED BECAUSE CALCULATING MD5 HASH FOR 4 ARCHIVE VOLUMES WOULD TAKE 58 DAYS, SO ABORTING THIS APPROACH

//OBSOLETED BY 7de


/*1*/WAKEsHOWtEXT( "ifcIDaDAM_HEALaRCHIVES" )/*1*/
/**/
*/
  i assume that the volume names are distinct and will not function correctly if they are not
 i also write a single binary digest file for each year of each archive
 if i detect a change in the fileset, i append to the digesthistory metafile
 for each fileset, i refresh the digest metafile
 i scan all ///?/archive/ folders
i am currently a tool to be run at a command prompt (or in Elves)
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
