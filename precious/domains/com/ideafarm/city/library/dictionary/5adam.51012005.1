
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    ++ s ; ether.osSleepF( tin0P , TICK >> 2 ) ;

    etThread.traceF( tin0P , T("napping for a minute") ) ;
    etThread.boxPutF( tin0P , tFileReport , tReport , tReport.csF( tin0P ) ) ;
    etThread.traceF( tin0P , T("writing minute report file") ) ;

    }
        }
            while( !ether && ~hFindFile && !POOP ) ;
            }
                DEL( pInfoFile ) ;
                }
                    }
                        etThread.delF( tin0P , posti ) ;
                        }
                            }
                                }
                                    }
                                        postc = postHitEnd + 2 ; // SKIPS CRLF
                                        tReport += T(postHit)+tcrlf ;
                                        *postHitEnd = 0 ;
                                    {
                                    else
                                    if( !postHitEnd ) break ;
                                    osTextT* postHitEnd = thirdC::c_strstrIF( tin0P , postHit , "\r\n" ) ;
                                {
                                else
                                if( !postHit ) break ;
                                osTextT* postHit = thirdC::c_strstrIF( tin0P , postc , "!exception" ) ;

                            {
                            while( postc < poste )

                            postc = posti ;

                            }
                                postc ++ ;
                                if( !*postc ) *postc = 0xff ;
                            {
                            while( postc < poste )  // SMUDGE NULL CHAR (THESE FILES ARE BINARY FILES) SO CAN USE STRING HANDLING

                            osTextT* poste = posti + costi ;
                            osTextT* postc = posti ;
                        {
                        else
                        if( !posti ) etThread.traceF( tin0P , T("null length file:    ")+tShort ) ;

                        etThread.boxGetShadowF( tin0P , posti , costi , tFolder+tShort ) ; ___( posti ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;
                    {
                    if( tShort.csF( tin0P ) )        // IF NOT A DIRECTORY
                                                               
                    }
                        etThread.delF( tin0P , psttShort ) ;
                        etThread.delF( tin0P , psttFolder ) ;
                        tShort  = T(psttShort) ;
                        tFolder = T(psttFolder) ;
                        etThread.strBisectF( tin0P , psttFolder , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttFolder ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttFolder ) ;
                    {
                    TN( tShort , "" ) ;
                    TN( tFolder , "" ) ;
                {
                else
                }
                    break ;
                    DEL( pInfoFile ) ;
                {
                if( !pInfoFile || !pInfoFile->psttIfoName )

                etThread.diskFindFileOrDirF( tin0P , pInfoFile , hFindFile , tTraceFolder , &pat2 ) ; ___( pInfoFile ) ;
                ZE( infoFileS* , pInfoFile ) ;
            {
            do
            handleC hFindFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        {

        tReport += tcrlf+tcrlf ;

        }
            while( !ether && ~hFindFile && !POOP ) ;
            }
                DEL( pInfoFile ) ;
                }
                    }
                        etThread.delF( tin0P , posti ) ;
                        etThread.delF( tin0P , psttYear ) ;

                        tReport += T(psttYear)+tb4+T(posti)+tcrlf ;

                        etThread.strSubstringF( tin0P , psttYear , idf , idl , tShort ) ; ___( psttYear ) ;
                        countT idl = 0x17 ;
                        countT idf = 0x14 ;
                        ZE( strokeS* , psttYear ) ;

                        etThread.boxGetShadowF( tin0P , posti , costi , tFolder+tShort ) ; ___( posti ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;

                        //etThread.traceF( tin0P , tShort ) ;
                    {
                    if( tShort.csF( tin0P ) && !etThread.strIdF( tin0P , tDotHeyWritingDot , tShort ) )        // IF NOT A DIRECTORY
                                                               
                    }
                        etThread.delF( tin0P , psttShort ) ;
                        etThread.delF( tin0P , psttFolder ) ;
                        tShort  = T(psttShort) ;
                        tFolder = T(psttFolder) ;
                        etThread.strBisectF( tin0P , psttFolder , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttFolder ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttFolder ) ;
                    {
                    TN( tShort , "" ) ;
                    TN( tFolder , "" ) ;
                {
                else
                }
                    break ;
                    DEL( pInfoFile ) ;
                {
                if( !pInfoFile || !pInfoFile->psttIfoName )

                etThread.diskFindFileOrDirF( tin0P , pInfoFile , hFindFile , tStateFolder , &pat1 ) ; ___( pInfoFile ) ;
                ZE( infoFileS* , pInfoFile ) ;
            {
            do
            handleC hFindFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        {
    {

    TN( tReport , "IdeaFarm (tm) Archive Healer - Minute Report\r\n\r\nyear    LathFileHealed\r\n\r\n" ) ;
{
while( !ether && !POOP )
sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

patternC pat2( tin0P , etThread , tPatternTraceFile         , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
patternC pat1( tin0P , etThread , tPatternLathFileCompleted , ifcIDtYPEpATTERN_LITERAL               ) ;
TN( tFileReport  , "///d/ideafarm.home.101/ephemeral/ipdos/archives/healing/state/rpt.minute.ttt" ) ;
TN( tStateFolder , "///d/ideafarm.home.101/ephemeral/ipdos/archives/healing/state/" ) ;
TN( tDotHeyWritingDot , ".!writing." ) ;

//U::PROD: TN( tTraceFolder , "" ) ; tTraceFolder = T("///ideafarm/ephemeral/ipdos/memorySpaces/")+tUser+T("/00000100/stateSpaces/ffffefff/") ;
TN( tTraceFolder , "///d/ideafarm.home.101/ephemeral/ipdos/memorySpaces/SYSTEM/00000100/stateSpaces/ffffefff/" ) ; //U::

TN( tUser , thirdC::postUserNameIF() ) ;

TN( tPatternTraceFile , "bksTrace.booksC.*" ) ;

;

    +S2(sa_SSSaNDeND,sc_ccSSS)
    +T(".lath.file.completed.ttt")
    +S2(sa_SSSoReND,sc_ccSSS)
        +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
    +S2(sa_SSSoR,sc_ccSSS)
    +S3(2,sc_ccSSSrEPEAT,2)
    +S2(sa_SSSoReND,sc_ccSSS)
        +T("12")
    +S2(sa_SSSoR,sc_ccSSS)
    +T("status.wo.ideafarm.")
    +S2(sa_SSSaND,sc_ccSSS)
    T("")

TN( tPatternLathFileCompleted , "" ) ; tPatternLathFileCompleted =

// "status.wo.ideafarm.yyyy.lath.file.completed.ttt"
//  123456789abcdef0123456789abcdef0123456789abcdef0
//  0              1               2               3

TN( tcrlf , "\r\n" ) ;
TN( tb4   , "    " ) ;


TODO

/*1*/WAKEsHOWtEXT( "doodle.report.lath.file.healed" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
