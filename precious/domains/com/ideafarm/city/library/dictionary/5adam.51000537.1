
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.cioSetGetF( tinBaseP ) ;

sgnDone_tmWorkF.waitF( tinBaseP ) ;
stGotten << (byteT*)&info ;
cioGottenS info( tinBaseP ) ;
__Z( ether ) ;

}
    ++ s ; ether.osSleepF( tinBaseP , TOCK * 0x10 ) ;
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    CONoUTrAW( "1\r\n" ) ;

    //etThread.strokeF( tinBaseP , tRpt ) ;
    //LOGrAW( tRpt ) ;
    //scLeakageLag = scLeakage ;
    //tRpt += T("total extant drop leakage for this process: ")+TF1(scLeakage)+T(" delta: ")+TF1(scLeakage-scLeakageLag)+T("\r\n") ;
    //sCountT scLeakage = scDropNet-scDropNetWoth ;
    //if( !scDropNetWoth ) scDropNetWoth = scDropNet ;
    //sCountT scDropNet = etherC::ifc_cPoolDropNewG_IF( tinBaseP ) - etherC::ifc_cPoolDropDelG_IF( tinBaseP ) ;
    //static sCountT scLeakageLag ;
    //static sCountT scDropNetWoth ;

    //}
    //    if( scDelta > 0x1000 ) tRpt += TF1(processGlobal8I.source.idFileImmutableF(tinBaseP,off))+tb+TF1(pscPoolDropNewG[off])+tb+TF1(pscPoolDropDelG[off])+tb+TF1(pscPoolDropNewG[off]-pscPoolDropDelG[off])+tcr ;
    //    if( scDelta < 0 ) scDelta = - scDelta ;
    //    sCountT scDelta = pscPoolDropNewG[ off ] - pscPoolDropDelG[ off ] ;
    //{
    //for( countT off = 0 ; off <= cSourceFiles ; off ++ )  
    //tRpt += TF1(++idCycle)+tcr ;
    //TN( tRpt , "\r\n" USCORE79 "\r\n \r\n" ) ;
    //U::

    }
        }
            etThread( tinBaseP , psGift ) ;
            }
                CONoUTrAW( "2\r\n" ) ;
                etThread.cioPutF( tinBaseP , ether , c8ChannelReg , *psGift ) ;
                CONoUTrAW( "3\r\n" ) ;
                //etThread.strokeF( tinBaseP , T("dropping \"am ")+T(bMediator?"alive":"dead")+T("\" msg ")+TF1(++idCycle)+T("\r\n") ) ;
                *psGift << (countT)DDNUMB ;
                *psGift << (countT)( bMediator ? ifcOLDiDcMDrEGISTERmEDIATOR_AMaLIVE : ifcOLDiDcMDrEGISTERmEDIATOR_AMdEAD ) ;
            {
            if( psGift )
            etThread( tinBaseP , psGift , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psGift ) ;
        {
        if( bMediator || bMediatorLag )
        CONoUTrAW( "4\r\n" ) ;

        bMediator = cPinFiles > 2 ;
        bMediatorLag = bMediator ;
    
        }
            etThread( tinBaseP , psGift ) ;
            CONoUTrAW( "5\r\n" ) ;
            etThread.cioPutF( tinBaseP , ether , c8ChannelMenu , *psGift ) ;
            CONoUTrAW( "6\r\n" ) ;
            //etThread.strokeF( tinBaseP , T("dropping \"pin menu\" msg ")+TF1(++idCycle)+T(" listing  ")+TF1(cPinFiles)+T("\r\n") ) ;
            }
                CONoUTrAW( "7\r\n" ) ;
                etThread.delF( tinBaseP , pstt1m ) ;
                }
                    etThread.delF( tinBaseP , pczName ) ;
                    *psGift << pczName ;
                    }
                        etThread.delF( tinBaseP , pstt1w ) ;
                        }
                            pczName[ off ++ ] = 0 ;
                            FORsTRINGSiN3( pstt1w ) pczName[ off ++ ] = etThread.strDigitsToSCountF( tinBaseP , psttc3 , 0 , 1 ) ;
                            ZE( countT , off ) ;
                        {
                        if( pczName )
                        etThread.newF( tinBaseP , LF , pczName , 1 + cWords ) ; ___( pczName ) ;
            
                        FORsTRINGSiN2( pstt1w ) ++ cWords ;
                        ZE( countT , cWords ) ;
            
                        etThread.delF( tinBaseP , psttw ) ;
                        etThread.strWordsOldF( tinBaseP , pstt1w , psttw , sttq , td ) ; ___( pstt1w ) ;
                        ZE( strokeS* , pstt1w ) ;
                        etThread.strWordF( tinBaseP , psttw , psttc1 , sttq , sttd , - 1 ) ; ___( psttw ) ;
                        ZE( strokeS* , psttw ) ;
                    {
                    ZE( countT* , pczName ) ;
                {
                FORsTRINGSiN1( pstt1m )
                TN( td , "." ) ;
                strokeS sttd = S1C( '/' ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                CONoUTrAW( "8\r\n" ) ;
            
                cPinFiles = etThread.boxMenuF( tinBaseP , soul , tLike , 0 , 0x100 ) ; ___( pstt1m ) ;
                CONoUTrAW( "9\r\n" ) ;
                //U::WILL NOT WORK FOR LARGE NUMBER OF HOMES BECAUSE CAPACITY LIMIT IS HARDCODED HERE
            
                etThread.diskMakeDirIfNeededF( tinBaseP , tLike ) ;
            
                ZE( strokeS* , pstt1m ) ;
                TN( tLike , "///desk/" POSTfOLDERsECURITYkEYdEPOSITORY ) ; tLike += (idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/????????.????????.")+TF3(idbKEYtYPE_PIN,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot+TF3(idbKEYpINtYPE_SECRETsERVICE,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(".*") ;
                TN( tDot , "." ) ;
                CONoUTrAW( "a\r\n" ) ;
            {
            if( psGift )
            etThread( tinBaseP , psGift , TAG( TAGiDnULL ) ) ;
            ZE( soulC* , psGift ) ;
            CONoUTrAW( "b\r\n" ) ;
        {
        if( !ether )
        ZE( countT , cPinFiles ) ;
        CONoUTrAW( "c\r\n" ) ;
    {
{
while( ( bMediatorLag || !ether ) && !etThread )
ZE( boolT , bMediator ) ;
ZE( boolT , bMediatorLag ) ;

//const countT        cSourceFiles = processGlobal8I.source.cFilesF( tinBaseP ) ;
//const sCountT* const pscPoolDropDelG = etherC::ifc_pscPoolDropDelG_IF( tinBaseP ) ;
//const sCountT* const pscPoolDropNewG = etherC::ifc_pscPoolDropNewG_IF( tinBaseP ) ;
//TN( tb , " " ) ;  
//TN( tcr , "\r\n" ) ;  
//U::

countT idHomeDisk = etThread.ifc_idHomeIdisk_IF() ;
//U::ENABLE IN PRODUCTION: etThread.ifcHireF( tinBaseP , T("ifcIDaDAM_SECRETsERVICE") , ifcIDaDAM_NULL , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ;
ZE( countT , idCycle ) ;
count8S c8ChannelMenu( ifcOLDiDcHANNEL1_BYfUNCTION , ifcOLDiDcHANNELfUNCTION_MEDIATORpINmENU , DDNUMB ) ;
count8S c8ChannelReg( ifcOLDiDcHANNEL1_BYfUNCTION , ifcOLDiDcHANNELfUNCTION_MEDIATORrEGISTRATION ) ;
etThread.cioSetGetF( tinBaseP , cioGetF ) ;
etThread.cioSetArgF( tinBaseP , cArg ) ;
etThread.osThreadSwitchingDesireF( tinBaseP , ifcTHREADpRIORITY_LAZIEST ) ;
homeS& home = homeS::homeIF() ;

etThread.osThreadF( tinBaseP , countTC() , tmWorkF , &sgnDone_tmWorkF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&stGotten , (countT)&idpLever , (countT)&swsPin ) ;
signC sgnDone_tmWorkF( tinBaseP , TAG( TAGiDnULL ) ) ;

countT cArg = (countT)&stGotten ;

stackC stGotten( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO|flSTACKc_BLOB|flSTACKc_GIVEsIGNnEWpLATE , sizeof( cioGottenS ) ) ;
switchStackC swsPin( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , (byteT*)&idpLever , sizeof idpLever , flSTACKc_null , ifcSTACKtYPE_PTR_countT ) ;
portC idpLever ;

TODO

DONE( tmWorkF )
}
    }
        }
            //THREADmODE2rESTORE
            DEL( info.psGift ) ;
            etThread.delF( tinBaseP , info.pczChannel ) ;
            
            }
                }
                    }
                        swsPinP.ungrabF( tinBaseP ) ;
                        }
                            swsPinP.sinkF( tinBaseP , countTC() , pczName , flSTACKsINK_UNIQUE ) ;
                            //etThread.strokeF( tinBaseP , T("| ")+T(pczName)+T("\r\n") ) ;
                            *info.psGift >> pczName ;
                            ZE( countT* , pczName ) ;
                        {
                        while( (countT)*info.psGift )
                        swsPinP.purgeF( tinBaseP ) ;
                        idpLeverP = info.idptOrigin ;
                        swsPinP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                
                        //etThread.strokeF( tinBaseP , TF1(cIn)+T(": rec'd pin menu from ")+T(info.idptOrigin)+T("\r\n") ) ;
                        ++ cIn ;
                    {
                    if( info.pczChannel && info.pczChannel[ 0 ] == ifcOLDiDcHANNEL1_BYfUNCTION && info.pczChannel[ 1 ] == ifcOLDiDcHANNELfUNCTION_MEDIATORpINmENU && info.pczChannel[ 2 ] == DDNUMB )
                {
                else if( info.idGiftType == ifcOLDiDtYPEgIFT_APPLICATION )
                }
                    }
                        etThread( tinBaseP , psSecret ) ;
                        }
                            etThread( tinBaseP , psTo ) ;
                            }
                                }
                                    swsPinP.ungrabF( tinBaseP ) ;
                                    }
                                        while( !etThread && !swsPinP.third && ~hUp ) ;
                                        }
                                            idpLeverP = idptTo ;
                                            }
                                                break ;
                                                etThread( tinBaseP , psTo1 ) ;
                                                }
                                                    THREADmODE2rESTORE
                                                    etThread.cioPutSecretF( tinBaseP , ether , *psSecret , *psTo1 , info.pczChannel + 3 , pczName ) ;
                                                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                                                    idptTo >> *psTo1 ;
                                                {
                                                if( psTo1 )
                                                etThread( tinBaseP , psTo1 , TAG( TAGiDnULL ) ) ;
                                                ZE( soulC* , psTo1 ) ;
                    
                                                THREADmODE2rESTORE
                                                etThread.strokeF( tinBaseP , TF1(idOut)+T(" t: ")+T(idptTo)+T(" ")+T(info.pczChannel+3)+T("\r\n") ) ;
                                                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                                                countT idOut = 1 + incv02AM( idOutLath ) ;
                                                static countT idOutLath ;
                                            {
                                            if( swsPinP( pczName ) )
                                            idpLeverP = idptMe ;
                                            countT*& pczName = *(countT**)&swsPinP.upF( tinBaseP , hUp ) ;
                                        {
                                        do
                                        handleC hUp( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {
                                    if( swsPinP )
                                    idpLeverP = idptTo ;
                                    swsPinP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                                    idptTo << *psTo ;
                                    portTimeC idptTo ;
                                {
                                while( (countT)*psTo )
                                psTo->shiftLeftF( tinBaseP , ifcIDtYPEsOULiTEM_soulC , pbsTo , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                            {
                            if( psTo )
                            etThread( tinBaseP , psTo , TAG( TAGiDnULL ) ) ;
                            ZE( soulC* , psTo ) ;
                    
                            byteT* pbsTo = info.psGift->pbFieldF( tinBaseP , idTypesTo , flagssTo , cbsTo , 6 ) ;
                            ZE( countT , cbsTo ) ;
                            ZE( flagsT , flagssTo ) ;
                            ZE( countT , idTypesTo ) ;
                            portTimeC& idptMe = homeS::homeIF().idptRelay ;
                        {
                        if( psSecret )
                
                        }
                            etThread.delF( tinBaseP , pbsSecret ) ;
                            else            etThread( tinBaseP , psSecret ) ;
                            if( pbsSecret ) psSecret->shiftLeftF( tinBaseP , ifcIDtYPEsOULiTEM_soulC , pbsSecret , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                            }
                                //else { CONoUTrAW( "could not decode the secret\r\n" ) ; }
                                //}
                                //    etThread.strokeF( tinBaseP , T("\fGOT THE SECRET:\r\n \"")+T(psttMsg)+T("\"\r\n") ) ;
                                //    strokeS* psttMsg = (strokeS*)soulC::pbFieldIF( tinBaseP , idTypeMsg , flagsMsg , cbMsg , 1 , pbsSecret) ;
                                //    ZE( countT , cbMsg ) ;
                                //    ZE( flagsT , flagsMsg ) ;
                                //    ZE( countT , idTypeMsg ) ;
                                //    CONoUTrAW( "decoded the secret\r\n" ) ;
                                //{
                                //if( pbsSecret )
                                //REMOVE THIS IN PRODUCTION
                    
                                }
                                    dad( tinBaseP , pbsSecret , cbsSecret , pc01Codes , cc01Codes , 1 ) ; ___( pbsSecret ) ;
                                    dadC dad( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
                                {
                    
                                cc01Codes /= sizeof( count01T ) ;
                                count01T* pc01Codes = (count01T*)soulC::pbFieldIF( tinBaseP , idTypeCodes , flagsCodes , cc01Codes , 1 , pbsPay ) ;
                                ZE( countT , cc01Codes ) ;
                                ZE( flagsT , flagsCodes ) ;
                                ZE( countT , idTypeCodes ) ;
                            {
                            ZE( countT , cbsSecret ) ;
                            ZE( byteT* , pbsSecret ) ;
                        {
                        if( pbsPay && psSecret )
                        etThread( tinBaseP , psSecret , TAG( TAGiDnULL ) ) ;
                        ZE( soulC* , psSecret ) ;
                
                        byteT* pbsPay = info.psGift->pbFieldF( tinBaseP , idTypesPay , flagssPay , cbsPay , 9 ) ;
                        ZE( countT , cbsPay ) ;
                        ZE( flagsT , flagssPay ) ;
                        ZE( countT , idTypesPay ) ;

                        //CONoUTrAW( T("GOT SOMETHING ON MEDIATION CHANNEL\r\n")+T(info.pczChannel)+T("\r\n") ) ;
                    {
                    if( info.pczChannel && info.pczChannel[ 0 ] == ifcOLDiDcHANNEL1_BYfUNCTION && info.pczChannel[ 1 ] == ifcOLDiDcHANNELfUNCTION_MEDIATED && info.pczChannel[ 2 ] == DDNUMB )
                {
                if( info.idGiftType == ifcOLDiDtYPEgIFT_MEDIATE )
                //THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING ) //U::SQUEEZE TO FIND WHERE I NEED THIS
                //U::MIGHT NOT BE NEEDED
            {
            if( !ether )

            stGottenP >> pbInfo ;
            byteT* pbInfo = (byteT*)&info ;
            cioGottenS info( tinBaseP ) ;
        {
        while( stGottenP )
        stGottenP.waitF( tinBaseP ) ;
    {
    while( !ether && !etThread )

    switchStackC& swsPinP   = *(switchStackC*)pTaskP->c3 ;
    portC&      idpLeverP =      *(portC*)pTaskP->c2 ;
    stackC&       stGottenP =       *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmWorkF )

}
    if( etherP && bQuitP && idGiftTypeP && pczChannelP && psGiftP && idptOriginP ) ;
    }
        }
            stGottenP << (byteT*)&info ;
            cioGottenS info( tinBaseP , idGiftTypeP , psGiftP , pczChannelP , idptOriginP ) ;
        {
        else
        if( stGottenP > 0x10 ) { CONoUTrAW( "OVERLOADED: new channel input ignored\r\n" ) ; }
    {
    if( !bQuitP )
    _IO_

    stackC& stGottenP = *(stackC*)cArgP ;
{
voidT cioGetF( tinBaseS& tinBaseP , etherC& etherP , const boolT& bQuitP , const countT idGiftTypeP , soulC*& psGiftP , countT*& pczChannelP , countT& cArgP , const portTimeC& idptOriginP )

}
    pczChannelP = 0 ;
    psGiftP = 0 ;
{
idptOrigin( idptOriginP )
pczChannel( pczChannelP ) ,
psGift( psGiftP ) ,
idGiftType( idGiftTypeP ) ,
cioGottenS::cioGottenS( tinBaseS& tinBaseP , const countT idGiftTypeP , soulC*& psGiftP , countT*& pczChannelP , const portTimeC& idptOriginP ) :

}
    thirdC::c_memsetIF( tinBaseP , (byteT*)this , sizeof *this ) ;
{
cioGottenS::cioGottenS( tinBaseS& tinBaseP )

;
}
    cioGottenS( tinBaseS& tinBaseP , const countT idGiftTypeP , soulC*& psGiftP , countT*& pczChannelP , const portTimeC& idptOriginP ) ;
    cioGottenS( tinBaseS& tinBaseP ) ;

    portTimeC idptOrigin ;
    countT*     pczChannel ;
    soulC*      psGift ;
    countT      idGiftType ;
{
struct cioGottenS

countT cIn ;

/*1*/WAKEhIDE( "ifcIDaDAM_SECRETsERVICE" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

