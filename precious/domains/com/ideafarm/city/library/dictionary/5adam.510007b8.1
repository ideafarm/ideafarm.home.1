
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST


}
    etThread.loafIF( tin0P ) ;

    //G:nodeC nodeMe( tin0P , etThread , flSEEnODES_ME | flSEEnODES_LOCAL ) ;
    //G:nodeC nodeMe( tin0P , etThread ) ;

    while( cDo -- ) etThread.osThreadF( TaRG3fLAGScBtLS( tmNodeF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLS ) ) ;

    //G:countT cDo = TUCK >> 2 ;
    countT cDo = 2 ;


    //G:countT cDo = 0x50 ;
    //B:countT cDo = 0x60 ;
    //B: sameo at will dadC bug: countT cDo = 0x40 ;

    //G:CNR: 1
    //B:SAMEO: countT cDo = 0x20 ;

    //G::countT cDo = 0x30 ;
    //G:countT cDo = 0x20 ;
    //G:countT cDo = 0x10 ;
    //B:countT cDo = TUCK >> 3 ;
    //B:countT cDo = TUCK >> 1 ;
    //G:countT cDo = 8 ;

    VirtualQuery( &foo , &info , sizeof info ) ;
    static MEMORY_BASIC_INFORMATION info ;
    static countT addr2 = (countT)&goo ;
    static countT addr1 = (countT)&foo ;
    ZE( countT , goo ) ;
    ZE( countT , foo ) ;
{
else
}
    etThread.loafIF( tin0P ) ;
    }
        }
            ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        {
        if( cDo )

        etThread.ifcHireF( tin0P , T("ifcIDaDAM_3BANGsIMULATION") , 0 , tHeyKid , flHIRE_DISPLAYtEXT /*| flHIRE_DEBUG*/ , nicNameC() ) ;
        etThread.traceF( tin0P , T("hiring kid [cDo after]:    ")+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( cDo -- )
    //countT cDo = TUCK >> 5 ;
    //G:aok: countT cDo = TUCK >> 2 ;
    countT cDo = 1 ;
{
if( !bKid )

}
    }
        }
            break ;
            bKid = 1 ;
        {
        if( !etThread.strCompareF( tin0P , psttc1 , tHeyKid ) )
        etThread.traceF( tin0P , T("param: ")+T(psttc1) ) ;
    {
    FORsTRINGSiN1( pstt1Param )
    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tin0P ) ;
{
TN( tHeyKid , "!kid" ) ;
ZE( boolT , bKid ) ;

TODO

DONE( tmNodeF )
nodeC nodeMe( tin0P , etThread , flSEEnODES_ME | flSEEnODES_LOCAL ) ;
TASK( tmNodeF )

DONE( tmAcceptF )
}
    dec02AM( cKidsP ) ;

    }
        }
            stAcceptedP << (countT)psoa ;

            //etThread.traceF( tin0P , T("called  acceptF [psoa]:    ")+TF2((countT)psoa,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            sockListen.acceptF( tin0P , psoa , idpHe , nnHe , bRefuse ) ; ___( psoa ) ;
            //etThread.traceF( tin0P , T("calling acceptF") ) ;
            nicNameC nnHe ;
            ZE( countT , idpHe ) ;

            ZE( socketC* , psoa ) ;
        {
        while( !ether && !POOP && !bQuitP )
        ZE( boolT , bRefuse ) ;

        sockListen.listenF( tin0P ) ;

        etThread.osThreadF( TaRG3fLAGScBtLS( tmLiveF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLS ) , (countT)&nodeP , (countT)&bQuitP , (countT)&cKidsP , (countT)&stOpenP , flagsSeeNodesP , (countT)&portMeP ) ; // portMeP IS NOW COMPLETELY KNOWN
        inc02AM( cKidsP ) ;

        etThread.osThreadF( TaRG3fLAGScBtLS( tmRefreshListF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLS ) , (countT)&nodeP , (countT)&bQuitP , (countT)&cKidsP , (countT)&stOpenP , flagsSeeNodesP , (countT)&portMeP ) ; // portMeP IS NOW COMPLETELY KNOWN
        inc02AM( cKidsP ) ;

        }
            }
                }
                    break ;
                    portMeP = idPortBound ;
                    //etThread.traceF( tin0P , T("bound aok [idPortBound]:    ")+TF2(idPortBound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                else
                }
                    //etThread.traceF( tin0P , T("could not bind [idPortTry]:    ")+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                {
                if( POOP )
                idPortBound = sockListen.bindF( tin0P , idpTry , nicNameC() , 1 , 0 ) ;
            {
            for( countT idpTry = idpMin ; idpTry <= idpMax ; idpTry ++ )
            countT idpMax = - 1             ; // IF I BIND TO A PORT VALUE THAT IS TOO HIGH THEN I WON'T BE FOUND BY A PEER'S SCAN OF MY HOST
            countT idpMin = ifcIDpORT_nodeC ;

            sockListen.etherF( tin0P , *((tin1S&)tin0P).pEtScratch ) ;
            SCOOPS
        {
        IFsCRATCH
        ZE( countT , idPortBound ) ;
        TN( tb4 , "    " ) ;

        socketC sockListen( tin0P , etThread , TAG( TAGiDnULL ) ) ;
    {

    portC&       portMeP     =  *(portC*)pTaskP->c7 ;
    const countT flagsSeeNodesP     =           pTaskP->c6 ;
    stackC&      stOpenP     = *(stackC*)pTaskP->c5 ;
    stackC&      stAcceptedP = *(stackC*)pTaskP->c4 ;
    countT&      cKidsP      = *(countT*)pTaskP->c3 ;
    boolT&       bQuitP      =  *(boolT*)pTaskP->c2 ;
    nodeC&       nodeP       =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TASK( tmAcceptF )

DONE( tmWorkerF )
}
    dec02AM( cKidsP ) ;

    DEL( psoaP ) ;

    }
        }
            }
                etThread.traceF( tin0P , T("coding error 85") ) ;
                POOPRqUIET
            {
            if( POOP )

            }
                }
                    }
                        }
                            break ;

                            }
                                //etThread.traceF( tin0P , T("unexpected command [idCmd]:    ")+TF2(idCmd,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                bBye = 1 ;
                                POOPRqUIET
                            {
                            if( POOP )

                            __1
                            __( idCmd ) ;
                        {
                        default :
                        }
                            break ;

                            }
                                //etThread.traceF( tin0P , T("could not write ifcIDcMDnODE_PINGrEPLY") ) ;
                                POOPRqUIET
                            {
                            if( POOP )

                            psoaP->writeF( tin0P , soulo ) ;

                            soulo << finger ;   // idCmd
                            finger = ifcIDcMDnODE_PINGrEPLY ;

                            soulo << finger ;   // idFormat
                            finger = 1 ;

                            soulo << finger ;
                            putNegAM( finger , FINGERnEG_nodeC ) ;
                            ZE( countT , finger ) ;

                            soulC soulo( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
                        {
                        case ifcIDcMDnODE_PING :
                        }
                            break ;
                            bBye = 1 ;
                        {
                        case ifcIDcMDnODE_BYE :
                    {
                    switch( idCmd )

                    souli >> idCmd ;
                    ZE( countT , idCmd ) ;
                {
                else
                }
                    //etThread.traceF( tin0P , T("incoming soul contained unexpected fingerprint or idFormat") ) ;
                    bBye = 1 ;
                    POOPRqUIET
                {
                if( POOP )

                __( finger - 1 ) ;
                souli >> finger ;
                finger = 0 ;

                __( getNegAM( finger ) - FINGERnEG_nodeC ) ;
                souli >> finger ;
                ZE( countT , finger ) ;
            {
            else
            }
                //etThread.traceF( tin0P , T("could not read soul") ) ;
                bBye = 1 ;
                POOPRqUIET
            {
            if( POOP )

            psoaP->readF( tin0P , souli ) ;
            soulC souli( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;

            psoaP->etherF( tin0P , *((tin1S&)tin0P).pEtScratch ) ;

            SCOOPS
        {
        IFsCRATCH
    {
    while( !bQuitP && !bBye )
    ZE( boolT , bBye ) ;

    socketC*     psoaP       = (socketC*)pTaskP->c8 ;
    portC&       portMeP     =  *(portC*)pTaskP->c7 ;
    const countT flagsSeeNodesP     =           pTaskP->c6 ;
    stackC&      stOpenP     = *(stackC*)pTaskP->c5 ;
    stackC&      stAcceptedP = *(stackC*)pTaskP->c4 ;
    countT&      cKidsP      = *(countT*)pTaskP->c3 ;
    boolT&       bQuitP      =  *(boolT*)pTaskP->c2 ;
    nodeC&       nodeP       =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 && pTaskP->c8 )
TASK( tmWorkerF )

DONE( tmHireWorkersF )
}
    dec02AM( cKidsP ) ;

    }
        }
            stAcceptedP.ungrabF( tin0P ) ;

            }
                ether.osThreadF( TaRG3fLAGScBtLS( tmWorkerF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLS ) , (countT)&nodeP , (countT)&bQuitP , (countT)&cKidsP , (countT)&stAcceptedP , (countT)&stOpenP , flagsSeeNodesP , (countT)&portMeP , c_psoa ) ;
                inc02AM( cKidsP ) ;
                stAcceptedP >> c_psoa ;
                ZE( countT , c_psoa ) ;
            {
            while( stAcceptedP )
        {
        else
        if( !stAcceptedP ) stAcceptedP.ungrabF( tin0P ) ;
        stAcceptedP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        stAcceptedP.waitF( tin0P ) ;
    {
    while( !ether && !POOP && !bQuitP )

    portC&       portMeP     =  *(portC*)pTaskP->c7 ;
    const countT flagsSeeNodesP     =           pTaskP->c6 ;
    stackC&      stOpenP     = *(stackC*)pTaskP->c5 ;
    stackC&      stAcceptedP = *(stackC*)pTaskP->c4 ;
    countT&      cKidsP      = *(countT*)pTaskP->c3 ;
    boolT&       bQuitP      =  *(boolT*)pTaskP->c2 ;
    nodeC&       nodeP       =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TASK( tmHireWorkersF )

DONE( tmRefreshListF )
}
    dec02AM( cKidsP ) ;

    }
        DEL( pNapNodeListGlobal ) ;
        DEL( pNapNodeListLocal  ) ;
        DEL( pNapNodeListMe     ) ;

        }
        {
        if( F(flagsSeeNodesP) & flSEEnODES_GLOBAL )

        }
        {
        if( F(flagsSeeNodesP) & flSEEnODES_LOCAL )

        }
            }
                }
                    break ;

                    nl.pEntry[ offi ].ttl  = 0 ;
                    nl.pEntry[ offi ].port = portC() ;
                    dec02AM( nl.cElts ) ;

                    etThread.traceF( tin0P , T("removing myself [nn,nnv4]:    ")+T(nn)+T("    ")+T(nnv4) ) ;
                    nicNameC nnv4 = nl.pEntry[ offi ].port.nnv4F() ;
                    nicNameC nn   = nl.pEntry[ offi ].port ;
                {
                if( nl.pEntry[ offi ].port == portMeP )
            {
            for( countT offi = 0 ; offi < nl.cEltsMax ; offi ++ )
            nodeListS& nl = *pzNodeListMe ;
        {
        if( F(flagsSeeNodesP) & flSEEnODES_ME )

        }
            ++ s ; ether.osSleepF( tin0P , TOCK ) ;
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

            stOpenP.ungrabF( tin0P ) ;
            }
                while( !stOpenP.third && ~hDown ) ;
                }
                    //etThread.traceF( tin0P , TF2(idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(timeHe)+tb4+T(nnHe)+tb4+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(bMe?" )  (me)":" )")+T(bMe&&idPlate==1?" (root)":"") ) ; //U:: TO FIND A BUG
                    const timeS& timeHe = ptHe ;
                    nicNameC nnHe = ptHe ;

                    boolT bMe = (portC&)ptHe == portMeP ;

                    portTimeC& ptHe = *(portTimeC*)&stOpenP.downF( tin0P , hDown ) ;

                    ++ idPlate ;
                {
                do
                handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;
            {
            if( stOpenP )

            }
                while( !stValidated.third && ~hDown ) ;
                }
                    //etThread.traceF( tin0P , T("stValidated [idPlate,port,v4,time]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(nnHe)+T("    ")+T(portHe.nnv4F())+T(" ( ")+TF2((countT)portHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )    ")+T(timeHe) ) ; //U:: TO FIND A BUG

                    tFoo = T(timeHe) ;
                    TN( tFoo , "" ) ;

                    timeS timeHe = ptHe ;
                    nicNameC nnHe = portHe ;
                    stOpenP.sinkF( tin0P , countTC() , (byteT*)&ptHe , flSTACKsINK_UNIQUE , subtractPortTimeF ) ;

                    ptHe.timeStampIfF( tin0P , etThread ) ;
                    portTimeC ptHe = portHe ;

                    portC& portHe = *(portC*)&stValidated.downF( tin0P , hDown ) ;
                {
                do
                handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;
            {
            if( stValidated )

            // AT THIS POINT ALL PLATES IN stOpenP ARE STILL GOOD, AND stValidated ONLY CONTAINS PLATES THAT ARE NOT IN stOpenP
            }
                while( !stOpenP.third && ~hDown ) ;
                }
                    }
                        stValidated.extractF( 0 , tin0P ) ;
                        //etThread.traceF( tin0P , T("extracting from stValidated (not newly open) [port,v4]:    ")/*+T((nicNameC)ptHe)+T("    ")+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )")*/ ) ; //U:: TO FIND A BUG
                    {
                    else                
                    }
                        stOpenP.extractF( 0 , tin0P ) ;
                        //etThread.traceF( tin0P , T("extracting from stOpenP (no longer open) [port,v4]:    ")/*+T((nicNameC)ptHe)+T("    ")+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" )")*/ ) ; //U:: TO FIND A BUG
                    {
                    if( !stValidated( (byteT*)&ptHe , subtractPortF ) )
                    portTimeC& ptHe = *(portC*)&stOpenP.downF( tin0P , hDown ) ;
                {
                do
                handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;
            {
            if( stOpenP )
            stOpenP.grabF( tin0P , TAG( TAGiDnULL ) ) ;

            //}
            //    stValidated.purgeF( tin0P ) ; //U:: TO TEST
            //    etThread.traceF( tin0P , T("U:: purging stValidated (to test)") ) ; //U:: TO FIND A BUG
            //{
            //if( stOpenP )

            }
                while( !stToScan.third && ~hDown ) ;
                }
                    }
                        }
                            }
                                //etThread.traceF( tin0P , T("connected aok [nnTry,idPortTry]:    ")+T(nnHe)+tb4+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                nicNameC nnHe = portHe ;
                                stValidated.sinkF( tin0P , countTC() , (byteT*)&portHe , flSTACKsINK_UNIQUE , subtractPortF ) ;
                                portHe = idpTry ;
                            {
                            if( !bFail )
                        
                            }
                                }
                                    }
                                        }
                                            sockScan.writeF( tin0P , soulo ) ;

                                            soulo << finger ;   // idCmd
                                            finger = ifcIDcMDnODE_BYE ;
                                            soulo << finger ;   // idFormat
                                            finger = 1 ;
                                            soulo << finger ;
                                            putNegAM( finger , FINGERnEG_nodeC ) ;
                                            ZE( countT , finger ) ;
                                            soulC soulo( tin0P , TAG( TAGiDnULL ) ) ;
                                        {
                                        else
                                        }
                                            etThread.traceF( tin0P , T("unexpected contents in incoming soul") ) ;
                                            bFail = 1 ;
                                            POOPRqUIET
                                        {
                                        if( POOP )

                                        __( finger - ifcIDcMDnODE_PINGrEPLY ) ;
                                        souli >> finger ;   //idCmd
                                        finger = 0 ;

                                        __( finger - 1 ) ;
                                        souli >> finger ;   //idFormat
                                        finger = 0 ;

                                        __( getNegAM( finger ) - FINGERnEG_nodeC ) ;
                                        souli >> finger ;
                                        ZE( countT , finger ) ;
                                    {
                                    else
                                    }
                                        etThread.traceF( tin0P , T("could not read") ) ;
                                        bFail = 1 ;
                                        POOPRqUIET
                                    {
                                    if( POOP )

                                    sockScan.readF( tin0P , souli ) ;
                                    soulC souli( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
                                {
                                else
                                }
                                    etThread.traceF( tin0P , T("could not write") ) ;
                                    bFail = 1 ;
                                    POOPRqUIET
                                {
                                if( POOP )

                                sockScan.writeF( tin0P , soulo ) ;
                                //etThread.traceF( tin0P , T("writing ifcIDcMDnODE_PING") ) ;
                                SCOOPS
                            {
                            IFsCRATCH

                            soulo << finger ;   // idCmd
                            finger = ifcIDcMDnODE_PING ;
                            soulo << finger ;   // idFormat
                            finger = 1 ;
                            soulo << finger ;
                            putNegAM( finger , FINGERnEG_nodeC ) ;
                            ZE( countT , finger ) ;
                            soulC soulo( tin0P , TAG( TAGiDnULL ) ) ;
                        {
                        if( !bFail )

                        }
                            }
                                //etThread.traceF( tin0P , T("could not connect [nnTry,idPortTry]:    ")+T(nnHe)+tb4+TF2(idpTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                nicNameC nnHe = portHe ;
                                bFail = 1 ;
                                POOPRqUIET
                            {
                            if( POOP )

                            sockScan.connectF( tin0P , idpTry , portHe , 1 , TUCK >> 4 ) ; //U:: LONGER TIMEOUT FOR GLOBAL TREE
                            sockScan.etherF( tin0P , *((tin1S&)tin0P).pEtScratch ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        ZE( boolT , bFail ) ;

                        socketC sockScan( tin0P , etThread , TAG( TAGiDnULL ) ) ;
                    {
                    for( countT idpTry = idpMin ; idpTry <= idpMax ; idpTry ++ )
                    countT idpMax = (countT)portHe ? (countT)portHe : ifcIDpORT_nodeC + 3 ;
                    countT idpMin = (countT)portHe ? (countT)portHe : ifcIDpORT_nodeC     ;

                    //etThread.traceF( tin0P , T("stToScan [idPlate,port,v4]:    ")+TF2(++idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((nicNameC&)portHe)+T("    ")+T(portHe.nnv4F()) ) ; //U:: TO FIND A BUG
                    portC& portHe = *(portC*)&stToScan.downF( tin0P , hDown ) ;
                {
                do
                handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , idPlate ) ;
            {
            if( stToScan )
            stackC stValidated( tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_DOnOTsERIALIZE , sizeof( portC ) ) ;

            }
                //etThread.traceF( tin0P , T("global nodes (end)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
                }
                    }
                        //etThread.traceF( tin0P , T("global node [off,nn,nnv4]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(pzNodeListGlobal->pEntry[offi].nn)+tb4+T(nicNameC(pzNodeListGlobal->pEntry[offi].nnv4)) , flTRACE_null , ifcIDtRACEdIVERT_e ) ;

                        stToScan.sinkF( tin0P , countTC() , (byteT*)&portHe , flSTACKsINK_UNIQUE , subtractPortF ) ;

                        //FROM THAT POINT, THE PROCESSING IS JUST LIKE THE OLD CODE ; THE ROOT PUBLISHES THE OPEN LIST AND THE GOSSIP LIST
                        //RECIPE: SCAN PORTS FOR EACH LISTED HOST UNTIL I FIND AN ANSWER ; THEN REGISTER MYSELF WITH THAT ROOT
                        //FOR A LOCAL BANG RELAY, THE LIST ONLY GIVES ME A WAY TO DISCOVER ROOT
                        //U:: THE LIST ONLY GIVES ME POTENTIAL NODES ; stOpen CANNOT BE LOADED FROM THE LIST

                        //portHe = nicNameC( pzNodeListGlobal->pEntry[ offi ].nnv4   ) ;
                        //portHe =           pzNodeListGlobal->pEntry[ offi ].nn       ;
                        portHe = pzNodeListGlobal->pEntry[ offi ].port ;
                        portC portHe ;
                    {
                    if( pzNodeListGlobal->pEntry[ offi ].ttl )
                {
                for( countT offi = 0 ; offi < pzNodeListGlobal->cEltsMax ; offi ++ )
                //etThread.traceF( tin0P , T("global nodes (begin)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
            {
            if( pzNodeListGlobal )

            }
                //etThread.traceF( tin0P , T("local nodes (end)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
                }
                    }
                        //etThread.traceF( tin0P , T("local node [off,nn,nnv4]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(pzNodeListLocal->pEntry[offi].nn)+tb4+T(nicNameC(pzNodeListLocal->pEntry[offi].nnv4)) , flTRACE_null , ifcIDtRACEdIVERT_e ) ;

                        stToScan.sinkF( tin0P , countTC() , (byteT*)&portHe , flSTACKsINK_UNIQUE , subtractPortF ) ;

                        //FROM THAT POINT, THE PROCESSING IS JUST LIKE THE OLD CODE ; THE ROOT PUBLISHES THE OPEN LIST AND THE GOSSIP LIST
                        //RECIPE: SCAN PORTS FOR EACH LISTED HOST UNTIL I FIND AN ANSWER ; THEN REGISTER MYSELF WITH THAT ROOT
                        //FOR A LOCAL BANG RELAY, THE LIST ONLY GIVES ME A WAY TO DISCOVER ROOT
                        //U:: THE LIST ONLY GIVES ME POTENTIAL NODES ; stOpen CANNOT BE LOADED FROM THE LIST

                        //portHe = nicNameC( pzNodeListLocal->pEntry[ offi ].nnv4   ) ;
                        //portHe =           pzNodeListLocal->pEntry[ offi ].nn       ;
                        portHe = pzNodeListLocal->pEntry[ offi ].port ;
                        portC portHe ;
                    {
                    if( pzNodeListLocal->pEntry[ offi ].ttl )
                {
                for( countT offi = 0 ; offi < pzNodeListLocal->cEltsMax ; offi ++ )
                //etThread.traceF( tin0P , T("local nodes (begin)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
            {
            if( pzNodeListLocal )

            }
                //etThread.traceF( tin0P , T("me nodes (end)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
                }
                    }
                        //etThread.traceF( tin0P , T("me node [off,nn,nnv4]:    ")+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(pzNodeListMe->pEntry[offi].port.nn)+tb4+T(nicNameC(pzNodeListMe->pEntry[offi].port.nnv4)) , flTRACE_null , ifcIDtRACEdIVERT_e ) ;

                        stToScan.sinkF( tin0P , countTC() , (byteT*)&portHe , flSTACKsINK_UNIQUE , subtractPortF ) ;

                        //FROM THAT POINT, THE PROCESSING IS JUST LIKE THE OLD CODE ; THE ROOT PUBLISHES THE OPEN LIST AND THE GOSSIP LIST
                        //RECIPE: SCAN PORTS FOR EACH LISTED HOST UNTIL I FIND AN ANSWER ; THEN REGISTER MYSELF WITH THAT ROOT
                        //FOR A LOCAL BANG RELAY, THE LIST ONLY GIVES ME A WAY TO DISCOVER ROOT
                        //U:: THE LIST ONLY GIVES ME POTENTIAL NODES ; stOpen CANNOT BE LOADED FROM THE LIST

                        //portHe = nicNameC( pzNodeListMe->pEntry[ offi ].nnv4   ) ;
                        //portHe =           pzNodeListMe->pEntry[ offi ].nn       ;
                        portHe = pzNodeListMe->pEntry[ offi ].port ;
                        portC portHe ;
                    {
                    if( pzNodeListMe->pEntry[ offi ].ttl )
                {
                for( countT offi = 0 ; offi < pzNodeListMe->cEltsMax ; offi ++ )
                //etThread.traceF( tin0P , T("me nodes (begin)") , flTRACE_null , ifcIDtRACEdIVERT_e ) ;
            {
            if( pzNodeListMe )

            stackC stToScan( tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB | flSTACKc_DOnOTsERIALIZE , sizeof( portC ) ) ;
        {
        if( !bFail ) while( !ether && !POOP && !bQuitP )

        }
            //THE IDEA IS TO USE DISK TO REMEMBER PORTS SO THAT A NEW NODE CAN CONNECT ITSELF TO OTHER PORTS EVEN IF THE PORTS REGISTERED IN DNS ARE NOT RESPONSIVE
            //REGARDLESS OF MODE, THIS IS A LIST OF PORTS TO SCAN IN THE SEARCH FOR RESPONSIVE NODES
            //AT A MINIMUM, IT WILL CONTAIN spacenn.ideafarm.com ( spaceport.ideafarm.com )
            //U::ALLOCATE pzNodeList AND POPULATE IT FROM DNS AND OTHER SOURCES
        {
        if( F(flagsSeeNodesP) & flSEEnODES_GLOBAL )

        }
            if( !bFail ) pzNodeListLocal = (nodeListS*)(byteT*)*pNapNodeListLocal ;

            THREADmODE3rESTORE
            }
                bFail = 1 ;
                etThread.traceF( tin0P , T("watch must be running for this home; doing nothing") ) ;
                pNapNodeListLocal->formattingIsDoneF( tin0P ) ;
            {
            if( !POOP && !pNapNodeListLocal->bFormattedF() )
            __Z( pNapNodeListLocal ) ;
            pNapNodeListLocal = new( 0 , tin0P , LF ) napkinC( tin0P , TAG( TAGiDnULL ) , "ipdos.node.list.link.local.recent.advertisers" , 0 , TOCK , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_null , - 1 , ifcIDmEMORYsPACE_UNIVERSE ) ; ___( pNapNodeListLocal ) ;
            THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
        {
        if( F(flagsSeeNodesP) & flSEEnODES_LOCAL )

        }
            }
                }
                    break ;
                    inc02AM( nl.cElts ) ;
                    etThread.traceF( tin0P , T("adding myself [nn,nnv4]:    ")+T(nn)+T("    ")+T(nnv4) ) ;
                    nicNameC nnv4 = nl.pEntry[ offi ].port.nnv4F() ;
                    nicNameC nn   = nl.pEntry[ offi ].port ;

                    nl.pEntry[ offi ].port = portMeP ;
                {
                if( !setIfZeAM( nl.pEntry[ offi ].ttl , 1 ) )
            {
            for( countT offi = 0 ; offi < nl.cEltsMax ; offi ++ )
            nodeListS& nl = *pzNodeListMe ;

            pzNodeListMe = (nodeListS*)(byteT*)*pNapNodeListMe ;

            THREADmODE3rESTORE
            }
                pNapNodeListMe->formattingIsDoneF( tin0P ) ;

                nl.cEltsMax = ( cbData - sizeof( nodeListS ) + sizeof( nodeEntryS ) ) / sizeof( nodeEntryS ) ;
                nodeListS& nl = *(nodeListS*)pbData ;

                etThread.memSetF( tin0P , pbData , cbData ) ;
                countT cbData = *pNapNodeListMe ;
                byteT* pbData = *pNapNodeListMe ;
            {
            if( !POOP && !pNapNodeListMe->bFormattedF() )
            __Z( pNapNodeListMe ) ;
            pNapNodeListMe = new( 0 , tin0P , LF ) napkinC( tin0P , TAG( TAGiDnULL ) , "ipdos.node.list.intraprocess" , 0 , TOCK , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_null , - 1 , ifcIDmEMORYsPACE_UNIVERSE ) ; ___( pNapNodeListMe ) ;
            THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
        {
        if( F(flagsSeeNodesP) & flSEEnODES_ME )

        ZE( boolT , bFail ) ;
        ZE( nodeListS* , pzNodeListGlobal ) ;      // ZOMBIE IFF !!pNapNodeListGlobal
        ZE( nodeListS* , pzNodeListLocal  ) ;      // ZOMBIE IFF !!pNapNodeListLocal
        ZE( nodeListS* , pzNodeListMe     ) ;      // ZOMBIE IFF !!pNapNodeListMe
        ZE( napkinC*   , pNapNodeListGlobal ) ;
        ZE( napkinC*   , pNapNodeListLocal  ) ;
        ZE( napkinC*   , pNapNodeListMe     ) ;
        TN( tb4 , "    " ) ;
    {

    portC&       portMeP =  *(portC*)pTaskP->c6 ;
    const countT flagsSeeNodesP =           pTaskP->c5 ;
    stackC&      stOpenP = *(stackC*)pTaskP->c4 ;
    countT&      cKidsP  = *(countT*)pTaskP->c3 ;
    boolT&       bQuitP  =  *(boolT*)pTaskP->c2 ;
    nodeC&       nodeP   =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmRefreshListF )

DONE( tmLiveF )
}
    dec02AM( cKidsP ) ;

    }
        ++ s ; ether.osSleepF( tin0P , TOCK ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        stOpenP.ungrabF( tin0P ) ;
        }
            while( !stOpenP.third && ~hDown ) ;
            }
                etThread.traceF( tin0P , T("i am alive! ")+TF2(idPlate,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(timeHe)+tb4+T(nnHe)+tb4+T(ptHe.nnv4F())+T(" ( ")+TF2((countT)ptHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(bMe?" )  (me)":" )")+T(bMe&&idPlate==1?" (root)":"") ) ; //U:: TO FIND A BUG
                const timeS& timeHe = ptHe ;
                nicNameC nnHe = ptHe ;

                boolT bMe = (portC&)ptHe == portMeP ;

                portTimeC& ptHe = *(portTimeC*)&stOpenP.downF( tin0P , hDown ) ;

                ++ idPlate ;
            {
            do
            handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , idPlate ) ;
        {
        if( stOpenP )
        stOpenP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {
    while( !bQuitP )
    TN( tb4 , "    " ) ;

    portC&       portMeP =  *(portC*)pTaskP->c6 ;
    const countT flagsSeeNodesP =           pTaskP->c5 ;
    stackC&      stOpenP = *(stackC*)pTaskP->c4 ;
    countT&      cKidsP  = *(countT*)pTaskP->c3 ;
    boolT&       bQuitP  =  *(boolT*)pTaskP->c2 ;
    nodeC&       nodeP   =  *(nodeC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmLiveF )

}
    return sgn ;

    sCountT sgn = c1P && c2P ? *(portTimeC*)c1P - *(portTimeC*)c2P : 0 ;
    _IO_

    }
    {
    IFbEcAREFUL
{
/*1*/countT _export subtractPortTimeF( tin0S& tin0P , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
/**/
*/
/*

}
    return sgn ;

    sCountT sgn = c1P && c2P ? *(portC*)c1P - *(portC*)c2P : 0 ;
    _IO_

    }
    {
    IFbEcAREFUL
{
/*1*/countT _export subtractPortF( tin0S& tin0P , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/
/**/
*/
/*

}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
    {
    while( cKids )
    bQuit = 1 ;

    }
        ++ s ; ether.osSleepF( tin0P , TOCK ) ;
    {
    while( !etPrime )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    etherC& etPrime = etherC::etPrimeIF( tin0P ) ;

    ether.osThreadF( TaRG3fLAGScBtLS( tmHireWorkersF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLS ) , (countT)this , (countT)&bQuit , (countT)&cKids , (countT)&stAccepted , (countT)&stOpen , flagsSeeNodes , (countT)&portMe ) ;
    ether.osThreadF( TaRG3fLAGScBtLS( tmAcceptF      , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLS ) , (countT)this , (countT)&bQuit , (countT)&cKids , (countT)&stAccepted , (countT)&stOpen , flagsSeeNodes , (countT)&portMe ) ;
    countT cKids = 2 ;
    ZE( boolT , bQuit ) ;

    }
        portMe = neMe.port.nnv4F() ;
        portMe = neMe.port ;

        }
            neMe.port = nnWo ;

            if( bIgnore ) continue ;

            boolT bIgnore = bv4 ? ~nnv4 : ~nn ;
            nicNameC nnv4 = neMe.port.nnv4F() ;
            nicNameC nn   = neMe.port ;

            boolT bv4     = nnWo.isIPv4F() ;

            //ether.traceF( tin0P , T("[nnWo]:    ")+T(nnWo)+T(nnWo.isIPv4F()?"    IPv4":"    IPv6") ) ;
            soulNicName >> nnWo ;
            nicNameC nnWo ;

            }
                if( ~nn && ~nnv4 ) break ;
                nicNameC nnv4 = neMe.port.nnv4F() ;
                nicNameC nn   = neMe.port ;
            {
        {
        while( soulNicName )
        nodeEntryS neMe ;

        }
            ether.delF( tin0P , pnnMe ) ;
            }
                //else ether.traceF( tin0P , T("nodeC / NON-routable    :    ")+T(pnnMe[offi]) ) ;
                }
                    soulNicName << pnnMe[ offi ] ;
                    //ether.traceF( tin0P ,  T("nodeC / routable unicast:    ")+T(pnnMe[offi]) ) ;
                {
                if( pnnMe[ offi ].isRoutableUnicastF() )
            {
            for( countT offi = 0 ; offi < cnnMe ; offi ++ )
            socketC::nicNameIF( tin0P , ether , pnnMe , cnnMe , 0 ) ; ___( pnnMe ) ;
            ZE( countT    , cnnMe ) ;
            ZE( nicNameC* , pnnMe ) ;
        {
        soulC soulNicName( tin0P , TAG( TAGiDnULL ) ) ;
    {
{
stOpen(     tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( portTimeC ) )
stAccepted( tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_countT ) ,
flagsSeeNodes( flagsSeeNodesP ) ,
ether( etherP ) ,
nodeC::nodeC( tin0S& tin0P , etherC& etherP , const countT flagsSeeNodesP ) :

;
}
    nodeC( tin0S& tin0P , etherC& etherP , const flagsT flagsSeeNodesP = flSEEnODES_ME ) ;

    public :

    portC        portMe        ;
    stackC       stOpen        ;
    stackC       stAccepted    ;
    const flagsT flagsSeeNodes ;
    etherC&      ether         ;
{
class nodeC

TASKpART0PROTO( tmRefreshListF ) ;
TASKpART0PROTO( tmWorkerF      ) ;
TASKpART0PROTO( tmHireWorkersF ) ;
TASKpART0PROTO( tmAcceptF      ) ;

#define ifcIDcMDnODE_HELLOfROMrOOT   4
#define ifcIDcMDnODE_PINGrEPLY       3
#define ifcIDcMDnODE_PING            2
#define ifcIDcMDnODE_BYE             1

#define CBtLS ( TUCK << 3 )

/*3*/
#define flSEEnODES_GLOBAL                            0xe00004ff
#define flSEEnODES_LOCAL                             0xe00002ff
#define flSEEnODES_ME                                0xe00001ff
/*3*/

/*1*/WAKEhIDE( "doodle.nodeC.bang.relay" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
