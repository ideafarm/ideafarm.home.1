
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cReplacements ;

    if( bDeleteOldBig ) delF( tinP , *(strokeS**)&psttOldBig ) ;

    }
        }
            break ;

            strReverseF( tinP , psttNewBigP , 0 , tLF       , 0 , 0 , 0 ) ; ___( psttNewBigP ) ;
            strReplaceF( tinP , psttNewBigP , 0 , T(" ")    , T("&nbsp;") , 0 , flSTRrEPLACE_IGNOREqUOTES ) ;

            delF( tinP , pstt1w ) ;
            }
                }
                    strFuseF( tinP , psttNewBigP , tEscRawCrLf ) ;
                    strFuseF( tinP , psttNewBigP , psttc2 ) ;
                    strFuseF( tinP , psttNewBigP , tBarb4 ) ;
                    idLF = 0 ;
                {
                else
                }
                    }
                        strFuseF( tinP , psttNewBigP , tEscNullCrLf ) ;
                        strFuseF( tinP , psttNewBigP , tBarb0 ) ;
                        //traceF( tinP , T("insert blank line now") ) ;
                    {
                    if( 1 < ++ idLF )
                {
                if( !strCompareF( tinP , psttc2 , tLF ) )
            {
            FORsTRINGSiN2( pstt1w )
            idLF = 0 ;

            strMakeF( tinP , LF , psttNewBigP , 0 , /*U::*/TOCK + csttOld + ( cLines + cBlankLines ) * ( tBarb4.csF( tinP ) + tEscRawCrLf.csF( tinP ) ) ) ; ___( psttNewBigP ) ;

            }
                }
                    csttOld += psttc1->idAdam ;
                    cLines ++ ;
                    //traceF( tinP , T("my line [cstt,value]:    ")+TF2(psttc1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    \"")+T(psttc1)+T("\"") , flTRACE_KEEPcRlF | flTRACE_NOpREFIX ) ;

                    if( idLF ) idLF = 0 ;
                {
                else
                }
                    }
                        //traceF( tinP , T("blank line [cBlankLines]:    ")+TF2(cBlankLines,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        cBlankLines ++ ;
                    {
                    if( 1 < ++ idLF )
                    //traceF( tinP , T("my LF") ) ;
                {
                if( !strCompareF( tinP , psttc1 , tLF ) )
            {
            FORsTRINGSiN1( pstt1w )
            ZE( countT , csttOld ) ;
            ZE( countT , cBlankLines ) ;
            ZE( countT , idLF ) ;
            ZE( countT , cLines ) ;
            TN( tEscNullCrLf , "\\n\\j\r\n" ) ;
            TN( tEscRawCrLf  , "\\r\\j\r\n" ) ;
            TN( tBarb0 , "<br>\\m&#124;" ) ;
            TN( tBarb4 , "<br>\\m&#124;&nbsp;&nbsp;&nbsp;&nbsp;" ) ;
            
            delF( tinP , psttNewBigP ) ;
            strWordsF( tinP , pstt1w , psttNewBigP , sttq , T("\r\n") , flSTRwORDS_DELIMITERsTRING | flSTRwORDS_DELIMITERS , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1w ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1w ) ;

            strReplaceF( tinP , psttNewBigP , 0          , T("\\")   , T("&#92;")  , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttNewBigP ) ;
            strReplaceF( tinP , psttNewBigP , 0          , T("}")    , T("&#125;") , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttNewBigP ) ;
            strReplaceF( tinP , psttNewBigP , 0          , T("{")    , T("&#123;") , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttNewBigP ) ;
            strReplaceF( tinP , psttNewBigP , 0          , T(">")    , T("&#62;")  , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttNewBigP ) ;
            strReplaceF( tinP , psttNewBigP , psttOldBig , T("<")    , T("&#60;")  , 0 , flSTRrEPLACE_IGNOREqUOTES ) ; ___( psttNewBigP ) ;

            TN( tLFLFLFLF , "\r\n\r\n\r\n\r\n" ) ;
            TN( tLFLFLF   , "\r\n\r\n\r\n" ) ;
            TN( tLFLF     , "\r\n\r\n" ) ;
            TN( tLF       , "\r\n" ) ;
        {
        case ifcIDtYPEsTRrEPLACE_KTsOIIdISPLAYfROMsOURCEsOIL :
        }
            break ;

            }
                }
                    else strFuseF( tinP , psttNewBigP , psttOldBig[ CSpREFIX - 1 + ids ] ) ;
                    else if( psttOldBig[ CSpREFIX - 1 + ids ].idCaste == sc_cADAMeXPORT ) csDeltaThis = psttOldBig[ CSpREFIX - 1 + ids ].idAdam ;
                    }
                        cReplacements ++ ;
                        csDeltaThis = 0 ;
                        ids += csDeltaThis - 1 ;

                        strFuseF( tinP , psttNewBigP , stta ) ;
                        strokeS stta( FINGERnEG_SADAMsTROKEcT , psf ) ;

                        //}
                        //    delF( tinP , psttd ) ;
                        //    thirdC::dosExitProcessIF( 1 ) ;
                        //    LOGrAW( T("import: \"")+T(psttd)+T("\"\r\n") ) ;
                        //    soulC::dumpIF( tinP , psttd , *psf ) ; ___( psttd ) ;
                        //    ZE( strokeS* , psttd ) ;
                        //{
                        // FOR DEBUGGING ONLY

                        psf->shiftLeftF( tinP , ifcIDtYPEsOULiTEM_soulC , pbi , 0 , flSOULiTEM_null , flSOULsHIFTlEFTmODE_UNPACKsOULiMAGE ) ;
                        
                        if( POOP ) break ;
                        __( ((const countT*)pbi)[ 1 ] - 1                             ) ;
                        __( getNegAM( ((const countT*)pbi)[ 0 ] ) - FINGERnEG_SOULc ) ;
                        const byteT* pbi = (const byteT*)( psttOldBig + CSpREFIX - 1 + ids ) ;
                        (*this)( tinP , psf , TAG( TAGiDnULL ) ) ;
                        ZE( soulC* , psf ) ;
                    {
                    if( csDeltaThis )
                {
                for( countT ids = 1 ; ids <= psttOldBig->idAdam ; ids ++ )
                ZE( countT , csDeltaThis ) ; //SEMANTICS: "bArmed": IF NOT ZE THEN I AM AT THE BEGINNING OF A soulC IMAGE

                strMakeF( tinP , LF , psttNewBigP , T("") , psttOldBig->idAdam - csDelta + csttExtraP ) ;
            {
            else
            }
                strMakeF( tinP , LF , psttNewBigP , psttOldBig , csttExtraP ) ; //CALLER MUST TAG
            {
            if( !csDelta )
    
            }
                }
                    ids     += csDeltaThis ;
                    csDelta += csDeltaThis ;
                    countT csDeltaThis = psttOldBig[ CSpREFIX - 1 + ids ].idAdam ;
                {
                if( psttOldBig[ CSpREFIX - 1 + ids ].idCaste == sc_cADAMeXPORT )
            {
            for( countT ids = 1 ; ids <= psttOldBig->idAdam ; ids ++ )
            ZE( countT , csDelta ) ;
        {
        case ifcIDtYPEsTRrEPLACE_MAKEiMPORT :
        }
            break ;

            }
                }
                    else strFuseF( tinP , psttNewBigP , psttOldBig[ CSpREFIX - 1 + ids ] ) ;
                    }
                        (*this)( tinP , psf ) ;

                        }
                            }
                                cReplacements ++ ;
                                thirdC::c_memcpyIF( tinP , pbTo , *psf , cbImage ) ;
                                    
                                while( csDeltaThis -- ) strFuseF( tinP , psttNewBigP , stt0 ) ; //DONE THIS WAY CAUSE SAFER; IF WANT SPEED THEN DEFINE A NEW OVERLOAD OF strFuseF TO DO THIS JOB FASTER; DON'T KLUDGE IT WITH A MEMCPY
                                byteT* pbTo = (byteT*)( psttNewBigP + CSpREFIX + psttNewBigP->idAdam ) ;
    
                                psttNewBigP[ CSpREFIX - 1 + psttNewBigP->idAdam ].idAdam  = csDeltaThis ;
                                psttNewBigP[ CSpREFIX - 1 + psttNewBigP->idAdam ].idCaste = sc_cADAMeXPORT ;
                                strFuseF( tinP , psttNewBigP , stt0 ) ;
                                strokeS stt0 ;
        
                                countT csDeltaThis = ( cbImage + cbPad ) / sizeof( strokeS ) ;
                                countT cbPad = sizeof( strokeS ) - 1 - ( cbImage + sizeof( strokeS ) - 1 ) % sizeof( strokeS ) ;
                                countT cbImage = 3 * sizeof( countT ) + *(const countT*)pbi ;
                            {
                            if( !POOP )

                            __( *(const countT*)pbi - 1                             ) ; pbi += sizeof( countT ) ;
                            __( getNegAM( *(const countT*)pbi ) - FINGERnEG_SOULc ) ; pbi += sizeof( countT ) ;
                            const byteT* pbi = *psf ;

                            //}
                            //    delF( tinP , psttd ) ;
                            //    LOGrAW( T("export: \"")+T(psttd)+T("\"\r\n") ) ;
                            //    soulC::dumpIF( tinP , psttd , *psf ) ; ___( psttd ) ;
                            //    ZE( strokeS* , psttd ) ;
                            //{
                            // FOR DEBUGGING ONLY
                        {
                        if( !POOP )
                        __Z( psf ) ;

                        psttOldBig[ CSpREFIX - 1 + ids ].featuresF( tinP , psf ) ; ___( psf ) ;
                        ZE( soulC* , psf ) ;
                    {
                    if( psttOldBig[ CSpREFIX - 1 + ids ].idCaste == sc_cADAM )
                {
                for( countT ids = 1 ; ids <= psttOldBig->idAdam ; ids ++ )

                strMakeF( tinP , LF , psttNewBigP , T("") , psttOldBig->idAdam + csDelta + csttExtraP ) ; // CALLER MUST TAG
            {
            else
            }
                strMakeF( tinP , LF , psttNewBigP , psttOldBig , csttExtraP ) ; //CALLER MUST TAG
            {
            else if( !csDelta )
            if( POOP ) ;
    
            }
                }
                    (*this)( tinP , psf ) ;
                    }
                        csDelta += csDeltaThis ;
                        countT csDeltaThis = ( cbImage + cbPad ) / sizeof( strokeS ) ;
                        countT cbPad = sizeof( strokeS ) - 1 - ( cbImage + sizeof( strokeS ) - 1 ) % sizeof( strokeS ) ;
                        countT cbImage = 3 * sizeof( countT ) + *(const countT*)pbi ;

                        __( *(const countT*)pbi - 1                 ) ; pbi += sizeof( countT ) ;
                        __( getNegAM( *(const countT*)pbi ) - FINGERnEG_SOULc ) ; pbi += sizeof( countT ) ;
                        const byteT* pbi = *psf ;
                    {
                    if( !POOP )
                    __Z( psf ) ;

                    psttOldBig[ CSpREFIX - 1 + ids ].featuresF( tinP , psf ) ; ___( psf ) ;
                    ZE( soulC* , psf ) ;
                {
                if( psttOldBig[ CSpREFIX - 1 + ids ].idCaste == sc_cADAM )
            {
            for( countT ids = 1 ; ids <= psttOldBig->idAdam ; ids ++ )
            ZE( countT , csDelta ) ;
        {
        case ifcIDtYPEsTRrEPLACE_MAKEeXPORT :
        }
            break ;
            }
                psttNewBigP[ 2 ].idAdam -= offn ;
                psttNewBigP[ 0 ].idAdam += offn ;
                }
                    else        cReplacements ++ ;
                    if( bCopy ) psttNewBigP[ CSpREFIX + offn ++ ] = psttOldBig[ CSpREFIX - 1 + ido ] ;

                    }
                        }
                            ido ++ ;
                            psttNewBigP[ CSpREFIX + offn ++ ] = S1C(offt<0xa?'0'+offt:'a'+offt-0xa) ;
                            bCopy = 0 ;
                        {
                        if( offt < 0x10 )

                        }
                            }
                                offt ++ ;
                                if( idAdamA == ppostNam[ offt ][ 0 ] && idAdamB == ppostNam[ offt ][ 1 ] ) break ;
                            {
                            while( offt < 0x10 )
                            offt = 0 ;
                        {
                        else if( !bInQuote || F(flagsP) & flSTRrEPLACE_IGNOREqUOTES )
                        if( idAdamA == '"' ) bInQuote = !bInQuote ;
                        countT offt = - 1 ;
                        countT idAdamB = psttOldBig[ CSpREFIX     + ido ].idAdam ;
                        countT idAdamA = psttOldBig[ CSpREFIX - 1 + ido ].idAdam ;
                    {
                    if( psttOldBig[ CSpREFIX - 1 + ido ].idCaste == sc_cFROMaSCII )

                    countT bCopy = 1 ;
                {
                for( countT ido = 1 ; ido <= psttOldBig->idAdam ; ido ++ )
                ZE( countT , offn ) ;

                ZE( boolT , bInQuote ) ;
            {
            if( psttNewBigP )
            strMakeF( tinP , LF , psttNewBigP , T("") , psttOldBig->idAdam + csttExtraP ) ; //CALLER MUST TAG
        {
        case ifcIDtYPEsTRrEPLACE_DIGITnAMEStOdIGITS :
        }
            break ;
            }
                psttNewBigP[ 2 ].idAdam -= offn ;
                psttNewBigP[ 0 ].idAdam += offn ;
                }
                    else        cReplacements ++ ;
                    if( bCopy ) psttNewBigP[ CSpREFIX + offn ++ ] = psttOldBig[ CSpREFIX - 1 + ido ] ;

                    }
                        }
                            psttNewBigP[ CSpREFIX + offn ++ ] = S1C(ppostNam[offt][1]) ;
                            psttNewBigP[ CSpREFIX + offn ++ ] = S1C(ppostNam[offt][0]) ;
                            bCopy = 0 ;
                        {
                        if( offt != - 1 )

                        }
                            else if( idAdam >= 'a' && idAdam <= 'f' ) offt = idAdam - 'a' + 0xa ;
                                 if( idAdam >= '0' && idAdam <= '9' ) offt = idAdam - '0' ;
                        {
                        else if( !bInQuote || F(flagsP) & flSTRrEPLACE_IGNOREqUOTES )
                        if( idAdam == '"' ) bInQuote = !bInQuote ;
                        countT offt = - 1 ;
                        countT idAdam = psttOldBig[ CSpREFIX - 1 + ido ].idAdam ;
                    {
                    if( psttOldBig[ CSpREFIX - 1 + ido ].idCaste == sc_cFROMaSCII )

                    countT bCopy = 1 ;
                {
                for( countT ido = 1 ; ido <= psttOldBig->idAdam ; ido ++ )
                ZE( countT , offn ) ;

                ZE( boolT , bInQuote ) ;
            {
            if( psttNewBigP )
            strMakeF( tinP , LF , psttNewBigP , T("") , psttOldBig->idAdam * 2 + csttExtraP ) ; //CALLER MUST TAG
        {
        case ifcIDtYPEsTRrEPLACE_DIGITStOdIGITnAMES :
        }
            break ;
            }
                }
                    if( sttc.idCaste == sc_cFROMaSCII && ( sttc.idAdam < 0x20 || sttc.idAdam > 0x7f ) ) sttc.idAdam = '.' ;
                    strokeS& sttc = psttNewBigP[ CSpREFIX - 1 + idr ] ;
                {
                for( countT idr = 1 ; idr <= psttNewBigP->idAdam ; idr ++ )
            {
            if( psttNewBigP )
            strMakeF( tinP , LF , psttNewBigP , psttOldBigP ) ; //CALLER MUST TAG;   U::BUG? CONJ: SHOULD BE psttOldBig NOT psttOldBigP
        {
        case ifcIDtYPEsTRrEPLACE_REMOVEaSCIIlOWhIGH :
    {
    switch( idTypeP )
    static const osTextT ppostNam[ 0x10 ][ 2 ] = { 'Z' , 'e' , 'W' , 'o' , 'O' , 'o' , 'R' , 'e' , 'F' , 'o' , 'F' , 'i' , 'S' , 'e' , 'V' , 'e' , 'T' , 'a' , 'N' , 'i' , 'A' , 'y' , 'B' , 'e' , 'C' , 'e' , 'D' , 'e' , 'E' , 'e' , 'F' , 'e' } ;

    }
        bDeleteOldBig = 1 ;
        psttNewBigP = 0 ;
        psttOldBig = psttNewBigP ;
    {
    else
    if( psttOldBigP ) psttOldBig = psttOldBigP ;
    ZE( boolT , bDeleteOldBig ) ;
    ZE( const strokeS* , psttOldBig ) ;
    ZE( countT , cReplacements ) ;
    _IO_

    }
        if( POOP ) return 0 ;
        __( !psttNewBigP == !psttOldBigP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/countT etherC::strReplaceF( tinS& tinP , strokeS*& psttNewBigP , const strokeS* const psttOldBigP , const countT idTypeP , const countT csttExtraP , const flagsT flagsP )/*1*/

/**/
*/
 flagsP 
  use csttExtraP to specify additional extra strokes
  i always preserve the extra strokes that are present in the source string
  can be 0
 csttExtraP
  if i am exporting then i assume that the soulC objects referenced are not volatile
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010156.ifcIDtYPEsTRrEPLACE!||
 idTypeP
  if not 0 then psttNewBigP must be 0
  if 0 then psttNewBigP will be replaced
  can be 0
 psttOldBigP
 psttNewBigP
 tinP
arguments
i do a set of replacements that are specified by setting flag bits
\<A HREF=\"5.1030174.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strReplaceF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//

