
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tinBaseP ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tinBaseP , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        // #endif
        //     //etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_SHUTDOWN ) ;
        // #if defined( IFC tESTING )

        }
            }
                ++ s ; thirdC::dosSleepWinkIF( tinBaseP , 0 ) ;
            {
            while( cWorkersCompare || cWorkersHeal )
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        {

        swJotSortedShortByArchiveYear.ungrabF( tinBaseP ) ;
        }
            DEL( pDoomed ) ;                                                                        //20230306@1825: U:: jotC DT/OR FAILS COMPLAINING THAT pEtScratch IS IMPOTENT ; HOW: CTRL-C OR FIRE SERVICE
            jotC*& pDoomed = (jotC*&)(countT&)swJotSortedShortByArchiveYear ;
            psttzlArchiveSlashYear = (strokeS*)swJotSortedShortByArchiveYear.leverF( tinBaseP , idf ) ;
            _IO_
        {
        for( countT idf = 1 ; idf < cFlavors ; idf ++ )
        countT cFlavors = swJotSortedShortByArchiveYear.cFlavorsF( tinBaseP ) ;
        swJotSortedShortByArchiveYear.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

        }
            funJobHealFile.writeF( tinBaseP , pbz ) ;
            new( 0 , tinBaseP , pbz , sizeof pbz ) jobHealFileS( tinBaseP , etThread , cnu , *(paramHealFileS*)0 , 0 , 0 , 0 ) ;
            byteT pbz[ sizeof( jobHealFileS ) ] ;
            ZE( countT , cnu ) ;
        {
        while( cWorkersHeal )

        FIREmYSELF              // THIS IS TO ENSURE THAT ether IS IMPOTENT

        }
            }
                }
                    ;
                        : 1 + ( ++ idPhase - 1 ) % CpHASES
                        ? IDpHASE_GETnAMESoNLY
                    idPhase = bNamesAreStale
                {
                else
                if( ether ) break ;

                }
                    }
                        }
                            }
                                break ;
                                }
                                    }
                                        ether.traceF( tinBaseP , T("fired  base operating system (hibernate)") ) ;
                                        ether.osSuspendF( tinBaseP ) ;
                                        ether.traceF( tinBaseP , T("firing base operating system (hibernate)") ) ;
                                    {
                                    else if( F(flagsMode) & flHEALmODE_HIBERNATEoSwHENdONE )
                                         if( !bDo                                          ) etThread.traceF( tinBaseP , T("i will not hibernate because the heal phase took less than 2 ticks") ) ;

                                    boolT bDo = timeE2 || timeE1 >> 0x19 ;                          // HIBERNATE ONLY IF THIS PHASE HAS TAKEN MORE THAN 2 TICKS
                                {                                                                   // A:ASSUME: I WILL COMPLETE WITHIN 2 TICKS IF THERE IS NO HEALING TO BE DONE ; (REQUIREMENT: DO NOT HIBERNATE IF THE ARCHIVE HAS BEEN RECENTLY HEALED)
                                if( F(flagsMode) & flHEALmODE_HIBERNATEoSwHENdONE && !ether )
                                time2lATHhEALINGaOK = timeN2 ;
                                time1lATHhEALINGaOK = timeN1 ;
                            {
                            case IDpHASE_HEAL :
                            }
                                break ;
                                }
                                    bNamesAreStale = 1 ;
                                {
                                if( cNewChunks )
                            {
                            case IDpHASE_CHUNKfILESbYdAY :
                        {
                        switch( idPhase )

                        etThread.traceF( tinBaseP , T("phase ended aok [time]:    ")+TT(time1AOK,time2AOK) ) ;
                        time2AOK = timeN2 ;
                        time1AOK = timeN1 ;
                        idPhaseLathAOK = idPhase ;

                        cConsecutiveAborts = 0 ;

                        // IDpHASE_ZAPfILEaTTRIBUTES IS OMITTED BECAUSE THAT PHASE IS DONE WITHIN THE CURRENT LOOP ; 20240718@1228: HUH?
                    {
                    else
                    }
                        }
                            etThread.osFireF( tinBaseP ) ;
                            etThread.traceF( tinBaseP , T("too many consecutive aborts, so firing (restarting) os") ) ;
                            FIREmYSELF
                        {
                        if( ++ cConsecutiveAborts == 8 )

                        time2AOK = time1AOK = 0 ;      // THIS WILL CAUSE THE NEXT ITERATION TO PROCEED AFTER ONLY NAPPING WO TICK
                        etThread.traceF( tinBaseP , T("this phase was aborted") ) ;
                        // /*if( cYearsInParallelHeal > 1 && 1 == decv02AM( cYearsInParallelHeal ) )*/ cYearsInParallelHeal = 1 ;  // REDUCE cYearsInParallelHeal BUT NOT BELOW 1
                        //20230106@1137: NAWWH; ABORT IS NOW DONE ROUTINELY BY PAUSE/RESUME, SO DOES NOT IMPLY FAILURE
                        //20221229@1435: IF ABORT THEN ON NEXT ITERATION PROCESS YEARS SERIALLY
                        //CS:DUPLICATEcODE 51000806 51000806
                    {
                    if( bAbort )

                    }
                        }
                            ++ s ; thirdC::dosSleepWinkIF( tinBaseP , 0 ) ;

                            }
                                funJobFileInfo.writeF( tinBaseP , pbz ) ;
                                new( 0 , tinBaseP , pbz , sizeof pbz ) jobFileInfoS( tinBaseP , etThread , T("") , pnu ) ;
                                byteT pbz[ sizeof( jobFileInfoS ) ] ;
                                ZE( infoFileS* , pnu ) ;
                            {
                            while( cDo -- )
                            countT cDo = cWorkersFileInfo ;
                        {
                        while( cWorkersFileInfo )
                        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

                        bQuitFileInfo = 1 ;
                    {

                    etThread.osTimeSubtractF( tinBaseP , timeE1 , timeE2 , timeA1 , timeA2 ) ;

                    sCountT timeN2 = timeE2 ;
                    countT  timeN1 = timeE1 ;
                    etThread.osTimeNowF( tinBaseP , timeE1 , timeE2 ) ;
                    ZE( sCountT , timeE2 ) ;
                    ZE( countT  , timeE1 ) ;

                    }
                        }
                            }
                                }
                                    if( cExecutiveHealYearPaused ) { BLAMMO ; }

                                    THREADmODE2rESTORE
                                    }
                                        thirdC::dosSleepWinkIF( tinBaseP ) ;
                                        //etThread.traceF( tinBaseP , T("waiting for all exec to die [cExecutiveHealYear]:    ")+TF2(cExecutiveHealYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    {
                                    while( cExecutiveHealYear )
                                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                                    _IO_
                                {

                                }
                                    while( !bAbort && ~hStYearToHeal ) ;
                                    }
                                        }
                                            }
                                                }
                                                    break ;
                                                    bAbort = 1 ;
                                                    etThread.traceF( tinBaseP , T("!exception: could not launch thread tmExecutiveHealYearF") ) ;
                                                    dec02AM( cExecutiveHealYear ) ;
                                                    POOPRqUIET
                                                {
                                                if( POOP )
                                                //U::((tinNormalS&)tinBaseP).pEtScratch->osThreadF( TaRG3fLAGScBtLS( tmExecutiveHealYearF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cPause , (countT)&funJobHealFile , (countT)&stJobCompare , (countT)&funJobFileInfo , (countT)&cYearsHealing , flagsMode , (countT)&cExecutiveHealYear , (countT)&cExecutiveHealYearPaused , (countT)&tUnique , (countT)psttYear , (countT)&psttzlArchive , (countT)&swsPathToArchivesByArchiveName , (countT)&bAbort , (countT)&psttzlArchiveSlashYear , (countT)&swJotSortedShortByArchiveYear , (countT)&swIdPhaseDoneAOKLath , (countT)&cPathsToYearHealing , idPhase , (countT)&grabLathFileHealedFiles , (countT)&grabDisk , (countT)&cNewChunks ) ;
                                                     ((tinNormalS&)tinBaseP).pEtScratch->osThreadF( TaRG1(           tmExecutiveHealYearF                                                     ) , (countT)&cPause , (countT)&funJobHealFile , (countT)&stJobCompare , (countT)&funJobFileInfo , (countT)&cYearsHealing , flagsMode , (countT)&cExecutiveHealYear , (countT)&cExecutiveHealYearPaused , (countT)&tUnique , (countT)psttYear , (countT)&psttzlArchive , (countT)&swsPathToArchivesByArchiveName , (countT)&bAbort , (countT)&psttzlArchiveSlashYear , (countT)&swJotSortedShortByArchiveYear , (countT)&swIdPhaseDoneAOKLath , (countT)&cPathsToYearHealing , idPhase , (countT)&grabLathFileHealedFiles , (countT)&grabDisk , (countT)&cNewChunks ) ;
                                                SCOOPS
                                                _IO_
                                            {
                                            IFsCRATCH
                                            inc02AM( cExecutiveHealYear ) ;

                                            etThread.strMakeF( tinBaseP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                                            ZE( strokeS* , psttYear ) ;

                                            //etThread.traceF( tinBaseP , T("year to heal:    ")+T(psttzYear) ) ;
                                            strokeS* psttzYear = (strokeS*)stYearToHeal.upF( tinBaseP , hStYearToHeal ) ;       //PROCESSES YEARS BEGINNING WITH MOST RECENT  (A:ASSUME: CURRENT YEARS ARE IN MOST NEED OF HEALING SINCE FILES ARE ADDED AND MODIFIED)
                                        {
                                        if( !bAbort )

                                        }
                                            THREADmODE2rESTORE
                                            }
                                                thirdC::dosPriorityIF( tinBaseP ) ; //U:: TO FIND A BUG
                                                thirdC::dosSleepWinkIF( tinBaseP ) ;
                                                thirdC::dosPriorityIF( tinBaseP ) ; //U:: TO FIND A BUG
                                                _IO_
                                            {
                                            while( test == cExecutiveHealYear )
                                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                                            ;
                                                    : cYearsInParallelHeal
                                                    ? CyEARSiNpARALLELcHUNKfILESbYdAY
                                                : idPhase == IDpHASE_CHUNKfILESbYdAY
                                                ? CyEARSiNpARALLELgETnAMESoNLY
                                            countT test = idPhase == IDpHASE_GETnAMESoNLY                     // IDpHASE_ZAPfILEaTTRIBUTES IS OMITTED BECAUSE tmExecutiveHealYearF IS NOT USED DURING THAT PHASE

                                            thirdC::dosPriorityIF( tinBaseP ) ; //U:: TO FIND A BUG

                                            _IO_
                                        {
                                        _IO_
                                    {
                                    do
                                    handleC hStYearToHeal( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    _IO_
                                {
                                if( !bAbort && stYearToHeal )

                                }
                                    }
                                        }
                                            }
                                                }
                                                    break ;
                                                    bAbort = 1 ;
                                                    etThread.delF( tinBaseP , psttYear ) ;
                                                    etThread.traceF( tinBaseP , T("!exception: duplicate year [psttYear]:    ")+T(psttYear) ) ;                        
                                                {
                                                if( !idSlot ) //SHOULD BE IMPOSSIBLE
                                                stYearToHeal.sinkF( tinBaseP , idSlot , psttYear , flSTACKsINK_UNIQUE ) ;
                                                ZE( countT , idSlot ) ;
                                                etThread.strMakeF( tinBaseP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                                                ZE( strokeS* , psttYear ) ;
                                                _IO_
                                            {
                                            if( !bIgnore && tally > 1 )
                                            countT tally = swTallyByYear ;

                                            //#endif
                                                ZE( boolT , bIgnore ) ;
                                            //#else
                                            //    ;
                                            //
                                            //          || !etThread.strCompareF( tinBaseP , psttzYear , T("2099") )
                                            //          || !etThread.strCompareF( tinBaseP , psttzYear , T("2023") )
                                            //          || !etThread.strCompareF( tinBaseP , psttzYear , T("2022") )
                                            //          || !etThread.strCompareF( tinBaseP , psttzYear , T("2021") )
                                            //          || !etThread.strCompareF( tinBaseP , psttzYear , T("2020") )
                                            //          || !etThread.strCompareF( tinBaseP , psttzYear , T("2019") )
                                            //          || !etThread.strCompareF( tinBaseP , psttzYear , T("2018") )
                                            //          || !etThread.strCompareF( tinBaseP , psttzYear , T("2017") )
                                            //          || !etThread.strCompareF( tinBaseP , psttzYear , T("2016") )
                                            //          || !etThread.strCompareF( tinBaseP , psttzYear , T("2015") )
                                            //          || !etThread.strCompareF( tinBaseP , psttzYear , T("2014") )
                                            //          || !etThread.strCompareF( tinBaseP , psttzYear , T("2013") )
                                            //             !etThread.strCompareF( tinBaseP , psttzYear , T("2012") )
                                            //
                                            //    boolT bIgnore = 
                                            //#if defined( IFC tESTING )

                                            psttzYear = (strokeS*)swTallyByYear.leverF( tinBaseP , idf ) ;
                                            _IO_
                                        {
                                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                        countT cFlavors = swTallyByYear.cFlavorsF( tinBaseP ) ;
                                        _IO_
                                    {
                                    if( !bAbort )

                                    while( ~hSwsPathToArchives ) ;
                                    }
                                        etThread.delF( tinBaseP , pstt1PathToYear ) ;
                                        }
                                            //etThread.traceF( tinBaseP , T("[tYear,tally]:    ")+tYear+tb4+TF2((countT)swTallyByYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            swTallyByYear ++ ;
                                            psttzYear = tYear ;

                                            }
                                                etThread.delF( tinBaseP , psttYear ) ;
                                                tYear = T(psttYear) ;
                                                etThread.strWordF( tinBaseP , psttYear , psttc1 , sttq , sttSlash , - 2 ) ; ___( psttYear ) ;
                                                ZE( strokeS* , psttYear ) ;
                                            {
                                            TN( tYear , "" ) ;
                                            _IO_
                                        {
                                        FORsTRINGSiN1( pstt1PathToYear )
                                        etThread.strConvertToLowerCaseF( tinBaseP , pstt1PathToYear ) ;
                                        }
                                            }
                                                break ;
                                                bAbort = 1 ;
                                                etThread.delF( tinBaseP , pstt1PathToYear ) ;
                                                etThread.traceF( tinBaseP , T("!exception: diskFindFileOrDirF failed [tPathToArchive]:    ")+tPathToArchive ) ;
                                                POOPRqUIET
                                            {
                                            if( POOP )
                                            ((tinNormalS&)tinBaseP).pEtScratch->diskFindFileOrDirF( tinBaseP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                                            SCOOPS
                                            _IO_
                                        {
                                        IFsCRATCH
                                        patternC pat( tinBaseP , etThread , tYearPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                                        ZE( strokeS* , pstt1PathToYear ) ;

                                        //etThread.traceF( tinBaseP , T("[tPathToArchive]:    ")+tPathToArchive ) ;
                                        TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzlArchive)+tSlash ;
                                        strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveName.downF( tinBaseP , hSwsPathToArchives ) ;
                                        _IO_
                                    {
                                    do
                                    handleC hSwsPathToArchives( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    strokeS sttSlash( '/' ) ;
                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

                                    switchC swTallyByYear( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzYear ) ;
                                    ZE( strokeS* , psttzYear ) ;
                                    _IO_
                                {
                                stackC stYearToHeal( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

                                // FOR EACH YEAR FOLDER (ALL YEARS FOR THIS ARCHIVE NAME (EXAMPLE: ALL YEAR PATHS FOR EVERY YEAR FOR "wo.ideafarm"), LAUNCH A FILE RECORD COLLECTION THREAD
                                _IO_
                            {
                            if( cArchivesWithThisName > 1 )
                            //etThread.traceF( tinBaseP , T("[cArchivesWithThisName,archive]:    ")+TF2(cArchivesWithThisName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzlArchive) ) ;
                            swsPathToArchivesByArchiveName.ungrabF( tinBaseP ) ;
                            countT cArchivesWithThisName = swsPathToArchivesByArchiveName ;
                            psttzlArchive = (strokeS*)swsPathToArchivesByArchiveName.leverF( tinBaseP , idf ) ;
                            swsPathToArchivesByArchiveName.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                            _IO_
                        {
                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )    // FOR EACH ARCHIVE NAME (EXAMPLE: "wo.ideafarm")
                        swsPathToArchivesByArchiveName.ungrabF( tinBaseP ) ;
                        countT cFlavors = swsPathToArchivesByArchiveName.cFlavorsF( tinBaseP ) ;
                        swsPathToArchivesByArchiveName.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                        #endif
                            TN( tYearPattern , "?" "?" "?" "?" "/" ) ;                                                              //20221118@1747: "????/" PROUCES A SPURIOUS COMPILER ERROR INVOLVING TRIGRAPH
                        #else
                            //TN( tYearPattern , "2099/" ) ;          // THE YEAR WITH THE LARGEST FILE, ALSO WITH THE FILE OF SIZE 1,004,306,432
                            //TN( tYearPattern , "2019/" ) ;
                            //TN( tYearPattern , "2013/" ) ;          // 10,000,635 BYTE FILE
                            //TN( tYearPattern , "2014/" ) ;          // THE YEAR WITH THE MOST SHORT NAME VALUES
                            //TN( tYearPattern , "2023/" ) ;
                            //TN( tYearPattern , "2022/" ) ;
                            //TN( tYearPattern , "2017/" ) ;
                            //TN( tYearPattern , "2012/" ) ;
                            //TN( tYearPattern , "2010/" ) ;
                            //TN( tYearPattern , "2009/" ) ;
                            //TN( tYearPattern , "2008/" ) ;
                            //TN( tYearPattern , "1999/" ) ;
                              TN( tYearPattern , "1234/" ) ;
                        #if defined( IFCtESTING )
                        _IO_
                    {
                    if( !bAbort )

                    }
                        etThread.delF( tinBaseP , psttu ) ;
                        tUnique = T(psttu) ;
                        etThread.strUniqueF( tinBaseP , psttu ) ; ___( psttu ) ;
                        ZE( strokeS* , psttu ) ;
                    {
                    TN( tUnique , "" ) ;

                    }
                        }
                            etThread.osThreadF( TaRG3fLAGScBtLS( tmWorkerFileInfoF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&bQuitFileInfo , (countT)&cWorkersFileInfo , (countT)&bAbort , (countT)&idPhase , (countT)&cPause , (countT)&funJobFileInfo , flagsMode ) ;
                            inc02AM( cWorkersFileInfo ) ;
                        {
                        while( cDo -- )
                        countT cDo = cArchive >> 1 ;
                    {
                    ZE( countT , cWorkersFileInfo ) ;
                    ZE( boolT , bQuitFileInfo ) ;

                    etThread.osTimeNowF( tinBaseP , timeA1 , timeA2 ) ;
                    ZE( sCountT , timeA2 ) ;
                    ZE( countT  , timeA1 ) ;

                    _IO_
                {
                else
                }
                    idPhaseLathAOK = idPhase ;

                    }
                        THREADmODE2rESTORE
                        etThread.diskWalkF( tinBaseP , cDirs , cFiles , tmFlush , ether , flDISKwALK_null , walkNewFsetCBF , pcArg ) ;
                        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                        countT pcArg[] = { (countT)&etThread , (countT)&bAbort , (countT)&swsPathToArchivesByArchiveName , (countT)&psttzlArchive } ;
                        ZE( countT , cFiles ) ;
                        ZE( countT , cDirs ) ;

                        }
                            etThread.delF( tinBaseP , psttm22FlushToArchive ) ;
                            tmFlush = T(psttm22FlushToArchive) ;
                            etThread.diskMapFileNameF( tinBaseP , psttm22FlushToArchive , t22FlushToArchive ) ; ___( psttm22FlushToArchive ) ;
                            TN( t22FlushToArchive , "///ideafarm/IdeaFarm " "(tm)/" ) ; t22FlushToArchive += tUser+T("/2.2. Filesets Awaiting Flushing To An Archive/" ) ;
                            TN( tUser             , thirdC::postUserNameIF() ) ;
                            ZE( strokeS* , psttm22FlushToArchive ) ;
                        {
                        TN( tmFlush , "" ) ;
                        TN( tb4               , "    " ) ;

                        _IO_
                    {

                    etThread.traceF( tinBaseP , T("IDpHASE_ARCHIVEnEWfSETS") ) ;
                    etThread.traceF( tinBaseP , T("[idPhase]:     ")+TF2(idPhase,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( idPhase == IDpHASE_ARCHIVEnEWfSETS )
            {
            if( !ether )
            ZE( boolT , bNamesAreStale ) ;

            countT cArchive = loadArchivePathsF( tinBaseP , etThread , bAbort , swsPathToArchivesByArchiveName , psttzlArchive , stPathToArchives ) ;
            stackC         stPathToArchives( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
            switchStackC   swsPathToArchivesByArchiveName( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzlArchive , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
            ZE( strokeS* , psttzlArchive ) ;
            // LOAD swsPathToArchivesByArchiveName WITH VALUES LIKE "///c/ideafarm.arhives/" OR "///ideafarm/devices/mydevname/ideafarm.archives/" SWITCHED ON VALUES LIKE "wo.ideafarm"

            if( idPhase == IDpHASE_CHUNKfILESbYdAY ) cNewChunks = 0 ;

            }
                etThread.traceF( tinBaseP , T("napped") ) ;
                ++ s ; ether.osSleepF( tinBaseP , TICK >> 4 ) ;
                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                etThread.traceF( tinBaseP , T("napping for a minute") ) ;
            {
            else
            }
                etThread.traceF( tinBaseP , T("napped") ) ;
                ++ s ; ether.osSleepF( tinBaseP , TOCK ) ;
                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                etThread.traceF( tinBaseP , T("napping for a tock") ) ;
            {
            if( bSandbox )

            //etThread.traceF( tinBaseP , T("[idPhase]:    ")+TF2(idPhase,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            //    }
            //        }
            //            idPhase ++ ;
            //        {
            //        if( idIn == 1 )
            //        countT idIn = 1 + incv02AM( idInLath ) ;
            //        static countT idInLath ;
            //    {
            //    //if( idPhase == IDpHASE_CHUNKfILESbYdAY )
            //      if( idPhase == IDpHASE_GETnAMESoNLY    )
            //REMOVE IN PRODUCTION ; THESE ARE FOR TESTING ONLY TO TEST THE SCENARIO IN WHICH A REQUIRED PHASE IS NOT DONE DUE TO RACE SCENARIO WHEN FRESH BECOMES STALE
            //20240810@1455: PASSES THESE 2 TESTS

            // IDpHASE_HEAL
            // IDpHASE_CHUNKfILESbYdAY
            // IDpHASE_GETnAMESoNLY
            // IDpHASE_ARCHIVEnEWfSETS

            if( idPhase == IDpHASE_ARCHIVEnEWfSETS ) swIdPhaseDoneAOKLath.freeAllF( tinBaseP ) ;

            _IO_
        {                                   // BUT NOT ALL ITERATIONS ARE SUCCESSFUL ; THOSE THAT FAIL ARE RETRIED, AND THE PHASE ID IS NOT ADVANCED UNTIL THE CURRENT PHASE SUCCEEDS
        while( !ether && !POOP )            // EVERY 3 SUCCESSFUL ITERATIONS ARE [ PHASE1 , PHASE2 , PHASE3 ] ( 1: GET NAMES, 2: HEAL, 3: CHUNK FILES BY DAY ) ; THE PHASE ID DETERMINES WHAT tmExecutiveHealYearF DOES
        ZE( sCountT , time2lATHhEALINGaOK ) ;
        ZE( countT  , time1lATHhEALINGaOK ) ;

        switchC swIdPhaseDoneAOKLath(          tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzlArchiveSlashYear ) ;
        switchC swJotSortedShortByArchiveYear( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzlArchiveSlashYear ) ;
        ZE( strokeS* , psttzlArchiveSlashYear ) ;

        ZE( countT , cNewChunks ) ;
        ZE( countT , cConsecutiveAborts ) ;
        ZE( boolT , bPhase3ChunkByDay ) ;
        ZE( boolT , bPhase2Heal       ) ;
        ZE( countT  , idPhaseLathAOK ) ;
        ZE( sCountT , time2AOK ) ;
        ZE( countT  , time1AOK ) ;

        }
            etThread.traceF( tinBaseP , T("napped  for a minute to give devices some more time to come online") ) ;
            ++ s ; ether.osSleepF( tinBaseP , TICK >> 2 ) ;
            etThread.traceF( tinBaseP , T("napping for a minute to give devices some more time to come online") ) ;
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        {
        if( !bSandbox ) // NAP IF RUNNING AS SERVICE BUT NOT IF RUNNING FROM IdeaFarm (tm) Elves

        }
            etThread.osThreadF( TaRG3fLAGScBtLS( tmWorkerMemCompareF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM << 6 /*U::O: USE THE LEAST POSSIBLE CBtLS*/ ) , (countT)&cWorkersCompare , (countT)&bAbort , (countT)&idPhase , (countT)&cPause , (countT)&stJobCompare , flagsMode , (countT)&cYearsHealing ) ;
            inc02AM( cWorkersCompare ) ;
        {
        while( cDo    -- )
        cDo = cToHireCompare ;

        }
            etThread.osThreadF( TaRG3fLAGScBtLS( tmWorkerHealFileF   , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cWorkersHeal    , (countT)&bAbort , (countT)&idPhase , (countT)&cPause , (countT)&funJobHealFile , flagsMode , (countT)&cYearsHealing , cToHireHeal , cToHireCompare ) ;
            inc02AM( cWorkersHeal ) ;
        {
        while( cDo    -- )
        countT cDo = cToHireHeal ;

        ZE( countT , cWorkersHeal    ) ;
        ZE( countT , cWorkersCompare ) ;
        ZE( countT , cYearsHealing   ) ;

        countT idPhase = IDpHASE_ARCHIVEnEWfSETS ;

        // #endif
        //     //etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , cToHireHeal ) ;
        // #if defined( IFC tESTING )

        }
            etThread.traceF( tinBaseP , T("HEALaRCHIVES: [bKeepNames,bHibernateOs,bStrict,bNoImageCompare,bNoMoveOrReplace,bLonelyIsOk]:    ")+tb4+TF2(bKeepNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bHibernateOs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bStrict,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bNoImageCompare,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bNoMoveOrReplace,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bLonelyIsOk,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            boolT bLonelyIsOk       = !!( F(flagsMode) & flHEALmODE_LONELYiSoK          ) ;
            boolT bNoMoveOrReplace  = !!( F(flagsMode) & flHEALmODE_NOmOVEoRrEPLACE     ) ;
            boolT bNoImageCompare   = !!( F(flagsMode) & flHEALmODE_NOiMAGEcOMPARE      ) ;
            boolT bStrict           = !!( F(flagsMode) & flHEALmODE_STRICT              ) ;
            boolT bHibernateOs      = !!( F(flagsMode) & flHEALmODE_HIBERNATEoSwHENdONE ) ;
            boolT bKeepNames        = !!( F(flagsMode) & flHEALmODE_KEEPnAMES           ) ;
        {

        etThread.traceF( tinBaseP , T("HEALaRCHIVES: [cProcessors,cToHireHeal,cToHireCompare]:    ")+TF2(cProcessors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cToHireHeal,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cToHireCompare,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        //#endif
        //    flagsMode &= ~( F(flHEALmODE_HIBERNATEoSwHENdONE) ) ;
        //    *(countT*)&cToHireHeal = 0x1 ;
        //#if defined( IFC tESTING )

        ;
            : CtOhIREcOMPARE
            ? 0
        const countT cToHireCompare = F(flagsMode) & flHEALmODE_NOiMAGEcOMPARE

        ;
            : CtOhIREhEAL
            ? CtOhIREhEAL
        const countT cToHireHeal = F(flagsMode) & flHEALmODE_NOiMAGEcOMPARE

        //cToHireCompare = 4 ; //U:: FOR TESTING
        //cToHireCompare = 8 ; //U:: FOR TESTING
        //cToHireCompare = 1 ; //U:: FOR TESTING
        //countT cToHireCompare = cProcessors ;
        //countT cToHireCompare = cProcessors << 1 ;
        //countT cToHireCompare = cProcessors >> 1 ; // BEST BEFORE OPTIMIZATION
        //countT cToHireCompare = 1 ; // VERY SLOW
        //countT cToHireCompare = cProcessors << 3 ; //VERY SLOW
        //WORSE:cToHireHeal = cProcessors ; //FOR TESTING
        //countT cToHireHeal    = 1 /* cProcessors << 1 */ ;  //PRODUCTION:  ">> 1" "<< 0" TOO LITTLE JOB PUSHING ; \cToHireHeal == 1 SO THAT WO FILE IS HEALED AT A TIME ; THIS IS INTENDED TO MINIMIZE WASTAGE CAUSED BY FIRING HEALING ; WITH LARGE FILES IT SHOULD BE POSSIBLE TO KEEP CPU PEGGED WITH A SINGLE FILE AS INPUT

        const countT cProcessors = thirdC::osProcessorsIF( tinBaseP ) ;

        etThread.osThreadF( TaRG4fLAGScBsTACKcBtLS( tmReportF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBsTACKmIN << 1 , CBtLSmINIMUM ) , (countT)&grabLathFileHealedFiles , flagsMode ) ;

        }
            if( bLonelyIsOk ) flagsMode |= flHEALmODE_LONELYiSoK ;
            #endif
                bLonelyIsOk = 1 ;
            #if defined( OVERRIDElONELYiSoK )
            etThread.delF( tinBaseP , psttv ) ;
            boolT bLonelyIsOk = psttv && !etThread.strCompareF( tinBaseP , psttv , T("yes") ) ;
            ZE( strokeS* , psttv ) ; etThread.querySettingF( tinBaseP , psttv , T("!ipdos.heallonelyisok")  ) ; ___( psttv ) ;
        {

        }
            if( bNoMoveOrReplace ) flagsMode |= flHEALmODE_NOmOVEoRrEPLACE ;
            #endif
                bNoMoveOrReplace = 1 ;
            #if defined( OVERRIDEdOnOTmOVEoRrEPLACEfILES )
            etThread.delF( tinBaseP , psttv ) ;
            boolT bNoMoveOrReplace = psttv && !etThread.strCompareF( tinBaseP , psttv , T("no") ) ;
            ZE( strokeS* , psttv ) ; etThread.querySettingF( tinBaseP , psttv , T("!ipdos.healmoveorreplace")  ) ; ___( psttv ) ;
        {

        }
            if( bNoImageCompare ) flagsMode |= flHEALmODE_NOiMAGEcOMPARE ;
            #endif
                bNoImageCompare = 1 ;
            #if defined( OVERRIDEnOiMAGEcOMPARE )
            etThread.delF( tinBaseP , psttv ) ;
            boolT bNoImageCompare = psttv && !etThread.strCompareF( tinBaseP , psttv , T("no") ) ;
            ZE( strokeS* , psttv ) ; etThread.querySettingF( tinBaseP , psttv , T("!ipdos.healimagecompare")  ) ; ___( psttv ) ;
        {

        }
            if( bStrict ) flagsMode |= flHEALmODE_STRICT ;
            etThread.delF( tinBaseP , psttHealStrict ) ;
            boolT bStrict = psttHealStrict && !etThread.strCompareF( tinBaseP , psttHealStrict , T("yes") ) ;
            ZE( strokeS* , psttHealStrict ) ; etThread.querySettingF( tinBaseP , psttHealStrict , T("!ipdos.healstrict")  ) ; ___( psttHealStrict ) ;
        {

        }
            if( !bNoHibernateOs && !bSandbox ) flagsMode |= flHEALmODE_HIBERNATEoSwHENdONE ;
            #endif
                bNoHibernateOs = 1 ;
            #if defined( OVERRIDEnOhIBERNATEoS )
            etThread.delF( tinBaseP , psttHealHibernateOs ) ;
            boolT bNoHibernateOs = psttHealHibernateOs && etThread.strCompareF( tinBaseP , psttHealHibernateOs , T("no") ) ;
            ZE( strokeS* , psttHealHibernateOs ) ; etThread.querySettingF( tinBaseP , psttHealHibernateOs , T("!ipdos.healhibernateos")  ) ; ___( psttHealHibernateOs ) ;
        {

        }
            if( bKeepNames ) flagsMode |= flHEALmODE_KEEPnAMES ;
            #endif
                bKeepNames = 1 ;
            #if defined( OVERRIDEkEEPnAMES )
            etThread.delF( tinBaseP , psttHealKeepNames ) ;
            boolT bKeepNames = psttHealKeepNames && !etThread.strCompareF( tinBaseP , psttHealKeepNames , T("yes") ) ;
            ZE( strokeS* , psttHealKeepNames ) ; etThread.querySettingF( tinBaseP , psttHealKeepNames , T("!ipdos.healkeepnames")  ) ; ___( psttHealKeepNames ) ;
        {

        flagsT flagsMode = flHEALmODE_null ;

        funnelHornC funJobFileInfo( tinBaseP , etThread , countTC() , sizeof( jobFileInfoS ) , FUNNELhORNcAPACITY ) ;
        stackC      stJobCompare(  tinBaseP , etThread , TAG( TAGiDnULL ) ) ;                                                       //U::MIGRATE FROM THIS TO USE A funnelHornC INSTANCE
        funnelHornC funJobHealFile( tinBaseP , etThread , countTC() , sizeof( jobHealFileS ) , FUNNELhORNcAPACITY ) ;

        etThread.osThreadF( TaRG4fLAGScBsTACKcBtLS( tmObeyPauseSemaphoreFileF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBsTACKmIN << 1 , CBtLSmINIMUM ) , (countT)&bAbort , (countT)&cPause , (countT)&cExecutiveHealYear , (countT)&cExecutiveHealYearPaused ) ;
        ZE( countT , cPathsToYearHealing      ) ;
        ZE( countT , cExecutiveHealYearPaused ) ;
        ZE( countT , cExecutiveHealYear       ) ;
        ZE( countT , cPause                   ) ;
        ZE( boolT  , bAbort                   ) ;

        boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;

        grabC grabDisk(                tinBaseP , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS ) ;
        grabC grabLathFileHealedFiles( tinBaseP , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS ) ;

        TN( tSlash , "/" ) ;
        TN( tb4    , "    " ) ;
        _IO_
    {
{
if( pTaskP )
TASK( tmWorkF )

DONE( tmReportF )
}
    }
        ++ s ; ether.osSleepF( tinBaseP , TICK >> 6 ) ;     //MUST BE SHORT ENOUGH TO AVOID OVERFLOW IN COUNTER

        }
            }
                etThread.boxPutF( tinBaseP , tFileReport , tReport , tReport.csF( tinBaseP ) ) ;
                tReport += tcrlf+tcrlf+tcrlf+T("(end of report)\r\n") ;
            {
            if( !ether )

            }
                while( !ether && ~hFindFile && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        }
                            etThread.delF( tinBaseP , posti ) ;
                            }
                                }
                                    }
                                        }
                                            postc = postHitEnd + 2 ; // SKIPS CRLF
                                            tReport += T(postHit)+tcrlf ;
                                            *postHitEnd = 0 ;
                                        {
                                        else if( !ether )
                                        if( !postHitEnd ) break ;
                                        osTextT* postHitEnd = thirdC::c_strstrIF( tinBaseP , postHit , "\r\n" ) ;
                                    {
                                    else if( !ether )
                                    if( !postHit ) break ;
                                    osTextT* postHit = thirdC::c_strstrIF( tinBaseP , postc , "!exception" ) ;

                                {
                                while( !ether && postc < poste )

                                postc = posti ;

                                }
                                    postc ++ ;
                                    if( !*postc ) *postc = 0xff ;
                                {
                                while( postc < poste )  // SMUDGE NULL CHAR (THESE FILES ARE BINARY FILES) SO CAN USE STRING HANDLING

                                osTextT* poste = posti + costi ;
                                osTextT* postc = posti ;
                            {
                            else if( !ether )
                            if( !posti ) etThread.traceF( tinBaseP , T("null length file:    ")+tShort ) ;

                            etThread.boxGetShadowF( tinBaseP , posti , costi , tFolder+tShort ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;
                        {
                        if( !ether && tShort.csF( tinBaseP ) )        // IF NOT A DIRECTORY

                        }
                            etThread.delF( tinBaseP , psttShort ) ;
                            etThread.delF( tinBaseP , psttFolder ) ;
                            tShort  = T(psttShort) ;
                            tFolder = T(psttFolder) ;
                            etThread.strBisectF( tinBaseP , psttFolder , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttFolder ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttFolder ) ;
                        {
                        TN( tShort , "" ) ;
                        TN( tFolder , "" ) ;
                    {
                    else if( !ether )
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( !pInfoFile || !pInfoFile->psttIfoName )

                    etThread.diskFindFileOrDirF( tinBaseP , pInfoFile , hFindFile , tTraceFolder , &pat2 ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                handleC hFindFile( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                tReport += tcrlf+tcrlf+T("exceptions\r\n\r\n") ;
            {
            if( !ether )

            THREADmODE2rESTORE
            grabLathFileHealedFilesP.ungrabF( tinBaseP ) ;
            }
                while( !ether && ~hFindFile && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        }
                            etThread.delF( tinBaseP , posti ) ;

                            }
                                etThread.delF( tinBaseP , psttYear ) ;
                                tReport += T(psttYear)+tb4+TF2(*(countT*)posti,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcrlf ;

                                etThread.strSubstringF( tinBaseP , psttYear , idf , idl , tShort ) ; ___( psttYear ) ;
                                countT idl = 0x17 ;
                                countT idf = 0x14 ;
                                ZE( strokeS* , psttYear ) ;
                            {
                            else if( !ether )
                            }
                                etThread.traceF( tinBaseP , T("!exception: invalid file content [tShort]:    ")+tShort ) ;
                            {
                            if( !posti || costi != sizeof( countT ) )

                            etThread.boxGetShadowF( tinBaseP , posti , costi , tFolder+tShort ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;

                            //etThread.traceF( tinBaseP , tShort ) ;
                        {
                        if( !ether && tShort.csF( tinBaseP ) && !etThread.strIdF( tinBaseP , tDotHeyWritingDot , tShort ) )        // IF NOT A DIRECTORY

                        }
                            etThread.delF( tinBaseP , psttShort ) ;
                            etThread.delF( tinBaseP , psttFolder ) ;
                            tShort  = T(psttShort) ;
                            tFolder = T(psttFolder) ;
                            etThread.strBisectF( tinBaseP , psttFolder , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttFolder ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttFolder ) ;
                        {
                        TN( tShort , "" ) ;
                        TN( tFolder , "" ) ;
                    {
                    else if( !ether )
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( !pInfoFile || !pInfoFile->psttIfoName )

                    etThread.diskFindFileOrDirF( tinBaseP , pInfoFile , hFindFile , tStateFolder , &pat1 ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                handleC hFindFile( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {
            grabLathFileHealedFilesP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

            TN( tReport , "" ) ; tReport = T("IdeaFarm (tm) Archive Healer - Minute Report #")+TF2(++idReport,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n\r\n\r\nyear    lathIdNameHealed\r\n\r\n" ) ;
        {
        if( !ether && !( ++ idCycle % 4 ) )

        }
            }
                etThread.traceF( tinBaseP , T("compare bytes speed [elapsedTime,cbRecent,cTickPerTock]:    ")+TT(timeE1,timeE2)+tb4+TF3(cbWas,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF3(cTickPerTock,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+tBar , flTRACE_null , ifcIDtRACEdIVERT_1 ) ;

                TN( tBar , "" ) ; if( cTickPerTock ) tBar = TPS( "" , cTickPerTock , strokeS( '*' ) ) ;

                countT     cTickPerTock = !mTock ? - 1 : ( cbWas / mTock ) / TICK ;
                measure04T mTock        = mTime / TOCK                            ;
                measure04T mTime        = timeE1                                  ;

                etThread.osTimeSubtractF( tinBaseP , timeE1 , timeE2 , timeA1, timeA2 ) ;
                etThread.osTimeNowF( tinBaseP , timeE1 , timeE2 ) ;
                ZE( sCountT , timeE2 ) ;
                ZE( countT  , timeE1 ) ;
            {
            if( !ether && cbWas )

            etThread.osTimeNowF( tinBaseP , timeLathReset1 , timeLathReset2 ) ;

            }
                if( cbWas == setIfEqualsAM( cbNewlyCompared , 0 , cbWas ) ) break ;
                cbWas = cbNewlyCompared ;
            {
            while( !ether )
            timeLathReset2 = timeLathReset1 = 0 ;
            sCountT timeA2 = timeLathReset2 ;
            countT  timeA1 = timeLathReset1 ;
            ZE( countT , cbWas ) ;
        {
        if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )
    {
    while( !ether && !POOP )
    ZE( sCountT , timeLathReset2 ) ;
    ZE( countT  , timeLathReset1 ) ;
    ZE( countT , idReport ) ;
    ZE( countT , idCycle ) ;
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

    patternC pat2( tinBaseP , etThread , tPatternTraceFile           , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
    patternC pat1( tinBaseP , etThread , tPatternLathIdNameCompleted , ifcIDtYPEpATTERN_LITERAL               ) ;
    TN( tFileReport  , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/rpt.minute.ttt" ) ;
    TN( tStateFolder , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/" ) ;
    TN( tDotHeyWritingDot , ".!writing." ) ;

    TN( tTraceFolder , "" ) ; tTraceFolder = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/")+tUser+T("/00000100/stateSpaces/ffffefff/") ;

    TN( tUser , thirdC::postUserNameIF() ) ;

    TN( tPatternTraceFile , "bksTrace.booksC.*" ) ;

    ;

        +S2(sa_SSSaNDeND,sc_ccSSS)
        +T(".lath.idName.completed.ttt")
        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("12")
        +S2(sa_SSSoR,sc_ccSSS)
        +T("status.wo.ideafarm.")
        +S2(sa_SSSaND,sc_ccSSS)
        T("")

    TN( tPatternLathIdNameCompleted , "" ) ; tPatternLathIdNameCompleted =

    // "status.wo.ideafarm.yyyy.lath.idName.completed.ttt"
    //  123456789abcdef0123456789abcdef0123456789abcdef0
    //  0              1               2               3

    TN( tcrlf , "\r\n" ) ;
    TN( tb4   , "    " ) ;

    flagsT flagsModeP               =  (flagsT)pTaskP->c2 ;
    grabC& grabLathFileHealedFilesP = *(grabC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmReportF )

DONE( tmObeyPauseSemaphoreFileF )
}
    }
        }
            if( POOP ) POOPRqUIET
            ((tinNormalS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tFilePause , 1 ) ;
            SCOOPS
        {
        IFsCRATCH
        etThread.traceF( tinBaseP , T("deleting the pause semaphore file and decremented cPauseP [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        countT was = decv02AM( cPauseP ) ;
    {
    if( etThread.diskFileExistsF( tinBaseP , tFilePause ) )

    }
        ++ s ; ether.osSleepF( tinBaseP , TOCK ) ;

        bFileExistsLag = bFileExists ;

        }
            }
                if( POOP ) POOPRqUIET
                ((tinNormalS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tFilePaused , 1 ) ;
                SCOOPS
            {
            IFsCRATCH
        {
        else if( !bFileExists && bFileExistsLag )
        }
            etThread.boxPutF( tinBaseP , tFilePaused , tSay , tSay.csF( tinBaseP ) + 1 ) ;
            TN( tSay , "If this file exists then IdeaFarm (tm) Archive Heal is paused due to a user request (a pause semaphore file)." ) ;
        {
        if( bFileExists && !bFileExistsLag && cExecutiveHealYearPausedP == cExecutiveHealYearP )

        }
            }
                etThread.traceF( tinBaseP , T("decremented cPause on request [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                countT was = decv02AM( cPauseP ) ;
                bFileExists = 0 ;
            {
            if( bFileExists )
        {
        else
        }
            }
                etThread.traceF( tinBaseP , T("incremented cPause on request [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                countT was = incv02AM( cPauseP ) ;
                bFileExists = 1 ;
            {
            if( !bFileExists )
        {
        if( etThread.diskFileExistsF( tinBaseP , tFilePause ) )
    {
    while( !ether )
    ZE( boolT  , bFileExistsLag ) ;
    ZE( boolT  , bFileExists ) ;

    }
        if( POOP ) POOPRqUIET
        ((tinNormalS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tFilePause , 1 ) ;

        if( POOP ) POOPRqUIET
        ((tinNormalS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tFilePaused , 1 ) ;

        SCOOPS
    {
    IFsCRATCH

    etThread.diskMakeDirIfNeededF( tinBaseP , tFilePause ) ;
    TN( tFilePaused , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/control/paused" ) ;
    TN( tFilePause  , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/control/pause"  ) ;
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

    countT& cExecutiveHealYearPausedP = *(countT*)pTaskP->c4 ;
    countT& cExecutiveHealYearP       = *(countT*)pTaskP->c3 ;
    countT& cPauseP                   = *(countT*)pTaskP->c2 ;
    boolT&  bAbortP                   =  *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmObeyPauseSemaphoreFileF )

DONE( tmExecutiveHealYearF )
}
    // #endif
    //     //etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
    // #if defined( IFC tESTING )

    dec02AM( cExecutiveHealYearP ) ;
    }
        }
            etThread.traceF( tinBaseP , T("done for archive [idPhase,bAbort,archive,year]:    ")+TF2(idPhaseP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bAbortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzlArchiveP)+tb4+tYear ) ;

            etThread.delF( tinBaseP , *(countT**)&ppsttPathToYear ) ;
            }
                etThread.delF( tinBaseP , ppsttPathToYear[ offi ] ) ;
            {
            for( countT offi = 0 ; offi < cPathsToYear ; offi ++ )

            DEL( pJotSortedShort ) ;
            }
                }
                    }
                        }
                            break ;

                            idPhaseLathAOK = idPhaseP ;
                            etThread.traceF( tinBaseP , T("phase HEAL completed aok [idPhaseLathAOK,archive/year]:    ")+TF2(idPhaseLathAOK,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tArchiveSlashYear ) ;
                            countT& idPhaseLathAOK = swIdPhaseDoneAOKLathP ;
                            psttzlArchiveSlashYearP = tArchiveSlashYear ;

                            grabLathFileHealedFilesP.ungrabF( tinBaseP ) ;
                            THREADmODE2rESTORE
                            }
                                if( POOP ) POOPRqUIET
                                ((tinNormalS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tLong , 1 ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                            grabLathFileHealedFilesP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                            //etThread.traceF( tinBaseP , T("deleting [file]:    ")+tLong ) ;
                            tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".lath.idName.completed.ttt") ;

                            etThread.boxPutF( tinBaseP , tLong , tBody , tBody.csF( tinBaseP ) ) ;
                            TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".completed.ttt") ;

                            TN( tBody , "" ) ; tBody = TT(time1N,time2N) + T("\r\nIPDOS (tm) Archive Healer\r\nDelete this file to cause Healer to not wait to heal this year.\r\n") ;
                            etThread.osTimeNowF( tinBaseP , time1N , time2N ) ;
                            ZE( sCountT , time2N ) ;
                            ZE( countT  , time1N ) ;

                            DEL( pJotSortedShort ) ;

                            if( pJotSortedShort && !( F(flagsModeP) & flHEALmODE_KEEPnAMES ) ) pJotSortedShort->flagsCtRefF() |= flJOTc_PATCHbOOKSfLAGStOpURGEoNdT ;
                            _IO_
                        {
                        case IDpHASE_HEAL :
                        }
                            break ;

                            idPhaseLathAOK = idPhaseP ;
                            etThread.traceF( tinBaseP , T("phase CHUNKfILESbYdAY completed aok [idPhaseLathAOK,archive/year]:    ")+TF2(idPhaseLathAOK,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tArchiveSlashYear ) ;
                            countT& idPhaseLathAOK = swIdPhaseDoneAOKLathP ;
                            psttzlArchiveSlashYearP = tArchiveSlashYear ;

                            if( cNewChunksP && pJotSortedShort ) pJotSortedShort->flagsCtRefF() |= flJOTc_PATCHbOOKSfLAGStOpURGEoNdT ;
                        {
                        case IDpHASE_CHUNKfILESbYdAY :
                        }
                            break ;

                            idPhaseLathAOK = idPhaseP ;
                            etThread.traceF( tinBaseP , T("phase GETnAMESoNLY completed aok [idPhaseLathAOK,archive/year]:    ")+TF2(idPhaseLathAOK,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tArchiveSlashYear ) ;
                            countT& idPhaseLathAOK = swIdPhaseDoneAOKLathP ;
                            psttzlArchiveSlashYearP = tArchiveSlashYear ;
                        {
                        case IDpHASE_GETnAMESoNLY :
                        case IDpHASE_ARCHIVEnEWfSETS : { BLAMMOiD( idPhaseP ) ; break ; }
                    {
                    switch( idPhaseP )
                {
                if( !bAbortP )

                }
                    }
                        break ;

                        }
                            while( cDo -- ) dec02AM( cPathsToYearHealingP ) ;
                            countT cDo = cPathsToYear ;
                        {

                        }
                            bFireCheckpointUpdate = 1 ;

                            st_pzJobHealFileDone.ungrabF( tinBaseP ) ;
                            }
                                funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
                                DELzOMBIE( pzJob ) ;
                                jobHealFileS* pzDoomed = pzJob ;
                                st_pzJobHealFileDone >> *(countT*)&pzJob ;
                                ZE( jobHealFileS* , pzJob ) ;
                            {
                            while( st_pzJobHealFileDone )        //THIS MIGHT HAPPEN DUE TO RACE CONDITION, BUT IT (UPDATING THE "LATH FILE HEALED" FILE) DOESN'T MATTER 'CAUSE WE'RE DONE
                            st_pzJobHealFileDone.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                            if( bWorking ) dec02AM( cYearsHealingP ) ;

                            }
                                }
                                    }
                                        funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
                                        DELzOMBIE( pzJob ) ;
                                        jobHealFileS* pzDoomed = pzJob ;

                                        if( !pzJob ) break ;
                                        jobHealFileS* pzJob = (jobHealFileS*)funJobHealFileP.readF( tinBaseP , flFUNNELhORNcrEAD_NOwAIT ) ;
                                    {
                                    for(;;)
                                {
                                if( ether )

                                ++ s ; thirdC::dosSleepWinkIF( tinBaseP , 0 ) ;

                                //etThread.traceF( tinBaseP , T("waiting for pending heal jobs [cJobsPendingHeal,stDone]:    ")+TF2(cJobsPendingHeal,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(st_pzJobHealFileDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4 ) ;

                                _IO_
                            {
                            while( cJobsPendingHeal - st_pzJobHealFileDone )
                            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

                            etThread.delF( tinBaseP , pcArraySortedBySize ) ;
                            }
                                }
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //****                                        ***********************************************************************************************************************************************************************************************************************************
                                    //****  H E A L   W O   N A M E   ( E N D )   ***********************************************************************************************************************************************************************************************************************************
                                    //****                                        ***********************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************

                                    ///*if( !( idName % TUCK ) )*/ etThread.traceF( tinBaseP , T("---- [tYear,idName]:    ")+tYear+tb4+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    etThread.delF( tinBaseP , psttShort ) ;
                                    }
                                        // #endif
                                        //     //etThread.traceF( tinBaseP , T("---- watch") ) ;
                                        //     //etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_UNWATCH ) ;
                                        // #if defined( IFC tESTING )

                                        }
                                            //etThread.traceF( tinBaseP , T("wrote   to funJobHealFileP [idName]:    ")+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            funJobHealFileP.writeF( tinBaseP , pbz ) ;
                                            //etThread.traceF( tinBaseP , T("writing to funJobHealFileP [idName]:    ")+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            new( 0 , tinBaseP , pbz , sizeof pbz ) jobHealFileS( tinBaseP , etThread , cJobsPendingHeal , infoYear , psttShort , idName , cShortNames ) ;
                                            byteT pbz[ sizeof( jobHealFileS ) ] ;
                                        {
                                        if( !ether && !bAbortP )

                                        // #endif
                                        //     //etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_WATCH ) ;
                                        //     //etThread.traceF( tinBaseP , T("++++ watch") ) ;
                                        // #if defined( IFC tESTING )

                                        //}
                                        //    etThread.traceF( tinBaseP , T("healing [archive,year,cShortNames,idName,perTuck,tShort]:    ")+tArchive+tb4+tYear+tb4+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tPerTuck+tb4+tShort ) ;
                                        //    countT perTuck = ( idName << 8 ) / cShortNames ;
                                        //{
                                        //if( !( idName % ( TUCK >> 0 ) ) )

                                        }
                                            inc02AM( cYearsHealingP ) ;
                                            bWorking = 1 ;
                                        {
                                        if( !bWorking )

                                        }
                                            break ;
                                            bAbortP = 1 ;
                                        {
                                        if( ether )

                                        //etThread.traceF( tinBaseP , T("sorted [idJotIn,psttShort]:    ")+TF2(idJotIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttShort) ) ;
                                        //etThread.traceF( tinBaseP , T("healing [archive,year,short]:    ")+tArchive+tb4+tYear+tb4+T(psttShort) ) ;
                                        //countT idJotIn = pJotSortedShort->idLathReadF() ;
                                        _IO_
                                    {
                                    else
                                    if( !psttShort->idAdam ) ether.traceF( tinBaseP , T("TODO / !exception: psttShort is null length so ignoring this page") ) ;

                                    //etThread.traceF( tinBaseP , T("[pbIn,cbIn]:    ")+T(psttShort)+tb4+TF2(psttShort->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    if( bAbortP ) break ;
                                    pauseIfF( tinBaseP , bAbortP , cExecutiveHealYearPausedP , cPauseP ) ;

                                    //etThread.traceF( tinBaseP , T("pushing [cbUsed[0],cbUsed[1],psttShort]:    ")+TF2(((countT*)&c4CbUsed)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((countT*)&c4CbUsed)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttShort) ) ;

                                    //}
                                    //    continue ;
                                    //    etThread.delF( tinBaseP , psttShort ) ;
                                    //{
                                    //if( etThread.strCompareF( tinBaseP , psttShort , T("!ideafarm.a.2.00000000.00000001.20990004.!.chunk.day.zip") ) )

                                    //etThread.traceF( tinBaseP , T("U:: [tShort]:    ")+T(psttShort) ) ;

                                    etThread.strMakeFromOsTextF( tinBaseP , psttShort , pbIn + sizeof( count04T ) ) ; ___( psttShort ) ;
                                    ZE( strokeS* , psttShort ) ;
                            
                                    c4CbUsed = *(count04T*)pbIn ;
                            
                                    const byteT* pbIn = pageIn ;
                                    pageC pageIn = (*pJotSortedShort)[ idJot ] ;
                            
                                    if( bAbortP ) break ;
                                    pauseIfF( tinBaseP , bAbortP , cExecutiveHealYearPausedP , cPauseP ) ;

                                    count04T c4CbUsed = *(count04T*)( pcElt + 1 ) ;
                                    countT   idJot    =              *pcElt       ;

                                    ///*if( !( idName % TUCK ) )*/ etThread.traceF( tinBaseP , T("++++ [tYear,idName]:    ")+tYear+tb4+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    if( ++ idName <= idNameSkipBeyond ) continue ;

                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //****                                            *******************************************************************************************************************************************************************************************************************************
                                    //****  H E A L   W O   N A M E   ( B E G I N )   *******************************************************************************************************************************************************************************************************************************
                                    //****                                            *******************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************
                                    //*******************************************************************************************************************************************************************************************************************************************************************************

                                    _IO_
                                {
                                //for( countT* pcElt = pce - ccElt         ; pcElt >= pcArraySortedBySize ; pcElt -= ccElt )            // LARGEST  FILES WOTH
                                  for( countT* pcElt = pcArraySortedBySize ; pcElt < pce                  ; pcElt += ccElt )            // SMALLEST FILES WOTH
                                
                                countT  cElt  = ccArraySortedBySize / ccElt ;
                                countT  ccElt = 3 ;
                                countT* pce   = pcArraySortedBySize + ccArraySortedBySize ;

                                const countT cMaxBacklog = infoYear.cProcessors << 2 ;
                                ZE( countT , idName ) ;
                            {

                            etThread.osThreadF( TaRG3fLAGScBtLS( tmUpdateYearCheckpointF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&bFireCheckpointUpdate , (countT)&st_pzJobHealFileDone , (countT)&funJobHealFileP , (countT)&idNameConsecutiveLathDone , (countT)&tArchive , (countT)&tYear ) ;
                            ZE( boolT , bFireCheckpointUpdate ) ;

                            countT idNameConsecutiveLathDone = idNameSkipBeyond ;
                            ZE( countT , cJobsPendingHeal ) ;
                            ZE( boolT , bWorking ) ;

                            paramHealFileS infoYear( tinBaseP , etThread , bAbortP , cPauseP , tYear , tArchive , tUniqueP , cExecutiveHealYearPausedP , stJobCompareP , funJobFileInfoP , cPathsToYear , cResultStructsNeeded , (const strokeS**)ppsttPathToYear , st_pzJobHealFileDone , funJobHealFileDone , grabDiskP ) ;
                            funnelHornC funJobHealFileDone( tinBaseP , etThread , countTC() , sizeof( jobHealFileS ) , FUNNELhORNcAPACITY ) ;
                            stackC st_pzJobHealFileDone( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_countT ) ;

                            }
                                //}
                                //    etThread.traceF( tinBaseP , T("out [cbUsed[0],cbUsed[1],tShort]:    ")+TF2(((countT*)&c4CbUsed)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((countT*)&c4CbUsed)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
                                //
                                //    TN( tShort , "" ) ; tShort = T(pbIn+sizeof(count04T)) ;
                                //
                                //    c4CbUsed = *(count04T*)pbIn ;
                                //
                                //    const byteT* pbIn = pageIn ;
                                //    pageC pageIn = (*pJotSortedShort)[ idJot ] ;
                                //
                                //    countT   idJot    = *( pco ++ ) ;
                                //    count04T c4CbUsed = *(count04T*)pco ; pco += 2 ; 
                                //{
                                //for( countT* pco = pcArraySortedBySize ; pco < pce ; )
                                //countT* pce = pcArraySortedBySize + ccArraySortedBySize ;

                                etThread.boxPutF( tinBaseP , tLongSortedBySize , (byteT*)pcArraySortedBySize , ccArraySortedBySize * sizeof( countT ) ) ;
                            
                                //etThread.traceF( tinBaseP , T("called  ifcSortaF") ) ;

                                //etThread.ifcSortaF( tinBaseP , bQuit , (byteT*)pcArraySortedBySize , ccArraySortedBySize * sizeof( countT ) , 0 , 0 , 3 * sizeof( countT ) , /*flSORTAc_NOwORKERS*/ flSORTAc_null ) ;
                                // ENABLING THIS LINE CAUSES NAMES TO BE PROCESSED IN ORDER OF SIZE ; DISABLING CAUSES NAMES TO BE PROCESSED IN ORDER OF NAME

                                //etThread.traceF( tinBaseP , T("calling ifcSortaF") ) ;
                                ZE( boolT , bQuit ) ;
                            
                                }
                                    }
                                        //etThread.traceF( tinBaseP , T("in  [cbUsed[0],cbUsed[1],tShort]:    ")+TF2(((countT*)&c4CbUsed)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((countT*)&c4CbUsed)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
                            
                                        }
                                            }
                                                *(count04T*)pcCursor = c4CbUsed ; pcCursor += 2 ;                           // BOTH OF THESE LINES SET THE SORT KEY VALUE, WHICH IS SIZE sizeof( countT ) * 3
                                                *( pcCursor ++ ) = pJotSortedShort->idLathReadF() & ~( NM_HIGH ) ;          //A:ASSUME: TEXT SORT VALUES ARE MONOTONIC INCREASING IN idJot VALUES (BECAUSE TEXT IN THE jotC FILESET WAS WRITTEN IN SORTED ORDER)
                            
                                                tShort = T(pbIn+sizeof(count04T)) ;
                                                c4CbUsed = *(count04T*)pbIn ;
                                            {
                                            else
                                            if( !pbIn ) ether.traceF( tinBaseP , T("!exception: could not obtain blob so ignoring this page") ) ;
                                            const byteT* pbIn = pageIn ;
                                            pageC pageIn = *pJotSortedShort ;
                                        {
                                        TN( tShort , "" ) ;
                                        ZE( count04T , c4CbUsed ) ;
                            
                                        _IO_
                                    {
                                    while( cDo -- )
                                    countT cDo = cShortNames ;
                                    countT* pcCursor = pcArraySortedBySize ;
                                    
                                    etThread.memSetF( tinBaseP , (byteT*)pcArraySortedBySize , ccArraySortedBySize * sizeof( countT ) ) ;
                                    etThread.newF( tinBaseP , LF , pcArraySortedBySize , ccArraySortedBySize ) ; ___( pcArraySortedBySize ) ;
                                    ccArraySortedBySize = cShortNames * 3 ;
                            
                                    etThread.traceF( tinBaseP , T("[cShortNames]:    ")+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                {
                            
                                TN( tb4 , "    " ) ;
                            
                                _IO_
                            {
                            if( !pcArraySortedBySize )

                            _IO_
                        {
                        if( cShortNames )

                        }
                            }
                                THREADmODE2rESTORE
                                }
                                    if( POOP ) POOPRqUIET
                                    ((tinNormalS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tLongSortedBySize , 1 ) ;
                                    SCOOPS
                                {
                                IFsCRATCH
                                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                                ccArraySortedBySize = 0 ;
                                etThread.delF( tinBaseP , pcArraySortedBySize ) ;
                                etThread.traceF( tinBaseP , T("invalid file image ; file will be deleted and regenerated [tLong]:    ")+tLongSortedBySize ) ;
                            {
                            else
                            }
                                ccArraySortedBySize = ccExpected ;
                            {
                            if( !( cbi % cbElt ) && cbi == ccExpected * sizeof( countT ) )
                            countT cbElt      = sizeof( countT ) * 3 ;
                            countT ccExpected = cShortNames      * 3 ;
                            etThread.boxGetShadowF( tinBaseP , *(byteT**)&pcArraySortedBySize , cbi , tLongSortedBySize ) ; ___( pcArraySortedBySize )
                            ZE( countT , cbi ) ;
                        {
                        if( etThread.diskFileExistsF( tinBaseP , tLongSortedBySize ) )
                        ZE( countT  , ccArraySortedBySize ) ;
                        ZE( countT* , pcArraySortedBySize ) ;

                        //etThread.traceF( tinBaseP , T("[archive,year,cShortNames]:    ")+tArchive+tb4+tYear+tb4+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        const countT cShortNames = pJotSortedShort->cElementsF() ;
                        pJotSortedShort->resetLathReadF() ;

                        }
                            ++ s ; ether.osSleepF( tinBaseP , ( TICK >> 4 ) ) ;     //GIVE OTHER NEWLY LAUNCHED YEAR THREADS SOME TIME TO ALSO ACCUMULATE INTO cPathsToYearHealingP BEFORE I PROCEED
                            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;               //THE IDEA HERE IS TO PREVENT AN EARLY YEAR THREAD FROM RACING AHEAD AND CALCULATING A HUGE FILE WINDOW SIZE FOR ITSELF JUST AHEAD OF OTHER NEWLY LAUNCHED YEAR THREADS

                            while( cDo -- ) inc02AM( cPathsToYearHealingP ) ;
                            countT cDo = cPathsToYear ;
                        {

                        _IO_
                    {
                    case IDpHASE_HEAL :
                    }
                        break ;

                             if( ether ) bAbortP = 1 ;
                        else if( tDayPrefix.csF( tinBaseP ) ) chunkDayIfF( tinBaseP , etThread , bAbortP , cNewChunksP , cPathsToYear , ppsttPathToYear , tDayPrefix ) ;
                             if( ether ) bAbortP = 1 ;

                        }
                            //break ; //U:: CHUNK ONLY WO DAY
                            //etThread.traceF( tinBaseP , T("[tDayPrefixNew,tShort]:    ")+tDayPrefixNew+tb4+tShort ) ;

                            }
                                tDayPrefix = tDayPrefixNew ;

                                }
                                    chunkDayIfF( tinBaseP , etThread , bAbortP , cNewChunksP , cPathsToYear , ppsttPathToYear , tDayPrefix ) ;
                                    etThread.traceF( tinBaseP , T("calling chunkDayIfF [prefix]:    ")+tDayPrefix ) ;
                                {
                                if( tDayPrefix.csF( tinBaseP ) && !etThread.strIdF( tinBaseP , tIgnore , tDayPrefix ) )
                            {
                            if( etThread.strCompareF( tinBaseP , tDayPrefix , tDayPrefixNew ) )

                            }
                                etThread.delF( tinBaseP , psttDayPrefix ) ;
                                tDayPrefixNew = T(psttDayPrefix) ;
                                etThread.strSubstringF( tinBaseP , psttDayPrefix , idf , sttq , sttAt , tShort , 0 ) ; ___( psttDayPrefix ) ;
                                countT idf = 1 ;
                                strokeS sttAt( '@' ) ;
                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                ZE( strokeS* , psttDayPrefix ) ;
                            {
                            TN( tDayPrefixNew , "" ) ;
                
                            }
                                }
                                    tShort = T(pbIn+sizeof(count04T)) ;
                                    c4CbUsed = *(count04T*)pbIn ;
                                {
                                else
                                if( !pbIn ) ether.traceF( tinBaseP , T("!exception: could not obtain blob so ignoring this page") ) ;
                                const byteT* pbIn = pageIn ;
                                pageC pageIn = *pJotSortedShort ;
                            {
                            TN( tShort , "" ) ;
                            ZE( count04T , c4CbUsed ) ;
                
                            _IO_
                        {
                        while( !ether && cDo -- && !bAbortP )
                        TN( tIgnore , ".!.chunk." ) ;
                        TN( tDayPrefix , "" ) ;
                        countT cDo = cShortNames ;

                        }
                            etThread.traceF( tinBaseP , T("[path list]:    ")+T(ppsttPathToYear[offi]) ) ;
                        {
                        for( countT offi = 0 ; offi < cPathsToYear ; offi ++ )
                        
                        etThread.traceF( tinBaseP , T("[archive,year,cShortNames]:    ")+tArchive+tb4+tYear+tb4+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        const countT cShortNames = pJotSortedShort->cElementsF() ;
                        pJotSortedShort->resetLathReadF() ;

                        TN( tb  , " " ) ;
                        TN( tb4 , "    " ) ;

                        // IOW, ALL FILES IN EACH FILESET ARE DATED ONLY WITH THE TIME MODIFIED VALUE OF THE DATA FILE
                        // THIS IS TO SUPPRESS DIFFERENCES IN META DATA ACROSS VOLUMES THAT ARE DUE TO ACCESSING OR DUE TO AD HOC DATA RECOVERY AND MIGRATION ACTIVITIES
                        //PS:PERSONALITY: I CLOBBER FILE TIME METADATA SO THAT TIME WRITTEN, ACCESSED, AND CREATED FOR EVERY FILE IN THE DAY CHUNK ARE ALL SMUDGED TO THE TIME WRITTEN VALUE OF THE MOST RECENT FILE
                    {
                    case IDpHASE_CHUNKfILESbYdAY :
                    case IDpHASE_GETnAMESoNLY    : {                        break ; }
                    case IDpHASE_ARCHIVEnEWfSETS : { BLAMMOiD( idPhaseP ) ; break ; }

                    // IDpHASE_ZAPfILEaTTRIBUTES IS OMITTED BECAUSE tmExecutiveHealYearF IS NOT USED DURING THAT PHASE ; 20240718@1252: CONJ: THIS IS OBSOLETE BECAUSE THERE IS NO LONGER SUCH A PHASE
                {
                if( !bAbortP && !POOP ) switch( idPhaseP )

                }
                    }
                        }
                            }
                                etThread.traceF( tinBaseP , T("decremented cPause after nap after exception [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                was = decv02AM( cPauseP ) ;
                                ++ s ; etThread.osSleepF( tinBaseP , TIMEpAUSEoNfAIL ) ;
                                etThread.traceF( tinBaseP , T("incremented cPause on exception [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                countT was = incv02AM( cPauseP ) ;
                            {
                            else
                            if( !cTries ) bAbortP = 1 ;
                        {
                        if( bAbortLocal )

                        }
                            etThread.delF( tinBaseP , psttName ) ;
                            //etThread.traceF( tinBaseP , T("sorted jotC fileset [archive,year,short]:    ")+tArchive+tb4+tYear+tb4+T(psttName) ) ;
                            sortF( tinBaseP , etThread , countTC() , pJotSortedShort , jotShortFileNames , psttName , T("healarchive.sorted.short.filenames.")+tArchive+tDot+tYear , CBdATAbOOKsHORTfILEnAMES , CiNDEXeNTRIESpERbOOKsHORTfILEnAMES , TUCK << 0 , flSORTERc_SILENTLYsUPPRESSdUPLICATES , flJOTc_null , cNamesEstimate , sizeof( count04T ) ) ;
                            ZE( strokeS* , psttName ) ;

                            countT cNamesEstimate = cNames ;    // ACCURATE IF I HAVE ELIMINATED ALL DUPLICATES
                            cTries = 0 ; // IF GET HERE THEN READING FILE NAMES DID NOT FAIL SO WILL BE DONE
                        {
                        if( !bAbortP && !bAbortLocal )

                        if( ether ) bAbortP = 1 ;

                        if( !bAbortP ) pauseIfF( tinBaseP , bAbortP , cExecutiveHealYearPausedP , cPauseP ) ;

                        etThread.delF( tinBaseP , *(byteT**)&pc4CbUsed  ) ;
                        etThread.delF( tinBaseP , *(byteT**)&ppsttShort ) ;
                        etThread.delF( tinBaseP , *(byteT**)&pphff      ) ;
                        etThread.delF( tinBaseP , *(byteT**)&ppif       ) ;
                        }
                            while( !ether && !bAbortP && !POOP && cPathsDone < cPathsToYear ) ;
                            }
                                //if( tShortToTest.csF( tinBaseP ) ) break ;

                                }
                                    if( !( ++ cNames % ( TUCK << 0 ) ) ) etThread.traceF( tinBaseP , T("wrote to unsorted [archive,year,idName,idJot,tShort]:    ")+tArchive+tb4+tYear+tb4+TF2(cNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
                                    countT idJot = jotShortFileNames.writeF( tinBaseP , (byteT*)&c4CbUsed , sizeof c4CbUsed , tShort , tShort.csF( tinBaseP ) + 1 ) ;
                                    etThread.delF( tinBaseP , ppsttShort[ offhMin ] ) ;
                                    etThread.traceF( tinBaseP , T("jotting [c4cbUsed,tShort]:    ")+TT(pczCbUsed[0],pczCbUsed[1])+tb4+tShort ) ;
                                    countT* pczCbUsed = (countT*)&c4CbUsed ;

                                    TN( tShort , ppsttShort[ offhMin ] ) ;
                                    count04T c4CbUsed = pc4CbUsed[ offhMin ] ;
                                {
                                if( offhMin != - 1 )
                                // WRITE THE MINIMUM SHORT NAME TO JOT AND THEN DELETE IT SO THAT THE NEXT NAME WILL BE LOADED ON THE NEXT ITERATION

                                }
                                    }
                                        else if(    !sgn ) etThread.delF( tinBaseP , ppsttShort[ offh ] ) ;
                                             if( 0 > sgn ) { offhMin = offh /*; etThread.traceF( tinBaseP , T("updated offhMin") )*/ ; }

                                        sCountT sgn = offhMin == - 1 ? - 1 : etThread.strCompareF( tinBaseP , ppsttShort[ offh ] , ppsttShort[ offhMin ] ) ;
                                    {
                                    if( ppsttShort[ offh ] )

                                    //if( offhMin != - 1 ) etThread.traceF( tinBaseP , T("[offhMin,ppsttShort[offhMin]]:    ")+TF2(offhMin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb+T(ppsttShort[offhMin]) ) ;
                                    //etThread.traceF( tinBaseP , T("[offh,ppsttShort[offh]]:    ")+TF2(offh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb+T(ppsttShort[offh]) ) ;
                                {
                                for( countT offh = 0 ; !bAbortP && offh < cPathsToYear ; offh ++ )
                                countT offhMin = - 1 ;
                                // SET offhMin TO THE offh OF THE MINIMUM SHORT NAME ; SUPPRESS DUPLICATES

                                if( bAbortP || bAbortLocal ) break ;

                                }
                                    }
                                        if( bRetry ) offh -- ;   // TRY AGAIN TO LOAD A NAME FROM THIS VOLUME

                                        DEL( ppif[ offh ] ) ;
                                        }
                                            //}
                                            //    etThread.traceF( tinBaseP , T("got [offh,psttShort]:    ")+TF2(offh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(ppsttShort[offh]) ) ;
                                            //{
                                            //else
                                            }
                                                bRetry = 1 ;
                                                etThread.delF( tinBaseP , psttFolder ) ;
                                                etThread.traceF( tinBaseP , T("folder ignored [tFolder]:    ")+T(psttFolder) ) ;
                                                etThread.delF( tinBaseP , psttnu ) ;
                                                etThread.strBisectF( tinBaseP , psttnu , psttFolder , ppif[ offh ]->psttIfoName , T("/") , - 2 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttFolder ) ;
                                                ZE( strokeS* , psttFolder ) ;
                                                ZE( strokeS* , psttnu ) ;

                                                etThread.delF( tinBaseP , ppsttShort[ offh ] ) ;
                                            {                                                                               
                                            else if( !ppsttShort[ offh ]->idAdam )          //IT'S A DIRECTORY
                                            #endif
                                                }
                                                    bRetry = 1 ;
                                                    etThread.delF( tinBaseP , ppsttShort[ offh ] ) ;
                                                {
                                                else if( etThread.strIdF( tinBaseP , tShortIgnore , ppsttShort[ offh ] , 1 ) )
                                            #if defined( NEVERdEFINED )
                                            if( !ppsttShort[ offh ] ) bRetry = 1 ;

                                            etThread.delF( tinBaseP , psttnu ) ;
                                            etThread.strBisectF( tinBaseP , psttnu , ppsttShort[ offh ] , ppif[ offh ]->psttIfoName , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( ppsttShort[ offh ] ) ;
                                            ZE( strokeS* , psttnu ) ;

                                            pc4CbUsed[ offh ] = *(count04T*)&ppif[ offh ]->cbUsed ;
                                        {
                                        else
                                        }
                                            continue ;
                                            cPathsDone ++ ;
                                            DEL( pphff[ offh ] ) ;
                                            DEL( ppif[ offh ] ) ;
                                        {
                                        else if( !ppif[ offh ] || !ppif[ offh ]->psttIfoName )
                                        if( bAbortP || bAbortLocal ) break ;
                                        ZE( boolT , bRetry ) ;

                                        }
                                            }
                                                break ;
                                                DEL( ppif[ offh ] ) ;
                                                else          bAbortLocal = 1 ;
                                                if( !cTries ) bAbortP = 1 ;
                                                etThread.traceF( tinBaseP , T("!exception:  diskFindFileOrDirF ; aborting [path]:    ")+T(ppsttPathToYear[offh]) ) ;
                                                POOPRqUIET
                                            {
                                            if( POOP )

                                            // #endif

                                                ((tinNormalS&)tinBaseP).pEtScratch->diskFindFileOrDirF( tinBaseP , ppif[ offh ] , *pphff[ offh ] , ppsttPathToYear[ offh ]        ) ; ___( ppif[ offh ] ) ;

                                            // #else
                                            // 
                                            //     ((tinNormalS&)tinBaseP).pEtScratch->diskFindFileOrDirF( tinBaseP , ppif[ offh ] , *pphff[ offh ] , ppsttPathToYear[ offh ] , &pat ) ; ___( ppif[ offh ] ) ; //FOR TESTING
                                            // 
                                            //       patternC pat( tinBaseP , etThread , T("!ideafarm.a.2.00000000.00000001.20220904@1430.20220912@1742.70cfa724f22dae220ecc078ad6538c5c.001.fset.zip") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; //DUT 20240326@1715
                                            //     //patternC pat( tinBaseP , etThread , T("!ideafarm.9.2.00000000.00000001.20990007@0000.20220225@1343.ab155b6a3666b3c92434e1d1d650e2cf.001.data.zip") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; //LARGEST FILE IN THE ARCHIVE
                                            //     //patternC pat( tinBaseP , etThread , T("!ideafarm.9.2.00000000.00000001.20990013@0000.20210119@0000.014c4e4d37bea606de6c6ac99d8d50c2.001.data.iso") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; // 1,004,306,432 BYTES
                                            //     //patternC pat( tinBaseP , etThread , T("!ideafarm.9.2.00000000.00000001.20131226@1827.20170306@1754.8e00e6d01d529344e90f3e984315b7ce.001.data.mp3") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; //    10,000,635 BYTES
                                            // 
                                            // #if defined( IFC tESTING )

                                            SCOOPS
                                        {
                                        IFsCRATCH

                                        //}
                                        //    continue ;
                                        //    etThread.strMakeF( tinBaseP , LF , ppsttShort[ offh ] , tShortToTest ) ; ___( ppsttShort[ offh ] ) ;
                                        //{
                                        //if( tShortToTest.csF( tinBaseP ) )
                                    {
                                    if( pphff[ offh ] && !ppsttShort[ offh ] )
                                    _IO_
                                {
                                for( countT offh = 0 ; !bAbortP && offh < cPathsToYear ; offh ++ )

                                if( bAbortP ) break ;
                                pauseIfF( tinBaseP , bAbortP , cExecutiveHealYearPausedP , cPauseP ) ;

                                //   LOAD A NONDIRECTORY SHORT NAME FROM EACH VOLUME FOR WHICH THERE IS NOT WO LOADED

                                //
                                //   SELECT THE MINIMUM SHORT NAME, WRITE IT TO JOT, AND DELETE IT
                                //   LOAD A NONDIRECTORY SHORT NAME FROM EACH VOLUME IF NOT ALREADY LOADED
                                //  EACH ITERATION
                                //
                                // RECIPE

                                // LOAD jotShortFileNames (WILL CONTAIN A PAGE FOR EACH VOLUME FOR EACH FILE, SO SHORT NAMES WILL BE DUPLICATED)

                                //  IF I DO THIS, THEN THE ONLY THING THAT SORTER WILL NEED TO CLEAN UP IS VOLUMES THAT PRESENT NAMES OUT OF ORDER, AND THIS WILL BE RARE FOR NTFS VOLUMES
                                // OBJECTIVE: IF EACH VOLUME PRESENTS ITS NAMES IN ASCENDING ORDER THEN, EVEN IF NOT ALL FILES ARE IN ALL VOLUMES, THE NAMES THAT I WRITE WILL BE IN ASCENDING ORDER
                                //  REPEAT
                                //  SELECT THE LOWEST NAME, WRITE IT TO JOT, AND GET THE NEXT NAME FROM THAT VOLUME
                                //  LOAD A SHORT NAME FROM EACH VOLUME
                                // RECIPE
                                _IO_
                            {
                            do
                            ZE( countT , cPathsDone ) ;
                            //TN( tShortToTest , "!ideafarm.9.2.00000000.00000001.20990004@0001.20170124@1441.46c264d2bf71383d11f319c316c3c001.001.data.ISO" ) ;
                            // /*U::COMMENT OUT IN PRODUCTION:*/ TN( tShortIgnore , ".fset.zip" ) ;

                            for( countT offh = 0 ; offh < cPathsToYear ; offh ++ ) pphff[ offh ] = new( 0 , tinBaseP , LF ) handleC( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                            etThread.memSetF( tinBaseP , (byteT*)pc4CbUsed  , cPathsToYear * sizeof( count04T   ) ) ;
                            etThread.memSetF( tinBaseP , (byteT*)ppsttShort , cPathsToYear * sizeof( strokeS*   ) ) ;
                            etThread.memSetF( tinBaseP , (byteT*)ppif       , cPathsToYear * sizeof( infoFileS* ) ) ;
                            etThread.memSetF( tinBaseP , (byteT*)pphff      , cPathsToYear * sizeof( handleC*   ) ) ;

                            _IO_
                        {
                        else
                        if( POOP || ether ) bAbortP = 1 ;
                        ZE( countT , cNames ) ;

                        etThread.newF( tinBaseP , LF , *(byteT**)&pc4CbUsed  , cPathsToYear * sizeof( count04T   ) ) ; ___( pc4CbUsed ) ;
                        ZE( count04T* , pc4CbUsed ) ;

                        etThread.newF( tinBaseP , LF , *(byteT**)&ppsttShort , cPathsToYear * sizeof( strokeS*   ) ) ; ___( ppsttShort ) ;
                        ZE( strokeS** , ppsttShort ) ;

                        etThread.newF( tinBaseP , LF , *(byteT**)&ppif       , cPathsToYear * sizeof( infoFileS* ) ) ; ___( ppif       ) ;
                        ZE( infoFileS** , ppif ) ;

                        etThread.newF( tinBaseP , LF , *(byteT**)&pphff      , cPathsToYear * sizeof( handleC*   ) ) ; ___( pphff      ) ;
                        ZE( handleC** , pphff ) ;

                        jotC jotShortFileNames( tinBaseP , "short.file.names" , flJOTc_WRITE | flJOTc_PRIVATE | flJOTc_DELETE | flJOTc_PURGEoNcT , 1 , CBdATAbOOKsHORTfILEnAMES , CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ) ;
                        //etThread.traceF( tinBaseP , T("reading short names from volumes [archive,year]    ")+tArchive+tb4+tYear ) ;

                        ZE( boolT , bAbortLocal ) ;

                        THREADmODE2rESTORE
                        }
                            if( POOP ) POOPRqUIET
                            ((tinNormalS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tLongSortedBySize , 1 ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                        _IO_
                    {
                    while( !ether && cTries -- )
                    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                    countT cTries = ( F(flagsModeP) & flHEALmODE_STRICT ) ? 1 : CtRIESiFnOTsTRICT ;
                {
                else
                else if( pJotSortedShort ) ;//etThread.traceF( tinBaseP , T("reusing a sorted list of short names") ) ;
                if( bAbortP ) ;

                //for( countT offh = 0 ; offh < cPathsToYear ; offh ++ ) etThread.traceF( tinBaseP , T("cache [cPaths,off,pstt]:    ")+TF2(cPathsToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(ppsttPathToYear[offh]) ) ;

                }
                    if( !bMatch && !bAbortP ) etThread.boxPutF( tinBaseP , tLongBox , twl , twl.csF( tinBaseP ) ) ;

                    }
                        }
                            bAbortP = 1 ;
                            etThread.boxPutF( tinBaseP , tLongBoxSee , twl , twl.csF( tinBaseP ) ) ;
                            etThread.traceF( tinBaseP , T("!exception: volume list that I see differs from list in volumes file ; aborting") ) ;
                        {
                        else
                        }
                            THREADmODE2rESTORE
                            }
                                if( POOP ) POOPRqUIET
                                ((tinNormalS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tLongBoxSee , 1 ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                            bMatch = 1 ;
                        {
                        if( !etThread.strCompareF( tinBaseP , twl , twlLag ) )

                        etThread.delF( tinBaseP , posti ) ;
                        TN( twlLag , posti ) ;

                        etThread.boxGetShadowF( tinBaseP , posti , costi , tLongBox ) ; ___( posti ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;
                    {
                    if( etThread.diskFileExistsF( tinBaseP , tLongBox ) )
                    ZE( boolT , bMatch ) ;

                    TN( tLongBoxSee , "" ) ; tLongBoxSee = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/volumes.")+tArchive+tDot+tYear+T(".see.ttt") ;
                    TN( tLongBox    , "" ) ; tLongBox    = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/volumes.")+tArchive+tDot+tYear+T(".ttt") ;

                    etThread.delF( tinBaseP , psttWorkList ) ;
                    TN( twl , psttWorkList ) ;

                    }
                        etThread.delF( tinBaseP , psttv ) ;
                        etThread.strFuseF( tinBaseP , psttWorkList , tcr   ) ;
                        etThread.strFuseF( tinBaseP , psttWorkList , psttv ) ;
                        stVolume >> psttv ;
                        ZE( strokeS* , psttv ) ;
                    {
                    while( stVolume )

                    etThread.strMakeF( tinBaseP , LF , psttWorkList , 0 , stVolume * 2 + csttVolume ) ; ___( psttWorkList ) ;
                    ZE( strokeS* , psttWorkList ) ;

                    }
                        }
                            stVolume.sinkF( tinBaseP , countTC() , psttv , flSTACKsINK_null ) ;     //INTENTIONALLY ALLOWS DUPLICATES SO WILL FUNCTION CORRECTLY IF MULTIPLE DEVICES HAVE THE SAME VOLUME NAME (WHICH IS BAD PRACTICE AND MIGHT NOT BE SUPPORTED IN THE FUTURE)
                            csttVolume += tVolumeName.csF( tinBaseP ) ;

                            etThread.strMakeF( tinBaseP , LF , psttv , tVolumeName ) ; ___( psttv ) ;
                            ZE( strokeS* , psttv ) ;

                            //etThread.traceF( tinBaseP , T("[volume,pathToYear]:    ")+tVolumeName+tb4+T(ppsttPathToYear[offh]) ) ;
                        {
                        if( !bAbortP )

                        }
                            if( tPseudoVolume.csF( tinBaseP ) ) tVolumeName = tVolumeName+tDot+tPseudoVolume ;

                            DEL( pInfoDisk ) ;
                            }
                                tVolumeName = T(pInfoDisk->psttVolumeName) ;
                                etThread.strConvertToLowerCaseF( tinBaseP , pInfoDisk->psttVolumeName ) ;
                                etThread.delF( tinBaseP , psttDisk ) ;
                            {
                            if( !bAbortP )

                            }
                                }
                                    bAbortP = 1 ;
                                    etThread.traceF( tinBaseP , T("!exception:  diskInfoF: could not obtain volume name [psttDisk]:    ")+T(psttDisk) ) ;
                                    POOPRqUIET
                                {
                                if( POOP )
                                ((tinNormalS&)tinBaseP).pEtScratch->diskInfoF( tinBaseP , pInfoDisk , psttDisk , 1 ) ; ___( pInfoDisk ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            ZE( infoDiskS* , pInfoDisk ) ;

                            etThread.strSubstringF( tinBaseP , psttDisk , idf , idl , ppsttPathToYear[ offh ] ) ; ___( psttDisk ) ;
                            countT idl = 5 ;
                            countT idf = 1 ;
                            ZE( strokeS* , psttDisk ) ;
                        {
                        TN( tVolumeName , "" ) ;

                        }
                            etThread.delF( tinBaseP , pstt1w ) ;
                            }
                                }
                                    break ;
                                    tPseudoVolume = T(psttc1) ;
                                {
                                else if( bArm )
                                if( !etThread.strCompareF( tinBaseP , psttc1 , tDevices ) ) bArm = 1 ;
                            {
                            FORsTRINGSiN1( pstt1w )
                            ZE( boolT , bArm ) ;
                            etThread.strWordsF( tinBaseP , pstt1w , ppsttPathToYear[ offh ] , sttq , tSlash ) ;
                            ZE( strokeS* , pstt1w ) ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        {
                        if( 1 == etThread.strIdF( tinBaseP , tPathDevices , ppsttPathToYear[ offh ] ) )
                        TN( tPseudoVolume , "" ) ;
                    {
                    for( countT offh = 0 ; !bAbortP && offh < cPathsToYear ; offh ++ )
                    TN( tDevices , "devices" ) ;
                    TN( tSlash , "/" ) ;
                    ZE( countT , csttVolume ) ;
                    stackC stVolume( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

                    }
                        etThread.delF( tinBaseP , psttd ) ;
                        tPathDevices = T(psttd) ;
                        #endif
                            //etThread.diskMapFileNameF( tinBaseP , psttd , T("///ideafarm/devices/")            ) ; ___( psttd ) ;
                            etThread.diskMapFileNameF( tinBaseP , psttd , T("///d/ideafarm.home.101/devices/") ) ; ___( psttd ) ;
                        #else
                            etThread.diskMapFileNameF( tinBaseP , psttd , T("///d/ideafarm.home.101/devices/") ) ; ___( psttd ) ;
                        #if defined( IFCtESTING )
                        ZE( strokeS* , psttd ) ;
                    {
                    TN( tPathDevices , "" ) ;

                    _IO_
                {
                ZE( countT , idName ) ;
                TN( tPathLonely   , "/ideafarm.archives.lonely/"  ) ; tPathLonely  += tUniqueP+tSlash ;
                TN( tPathRejects  , "/ideafarm.archives.rejects/" ) ; tPathRejects += tUniqueP+tSlash ;
                TN( tPathArchives , "/ideafarm.archives/"         ) ;

                TN( tLongSortedBySize , "" ) ; tLongSortedBySize = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/sorted.by.size.")+tArchive+tDot+tYear+T(".ttt") ;

                _IO_
            {
            if( cPathsToYear > 1 )

            countT cResultStructsNeeded = 1 + cPathsToYear / cResultsPerStruct ;
            countT cPathsToYear         = listPathsToYearF( tinBaseP , etThread , bAbortP , ppsttPathToYear , swsPathToArchivesByArchiveNameP , psttzlArchiveP , tYear ) ; ___( ppsttPathToYear ) ;
            ZE( strokeS** , ppsttPathToYear ) ;

            //idNameSkipBeyond = 0xb0 ; //U:: TO FIND A BUG

            }
                ++ s ; ether.osSleepF( tinBaseP , TOCK ) ;
                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

                }
                    }
                        etThread.delF( tinBaseP , posti ) ;
                        }
                            //etThread.traceF( tinBaseP , T("i will skip files recently healed [archive,year,idNameSkipBeyond]:    ")+tArchive+tb4+tYear+tb4+TF2(idNameSkipBeyond,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            idNameSkipBeyond = *(countT*)posti ;
                        {
                        else if( posti && costi == sizeof( countT ) )
                        if( POOP ) POOPRqUIET
                        ((tinNormalS&)tinBaseP).pEtScratch->boxGetShadowF( tinBaseP , posti , costi , tLong , 1 ) ; ___( posti ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".lath.idName.completed.ttt") ;
                {
                if( !bAbortP )
            {
            ZE( countT , idNameSkipBeyond ) ;

            }
                }
                    //etThread.traceF( tinBaseP , T("[pJotSortedShort]:    ")+TF3((countT)pJotSortedShort,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ;
                    pJotSortedShort = new( 0 , tinBaseP , LF ) jotC( tinBaseP , tPart2 , flJOTc_DOnOTrEGISTER , 1 , CBdATAbOOKsHORTfILEnAMES , CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ) ;        //flJOTc_DOnOTrEGISTER BECAUSE WILL BE DELETED ON ANOTHER THREAD
                    //etThread.traceF( tinBaseP , T("reusing existing jot of sorted short file names [file]:    ")+tPart2 ) ;
                {
                else
                if( !etThread.diskFileExistsF( tinBaseP , tLongLikeIndex ) || !etThread.diskFileExistsF( tinBaseP , tLongLikeData ) ) ;//etThread.traceF( tinBaseP , T("could not find existing jot of sorted short file names [file]:    ")+tPart2 ) ;

                //if( !etThread.diskFileExistsF( tinBaseP , tLongLikeData  ) ) etThread.traceF( tinBaseP , T("not found [pattern]:    ")+tLongLikeData  ) ;
                //if( !etThread.diskFileExistsF( tinBaseP , tLongLikeIndex ) ) etThread.traceF( tinBaseP , T("not found [pattern]:    ")+tLongLikeIndex ) ;
                //etThread.traceF( tinBaseP , T("looking for [pattern]:    ")+tLongLikeData ) ;
                //etThread.traceF( tinBaseP , T("looking for [pattern]:    ")+tLongLikeIndex ) ;

                TN( tLongLikeData  , "" ) ; tLongLikeData  = tPart1+tPart2+tPart3+tPart4b ;
                TN( tLongLikeIndex , "" ) ; tLongLikeIndex = tPart1+tPart2+tPart3+tPart4a ;
                TN( tPart4b , "" ) ; tPart4b = T("data.booksC.*.bookC" ) ;
                TN( tPart4a , "" ) ; tPart4a = T("index.booksC.*.bookC" ) ;
                TN( tPart3  , "" ) ; tPart3  = T(".jotC." ) ;
                TN( tPart2  , "" ) ; tPart2  = T("healarchive.sorted.short.filenames")+tDot+tArchive+tDot+tYear ;
                TN( tPart1  , "" ) ; tPart1  = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/")+tUser+T("/")+TF3(ifcIDmEMORYsPACE_APPLICATION,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T("/stateSpaces/")+TF3(ifcIDsTATEsPACE_MULTIPLEaDAMS,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tSlash ;

                TN( tUser , thirdC::postUserNameIF() ) ;
            {
            if( !pJotSortedShort )

            jotC*& pJotSortedShort = *ppJotSortedShort ;
            }
                swJotSortedShortByArchiveYearP.ungrabF( tinBaseP ) ;
                ppJotSortedShort = (jotC**)&(countT&)swJotSortedShortByArchiveYearP ;
                psttzlArchiveSlashYearP = tLever ;
                swJotSortedShortByArchiveYearP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                TN( tLever , "" ) ; tLever = tArchive+tSlash+tYear ;
            {
            ZE( jotC** , ppJotSortedShort ) ;
            _IO_
        {
        else
        if( bPriorNotDone ) ;
        if( !bDoThisYear  ) etThread.traceF( tinBaseP , T("skipping this year because it was recently healed AOK [archive,year]:    ")+tArchive+tb4+tYear ) ;

        }
            if( bPriorNotDone ) etThread.traceF( tinBaseP , T("skipping this year because prerequisite phase not done aok [idPhaseLathAOK,archive/year]:    ")+TF2(idPhaseLathAOK,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tArchiveSlashYear ) ;

            }
                }
                    break ;
                    bPriorNotDone = idPhaseLathAOK != IDpHASE_CHUNKfILESbYdAY ;
                {
                case IDpHASE_HEAL :
                }
                    break ;
                    bPriorNotDone = idPhaseLathAOK != IDpHASE_GETnAMESoNLY ;
                {
                case IDpHASE_CHUNKfILESbYdAY :
                }
                    break ;
                    bPriorNotDone = idPhaseLathAOK && idPhaseLathAOK != IDpHASE_CHUNKfILESbYdAY && idPhaseLathAOK != IDpHASE_HEAL ;           // THE PHASE IDpHASE_ARCHIVEnEWfSETS DOES NOT REGISTER ITSELF, SO GETnAMES CAN FOLLOW 0 OR CHUNK OR HEAL
                {
                case IDpHASE_GETnAMESoNLY :
            {
            switch( idPhaseP )

            const countT& idPhaseLathAOK = swIdPhaseDoneAOKLathP ;
            psttzlArchiveSlashYearP = tArchiveSlashYear ;
        {
        ZE( boolT , bPriorNotDone ) ;

        }
            etThread.delF( tinBaseP , posti ) ;
            }
                }
                    if( time2E < 0x40 ) bDoThisYear = 0 ;
                    etThread.osTimeSubtractF( tinBaseP , time1E , time2E , time1AOK , time2AOK ) ;

                    }
                        etThread.delF( tinBaseP , pstt1w ) ;
                        }
                            if( cDone == 2 ) break ;
                            *( cDone ++ ? &time2AOK : (sCountT*)&time1AOK ) = etThread.strDigitsToSCountF( tinBaseP , psttc1 ) ;
                            //etThread.traceF( tinBaseP , T("time word:    ")+T(psttc1) ) ;
                        {
                        FORsTRINGSiN1( pstt1w )
                        ZE( countT  , cDone ) ;
                        etThread.strWordsF( tinBaseP , pstt1w , tTimeAOK , sttq , tDot ) ; ___( pstt1w ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        ZE( strokeS* , pstt1w ) ;

                        //etThread.traceF( tinBaseP , T("[archive,year,timeAOK]:    ")+tArchive+tb4+tYear+tb4+tTimeAOK ) ;
                        TN( tTimeAOK , posti ) ;
                        *postc = 0 ;
                    {
                    ZE( sCountT , time2AOK ) ;
                    ZE( countT  , time1AOK ) ;

                    etThread.osTimeNowF( tinBaseP , time1E , time2E ) ;
                    ZE( sCountT , time2E ) ;
                    ZE( countT  , time1E ) ;
                {
                if( postc )
                osTextT* postc = thirdC::c_strstrIF( tinBaseP , posti , "\r\n" ) ;
            {
            else
            if( POOP ) POOPRqUIET
            ((tinNormalS&)tinBaseP).pEtScratch->boxGetShadowF( tinBaseP , posti , costi , tLong , 1 ) ; ___( posti ) ;
            TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".completed.ttt") ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCH
        boolT bDoThisYear = 1 ;

        etThread.delF( tinBaseP , psttYearP ) ;

        //etThread.traceF( tinBaseP , T("[archive,year]:    ")+tArchive+tb4+tYear ) ;

        TN( tArchiveSlashYear , ""             ) ; tArchiveSlashYear = tArchive+tSlash+tYear        ;
        TN( tYearSlash        , ""             ) ; tYearSlash        =                 tYear+tSlash ;
        TN( tYear             , psttYearP      ) ;
        TN( tArchive          , psttzlArchiveP  ) ;
        TN( tIndent3          , "|           " ) ;
        TN( tIndent2          , "|       "     ) ;
        TN( tIndent1          , "|   "         ) ;
        TN( tPerTuck          , "%"            ) ;
        TN( tDot              , "."            ) ;
        TN( tcr               , "\r\n"         ) ;
        TN( tSlash            , "/"            ) ;
        TN( tb4               , "    "         ) ;
        TN( tb                , " "            ) ;
        _IO_
    {
    if( !POOP )

    // #endif
    //     //etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
    // #if defined( IFC tESTING )
    const countT cProcessors = thirdC::osProcessorsIF( tinBaseP ) ;

    __Z( psttzlArchiveP->idAdam ) ;
    __Z( psttYearP->idAdam ) ;
    _IO_

    etThread.traceF( tinBaseP , T("[idPhaseP]:    ")+TF2(idPhaseP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    countT&       cNewChunksP                     =       *(countT*)pTaskP->c51 ;
    grabC&        grabDiskP                       =        *(grabC*)pTaskP->c41 ;
    grabC&        grabLathFileHealedFilesP        =        *(grabC*)pTaskP->c31 ;
    countT        idPhaseP                        =                 pTaskP->c21 ;
    countT&       cPathsToYearHealingP            =       *(countT*)pTaskP->c11 ;
    switchC&      swIdPhaseDoneAOKLathP           =      *(switchC*)pTaskP->c01 ;
    switchC&      swJotSortedShortByArchiveYearP  =      *(switchC*)pTaskP->cf  ;
    strokeS*&     psttzlArchiveSlashYearP         =     *(strokeS**)pTaskP->ce  ;
    boolT&        bAbortP                         =        *(boolT*)pTaskP->cd  ;
    switchStackC& swsPathToArchivesByArchiveNameP = *(switchStackC*)pTaskP->cc  ;
    strokeS*&     psttzlArchiveP                   =     *(strokeS**)pTaskP->cb  ;
    strokeS*      psttYearP                       =       (strokeS*)pTaskP->ca  ;
    textC&        tUniqueP                        =        *(textC*)pTaskP->c9  ;
    countT&       cExecutiveHealYearPausedP       =       *(countT*)pTaskP->c8  ;
    countT&       cExecutiveHealYearP             =       *(countT*)pTaskP->c7  ;
    flagsT        flagsModeP                      =         (flagsT)pTaskP->c6  ;
    countT&       cYearsHealingP                  =       *(countT*)pTaskP->c5  ;
    funnelHornC&  funJobFileInfoP                 =  *(funnelHornC*)pTaskP->c4  ;
    stackC&       stJobCompareP                   =       *(stackC*)pTaskP->c3  ;
    funnelHornC&  funJobHealFileP                 =  *(funnelHornC*)pTaskP->c2  ;
    countT&       cPauseP                         =       *(countT*)pTaskP->c1  ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 && pTaskP->c8 && pTaskP->c9 && pTaskP->ca && pTaskP->cb && pTaskP->cc && pTaskP->cd && pTaskP->ce && pTaskP->cf && pTaskP->c01 && pTaskP->c21 && pTaskP->c31 && pTaskP->c41 )
TASK( tmExecutiveHealYearF )

DONE( tmUpdateYearCheckpointF )
}
    }
        ++ s ; thirdC::dosSleepIF( tinBaseP , TOCK >> 1 ) ;
        //etThread.traceF( tinBaseP , T("napping") ) ;
        //if( bDo ) FIREmYSELF ;

        }
            //grabLathFileHealedFilesP.ungrabF( tinBaseP ) ;
            //THREADmODE2rESTORE
            etThread.boxPutF( tinBaseP , tLong , (byteT*)&idNameLathDoneInSequenceNew , sizeof idNameLathDoneInSequenceNew ) ;
            //THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
            //grabLathFileHealedFilesP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
            TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchiveP+tDot+tYearP+T(".lath.idName.completed.ttt") ;

            //etThread.traceF( tinBaseP , T("lath done [idNameLathDoneInSequenceNew]:    ")+TF2(idNameLathDoneInSequenceNew,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            _IO_
        {
        if( idNameLathDoneInSequenceNew )

        st_pzJobHealFileDoneP.ungrabF( tinBaseP ) ;
        }
            while( ~hStk ) ;
            }
                }
                    funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
                    DELzOMBIE( pzJob ) ;
                    jobHealFileS* pzDoomed = pzJob ;
                    idNameLathDoneInSequenceNew = idNameConsecutiveLathDoneP = pzJob->idName ;
                    st_pzJobHealFileDoneP.extractF( 0 , tinBaseP ) ;
                    _IO_
                {
                else if( idNameConsecutiveLathDoneP + 1 == pzJob->idName )
                }
                    funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
                    DELzOMBIE( pzJob ) ;
                    jobHealFileS* pzDoomed = pzJob ;
                    st_pzJobHealFileDoneP.extractF( 0 , tinBaseP ) ;
                    _IO_
                {
                if( ether )  //20231126@2016: ADDED ; IF I'VE BEEN FIRED, tmWorkerHealFileF MIGHT HAVE DELETED SOME JOBS SO I CANNOT RELY ON ALL idName VALUES BEING PRESENT IN st_pzJobHealFileDoneP ; IF ( idNameConsecutiveLathDoneP + 1 ) IS NOT PRESENT THEN THIS LOOP WILL SPIN FOREVER

                //etThread.traceF( tinBaseP , T("walking stack of done jobs [idName,short]:    ")+TF3(pzJob->idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+T(pzJob->psttShort) ) ;
                jobHealFileS* pzJob = (jobHealFileS*)st_pzJobHealFileDoneP.downF( tinBaseP , hStk ) ;
                _IO_
            {
            do
            handleC hStk( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            //bDo = 1 ;
            _IO_
        {
        if( st_pzJobHealFileDoneP )
        st_pzJobHealFileDoneP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        ZE( countT , idNameLathDoneInSequenceNew ) ;
        _IO_
    {
    while( !bFireCheckpointUpdateP )
    //ZE( boolT , bDo ) ;
    TN( tDot , "." ) ;
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

    _IO_

    textC&       tYearP                     =       *(textC*)pTaskP->c6 ;
    textC&       tArchiveP                  =       *(textC*)pTaskP->c5 ;
    countT&      idNameConsecutiveLathDoneP =      *(countT*)pTaskP->c4 ;
    funnelHornC& funJobHealFileP            = *(funnelHornC*)pTaskP->c3 ;
    stackC&      st_pzJobHealFileDoneP      =      *(stackC*)pTaskP->c2 ;
    boolT&       bFireCheckpointUpdateP     =       *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmUpdateYearCheckpointF )

DONE( tmWorkerMemCompareF )
}
    dec02AM( cWorkersCompareP ) ;
    stJobCompareP.ungrabF( tinBaseP ) ;
    }
        DEL( pJob ) ;
        stJobCompareP >> *(countT*)&pJob ;
        ZE( jobCompareOoImagesS* , pJob ) ;
        _IO_
    {
    while( stJobCompareP )
    stJobCompareP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

    // #endif
    //     //etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
    // #if defined( IFC tESTING )
    }
        stJobCompareP.ungrabF( tinBaseP ) ;

        }
            stJobCompareP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
            ++ s ; thirdC::dosSleepWinkIF( tinBaseP , 0 ) ;
            //if( cYearsHealingP && idPhaseP == IDpHASE_HEAL ) etThread.traceF( tinBaseP , T("years are healing but i have nothing to do (no memory compare jobs) [cIdle]:    ")+TF2(++cIdle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            stJobCompareP.ungrabF( tinBaseP ) ;
            _IO_
        {
        if( !cDone )

        // #endif
        //     //}
        //     //    etThread.traceF( tinBaseP , T("---- watch") ) ;
        //     //    etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_UNWATCH ) ;
        //     //    bWatching = 0 ;
        //     //{
        //     //if( bWatching )
        // #if defined( IFC tESTING )

        }
            stJobCompareP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
            cDone ++ ;
            DEL( pJob ) ;
            }
                //etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_UNWATCH ) ;
                compareOoImagesF( tinBaseP , ether , etThread , bAbortP , cPauseP , pJob->bEqual , flagsModeP , pJob->pbwOuter , pJob->pbwInner , pJob->cbwOuter /*, T(pJob->psttLongOuter) , T(pJob->psttLongInner) , tIndent3*/ ) ; // bEqual MIGHT BE RESET DUE TO A PREVIOUS JOB ; THIS CAN HAPPEN DUE TO RACE BETWEEN ME AND THE THREAD THAT PUSHES JOBS ; SOMETIMES compareOoImagesF WILL BE CALLED UNNECESSARILY BUT THIS IS HARMLESS
                //etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_WATCH ) ;
                _IO_
            {
            if( pJob->bEqual )
            stJobCompareP.ungrabF( tinBaseP ) ;

            stJobCompareP >> *(countT*)&pJob ;
            ZE( jobCompareOoImagesS* , pJob ) ;

            // #endif
            //     //}
            //     //    etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_WATCH ) ;
            //     //    etThread.traceF( tinBaseP , T("++++ watch") ) ;
            //     //    bWatching = 1 ;
            //     //{
            //     //if( !bWatching )
            // #if defined( IFC tESTING )
            _IO_
        {
        while( stJobCompareP )
        //ZE( boolT , bWatching ) ;
        ZE( countT , cDone ) ;
        stJobCompareP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        _IO_
    {
    while( !ether )
    ZE( countT , cIdle ) ;
    // #endif
    //     //etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
    // #if defined( IFC tESTING )
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

    TN( tIndent3 , "|           " ) ;

    _IO_

    countT&       cYearsHealingP                  = *(countT*)pTaskP->c7 ;
    flagsT        flagsModeP                      =   (flagsT)pTaskP->c6 ;
    stackC&       stJobCompareP                   = *(stackC*)pTaskP->c5 ;
    countT&       cPauseP                         = *(countT*)pTaskP->c4 ;
    countT&       idPhaseP                        = *(countT*)pTaskP->c3 ;
    boolT&        bAbortP                         =  *(boolT*)pTaskP->c2 ;
    countT&       cWorkersCompareP                = *(countT*)pTaskP->c1 ;  //U:: cWorkersCompareP IS ALSO NEEDED TO WORKAROUND A DESIGN DEFECT OF etherWhereF (20231126@1005 I NO LONGER REMEMBER WHAT DEFECT THAT WAS)
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TASK( tmWorkerMemCompareF )

DONE( tmWorkerFileInfoF )
}
    dec02AM( cWorkersFileInfoP ) ;

    }
        funJobFileInfoP.readDoneF( (byteT*)pzDoomed ) ;
        DELzOMBIE( pzJob ) ;
        jobFileInfoS* pzDoomed = pzJob ;
        if( !pzJob ) break ;
        jobFileInfoS* pzJob = (jobFileInfoS*)funJobFileInfoP.readF( tinBaseP , flFUNNELhORNcrEAD_NOwAIT ) ;
        _IO_
    {
    for(;;)

    }
        //etThread.traceF( tinBaseP , tSay2 ) ;

        funJobFileInfoP.readDoneF( (byteT*)pzDoomed ) ;
        DELzOMBIE( pzJob ) ;
        jobFileInfoS* pzDoomed = pzJob ;

        }
            if( !bOk ) pzJob->pInfo = INFOfILEnOTaVAILABLE ; // CLIENT MUST INSPECT FOR THIS SPECIAL VALUE

            }
                }
                    }
                        DEL( pzJob->pInfo ) ;
                        bOk = 0 ;
                        bAbortP = 1 ;
                        etThread.traceF( tinBaseP , T("!exception:  diskFileQueryF [tLong]:    ")+T(pzJob->psttLong) ) ;
                        POOPRqUIET
                        _IO_
                    {
                    else
                    if( !POOP ) pzJob->pInfo = pInfoFile ;
                    ((tinNormalS&)tinBaseP).pEtScratch->diskFileQueryF( tinBaseP , pInfoFile , fi ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                    _IO_
                {
                else if( bOk )
                }
                    bOk = 0 ;
                    bAbortP = 1 ;
                    etThread.traceF( tinBaseP , T("!exception:  fileC::fileC [POOP,tLong]:    ")+TF2(save,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(pzJob->psttLong) ) ;
                    POOPRqUIET
                    countT save = POOP ;
                    _IO_
                {
                if( POOP )

                }
                    }
                        break ;
                        bOk = 0 ;
                        //etThread.traceF( tinBaseP , T("warning: listed file not found [tLong]:    ")+T(pzJob->psttLong) ) ;
                        POOPRqUIET
                    {
                    case ifcIDiMPOTENCEbASEeRRORcODE_FILEnOTfOUND :
                    }
                        break ;
                        bOk = 0 ;
                        //etThread.traceF( tinBaseP , T("warning: listed file path not found [tLong]:    ")+T(pzJob->psttLong) ) ;
                        POOPRqUIET
                    {
                    case ifcIDiMPOTENCEbASEeRRORcODE_PATHnOTfOUND :
                {
                switch( POOP )

                fileC fi( tinBaseP , pzJob->psttLong , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 ) ;

                SCOOPS
                _IO_
            {
            IFsCRATCH
            boolT bOk = 1 ;
            _IO_
        {
        if( pzJob->psttLong && pzJob->psttLong->idAdam && !bQuitP )    // FILE NAME WILL BE NULL LENGTH FOR NULL JOBS PUSHED JUST TO ENABLE ME TO QUIT

        //etThread.traceF( tinBaseP , tSay1 ) ;
        //if( timeE1 || timeE2 ) tSay1 += T("    nothing to do for time    ")+TT(timeE1,timeE2) ;
        //TN( tSay2 , "                                                                                                                 -----------------------------------------------------------------------------------------------------------------" ) ;
        //TN( tSay1 , "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" ) ;

        etThread.osTimeSubtractF( tinBaseP , timeE1 , timeE2 , timeN1 , timeN2 ) ;
        etThread.osTimeNowF( tinBaseP , timeE1 , timeE2 ) ;
        ZE( sCountT , timeE2 ) ;
        ZE( countT  , timeE1 ) ;
        jobFileInfoS* pzJob = (jobFileInfoS*)funJobFileInfoP.readF( tinBaseP ) ;
        etThread.osTimeNowF( tinBaseP , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;
        _IO_
    {
    while( !bQuitP )
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

    TN( tb4 , "    " ) ;
    TN( tIndent3 , "|           " ) ;

    _IO_

    flagsT        flagsModeP                      =         (flagsT)pTaskP->c7 ;
    funnelHornC&  funJobFileInfoP                 =  *(funnelHornC*)pTaskP->c6 ;
    countT&       cPauseP                         =       *(countT*)pTaskP->c5 ;
    countT&       idPhaseP                        =       *(countT*)pTaskP->c4 ;
    boolT&        bAbortP                         =        *(boolT*)pTaskP->c3 ;
    countT&       cWorkersFileInfoP               =       *(countT*)pTaskP->c2 ;
    boolT&        bQuitP                          =        *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TASK( tmWorkerFileInfoF )

DONE( tmWorkerHealFileF )
}
    dec02AM( cWorkersHealP ) ;

    }
        funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
        DELzOMBIE( pzJob ) ;
        jobHealFileS* pzDoomed = pzJob ;
        if( !pzJob ) break ;
        jobHealFileS* pzJob = (jobHealFileS*)funJobHealFileP.readF( tinBaseP , flFUNNELhORNcrEAD_NOwAIT ) ;
        _IO_
    {
    for(;;)

    //etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
    }
        }
            funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
            DELzOMBIE( pzJob ) ;
            jobHealFileS* pzDoomed = pzJob ;
            _IO_
        {
        if( !ids )

        }
            ++ s ; thirdC::dosSleepWinkIF( tinBaseP ) ;
            }
                break ;
                pzJob = 0 ; 
            {
            if( ids )
            pzJob->info.st_pzJobHealFileDone.sinkF( tinBaseP , ids , (countT)pzJob , flSTACKsINK_UNIQUE , subtractHealFileJobF ) ;
            _IO_
        {
        while( !ether )
        ZE( countT , ids ) ;

        }
            // if( bChatter ) etThread.traceF( tinBaseP , T("done [idName,tShort]:    ")+TF2(pzJob->idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
            healShortNameF( tinBaseP , ether , pzJob->info , tShort , flagsModeP , pzJob->idName , pzJob->cShortNames , cToHireHealP , cToHireCompareP , bChatter ) ;
            // /*if( !( id In % TUCK ) )*/ etThread.traceF( tinBaseP , T("calling healShortNameF [id In]:    ")+TF2(id In,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            //countT id In = 1 + incv02AM( id InLath ) ;
            //sta tic countT id InLath ;
            _IO_
        {
        TN( tShort , pzJob->psttShort ) ;

        //U:: LATER: pzJob->info.funJobHealFileDone.writeF( tinBaseP , (byteT*)pzJob ) ;

        //etThread.traceF( tinBaseP , T("pulled from funJobHealFileP [idName]:    ")+TF2(pzJob->idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        }
            break ;
            }
                funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
                DELzOMBIE( pzJob ) ;
                jobHealFileS* pzDoomed = pzJob ;
                _IO_
            {
            if( pzJob )
        {
        if( !pzJob || ether )
        jobHealFileS* pzJob = (jobHealFileS*)funJobHealFileP.readF( tinBaseP ) ;
        _IO_
    {
    while( !ether )
    ZE( countT , cIdle ) ;

    //etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
    ZE( countT , cDoneTotal ) ;
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

    TN( tb4 , "    " ) ;
    TN( tIndent3 , "|           " ) ;

    boolT bChatter = 0 ;
    //boolT bChatter = id In == 1 ;
    //countT id In = 1 + incv02AM( id InLath ) ;
    //sta tic countT id InLath ;

    _IO_

    countT        cToHireCompareP                 =                 pTaskP->c9 ;
    countT        cToHireHealP                    =                 pTaskP->c8 ;
    countT&       cYearsHealingP                  =       *(countT*)pTaskP->c7 ;
    flagsT        flagsModeP                      =         (flagsT)pTaskP->c6 ;
    funnelHornC&  funJobHealFileP                 =  *(funnelHornC*)pTaskP->c5 ;
    countT&       cPauseP                         =       *(countT*)pTaskP->c4 ;
    countT&       idPhaseP                        =       *(countT*)pTaskP->c3 ;
    boolT&        bAbortP                         =        *(boolT*)pTaskP->c2 ;
    countT&       cWorkersHealP                   =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 && pTaskP->c8 && pTaskP->c9 )
TASK( tmWorkerHealFileF )

}
    THREADmODE2rESTORE
    }
        #endif

            if( !bAbortP && !etPrime ) zipDayF( tinBaseP , etherP , bAbortP , cNewChunksP , cPathsToYearP , ppsttPathToYearP , tShortDayZip , tDayPrefixP , - 1 ) ;
            // THIS IS DEBUGGING CODE (ZIPPING IS DONE SERIALLY)

        #else

            }
                ++ s ; etherP.osSleepF( tinBaseP , TOCK >> 2 ) ;
            {
            while( cDayZippers )
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

            }
                etherP.osThreadF( TaRG1( tmDayZipperF ) , (countT)&cDayZippers , (countT)&bAbortP , (countT)&cNewChunksP , cPathsToYearP , offi , (countT)ppsttPathToYearP , (countT)&tShortDayZip , (countT)&tDayPrefixP ) ;
                inc02AM( cDayZippers ) ;

                }
                    ++ s ; etherP.osSleepF( tinBaseP , TOCK >> 2 ) ;              //20240622@1800: STALLS WITH 01 WITHIN 2 TICKS
                {                                                             //20240622@1743: STALLS WITH 4, SO REVERTING TO 01 FOR DEBUGGING (CONJ: LEAK)
                while( cDayZippers > 0x20 )                                   //20240622@1654: STALLS WITH 8
                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;

            {
            for( countT offi = 0 ; !etPrime && offi < cPathsToYearP ; offi ++ )
            ZE( countT , cDayZippers ) ;
            // THIS IS PRODUCTION CODE (ZIPPING IS DONE IN PARALLEL)

        #if !defined( NEVERdEFINED )
    {
    if( !bAbortP )

    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

    TN( tDotHeyDot , ".!." ) ;
    TN( tShortDayZip , "" ) ; tShortDayZip = tDayPrefixP+T(".!.chunk.day.zip") ;
    TN( tb4  , "    " ) ;
    TN( tb   , " " ) ;
    TN( tAtAsterisk , "@*" ) ;
    etherC& etPrime = etherC::etPrimeIF() ;
{
voidT chunkDayIfF( tinBaseS& tinBaseP , etherC& etherP , boolT& bAbortP , countT& cNewChunksP , countT cPathsToYearP , strokeS** ppsttPathToYearP , textC& tDayPrefixP )

}
    return 1 ;

    }
        etherP.delF( tinBaseP , *(countT**)&ppsttPathToYear ) ;
        }
            etherP.delF( tinBaseP , ppsttPathToYear[ offi ] ) ;

            }
                }
                    }
                        etherP.traceF( tinBaseP , T("could not extract fset from chunk [rc,postRc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc) ) ;
                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )

                    ((tinNormalS&)tinBaseP).pEtScratch->diskUnzipF( tinBaseP , tShortDayChunk , flUNZIP_null , tShortFset+T(".fooey") , 0 , 0 , T("-embedded=no") , 0 , 0 ) ;
                    SCOOPS
                {
                IFsCRATCH
                // TRY TO EXTRACT A CHUNKED VERSION OF THIS FILE

                hoverC hover( tinBaseP , etherP , tPathYear ) ;

                etherP.traceF( tinBaseP , T("walkNewFsetCBF / chunk file found [tLongDayChunk]:    ")+tLongDayChunk ) ;
            {
            if( etherP.diskFileExistsF( tinBaseP , tLongDayChunk ) )

            TN( tLongDayChunk , "" ) ; tLongDayChunk = tPathYear+tShortDayChunk ;
            etherP.traceF( tinBaseP , T("walkNewFsetCBF [path]:    ")+tPathYear ) ;
            TN( tPathYear , ppsttPathToYear[ offi ] ) ;
        {
        for( countT offi = 0 ; offi < cPathsToYear ; offi ++ )

        countT cResultStructsNeeded = 1 + cPathsToYear / cResultsPerStruct ;
        countT cPathsToYear         = listPathsToYearF( tinBaseP , etherP , bAbortP , ppsttPathToYear , swsPathToArchivesByArchiveNameP , psttzlArchiveP , tYear ) ; ___( ppsttPathToYear ) ;
        psttzlArchiveP = tArchive ;
        ZE( strokeS** , ppsttPathToYear ) ;

        etherP.traceF( tinBaseP , T("                      [tShortDayChunk]:    ")+tShortDayChunk ) ;
        etherP.traceF( tinBaseP , T("walkNewFsetCBF file to archive [tLongFset]:    ")+tLongFset ) ;
    {
    if( bDoIt )

    }
        }
            if( idHit && idHit == tShortFset.csF( tinBaseP ) + 1 - tTest.csF( tinBaseP ) ) bDoIt = 1 ;

            countT idHit = etherP.strIdF( tinBaseP , tTest , tShortFset ) ;
            TN( tTest , ".fset.zip" ) ;

            //etherP.traceF( tinBaseP , T("[tArchive,tYear]:    ")+tArchive+T("    ")+tYear ) ;
        {
        if( !bDir && cWords == 7 )

        etherP.delF( tinBaseP , pstt1w ) ;
        }
            }
                }
                    break ;

                    etherP.delF( tinBaseP , psttSnip ) ;
                    tShortDayChunk = T(psttSnip)+T(".!.chunk.day.zip") ;
                    etherP.strSubstringF( tinBaseP , psttSnip , idf , idl , psttc1 ) ; ___( psttSnip ) ;
                    idl = 0x28 ;
                    idf = 0x01 ;

                    etherP.delF( tinBaseP , psttSnip ) ;
                    tYear = T(psttSnip) ;
                    etherP.strSubstringF( tinBaseP , psttSnip , idf , idl , psttc1 ) ; ___( psttSnip ) ;
                    countT idl = 0x24 ;
                    countT idf = 0x21 ;
                    ZE( strokeS* , psttSnip ) ;

                    // !ideafarm.a.2.00000000.00000001.12340101@1111.12340101@1111.47b026940e01c589dcbe1258d7ed69ce.001.fset.zip
                    //                                 |--|
                    // 123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0
                    // 0              1               2               3               4               5               6               7

                    tShortFset = T(psttc1) ;
                {
                case 7 :
                }
                    break ;
                    tArchive = T(psttc1) ;
                {
                case 6 :
            {
            switch( idw )

            //etherP.traceF( tinBaseP , T("    [idWord,word]:    ")+TF2(idw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttc1) ) ;
            ++ idw ;
        {
        FORsTRINGSiN1( pstt1w )
        ZE( countT , idw ) ;
        etherP.traceF( tinBaseP , T("[bDir,cWords,tLongFset]:    ")+TF2(bDir,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cWords,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tLongFset ) ;
        countT cWords = etherP.strWordsF( tinBaseP , pstt1w , tLongFset , sttq , T("/") ) ; ___( pstt1w ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        ZE( strokeS* , pstt1w ) ;

        boolT bDir = psttzName[ CSpREFIX + psttzName->idAdam - 1 ].idAdam == '/' ;
        strokeS* psttzName = tLongFset ;

        tLongFset = T(iffn) ;
        ifFileNameC iffn( tinBaseP , etherP , postNameP ) ;
    {
    if( postNameP )
    TN( tShortDayChunk , "" ) ;
    TN( tShortFset , "" ) ;
    TN( tLongFset , "" ) ;
    TN( tYear    , "" ) ;
    TN( tArchive , "" ) ;
    TN( tb4 , "    " ) ;
    ZE( boolT , bDoIt ) ;

    strokeS*&     psttzlArchiveP                  =     *(strokeS**)pcArgP[ 3 ] ;
    switchStackC& swsPathToArchivesByArchiveNameP = *(switchStackC*)pcArgP[ 2 ] ;
    boolT&        bAbortP                         =        *(boolT*)pcArgP[ 1 ] ;
    etherC&       etherP                          =       *(etherC*)pcArgP[ 0 ] ;
{
boolT walkNewFsetCBF( tinBaseS& tinBaseP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

DONE( tmDayZipperF )
}
    dec02AM( cDayZippersP ) ;
    if( !bAbortP ) zipDayF( tinBaseP , etThread , bAbortP , cNewChunksP , cPathsToYearP , ppsttPathToYearP , tShortDayZipP , tDayPrefixP , offDoP ) ;

    //etThread.traceF( tinBaseP , T("[tPathYear]:    ")+tPathYear ) ;
    TN( tPathYear , "" ) ; if( offDoP < cPathsToYearP ) tPathYear = T(ppsttPathToYearP[offDoP]) ;

//((tinNormalS&)tinBaseP).pc Utility[ 0 ] ++ ; //U:: TO FIND A BUG

    textC&    tDayPrefixP         =   *(textC*)pTaskP->c8 ;
    textC&    tShortDayZipP       =   *(textC*)pTaskP->c7 ;
    strokeS** ppsttPathToYearP    = (strokeS**)pTaskP->c6 ;
    countT    offDoP              =            pTaskP->c5 ;
    countT    cPathsToYearP       =            pTaskP->c4 ;
    countT&   cNewChunksP         =  *(countT*)pTaskP->c3 ;
    boolT&    bAbortP             =   *(boolT*)pTaskP->c2 ;
    countT&   cDayZippersP        =  *(countT*)pTaskP->c1 ;

    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c6 && pTaskP->c7 && pTaskP->c8 )
TASK( tmDayZipperF )

}
    return cPathsToYear ;

    }
        }
            }
                while( ~hStk ) ;
                }
                    etherP.traceF( tinBaseP , T("ppsttPathToYearP loaded [idPath,ppsttPath]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(ppsttPathToYearP[offo-1]) ) ;

                    etherP.strMakeF( tinBaseP , LF , ppsttPathToYearP[ offo ++ ] , psttPath ) ; ___( ppsttPathToYearP[ offo ] ) ;

                    strokeS* psttPath = (strokeS*)stPathToYear.downF( tinBaseP , hStk ) ;

                    if( offo == cca ) { BLAMMO ; }
                {
                do
                ZE( countT , offo ) ;
                handleC hStk( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                }
                    for( countT offo = 0 ; offo < cca ; offo ++ ) pca[ offo ] = 0 ;
                    etherP.newF( tinBaseP , LF , pca , cca ) ; ___( pca ) ;

                             cca = stPathToYear ;
                    countT*& pca = *(countT**)&ppsttPathToYearP ;
                {
                ZE( countT , cca ) ;
            {
            if( stPathToYear )

            stPathToYear.lockIfF( tinBaseP ) ;
        {
        if( idPass == 1 )

        if( bAbortP ) break ;

        while( !bAbortP && ~hSwsPathToArchives ) ;
        }
            etherP.delF( tinBaseP , pstt1PathToYear ) ;
            }
                }
                    //etherP.traceF( tinBaseP , T("stPathToYear [cPlates,ids,psttc1]:    ")+TF2(stPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idSlotPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttc1) ) ;
                    countT idSlotPathToYear = stPathToYear( psttc1 ) ;
                {
                else
                }
                    }
                        break ;
                        bAbortP = 1 ;
                        etherP.traceF( tinBaseP , T("!exception: idSlotPathToYear is null") ) ;
                        etherP.delF( tinBaseP , psttPathToYear ) ;
                    {
                    if( !idSlotPathToYear ) //SHOULD BE IMPOSSIBLE
                    //etherP.traceF( tinBaseP , T("maybe sunk into stPathToYear [now,psttPathToYear]:    ")+TF2(st OldPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttPathToYear) ) ;
                    stPathToYear.sinkF( tinBaseP , idSlotPathToYear , psttPathToYear , flSTACKsINK_UNIQUE ) ;
                    ZE( countT , idSlotPathToYear ) ;

                    etherP.strMakeF( tinBaseP , LF , psttPathToYear , psttc1 ) ; ___( psttPathToYear ) ;
                    ZE( strokeS* , psttPathToYear ) ;
                {
                if( idPass == 1 )
            {
            FORsTRINGSiN1( pstt1PathToYear )

            //etherP.traceF( tinBaseP , T("[pstt1PathToYear]:    ")+T(pstt1PathToYear) ) ;
            etherP.strConvertToLowerCaseF( tinBaseP , pstt1PathToYear ) ;

            }
                }
                    break ;
                    bAbortP = 1 ;
                    etherP.traceF( tinBaseP , T("!exception:  diskFindFileOrDirF ; aborting [tPathToArchive]:    ")+tPathToArchive ) ;
                    POOPRqUIET
                {
                if( POOP )
                ((tinNormalS&)tinBaseP).pEtScratch->diskFindFileOrDirF( tinBaseP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                SCOOPS
            {
            IFsCRATCH
            patternC pat( tinBaseP , etherP , T(psttYearP)+T("/") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
            ZE( strokeS* , pstt1PathToYear ) ;

            //if( idPass == 1 ) etherP.traceF( tinBaseP , T("flavor [tPathToArchive]:    ")+tPathToArchive ) ;
            TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzlArchiveP)+tSlash ;
            strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveNameP.downF( tinBaseP , hSwsPathToArchives ) ;
        {
        do
        handleC hSwsPathToArchives( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

        if( idPass == 2 ) cPathsToYear = stPathToYear ;

        _IO_
    {
    for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
    TN( tb4    , "    " ) ;
    TN( tSlash , "/" ) ;
    stackC stPathToYear( tinBaseP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    ZE( countT , cPathsToYear ) ;
{
countT listPathsToYearF( tinBaseS& tinBaseP , etherC& etherP , boolT& bAbortP , strokeS**& ppsttPathToYearP , switchStackC& swsPathToArchivesByArchiveNameP , strokeS*& psttzlArchiveP , const strokeS* psttYearP )

}
    return cArchive ;

    swsPathToArchivesByArchiveNameP.lockIfF( tinBaseP ) ;

    etherP.delF( tinBaseP , pstt1ArchivesAllLag ) ;
    }
        }
            ++ s ; etPrime.osSleepF( tinBaseP , TOCK << 2 ) ;
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        {
        if( bAbortP )

        }
            break ;
            etherP.delF( tinBaseP , pstt1ArchivesAll ) ;
            }
                swsPathToArchivesByArchiveNameP.sinkF( tinBaseP , countTC() , psttPathArchives ) ;                           // EXAMPLE: "///c/ipdos.arhives/"
                psttzArchiveP = tArchive ;

                }
                    if( !ids ) etherP.delF( tinBaseP , psttp ) ;
                    stPathToArchivesP.sinkF( tinBaseP , ids , psttp , flSTACKsINK_UNIQUE ) ;
                    ZE( countT , ids ) ;
                    etherP.strMakeF( tinBaseP , LF , psttp , psttPathArchives ) ; ___( psttp ) ;
                    ZE( strokeS* , psttp ) ;
                {


                //etherP.traceF( tinBaseP , T("    [tPathArchives,tArchive]:    ")+T(psttPathArchives)+tb4+tArchive ) ;

                }
                    etherP.delF( tinBaseP , psttShorter ) ;
                    tArchive = T(psttShorter) ;
                    etherP.strSubstringF( tinBaseP , psttShorter , idf , idl , tArchiveSlash ) ; ___( psttShorter ) ;
                    ZE( strokeS* , psttShorter ) ;
                {
                if( idl )
                countT idl = tArchiveSlash.csF( tinBaseP ) ? tArchiveSlash.csF( tinBaseP ) - 1 : 0 ;
                countT idf = 1 ;
                TN( tArchive , "" ) ;                                                                                   // EXAMPLE: "wo.ideafarm"

                }
                    etherP.delF( tinBaseP , psttArchiveSlash ) ;
                    tArchiveSlash = T(psttArchiveSlash) ;
                    etherP.strBisectF( tinBaseP , psttPathArchives , psttArchiveSlash , psttc3 , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathArchives ) ; ___( psttArchiveSlash ) ;
                    ZE( strokeS* , psttArchiveSlash ) ;
                {
                TN( tArchiveSlash , "" ) ;                                                                              // EXAMPLE: "wo.ideafarm/"
                ZE( strokeS* , psttPathArchives ) ;                                                                     // EXAMPLE: "///c/ipdos.arhives/"

                //etherP.traceF( tinBaseP , T("processing archive ")+T(psttc3) ) ;                                          // EXAMPLE: "///c/ipdos.arhives/wo.ideafarm/"
                _IO_
            {
            FORsTRINGSiN3( pstt1ArchivesAll )

            }
                continue ;
                pstt1ArchivesAllLag = pstt1ArchivesAll ; pstt1ArchivesAll = 0 ;
                etherP.delF( tinBaseP , pstt1ArchivesAllLag ) ;
                ++ s ; etPrime.osSleepF( tinBaseP , TICK >> 4 ) ;
                if( bTest3 ) etherP.traceF( tinBaseP , T("napping for a minute [reason]:    my list of visible archives changed") ) ;
                if( bTest2 ) etherP.traceF( tinBaseP , T("napping for a minute [reason]:    waiting to give time for all archives to become visible") ) ;
                if( bTest1 ) etherP.traceF( tinBaseP , T("napping for a minute [reason]:    less than oo archives found") ) ;
            {
            if( bTest1 /*|| bTest2*/ || bTest3 )
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
            boolT bTest3 = !pstt1ArchivesAllLag ? 0 : etherP.strCompareF( tinBaseP , pstt1ArchivesAllLag , pstt1ArchivesAll ) ;
            boolT bTest2 = !pstt1ArchivesAllLag ;
            boolT bTest1 =  cArchive < 2 ;
            _IO_
        {
        if( !bAbortP && pstt1ArchivesAll )

        }
            while( ~hWalk ) ;
            }
                etherP.strFuseSeparateF( tinBaseP , pstt1ArchivesAll , psttzArchive ) ;
                strokeS* psttzArchive = (strokeS*)stArchive.downF( tinBaseP , hWalk ) ;
            {
            do

            etherP.strMakeF( tinBaseP , LF , pstt1ArchivesAll , 0 , cArchive * CSpREFIX + csttArchive ) ; ___( pstt1ArchivesAll ) ;

            while( ~hWalk ) ;
            }
                csttArchive += psttzArchive->idAdam ;
                cArchive ++ ;
                strokeS* psttzArchive = (strokeS*)stArchive.downF( tinBaseP , hWalk ) ;
            {
            do
            ZE( countT , csttArchive ) ;

            handleC hWalk( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            _IO_
        {
        if( !bAbortP && stArchive )
        ZE( strokeS* , pstt1ArchivesAll ) ;

        }
            etherP.delF( tinBaseP , pstt1Archives1 ) ;
            }
                }
                    }
                        bAbortP = 1 ;                                                    
                        etherP.traceF( tinBaseP , T("!exception: duplicate archive long name") ) ;
                        etherP.delF( tinBaseP , psttArchive ) ;
                    {
                    if( !ids ) //SHOULD BE IMPOSSIBLE
                    stArchive.sinkF( tinBaseP , ids , psttArchive , flSTACKsINK_UNIQUE ) ;
                    ZE( countT , ids ) ;
                    //etherP.traceF( tinBaseP , T("sinking archive ")+T(psttArchive) ) ;

                    etherP.strMakeF( tinBaseP , LF , psttArchive , psttc1 ) ; ___( psttArchive ) ;
                    ZE( strokeS* , psttArchive ) ;

                    //etherP.traceF( tinBaseP , T("on lettered device [idArchive1,archive]:    ")+TF2(++cArchives,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttc1) ) ;
                {
                FORsTRINGSiN1( pstt1Archives1 )
                ZE( countT , cArchives ) ;
            {
            if( !bAbortP )

            }
                }
                    bAbortP = 1 ;
                    etherP.traceF( tinBaseP , T("!exception:  diskFindFileOrDirF [tLikeArchives1,tDiskCulprit]:    ")+tLikeArchives1+tb4+tDiskCulprit ) ;
                    POOPRqUIET

                    }
                        tDiskCulprit = T(postCulprit) ;
                        postCulprit[ 3 ] = ostCulprit ;
                        osTextT postCulprit[] = "///?/" ;
                    {
                    if( ostCulprit >= 'a' && ostCulprit <= 'z' ) 
                    osTextT ostCulprit = (osTextT)( POOP >> 0x18 ) ;
                    TN( tDiskCulprit , "" ) ;
                {
                if( POOP )
                ((tinNormalS&)tinBaseP).pEtScratch->diskFindFileOrDirF( tinBaseP , pstt1Archives1 , tLikeArchives1 ) ; ___( pstt1Archives1 ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCH
            ZE( strokeS* , pstt1Archives1 ) ;
            _IO_
        {
        if( !cPseudoVolumes ) //P:PERSONALITY:  IF PSEUDOVOLUMES EXIST THEN I DO NOT SCAN FOR DEVICES WITH DRIVE LETTERS ; THIS IS FOR USER CONVENIENCE. FOR EXAMPLE, BACKUP CAN BE RUN TO A LETTERED DEVICE WHILE HEAL IS RUNNING USING PSEUDODEVICES IN ///ideafarm/devices/, EVEN THOUGH THE BACKUP DEVICE IS ALSO A PSEUDODEVICE SO IS BEING USED BOTH FOR BACKUP AND FOR HEALING
        //etherP.traceF( tinBaseP , T("accumulating archives on lettered devices") ) ;

        }
            etherP.delF( tinBaseP , pstt1PseudoVolumes ) ;
            }
                }
                    if( bAbortP ) break ;
                    etherP.delF( tinBaseP , pstt1Archives ) ;
                    }
                        }
                            etherP.delF( tinBaseP , pstt1Archives2 ) ;
                            }
                                }
                                    }
                                        bAbortP = 1 ;                                                    
                                        etherP.traceF( tinBaseP , T("!exception: duplicate archive long name") ) ;
                                        etherP.delF( tinBaseP , psttArchive ) ;
                                    {
                                    if( !ids ) //SHOULD BE IMPOSSIBLE
                                    stArchive.sinkF( tinBaseP , ids , psttArchive , flSTACKsINK_UNIQUE ) ;
                                    ZE( countT , ids ) ;
                                    //etherP.traceF( tinBaseP , T("sinking archive ")+T(psttArchive) ) ;
    
                                    etherP.strMakeF( tinBaseP , LF , psttArchive , psttc1 ) ; ___( psttArchive ) ;
                                    ZE( strokeS* , psttArchive ) ;

                                    cPseudoVolumes ++ ;
    
                                    //etherP.traceF( tinBaseP , T("on mounted device [idArchive1,archive]:    ")+TF2(++cArchives,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttc1) ) ;
                                {
                                FORsTRINGSiN1( pstt1Archives2 )
                                ZE( countT , cArchives ) ;
                            {
                            else
                            if( bAbortP ) break ;

                            }
                                }
                                    bAbortP = 1 ;
                                    etherP.traceF( tinBaseP , T("!exception:  diskFindFileOrDirF [psttc1,tDiskCulprit]:    ")+T(psttc1)+tb4+tDiskCulprit ) ;
                                    POOPRqUIET

                                    }
                                        tDiskCulprit = T(postCulprit) ;
                                        postCulprit[ 3 ] = ostCulprit ;
                                        osTextT postCulprit[] = "///?/" ;
                                    {
                                    if( ostCulprit >= 'a' && ostCulprit <= 'z' ) 
                                    osTextT ostCulprit = (osTextT)( POOP >> 0x18 ) ;
                                    TN( tDiskCulprit , "" ) ;
                                {
                                if( POOP )
                                ((tinNormalS&)tinBaseP).pEtScratch->diskFindFileOrDirF( tinBaseP , pstt1Archives2 , psttc1 ) ; ___( pstt1Archives2 ) ;
                                SCOOPS
                                _IO_
                            {
                            IFsCRATCH
                            ZE( strokeS* , pstt1Archives2 ) ;

                            //etherP.traceF( tinBaseP , T("[archives found on pseudoVolume]:    ")+T(psttc1) ) ;

                            if( idLoop ++ ) { BLAMMO ; }
                        {
                        FORsTRINGSiN1( pstt1Archives )
                        ZE( countT , idLoop ) ;
                    {
                    else
                    if( bAbortP ) break ;

                    }
                        }
                            break ;
                            bAbortP = 1 ;
                            etherP.traceF( tinBaseP , T("!exception:  diskFindFileOrDirF ; aborting [pseudoVolume]:    ")+T(psttc1) ) ;
                            POOPRqUIET
                        {
                        if( POOP )
                        ((tinNormalS&)tinBaseP).pEtScratch->diskFindFileOrDirF( tinBaseP , pstt1Archives , psttc1 , &pat ) ; ___( pstt1Archives ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    patternC pat( tinBaseP , etherP , T("ideafarm.archives/") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                    ZE( strokeS* , pstt1Archives ) ;

                    //etherP.traceF( tinBaseP , T("[pseudoVolume]:    ")+T(psttc1) ) ;
                {
                FORsTRINGSiN1( pstt1PseudoVolumes )
            {
            if( !bAbortP )

            }
                }
                    bAbortP = 1 ;
                    etherP.traceF( tinBaseP , T("!exception:  diskFindFileOrDirF [tLikePseudoVolumes,tDiskCulprit]:    ")+tLikePseudoVolumes+tb4+tDiskCulprit ) ;
                    POOPRqUIET

                    }
                        tDiskCulprit = T(postCulprit) ;
                        postCulprit[ 3 ] = ostCulprit ;
                        osTextT postCulprit[] = "///?/" ;
                    {
                    if( ostCulprit >= 'a' && ostCulprit <= 'z' ) 
                    osTextT ostCulprit = (osTextT)( POOP >> 0x18 ) ;
                    TN( tDiskCulprit , "" ) ;
                {
                if( POOP )
                ((tinNormalS&)tinBaseP).pEtScratch->diskFindFileOrDirF( tinBaseP , pstt1PseudoVolumes , tLikePseudoVolumes ) ; ___( pstt1PseudoVolumes ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCH
            ZE( strokeS* , pstt1PseudoVolumes ) ;
            _IO_
        {
        if( !bAbortP )
        ZE( countT , cPseudoVolumes ) ;
        //etherP.traceF( tinBaseP , T("accumulating archives mounted in ")+tLikePseudoVolumes ) ;

        stackC stArchive( tinBaseP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
        cArchive = bAbortP = 0 ;
        _IO_
    {
    while( !etPrime )
    #endif
        //TN( tLikePseudoVolumes , "///ideafarm/devices/"          ) ;
        TN( tLikePseudoVolumes , "///d/ideafarm.home.101/devices/" ) ;
    #else
        TN( tLikePseudoVolumes , "///d/ideafarm.home.101/devices/" ) ;
    #if defined( IFCtESTING )
    TN( tLikeArchives1 , "///?/ideafarm.archives/" ) ;
    ZE( strokeS* , pstt1ArchivesAllLag ) ;

    ZE( countT , cArchive ) ;
    TN( tb4 , "    " ) ;

    etherC& etPrime = etherC::etPrimeIF() ;
{
countT loadArchivePathsF( tinBaseS& tinBaseP , etherC& etherP , boolT& bAbortP , switchStackC& swsPathToArchivesByArchiveNameP , strokeS*& psttzArchiveP , stackC& stPathToArchivesP )

}
    etherP.traceF( tinBaseP , T("zipDayF / ----") ) ;
    }
        }
            }
                }
                    }
                        if( bZippedAok ) etherP.traceF( tinBaseP , T("!exception: could not reset some file attribute flags [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+tLongChunk ) ;
                        bAbortP = 1 ;
                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )                                                                                                  // EXPECTED IF !bZippedAok
                    ((tinNormalS&)tinBaseP).pEtScratch->diskFileSetAttrF( tinBaseP , tLongChunk , flagsAttributeNow.c1 , flagsAttributeNow.c2 ) ;
                {
                if( flagsAttributeNow.c1 != flagsAttributeWas.c2 )
                //etherP.traceF( tinBaseP , T("now [flagsAttributeNow]:    ")+TF3(flagsAttributeNow.c1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+tLongChunk ) ;

                }
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_PINNED             ) ) ;
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_EA                 ) ) ;
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_NO_SCRUB_DATA      ) ) ;
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_VIRTUAL            ) ) ;
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_INTEGRITY_STREAM   ) ) ;
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_ENCRYPTED          ) ) ;
                      flagsAttributeNow.c1 |=      flFILEaTTR1_NOT_CONTENT_INDEXED    ;     //PS:PERSONALITY: I ALWAYS SET THIS BECAUSE I PRESUME THAT INDEXING OF THE CONTENTS OF THE ARCHIVE IS UNDESIRABLE (DUE TO COST)
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_OFFLINE            ) ) ;
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_REPARSE_POINT      ) ) ;
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_SPARSE_FILE        ) ) ;
                      flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_TEMPORARY          ) ) ;
                      flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_DEVICE             ) ) ;
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_COMPRESSED         ) ) ;
                      flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_ARCHIVE            ) ) ;
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_DIRECTORY          ) ) ;
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_DOTdIRECTORY       ) ) ;
                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_SYSTEM             ) ) ;
                      flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_HIDDEN             ) ) ;
                      flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_READoNLY           ) ) ;
                      flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_NORMAL             ) ) ;
                {
                if( !( F(flagsAttributeWas.c1) & flFILEaTTR1_SYSTEM ) )

                //CS:CODEsYNC: 51000806 1120000b 112005e2

                count2S flagsAttributeNow  = flagsAttributeWas ;

                //etherP.traceF( tinBaseP , T("was [flagsAttributeWas]:    ")+TF3(flagsAttributeWas.c1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+tLongChunk ) ;
                count2S flagsAttributeWas = ((tinNormalS&)tinBaseP).pEtScratch->diskFileQueryAttrF( tinBaseP , tLongChunk ) ;

                SCOOPS
                _IO_
            {                   // PS:PERSONALITY: RESET ALL ATTRIBUTE FLAGS THAT THE BASE O.S. ALLOWS APPLICATION CODE TO MODIFY
            IFsCRATCH           // RESET ALL VOLATILE FILE ATTRIBUTE FLAGS TO PREVENT DIFFERENCES IN THESE FLAGS ACROSS DEVICES FROM RESULTING IN DIFFERENCES IN THE CHUNK FILE ACROSS DEVICES
            //CS:CODEsYNC: 51000806 51000806

            }
                }
                    }
                        etherP.traceF( tinBaseP , T("!exception: could not set file time [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+tPathYear+tShortDayZipP ) ;
                        bAbortP = 1 ;
                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )

                    ((thirdC&)etherP).setFileTimeF( tinBaseP , fiw , &timeWrittenNewest , &timeWrittenNewest , &timeWrittenNewest ) ;
                {
                else
                }
                    if( bZippedAok ) etherP.traceF( tinBaseP , T("!exception: could not open file WR 0 [name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+tPathYear+tShortDayZipP ) ;
                    bAbortP = 1 ;
                    const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                {
                if( POOP )  // EXPECTED IF !bZippedAok

                fileC fiw( tinBaseP , (strokeS*)tLongChunk , ifcOPENaCCESS_WR , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                SCOOPS
                _IO_
            {
            IFsCRATCH           // EVEN IF bAbortP, I TRY TO SET THE TIMESTAMPS OF THE DAY CHUNK ZIP FILE TO PREVENT A MISTIMED ARCHIVE FILE FROM EXISTING
            TN( tLongChunk , "" ) ; tLongChunk = tPathYear+tShortDayZipP ;

            }
                if( !bZippedAok ) etherP.traceF( tinBaseP , T(bZippedAok?"zipped aok":"zip failed") ) ;

                }
                    }
                        //    IF THE ZIP FAILED, EVEN IF THE CHUNK FILE CONTAINS CORRUPTION, THE FSET FILES WILL REMAIN SO WILL BE ZIPPED INTO THE CHUNK FILE ON THE NEXT HEAL, FIXING IT
                        //    IF THE ERROR IS A FALSE POSITIVE AND THE ZIP REALLY SUCCEEDED, THE CHUNK FILE CONTAINS VALUABLE DATA THAT IS NO LONGER PRESENT AS FSET FILES
                        //DO NOT DELETE THE CHUNK FILE

                        etherP.traceF( tinBaseP , T("!exception: kid process failed [value,rc,name]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+tLong ) ;
                        TN( tLong , "" ) ; tLong = tPathYear+tShortDayZipP ;

                        bAbortP = 1 ;
                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    else
                    if( !POOP ) bZippedAok = 1 ;

                    }
                        __1
                        __( value ) ;
                    {
                    if( value != ifcEXITcODE_EXITpROCESSaOK )

                    ((tinNormalS&)tinBaseP).pEtScratch->osProcessWaitF( tinBaseP , value , countTC() , osTid , osPid ) ;
                    ZE( countT , value ) ;

                    SCOOPS
                    _IO_
                {
                IFsCRATCH
            {
            else
            }
                etherP.traceF( tinBaseP , T("!exception: could not launch zip process [path,day]:    ")+tPathYear+tb4+tDayPrefixP ) ;
                bAbortP = 1 ;
            {
            if( !osPid )
            ZE( boolT , bZippedAok ) ;

            THREADmODE2rESTORE
            }
                c4Result = etherP.ifcHireF( tinBaseP , T("ifcIDaDAM_HEALaRCHIVES") , ifcIDaDAM_HIREwITHOUTdEBUGGING , tArgs , flHIRE_DISPLAYaUTO , 0 , 0 , 1 , nicNameC() ) ; // tPathYear IS PASSED AS ARGUMENT SO THAT IT IS VISIBLE IN TRACE FOR THE KID PROCESS
                hoverC hover( tinBaseP , etherP , tPathYear ) ;
                //etherP.traceF( tinBaseP , T("zipping [tArgs]:    ")+tArgs ) ;
                TN( tArgs , "" ) ; tArgs = T("!ignore ")+tPathYear+T(" !maxValue 0 !hireLater pkzipc.exe -store -add -move ")+tShortDayZipP+tb+tDayPrefixP+tAtAsterisk ; // MAXvALUE 0 BECAUSE pkzipc.exe WILL NOT DELETE THE SOURCE FILES IF EVEN A MINOR WARNING OCCURS ; IF ZIP FAILS THEN DELETE THE CHUNK FILE AFTER VERIFYING THAT EVERY FILE WITHIN IT IS ALSO PRESENT IN THE ARCHIVE
                _IO_
            {
            countT& osPid = c4Result.c2 ;
            countT& osTid = c4Result.c1 ;
            count4S c4Result ;
            THREADmODE2oN( flTHREADmODE2_ALLOWmULTItHREADEDhOVER | flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

            inc02AM( cNewChunksP ) ;    // INTENTIONALLY INCREMENTED FOR EACH HIRE, NOTWITHSTANDING WHETHER THE HIRE SUCCEEDED OR A CHUNK FILE WAS REALLY CREATED ; AS OF THIS WRITING, THIS IS ONLY USED TO DETECT WHETHER THE LIST OF SHORT NAME SHOULD BE PRESUMED TO BE STALE
            etherP.traceF( tinBaseP , T("zipDayF calling ifcHireF [tDayPrefix,path]:    ")+tDayPrefixP+tb4+tPathYear ) ;
        {
        if( !bAbortP )

        if( !timeWrittenNewest ) continue ;     // TIME WILL BE 0 IF NO AT FILES WERE FOUND

        }
            if( idPass == 1 ) cAtFiles = idAtFile ;

            while( ~hFindFile && !POOP ) ;
            }
                DEL( pInfoFile ) ;
                }
                    }
                        }
                            }
                                }
                                    }
                                        etherP.traceF( tinBaseP , T("!exception: could not reset some file attribute flags [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+T(pInfoFile->psttIfoName) ) ;
                                        bAbortP = 1 ;
                                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                        POOPRqUIET
                                        countT rc = POOP ;
                                    {
                                    if( POOP )
                                    ((tinNormalS&)tinBaseP).pEtScratch->diskFileSetAttrF( tinBaseP , pInfoFile->psttIfoName , flagsAttributeNow.c1 , flagsAttributeNow.c2 ) ;
                                {
                                if( flagsAttributeNow.c1 != flagsAttributeWas.c2 )
                                //etherP.traceF( tinBaseP , T("now [flagsAttributeNow]:    ")+TF3(flagsAttributeNow.c1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+tLongAt ) ;

                                }
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_PINNED             ) ) ;
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_EA                 ) ) ;
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_NO_SCRUB_DATA      ) ) ;
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_VIRTUAL            ) ) ;
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_INTEGRITY_STREAM   ) ) ;
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_ENCRYPTED          ) ) ;
                                      flagsAttributeNow.c1 |=      flFILEaTTR1_NOT_CONTENT_INDEXED    ;     //PS:PERSONALITY: I ALWAYS SET THIS BECAUSE I PRESUME THAT INDEXING OF THE CONTENTS OF THE ARCHIVE IS UNDESIRABLE (DUE TO COST)
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_OFFLINE            ) ) ;
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_REPARSE_POINT      ) ) ;
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_SPARSE_FILE        ) ) ;
                                      flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_TEMPORARY          ) ) ;
                                      flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_DEVICE             ) ) ;
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_COMPRESSED         ) ) ;
                                      flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_ARCHIVE            ) ) ;
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_DIRECTORY          ) ) ;
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_DOTdIRECTORY       ) ) ;
                                    //flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_SYSTEM             ) ) ;
                                      flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_HIDDEN             ) ) ;
                                      flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_READoNLY           ) ) ;
                                      flagsAttributeNow.c1 &= ~( F(flFILEaTTR1_NORMAL             ) ) ;
                                {
                                if( !( F(flagsAttributeWas.c1) & flFILEaTTR1_SYSTEM ) )

                                //CS:CODEsYNC: 51000806 1120000b 112005e2

                                count2S flagsAttributeNow  = flagsAttributeWas ;

                                //etherP.traceF( tinBaseP , T("was [flagsAttributeWas]:    ")+TF3(flagsAttributeWas.c1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+tLongAt ) ;
                                count2S flagsAttributeWas = ((tinNormalS&)tinBaseP).pEtScratch->diskFileQueryAttrF( tinBaseP , tLongAt ) ;

                                SCOOPS
                                _IO_
                            {                   // PS:PERSONALITY: RESET ALL ATTRIBUTE FLAGS THAT THE BASE O.S. ALLOWS APPLICATION CODE TO MODIFY
                            IFsCRATCH           // RESET ALL VOLATILE FILE ATTRIBUTE FLAGS TO PREVENT DIFFERENCES IN THESE FLAGS ACROSS DEVICES FROM RESULTING IN DIFFERENCES IN THE CHUNK FILE ACROSS DEVICES
                            //CS:CODEsYNC: 51000806 51000806

                            }
                                }
                                    }
                                        etherP.traceF( tinBaseP , T("!exception: could not set file time [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+tLongAt ) ;
                                        bAbortP = 1 ;
                                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                        POOPRqUIET
                                        countT rc = POOP ;
                                    {
                                    if( POOP )

                                    ((thirdC&)etherP).setFileTimeF( tinBaseP , fiw , &timeWrittenNewest , &timeWrittenNewest , &timeWrittenNewest ) ;
                                {
                                else
                                }
                                    etherP.traceF( tinBaseP , T("!exception: could not open file WR 0 [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+tLongAt ) ;
                                    bAbortP = 1 ;
                                    const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                    POOPRqUIET
                                    countT rc = POOP ;
                                {
                                if( POOP )

                                fileC fiw( tinBaseP , (strokeS*)tLongAt , ifcOPENaCCESS_WR , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                                SCOOPS
                                _IO_
                            {
                            IFsCRATCH
                            TN( tLongAt , pInfoFile->psttIfoName ) ;
                            //etherP.traceF( tinBaseP , T("zipDayF pass 2 [tShort]:    ")+tShort ) ;
                        {
                        else if( cAtFiles > 1 )     // NO NEED TO SET FILE TIME TO NEWEST FILE TIME IF THIS FILE IS ALONE
                        }
                            }
                                //etherP.traceF( tinBaseP , T("[timeWritten,timeWrittenNewest]:    ")+TT(timeWritten.time1,timeWritten.time2)+tb4+TT(timeWrittenNewest.time1,timeWrittenNewest.time2) ) ;
                                //etherP.traceF( tinBaseP , T("zipDayF pass 1 [tShort]:    ")+tShort ) ;

                                if( timeWrittenNewest.time2 < timeWritten.time2 || ( timeWrittenNewest.time2 == timeWritten.time2 && timeWrittenNewest.time1 < timeWritten.time1 ) ) timeWrittenNewest = timeWritten ;

                                }
                                    }
                                        }
                                            }
                                                etherP.traceF( tinBaseP , T("!exception: could not get file time [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+T(pInfoFile->psttIfoName) ) ;
                                                bAbortP = 1 ;
                                                const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                POOPRqUIET
                                                countT rc = POOP ;
                                            {
                                            if( POOP )

                                            thirdC::getFileTimeIF( tinBaseP , fir , &timeWritten , 0 , 0 ) ;
                                        {
                                        else
                                        }
                                            etherP.traceF( tinBaseP , T("!exception: could not open file R R [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+T(pInfoFile->psttIfoName) ) ;
                                            bAbortP = 1 ;
                                            const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                            POOPRqUIET
                                            countT rc = POOP ;
                                        {
                                        if( POOP )

                                        fileC fir( tinBaseP , pInfoFile->psttIfoName , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                                        SCOOPS
                                        _IO_
                                    {
                                    IFsCRATCH
                                {
                                timeS timeWritten = timeS() ;
                            {
                            if( !etherP.strIdF( tinBaseP , tDotHeyDot , pInfoFile->psttIfoName , 1 ) )      // IF NOT A CONTROL FILE ; (SUCH FILES ARE USED E.G. TO CONTROL REPORTING OF THE ARCHIVE, CAN BE ADDED TO THE ARCHIVE AT ANY TIME, AND ARE UNRELATED TO THE CONTENT OF THE ARCHIVE, SO SHOULD NOT BE ALLOWED TO AFFECT THE TIMESTAMP OF A DAY CHUNK)

                            idAtFile ++ ;
                        {
                        if( idPass == 1 )
                    {
                    if( tShort.csF( tinBaseP ) )        // IF NOT A DIRECTORY

                    }
                        etherP.delF( tinBaseP , psttShort ) ;
                        etherP.delF( tinBaseP , psttnu ) ;
                        tShort  = T(psttShort) ;
                        etherP.strBisectF( tinBaseP , psttnu , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShort , "" ) ;
                {
                if( !bAbortP && !etPrime && pInfoFile && pInfoFile->psttIfoName )

                }
                    }
                        etherP.strMakeFromOsTextF( tinBaseP , pInfoFile->psttIfoName , iffn ) ; ___( pInfoFile->psttIfoName ) ;
                        ifFileNameC iffn( tinBaseP , etherP , pInfoFile->postOsName ) ;
                    {
                    if( !bAbortP && pInfoFile && !pInfoFile->psttIfoName )

                    }
                        }
                            etherP.traceF( tinBaseP , T("!exception: find file failed [rc,postRc,like]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+T(osfnLike) ) ;
                            bAbortP = 1 ;
                            const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                            POOPRqUIET
                            countT rc = POOP ;
                        {
                        if( POOP )

                        ((thirdC&)*((tinNormalS&)tinBaseP).pEtScratch).dosFindFileOrDirPrivateF( tinBaseP , pInfoFile , hFindFile , osfnLike ) ;

                        SCOOPS
                        _IO_
                    {
                    IFsCRATCH

                    //etherP.traceF( tinBaseP , T("like:    ")+tLike ) ;
                    osFileNameC osfnLike( tinBaseP , etherP , tLike ) ;
                    TN( tLike , "" )  ; tLike = tPathYear+tPattern ;
                {
                ZE( infoFileS* , pInfoFile ) ;
                _IO_
            {
            do
            handleC hFindFile( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            ZE( countT , idAtFile ) ;

            //etherP.traceF( tinBaseP , T("zipDayF [idPass,path,tDay]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tPathYear+tb4+tDayPrefixP ) ;

            if( idPass == 2 && !timeWrittenNewest ) break ;
            _IO_
        {
        for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
        ZE( countT , cAtFiles ) ;                // AN "AT FILE" IS A FILE THAT CONTAINS AN '@' IMMEDIATELY AFTER THE DAY PREFIX, I.E. A FILE WITH A NAME THAT CONTAINS A FULL TIMESTAMP ; THE DAY CHUNK FILE IS NOT AN AT FILE
        TN( tPattern  , "" ) ; tPattern  = tDayPrefixP+tAtAsterisk ;
        TN( tPathYear , "" ) ; tPathYear = T(ppsttPathToYearP[offi]) ;
        timeS timeWrittenNewest = timeS() ;
        //PASS 1: GET THE MOST RECENT FILE TIME MODIFIED ; PASS 2: SET ALL FILE TIMES TO THE MOST RECENT TIME ; (NOTE: IF A DAY CHUNK ZIP FILE IS BEING UPDATED, EXISTING ITEMS NOT UPDATED WILL RETAIN THEIR EARLIER TIME)

        if( offDoP != -1 && offi != offDoP ) continue ;
        if( etPrime ) break ;
        _IO_
    {
    for( countT offi = 0 ; !bAbortP && offi < cPathsToYearP ; offi ++ )
    TN( tDotHeyDot , ".!." ) ;
    TN( tAtAsterisk , "@*" ) ;
    TN( tb4  , "    " ) ;
    TN( tb   , " " ) ;
    etherC& etPrime = etherC::etPrimeIF() ;
    etherP.traceF( tinBaseP , T("zipDayF / ++++") ) ;
    _IO_
{
voidT zipDayF( tinBaseS& tinBaseP , etherC& etherP , boolT& bAbortP , countT& cNewChunksP , countT cPathsToYearP , strokeS** ppsttPathToYearP , textC& tShortDayZipP , textC& tDayPrefixP , countT offDoP )

//U::O: ZIP EACH DEVICE WO DAY AT A TIME BUT NOT WAITING FOR ALL DEVICES TO BE ZIPPED FOR A DAY ; THE CURRENT CODE PROCEEDS AT THE PACE OF THE SLOWEST DEVICE, LEAVING FASTER DEVICES IDLE

}
    return pJob1->idName - pJob2->idName ;

    jobHealFileS* pJob2 = (jobHealFileS*)c2P ;
    jobHealFileS* pJob1 = (jobHealFileS*)c1P ;
{
countT _export subtractHealFileJobF( tinBaseS& tinBaseP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    // /* if( bChatterP )*/ pP.ether.traceF( tinBaseP , T("healed  ---- [idName]:    ")+TF2(idNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    }
        }
            //((tinNormalS&)tinBaseP).pc Utility[ 0 ] -- ;

            //pP.ether.traceF( tinBaseP , T("    ---- watch") ) ;
            //pP.ether.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_UNWATCH ) ;
        {
        if( bChatterP )

        //if( !pP.bAbort ) pP.ether.traceF( tinBaseP , T("---- healed  [tShort]:    ")+tShortP ) ;

        }
            //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 00") ) ;
            }
                THREADmODE2rESTORE
                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 10") ) ;
                }
                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 20") ) ;
                    }
                        }
                            //pP.ether.traceF( tinBaseP , T("healed [cShortNames,idName,cRemaining,perTuckDone,timePerTock,timeE1,cbUsedMax,cbUsedHighMax,tShort]:    ")+TF3(cShortNamesP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF3(idNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF3(cRemaining,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF3(perTuckDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,3)+tPerTuck+tb4+TF3(timePerTock,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF3(timeE1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF3(cbUsedMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb+TF3(cbUsedHighMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+tShortP ) ;

                            countT perTuckDone = !cShortNamesP ? 0 : ( idNameP << 8 ) / cShortNamesP ;
                            countT cRemaining = cShortNamesP - idNameP ;

                            countT timePerTock = !c4Tock ? 0 : (countT)( c4Time / c4Tock ) ;

                            count04T& c4Time = *(count04T*)pcTime ;
                            countT pcTime[] = { timeE1 , timeE2 } ;

                            count04T  c4Tock = c4Used / TOCK ;
                            count04T& c4Used = *(count04T*)pcUsed ;
                            countT pcUsed[] = { cbUsedMax , cbUsedHighMax } ;

                            pP.ether.osTimeSubtractF( tinBaseP , timeE1 , timeE2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO HEAL THIS SHORT NAME
                            pP.ether.osTimeNowF( tinBaseP , timeE1 , timeE2 ) ;
                            ZE( sCountT , timeE2 ) ;
                            ZE( countT  , timeE1 ) ;
                            _IO_
                        {
                        //)
                        //    )
                        //        !( idNameP % ( TUCK >> 2 ) )
                        //        ||
                        //        ( cbUsedHighMax || cbUsedMax > ( TOCK << 2 ) )
                        //    (
                        //    &&
                        //    !pP.bAbort
                        //(
                        //if

                        //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 30") ) ;
                        }
                            //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 40") ) ;
                            }
                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 50") ) ;
                                }
                                    while( ~hStkMeta ) ;
                                    }
                                        DELzOMBIE( pfmOuter ) ;

                                        }
                                            DELzOMBIE( pd ) ;
                                            imageCompareS* pd = picOuter + offd ;
                                            _IO_
                                        {
                                        for( countT offd = 0 ; offd < pP.cResultStructsNeeded ; offd ++ )

                                        fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + pP.cResultStructsNeeded ) ;
                                        imageCompareS* picOuter  = (imageCompareS*)&stMeta.upF( tinBaseP , hStkMeta ) ;
                                        _IO_
                                    {
                                    do
                                    handleC hStkMeta( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    _IO_
                                {
                                if( stMeta )
                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 60") ) ;
                                //pP.ether.traceF( tinBaseP , T("deleting metadata [cPlates]:    ")+TF2(stMeta,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                //pP.ether.traceF( tinBaseP , T("healed  [result,tArchive,tYear,tShort]:    ")+T(pP.bAbort?"aborted    ":"aok    ")+pP.tArchive+tb4+pP.tYear+tb4+tShortP ) ;

                                //pP.ether.traceF( tinBaseP , T("processed  [tShort]:    ")+tShortP ) ;

                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // ****                                                                                                                                  *******************************************************************
                                // ****  END:    COMPARE ALL COPIES OF THIS SHORT FILE NAME.  THIS IS RETRIED UNTIL ALL COMPARISONS COMPLETE WITHOUT AN EXCEPTION EVENT  *******************************************************************
                                // ****                                                                                                                                  *******************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                _IO_
                            {
                            if( !pP.bAbort )

                            //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 70") ) ;
                            }
                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 80") ) ;
                                }
                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                *************************************************************************************************************************************************************************************
                                    // ****  END:    HEAL  *************************************************************************************************************************************************************************************
                                    // ****                *************************************************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************

                                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 90") ) ;
                                    }
                                        //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / a0") ) ;
                                        }
                                            //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / b0") ) ;
                                            }
                                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / c0") ) ;
                                                }
                                                    }
                                                        pP.ether.delF( tinBaseP , psttFrom ) ;
                                                        pP.ether.delF( tinBaseP , psttTo   ) ;

                                                        }
                                                            }
                                                                //if( !pP.bAbort ) pP.ether.traceF( tinBaseP , T("copied [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;

                                                                }
                                                                    }
                                                                        }
                                                                            break ;
                                                                            pP.bAbort = 1 ;
                                                                            pP.ether.traceF( tinBaseP , T("!exception:  unexpected impotence copy [rc,postRc,to,from]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc)+T("    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                            const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                                            _IO_
                                                                            POOPRqUIET
                                                                            countT rc = POOP ;
                                                                        {
                                                                        else
                                                                        }
                                                                            thirdC::dosSleepWinkIF( tinBaseP , 2 ) ;
                                                                            pP.ether.traceF( tinBaseP , T("!exception:  could not copy file (access denied)) ; will retry until fired [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                            _IO_
                                                                            POOPRqUIET
                                                                        {
                                                                        else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_ACCESSdENIED )
                                                                        }
                                                                            break ;
                                                                            pP.ether.traceF( tinBaseP , T("!exception: could not copy file because destination device is write protected [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                            _IO_
                                                                            POOPRqUIET
                                                                        {
                                                                        else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_WRITEpROTECT )
                                                                        if( !POOP ) break ;
                                                                        ((tinNormalS&)tinBaseP).pEtScratch->diskCopyFileF( tinBaseP , psttTo , psttFrom , 1 ) ;
                                                                        SCOOPS
                                                                        _IO_
                                                                    {
                                                                    IFsCRATCH
                                                                    _IO_
                                                                {
                                                                while( !etPrime )

                                                                pP.ether.traceF( tinBaseP , T("copying [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                _IO_
                                                            {
                                                            else
                                                            }
                                                                else pP.ether.traceF( tinBaseP , T("flHEALmODE_NOmOVEoRrEPLACE is set so the target file exists and was not moved out of the way and am not copying to target [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                }
                                                                    pP.ether.traceF( tinBaseP , T("!exception: bizarre!  there is still a file in the way, so not copying [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                    pP.bAbort = 1 ;
                                                                {
                                                                else if( !( F(flagsModeP) & flHEALmODE_NOmOVEoRrEPLACE ) )
                                                                if( bReadOnly ) ;
                                                                _IO_
                                                            {
                                                            else if( bExists )
                                                            }
                                                                }
                                                                    pP.ether.traceF( tinBaseP , T("!exception: after rejecting a file out of the way, not copying because could not obtain bExists (probable drive failure) [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                {
                                                                if( !( F(flagsModeP) & flHEALmODE_NOmOVEoRrEPLACE ) )
                                                                _IO_
                                                            {
                                                            if( pP.bAbort )

                                                            }
                                                                }
                                                                    }
                                                                        pP.bAbort = 1 ;
                                                                        pP.ether.traceF( tinBaseP , T("!exception: diskFileExistsF failed FOR psttTol 2 [rc,postRc,to,from]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                                        POOPRqUIET
                                                                        countT rc = POOP ;
                                                                    {
                                                                    if( POOP )
                                                                    bExists = ((tinNormalS&)tinBaseP).pEtScratch->diskFileExistsF( tinBaseP , psttTo ) ;

                                                                    _IO_
                                                                    SCOOPS
                                                                {
                                                                IFsCRATCH
                                                                _IO_
                                                            {
                                                            if( !( F(flagsModeP) & flHEALmODE_NOmOVEoRrEPLACE ) )

                                                            // *********************************************************************************************************************************************************************************************************
                                                            // ****                                                  ***************************************************************************************************************************************************
                                                            // ****  COPY AUTHORITATIVE FILE TO WO RECIPIENT VOLUME  ***************************************************************************************************************************************************
                                                            // ****                                                  ***************************************************************************************************************************************************
                                                            // *********************************************************************************************************************************************************************************************************

                                                            }
                                                                pP.ether.delF( tinBaseP , psttLongInRejects ) ;

                                                                }
                                                                    if( bDone ) pP.ether.traceF( tinBaseP , T("moved [toInRejects,to]:    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;

                                                                    }
                                                                        }
                                                                            }
                                                                                break ;
                                                                                pP.bAbort = 1 ;
                                                                                pP.ether.traceF( tinBaseP , T("!exception:  unexpected impotence [rc,postRc,toInRejects,to]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc)+T("    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;
                                                                                const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                                                POOPRqUIET
                                                                                countT rc = POOP ;
                                                                            {
                                                                            else
                                                                            }
                                                                                thirdC::dosSleepWinkIF( tinBaseP , 2 ) ;
                                                                                pP.ether.traceF( tinBaseP , T("!exception:  could not move file (access denied) ; will retry until fired [toInRejects,to]:    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;
                                                                                POOPRqUIET
                                                                            {
                                                                            else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_ACCESSdENIED )
                                                                            }
                                                                                break ;
                                                                                bReadOnly = 1 ;
                                                                                pP.ether.traceF( tinBaseP , T("!exception: could not move file out of the way because destination device is write protected [to,from]:    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;
                                                                                POOPRqUIET
                                                                            {
                                                                            else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_WRITEpROTECT )
                                                                            }
                                                                                break ;
                                                                                bDone = 1 ;
                                                                            {
                                                                            if( !POOP )
                                                                            ((tinNormalS&)tinBaseP).pEtScratch->diskMoveFileOrDirF( tinBaseP , psttLongInRejects , psttTo , 1 ) ;
                                                                            SCOOPS
                                                                        {
                                                                        IFsCRATCH
                                                                        _IO_
                                                                    {
                                                                    while( !etPrime )
                                                                    ZE( boolT , bDone ) ;
                                                                    _IO_
                                                                {
                                                                else
                                                                if( F(flagsModeP) & flHEALmODE_NOmOVEoRrEPLACE ) pP.ether.traceF( tinBaseP , T("flHEALmODE_NOmOVEoRrEPLACE is set and the target file exists so i will not move file [toInRejects,to]:    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;

                                                                pP.ether.strReplaceF( tinBaseP , psttLongInRejects , psttTo , pP.tPathArchives , pP.tPathRejects ) ; ___( psttLongInRejects ) ;
                                                                ZE( strokeS* , psttLongInRejects ) ;
                                                                _IO_
                                                            {
                                                            if( bExists )
                                                            ZE( boolT , bReadOnly ) ;
                                                            _IO_
                                                        {
                                                        if( !pP.bAbort )

                                                        }
                                                            }
                                                                pP.bAbort = 1 ;
                                                                pP.ether.traceF( tinBaseP , T("!exception: diskFileExistsF failed FOR psttTo [rc,postRc,to,from]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                                POOPRqUIET
                                                                countT rc = POOP ;
                                                                _IO_
                                                            {
                                                            if( POOP )
                                                            bExists = ((tinNormalS&)tinBaseP).pEtScratch->diskFileExistsF( tinBaseP , psttTo ) ;

                                                            _IO_
                                                            SCOOPS
                                                        {
                                                        IFsCRATCH
                                                        ZE( boolT , bExists ) ;

                                                        // *********************************************************************************************************************************************************************************************************
                                                        // ****                                   ******************************************************************************************************************************************************************
                                                        // ****  MOVE TARGET FILE OUT OF THE WAY  ******************************************************************************************************************************************************************
                                                        // ****                                   ******************************************************************************************************************************************************************
                                                        // *********************************************************************************************************************************************************************************************************

                                                        //pP.ether.traceF( tinBaseP , T("new      [psttTo,psttFrom]:    ")+TF2((countT)psttTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)psttFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                                        //pP.ether.traceF( tinBaseP , T("copying [idFrom,to,from]:    ")+TF2(idFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttTo)+tb4+T(psttFrom) ) ;

                                                        pP.ether.strMakeF( tinBaseP , LF , psttFrom , (strokeS*)stFrom[ idFrom ] ) ; ___( psttFrom ) ;
                                                        ZE( strokeS* , psttFrom ) ;

                                                        countT idFrom = 1 + ( cDone ++ % cFrom ) ;

                                                        stTo >> psttTo ;
                                                        ZE( strokeS* , psttTo ) ;
                                                        _IO_
                                                    {
                                                    while( !pP.bAbort && stTo )
                                                    ZE( countT , cDone ) ;
                                                    countT cFrom = stFrom ;

                                                    // *********************************************************************************************************************************************************************************************************
                                                    // ****                                              *******************************************************************************************************************************************************
                                                    // ****  COPY AUTHORITATIVE FILES TO TARGET VOLUMES  *******************************************************************************************************************************************************
                                                    // ****                                              *******************************************************************************************************************************************************
                                                    // *********************************************************************************************************************************************************************************************************
                                                    _IO_
                                                {
                                                if( !pP.bAbort )
                                                pauseIfF( tinBaseP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / d0") ) ;

                                                }
                                                    }
                                                        if( !idSlot ) pP.ether.delF( tinBaseP , psttLong ) ;
                                                        stTo.sinkF( tinBaseP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ;
                                                        ZE( countT , idSlot ) ;
                                                        // //pP.ether.traceF( tinBaseP , T("sinking to stTo 2 [long]:    ")+T(psttLong) ) ;
                                                    {
                                                    else
                                                    if( stFrom( psttLong ) ) pP.ether.delF( tinBaseP , psttLong ) ;

                                                    pP.ether.strMakeF( tinBaseP , LF , psttLong , T(psttPathToYear)+tShortP ) ; ___( psttLong ) ;
                                                    ZE( strokeS* , psttLong ) ;

                                                    const strokeS* psttPathToYear = pP.pzpsttPathToYear[ offi ] ;
                                                    _IO_
                                                {
                                                for( countT offi = 0 ; !pP.bAbort && offi < pP.cPathsToYear ; offi ++ )

                                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / e0") ) ;

                                                // *********************************************************************************************************************************************************************************************************
                                                // ****                                            *********************************************************************************************************************************************************
                                                // ****  LOAD stTo WITH LONG FILE NAMES NOT FOUND  *********************************************************************************************************************************************************
                                                // ****                                            *********************************************************************************************************************************************************
                                                // *********************************************************************************************************************************************************************************************************

                                                while( !pP.bAbort && ~hStUnique ) ;
                                                }
                                                    }
                                                        while( ~hStkInner ) ;
                                                        }
                                                            }
                                                                if( !idSlot ) pP.ether.delF( tinBaseP , psttLong ) ;
                                                                }
                                                                    stTo.sinkF( tinBaseP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                                    // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("sunk into stTo [cPlatesBefore,long]:    ")+TF2(stTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                                    _IO_
                                                                {
                                                                else
                                                                }
                                                                    stFrom.sinkF( tinBaseP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                                    // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("sunk into stFrom [cPlatesBefore,long]:    ")+TF2(stFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                                    _IO_
                                                                {
                                                                if( bYoungestUse && bWinner )
                                                                ZE( countT , idSlot ) ;

                                                                pP.ether.strMakeF( tinBaseP , LF , psttLong , T(pP.pzpsttPathToYear[pfmInner->idSlotPathToYear-1])+tShortP ) ; ___( psttLong ) ;
                                                                ZE( strokeS* , psttLong ) ;
                                                                _IO_
                                                            {
                                                            if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) )

                                                            }
                                                                }
                                                                    break ;
                                                                    bMatchImage = 0 ;
                                                                {
                                                                if( picUnique[ offc ] - picInner[ offc ] )
                                                            {
                                                            for( countT offc = 0 ; offc < pP.cResultStructsNeeded ; offc ++ )
                                                            boolT bMatchImage = 1 ;

                                                            //picInner->traceF( tinBaseP , pP.tIndent3+T("inner :    ") ) ;
                                                            fileMetaS*     pfmInner = (fileMetaS*)( picInner + pP.cResultStructsNeeded ) ;
                                                            imageCompareS* picInner  = (imageCompareS*)&stMeta.upF( tinBaseP , hStkInner ) ;
                                                            _IO_
                                                        {
                                                        do
                                                        handleC hStkInner( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                        _IO_
                                                    {

                                                    //pfmUnique->traceF( tinBaseP , pP.st O ldPathToYear , T(bYoungestUse?"reporting tallies (youngestNotAlone):    ":"reporting tallies            (other):    ") ) ;

                                                    // //pP.ether.traceF( tinBaseP , pP.tIndent2+T("[bYoungestUse,bWinner,cVotes]:    ")+TF2(bYoungestUse,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bWinner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pfmUnique->cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    boolT bWinner      = pfmUnique->cVotes         == cVotesMaxUse      ;
                                                    boolT bYoungestUse = pfmUnique->timeModRounded == timeModRoundedUse ;

                                                    //for( countT offc = 0 ; offc < pP.cResultStructsNeeded ; offc ++ ) picUnique[ offc ].traceF( tinBaseP , pP.tIndent3+T("reporting tallies:    ") ) ;

                                                    //picUnique->traceF( tinBaseP , pP.tIndent2+T("unique:    ") ) ;
                                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hStUnique ) ;
                                                    _IO_
                                                {
                                                do
                                                handleC hStUnique( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                stackC stTo(     tinBaseP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                                                stackC stFrom(   tinBaseP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

                                                // *********************************************************************************************************************************************************************************************************
                                                // ****                                               ******************************************************************************************************************************************************
                                                // ****  LOAD stTo stFrom WITH LONG FILE NAMES FOUND  ******************************************************************************************************************************************************
                                                // ****                                               ******************************************************************************************************************************************************
                                                // *********************************************************************************************************************************************************************************************************
                                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / f0") ) ;
                                                _IO_
                                            {
                                            else
                                            }
                                                }
                                                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 01") ) ;
                                                    while( !pP.bAbort && ~hStkInner ) ;
                                                    }
                                                        pP.ether.delF( tinBaseP , psttLongFrom ) ;
                                                        pP.ether.delF( tinBaseP , psttLongTo   ) ;

                                                        }
                                                            }
                                                                if( !etPrime ) pP.bAbort = 1 ;
                                                                pP.ether.traceF( tinBaseP , pP.tIndent3+T("!exception:  i never could move file and either i am now fired or i encountered an unexpected impotence, so will purge the pending jobs and fire myself [to,from]:    ")+T(psttLongTo)+T("    ")+T(psttLongFrom) ) ;
                                                            {
                                                            else
                                                            if( bDone ) pP.ether.traceF( tinBaseP , T("moved [to,from]:    ")+T(psttLongTo)+T("    ")+T(psttLongFrom) ) ;

                                                            }

                                                                }
                                                                    }
                                                                        break ;
                                                                        pP.ether.traceF( tinBaseP , pP.tIndent3+T("!exception:  unexpected impotence [rc,postRc,to,from]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc)+T("    ")+T(psttLongTo)+T("    ")+T(psttLongFrom) ) ;
                                                                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                                        POOPRqUIET
                                                                        countT rc = POOP ;
                                                                    {
                                                                    else
                                                                    }
                                                                        thirdC::dosSleepWinkIF( tinBaseP , 2 ) ;
                                                                        pP.ether.traceF( tinBaseP , pP.tIndent3+T("!exception:  could not move file (access denied) ; will retry until fired [to,from]:    ")+T(psttLongTo)+T("    ")+T(psttLongFrom) ) ;
                                                                        POOPRqUIET
                                                                    {
                                                                    else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_ACCESSdENIED )
                                                                    }
                                                                        break ;
                                                                        bDone = 1 ;
                                                                    {
                                                                    if( !POOP )
                                                                    ((tinNormalS&)tinBaseP).pEtScratch->diskMoveFileOrDirF( tinBaseP , psttLongTo , psttLongFrom , 1 ) ;
                                                                    SCOOPS
                                                                    _IO_
                                                                {
                                                                IFsCRATCH
                                                                _IO_
                                                            {
                                                            while( !etPrime )
                                                            ZE( boolT , bDone ) ;
                                                            _IO_
                                                        {

                                                        pP.ether.strReplaceF( tinBaseP , psttLongTo , psttLongFrom , pP.tPathArchives , !bLonely ? pP.tPathRejects : pP.tPathLonely ) ; ___( psttLongTo ) ;
                                                        ZE( strokeS* , psttLongTo ) ;
                                                        //P:PERSONALITY: LONELY FILES (ONLY 1 COPY) ARE MOVED OUT OF ARCHIVE INTO A "LONELY" DIRECTORY

                                                        pP.ether.strMakeF( tinBaseP , LF , psttLongFrom , T(pP.pzpsttPathToYear[pfmInner->idSlotPathToYear-1])+tShortP ) ; ___( psttLongFrom ) ;
                                                        ZE( strokeS* , psttLongFrom ) ;

                                                        fileMetaS*     pfmInner = (fileMetaS*)( picInner + pP.cResultStructsNeeded ) ;
                                                        imageCompareS* picInner  = (imageCompareS*)&stMeta.upF( tinBaseP , hStkInner ) ;
                                                        _IO_
                                                    {
                                                    do
                                                    handleC hStkInner( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                                    pP.ether.traceF( tinBaseP , pP.tIndent1+T("no, or too many (more than 1), winners (authoritative copies) so i will move all copies [bLonely,file]:    ")+TF2(bLonely,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;
                                                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 11") ) ;

                                                    // *********************************************************************************************************************************************************************************************************
                                                    // ****                                         ************************************************************************************************************************************************************
                                                    // ****  NO UNIQUE WINNER SO REJECT ALL COPIES  ************************************************************************************************************************************************************
                                                    // ****                                         ************************************************************************************************************************************************************
                                                    // *********************************************************************************************************************************************************************************************************
                                                    _IO_
                                                {
                                                else
                                                if( F(flagsModeP) & flHEALmODE_NOmOVEoRrEPLACE ) pP.ether.traceF( tinBaseP , pP.tIndent1+T("no, or too many (more than 1), winners (authoritative copies), but because flHEALmODE_NOmOVEoRrEPLACE is set i will NOT move all copies [bLonely,file]:    ")+TF2(bLonely,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;

                                                boolT bLonely = cCopies <= 1 ;
                                                _IO_
                                            {
                                            if( !cWinners || cWinners > 1 )
                                            _IO_
                                        {
                                        if( !pP.bAbort )
                                        pauseIfF( tinBaseP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                        //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 21") ) ;

                                        }
                                            while( !pP.bAbort && ~hSt ) ;
                                            }
                                                cWinners ++ ;
                                                )
                                                    pfmUnique->cVotes == cVotesMaxUse
                                                    &&
                                                    timeModRoundedUse == pfmUnique->timeModRounded
                                                (
                                                if

                                                //picUnique->traceF( tinBaseP , pP.tIndent2+T("unique:    ") ) ;
                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                                            {
                                            do
                                            handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            _IO_
                                        {
                                        if( !pP.bAbort && cVotesMaxUse )

                                        ZE( countT , cWinners ) ;
                                        //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 31") ) ;

                                        // RULE; TO WIN, A SLOT MUST HAVE A "YOUNGEST NOT ALONE" AGE AND BE "NOT ALONE" AND HAVE THE MAXIMUM VOTES FOR SLOTS YOUNGEST AND NOT ALONE
                                        //P:PERSONALITY: RULES FOR "WINNING": A stRecUnique SLOT "WINNING" MEANS THAT THE SLOT IS DEEMED TO BE AN AUTHORITATIVE IMAGE FOR THE FILE

                                        // *********************************************************************************************************************************************************************************************************
                                        // ****                  ***********************************************************************************************************************************************************************************
                                        // ****  TALLY cWinners  ***********************************************************************************************************************************************************************************
                                        // ****                  ***********************************************************************************************************************************************************************************
                                        // *********************************************************************************************************************************************************************************************************

                                        ;
                                            : cVotesMaxYoungestNotAlone
                                            ? cVotesMaxYoungest
                                        countT& cVotesMaxUse = F(flagsModeP) & flHEALmODE_LONELYiSoK

                                        ;
                                            : timeModRoundedYoungestNotAlone
                                            ? timeModRoundedYoungest
                                        countT& timeModRoundedUse = F(flagsModeP) & flHEALmODE_LONELYiSoK

                                        }
                                            while( !pP.bAbort && ~hSt ) ;
                                            }
                                                }
                                                    if( pfmUnique->cVotes > 1 && cVotesMaxYoungestNotAlone < pfmUnique->cVotes ) cVotesMaxYoungestNotAlone = pfmUnique->cVotes ;
                                                {
                                                if( timeModRoundedYoungestNotAlone == pfmUnique->timeModRounded )

                                                }
                                                    if(                          cVotesMaxYoungest         < pfmUnique->cVotes ) cVotesMaxYoungest         = pfmUnique->cVotes ;
                                                {
                                                if( timeModRoundedYoungest == pfmUnique->timeModRounded )

                                                //picUnique->traceF( tinBaseP , pP.tIndent2+T("unique:    ") ) ;
                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                                            {
                                            do
                                            handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            _IO_
                                        {
                                        if( !pP.bAbort && ( timeModRoundedYoungestNotAlone || F(flagsModeP) & flHEALmODE_LONELYiSoK ) )        // IF ALL ARE ALONE THEN THERE WILL BE NO WINNER (UNLESS flHEALmODE_LONELYiSoK)
                                        ZE( countT , cVotesMaxYoungestNotAlone ) ;
                                        ZE( countT , cVotesMaxYoungest         ) ;
                                        //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 41") ) ;

                                        // *********************************************************************************************************************************************************************************************************
                                        // ****                                                          *******************************************************************************************************************************************
                                        // ****  ACCUMULATE cVotesMaxYoungest cVotesMaxYoungestNotAlone  *******************************************************************************************************************************************
                                        // ****                                                          *******************************************************************************************************************************************
                                        // *********************************************************************************************************************************************************************************************************

                                        }
                                            while( !pP.bAbort && ~hSt ) ;
                                            }
                                                if( pfmUnique->cVotes > 1 && timeModRoundedYoungestNotAlone < pfmUnique->timeModRounded ) timeModRoundedYoungestNotAlone = pfmUnique->timeModRounded ;

                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                                            {
                                            do
                                            handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            _IO_
                                        {
                                        if( !pP.bAbort )
                                        ZE( countT , timeModRoundedYoungestNotAlone ) ;
                                        // SET timeModRoundedYoungestNotAlone

                                        // *********************************************************************************************************************************************************************************************************
                                        // ****                                             ********************************************************************************************************************************************************
                                        // ****  ACCUMULATE timeModRoundedYoungestNotAlone  ********************************************************************************************************************************************************
                                        // ****                                             ********************************************************************************************************************************************************
                                        // *********************************************************************************************************************************************************************************************************
                                        //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 51") ) ;

                                        }
                                            while( !pP.bAbort && ~hSt ) ;
                                            }
                                                while( ~hStkInner ) ;
                                                }
                                                    }
                                                        // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("    [cVotes.after]:    ")+TF2(pfmUnique->cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        pfmUnique->cVotes ++ ;
                                                    {
                                                    if( bMatchImage && !bFileMetaDiffer )

                                                    // //pP.ether.traceF( tinBaseP , pP.tIndent3+T(bFileMetaDiffer?"    file meta differ":"    file meta are the same") ) ;
                                                    boolT bFileMetaDiffer = *pfmUnique - *(fileMetaS*)pfmInner ;

                                                    // //pP.ether.traceF( tinBaseP , pP.tIndent3+T(bMatchImage?"    image matches":"    image does not match") ) ;
                                                    }
                                                        }
                                                            break ;
                                                            bMatchImage = 0 ;
                                                        {
                                                        if( picUnique[ offc ] - picInner[ offc ] )
                                                    {
                                                    for( countT offc = 0 ; offc < pP.cResultStructsNeeded ; offc ++ )
                                                    boolT bMatchImage = 1 ;

                                                    //}
                                                    //    pfmInner->traceF( tinBaseP , pP.st O ldPathToYear , pP.tIndent3+T("inner : ") ) ;
                                                    //    picInner->traceF( tinBaseP , pP.tIndent3+T("inner :    ") ) ;
                                                    //{
                                                    //if( bChatter )
                                                    fileMetaS*     pfmInner = (fileMetaS*)( picInner + pP.cResultStructsNeeded ) ;
                                                    imageCompareS* picInner  = (imageCompareS*)&stMeta.upF( tinBaseP , hStkInner ) ;
                                                    _IO_
                                                {
                                                do
                                                handleC hStkInner( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                                if( timeModRoundedYoungest < pfmUnique->timeModRounded ) timeModRoundedYoungest = pfmUnique->timeModRounded ;

                                                //}
                                                //    pfmUnique->traceF( tinBaseP , pP.st O ldPathToYear , pP.tIndent2+T("unique: ") ) ;
                                                //    picUnique->traceF( tinBaseP , pP.tIndent2+T("unique:    ") ) ;
                                                //{
                                                //if( bChatter )
                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                                                // //pP.ether.traceF( tinBaseP , pP.tIndent2+T("tallying votes for a particular image") ) ;
                                                _IO_
                                            {
                                            do
                                            handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            _IO_
                                        {
                                        ZE( countT , timeModRoundedYoungest ) ;
                                        // TALLY cVotes AND SET timeModRoundedYoungest

                                        // *********************************************************************************************************************************************************************************************************
                                        // ****                                                   **************************************************************************************************************************************************
                                        // ****  ACCUMULATE timeModRoundedYoungest ; TALLY VOTES  **************************************************************************************************************************************************
                                        // ****                                                   **************************************************************************************************************************************************
                                        // *********************************************************************************************************************************************************************************************************
                                        //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 61") ) ;

                                        }
                                            bChatter = 1 ;
                                            //pP.ether.traceF( tinBaseP , pP.tIndent1+T("lengths or times or images differ [tShort]:    ")+tShortP ) ;
                                        {
                                        if( stRecUnique > 1 )
                                        ZE( boolT , bChatter ) ;
                                        _IO_
                                    {
                                    else                            // EVEN IF THERE IS ONLY WO PLATE, THERE IS STILL WORK TO DO BECAUSE THE FILE MIGHT NEED TO BE COPIED TO DESTINATIONS THAT DON'T HAVE IT
                                    }
                                        pP.bAbort = 1 ;
                                        pP.ether.traceF( tinBaseP , T("!exception: stRecUnique is empty") ) ;
                                    {
                                    if( !stRecUnique ) //SHOULD  BE IMPOSSIBLE

                                    while( ~hStkOuter ) ;
                                    do stRecUnique.sinkF( tinBaseP , countTC() , (byteT*)&stMeta.upF( tinBaseP , hStkOuter ) , flSTACKsINK_UNIQUE , subtractFileMetaF ) ;
                                    stackC stRecUnique( tinBaseP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , pP.cPathsToYear * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ;
                                    handleC hStkOuter( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                *************************************************************************************************************************************************************************************
                                    // ****  BEGIN:  HEAL  *************************************************************************************************************************************************************************************
                                    // ****                *************************************************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************
                                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 71") ) ;
                                    _IO_
                                {
                                if( !pP.bAbort )
                                pauseIfF( tinBaseP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 81") ) ;
                                _IO_
                            {
                            if( !etPrime && cCopies )
                            // //pP.ether.traceF( tinBaseP , pP.tIndent1+T("[cFound,file]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;

                            // PHASE 4: COPY TO ALL ARCHIVE CONTAINERS THAT DO NOT HAVE A COPY OF THIS FILE NAME
                            // PHASE 3: OVERWRITE ALL COPIES THAT DO NOT MATCH THIS UNIQUE META
                            // PHASE 2: IS THIS UNIQUE META VERIFIED (cVotes > 1)?
                            // PHASE 1: IDENTIFY THE UNIQUE META WITH THE LATEST FILE DATE
                            // HEALING ACTION HAS PHASES
                            // COMPARE AND FILE META FOR THIS FILE ARE SET AND READY FOR ANALYSIS AND HEALING ACTION
                            // THESE COMMENTS ARE OBSOLETED BY ACTUAL CODE WHICH CONTRADICTS THEM
                            _IO_
                        {
                        if( !pP.bAbort )

                        while( !etPrime && !pP.bAbort && ~hStkOuter ) ;
                        }
                            //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 91") ) ;
                            // *********************************************************************************************************************************************************************************************************
                            // ****                                      ***************************************************************************************************************************************************************
                            // ****  END:    FOR EACH COPY OF THIS FILE  ***************************************************************************************************************************************************************
                            // ****                                      ***************************************************************************************************************************************************************
                            // *********************************************************************************************************************************************************************************************************

                            pP.ether.delF( tinBaseP ,            pcBitsShiftLeftHeInMine ) ;
                            pP.ether.delF( tinBaseP ,            pcBitsShiftLeftMeInHis  ) ;
                            pP.ether.delF( tinBaseP , *(byteT**)&ppIdResultHeInMine      ) ;
                            pP.ether.delF( tinBaseP , *(byteT**)&ppIdResultMeInHis       ) ;
                            pP.ether.delF( tinBaseP ,            pcbwInner               ) ;
                            pP.ether.delF( tinBaseP , *(byteT**)&ppbwInner               ) ;

                            }
                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / a1") ) ;
                                deleteEqualArrayFwsInnerArrayF( tinBaseP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / b1") ) ;

                                }
                                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / c1") ) ;
                                    }
                                        }
                                            while( ~hStkEqual ) ;
                                            }
                                                //picHe->traceF( tinBaseP , pP.tIndent3+T("he is equal (after) :") ) ;
                                                pP.ether.memCopyF( tinBaseP , (byteT*)picHe , (byteT*)picOuter , sizeof( imageCompareS ) * pP.cResultStructsNeeded ) ;
                                                //picHe->traceF( tinBaseP , pP.tIndent3+T("he is equal (before):") ) ;
                                                imageCompareS* picHe = (imageCompareS*)&stMeta[ cMeta - idHeIsEqual + 1 ] ;

                                                // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("[heIsEqual]:    ")+TF2(idHeIsEqual,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                countT idHeIsEqual = stHeIsEqual.downF( tinBaseP , hStkEqual ) ;
                                                _IO_
                                            {
                                            do
                                            handleC hStkEqual( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                            _IO_
                                        {
                                        if( !pP.bAbort )

                                        }
                                            // #endif
                                            //     // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("[idInner,resultHeInMine]:    ")+TF2(1+offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tResultHeInMine ) ;
                                            //     // 
                                            //     // }
                                            //     //     case BITSrESULT_ALLbITS  : { tResultHeInMine = T("allBits")  ; break ; }
                                            //     //     case BITSrESULT_EQUAL    : { tResultHeInMine = T("equal")    ; break ; }
                                            //     //     case BITSrESULT_NOTeQUAL : { tResultHeInMine = T("notEqual") ; break ; }
                                            //     //     case BITSrESULT_UNKNOWN  : { tResultHeInMine = T("unknown")  ; break ; }
                                            //     // {
                                            //     // switch( resultHeInMine )
                                            //     // TN( tResultHeInMine , "" ) ;
                                            // #if defined( IFC tESTING )

                                            }
                                        
                                                if( !ids ) { BLAMMO }
                                                stHeIsEqual.sinkF( tinBaseP , ids , 1 + offi , flSTACKsINK_UNIQUE ) ;
                                                ZE( countT , ids ) ;
                                            {
                                            if( resultHeInMine == BITSrESULT_EQUAL )
                                        
                                            countT  resultHeInMine         = ( bitsResultHeInMine & maskHeInMine ) >> cBitsShiftLeftHeInMine ;
                                            countT  maskHeInMine           = BITSrESULT_ALLbITS << cBitsShiftLeftHeInMine ;
                                            countT  cBitsShiftLeftHeInMine =         ( offi % cResultsPerStruct ) << 1 ;
                                            countT& bitsResultHeInMine     = picOuter[ offi / cResultsPerStruct ].bitsResult ;
                                            _IO_
                                        {
                                        for( countT offi = 0 ; !pP.bAbort && offi < cMeta ; offi ++ )
                                        countT cMeta = stMeta ;
                                        stackC stHeIsEqual( tinBaseP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE ) ;

                                        //picOuter->traceF( tinBaseP , pP.tIndent2+T("outer (mine):") ) ;

                                        // //pP.ether.traceF( tinBaseP , pP.tIndent2+T("transitivity: copying my results to other rows [idSlotPathToYearOuter]:    ")+TF2(idSlotPathToYearOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        _IO_
                                    {
                                    if( !pP.bAbort )
                                    //SET OTHER RESULTS TO EXPLOIT TRANSITIVITY (A COPY THAT IS EQUAL TO ME RECEIVES ALL OF MY RESULTS)
                                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / d1") ) ;

                                    //while( ~hStkInner ) ;
                                    //}
                                    //    picInner->traceF( tinBaseP , T("after comparing inners with [tLongOuter]:    ")+tLongOuter ) ;
                                    //    imageCompareS* picInner = (imageCompareS*)&stMeta.upF( tinBaseP , hStkInner ) ;
                                    //{
                                    //do
                                    //handleC hStkInner( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                    }
                                        // //pP.ether.traceF( tinBaseP , pP.tIndent3+T(pEqual[offo]?"        set other and myself to BITSrESULT_EQUAL because images match [offo]:    ":"        set other and myself to BITSrESULT_NOTeQUAL because images differ [offo]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                        }
                                            // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("after  [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                            *ppIdResultMeInHis[  offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftMeInHis[  offo ] ;
                                            *ppIdResultHeInMine[ offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftHeInMine[ offo ] ;
                                            // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("before [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                        {
                                        else
                                        }
                                            *ppIdResultMeInHis[  offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftMeInHis[  offo ] ;
                                            *ppIdResultHeInMine[ offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftHeInMine[ offo ] ;
                                        {
                                        if( pEqual[ offo ] )
                                        _IO_
                                    {
                                    for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ )
                                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / e1") ) ;
                                    _IO_
                                {
                                if( !pP.bAbort )

                                //if( pcz_bUseWorkers ) *pcz_bUseWorkers = 0 ;

                                THREADmODE2rESTORE
                                }
                                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / f1") ) ;
                                    //pP.ether.delF( tinBaseP , *(byteT**)&pfwsOuter ) ;
                                    // //pP.ether.traceF( tinBaseP , pP.tIndent2+T("del [pfwsOuter]:    ")+TF3((countT)pfwsOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;

                                    }
                                        }
                                            }
                                                break ;
                                                deleteEqualArrayFwsInnerArrayF( tinBaseP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                                pP.bAbort = 1 ;
                                                pP.ether.traceF( tinBaseP , pP.tIndent2+T("!exception: could not dt pfwsOuter [rc,postRc,cInnerImagesToInspect,tLongOuter]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                                                const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                POOPRqUIET
                                                _IO_
                                                countT rc = POOP ;
                                            {
                                            if( POOP )
                                            DEL( pfwsOuter ) ;
                                            _IO_
                                            SCOOPS
                                        {

                                        }
                                            break ;
                                            deleteEqualArrayFwsInnerArrayF( tinBaseP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                            pP.bAbort = 1 ;
                                            pP.ether.traceF( tinBaseP , pP.tIndent2+T("!exception [cbUsed,cbDone]:    ")+TT(pcbUsed[0],pcbUsed[1])+tb4+TT(pcbDone[0],pcbDone[1])+tb4+tLongOuter ) ;
                                            countT* pcbDone = (countT*)&cbDone ;
                                            countT* pcbUsed = (countT*)&pfmOuter->cbUsed ;
                                            _IO_
                                        {
                                        if( cbDone != pfmOuter->cbUsed ) //SHOULD BE IMPOSSIBLE
                                        _IO_
                                    {
                                    if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )

                                    if( pP.bAbort ) break ;
                                    if( etPrime   ) pP.bAbort = 1 ;
                                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 02") ) ;

                                    }
                                        //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 12") ) ;
                                        cbDone += cbwOuter ;

                                        if( pP.bAbort ) break ;

                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>

                                        //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 22: waited  for all pending compare jobs to complete for this file window") ) ;
                                        }
                                            ++ s ; thirdC::osThreadYieldIF( tinBaseP , TAG( TAGiDnULL ) , 0 , flYIELD_ANYtHREADdESIRE ) ;
                                            //++ s ; thirdC::dosSleepWinkIF( tinBaseP , 0 ) ;
                                            //pP.ether.traceF( tinBaseP , T("waiting for pending jobs [cJobsPendingCompare]:    ")+TF2(cJobsPendingCompare,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        {
                                        while( cJobsPendingCompare )
                                        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                                        //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 32: waiting for all pending compare jobs to complete for this file window") ) ;

                                        }
                                            }
                                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 42") ) ;
                                                //pcbwInner[ offi ] = 0 ;  // TELLS TO GET ANOTHER WINDOW
                                                //ppbwInner[ offi ] = 0 ;
                                                //20230623@0922: CONJ: THIS CODE IS OBSOLETE AND HAS NO EFFECT

                                                }
                                                    break ;
                                                    deleteEqualArrayFwsInnerArrayF( tinBaseP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                                    _IO_
                                                {
                                                if( pP.bAbort )

                                                }
                                                    }
                                                        }
                                                            pP.stJobCompare.sinkF( tinBaseP , countTC() , (countT)pJob , flSTACKsINK_null , subtract_jobCompareOoImagesS_F , 0 ) ;                                                    
                                                            jobCompareOoImagesS* pJob = new( 0 , tinBaseP , LF ) jobCompareOoImagesS( tinBaseP , pP.ether , cJobsPendingCompare , pEqual[ offi ] , pbwOuter , ppbwInner[ offi ] , cbwOuter , tLongOuter , T(pfwsInner?pfwsInner[offi]:(const strokeS*)0) , cbUsedMax04 ) ; ___( pJob ) ;

                                                            }
                                                                }
                                                                    }
                                                                        ++ s ; thirdC::dosSleepWinkIF( tinBaseP , 0 ) ;
                                                                        pP.ether.traceF( tinBaseP , T("napping: a large file is being processed and i am even larger [cbUsedMax04,cbPendingMax04]:    ")+TF3((countT)cbUsedMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tDot+TF3(((countT*)&cbUsedMax04)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF3((countT)cbPendingMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tDot+TF3(((countT*)&cbPendingMax04)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                                                                        if( !bNapped ) bNapped = 1 ;
                                                                    {
                                                                    else
                                                                    }
                                                                        break ;
                                                                        if( bNapped ) pP.ether.traceF( tinBaseP , T("no longer napping: a large file was being processed and i was even larger [cbUsedMax04,cbPendingMax04]:    ")+TF3((countT)cbUsedMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tDot+TF3(((countT*)&cbUsedMax04)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF3((countT)cbPendingMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tDot+TF3(((countT*)&cbPendingMax04)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                                                                    {
                                                                    if( !cbPendingMax04 || cbPendingMax04 > cbUsedMax04 )

                                                                    pP.stJobCompare.ungrabF( tinBaseP ) ;
                                                                    }
                                                                        cbPendingMax04 = topJob.cbUsedMax04 ;
                                                                        jobCompareOoImagesS& topJob = *(jobCompareOoImagesS*)pP.stJobCompare[ 1 ] ;
                                                                    {
                                                                    if( pP.stJobCompare )
                                                                    pP.stJobCompare.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                                                                    ZE( count04T , cbPendingMax04 ) ;
                                                                    _IO_
                                                                {
                                                                while( pP.stJobCompare )
                                                                ZE( boolT , bNapped ) ;
                                                                _IO_
                                                            {
                                                            // IF A VERY LARGE FILE IS BEING PROCESSED AND I AM EVEN LARGER, WAIT BEFORE PUSHING
                                                            _IO_
                                                        {
                                                        else
                                                        }
                                                            compareOoImagesF( tinBaseP , etPrimeP , pP.ether , pP.bAbort , pP.cPause , pEqual[ offi ] , flagsModeP , pbwOuter , ppbwInner[ offi ] , cbwOuter /*, tLongOuter , T(pfwsInner?pfwsInner[offi]:(const strokeS*)0) , pP.tIndent3*/ ) ;
                                                            if( !pEqual[ offi ] ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE BECAUSE THIS FILE IS BEING COMPARED SYNCHRONOUSLY
                                                            _IO_
                                                        {
                                                        if( !bLargeFile )

                                                        }
                                                            // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("comparing oo images [cWindows,idWindow,perTuck,offi]:    ")+TF2((countT)cWindows,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tPerTuck+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                            countT perTuck = (countT)( ( idWindow << 8 ) / cWindows ) ;
                                                        {
                                                        if( bChatter )
                                                        _IO_
                                                    {
                                                    if( pEqual[ offi ] )    // DON'T COMPARE BYTES IF ALREADY KNOW THAT A PREVIOUS WINDOW DIDN'T MATCH
                                                    _IO_
                                                {
                                                if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )

                                                }
                                                    break ;
                                                    deleteEqualArrayFwsInnerArrayF( tinBaseP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                                {
                                                if( pP.bAbort )
                                                pauseIfF( tinBaseP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;

                                                // *********************************************************************************************************************************************************************************************************
                                                // ****                                                      ***********************************************************************************************************************************************
                                                // ****  COMPARE WINDOWS BYTE BY BYTE TO SET pEqual[ offi ]  ***********************************************************************************************************************************************
                                                // ****                                                      ***********************************************************************************************************************************************
                                                // *********************************************************************************************************************************************************************************************************
                                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 52") ) ;
                                                _IO_
                                            {
                                            else
                                            }
                                                }
                                                    break ;
                                                    // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("done inspecting images [cInnerImagesToInspect,cImagesInspected,cWindows,idWindow]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cImagesInspected,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)cWindows,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( ++ cImagesInspected == cInnerImagesToInspect )
                                                _IO_
                                            {
                                            if( !pbwOuter || !cbwOuter )

                                            }
                                                }
                                                    break ;
                                                    deleteEqualArrayFwsInnerArrayF( tinBaseP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                                    pP.bAbort = 1 ;
                                                    pP.ether.traceF( tinBaseP , pP.tIndent3+T("!exception: preliminary checks (before byte by byte comparison) failed ; aborting [tLongOuter,tLongInner]:    ")+tLongOuter+tb4+T(pfwsInner?pfwsInner[offi]:(const strokeS*)0) ) ;
                                                {
                                                )
                                                      cbwOuter !=   pcbwInner[ offi ]
                                                    ||
                                                    !!cbwOuter != !!pcbwInner[ offi ]
                                                    ||
                                                    !!pbwOuter != !!ppbwInner[ offi ]
                                                (
                                                if
                                                _IO_
                                            {
                                            if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )

                                            // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("fed this [(countT)ppbwInner[offi],ppbwInner[offi]]:    ")+TF3((countT)ppbwInner[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+T(ppbwInner[offi]) ) ;

                                            // *********************************************************************************************************************************************************************************************************
                                            // ****                            *************************************************************************************************************************************************************************
                                            // ****  ABORT IF LENGTH MISMATCH  *************************************************************************************************************************************************************************
                                            // ****                            *************************************************************************************************************************************************************************
                                            // *********************************************************************************************************************************************************************************************************
                                            //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 62") ) ;

                                            }
                                                }
                                                    }
                                                        break ;
                                                        deleteEqualArrayFwsInnerArrayF( tinBaseP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;

                                                        }
                                                            etRock.traceF( tinBaseP , pP.tIndent3+T("!exception: could not get inner file window (not enough memory) ; traced  pool tallies and memory grain report") ) ;
                                                            etRock.traceMemoryGrainRptF( tinBaseP ) ;
                                                            etRock.tracePoolTalliesF( tinBaseP ) ;
                                                            etRock.traceF( tinBaseP , pP.tIndent3+T("!exception: could not get inner file window (not enough memory) ; tracing pool tallies and memory grain report") ) ;
                                                            etherC& etRock = etherC::etRockIF( tinBaseP ) ;
                                                        {
                                                        if( rc == ifcIDiMPOTENCEbASEeRRORcODE_NOTeNOUGHmEMORY )

                                                        pP.bAbort = 1 ;
                                                        pP.ether.traceF( tinBaseP , pP.tIndent3+T("!exception:  pfwsInner[ offi ].getF ; aborting [rc,postRc,idInner,tLongInner]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+TF2(offi+1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(pfwsInner?pfwsInner[offi]:(const strokeS*)0) ) ;

                                                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                        POOPRqUIET
                                                        _IO_
                                                        countT rc = POOP ;
                                                    {
                                                    if( POOP )

                                                    pfwsInner[ offi ].getF( tinBaseP , ppbwInner[ offi ] , pcbwInner[ offi ] , cbFileWindow ) ;
                                                    pcbwInner[ offi ] = 0 ;
                                                    ppbwInner[ offi ] = 0 ;

                                                    _IO_
                                                    SCOOPS
                                                {
                                                IFsCRATCH
                                            {
                                            if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )

                                            //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 72") ) ;

                                            // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("     inner [idWindow,tLongInner]:    ")+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE)+tb4+T(pfwsInner?pfwsInner[offi]:(const strokeS*)0) ) ;

                                            // *********************************************************************************************************************************************************************************************************
                                            // ****                       ******************************************************************************************************************************************************************************
                                            // ****  GET AN INNER WINDOW  ******************************************************************************************************************************************************************************
                                            // ****                       ******************************************************************************************************************************************************************************
                                            // *********************************************************************************************************************************************************************************************************
                                            _IO_
                                        {
                                        for( countT offi = 0 ; !pP.bAbort && offi < cInnerImagesToInspect ; offi ++ )
                                        ZE( countT , cJobsPendingCompare ) ;
                                        //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 82: process each inner window") ) ;

                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>

                                        }
                                            }
                                                }
                                                    break ;
                                                    deleteEqualArrayFwsInnerArrayF( tinBaseP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;

                                                    }
                                                        etRock.traceF( tinBaseP , pP.tIndent2+T("!exception: could not get outer file window (not enough memory) ; traced  pool tallies and memory grain report") ) ;
                                                        etRock.traceMemoryGrainRptF( tinBaseP ) ;
                                                        etRock.tracePoolTalliesF( tinBaseP ) ;
                                                        etRock.traceF( tinBaseP , pP.tIndent2+T("!exception: could not get outer file window (not enough memory) ; tracing pool tallies and memory grain report") ) ;
                                                        etherC& etRock = etherC::etRockIF( tinBaseP ) ;
                                                    {
                                                    if( rc == ifcIDiMPOTENCEbASEeRRORcODE_NOTeNOUGHmEMORY )

                                                    pP.bAbort = 1 ;
                                                    pP.ether.traceF( tinBaseP , pP.tIndent2+T("!exception:  pfwsOuter->getF ; aborting [rc,postRc,tLongOuter]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+T(pfwsOuter?*pfwsOuter:(const strokeS*)0) ) ;

                                                    const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                    POOPRqUIET
                                                    countT rc = POOP ;
                                                    _IO_
                                                {
                                                if( POOP )
                                                pfwsOuter->getF( tinBaseP , pbwOuter , cbwOuter , cbFileWindow ) ;
                                                _IO_
                                                SCOOPS
                                            {
                                            IFsCRATCH
                                        {
                                        if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )
                                        ZE( countT , cbwOuter ) ;
                                        ZE( byteT* , pbwOuter ) ;

                                        //TN( tLikeInner , "///ideafarm/tmp/debug.inner." ) ; tLikeInner += TF3((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot ;
                                        //TN( tLikeOuter , "///ideafarm/tmp/debug.outer." ) ; tLikeOuter += TF3((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;

                                        // //pP.ether.traceF( tinBaseP , pP.tIndent2+T("outer      [idWindow,tLongOuter]:    ")+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE)+tb4+T(pfwsOuter?*pfwsOuter:(const strokeS*)0) ) ;

                                        }
                                            }
                                                ++ s ; thirdC::osThreadYieldIF( tinBaseP , TAG( TAGiDnULL ) , 0 , flYIELD_ANYtHREADdESIRE ) ;
                                                //if( !( id In % TOCK ) ) pP.ether.traceF( tinBaseP , T("napping: too many pending compare jobs [id In]:    ")+TF2(id In,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                //countT id In = 1 + incv02AM( id InLath ) ;
                                            {
                                            while( pP.stJobCompare >= pP.cPathsToYear )
                                            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                                            //sta tic countT id InLath ;
                                        {
                                        if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )

                                        pP.ether.traceF( tinBaseP , T("processing window [cWindowsMax,idWindow,tShortP]:  ")+TF2(cWindowsMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;

                                        //}
                                        //    pP.ether.traceF( tinBaseP , T("processing window [idName,cInnerImagesToInspect,cImagesInspected,cWindowsMax,idWindow,%,tShort]:  ")+TF2(idNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF3(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2)+tb4+TF3(cImagesInspected,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2)+tb4+TF3(cWindowsMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,4)+tb4+TF3((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,4)+tb4+TF3(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,3)+tPerTuck+tb4+tShortP ) ;
                                        //    countT perTuck = (countT)( ( idWindow << 8 ) / cWindowsMax ) ;
                                        //{            
                                        //if( !( idWindow % ( TUCK >> 4 ) ) )

                                        idWindow ++ ;

                                        // *********************************************************************************************************************************************************************************************************
                                        // ****                       ******************************************************************************************************************************************************************************
                                        // ****  GET AN OUTER WINDOW  ******************************************************************************************************************************************************************************
                                        // ****                       ******************************************************************************************************************************************************************************
                                        // *********************************************************************************************************************************************************************************************************
                                        //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 92: get an outer window") ) ;

                                        }
                                            break ;
                                            deleteEqualArrayFwsInnerArrayF( tinBaseP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                        {
                                        if( pP.bAbort )
                                        pauseIfF( tinBaseP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                        _IO_
                                    {
                                    while( !etPrime && cImagesInspected < cInnerImagesToInspect )
                                    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                                    ZE( count04T , idWindow ) ;
                                    ZE( boolT , cImagesInspected ) ;
                                    ZE( count04T , cbDone ) ;
                                    const count04T cWindows = 1 + pfmOuter->cbUsed / cbFileWindow ;
                                    const boolT    bChatter =     pfmOuter->cbUsed > cbFileWindow ;

                                    // //pP.ether.traceF( tinBaseP , pP.tIndent2+T("inspecting images [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;

                                    }
                                        }
                                            }
                                                break ;
                                                pP.bAbort = 1 ;
                                                deleteEqualArrayFwsInnerArrayF( tinBaseP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                                DEL( pfwsOuter ) ;
                                                pP.ether.traceF( tinBaseP , pP.tIndent2+T("!exception: could not ct pfwsOuter [rc,postRc,cInnerImagesToInspect,tLongOuter]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                                                const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                POOPRqUIET
                                                countT rc = POOP ;
                                                _IO_
                                            {
                                            if( POOP )
                                            new( 0 , tinBaseP , (byteT*)pfwsOuter , sizeof( fileWindowsC ) ) fileWindowsC( tinBaseP , *((tinNormalS&)tinBaseP).pEtScratch , tLongOuter ) ;
                                            _IO_
                                            SCOOPS
                                        {

                                        // //pP.ether.traceF( tinBaseP , pP.tIndent2+T("new [pfwsOuter]:    ")+TF3((countT)pfwsOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                                        pP.ether.newF( tinBaseP , LF , *(byteT**)&pfwsOuter , sizeof( fileWindowsC ) ) ; ___( pfwsOuter ) ;
                                        _IO_
                                    {
                                    if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )
                                    ZE( fileWindowsC* , pfwsOuter ) ;

                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                                  *******************************************************************************************************************************************************************
                                    // ****  CT OUTER fileWindowsC INSTANCE  *******************************************************************************************************************************************************************
                                    // ****                                  *******************************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************
                                    _IO_
                                {
                                IFsCRATCH
                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / a2") ) ;

                                }
                                    }
                                        if( pP.bAbort ) break ;

                                        }
                                            pP.ether.delF( tinBaseP , psttLongInner ) ;

                                            }
                                                }
                                                    break ;
                                                    pP.bAbort = 1 ;
                                                    deleteEqualArrayFwsInnerArrayF( tinBaseP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                                    DELzOMBIE( pDoomed ) ;
                                                    fileWindowsC* pDoomed = &pfwsInner[ offi ] ;
                                                    pP.ether.traceF( tinBaseP , pP.tIndent3+T("!exception: could not ct a fileWindowsC instance ; aborting [rc,postRc,tLongInner]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc)+tb4+T(psttLongInner) ) ;
                                                    const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                    POOPRqUIET
                                                    countT rc = POOP ;
                                                    _IO_
                                                {
                                                if( POOP )
                                                new( 0 , tinBaseP , (byteT*)( pfwsInner + offi ) , sizeof( fileWindowsC ) ) fileWindowsC( tinBaseP , *((tinNormalS&)tinBaseP).pEtScratch , psttLongInner ) ;
                                                _IO_
                                                SCOOPS
                                            {
                                            IFsCRATCH

                                            // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("[cInnerImagesToInspect,idInner,tLongInner]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi+1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLongInner) ) ;
                                            stLongInner >> psttLongInner ;
                                            ZE( strokeS* , psttLongInner ) ;
                                        {
                                        for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )
                                    {
                                    if( pfwsInner )
                                    _IO_
                                {
                                if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )
                                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                                for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ ) pEqual[ offi ] = 1 ;
                                pP.ether.newF( tinBaseP , LF , pEqual , cInnerImagesToInspect ) ; ___( pEqual ) ;
                                ZE( boolT* , pEqual ) ;

                                if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) ) pP.ether.newF( tinBaseP , LF , *(byteT**)&pfwsInner , cInnerImagesToInspect * sizeof( fileWindowsC ) ) ; ___( pfwsInner ) ;
                                ZE( fileWindowsC* , pfwsInner ) ;

                                }
                                    break ;
                                    pP.bAbort = 1 ;                                
                                    pP.ether.traceF( tinBaseP , pP.tIndent3+T("!exception [cInnerImagesToInspect,stLongInner]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+TF2(stLongInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                {
                                if( stLongInner != cInnerImagesToInspect ) //SHOULD BE IMPOSSIBLE

                                // *********************************************************************************************************************************************************************************************************
                                // ****                                                             ****************************************************************************************************************************************
                                // ****  CT INNER fileWindowsC INSTANCES ; INITIALIZE pEqual ARRAY  ****************************************************************************************************************************************
                                // ****                                                             ****************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************

                                //}
                                //    }
                                //        }
                                //            break ;
                                //            pcz_bUseWorkers = &bOk[ offs ] ;
                                //        {
                                //        if( !setIfZeAM( bOk[ offs ] , 1 ) )
                                //    {
                                //    for( countT offs = 0  ; offs < sizeof bOk / sizeof bOk[ 0 ] ; offs ++ )
                                //    sta tic boolT bOk[ 4 ] ;        // ARRAY SIZE IS HARDCODED NUMBER OF YEARS TO ALLOW TO USE WORKERS SIMULTANEOUSLY
                                //{
                                //if( bLargeFile )
                                //ZE( countT* , pcz_bUseWorkers ) ;         // WILL BE SET TO &bOk[ offs ]
                                //20230807@1408: pcz_bUseWorkers IS NOT USED ; CONJ: THIS CODE IS LEFT OVER FROM A CRAFTWORK IDEA THAT I BEGAN TO CODE BUT THEN DID NOT COMPLETE

                                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / b2") ) ;
                                _IO_
                            {
                            if( !etPrime && !pP.bAbort && cInnerImagesToInspect )

                            }
                                if( pP.bAbort ) break ;

                                }
                                    // /**/if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / c2 /                         DDDDDDDD [idPass]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    while( !etPrime && !pP.bAbort && ~hStkInner ) ;
                                    }
                                        // /**/if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / c2") ) ;
                                        }
                                            }
                                                break ;

                                                }
                                                    // /**/if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / d2 / maked  and sinked  psttLongInner") ) ;
                                                    }
                                                        pP.bAbort = 1 ;                                                    
                                                        pP.ether.traceF( tinBaseP , pP.tIndent3+T("!exception: iSlotLongInnr is null") ) ;
                                                        pP.ether.delF( tinBaseP , psttLongInner ) ;
                                                    {
                                                    if( !idSlotLongInner ) //SHOULD BE IMPOSSIBLE
                                                    stLongInner.sinkF( tinBaseP , idSlotLongInner , psttLongInner , flSTACKsINK_UNIQUE ) ;
                                                    ZE( countT , idSlotLongInner ) ;

                                                    pP.ether.strMakeF( tinBaseP , LF , psttLongInner , tLongInner ) ; ___( psttLongInner ) ;
                                                    ZE( strokeS* , psttLongInner ) ;
                                                    // /**/if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / d2 / making and sinking psttLongInner") ) ;

                                                    offResult ++ ;

                                                    pcBitsShiftLeftHeInMine[ offResult ] = cBitsShiftLeftHeInMine ;
                                                    pcBitsShiftLeftMeInHis[  offResult ] = cBitsShiftLeftMeInHis  ;
                                                    ppIdResultHeInMine[      offResult ] = &bitsResultHeInMine    ;
                                                    ppIdResultMeInHis[       offResult ] = &bitsResultMeInHis     ;
                                                {
                                                if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                                _IO_
                                            {
                                            case 3 :
                                            }
                                                break ;

                                                }
                                                    cInnerImagesToInspect ++ ;
                                                    // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("incrementing") ) ;
                                                {
                                                if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )

                                                // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("        maybe incrementing cInnerImagesToInspect [bitsResultHeInMine,maskHeInMine,masked,cBitsShiftLeftHeInMine,inner]:    ")+TF2(bitsResultHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(maskHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((bitsResultHeInMine&maskHeInMine),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                                _IO_
                                            {
                                            case 2 :    // COUNT THE NUMBER OF INNER FILES FOR WHICH I MUST INSPECT THE IMAGE (I SET cInnerImagesToInspect HERE)
                                            }
                                                break ;

                                                }
                                                    }
                                                        bitsResultHeInMine |= BITSrESULT_NOTeQUAL << cBitsShiftLeftHeInMine ;
                                                        bitsResultMeInHis  |= BITSrESULT_NOTeQUAL << cBitsShiftLeftMeInHis  ;
                                                        // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("        set other and myself to BITSrESULT_NOTeQUAL because cbUsed differs") ) ;
                                                    {
                                                    if( pfmOuter->cbUsed != pfmInner->cbUsed )

                                                    //U:: SET TO NOTeQUAL HERE IF DATETIME DIFFERS ; THIS WOULD BE AN OPTIMIZATION TO AVOID DOING IMAGE COMPARISON FOR COPIES THAT HAVE DIFFERENT TIMESTAMPS ; IN PRACTICE, THIS OPTIMIZATION WOULD NOT MAKE MUCH DIFFERENCE BECAUSE INTENTIONAL UPDATES TO A FILE ALMOST ALWAYS CHANGE ITS SIZE
                                                {
                                                else if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                                }
                                                    // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("        setted  myself to BITSrESULT_EQUAL [bitsResultMeInHis]:    ")+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    bitsResultMeInHis |= BITSrESULT_EQUAL << cBitsShiftLeftMeInHis ;
                                                    // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("        setting myself to BITSrESULT_EQUAL [&bitsResultMeInHis,bitsResultMeInHis,&cBitsShiftLeftMeInHis,cBitsShiftLeftMeInHis]:    ")+TF2(&bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(&cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( pfmInner == pfmOuter )
                                                _IO_
                                            {
                                            case 1 :    // SET bitsResult WITHOUT COMPARING FILE IMAGES
                                        {
                                        switch( idPass )

                                        // /*if( idPass == 3 )*/ pP.ether.traceF( tinBaseP , pP.tIndent3+T("    [idPass,idInner,tLongInner]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(++idInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                        // /**/if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / d2 / calculated  tLongInner by querying stack[]") ) ;
                                        TN( tLongInner , "" ) ; tLongInner = T(pP.pzpsttPathToYear[pfmInner->idSlotPathToYear-1])+tShortP ;
                                        // /**/if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / d2 / calculating tLongInner by querying stack[]") ) ;

                                        countT maskHeInMine = BITSrESULT_ALLbITS << cBitsShiftLeftHeInMine ;
                                        countT maskMeInHis  = BITSrESULT_ALLbITS << cBitsShiftLeftMeInHis  ;

                                        countT  cBitsShiftLeftHeInMine =           ( ( pfmInner->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;
                                        countT  cBitsShiftLeftMeInHis  =           ( ( pfmOuter->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;
                                        countT& bitsResultHeInMine     = picOuter[ ( pfmInner->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;
                                        countT& bitsResultMeInHis      = picInner[ ( pfmOuter->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;

                                        }
                                            break ;
                                            pP.bAbort = 1 ;
                                            pP.ether.traceF( tinBaseP , pP.tIndent3+T("!exception / !pfmInner->idSlotPathToYear [tShort]:    ")+tShortP ) ;
                                        {
                                        if( !pfmInner->idSlotPathToYear )

                                        //picInner->traceF( tinBaseP , pP.tIndent3+T("    inner :    ") ) ;
                                        //pfmInner->traceF( tinBaseP , pP.st O ldPathToYear , pP.tIndent3+T("    inner: ") ) ;
                                        fileMetaS*     pfmInner = (fileMetaS*)( picInner + pP.cResultStructsNeeded ) ;

                                        // //pP.ether.traceF( tinBaseP , pP.tIndent3+T("    [picInner]:    ")+TF2((countT)picInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        imageCompareS* picInner = (imageCompareS*)&stMeta.upF( tinBaseP , hStkInner ) ;

                                        if( pP.bAbort ) break ;
                                        pauseIfF( tinBaseP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                        // /**/if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / d2") ) ;
                                        _IO_
                                    {
                                    do
                                    // /**/if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / e2 /                 CCCCCCCC         [idPass]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    handleC hStkInner( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    ZE( countT , idInner ) ;
                                    _IO_
                                {
                                if( idPass != 3 || cInnerImagesToInspect )

                                }
                                    pP.ether.memSetF( tinBaseP , (byteT*)pcBitsShiftLeftHeInMine , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                    pP.ether.memSetF( tinBaseP , (byteT*)pcBitsShiftLeftMeInHis  , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                    pP.ether.memSetF( tinBaseP , (byteT*)ppIdResultHeInMine      , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                    pP.ether.memSetF( tinBaseP , (byteT*)ppIdResultMeInHis       , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                    pP.ether.memSetF( tinBaseP , (byteT*)pcbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                    pP.ether.memSetF( tinBaseP , (byteT*)ppbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;

                                    pP.ether.newF( tinBaseP , LF ,             pcBitsShiftLeftHeInMine , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftHeInMine ) ;
                                    pP.ether.newF( tinBaseP , LF ,             pcBitsShiftLeftMeInHis  , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftMeInHis  ) ;
                                    pP.ether.newF( tinBaseP , LF , *(countT**)&ppIdResultHeInMine      , cInnerImagesToInspect ) ; ___( ppIdResultHeInMine      ) ;
                                    pP.ether.newF( tinBaseP , LF , *(countT**)&ppIdResultMeInHis       , cInnerImagesToInspect ) ; ___( ppIdResultMeInHis       ) ;
                                    pP.ether.newF( tinBaseP , LF ,             pcbwInner               , cInnerImagesToInspect ) ; ___( pcbwInner               ) ;
                                    pP.ether.newF( tinBaseP , LF , *(countT**)&ppbwInner               , cInnerImagesToInspect ) ; ___( ppbwInner               ) ;
                                {
                                if( idPass == 3 && cInnerImagesToInspect )
                                _IO_
                            {
                            for( countT idPass = 1 ; !etPrime && !pP.bAbort && idPass <= 3 ; idPass ++ )
                            ZE( countT   , offResult               ) ;
                            ZE( countT*  , pcBitsShiftLeftHeInMine ) ;
                            ZE( countT*  , pcBitsShiftLeftMeInHis  ) ;
                            ZE( countT** , ppIdResultHeInMine      ) ;
                            ZE( countT** , ppIdResultMeInHis       ) ;
                            ZE( countT*  , pcbwInner               ) ;
                            ZE( byteT**  , ppbwInner               ) ;
                            ZE( countT   , cInnerImagesToInspect   ) ;
                            stackC stLongInner( tinBaseP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

                            // *********************************************************************************************************************************************************************************************************
                            // ****                                                *****************************************************************************************************************************************************
                            // ****  LOAD stLongInner AND INITIALIZE ACCUMULATORS  *****************************************************************************************************************************************************
                            // ****                                                *****************************************************************************************************************************************************
                            // *********************************************************************************************************************************************************************************************************

                            //pfmOuter->traceF( tinBaseP , pP.st O ldPathToYear , pP.tIndent2+T("outer: ") ) ;
                            pP.ether.traceF( tinBaseP , pP.tIndent2+T("[cCopies,idCopy,tLongOuter]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(++idCopy,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                            TN( tLongOuter , "" ) ; tLongOuter = T(pP.pzpsttPathToYear[idSlotPathToYearOuter-1])+tShortP ;
                            countT idSlotPathToYearOuter = pfmOuter->idSlotPathToYear ;

                            }
                                break ;
                                pP.bAbort = 1 ;
                                pP.ether.traceF( tinBaseP , pP.tIndent2+T("!exception / !pfmOuter->idSlotPathToYear [tShort]:    ")+tShortP ) ;
                            {
                            if( !pfmOuter->idSlotPathToYear )

                            // //picOuter->traceF( tinBaseP , pP.tIndent2+T("outer :    ") ) ;
                            fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + pP.cResultStructsNeeded ) ;
                            imageCompareS* picOuter  = (imageCompareS*)&stMeta.upF( tinBaseP , hStkOuter ) ;

                            if( pP.bAbort ) break ;
                            if( etPrime ) pP.bAbort = 1 ;
                            pauseIfF( tinBaseP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;

                            // *********************************************************************************************************************************************************************************************************
                            // ****                                      ***************************************************************************************************************************************************************
                            // ****  BEGIN:  FOR EACH COPY OF THIS FILE  ***************************************************************************************************************************************************************
                            // ****                                      ***************************************************************************************************************************************************************
                            // *********************************************************************************************************************************************************************************************************
                            //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / e2") ) ;
                            _IO_
                        {
                        do
                        handleC hStkOuter( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        ZE( countT , idCopy ) ;
                        // SET ALL COMPARE META ELEMENTS FOR EACH FILE'S IMAGE COMPARE META ARRAY

                        if( !pP.bAbort && ( cbUsedHighMax || cbUsedMax > TOCK ) ) pP.ether.osTimeNowF( tinBaseP , timeA1 , timeA2 ) ;
                        ZE( sCountT , timeA2 ) ;
                        ZE( countT  , timeA1 ) ;

                        //pP.ether.traceF( tinBaseP , T("[cbUsedMax04,cWindowsMax]:    ")+TF2((countT)cbUsedMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cWindowsMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        countT   cWindowsMax = (countT)( 1 + cbUsedMax04 / cbFileWindow ) ;
                        count04T cbUsedMax04 = ( (count04T)cbUsedHighMax << 0x20 ) | (count04T)cbUsedMax ;      //A:ASSUME: sizeof( countT) IS 0x20

                        if( cbUsedHighMax || cbUsedMax > TOCK ) bLargeFile = 1 ;    //20230918@1130: TOCK <-- TUCK
                        ZE( boolT  , bLargeFile ) ;

                        //pP.ether.traceF( tinBaseP , T("[cCopies,cbFileWindow]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+TF3(cbFileWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                        }
                                   cbFileWindow         =   cbFileWindowsPerCopy                                                    ;

                                   cbFileWindowsPerCopy = ( cbFileWindowsPerCopy / cbGrain ) * cbGrain                              ;        //ENFORCES GRAINSIZE
                            //countT cbFileWindowsPerCopy =   cbAllFileWindows     / cCopies   /* / ( cToHireHealP + cToHireCompareP ) */ ;  // INTENTION IS TO PEG CPU WHEN FEW WINDOWS WHILE PREVENTING ADDRESS SPACE EXHAUSTION WHEN MANY WINDOWS ; COMPARES ARE DONE ON tmWorkerCompareF FOR LARGE FILES AND ON tmWorkerHealF FOR SMALL FILES

                              //countT cbFileWindowsPerCopy =   cbAllFileWindows     / cCopies   /* / pP.cPathsToYear            */ ;
                                countT cbFileWindowsPerCopy =   cbAllFileWindows     / cCopies      / CtOhIREhEAL                   ;  //U:: THIS LINE IS FOR EXPERIMENT: ALL COMPARE IN LINE

                            countT cbAllFileWindows     = ( CBaLLfILEwINDOWS     / cbGrain ) * cbGrain                              ;        //ENFORCES GRAINSIZE
                            countT cbGrain              = thirdC::os_cbAllocationGrain_IF( tinBaseP )                                   ;
                        {
                        ZE( countT , cbFileWindow ) ;                                                           //A:ASSUME: THE MAX NUMBER OF FILE WINDOWS THAT WILL EXIST FOR A FILE AT ANY TIME IS pP.cPathsToYear
     
                        pP.ether.traceF( tinBaseP , T("processing [idName,tShort]:    ")+TF2(idNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;
                        _IO_
                    {
                    if( !pP.bAbort )
                    pauseIfF( tinBaseP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;

                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // ****                                                                                                                                  *******************************************************************
                    // ****  BEGIN:  COMPARE ALL COPIES OF THIS SHORT FILE NAME.  THIS IS RETRIED UNTIL ALL COMPARISONS COMPLETE WITHOUT AN EXCEPTION EVENT  *******************************************************************
                    // ****                                                                                                                                  *******************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    _IO_
                {
                else
                else if( !cCopies ) pP.ether.traceF( tinBaseP , T("!exception: i found 0 copies of this listed file [tShort]:    ")+tShortP ) ;
                if( etPrime ) ;
                ////pP.ether.traceF( tinBaseP , T("healing / f2") ) ;

                // //pP.ether.traceF( tinBaseP , T("[cCopies,tShort]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;

                countT cCopies = stMeta ;
                _IO_
            {
            if( !pP.bAbort )
            //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 03") ) ;

            pP.ether.delF( tinBaseP , *(countT**)&ppInfoFile ) ;
            }
                DEL( ppInfoFile[ offh ] ) ;
                _IO_
            {
            for( countT offh = 0 ; offh < pP.cPathsToYear ; offh ++ )

            }
                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 13 / 0") ) ;

                DEL( ppInfoFile[ offh ] ) ;
                }
                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 13 / ") ) ;
                    new( 0 , tinBaseP , (byteT*)pCursor , sizeof( fileMetaS ) ) fileMetaS( tinBaseP , pP.bAbort , offh + 1 , time1Mod , time2Mod , cbUsed ) ;
                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 13 / 1") ) ;

                    pCursor += pP.cResultStructsNeeded ;

                    bitsResultMeInMine = BITSrESULT_EQUAL << cBitsShiftLeftMeInMine ;   // INITIALIZE RESULT TO SAY THAT I MATCH MYSELF

                    countT  cBitsShiftLeftMeInMine =        ( offh % cResultsPerStruct ) << 1 ;
                    countT& bitsResultMeInMine     = pCursor[ offh / cResultsPerStruct ].bitsResult ;
                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 13 / 2") ) ;

                    for( countT offs = 0 ; offs < pP.cResultStructsNeeded ; offs ++ ) new( 0 , tinBaseP , (byteT*)( pCursor + offs ) , sizeof( imageCompareS ) ) imageCompareS ;
                    imageCompareS* pCursor = (imageCompareS*)&(stMeta)[ 1 ] ;
                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 13 / 3") ) ;

                    stMeta << (byteT*)0 ;

                    count04T cbUsed = (count04T)ppInfoFile[ offh ]->cbUsedHigh << sizeof( count02T ) * SB | ppInfoFile[ offh ]->cbUsed ;

                    sCountT time2Mod = ppInfoFile[ offh ]->timeWritten2 ;
                    countT  time1Mod = ppInfoFile[ offh ]->timeWritten1 ;

                    }
                        cbUsedHighMax = ppInfoFile[ offh ]->cbUsedHigh ;
                        cbUsedMax     = ppInfoFile[ offh ]->cbUsed     ;
                    {
                    if( cbUsedHighMax < ppInfoFile[ offh ]->cbUsedHigh || ( cbUsedHighMax == ppInfoFile[ offh ]->cbUsedHigh && cbUsedMax < ppInfoFile[ offh ]->cbUsed ) )
                    //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 13 / 4") ) ;
                    _IO_
                {
                if( ppInfoFile[ offh ] )

                // //pP.ether.traceF( tinBaseP , T("processing a path to this file [idPath,cPathsToYear,tLong]:    ")+TF2(1+offh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+pP.tb4+TF2(pP.cPathsToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+pP.tb4+tLong ) ;

                TN( tLong , "" ) ; tLong = T(pP.pzpsttPathToYear[offh])+tShortP ;
                //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 13 / a") ) ;
                _IO_
            {
            for( countT offh = 0 ; !pP.bAbort && !etPrime && offh < pP.cPathsToYear ; offh ++ )
            ZE( countT , cbUsedHighMax ) ;
            ZE( countT , cbUsedMax ) ;
            // /**/if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 13 /         BBBBBBBB") ) ;

            if( etPrime ) pP.bAbort = 1 ;

            }
                //((tinNormalS&)tinBaseP).pc Utility[ 0 ] ++ ;

                //pP.ether.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_WATCH ) ;
                //pP.ether.traceF( tinBaseP , T("   +     watch") ) ;
            {
            if( bChatterP )

            pP.grabDisk.ungrabF( tinBaseP ) ;

            }
                //++ s ; thirdC::dosSleepWinkIF( tinBaseP , 0 ) ;
                Sleep( 0 ) ;

                }
                    break ;
                    }
                        }
                            //pP.ether.traceF( tinBaseP , T("file not found or i could not obtain file info [tLong]:    ")+tLong ) ;
                            TN( tLong , "" ) ; tLong = T(pP.pzpsttPathToYear[offh])+tShortP ;
                            ppInfoFile[ offh ] = 0 ;
                        {
                        if( ppInfoFile[ offh ] == INFOfILEnOTaVAILABLE )
                    {
                    for( countT offh = 0 ; offh < pP.cPathsToYear ; offh ++ )
                {
                if( offh == pP.cPathsToYear )

                }
                    if( !ppInfoFile[ offh ] ) break ;
                {
                for( ; offh < pP.cPathsToYear ; offh ++ )
                ZE( countT , offh ) ;
                _IO_
            {
            for(;;)                                                                         // NAP UNTIL ALL ELEMENTS ARE SET ; THEN SMUDGE THE "INFOfILEnOTaVAILABLE" VALUES TO 0
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
            // /**/if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 23 / AAAAAAAA") ) ;

            }
                pP.funJobFileInfo.writeF( tinBaseP , pbz ) ;
                new( 0 , tinBaseP , pbz , sizeof pbz ) jobFileInfoS( tinBaseP , pP.ether , tLong , ppInfoFile[ offh ] ) ;
                byteT pbz[ sizeof( jobFileInfoS ) ] ;

                TN( tLong , "" ) ; tLong = T(pP.pzpsttPathToYear[offh])+tShortP ;
                _IO_
            {
            for( countT offh = 0 ; offh < pP.cPathsToYear ; offh ++ )
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
            //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 33") ) ;

            pP.grabDisk.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

            }
                //((tinNormalS&)tinBaseP).pc Utility[ 0 ] -- ;

                //pP.ether.traceF( tinBaseP , T("    -    watch") ) ;
                //pP.ether.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_UNWATCH ) ;
            {
            if( bChatterP )

            pP.ether.memSetF( tinBaseP , (byteT*)ppInfoFile , sizeof( countT ) * pP.cPathsToYear ) ;
            pP.ether.newF( tinBaseP , LF , *(countT**)&ppInfoFile , pP.cPathsToYear ) ; ___( ppInfoFile ) ;
            ZE( infoFileS** , ppInfoFile ) ;
            //if( bChatterP ) pP.ether.traceF( tinBaseP , T("healing / 43") ) ;
            _IO_
        {
        if( !pP.bAbort )
        pauseIfF( tinBaseP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;

        stackC stMeta( tinBaseP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB | flSTACKc_ALLOWzE , pP.cResultStructsNeeded * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ;

        //pP.ether.traceF( tinBaseP , T("++++ healing [tShort]:    ")+tShortP ) ;

        const countT cProcessors = thirdC::osProcessorsIF( tinBaseP ) ;

        etherC& etRock  = etherC::etRockIF( tinBaseP ) ;
        etherC& etText  = etherC::etTextIF( tinBaseP ) ;
        etherC& etPrime = etherC::etPrimeIF() ;
        TN( tPerTuck , " %" ) ;
        TN( tDot , "." ) ;
        TN( tb4  , "    " ) ;
        TN( tb   , " " ) ;

        }
            //((tinNormalS&)tinBaseP).pc Utility[ 0 ] ++ ;

            //pP.ether.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_WATCH ) ;
            //pP.ether.traceF( tinBaseP , T("++++     watch") ) ;
        {
        if( bChatterP )
        _IO_
    {

    //)
    //    && !pP.ether.strIdF( tinBaseP , T("!ideafarm.a."       ) , tShortP , 1 )
    //    && !pP.ether.strIdF( tinBaseP , T(".meta.datafiletimes") , tShortP , 1 )
    //       !pP.ether.strIdF( tinBaseP , T(".fset.zip"          ) , tShortP , 1 )
    //(
    //if
    /*U::COMMENT OUT IN PRODUCTION:*/

    // /* if( bChatterP )*/ pP.ether.traceF( tinBaseP , T("healing ++++ [idName]:    ")+TF2(idNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    //bChatterP = 1 ; //U:: TO FIND A BUG
    _IO_
{
voidT healShortNameF( tinBaseS& tinBaseP , etherC& etPrimeP , paramHealFileS& pP , textC& tShortP , const flagsT flagsModeP , const countT idNameP , const countT cShortNamesP , const countT cToHireHealP , const countT cToHireCompareP , boolT bChatterP )

}
    //etherP.traceF( tinBaseP , T("compareOoImagesF / ----") ) ;
    }
        }
            //if( !( id In % ( TUCK << 4 ) ) ) etherP.traceF( tinBaseP , T("images match [id In]:    ")+TF2(id In,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        else
        }
            //etherP.delF( tinBaseP , psttGen ) ;
            //etherP.traceF( tinBaseP , tIndent3P+T("wrote inner [gen]:    ")+T(psttGen) ) ;
            //etherP.boxPutGenerationF( tinBaseP , psttGen , tLikeInner+TF3(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) , TUCK , ppbwInner[ offi ] , cbwOuter ) ; ___( psttGen ) ;
    
            //etherP.delF( tinBaseP , psttGen ) ;
            //etherP.traceF( tinBaseP , tIndent3P+T("wrote outer [gen]:    ")+T(psttGen) ) ;
            //etherP.boxPutGenerationF( tinBaseP , psttGen , tLikeOuter , TUCK , pbwOuter , cbwOuter ) ; ___( psttGen ) ;
            //ZE( strokeS* , psttGen ) ;
    
            //etherP.traceF( tinBaseP , tIndent3P+T("difference detected between unique and inner [idWindow,offi]:    ")+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    
            bEqualP = 0 ;
        {
        if( sgn )

        }
            if( cbWas == setIfEqualsAM( cbNewlyCompared , cbNow , cbWas ) ) break ;
            countT cbNow = cbWas + cbwOuterP ;
            countT cbWas = cbNewlyCompared ;
        {
        for(;;)
    {
    if( !bAbortP )
    
    //countT id In = 1 + incv02AM( id InLath ) ;
    //sta tic countT id InLath ;
    
    if( etPrimeP ) bAbortP = 1 ;

    }
        }
            }
                }
                    etherP.traceF( tinBaseP , T("decremented cPause after nap after exception [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    was = decv02AM( cPauseP ) ;
                    ++ s ; etPrimeP.osSleepF( tinBaseP , TIMEpAUSEoNfAIL ) ;
                    etherP.traceF( tinBaseP , T("incremented cPause on exception [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT was = incv02AM( cPauseP ) ;
                {
                else
                }
                    break ;
                    bAbortP = 1 ;
                {
                else if( !cTries )
                if( bAbortP ) break ;

                if( etPrimeP ) bAbortP = 1 ;

                //etherP.traceF( tinBaseP , tIndent3P+T("!exception / memCompareF impotence ; aborting if !cTries [cTries,idCulprit,tLongOuter,tLongInner]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idCulprit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuterP+tb4+tLongInnerP ) ;
                POOPRqUIET
    
                }
                    default                             : { etherP.traceF( tinBaseP , T("!exception: software error: unknown impotence code (ifcIDiMPOTENCEmEMcMP)") ) ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_COMPARE2  : { idCulprit = 2 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_COMPARE1  : { idCulprit = 1 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_COMPARE0  : {                 break ; }
                    case ifcIDiMPOTENCEmEMcMP_LATHbYTE2 : { idCulprit = 2 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_WOTHbYTE2 : { idCulprit = 2 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_LATHbYTE1 : { idCulprit = 1 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_WOTHbYTE1 : { idCulprit = 1 ; break ; }
                    //CS:CODEsYNC: 510007e9 112005be
                {
                switch( POOP )
                ZE( countT , idCulprit ) ;
            {
            else
            if( !POOP ) break ;
            //etherP.traceF( tinBaseP , tIndent3P+T("called  memCompareF [cb]:    ")+TF2(cbwOuterP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            sgn = ((tinNormalS&)tinBaseP).pEtScratch->memCompareF( tinBaseP , pbwOuterP , pbwInnerP , cbwOuterP ) ;
            //etherP.traceF( tinBaseP , tIndent3P+T("calling memCompareF [cb]:    ")+TF2(cbwOuterP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        while( bEqualP && !etPrimeP && !bAbortP && cTries -- )
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        countT cTries = ( F(flagsModeP) & flHEALmODE_STRICT ) ? 1 : CtRIESiFnOTsTRICT ;
    
        SCOOPS
    {
    IFsCRATCH
    ZE( sCountT , sgn ) ;
    //etherP.traceF( tinBaseP , tIndent3P+tLongInnerP ) ;
    //etherP.traceF( tinBaseP , tIndent3P+tLongOuterP ) ;
    //etherP.traceF( tinBaseP , T("compareOoImagesF / ++++" /*U::" [id In,cbwOuterP]:"*/ "    ")+TF2(id In,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)/*U::+tb4+TF2(cbwOuterP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)*/ ) ;
    //TN( tb4 , "    " ) ;

    //countT id In = 1 + incv02AM( id InLath ) ;
    //sta tic countT id InLath ;
{
voidT compareOoImagesF( tinBaseS& tinBaseP , etherC& etPrimeP , etherC& etherP , boolT& bAbortP , countT& cPauseP , boolT& bEqualP , const flagsT flagsModeP , const byteT* pbwOuterP , const byteT* pbwInnerP , countT cbwOuterP /*, const textC& tLongOuterP , const textC& tLongInnerP , textC& tIndent3P*/ )

countT cbNewlyCompared ;

}
    etherP.delF( tinBaseP , pEqualP ) ;

    }
        etherP.delF( tinBaseP , *(byteT**)&pfwsInnerP ) ;

        }
            DELzOMBIE( pDoomed ) ;
            fileWindowsC* pDoomed = pfwsInnerP + offi ;
        {
        for( countT offi = 0 ; offi < cInnerImagesToInspectP ; offi ++ )
    {
    if( pfwsInnerP )
{
voidT deleteEqualArrayFwsInnerArrayF( tinBaseS& tinBaseP , etherC& etherP , boolT*& pEqualP , fileWindowsC*& pfwsInnerP , countT cInnerImagesToInspectP )

}
    if( ether ) bAbortP = 1 ;

    }
        dec02AM( cExecutiveHealYearPausedP ) ;
        }
            ++ s ; ether.osSleepF( tinBaseP , TOCK ) ;
        {
        while( cPauseP && !ether )
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        inc02AM( cExecutiveHealYearPausedP ) ;
    {
    if( cPauseP && !ether && !bAbortP )
    etherC& ether = etherC::etPrimeIF( tinBaseP ) ;
{
voidT pauseIfF( tinBaseS& tinBaseP , boolT& bAbortP , countT& cExecutiveHealYearPausedP , countT& cPauseP )

}
    return *pfr1 - *pfr2 ;

    fileMetaS* pfr2 = (fileMetaS*)c2P ;
    fileMetaS* pfr1 = (fileMetaS*)c1P ;
{
/*1*/countT subtractFileMetaF( tinBaseS& tinBaseP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    return - sgn ;                          //SORT IN DECREASING ORDER OF SIZE SO THAT THE LARGEST FILES ARE PROCESSED WOTH
    sCountT sgn = *pJob1 - *pJob2 ;

    jobCompareOoImagesS* pJob2 = (jobCompareOoImagesS*)c2P ;
    jobCompareOoImagesS* pJob1 = (jobCompareOoImagesS*)c1P ;
{
/*1*/countT subtract_jobCompareOoImagesS_F( tinBaseS& tinBaseP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    tPathLonely  += tUniqueP+tSlash ;
    tPathRejects += tUniqueP+tSlash ;
{
grabDisk( grabDiskP )
funJobHealFileDone( funJobHealFileDoneP ) ,
st_pzJobHealFileDone( st_pzJobHealFileDoneP ) ,
pzpsttPathToYear( ppsttPathToYearP ) ,
cResultStructsNeeded( cResultStructsNeededP ) ,
cPathsToYear( cPathsToYearP ) ,
funJobFileInfo( funJobFileInfoP ) ,
stJobCompare( stJobCompareP ) ,
cExecutiveHealYearPaused( cExecutiveHealYearPausedP ) ,
cProcessors( thirdC::osProcessorsIF( tinBaseP ) ) ,
tArchive( tArchiveP ) ,
tYear( tYearP ) ,
tPathLonely(    tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "/ideafarm.archives.lonely/" ) ,
tPathRejects(   tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "/ideafarm.archives.rejects/" ) ,
tPathArchives(  tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "/ideafarm.archives/" ) ,
tIndent3(  tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "|           " ) ,
tIndent2(  tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "|       " ) ,
tIndent1(  tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "|   " ) ,
tSlash( tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "/" ) ,
tDot( tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "." ) ,
tb4( tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "    " ) ,
tn( tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
cPause( cPauseP ) ,
bAbort( bAbortP ) ,
etPrime( etherC::etPrimeIF() ) ,
ether( etherP ) ,
paramHealFileS::paramHealFileS( tinBaseS& tinBaseP , etherC& etherP , boolT& bAbortP , countT& cPauseP , textC& tYearP , textC& tArchiveP , textC& tUniqueP , countT& cExecutiveHealYearPausedP , stackC& stJobCompareP , funnelHornC& funJobFileInfoP , const countT cPathsToYearP , const countT cResultStructsNeededP , const strokeS** const ppsttPathToYearP , stackC& st_pzJobHealFileDoneP , funnelHornC& funJobHealFileDoneP , grabC& grabDiskP ) :

}
    ((tinNormalS&)tinBaseP).pEther->traceF( tinBaseP , T(psttP)+T(" [bitsResult]:    ")+TF4(bitsResult,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
{
voidT imageCompareS::traceF( tinBaseS& tinBaseP , const strokeS* const psttP )

}
    //traceF( tinBaseP , T("ct      :    ") ) ;
    TINSL
{
bitsResult( BITSrESULT_UNKNOWN )
imageCompareS::imageCompareS( voidT ) :

NEWdELcLASS( 5 , imageCompareS ) ;

}
    return ((tinNormalS&)tinBaseP).pEther->memCompareF( tinBaseP , (byteT*)this , (byteT*)&frP , sizeof( countT ) + sizeof( count04T ) ) ;    //CS:CODEsYNC 1 1
    TINSL
{
sCountT fileMetaS::operator -( const fileMetaS& frP ) const

}
    //((tinNormalS&)tinBaseP).pEther->traceF( tinBaseP , T(psttP)+T(" [timeModRounded,timeMod,cbUsed,cVotes,idSlotPathToYear,path]:    ")+TF3(timeModRounded,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T("    ")+TT(time1Mod,time2Mod)+T("    ")+TT(((countT*)&cbUsed)[0],((countT*)&cbUsed)[1])+T("    ")+TF2(cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idSlotPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((strokeS*)st O ldPathToYearP[idSlotPathToYear]) ) ;
{
voidT fileMetaS::traceF( tinBaseS& tinBaseP , const strokeS* const psttP )

}
    timeModRounded = *(countT*)( (byteT*)pc2 + 3 ) + bRoundUp ;
    countT pc2[ 2 ] = { time1Mod , time2Mod } ;

    boolT bRoundUp = !!( ( time1Mod & 0xffffff ) > 0x800000 ) ;

    }
        bAbortP = 1 ;
        ((tinNormalS&)tinBaseP).pEther->traceF( tinBaseP , T("fileMetaS::fileMetaS / !exception: idSlotPathToYear is null") ) ;
    {
    if( !idSlotPathToYear )
{
idSlotPathToYear( idSlotPathToYearP )
cVotes( 0 ) ,
time2Mod( time2ModP ) ,
time1Mod( time1ModP ) ,
cbUsed( cbUsedP ) ,
timeModRounded( 0 ) ,
fileMetaS::fileMetaS( tinBaseS& tinBaseP , boolT& bAbortP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) :

NEWdELcLASS( 4 , fileMetaS ) ;

}
{
pInfo( *(infoFileS**)0 )
psttLong( 0 ) ,
ether( *(etherC*)0 ) ,
jobFileInfoS::jobFileInfoS( voidT ) :

}
    ether.strMakeF( tinBaseP , LF , psttLong , psttLongP ) ; ___( psttLong ) ;
{
pInfo( pInfoP )
psttLong( 0 ) ,
ether( etherP ) ,
jobFileInfoS::jobFileInfoS( tinBaseS& tinBaseP , etherC& etherP , const strokeS* const psttLongP , infoFileS*& pInfoP ) :

}
    ether.delF( tinBaseP , psttLong ) ;
    TINSL
{
jobFileInfoS::~jobFileInfoS( voidT )

NEWdELcLASS( 3 , jobFileInfoS ) ;

}
{
cShortNames( 0 )
idName( 0 ) ,
psttShort( 0 ) ,
info( *(paramHealFileS*)0 ) ,
cJobsPendingHeal( *(countT*)0 ) ,
ether( *(etherC*)0 ) ,
jobHealFileS::jobHealFileS( voidT ) :

}
    //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("++++ [cJobsPendingHealAfterCt,idName,short]:    ")+TF3(cJobsPendingHealNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(" ")+T(psttShort) ) ;
    ether.strMakeF( tinBaseP , LF , psttShort , psttShortP ) ; ___( psttShort ) ;

    countT cJobsPendingHealNow = 1 + incv02AM( cJobsPendingHeal ) ;
{
cShortNames( cShortNamesP )
idName( idNameP ) ,
psttShort( 0 ) ,
info( infoP ) ,
cJobsPendingHeal( cJobsPendingHealP ) ,
ether( etherP ) ,
jobHealFileS::jobHealFileS( tinBaseS& tinBaseP , etherC& etherP , countT& cJobsPendingHealP , paramHealFileS& infoP , const strokeS* const psttShortP , const countT idNameP , const countT cShortNamesP ) :

}
    ether.delF( tinBaseP , psttShort ) ;
    //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("---- [cJobsPendingHealAfterDt,idName,short]:    ")+TF3(cJobsPendingHealNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(" ")+T(psttShort) ) ;
    countT cJobsPendingHealNow = decv02AM( cJobsPendingHeal ) - 1 ;
    if( !pEther ) { BLAMMO ; }              // IT IS ILLEGAL TO CT USING THE DEFAULT CT'OR WITHOUT IMMEDIATELY OVERWRITING THE IMAGE TO MAKE IT VALID
    etherC* pEther = &ether ;
    TINSL
{
jobHealFileS::~jobHealFileS( voidT )

NEWdELcLASS( 2 , jobHealFileS ) ;

}
{
psttLongInner( 0 )
psttLongOuter( 0 ) ,
cbwOuter( 0 ) ,
pbwInner( 0 ) ,
pbwOuter( 0 ) ,
bEqual( *(boolT*)0 ) ,
cJobsPendingCompare( *(countT*)0 ) ,
ether( *(etherC*)0 ) ,
jobCompareOoImagesS::jobCompareOoImagesS( voidT ) :

}
    ether.strMakeF( tinBaseP , LF , psttLongInner , psttLongInnerP ) ; ___( psttLongInner ) ;
    ether.strMakeF( tinBaseP , LF , psttLongOuter , psttLongOuterP ) ; ___( psttLongOuter ) ;

    inc02AM( cJobsPendingCompare ) ;
{
psttLongInner( 0 )
psttLongOuter( 0 ) ,
cbwOuter( cbwOuterP ) ,
pbwInner( pbwInnerP ) ,
pbwOuter( pbwOuterP ) ,
bEqual( bEqualP ) ,
cJobsPendingCompare( cJobsPendingCompareP ) ,
ether( etherP ) ,
jobCompareOoImagesS::jobCompareOoImagesS( tinBaseS& tinBaseP , etherC& etherP , countT& cJobsPendingCompareP , boolT& bEqualP , const byteT* pbwOuterP , const byteT* pbwInnerP , countT cbwOuterP , const strokeS* const psttLongOuterP , const strokeS* const psttLongInnerP , count04T cbUsedMax04P ) :

}
    dec02AM( cJobsPendingCompare ) ;
    ether.delF( tinBaseP , psttLongInner ) ;
    ether.delF( tinBaseP , psttLongOuter ) ;
    if( !pEther ) { BLAMMO ; }              // IT IS ILLEGAL TO CT USING THE DEFAULT CT'OR WITHOUT IMMEDIATELY OVERWRITING THE IMAGE TO MAKE IT VALID
    etherC* pEther = &ether ;
    TINSL
{
jobCompareOoImagesS::~jobCompareOoImagesS( voidT )

NEWdELcLASS( 1 , jobCompareOoImagesS ) ;

osTextT* postDebugLever ;

countT cYearsInParallelHeal = CyEARSiNpARALLELhEAL ;
const countT cResultsPerStruct = sizeof( countT ) * SB / 2 ;     // 2 BITS ARE USED TO STORE A RESULT, SO 4 RESULTS FIT INTO A BYTE AND 01 RESULTS FIT INTO A count02T ; MY CODE SHOULD BE WRITTEN WITHOUT ASSUMING countT IS count02T

;
}
    voidT traceF( tinBaseS& tinBaseP , const strokeS* const psttP = 0 ) ;
    inline sCountT operator -( imageCompareS& picP ) { return bitsResult - picP.bitsResult ; }
    imageCompareS( voidT ) ;
    NEWdELcLASSpROTOS

    countT bitsResult ;
{
struct imageCompareS

;
}
    sCountT operator -( const fileMetaS& frP ) const ;
    voidT traceF( tinBaseS& tinBaseP , const strokeS* const psttP = 0 ) ;
    fileMetaS( tinBaseS& tinBaseP , boolT& bAbortP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) ;
    NEWdELcLASSpROTOS

    countT   idSlotPathToYear ;
    countT   cVotes ;
    sCountT  time2Mod ;
    countT   time1Mod ;
    count04T cbUsed ;
    countT   timeModRounded ;   //CS:CODEsYNC 1 1
{
struct fileMetaS

;
}
    jobFileInfoS( voidT ) ;
    jobFileInfoS( tinBaseS& tinBaseP , etherC& etherP , const strokeS* const psttLongP , infoFileS*& pInfoP ) ;
    ~jobFileInfoS( voidT ) ;
    NEWdELcLASSpROTOS

    infoFileS*&         pInfo    ;      //NOTE THAT THIS IS A REFERENCE TO ANOTHER LOCATION WHERE A POINTER VALUE IS TO BE STORED
    strokeS*            psttLong ;
    etherC&             ether    ;
{
struct jobFileInfoS

;
}
    }
        ;
                : 0
                ? - 1
            : cbUsedMax04 < heP.cbUsedMax04
            ? 1
        return cbUsedMax04 > heP.cbUsedMax04
    {
    inline sCountT operator -( jobCompareOoImagesS& heP ) const
    inline operator countT( voidT ) const { return cbwOuter << 1 ; }

    jobCompareOoImagesS( voidT ) ;
    jobCompareOoImagesS( tinBaseS& tinBaseP , etherC& etherP , countT& cJobsPendingCompareP , boolT& bEqualP , const byteT* pbwOuterP , const byteT* pbwInnerP , countT cbwOuterP , const strokeS* const psttLongOuterP , const strokeS* const psttLongInnerP , count04T cbUsedMax04P ) ;
    ~jobCompareOoImagesS( voidT ) ;
    NEWdELcLASSpROTOS


    count04T     cbUsedMax04         ;
    strokeS*     psttLongInner       ;
    strokeS*     psttLongOuter       ;
    countT       cbwOuter            ;
    const byteT* pbwInner            ;
    const byteT* pbwOuter            ;
    boolT&       bEqual              ;
    countT&      cJobsPendingCompare ;
    etherC&      ether               ;
{
struct jobCompareOoImagesS

;
}
    jobHealFileS( voidT ) ;
    jobHealFileS( tinBaseS& tinBaseP , etherC& etherP , countT& cJobsPendingHealP , paramHealFileS& infoP , const strokeS* const psttShortP , const countT idNameP , const countT cShortNamesP ) ;
    ~jobHealFileS( voidT ) ;
    NEWdELcLASSpROTOS

    const countT        cShortNames      ;
    const countT        idName           ;
    strokeS*            psttShort        ;
    paramHealFileS&     info             ;
    countT&             cJobsPendingHeal ;
    etherC&             ether            ;
{
struct jobHealFileS

;
}
    paramHealFileS( tinBaseS& tinBaseP , etherC& etherP , boolT& bAbortP , countT& cPauseP , textC& tYearP , textC& tArchiveP , textC& tUniqueP , countT& cExecutiveHealYearPausedP , stackC& stJobCompareP , funnelHornC& funJobFileInfoP , const countT cPathsToYearP , const countT cResultStructsNeededP , const strokeS** const ppsttPathToYearP , stackC& st_pzJobHealFileDoneP , funnelHornC& funJobHealFileDoneP , grabC& grabDiskP ) ;

    grabC&                  grabDisk ;
    funnelHornC&            funJobHealFileDone ;
    stackC&                 st_pzJobHealFileDone  ;
    const strokeS** const   pzpsttPathToYear ;
    const countT            cResultStructsNeeded ;
    const countT            cPathsToYear ;
    funnelHornC&            funJobFileInfo ;
    stackC&                 stJobCompare ;
    countT&                 cExecutiveHealYearPaused ;
    const countT            cProcessors ;

    textC&                  tArchive ;
    textC&                  tYear ;

    textC                   tPathLonely ;
    textC                   tPathRejects ;
    textC                   tPathArchives ;
    textC                   tIndent3 ;
    textC                   tIndent2 ;
    textC                   tIndent1 ;
    textC                   tSlash ;
    textC                   tDot ;
    textC                   tb4 ;
    textC                   tn ;

    countT&                 cPause ;
    boolT&                  bAbort ;
    etherC&                 etPrime ;
    etherC&                 ether ;
{
struct paramHealFileS

#define IDpHASE_HEAL                    0x4
#define IDpHASE_CHUNKfILESbYdAY         0x3
#define IDpHASE_GETnAMESoNLY            0x2
#define IDpHASE_ARCHIVEnEWfSETS         0x1
#define CpHASES 4

#define IDtYPEjOB_COPY       0x3
#define IDtYPEjOB_MOVEuNIQUE 0x2
#define IDtYPEjOB_NULL       0x1

//#define CyEARSiNpARALLELhEAL  0x1
//B:#define CyEARSiNpARALLELhEAL  0x2
//B:#define CyEARSiNpARALLELhEAL  0x4
//G:#define CyEARSiNpARALLELhEAL  0x1
//U:: TO TEST WITH 32_9 DEVICES WITH SUSPECTED INADEQUATE POWER

//B: WORSE:  CPU NOT PEGGED: #define CyEARSiNpARALLELhEAL  0x1

#define CyEARSiNpARALLELhEAL            0x1
#define CyEARSiNpARALLELcHUNKfILESbYdAY 0x1
#define CyEARSiNpARALLELgETnAMESoNLY    0x10

//20240526@0904: CONJ: WO YEAR AT A TIME IS OPTIMAL BECAUSE DISK I/O IS THE BOTTLENECK SO IT IS OPTIMAL TO MAKE DISK I/O AS EFFICIENT AS POSSIBLE ; WO YEAR AT A TIME ELIMINATES CONTENTION ON EACH DISK, WHICH CAUSES MUCH HEAD SEEK MOVEMENT

//20240526@0903: SORTA AOK BUT SOME FAILS: #define CyEARSiNpARALLELhEAL  0x4
//20240508@1121: AOK:  #define CyEARSiNpARALLELhEAL  0x2
//20240507@1823: FAIL: #define CyEARSiNpARALLELhEAL  0x8

//B:MEMORY EXHAUSTION: #define CyEARSiNpARALLELhEAL  0x10

//B:MEMORY EXHAUSTION: #define CyEARSiNpARALLELhEAL  0x18

//B:DOES NOT PEG CPU WITH 4 YEARS: #define CyEARSiNpARALLELhEAL  0x18

//#define CyEARSiNpARALLELhEAL  8
//20231022@1244: 8 <-- 4
//20230922@0852: STUDY DOING 1 YEAR AT A TIME WITH ALL FILES PROCESSED ASYNCHRONOUSLY (BY PUSHING TO JOB stackC's)

//#define CyEARSiNpARALLELhEAL  0x8
//B: cpu only 1/3 used:#define CyEARSiNpARALLELhEAL  0x8

//NO IMPROVEMENT IN SWAPPING AND NOT PEGGED: #define CyEARSiNpARALLELhEAL  0x2
//OK BUT LOTS OF SWAPPING: #define CyEARSiNpARALLELhEAL  0x4
//B:"!exception: napping: too many pending job bytes: #define CyEARSiNpARALLELhEAL  0x8

//BAD:20230709@1002: #define CyEARSiNpARALLELhEAL  0x10
//BAD:#define CyEARSiNpARALLELhEAL  0x20
//AOK:#define CyEARSiNpARALLELhEAL  0x1
//AOK:#define CyEARSiNpARALLELhEAL  0x4
//AOK:#define CyEARSiNpARALLELhEAL  0x8
//AOK:#define CyEARSiNpARALLELhEAL  0x10
//U::TO FIND A BUG

#define CeXTRAcYCLESiFpAUSE 1

#define CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ( TOCK << 0 )
#define CBdATAbOOKsHORTfILEnAMES           ( TICK >> 1 )
//#define CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ( TOCK << 2 )
//#define CBdATAbOOKsHORTfILEnAMES           ( TICK << 1 )
//20240716@1808: NOW THAT THE ARCHIVE IS CHUNKED, THESE DON'T NEED TO BE SO LARGE; THE OLD VALUES EXHAUSTED MEMORY WHEN PROCESSING 01 YEARS SIMULTANEOUSLY
// THESE ARE TUNED TO BE LARGE ENOUGH FOR THE YEAR 2014, WHICH HAS THE LARGEST NUMBER OF SHORT FILE NAMES

#define CwORKERStHRESHOLDdOnOTlAUNCHmORE   ( TUCK >> 4 )

#define TIMEpAUSEoNfAIL ( TOCK << 4 )

//AMAZINGLY, IT WORKS!: #define CBfILEwINDOW   ( TICK << 1 )
// JUST FOR SHITS AND GIGGLES, TRY THIS
//20231010@1313: AOK BITCH ASS FAST.  FOR 01 VOLUMES, USES 1/2 OF USABLE ADDRESS SPACE:            ( TICK >> 0 )
//20231010@1250: AOK (WO YEAR AT A TIME, WO FILE AT A TIME, 22_9 VOLUMES, 2099, LARGE FILES WOTH): ( TICK >> 4 )
//20230819@1143: MEMORY EXHAUSTED WITH 5 YEARS AND f DEVICES PER YEAR: #define CBfILEwINDOW        ( TICK >> 2 )
//20230708@0837: MEMORY EXHAUSTED WITH a YEARS AND 6 DEVICES PER YEAR: #define CBfILEwINDOW        ( TICK >> 1 )
//20231010@1431: CBfILEwINDOW IS OBSOLETED BY USE OF CBaLLfILEwINDOWS

#define INFOfILEnOTaVAILABLE ( (infoFileS*)( - 1 ) )

#endif

    #define CtOhIREhEAL    1
    #define CtOhIREcOMPARE 0x18

    //#define CtOhIREhEAL    0x1
    //#define CtOhIREcOMPARE 0x20

    //#define CtOhIREhEAL    0x2
    //#define CtOhIREcOMPARE 0x10

    //.#define CtOhIREhEAL    0x1
    //#define CtOhIREcOMPARE 0xb

    //#define CtOhIREhEAL    0x1
    //#define CtOhIREcOMPARE 0x20

    //#define CtOhIREhEAL    0x10
    //#define CtOhIREcOMPARE 8

#else

    #define CtOhIREhEAL    1
    #define CtOhIREcOMPARE 0x18

#if defined( IFCtESTING )


//U::G: #define CtOhIREhEAL    8
//U::G: BUT DOES NOT PEG CPU: #define CtOhIREhEAL    4

#define CBaLLfILEwINDOWS ( TICK << 5 )
//20240527@1601: NOPE: #define CBaLLfILEwINDOWS ( TICK << 6 )
//20240527@1600: AOK: #define CBaLLfILEwINDOWS ( TICK << 5 )
//20231010@1601: NOPE: TRY TICK << 6, WHICH IS 1/2 OF USER ADDRESS SPACE

#define BITSrESULT_ALLbITS        3
#define BITSrESULT_EQUAL          2
#define BITSrESULT_NOTeQUAL       1
#define BITSrESULT_UNKNOWN        0

#define CtRIESiFnOTsTRICT   ( TUCK >> 5 )

#define flHEALmODE_LONELYiSoK          0xe00020ff
#define flHEALmODE_NOmOVEoRrEPLACE     0xe00010ff
#define flHEALmODE_NOiMAGEcOMPARE      0xe00008ff
#define flHEALmODE_STRICT              0xe00004ff
#define flHEALmODE_HIBERNATEoSwHENdONE 0xe00002ff
#define flHEALmODE_KEEPnAMES           0xe00001ff
#define flHEALmODE_null                0xe00000ff

#define FUNNELhORNcAPACITY       ( TUCK )

#define IFCtESTING

//#define OVERRIDElONELYiSoK
//#define OVERRIDEkEEPnAMES
//#define OVERRIDEnOhIBERNATEoS
//#define OVERRIDEdOnOTmOVEoRrEPLACEfILES
//#define OVERRIDEnOiMAGEcOMPARE
//THESE SHOULD BE COMMENTED OUT IN PRODUCTION ; THEY ARE USED FOR EXTRA SAFETY WHEN E.G. RECOVERING DATA

//FOR NORMAL PRODUCTION, IMAGE COMPARE SHOULD NEVER BE SUPPRESSED, BECAUSE THAT CAN RESULT IN THE PROPOGATION OF CORRUPT FILES
//THIS IS ONLY FOR SPECIAL APPLICATIONS

// AN ARRAY OF [cb4Used,idJot] SORTED BY cb4Used IS WRITTEN TO DISK AND REUSED FROM DISK
// LIKE 804 BUT PROCESSES SHORT NAMES IN DESCENDING ORDER OF SIZE
//OBSOLETES 804

/*1*/WAKEhIDE( "ifcIDaDAM_HEALaRCHIVES" )/*1*/
/**/
*/
i look for ///?/ideafarm.archives/ folders and, if found, i heal them
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
