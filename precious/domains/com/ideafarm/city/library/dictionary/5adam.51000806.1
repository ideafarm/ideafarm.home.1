
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

}
    // #endif
    //     //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SHUTDOWN ) ;
    // #if defined( IFC tESTING )

    }
        }
            ++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
        {
        while( cWorkersCompare || cWorkersHeal )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    {

    swJotSortedShortByArchiveYear.ungrabF( tinP ) ;
    }
        DEL( pDoomed ) ;                                                                        //20230306@1825: U:: jotC DT/OR FAILS COMPLAINING THAT pEtScratch IS IMPOTENT ; HOW: CTRL-C OR FIRE SERVICE
        jotC*& pDoomed = (jotC*&)(countT&)swJotSortedShortByArchiveYear ;
        psttzArchiveSlashYear = (strokeS*)swJotSortedShortByArchiveYear.leverF( tinP , idf ) ;
        _IO_
    {
    for( countT idf = 1 ; idf < cFlavors ; idf ++ )
    countT cFlavors = swJotSortedShortByArchiveYear.cFlavorsF( tinP ) ;
    swJotSortedShortByArchiveYear.grabF( tinP , TAG( TAGiDnULL ) ) ;

    }
        funJobHealFile.writeF( tinP , pbz ) ;
        new( 0 , tinP , pbz , sizeof pbz ) jobHealFileS( tinP , etThread , cnu , *(paramHealFileS*)0 , 0 , 0 , 0 ) ;
        byteT pbz[ sizeof( jobHealFileS ) ] ;
        ZE( countT , cnu ) ;
    {
    while( cWorkersHeal )

    FIREmYSELF              // THIS IS TO ENSURE THAT ether IS IMPOTENT

    }
        }
            }
                etThread.traceF( tinP , T("incremented  [offPhase]:    ")+TF2(offPhase,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
if( offPhase == OFFpHASE_HEAL ) offPhase = OFFpHASE_CHUNKfILESbYdAY ;
                offPhase = ++ offPhase % CpHASES ;
                etThread.traceF( tinP , T("incrementing [offPhase]:    ")+TF2(offPhase,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                }
                    }
                        break ;

                        }
                            ether.traceF( tinP , T("fired  base operating system (hibernate)") ) ;
                            ether.osSuspendF( tinP ) ;
                            ether.traceF( tinP , T("firing base operating system (hibernate)") ) ;
                        {
                        if( F(flagsMode) & flHEALmODE_FIREoS && !ether )

                        etThread.traceF( tinP , T("phase ended aok [time]:    ")+TT(time1AOK,time2AOK) ) ;
                        etThread.osTimeNowF( tinP , time1AOK , time2AOK ) ;
                        time2AOK = time1AOK = 0 ;
                    {
                    case OFFpHASE_CHUNKfILESbYdAY :
                    case OFFpHASE_HEAL            : { time2AOK = time1AOK = 0 ; break ; }       // THIS WILL CAUSE THE NEXT ITERATION TO PROCEED AFTER ONLY NAPPING WO TICK
                    case OFFpHASE_GETnAMESoNLY    :
                {
                switch( offPhase )
            {
            else
            }
                time2AOK = time1AOK = 0 ;      // THIS WILL CAUSE THE NEXT ITERATION TO PROCEED AFTER ONLY NAPPING WO TICK
                etThread.traceF( tinP , T("this phase was aborted") ) ;
                // /*if( cYearsInParallelHeal > 1 && 1 == decv02AM( cYearsInParallelHeal ) )*/ cYearsInParallelHeal = 1 ;  // REDUCE cYearsInParallelHeal BUT NOT BELOW 1
                //20230106@1137: NAWWH; ABORT IS NOW DONE ROUTINELY BY PAUSE/RESUME, SO DOES NOT IMPLY FAILURE
                //20221229@1435: IF ABORT THEN ON NEXT ITERATION PROCESS YEARS SERIALLY
            {
            if( bAbort )

            }
                }
                    ++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;

                    }
                        funJobFileInfo.writeF( tinP , pbz ) ;
                        new( 0 , tinP , pbz , sizeof pbz ) jobFileInfoS( tinP , etThread , T("") , pnu ) ;
                        byteT pbz[ sizeof( jobFileInfoS ) ] ;
                        ZE( infoFileS* , pnu ) ;
                    {
                    while( cDo -- )
                    countT cDo = cWorkersFileInfo ;
                {
                while( cWorkersFileInfo )
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                bQuitFileInfo = 1 ;
            {

            }
                }
                    //etThread.osSuspendF( tinP ) ;
                    //etThread.traceF( tinP , T("ok.  hibernating") ) ;

                    }
                        }
                            if( cExecutiveHealYearPaused ) { BLAMMO ; }

                            THREADmODE2rESTORE
                            }
                                thirdC::dosSleepWinkIF( tinP ) ;
                                //etThread.traceF( tinP , T("waiting for all exec to die [cExecutiveHealYear]:    ")+TF2(cExecutiveHealYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            while( cExecutiveHealYear )
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                            _IO_
                        {

                        }
                            while( !bAbort && ~hStYearToHeal ) ;
                            }
                                }
                                    }
                                        }
                                            break ;
                                            bAbort = 1 ;
                                            etThread.traceF( tinP , T("!exception: could not launch thread tmExecutiveHealYearF") ) ;
                                            dec02AM( cExecutiveHealYear ) ;
                                            POOPRqUIET
                                        {
                                        if( POOP )
                                        //U::tinP.pEtScratch->osThreadF( TaRG3fLAGScBtLS( tmExecutiveHealYearF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cPause , (countT)&funJobHealFile , (countT)&stJobCompare , (countT)&funJobFileInfo , (countT)&cYearsHealing , flagsMode , (countT)&cExecutiveHealYear , (countT)&cExecutiveHealYearPaused , (countT)&tUnique , (countT)psttYear , (countT)&psttzArchive , (countT)&swsPathToArchivesByArchiveName , (countT)&bAbort , (countT)&psttzArchiveSlashYear , (countT)&swJotSortedShortByArchiveYear , (countT)&cPathsToYearHealing , 1 + offPhase , (countT)&grabLathFileHealedFiles , (countT)&grabDisk ) ;
                                             tinP.pEtScratch->osThreadF( TaRG1(           tmExecutiveHealYearF                                                     ) , (countT)&cPause , (countT)&funJobHealFile , (countT)&stJobCompare , (countT)&funJobFileInfo , (countT)&cYearsHealing , flagsMode , (countT)&cExecutiveHealYear , (countT)&cExecutiveHealYearPaused , (countT)&tUnique , (countT)psttYear , (countT)&psttzArchive , (countT)&swsPathToArchivesByArchiveName , (countT)&bAbort , (countT)&psttzArchiveSlashYear , (countT)&swJotSortedShortByArchiveYear , (countT)&cPathsToYearHealing , 1 + offPhase , (countT)&grabLathFileHealedFiles , (countT)&grabDisk ) ;
                                        SCOOPS
                                        _IO_
                                    {
                                    IFsCRATCH
                                    inc02AM( cExecutiveHealYear ) ;

                                    etThread.strMakeF( tinP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                                    ZE( strokeS* , psttYear ) ;

                                    //etThread.traceF( tinP , T("year to heal:    ")+T(psttzYear) ) ;
                                    strokeS* psttzYear = (strokeS*)stYearToHeal.upF( tinP , hStYearToHeal ) ;       //PROCESSES YEARS BEGINNING WITH MOST RECENT  (A:ASSUME: CURRENT YEARS ARE IN MOST NEED OF HEALING SINCE FILES ARE ADDED AND MODIFIED)
                                {
                                if( !bAbort )

                                }
                                    THREADmODE2rESTORE
                                    while( test == cExecutiveHealYear ) thirdC::dosSleepWinkIF( tinP ) ;
                                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                                    countT test = offPhase == OFFpHASE_GETnAMESoNLY ? CyEARSiNpARALLELgETnAMESoNLY : cYearsInParallelHeal ;
                                    _IO_
                                {
                                _IO_
                            {
                            do
                            handleC hStYearToHeal( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            _IO_
                        {
                        if( !bAbort && stYearToHeal )

                        }
                            }
                                }
                                    }
                                        }
                                            break ;
                                            bAbort = 1 ;
                                            etThread.delF( tinP , psttYear ) ;
                                            etThread.traceF( tinP , T("!exception: duplicate year [psttYear]:    ")+T(psttYear) ) ;                        
                                        {
                                        if( !idSlot ) //SHOULD BE IMPOSSIBLE
                                        stYearToHeal.sinkF( tinP , idSlot , psttYear , flSTACKsINK_UNIQUE ) ;
                                        ZE( countT , idSlot ) ;
                                        etThread.strMakeF( tinP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                                        ZE( strokeS* , psttYear ) ;
                                        _IO_
                                    {
                                    if( !bIgnore && tally > 1 )
                                    countT tally = swTallyByYear ;

                                    //#endif
                                        ZE( boolT , bIgnore ) ;
                                    //#else
                                    //    ;
                                    //
                                    //          || !etThread.strCompareF( tinP , psttzYear , T("2099") )
                                    //          || !etThread.strCompareF( tinP , psttzYear , T("2023") )
                                    //          || !etThread.strCompareF( tinP , psttzYear , T("2022") )
                                    //          || !etThread.strCompareF( tinP , psttzYear , T("2021") )
                                    //          || !etThread.strCompareF( tinP , psttzYear , T("2020") )
                                    //          || !etThread.strCompareF( tinP , psttzYear , T("2019") )
                                    //          || !etThread.strCompareF( tinP , psttzYear , T("2018") )
                                    //          || !etThread.strCompareF( tinP , psttzYear , T("2017") )
                                    //          || !etThread.strCompareF( tinP , psttzYear , T("2016") )
                                    //          || !etThread.strCompareF( tinP , psttzYear , T("2015") )
                                    //          || !etThread.strCompareF( tinP , psttzYear , T("2014") )
                                    //          || !etThread.strCompareF( tinP , psttzYear , T("2013") )
                                    //             !etThread.strCompareF( tinP , psttzYear , T("2012") )
                                    //
                                    //    boolT bIgnore = 
                                    //#if defined( IFC tESTING )

                                    psttzYear = (strokeS*)swTallyByYear.leverF( tinP , idf ) ;
                                    _IO_
                                {
                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                countT cFlavors = swTallyByYear.cFlavorsF( tinP ) ;
                                _IO_
                            {
                            if( !bAbort )

                            while( ~hSwsPathToArchives ) ;
                            }
                                etThread.delF( tinP , pstt1PathToYear ) ;
                                }
                                    //etThread.traceF( tinP , T("[tYear,tally]:    ")+tYear+tb4+TF2((countT)swTallyByYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    swTallyByYear ++ ;
                                    psttzYear = tYear ;

                                    }
                                        etThread.delF( tinP , psttYear ) ;
                                        tYear = T(psttYear) ;
                                        etThread.strWordF( tinP , psttYear , psttc1 , sttq , sttSlash , - 2 ) ; ___( psttYear ) ;
                                        ZE( strokeS* , psttYear ) ;
                                    {
                                    TN( tYear , "" ) ;
                                    _IO_
                                {
                                FORsTRINGSiN1( pstt1PathToYear )
                                etThread.strConvertToLowerCaseF( tinP , pstt1PathToYear ) ;
                                }
                                    }
                                        break ;
                                        bAbort = 1 ;
                                        etThread.delF( tinP , pstt1PathToYear ) ;
                                        etThread.traceF( tinP , T("!exception: diskFindFileOrDirF failed [tPathToArchive]:    ")+tPathToArchive ) ;
                                        POOPRqUIET
                                    {
                                    if( POOP )
                                    tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                                    SCOOPS
                                    _IO_
                                {
                                IFsCRATCH
                                patternC pat( tinP , etThread , tYearPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                                ZE( strokeS* , pstt1PathToYear ) ;

                                etThread.traceF( tinP , T("[tPathToArchive]:    ")+tPathToArchive ) ;
                                TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchive)+tSlash ;
                                strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveName.downF( tinP , hSwsPathToArchives ) ;
                                _IO_
                            {
                            do
                            handleC hSwsPathToArchives( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            strokeS sttSlash( '/' ) ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

                            switchC swTallyByYear( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzYear ) ;
                            ZE( strokeS* , psttzYear ) ;
                            _IO_
                        {
                        stackC stYearToHeal( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

                        // FOR EACH YEAR FOLDER (ALL YEARS FOR THIS ARCHIVE NAME (EXAMPLE: ALL YEAR PATHS FOR EVERY YEAR FOR "wo.ideafarm"), LAUNCH A FILE RECORD COLLECTION THREAD
                        _IO_
                    {
                    if( cArchivesWithThisName > 1 )
                    //etThread.traceF( tinP , T("[cArchivesWithThisName,archive]:    ")+TF2(cArchivesWithThisName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzArchive) ) ;
                    swsPathToArchivesByArchiveName.ungrabF( tinP ) ;
                    countT cArchivesWithThisName = swsPathToArchivesByArchiveName ;
                    psttzArchive = (strokeS*)swsPathToArchivesByArchiveName.leverF( tinP , idf ) ;
                    swsPathToArchivesByArchiveName.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    _IO_
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )    // FOR EACH ARCHIVE NAME (EXAMPLE: "wo.ideafarm")
                swsPathToArchivesByArchiveName.ungrabF( tinP ) ;
                countT cFlavors = swsPathToArchivesByArchiveName.cFlavorsF( tinP ) ;
                swsPathToArchivesByArchiveName.grabF( tinP , TAG( TAGiDnULL ) ) ;
                #endif
                    TN( tYearPattern , "?" "?" "?" "?" "/" ) ;                                                              //20221118@1747: "????/" PROUCES A SPURIOUS COMPILER ERROR INVOLVING TRIGRAPH
                #else
                    //TN( tYearPattern , "2099/" ) ;          // THE YEAR WITH THE LARGEST FILE, ALSO WITH THE FILE OF SIZE 1,004,306,432
                    //TN( tYearPattern , "2013/" ) ;          // 10,000,635 BYTE FILE
                    //TN( tYearPattern , "2014/" ) ;          // THE YEAR WITH THE MOST SHORT NAME VALUES
                    //TN( tYearPattern , "2023/" ) ;
                    //TN( tYearPattern , "2022/" ) ;
                    //TN( tYearPattern , "2012/" ) ;
                    //TN( tYearPattern , "1999/" ) ;
                      TN( tYearPattern , "1234/" ) ;
                #if defined( IFCtESTING )
                _IO_
            {
            if( !bAbort )

            }
                etThread.delF( tinP , psttu ) ;
                tUnique = T(psttu) ;
                etThread.strUniqueF( tinP , psttu ) ; ___( psttu ) ;
                ZE( strokeS* , psttu ) ;
            {
            TN( tUnique , "" ) ;

            }
                }
                    etThread.osThreadF( TaRG3fLAGScBtLS( tmWorkerFileInfoF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&bQuitFileInfo , (countT)&cWorkersFileInfo , (countT)&bAbort , (countT)&cPause , (countT)&funJobFileInfo , flagsMode ) ;
                    inc02AM( cWorkersFileInfo ) ;
                {
                while( cDo -- )
                countT cDo = cArchive >> 1 ;
            {
            ZE( countT , cWorkersFileInfo ) ;
            ZE( boolT , bQuitFileInfo ) ;

            swsPathToArchivesByArchiveName.lockIfF( tinP ) ;

            etThread.delF( tinP , pstt1ArchivesAllLag ) ;
            }
                if( bAbort ) { ++ s ; ether.osSleepF( tinP , TOCK << 2 ) ; }

                }
                    break ;
                    etThread.delF( tinP , pstt1ArchivesAll ) ;
                    }
                        swsPathToArchivesByArchiveName.sinkF( tinP , countTC() , psttPathArchives ) ;                           // EXAMPLE: "///c/ipdos.arhives/"

                        psttzArchive = tArchive ;

                        //etThread.traceF( tinP , T("    [tPathArchives,tArchive]:    ")+T(psttPathArchives)+tb4+tArchive ) ;

                        }
                            etThread.delF( tinP , psttShorter ) ;
                            tArchive = T(psttShorter) ;
                            etThread.strSubstringF( tinP , psttShorter , idf , idl , tArchiveSlash ) ; ___( psttShorter ) ;
                            ZE( strokeS* , psttShorter ) ;
                        {
                        if( idl )
                        countT idl = tArchiveSlash.csF( tinP ) ? tArchiveSlash.csF( tinP ) - 1 : 0 ;
                        countT idf = 1 ;
                        TN( tArchive , "" ) ;                                                                                   // EXAMPLE: "wo.ideafarm"

                        }
                            etThread.delF( tinP , psttArchiveSlash ) ;
                            tArchiveSlash = T(psttArchiveSlash) ;
                            etThread.strBisectF( tinP , psttPathArchives , psttArchiveSlash , psttc3 , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathArchives ) ; ___( psttArchiveSlash ) ;
                            ZE( strokeS* , psttArchiveSlash ) ;
                        {
                        TN( tArchiveSlash , "" ) ;                                                                              // EXAMPLE: "wo.ideafarm/"
                        ZE( strokeS* , psttPathArchives ) ;                                                                     // EXAMPLE: "///c/ipdos.arhives/"

                        //etThread.traceF( tinP , T("processing archive ")+T(psttc3) ) ;                                          // EXAMPLE: "///c/ipdos.arhives/wo.ideafarm/"
                        _IO_
                    {
                    FORsTRINGSiN3( pstt1ArchivesAll )

                    }
                        continue ;
                        pstt1ArchivesAllLag = pstt1ArchivesAll ; pstt1ArchivesAll = 0 ;
                        etThread.delF( tinP , pstt1ArchivesAllLag ) ;
                        ++ s ; ether.osSleepF( tinP , TICK >> 4 ) ;
                        if( bTest3 ) etThread.traceF( tinP , T("napping for a minute [reason]:    my list of visible archives changed") ) ;
                        if( bTest2 ) etThread.traceF( tinP , T("napping for a minute [reason]:    waiting to give time for all archives to become visible") ) ;
                        if( bTest1 ) etThread.traceF( tinP , T("napping for a minute [reason]:    less than oo archives found") ) ;
                    {
                    if( bTest1 /*|| bTest2*/ || bTest3 )
                    boolT bTest3 = !pstt1ArchivesAllLag ? 0 : etThread.strCompareF( tinP , pstt1ArchivesAllLag , pstt1ArchivesAll ) ;
                    boolT bTest2 = !pstt1ArchivesAllLag ;
                    boolT bTest1 =  cArchive < 2 ;
                    _IO_
                {
                if( !bAbort )

                }
                    while( ~hWalk ) ;
                    }
                        etThread.strFuseSeparateF( tinP , pstt1ArchivesAll , psttzArchive ) ;
                        strokeS* psttzArchive = (strokeS*)stArchive.downF( tinP , hWalk ) ;
                    {
                    do

                    etThread.strMakeF( tinP , LF , pstt1ArchivesAll , 0 , cArchive * CSpREFIX + csttArchive ) ; ___( pstt1ArchivesAll ) ;

                    while( ~hWalk ) ;
                    }
                        csttArchive += psttzArchive->idAdam ;
                        cArchive ++ ;
                        strokeS* psttzArchive = (strokeS*)stArchive.downF( tinP , hWalk ) ;
                    {
                    do
                    ZE( countT , csttArchive ) ;

                    handleC hWalk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    _IO_
                {
                if( !bAbort && stArchive )
                ZE( strokeS* , pstt1ArchivesAll ) ;

                }
                    etThread.delF( tinP , pstt1Archives1 ) ;
                    }
                        }
                            }
                                bAbort = 1 ;                                                    
                                etThread.traceF( tinP , T("!exception: duplicate archive long name") ) ;
                                etThread.delF( tinP , psttArchive ) ;
                            {
                            if( !ids ) //SHOULD BE IMPOSSIBLE
                            stArchive.sinkF( tinP , ids , psttArchive , flSTACKsINK_UNIQUE ) ;
                            ZE( countT , ids ) ;
                            //etThread.traceF( tinP , T("sinking archive ")+T(psttArchive) ) ;

                            etThread.strMakeF( tinP , LF , psttArchive , psttc1 ) ; ___( psttArchive ) ;
                            ZE( strokeS* , psttArchive ) ;

                            //etThread.traceF( tinP , T("on lettered device [idArchive1,archive]:    ")+TF2(++cArchives,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttc1) ) ;
                        {
                        FORsTRINGSiN1( pstt1Archives1 )
                        ZE( countT , cArchives ) ;
                    {
                    if( !bAbort )

                    }
                        }
                            bAbort = 1 ;
                            etThread.traceF( tinP , T("!exception:  diskFindFileOrDirF [tLikeArchives1,tDiskCulprit]:    ")+tLikeArchives1+tb4+tDiskCulprit ) ;
                            POOPRqUIET

                            }
                                tDiskCulprit = T(postCulprit) ;
                                postCulprit[ 3 ] = ostCulprit ;
                                osTextT postCulprit[] = "///?/" ;
                            {
                            if( ostCulprit >= 'a' && ostCulprit <= 'z' ) 
                            osTextT ostCulprit = (osTextT)( POOP >> 0x18 ) ;
                            TN( tDiskCulprit , "" ) ;
                        {
                        if( POOP )
                        tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1Archives1 , tLikeArchives1 ) ; ___( pstt1Archives1 ) ;
                        SCOOPS
                        _IO_
                    {
                    IFsCRATCH
                    ZE( strokeS* , pstt1Archives1 ) ;
                    _IO_
                {
                if( !cPseudoVolumes ) //P:PERSONALITY:  IF PSEUDOVOLUMES EXIST THEN I DO NOT SCAN FOR DEVICES WITH DRIVE LETTERS ; THIS IS FOR USER CONVENIENCE. FOR EXAMPLE, BACKUP CAN BE RUN TO A LETTERED DEVICE WHILE HEAL IS RUNNING USING PSEUDODEVICES IN ///ideafarm/devices/, EVEN THOUGH THE BACKUP DEVICE IS ALSO A PSEUDODEVICE SO IS BEING USED BOTH FOR BACKUP AND FOR HEALING
                //etThread.traceF( tinP , T("accumulating archives on lettered devices") ) ;

                }
                    etThread.delF( tinP , pstt1PseudoVolumes ) ;
                    }
                        }
                            if( bAbort ) break ;
                            etThread.delF( tinP , pstt1Archives ) ;
                            }
                                }
                                    etThread.delF( tinP , pstt1Archives2 ) ;
                                    }
                                        }
                                            }
                                                bAbort = 1 ;                                                    
                                                etThread.traceF( tinP , T("!exception: duplicate archive long name") ) ;
                                                etThread.delF( tinP , psttArchive ) ;
                                            {
                                            if( !ids ) //SHOULD BE IMPOSSIBLE
                                            stArchive.sinkF( tinP , ids , psttArchive , flSTACKsINK_UNIQUE ) ;
                                            ZE( countT , ids ) ;
                                            //etThread.traceF( tinP , T("sinking archive ")+T(psttArchive) ) ;
            
                                            etThread.strMakeF( tinP , LF , psttArchive , psttc1 ) ; ___( psttArchive ) ;
                                            ZE( strokeS* , psttArchive ) ;

                                            cPseudoVolumes ++ ;
            
                                            //etThread.traceF( tinP , T("on mounted device [idArchive1,archive]:    ")+TF2(++cArchives,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttc1) ) ;
                                        {
                                        FORsTRINGSiN1( pstt1Archives2 )
                                        ZE( countT , cArchives ) ;
                                    {
                                    else
                                    if( bAbort ) break ;

                                    }
                                        }
                                            bAbort = 1 ;
                                            etThread.traceF( tinP , T("!exception:  diskFindFileOrDirF [psttc1,tDiskCulprit]:    ")+T(psttc1)+tb4+tDiskCulprit ) ;
                                            POOPRqUIET

                                            }
                                                tDiskCulprit = T(postCulprit) ;
                                                postCulprit[ 3 ] = ostCulprit ;
                                                osTextT postCulprit[] = "///?/" ;
                                            {
                                            if( ostCulprit >= 'a' && ostCulprit <= 'z' ) 
                                            osTextT ostCulprit = (osTextT)( POOP >> 0x18 ) ;
                                            TN( tDiskCulprit , "" ) ;
                                        {
                                        if( POOP )
                                        tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1Archives2 , psttc1 ) ; ___( pstt1Archives2 ) ;
                                        SCOOPS
                                        _IO_
                                    {
                                    IFsCRATCH
                                    ZE( strokeS* , pstt1Archives2 ) ;

                                    //etThread.traceF( tinP , T("[archives found on pseudoVolume]:    ")+T(psttc1) ) ;

                                    if( idLoop ++ ) { BLAMMO ; }
                                {
                                FORsTRINGSiN1( pstt1Archives )
                                ZE( countT , idLoop ) ;
                            {
                            else
                            if( bAbort ) break ;

                            }
                                }
                                    break ;
                                    bAbort = 1 ;
                                    etThread.traceF( tinP , T("!exception:  diskFindFileOrDirF ; aborting [pseudoVolume]:    ")+T(psttc1) ) ;
                                    POOPRqUIET
                                {
                                if( POOP )
                                tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1Archives , psttc1 , &pat ) ; ___( pstt1Archives ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            patternC pat( tinP , etThread , T("ideafarm.archives/") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                            ZE( strokeS* , pstt1Archives ) ;

                            //etThread.traceF( tinP , T("[pseudoVolume]:    ")+T(psttc1) ) ;
                        {
                        FORsTRINGSiN1( pstt1PseudoVolumes )
                    {
                    if( !bAbort )

                    }
                        }
                            bAbort = 1 ;
                            etThread.traceF( tinP , T("!exception:  diskFindFileOrDirF [tLikePseudoVolumes,tDiskCulprit]:    ")+tLikePseudoVolumes+tb4+tDiskCulprit ) ;
                            POOPRqUIET

                            }
                                tDiskCulprit = T(postCulprit) ;
                                postCulprit[ 3 ] = ostCulprit ;
                                osTextT postCulprit[] = "///?/" ;
                            {
                            if( ostCulprit >= 'a' && ostCulprit <= 'z' ) 
                            osTextT ostCulprit = (osTextT)( POOP >> 0x18 ) ;
                            TN( tDiskCulprit , "" ) ;
                        {
                        if( POOP )
                        tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1PseudoVolumes , tLikePseudoVolumes ) ; ___( pstt1PseudoVolumes ) ;
                        SCOOPS
                        _IO_
                    {
                    IFsCRATCH
                    ZE( strokeS* , pstt1PseudoVolumes ) ;
                    _IO_
                {
                if( !bAbort )
                ZE( countT , cPseudoVolumes ) ;
                //etThread.traceF( tinP , T("accumulating archives mounted in ")+tLikePseudoVolumes ) ;

                stackC stArchive( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                cArchive = bAbort = 0 ;
                _IO_
            {
            while( !ether )
            ZE( countT , cArchive ) ;
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            #endif
                //TN( tLikePseudoVolumes , "///ideafarm/devices/"          ) ;
                TN( tLikePseudoVolumes , "///d/ideafarm.home.101/devices/" ) ;
            #else
                TN( tLikePseudoVolumes , "///d/ideafarm.home.101/devices/" ) ;
            #if defined( IFCtESTING )
            TN( tLikeArchives1 , "///?/ideafarm.archives/" ) ;
            ZE( strokeS* , pstt1ArchivesAllLag ) ;

            switchStackC swsPathToArchivesByArchiveName( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzArchive , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
            ZE( strokeS* , psttzArchive ) ;
            // LOAD swsPathToArchivesByArchiveName WITH VALUES LIKE "///c/ideafarm.arhives/" OR "///ideafarm/devices/mydevname/ideafarm.archives/" SWITCHED ON VALUES LIKE "wo.ideafarm"
            _IO_
        {
        if( !ether )

        }
            }
                if( !bWaitWoDay ) etThread.traceF( tinP , T("napped") ) ;
                ++ s ; ether.osSleepF( tinP , TICK >> 6 ) ;
                cNaps ++ ;
                if( !cNaps ) etThread.traceF( tinP , T(bWaitWoDay?"napping for a day":"napping for a quarter minute") ) ;
                _IO_
            {
            else
            }
                break ;
                if( bWaitWoDay ) etThread.traceF( tinP , T("napped  for a day") ) ;
            {
            )
                (  bWaitWoDay && time2E )            // A DAY'S NAP IS     REQUIRED AND I'VE NAPPED FOR A DAY
                ||
                ( !bWaitWoDay && cNaps  )            // A DAY'S NAP IS NOT REQUIRED AND I'VE NAPPED WO TIME
            (
            if

            etThread.osTimeSubtractF( tinP , time1E , time2E , time1AOK , time2AOK ) ;
            etThread.osTimeNowF( tinP , time1E , time2E ) ;
            ZE( sCountT , time2E ) ;
            ZE( countT  , time1E ) ;

            boolT bWaitWoDay = !!time2AOK ;
            _IO_
        {
        while( !ether )
        ZE( countT , cNaps ) ;
        etThread.traceF( tinP , T("[offPhase]:    ")+TF2(offPhase,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        _IO_
    {                                   // BUT NOT ALL ITERATIONS ARE SUCCESSFUL ; THOSE THAT FAIL ARE RETRIED, AND THE PHASE ID IS NOT ADVANCED UNTIL THE CURRENT PHASE SUCCEEDS
    while( !ether && !POOP )            // EVERY 3 SUCCESSFUL ITERATIONS ARE [ PHASE1 , PHASE2 , PHASE3 ] ( 1: GET NAMES, 2: HEAL, 3: CHUNK FILES BY DAY ) ; THE PHASE ID DETERMINES WHAT tmExecutiveHealYearF DOES
    countT offPhase = OFFpHASE_GETnAMESoNLY ;

    ZE( boolT , bPhase3ChunkByDay ) ;
    ZE( boolT , bPhase2Heal       ) ;
    switchC swJotSortedShortByArchiveYear( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzArchiveSlashYear ) ;
    ZE( strokeS* , psttzArchiveSlashYear ) ;
    ZE( sCountT , time2AOK ) ;
    ZE( countT  , time1AOK ) ;

    //etThread.traceF( tinP , T("napped  for a half tick so you can plug in devices to heal") ) ;
    //++ s ; ether.osSleepF( tinP , TICK >> 1 ) ;
    //etThread.traceF( tinP , T("napping for a half tick so you can plug in devices to heal") ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    }
        etThread.osThreadF( TaRG3fLAGScBtLS( tmWorkerMemCompareF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cWorkersCompare , (countT)&bAbort , (countT)&cPause , (countT)&stJobCompare , flagsMode , (countT)&cYearsHealing ) ;
        inc02AM( cWorkersCompare ) ;
    {
    while( cDo    -- )
    cDo = cToHireCompare ;

    }
        etThread.osThreadF( TaRG3fLAGScBtLS( tmWorkerHealFileF   , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cWorkersHeal , (countT)&bAbort , (countT)&cPause , (countT)&funJobHealFile , flagsMode , (countT)&cYearsHealing , cToHireHeal , cToHireCompare ) ;
        inc02AM( cWorkersHeal ) ;
    {
    while( cDo    -- )
    countT cDo = cToHireHeal ;

    ZE( countT , cWorkersHeal    ) ;
    ZE( countT , cWorkersCompare ) ;
    ZE( countT , cYearsHealing   ) ;

    // #endif
    //     //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , cToHireHeal ) ;
    // #if defined( IFC tESTING )

    }
        etThread.traceF( tinP , T("HEALaRCHIVES: [bKeepNames,bFireOs,bStrict,bNoImageCompare,bNoMoveOrReplace,bLonelyIsOk]:    ")+tb4+TF2(bKeepNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bFireOs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bStrict,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bNoImageCompare,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bNoMoveOrReplace,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bLonelyIsOk,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        boolT bLonelyIsOk       = !!( F(flagsMode) & flHEALmODE_LONELYiSoK         ) ;
        boolT bNoMoveOrReplace  = !!( F(flagsMode) & flHEALmODE_NOmOVEoRrEPLACE    ) ;
        boolT bNoImageCompare   = !!( F(flagsMode) & flHEALmODE_NOiMAGEcOMPARE     ) ;
        boolT bStrict           = !!( F(flagsMode) & flHEALmODE_STRICT             ) ;
        boolT bFireOs           = !!( F(flagsMode) & flHEALmODE_FIREoS             ) ;
        boolT bKeepNames        = !!( F(flagsMode) & flHEALmODE_KEEPnAMES          ) ;
    {

    etThread.traceF( tinP , T("HEALaRCHIVES: [cProcessors,cToHireHeal,cToHireCompare]:    ")+TF2(cProcessors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cToHireHeal,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cToHireCompare,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    //#endif
    //    flagsMode &= ~( F(flHEALmODE_FIREoS) ) ;
    //    *(countT*)&cToHireHeal = 0x1 ;
    //#if defined( IFC tESTING )

    ;
        : CtOhIREcOMPARE
        ? 0
    const countT cToHireCompare = F(flagsMode) & flHEALmODE_NOiMAGEcOMPARE

    ;
        : CtOhIREhEAL
        ? CtOhIREhEAL
    const countT cToHireHeal = F(flagsMode) & flHEALmODE_NOiMAGEcOMPARE

    //cToHireCompare = 4 ; //U:: FOR TESTING
    //cToHireCompare = 8 ; //U:: FOR TESTING
    //cToHireCompare = 1 ; //U:: FOR TESTING
    //countT cToHireCompare = cProcessors ;
    //countT cToHireCompare = cProcessors << 1 ;
    //countT cToHireCompare = cProcessors >> 1 ; // BEST BEFORE OPTIMIZATION
    //countT cToHireCompare = 1 ; // VERY SLOW
    //countT cToHireCompare = cProcessors << 3 ; //VERY SLOW
    //WORSE:cToHireHeal = cProcessors ; //FOR TESTING
    //countT cToHireHeal    = 1 /* cProcessors << 1 */ ;  //PRODUCTION:  ">> 1" "<< 0" TOO LITTLE JOB PUSHING ; \cToHireHeal == 1 SO THAT WO FILE IS HEALED AT A TIME ; THIS IS INTENDED TO MINIMIZE WASTAGE CAUSED BY FIRING HEALING ; WITH LARGE FILES IT SHOULD BE POSSIBLE TO KEEP CPU PEGGED WITH A SINGLE FILE AS INPUT

    const countT cProcessors = thirdC::osProcessorsIF( tinP ) ;

    etThread.osThreadF( TaRG3fLAGScBtLS( tmReportF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&grabLathFileHealedFiles , flagsMode ) ;

    }
        if( bLonelyIsOk ) flagsMode |= flHEALmODE_LONELYiSoK ;
        #endif
            bLonelyIsOk = 1 ;
        #if defined( OVERRIDElONELYiSoK )
        etThread.delF( tinP , psttv ) ;
        boolT bLonelyIsOk = psttv && !etThread.strCompareF( tinP , psttv , T("yes") ) ;
        ZE( strokeS* , psttv ) ; etThread.querySettingF( tinP , psttv , T("!ipdos.heallonelyisok")  ) ; ___( psttv ) ;
    {

    }
        if( bNoMoveOrReplace ) flagsMode |= flHEALmODE_NOmOVEoRrEPLACE ;
        #endif
            bNoMoveOrReplace = 1 ;
        #if defined( OVERRIDEdOnOTmOVEoRrEPLACEfILES )
        etThread.delF( tinP , psttv ) ;
        boolT bNoMoveOrReplace = psttv && !etThread.strCompareF( tinP , psttv , T("no") ) ;
        ZE( strokeS* , psttv ) ; etThread.querySettingF( tinP , psttv , T("!ipdos.healmoveorreplace")  ) ; ___( psttv ) ;
    {

    }
        if( bNoImageCompare ) flagsMode |= flHEALmODE_NOiMAGEcOMPARE ;
        #endif
            bNoImageCompare = 1 ;
        #if defined( OVERRIDEnOiMAGEcOMPARE )
        etThread.delF( tinP , psttv ) ;
        boolT bNoImageCompare = psttv && !etThread.strCompareF( tinP , psttv , T("no") ) ;
        ZE( strokeS* , psttv ) ; etThread.querySettingF( tinP , psttv , T("!ipdos.healimagecompare")  ) ; ___( psttv ) ;
    {

    }
        if( bStrict ) flagsMode |= flHEALmODE_STRICT ;
        etThread.delF( tinP , psttHealStrict ) ;
        boolT bStrict = psttHealStrict && !etThread.strCompareF( tinP , psttHealStrict , T("yes") ) ;
        ZE( strokeS* , psttHealStrict ) ; etThread.querySettingF( tinP , psttHealStrict , T("!ipdos.healstrict")  ) ; ___( psttHealStrict ) ;
    {

    }
        if( !bNoFireOs ) flagsMode |= flHEALmODE_FIREoS ;
        #endif
            bNoFireOs = 1 ;
        #if defined( OVERRIDEnOfIREoS )
        etThread.delF( tinP , psttHealFireOs ) ;
        boolT bNoFireOs = psttHealFireOs && etThread.strCompareF( tinP , psttHealFireOs , T("no") ) ;
        ZE( strokeS* , psttHealFireOs ) ; etThread.querySettingF( tinP , psttHealFireOs , T("!ipdos.healfireos")  ) ; ___( psttHealFireOs ) ;
    {

    }
        if( bKeepNames ) flagsMode |= flHEALmODE_KEEPnAMES ;
        #endif
            bKeepNames = 1 ;
        #if defined( OVERRIDEkEEPnAMES )
        etThread.delF( tinP , psttHealKeepNames ) ;
        boolT bKeepNames = psttHealKeepNames && !etThread.strCompareF( tinP , psttHealKeepNames , T("yes") ) ;
        ZE( strokeS* , psttHealKeepNames ) ; etThread.querySettingF( tinP , psttHealKeepNames , T("!ipdos.healkeepnames")  ) ; ___( psttHealKeepNames ) ;
    {

    flagsT flagsMode = flHEALmODE_null ;

    funnelHornC funJobFileInfo( tinP , etThread , countTC() , sizeof( jobFileInfoS ) , FUNNELhORNcAPACITY ) ;
    stackC      stJobCompare(  tinP , etThread , TAG( TAGiDnULL ) ) ;                                                       //U::MIGRATE FROM THIS TO USE A funnelHornC INSTANCE
    funnelHornC funJobHealFile( tinP , etThread , countTC() , sizeof( jobHealFileS ) , FUNNELhORNcAPACITY ) ;

    etThread.osThreadF( TaRG3fLAGScBtLS( tmObeyPauseSemaphoreFileF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&bAbort , (countT)&cPause , (countT)&cExecutiveHealYear , (countT)&cExecutiveHealYearPaused ) ;
    ZE( countT , cPathsToYearHealing      ) ;
    ZE( countT , cExecutiveHealYearPaused ) ;
    ZE( countT , cExecutiveHealYear       ) ;
    ZE( countT , cPause                   ) ;
    ZE( boolT  , bAbort                   ) ;

    grabC grabDisk(                tinP , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS ) ;
    grabC grabLathFileHealedFiles( tinP , TAG( TAGiDnULL ) , flGRABc_NOTjEALOUS ) ;

    TN( tSlash , "/" ) ;
    TN( tb4    , "    " ) ;
    _IO_
{
TODO

DONE( tmReportF )
}
    }
        ++ s ; ether.osSleepF( tinP , TICK >> 6 ) ;     //MUST BE SHORT ENOUGH TO AVOID OVERFLOW IN COUNTER

        }
            etThread.boxPutF( tinP , tFileReport , tReport , tReport.csF( tinP ) ) ;

            tReport += tcrlf+tcrlf+tcrlf+T("(end of report)\r\n") ;

            }
                while( !ether && ~hFindFile && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        }
                            etThread.delF( tinP , posti ) ;
                            }
                                }
                                    }
                                        }
                                            postc = postHitEnd + 2 ; // SKIPS CRLF
                                            tReport += T(postHit)+tcrlf ;
                                            *postHitEnd = 0 ;
                                        {
                                        else
                                        if( !postHitEnd ) break ;
                                        osTextT* postHitEnd = thirdC::c_strstrIF( tinP , postHit , "\r\n" ) ;
                                    {
                                    else
                                    if( !postHit ) break ;
                                    osTextT* postHit = thirdC::c_strstrIF( tinP , postc , "!exception" ) ;

                                {
                                while( postc < poste )

                                postc = posti ;

                                }
                                    postc ++ ;
                                    if( !*postc ) *postc = 0xff ;
                                {
                                while( postc < poste )  // SMUDGE NULL CHAR (THESE FILES ARE BINARY FILES) SO CAN USE STRING HANDLING

                                osTextT* poste = posti + costi ;
                                osTextT* postc = posti ;
                            {
                            else
                            if( !posti ) etThread.traceF( tinP , T("null length file:    ")+tShort ) ;

                            etThread.boxGetShadowF( tinP , posti , costi , tFolder+tShort ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;
                        {
                        if( tShort.csF( tinP ) )        // IF NOT A DIRECTORY

                        }
                            etThread.delF( tinP , psttShort ) ;
                            etThread.delF( tinP , psttFolder ) ;
                            tShort  = T(psttShort) ;
                            tFolder = T(psttFolder) ;
                            etThread.strBisectF( tinP , psttFolder , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttFolder ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttFolder ) ;
                        {
                        TN( tShort , "" ) ;
                        TN( tFolder , "" ) ;
                    {
                    else
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( !pInfoFile || !pInfoFile->psttIfoName )

                    etThread.diskFindFileOrDirF( tinP , pInfoFile , hFindFile , tTraceFolder , &pat2 ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                handleC hFindFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {

            tReport += tcrlf+tcrlf+T("exceptions\r\n\r\n") ;

            THREADmODE2rESTORE
            grabLathFileHealedFilesP.ungrabF( tinP ) ;
            }
                while( !ether && ~hFindFile && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        }
                            etThread.delF( tinP , posti ) ;

                            }
                                etThread.delF( tinP , psttYear ) ;
                                tReport += T(psttYear)+tb4+TF2(*(countT*)posti,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tcrlf ;

                                etThread.strSubstringF( tinP , psttYear , idf , idl , tShort ) ; ___( psttYear ) ;
                                countT idl = 0x17 ;
                                countT idf = 0x14 ;
                                ZE( strokeS* , psttYear ) ;
                            {
                            else
                            }
                                etThread.traceF( tinP , T("!exception: invalid file content [tShort]:    ")+tShort ) ;
                            {
                            if( !posti || costi != sizeof( countT ) )

                            etThread.boxGetShadowF( tinP , posti , costi , tFolder+tShort ) ; ___( posti ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;

                            //etThread.traceF( tinP , tShort ) ;
                        {
                        if( tShort.csF( tinP ) && !etThread.strIdF( tinP , tDotHeyWritingDot , tShort ) )        // IF NOT A DIRECTORY

                        }
                            etThread.delF( tinP , psttShort ) ;
                            etThread.delF( tinP , psttFolder ) ;
                            tShort  = T(psttShort) ;
                            tFolder = T(psttFolder) ;
                            etThread.strBisectF( tinP , psttFolder , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttFolder ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttFolder ) ;
                        {
                        TN( tShort , "" ) ;
                        TN( tFolder , "" ) ;
                    {
                    else
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( !pInfoFile || !pInfoFile->psttIfoName )

                    etThread.diskFindFileOrDirF( tinP , pInfoFile , hFindFile , tStateFolder , &pat1 ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                handleC hFindFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {
            grabLathFileHealedFilesP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

            TN( tReport , "" ) ; tReport = T("IdeaFarm (tm) Archive Healer - Minute Report #")+TF2(++idReport,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n\r\n\r\nyear    lathIdNameHealed\r\n\r\n" ) ;
        {
        if( !( ++ idCycle % 4 ) )

        }
            }
                etThread.traceF( tinP , T("compare bytes speed [elapsedTime,cbRecent,cTickPerTock]:    ")+TT(timeE1,timeE2)+tb4+TF3(cbWas,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF3(cTickPerTock,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+tBar , flTRACE_null , ifcIDtRACEdIVERT_1 ) ;

                TN( tBar , "" ) ; if( cTickPerTock ) tBar = TPS( "" , cTickPerTock , strokeS( '*' ) ) ;

                countT     cTickPerTock = !mTock ? - 1 : ( cbWas / mTock ) / TICK ;
                measure04T mTock        = mTime / TOCK                            ;
                measure04T mTime        = timeE1                                  ;

                etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1, timeA2 ) ;
                etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                ZE( sCountT , timeE2 ) ;
                ZE( countT  , timeE1 ) ;
            {
            if( cbWas )

            etThread.osTimeNowF( tinP , timeLathReset1 , timeLathReset2 ) ;

            }
                if( cbWas == setIfEqualsAM( cbNewlyCompared , 0 , cbWas ) ) break ;
                cbWas = cbNewlyCompared ;
            {
            for(;;)
            timeLathReset2 = timeLathReset1 = 0 ;
            sCountT timeA2 = timeLathReset2 ;
            countT  timeA1 = timeLathReset1 ;
            ZE( countT , cbWas ) ;
        {
        if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )
    {
    while( !ether && !POOP )
    ZE( sCountT , timeLathReset2 ) ;
    ZE( countT  , timeLathReset1 ) ;
    ZE( countT , idReport ) ;
    ZE( countT , idCycle ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    patternC pat2( tinP , etThread , tPatternTraceFile           , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
    patternC pat1( tinP , etThread , tPatternLathIdNameCompleted , ifcIDtYPEpATTERN_LITERAL               ) ;
    TN( tFileReport  , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/rpt.minute.ttt" ) ;
    TN( tStateFolder , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/" ) ;
    TN( tDotHeyWritingDot , ".!writing." ) ;

    TN( tTraceFolder , "" ) ; tTraceFolder = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/")+tUser+T("/00000100/stateSpaces/ffffefff/") ;

    TN( tUser , thirdC::postUserNameIF() ) ;

    TN( tPatternTraceFile , "bksTrace.booksC.*" ) ;

    ;

        +S2(sa_SSSaNDeND,sc_ccSSS)
        +T(".lath.idName.completed.ttt")
        +S2(sa_SSSoReND,sc_ccSSS)
            +S2(sa_SSSmARKnUMERIC9,sc_cSSSmARK)
        +S2(sa_SSSoR,sc_ccSSS)
        +S3(2,sc_ccSSSrEPEAT,2)
        +S2(sa_SSSoReND,sc_ccSSS)
            +T("12")
        +S2(sa_SSSoR,sc_ccSSS)
        +T("status.wo.ideafarm.")
        +S2(sa_SSSaND,sc_ccSSS)
        T("")

    TN( tPatternLathIdNameCompleted , "" ) ; tPatternLathIdNameCompleted =

    // "status.wo.ideafarm.yyyy.lath.idName.completed.ttt"
    //  123456789abcdef0123456789abcdef0123456789abcdef0
    //  0              1               2               3

    TN( tcrlf , "\r\n" ) ;
    TN( tb4   , "    " ) ;

    flagsT flagsModeP               =  (flagsT)pTaskP->c2 ;
    grabC& grabLathFileHealedFilesP = *(grabC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmReportF )

DONE( tmObeyPauseSemaphoreFileF )
}
    }
        }
            if( POOP ) POOPRqUIET
            tinP.pEtScratch->boxZapF( tinP , tFilePause , 1 ) ;
            SCOOPS
        {
        IFsCRATCH
        etThread.traceF( tinP , T("deleting the pause semaphore file and decremented cPauseP [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        countT was = decv02AM( cPauseP ) ;
    {
    if( etThread.diskFileExistsF( tinP , tFilePause ) )

    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;

        bFileExistsLag = bFileExists ;

        }
            }
                if( POOP ) POOPRqUIET
                tinP.pEtScratch->boxZapF( tinP , tFilePaused , 1 ) ;
                SCOOPS
            {
            IFsCRATCH
        {
        else if( !bFileExists && bFileExistsLag )
        }
            etThread.boxPutF( tinP , tFilePaused , tSay , tSay.csF( tinP ) + 1 ) ;
            TN( tSay , "If this file exists then IdeaFarm (tm) Archive Heal is paused due to a user request (a pause semaphore file)." ) ;
        {
        if( bFileExists && !bFileExistsLag && cExecutiveHealYearPausedP == cExecutiveHealYearP )

        }
            }
                etThread.traceF( tinP , T("decremented cPause on request [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                countT was = decv02AM( cPauseP ) ;
                bFileExists = 0 ;
            {
            if( bFileExists )
        {
        else
        }
            }
                etThread.traceF( tinP , T("incremented cPause on request [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                countT was = incv02AM( cPauseP ) ;
                bFileExists = 1 ;
            {
            if( !bFileExists )
        {
        if( etThread.diskFileExistsF( tinP , tFilePause ) )
    {
    while( !ether )
    ZE( boolT  , bFileExistsLag ) ;
    ZE( boolT  , bFileExists ) ;

    }
        if( POOP ) POOPRqUIET
        tinP.pEtScratch->boxZapF( tinP , tFilePause , 1 ) ;

        if( POOP ) POOPRqUIET
        tinP.pEtScratch->boxZapF( tinP , tFilePaused , 1 ) ;

        SCOOPS
    {
    IFsCRATCH

    etThread.diskMakeDirIfNeededF( tinP , tFilePause ) ;
    TN( tFilePaused , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/control/paused" ) ;
    TN( tFilePause  , "///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/control/pause"  ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    countT& cExecutiveHealYearPausedP = *(countT*)pTaskP->c4 ;
    countT& cExecutiveHealYearP       = *(countT*)pTaskP->c3 ;
    countT& cPauseP                   = *(countT*)pTaskP->c2 ;
    boolT&  bAbortP                   =  *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmObeyPauseSemaphoreFileF )

DONE( tmExecutiveHealYearF )
}
    // #endif
    //     //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
    // #if defined( IFC tESTING )

    dec02AM( cExecutiveHealYearP ) ;
    }
        }
            etThread.traceF( tinP , T("done for archive [bAbort,archive,year]:    ")+TF2(bAbortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzArchiveP)+tb4+tYear ) ;

            etThread.delF( tinP , *(countT**)&ppsttPathToYear ) ;
            }
                etThread.delF( tinP , ppsttPathToYear[ offi ] ) ;
            {
            for( countT offi = 0 ; offi < cPathsToYear ; offi ++ )

            DEL( pJotSortedShort ) ;
            }
                }
                    grabLathFileHealedFilesP.ungrabF( tinP ) ;
                    THREADmODE2rESTORE
                    }
                        if( POOP ) POOPRqUIET
                        tinP.pEtScratch->boxZapF( tinP , tLong , 1 ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                    grabLathFileHealedFilesP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                    //etThread.traceF( tinP , T("deleting [file]:    ")+tLong ) ;
                    tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".lath.idName.completed.ttt") ;

                    etThread.boxPutF( tinP , tLong , tBody , tBody.csF( tinP ) ) ;
                    TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".completed.ttt") ;

                    TN( tBody , "" ) ; tBody = TT(time1N,time2N) + T("\r\nIPDOS (tm) Archive Healer\r\nDelete this file to cause Healer to not wait to heal this year.\r\n") ;
                    etThread.osTimeNowF( tinP , time1N , time2N ) ;
                    ZE( sCountT , time2N ) ;
                    ZE( countT  , time1N ) ;

                    DEL( pJotSortedShort ) ;

                    if( pJotSortedShort && !( F(flagsModeP) & flHEALmODE_KEEPnAMES ) ) pJotSortedShort->flagsCtRefF() |= flJOTc_PATCHbOOKSfLAGStOpURGEoNdT ;
                    _IO_
                {
                if( !bAbortP && idPhaseP == 1 + OFFpHASE_CHUNKfILESbYdAY )

                }
                    }
                        break ;

                        if( tDayPrefix.csF( tinP ) ) chunkDayIfF( tinP , etThread , bAbortP , cPathsToYear , ppsttPathToYear , tDayPrefix ) ;

                        }
                            //etThread.traceF( tinP , T("[tDayPrefixNew,tShort]:    ")+tDayPrefixNew+tb4+tShort ) ;

                            }
                                etThread.traceF( tinP , T("********************************************************************************************************************************") ) ;
                                tDayPrefix = tDayPrefixNew ;

                                if( tDayPrefix.csF( tinP ) ) chunkDayIfF( tinP , etThread , bAbortP , cPathsToYear , ppsttPathToYear , tDayPrefix ) ;
                            {
                            if( etThread.strCompareF( tinP , tDayPrefix , tDayPrefixNew ) )

                            }
                                etThread.delF( tinP , psttDayPrefix ) ;
                                tDayPrefixNew = T(psttDayPrefix) ;
                                etThread.strSubstringF( tinP , psttDayPrefix , idf , sttq , sttAt , tShort , 0 ) ; ___( psttDayPrefix ) ;
                                countT idf = 1 ;
                                strokeS sttAt( '@' ) ;
                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                ZE( strokeS* , psttDayPrefix ) ;
                            {
                            TN( tDayPrefixNew , "" ) ;
                
                            }
                                }
                                    tShort = T(pbIn+sizeof(count04T)) ;
                                    c4CbUsed = *(count04T*)pbIn ;
                                {
                                else
                                if( !pbIn ) ether.traceF( tinP , T("!exception: could not obtain blob so ignoring this page") ) ;
                                const byteT* pbIn = pageIn ;
                                pageC pageIn = *pJotSortedShort ;
                            {
                            TN( tShort , "" ) ;
                            ZE( count04T , c4CbUsed ) ;
                
                            _IO_
                        {
                        while( !ether && cDo -- && !bAbortP )
                        TN( tDayPrefix , "" ) ;
                        countT cDo = cShortNames ;

                        }
                            etThread.traceF( tinP , T("[path list]:    ")+T(ppsttPathToYear[offi]) ) ;
                        {
                        for( countT offi = 0 ; offi < cPathsToYear ; offi ++ )
                        
                        etThread.traceF( tinP , T("[archive,year,cShortNames]:    ")+tArchive+tb4+tYear+tb4+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        const countT cShortNames = pJotSortedShort->cElementsF() ;
                        pJotSortedShort->resetLathReadF() ;

                        TN( tb  , " " ) ;
                        TN( tb4 , "    " ) ;

                        // IOW, ALL FILES IN EACH FILESET ARE DATED ONLY WITH THE TIME MODIFIED VALUE OF THE DATA FILE
                        // THIS IS TO SUPPRESS DIFFERENCES IN META DATA ACROSS VOLUMES THAT ARE DUE TO ACCESSING OR DUE TO AD HOC DATA RECOVERY AND MIGRATION ACTIVITIES
                        //PS:PERSONALITY: I CLOBBER FILE TIME METADATA SO THAT TIME WRITTEN, ACCESSED, AND CREATED FOR EVERY FILE IN THE DAY CHUNK ARE ALL SMUDGED TO THE TIME WRITTEN VALUE OF THE MOST RECENT FILE
                    {
                    case 1 + OFFpHASE_CHUNKfILESbYdAY :
                    }
                        break ;

                        }
                            while( cDo -- ) dec02AM( cPathsToYearHealingP ) ;
                            countT cDo = cPathsToYear ;
                        {

                        bFireCheckpointUpdate = 1 ;

                        st_pzJobHealFileDone.ungrabF( tinP ) ;
                        }
                            funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
                            DELzOMBIE( pzJob ) ;
                            jobHealFileS* pzDoomed = pzJob ;
                            st_pzJobHealFileDone >> *(countT*)&pzJob ;
                            ZE( jobHealFileS* , pzJob ) ;
                        {
                        while( st_pzJobHealFileDone )        //THIS MIGHT HAPPEN DUE TO RACE CONDITION, BUT IT (UPDATING THE "LATH FILE HEALED" FILE) DOESN'T MATTER 'CAUSE WE'RE DONE
                        st_pzJobHealFileDone.grabF( tinP , TAG( TAGiDnULL ) ) ;

                        if( bWorking ) dec02AM( cYearsHealingP ) ;

                        }
                            }
                                }
                                    funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
                                    DELzOMBIE( pzJob ) ;
                                    jobHealFileS* pzDoomed = pzJob ;

                                    if( !pzJob ) break ;
                                    jobHealFileS* pzJob = (jobHealFileS*)funJobHealFileP.readF( tinP , flFUNNELhORNcrEAD_NOwAIT ) ;
                                {
                                for(;;)
                            {
                            if( ether )

                            ++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;

                            //etThread.traceF( tinP , T("waiting for pending heal jobs [cJobsPendingHeal,stDone]:    ")+TF2(cJobsPendingHeal,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(st_pzJobHealFileDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4 ) ;

                            _IO_
                        {
                        while( cJobsPendingHeal - st_pzJobHealFileDone )
                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                        etThread.delF( tinP , pcArraySortedBySize ) ;
                        }
                            }
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //****                                        ***********************************************************************************************************************************************************************************************************************************
                                //****  H E A L   W O   N A M E   ( E N D )   ***********************************************************************************************************************************************************************************************************************************
                                //****                                        ***********************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************

                                ///*if( !( idName % TUCK ) )*/ etThread.traceF( tinP , T("---- [tYear,idName]:    ")+tYear+tb4+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                etThread.delF( tinP , psttShort ) ;
                                }
                                    // #endif
                                    //     //etThread.traceF( tinP , T("---- watch") ) ;
                                    //     //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
                                    // #if defined( IFC tESTING )

                                    }
                                        //etThread.traceF( tinP , T("wrote   to funJobHealFileP [idName]:    ")+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        funJobHealFileP.writeF( tinP , pbz ) ;
                                        //etThread.traceF( tinP , T("writing to funJobHealFileP [idName]:    ")+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        new( 0 , tinP , pbz , sizeof pbz ) jobHealFileS( tinP , etThread , cJobsPendingHeal , infoYear , psttShort , idName , cShortNames ) ;
                                        byteT pbz[ sizeof( jobHealFileS ) ] ;
                                    {
                                    if( !ether && !bAbortP )

                                    // #endif
                                    //     //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
                                    //     //etThread.traceF( tinP , T("++++ watch") ) ;
                                    // #if defined( IFC tESTING )

                                    //}
                                    //    etThread.traceF( tinP , T("healing [archive,year,cShortNames,idName,perTuck,tShort]:    ")+tArchive+tb4+tYear+tb4+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tPerTuck+tb4+tShort ) ;
                                    //    countT perTuck = ( idName << 8 ) / cShortNames ;
                                    //{
                                    //if( !( idName % ( TUCK >> 0 ) ) )

                                    }
                                        inc02AM( cYearsHealingP ) ;
                                        bWorking = 1 ;
                                    {
                                    if( !bWorking )

                                    }
                                        break ;
                                        bAbortP = 1 ;
                                    {
                                    if( ether )

                                    //etThread.traceF( tinP , T("sorted [idJotIn,psttShort]:    ")+TF2(idJotIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttShort) ) ;
                                    //etThread.traceF( tinP , T("healing [archive,year,short]:    ")+tArchive+tb4+tYear+tb4+T(psttShort) ) ;
                                    //countT idJotIn = pJotSortedShort->idLathReadF() ;
                                    _IO_
                                {
                                else
                                if( !psttShort->idAdam ) ether.traceF( tinP , T("TODO / !exception: psttShort is null length so ignoring this page") ) ;

                                //etThread.traceF( tinP , T("[pbIn,cbIn]:    ")+T(psttShort)+tb4+TF2(psttShort->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                if( bAbortP ) break ;
                                pauseIfF( tinP , bAbortP , cExecutiveHealYearPausedP , cPauseP ) ;

                                //etThread.traceF( tinP , T("pushing [cbUsed[0],cbUsed[1],psttShort]:    ")+TF2(((countT*)&c4CbUsed)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((countT*)&c4CbUsed)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttShort) ) ;

                                etThread.strMakeFromOsTextF( tinP , psttShort , pbIn + sizeof( count04T ) ) ; ___( psttShort ) ;
                                ZE( strokeS* , psttShort ) ;
                        
                                c4CbUsed = *(count04T*)pbIn ;
                        
                                const byteT* pbIn = pageIn ;
                                pageC pageIn = (*pJotSortedShort)[ idJot ] ;
                        
                                if( bAbortP ) break ;
                                pauseIfF( tinP , bAbortP , cExecutiveHealYearPausedP , cPauseP ) ;

                                count04T c4CbUsed = *(count04T*)( pcElt + 1 ) ;
                                countT   idJot    =              *pcElt       ;

                                ///*if( !( idName % TUCK ) )*/ etThread.traceF( tinP , T("++++ [tYear,idName]:    ")+tYear+tb4+TF2(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                if( ++ idName <= idNameSkipBeyond ) continue ;

                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //****                                            *******************************************************************************************************************************************************************************************************************************
                                //****  H E A L   W O   N A M E   ( B E G I N )   *******************************************************************************************************************************************************************************************************************************
                                //****                                            *******************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************
                                //*******************************************************************************************************************************************************************************************************************************************************************************

                                _IO_
                            {
                            //for( countT* pcElt = pce - ccElt         ; pcElt >= pcArraySortedBySize ; pcElt -= ccElt )            // LARGEST  FILES WOTH
                              for( countT* pcElt = pcArraySortedBySize ; pcElt < pce                  ; pcElt += ccElt )            // SMALLEST FILES WOTH
                            
                            countT  cElt  = ccArraySortedBySize / ccElt ;
                            countT  ccElt = 3 ;
                            countT* pce   = pcArraySortedBySize + ccArraySortedBySize ;

                            const countT cMaxBacklog = infoYear.cProcessors << 2 ;
                            ZE( countT , idName ) ;
                        {

                        etThread.osThreadF( TaRG3fLAGScBtLS( tmUpdateYearCheckpointF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&bFireCheckpointUpdate , (countT)&st_pzJobHealFileDone , (countT)&funJobHealFileP , (countT)&idNameConsecutiveLathDone , (countT)&tArchive , (countT)&tYear ) ;
                        ZE( boolT , bFireCheckpointUpdate ) ;

                        countT idNameConsecutiveLathDone = idNameSkipBeyond ;
                        ZE( countT , cJobsPendingHeal ) ;
                        ZE( boolT , bWorking ) ;

                        paramHealFileS infoYear( tinP , etThread , bAbortP , cPauseP , tYear , tArchive , tUniqueP , cExecutiveHealYearPausedP , stJobCompareP , funJobFileInfoP , cPathsToYear , cResultStructsNeeded , (const strokeS**)ppsttPathToYear , st_pzJobHealFileDone , funJobHealFileDone , grabDiskP ) ;
                        funnelHornC funJobHealFileDone( tinP , etThread , countTC() , sizeof( jobHealFileS ) , FUNNELhORNcAPACITY ) ;
                        stackC st_pzJobHealFileDone( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_countT ) ;

                        }
                            //}
                            //    etThread.traceF( tinP , T("out [cbUsed[0],cbUsed[1],tShort]:    ")+TF2(((countT*)&c4CbUsed)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((countT*)&c4CbUsed)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
                            //
                            //    TN( tShort , "" ) ; tShort = T(pbIn+sizeof(count04T)) ;
                            //
                            //    c4CbUsed = *(count04T*)pbIn ;
                            //
                            //    const byteT* pbIn = pageIn ;
                            //    pageC pageIn = (*pJotSortedShort)[ idJot ] ;
                            //
                            //    countT   idJot    = *( pco ++ ) ;
                            //    count04T c4CbUsed = *(count04T*)pco ; pco += 2 ; 
                            //{
                            //for( countT* pco = pcArraySortedBySize ; pco < pce ; )
                            //countT* pce = pcArraySortedBySize + ccArraySortedBySize ;

                            etThread.boxPutF( tinP , tLongSortedBySize , (byteT*)pcArraySortedBySize , ccArraySortedBySize * sizeof( countT ) ) ;
                        
                            //etThread.traceF( tinP , T("called  ifcSortaF") ) ;

                            //etThread.ifcSortaF( tinP , bQuit , (byteT*)pcArraySortedBySize , ccArraySortedBySize * sizeof( countT ) , 0 , 0 , 3 * sizeof( countT ) , /*flSORTAc_NOwORKERS*/ flSORTAc_null ) ;
                            // ENABLING THIS LINE CAUSES NAMES TO BE PROCESSED IN ORDER OF SIZE ; DISABLING CAUSES NAMES TO BE PROCESSED IN ORDER OF NAME

                            //etThread.traceF( tinP , T("calling ifcSortaF") ) ;
                            ZE( boolT , bQuit ) ;
                        
                            }
                                }
                                    //etThread.traceF( tinP , T("in  [cbUsed[0],cbUsed[1],tShort]:    ")+TF2(((countT*)&c4CbUsed)[0],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(((countT*)&c4CbUsed)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
                        
                                    }
                                        }
                                            *(count04T*)pcCursor = c4CbUsed ; pcCursor += 2 ;                           // BOTH OF THESE LINES SET THE SORT KEY VALUE, WHICH IS SIZE sizeof( countT ) * 3
                                            *( pcCursor ++ ) = pJotSortedShort->idLathReadF() & ~( NM_HIGH ) ;          //A:ASSUME: TEXT SORT VALUES ARE MONOTONIC INCREASING IN idJot VALUES (BECAUSE TEXT IN THE jotC FILESET WAS WRITTEN IN SORTED ORDER)
                        
                                            tShort = T(pbIn+sizeof(count04T)) ;
                                            c4CbUsed = *(count04T*)pbIn ;
                                        {
                                        else
                                        if( !pbIn ) ether.traceF( tinP , T("!exception: could not obtain blob so ignoring this page") ) ;
                                        const byteT* pbIn = pageIn ;
                                        pageC pageIn = *pJotSortedShort ;
                                    {
                                    TN( tShort , "" ) ;
                                    ZE( count04T , c4CbUsed ) ;
                        
                                    _IO_
                                {
                                while( cDo -- )
                                countT cDo = cShortNames ;
                                countT* pcCursor = pcArraySortedBySize ;
                                
                                etThread.memSetF( tinP , (byteT*)pcArraySortedBySize , ccArraySortedBySize * sizeof( countT ) ) ;
                                etThread.newF( tinP , LF , pcArraySortedBySize , ccArraySortedBySize ) ; ___( pcArraySortedBySize ) ;
                                ccArraySortedBySize = cShortNames * 3 ;
                        
                                etThread.traceF( tinP , T("[cShortNames]:    ")+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                        
                            TN( tb4 , "    " ) ;
                        
                            _IO_
                        {
                        if( !pcArraySortedBySize )

                        }
                            }
                                THREADmODE2rESTORE
                                }
                                    if( POOP ) POOPRqUIET
                                    tinP.pEtScratch->boxZapF( tinP , tLongSortedBySize , 1 ) ;
                                    SCOOPS
                                {
                                IFsCRATCH
                                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                                ccArraySortedBySize = 0 ;
                                etThread.delF( tinP , pcArraySortedBySize ) ;
                                etThread.traceF( tinP , T("invalid file image ; file will be deleted and regenerated [tLong]:    ")+tLongSortedBySize ) ;
                            {
                            else
                            }
                                ccArraySortedBySize = ccExpected ;
                            {
                            if( !( cbi % cbElt ) && cbi == ccExpected * sizeof( countT ) )
                            countT cbElt      = sizeof( countT ) * 3 ;
                            countT ccExpected = cShortNames      * 3 ;
                            etThread.boxGetShadowF( tinP , *(byteT**)&pcArraySortedBySize , cbi , tLongSortedBySize ) ; ___( pcArraySortedBySize )
                            ZE( countT , cbi ) ;
                        {
                        if( etThread.diskFileExistsF( tinP , tLongSortedBySize ) )
                        ZE( countT  , ccArraySortedBySize ) ;
                        ZE( countT* , pcArraySortedBySize ) ;

                        //etThread.traceF( tinP , T("[archive,year,cShortNames]:    ")+tArchive+tb4+tYear+tb4+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        const countT cShortNames = pJotSortedShort->cElementsF() ;
                        pJotSortedShort->resetLathReadF() ;

                        }
                            ++ s ; ether.osSleepF( tinP , ( TICK >> 4 ) ) ;     //GIVE OTHER NEWLY LAUNCHED YEAR THREADS SOME TIME TO ALSO ACCUMULATE INTO cPathsToYearHealingP BEFORE I PROCEED
                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;               //THE IDEA HERE IS TO PREVENT AN EARLY YEAR THREAD FROM RACING AHEAD AND CALCULATING A HUGE FILE WINDOW SIZE FOR ITSELF JUST AHEAD OF OTHER NEWLY LAUNCHED YEAR THREADS

                            while( cDo -- ) inc02AM( cPathsToYearHealingP ) ;
                            countT cDo = cPathsToYear ;
                        {

                        _IO_
                    {
                    case 1 + OFFpHASE_HEAL :
                {
                if( !bAbortP && !POOP ) switch( idPhaseP )

                }
                    }
                        }
                            }
                                etThread.traceF( tinP , T("decremented cPause after nap after exception [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                was = decv02AM( cPauseP ) ;
                                ++ s ; etThread.osSleepF( tinP , TIMEpAUSEoNfAIL ) ;
                                etThread.traceF( tinP , T("incremented cPause on exception [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                countT was = incv02AM( cPauseP ) ;
                            {
                            else
                            if( !cTries ) bAbortP = 1 ;
                        {
                        if( bAbortLocal )

                        }
                            etThread.delF( tinP , psttName ) ;
                            //etThread.traceF( tinP , T("sorted jotC fileset [archive,year,short]:    ")+tArchive+tb4+tYear+tb4+T(psttName) ) ;
                            sortF( tinP , etThread , countTC() , pJotSortedShort , jotShortFileNames , psttName , T("healarchive.sorted.short.filenames.")+tArchive+tDot+tYear , CBdATAbOOKsHORTfILEnAMES , CiNDEXeNTRIESpERbOOKsHORTfILEnAMES , TUCK << 0 , flSORTERc_SILENTLYsUPPRESSdUPLICATES , flJOTc_null , cNamesEstimate , sizeof( count04T ) ) ;
                            ZE( strokeS* , psttName ) ;

                            countT cNamesEstimate = cNames ;    // ACCURATE IF I HAVE ELIMINATED ALL DUPLICATES
                            cTries = 0 ; // IF GET HERE THEN READING FILE NAMES DID NOT FAIL SO WILL BE DONE
                        {
                        if( !bAbortP && !bAbortLocal )

                        if( ether ) bAbortP = 1 ;

                        if( !bAbortP ) pauseIfF( tinP , bAbortP , cExecutiveHealYearPausedP , cPauseP ) ;

                        etThread.delF( tinP , *(byteT**)&pc4CbUsed  ) ;
                        etThread.delF( tinP , *(byteT**)&ppsttShort ) ;
                        etThread.delF( tinP , *(byteT**)&pphff      ) ;
                        etThread.delF( tinP , *(byteT**)&ppif       ) ;
                        }
                            while( !ether && !bAbortP && !POOP && cPathsDone < cPathsToYear ) ;
                            }
                                //if( tShortToTest.csF( tinP ) ) break ;

                                }
                                    if( !( ++ cNames % ( TUCK << 0 ) ) ) etThread.traceF( tinP , T("wrote to unsorted [archive,year,idName,idJot,tShort]:    ")+tArchive+tb4+tYear+tb4+TF2(cNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
                                    countT idJot = jotShortFileNames.writeF( tinP , (byteT*)&c4CbUsed , sizeof c4CbUsed , tShort , tShort.csF( tinP ) + 1 ) ;
                                    etThread.delF( tinP , ppsttShort[ offhMin ] ) ;
                                    etThread.traceF( tinP , T("jotting [c4cbUsed,tShort]:    ")+TT(pczCbUsed[0],pczCbUsed[1])+tb4+tShort ) ;
                                    countT* pczCbUsed = (countT*)&c4CbUsed ;

                                    TN( tShort , ppsttShort[ offhMin ] ) ;
                                    count04T c4CbUsed = pc4CbUsed[ offhMin ] ;
                                {
                                if( offhMin != - 1 )
                                // WRITE THE MINIMUM SHORT NAME TO JOT AND THEN DELETE IT SO THAT THE NEXT NAME WILL BE LOADED ON THE NEXT ITERATION

                                }
                                    }
                                        else if(    !sgn ) etThread.delF( tinP , ppsttShort[ offh ] ) ;
                                             if( 0 > sgn ) { offhMin = offh /*; etThread.traceF( tinP , T("updated offhMin") )*/ ; }

                                        sCountT sgn = offhMin == - 1 ? - 1 : etThread.strCompareF( tinP , ppsttShort[ offh ] , ppsttShort[ offhMin ] ) ;
                                    {
                                    if( ppsttShort[ offh ] )

                                    //if( offhMin != - 1 ) etThread.traceF( tinP , T("[offhMin,ppsttShort[offhMin]]:    ")+TF2(offhMin,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb+T(ppsttShort[offhMin]) ) ;
                                    //etThread.traceF( tinP , T("[offh,ppsttShort[offh]]:    ")+TF2(offh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb+T(ppsttShort[offh]) ) ;
                                {
                                for( countT offh = 0 ; !bAbortP && offh < cPathsToYear ; offh ++ )
                                countT offhMin = - 1 ;
                                // SET offhMin TO THE offh OF THE MINIMUM SHORT NAME ; SUPPRESS DUPLICATES

                                if( bAbortP || bAbortLocal ) break ;

                                }
                                    }
                                        if( bRetry ) offh -- ;   // TRY AGAIN TO LOAD A NAME FROM THIS VOLUME

                                        DEL( ppif[ offh ] ) ;
                                        }
                                            //}
                                            //    etThread.traceF( tinP , T("got [offh,psttShort]:    ")+TF2(offh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(ppsttShort[offh]) ) ;
                                            //{
                                            //else
                                            }
                                                bRetry = 1 ;
                                                etThread.delF( tinP , psttFolder ) ;
                                                etThread.traceF( tinP , T("folder ignored [tFolder]:    ")+T(psttFolder) ) ;
                                                etThread.delF( tinP , psttnu ) ;
                                                etThread.strBisectF( tinP , psttnu , psttFolder , ppif[ offh ]->psttIfoName , T("/") , - 2 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttFolder ) ;
                                                ZE( strokeS* , psttFolder ) ;
                                                ZE( strokeS* , psttnu ) ;

                                                etThread.delF( tinP , ppsttShort[ offh ] ) ;
                                            {                                                                               
                                            else if( !ppsttShort[ offh ]->idAdam )          //IT'S A DIRECTORY
                                            #endif
                                                }
                                                    bRetry = 1 ;
                                                    etThread.delF( tinP , ppsttShort[ offh ] ) ;
                                                {
                                                else if( etThread.strIdF( tinP , tShortIgnore , ppsttShort[ offh ] , 1 ) )
                                            #if defined( NEVERdEFINED )
                                            if( !ppsttShort[ offh ] ) bRetry = 1 ;

                                            etThread.delF( tinP , psttnu ) ;
                                            etThread.strBisectF( tinP , psttnu , ppsttShort[ offh ] , ppif[ offh ]->psttIfoName , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( ppsttShort[ offh ] ) ;
                                            ZE( strokeS* , psttnu ) ;

                                            pc4CbUsed[ offh ] = *(count04T*)&ppif[ offh ]->cbUsed ;
                                        {
                                        else
                                        }
                                            continue ;
                                            cPathsDone ++ ;
                                            DEL( pphff[ offh ] ) ;
                                            DEL( ppif[ offh ] ) ;
                                        {
                                        else if( !ppif[ offh ] || !ppif[ offh ]->psttIfoName )
                                        if( bAbortP || bAbortLocal ) break ;
                                        ZE( boolT , bRetry ) ;

                                        }
                                            }
                                                break ;
                                                DEL( ppif[ offh ] ) ;
                                                else          bAbortLocal = 1 ;
                                                if( !cTries ) bAbortP = 1 ;
                                                etThread.traceF( tinP , T("!exception:  diskFindFileOrDirF ; aborting [path]:    ")+T(ppsttPathToYear[offh]) ) ;
                                                POOPRqUIET
                                            {
                                            if( POOP )

                                            // #endif

                                                tinP.pEtScratch->diskFindFileOrDirF( tinP , ppif[ offh ] , *pphff[ offh ] , ppsttPathToYear[ offh ]        ) ; ___( ppif[ offh ] ) ;

                                            // #else
                                            // 
                                            //     tinP.pEtScratch->diskFindFileOrDirF( tinP , ppif[ offh ] , *pphff[ offh ] , ppsttPathToYear[ offh ] , &pat ) ; ___( ppif[ offh ] ) ; //FOR TESTING
                                            // 
                                            //       patternC pat( tinP , etThread , T("!ideafarm.a.2.00000000.00000001.20220904@1430.20220912@1742.70cfa724f22dae220ecc078ad6538c5c.001.fset.zip") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; //DUT 20240326@1715
                                            //     //patternC pat( tinP , etThread , T("!ideafarm.9.2.00000000.00000001.20990007@0000.20220225@1343.ab155b6a3666b3c92434e1d1d650e2cf.001.data.zip") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; //LARGEST FILE IN THE ARCHIVE
                                            //     //patternC pat( tinP , etThread , T("!ideafarm.9.2.00000000.00000001.20990013@0000.20210119@0000.014c4e4d37bea606de6c6ac99d8d50c2.001.data.iso") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; // 1,004,306,432 BYTES
                                            //     //patternC pat( tinP , etThread , T("!ideafarm.9.2.00000000.00000001.20131226@1827.20170306@1754.8e00e6d01d529344e90f3e984315b7ce.001.data.mp3") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ; //    10,000,635 BYTES
                                            // 
                                            // #if defined( IFC tESTING )

                                            SCOOPS
                                        {
                                        IFsCRATCH

                                        //}
                                        //    continue ;
                                        //    etThread.strMakeF( tinP , LF , ppsttShort[ offh ] , tShortToTest ) ; ___( ppsttShort[ offh ] ) ;
                                        //{
                                        //if( tShortToTest.csF( tinP ) )
                                    {
                                    if( pphff[ offh ] && !ppsttShort[ offh ] )
                                    _IO_
                                {
                                for( countT offh = 0 ; !bAbortP && offh < cPathsToYear ; offh ++ )

                                if( bAbortP ) break ;
                                pauseIfF( tinP , bAbortP , cExecutiveHealYearPausedP , cPauseP ) ;

                                //   LOAD A NONDIRECTORY SHORT NAME FROM EACH VOLUME FOR WHICH THERE IS NOT WO LOADED

                                //
                                //   SELECT THE MINIMUM SHORT NAME, WRITE IT TO JOT, AND DELETE IT
                                //   LOAD A NONDIRECTORY SHORT NAME FROM EACH VOLUME IF NOT ALREADY LOADED
                                //  EACH ITERATION
                                //
                                // RECIPE

                                // LOAD jotShortFileNames (WILL CONTAIN A PAGE FOR EACH VOLUME FOR EACH FILE, SO SHORT NAMES WILL BE DUPLICATED)

                                //  IF I DO THIS, THEN THE ONLY THING THAT SORTER WILL NEED TO CLEAN UP IS VOLUMES THAT PRESENT NAMES OUT OF ORDER, AND THIS WILL BE RARE FOR NTFS VOLUMES
                                // OBJECTIVE: IF EACH VOLUME PRESENTS ITS NAMES IN ASCENDING ORDER THEN, EVEN IF NOT ALL FILES ARE IN ALL VOLUMES, THE NAMES THAT I WRITE WILL BE IN ASCENDING ORDER
                                //  REPEAT
                                //  SELECT THE LOWEST NAME, WRITE IT TO JOT, AND GET THE NEXT NAME FROM THAT VOLUME
                                //  LOAD A SHORT NAME FROM EACH VOLUME
                                // RECIPE
                                _IO_
                            {
                            do
                            ZE( countT , cPathsDone ) ;
                            //TN( tShortToTest , "!ideafarm.9.2.00000000.00000001.20990004@0001.20170124@1441.46c264d2bf71383d11f319c316c3c001.001.data.ISO" ) ;
                            // /*U::COMMENT OUT IN PRODUCTION:*/ TN( tShortIgnore , ".fset.zip" ) ;

                            for( countT offh = 0 ; offh < cPathsToYear ; offh ++ ) pphff[ offh ] = new( 0 , tinP , LF ) handleC( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                            etThread.memSetF( tinP , (byteT*)pc4CbUsed  , cPathsToYear * sizeof( count04T   ) ) ;
                            etThread.memSetF( tinP , (byteT*)ppsttShort , cPathsToYear * sizeof( strokeS*   ) ) ;
                            etThread.memSetF( tinP , (byteT*)ppif       , cPathsToYear * sizeof( infoFileS* ) ) ;
                            etThread.memSetF( tinP , (byteT*)pphff      , cPathsToYear * sizeof( handleC*   ) ) ;

                            _IO_
                        {
                        else
                        if( POOP || ether ) bAbortP = 1 ;
                        ZE( countT , cNames ) ;

                        etThread.newF( tinP , LF , *(byteT**)&pc4CbUsed  , cPathsToYear * sizeof( count04T   ) ) ; ___( pc4CbUsed ) ;
                        ZE( count04T* , pc4CbUsed ) ;

                        etThread.newF( tinP , LF , *(byteT**)&ppsttShort , cPathsToYear * sizeof( strokeS*   ) ) ; ___( ppsttShort ) ;
                        ZE( strokeS** , ppsttShort ) ;

                        etThread.newF( tinP , LF , *(byteT**)&ppif       , cPathsToYear * sizeof( infoFileS* ) ) ; ___( ppif       ) ;
                        ZE( infoFileS** , ppif ) ;

                        etThread.newF( tinP , LF , *(byteT**)&pphff      , cPathsToYear * sizeof( handleC*   ) ) ; ___( pphff      ) ;
                        ZE( handleC** , pphff ) ;

                        jotC jotShortFileNames( tinP , "short.file.names" , flJOTc_WRITE | flJOTc_PRIVATE | flJOTc_DELETE | flJOTc_PURGEoNcT , 1 , CBdATAbOOKsHORTfILEnAMES , CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ) ;
                        //etThread.traceF( tinP , T("reading short names from volumes [archive,year]    ")+tArchive+tb4+tYear ) ;

                        ZE( boolT , bAbortLocal ) ;

                        THREADmODE2rESTORE
                        }
                            if( POOP ) POOPRqUIET
                            tinP.pEtScratch->boxZapF( tinP , tLongSortedBySize , 1 ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                        _IO_
                    {
                    while( !ether && cTries -- )
                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                    countT cTries = ( F(flagsModeP) & flHEALmODE_STRICT ) ? 1 : CtRIESiFnOTsTRICT ;
                {
                else
                else if( pJotSortedShort ) ;//etThread.traceF( tinP , T("reusing a sorted list of short names") ) ;
                if( bAbortP ) ;

                //for( countT offh = 0 ; offh < cPathsToYear ; offh ++ ) etThread.traceF( tinP , T("cache [cPaths,off,pstt]:    ")+TF2(cPathsToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(ppsttPathToYear[offh]) ) ;

                }
                    if( !bMatch && !bAbortP ) etThread.boxPutF( tinP , tLongBox , twl , twl.csF( tinP ) ) ;

                    }
                        }
                            bAbortP = 1 ;
                            etThread.boxPutF( tinP , tLongBoxSee , twl , twl.csF( tinP ) ) ;
                            etThread.traceF( tinP , T("!exception: volume list that I see differs from list in volumes file ; aborting") ) ;
                        {
                        else
                        }
                            THREADmODE2rESTORE
                            }
                                if( POOP ) POOPRqUIET
                                tinP.pEtScratch->boxZapF( tinP , tLongBoxSee , 1 ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                            bMatch = 1 ;
                        {
                        if( !etThread.strCompareF( tinP , twl , twlLag ) )

                        etThread.delF( tinP , posti ) ;
                        TN( twlLag , posti ) ;

                        etThread.boxGetShadowF( tinP , posti , costi , tLongBox ) ; ___( posti ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;
                    {
                    if( etThread.diskFileExistsF( tinP , tLongBox ) )
                    ZE( boolT , bMatch ) ;

                    TN( tLongBoxSee , "" ) ; tLongBoxSee = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/volumes.")+tArchive+tDot+tYear+T(".see.ttt") ;
                    TN( tLongBox    , "" ) ; tLongBox    = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/volumes.")+tArchive+tDot+tYear+T(".ttt") ;

                    etThread.delF( tinP , psttWorkList ) ;
                    TN( twl , psttWorkList ) ;

                    }
                        etThread.delF( tinP , psttv ) ;
                        etThread.strFuseF( tinP , psttWorkList , tcr   ) ;
                        etThread.strFuseF( tinP , psttWorkList , psttv ) ;
                        stVolume >> psttv ;
                        ZE( strokeS* , psttv ) ;
                    {
                    while( stVolume )

                    etThread.strMakeF( tinP , LF , psttWorkList , 0 , stVolume * 2 + csttVolume ) ; ___( psttWorkList ) ;
                    ZE( strokeS* , psttWorkList ) ;

                    }
                        }
                            stVolume.sinkF( tinP , countTC() , psttv , flSTACKsINK_null ) ;     //INTENTIONALLY ALLOWS DUPLICATES SO WILL FUNCTION CORRECTLY IF MULTIPLE DEVICES HAVE THE SAME VOLUME NAME (WHICH IS BAD PRACTICE AND MIGHT NOT BE SUPPORTED IN THE FUTURE)
                            csttVolume += tVolumeName.csF( tinP ) ;

                            etThread.strMakeF( tinP , LF , psttv , tVolumeName ) ; ___( psttv ) ;
                            ZE( strokeS* , psttv ) ;

                            //etThread.traceF( tinP , T("[volume,pathToYear]:    ")+tVolumeName+tb4+T(ppsttPathToYear[offh]) ) ;
                        {
                        if( !bAbortP )

                        }
                            if( tPseudoVolume.csF( tinP ) ) tVolumeName = tVolumeName+tDot+tPseudoVolume ;

                            DEL( pInfoDisk ) ;
                            }
                                tVolumeName = T(pInfoDisk->psttVolumeName) ;
                                etThread.strConvertToLowerCaseF( tinP , pInfoDisk->psttVolumeName ) ;
                                etThread.delF( tinP , psttDisk ) ;
                            {
                            if( !bAbortP )

                            }
                                }
                                    bAbortP = 1 ;
                                    etThread.traceF( tinP , T("!exception:  diskInfoF: could not obtain volume name [psttDisk]:    ")+T(psttDisk) ) ;
                                    POOPRqUIET
                                {
                                if( POOP )
                                tinP.pEtScratch->diskInfoF( tinP , pInfoDisk , psttDisk , 1 ) ; ___( pInfoDisk ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                            ZE( infoDiskS* , pInfoDisk ) ;

                            etThread.strSubstringF( tinP , psttDisk , idf , idl , ppsttPathToYear[ offh ] ) ; ___( psttDisk ) ;
                            countT idl = 5 ;
                            countT idf = 1 ;
                            ZE( strokeS* , psttDisk ) ;
                        {
                        TN( tVolumeName , "" ) ;

                        }
                            etThread.delF( tinP , pstt1w ) ;
                            }
                                }
                                    break ;
                                    tPseudoVolume = T(psttc1) ;
                                {
                                else if( bArm )
                                if( !etThread.strCompareF( tinP , psttc1 , tDevices ) ) bArm = 1 ;
                            {
                            FORsTRINGSiN1( pstt1w )
                            ZE( boolT , bArm ) ;
                            etThread.strWordsF( tinP , pstt1w , ppsttPathToYear[ offh ] , sttq , tSlash ) ;
                            ZE( strokeS* , pstt1w ) ;
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        {
                        if( 1 == etThread.strIdF( tinP , tPathDevices , ppsttPathToYear[ offh ] ) )
                        TN( tPseudoVolume , "" ) ;
                    {
                    for( countT offh = 0 ; !bAbortP && offh < cPathsToYear ; offh ++ )
                    TN( tDevices , "devices" ) ;
                    TN( tSlash , "/" ) ;
                    ZE( countT , csttVolume ) ;
                    stackC stVolume( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

                    }
                        etThread.delF( tinP , psttd ) ;
                        tPathDevices = T(psttd) ;
                        #endif
                            //etThread.diskMapFileNameF( tinP , psttd , T("///ideafarm/devices/")            ) ; ___( psttd ) ;
                            etThread.diskMapFileNameF( tinP , psttd , T("///d/ideafarm.home.101/devices/") ) ; ___( psttd ) ;
                        #else
                            etThread.diskMapFileNameF( tinP , psttd , T("///d/ideafarm.home.101/devices/") ) ; ___( psttd ) ;
                        #if defined( IFCtESTING )
                        ZE( strokeS* , psttd ) ;
                    {
                    TN( tPathDevices , "" ) ;

                    _IO_
                {
                ZE( countT , idName ) ;
                TN( tPathLonely   , "/ideafarm.archives.lonely/"  ) ; tPathLonely  += tUniqueP+tSlash ;
                TN( tPathRejects  , "/ideafarm.archives.rejects/" ) ; tPathRejects += tUniqueP+tSlash ;
                TN( tPathArchives , "/ideafarm.archives/"         ) ;

                TN( tLongSortedBySize , "" ) ; tLongSortedBySize = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/sorted.by.size.")+tArchive+tDot+tYear+T(".ttt") ;

                _IO_
            {
            if( cPathsToYear > 1 )

            }
                }
                    }
                        }
                            while( ~hStk ) ;
                            }
                                etThread.traceF( tinP , T("ppsttPathToYear loaded [idPath,ppsttPath]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(ppsttPathToYear[offo-1]) ) ;

                                etThread.strMakeF( tinP , LF , ppsttPathToYear[ offo ++ ] , psttPath ) ; ___( ppsttPathToYear[ offo ] ) ;

                                strokeS* psttPath = (strokeS*)stPathToYear.downF( tinP , hStk ) ;

                                if( offo == cca ) { BLAMMO ; }
                            {
                            do
                            ZE( countT , offo ) ;
                            handleC hStk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                            }
                                for( countT offo = 0 ; offo < cca ; offo ++ ) pca[ offo ] = 0 ;
                                etThread.newF( tinP , LF , pca , cca ) ; ___( pca ) ;

                                         cca = stPathToYear ;
                                countT*& pca = *(countT**)&ppsttPathToYear ;
                            {
                            ZE( countT , cca ) ;
                        {
                        if( stPathToYear )

                        stPathToYear.lockIfF( tinP ) ;
                    {
                    if( idPass == 1 )

                    if( bAbortP ) break ;

                    while( !bAbortP && ~hSwsPathToArchives ) ;
                    }
                        etThread.delF( tinP , pstt1PathToYear ) ;
                        }
                            }
                                //etThread.traceF( tinP , T("stPathToYear [cPlates,ids,psttc1]:    ")+TF2(stPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idSlotPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttc1) ) ;
                                countT idSlotPathToYear = stPathToYear( psttc1 ) ;
                            {
                            else
                            }
                                }
                                    break ;
                                    bAbortP = 1 ;
                                    etThread.traceF( tinP , T("!exception: idSlotPathToYear is null") ) ;
                                    etThread.delF( tinP , psttPathToYear ) ;
                                {
                                if( !idSlotPathToYear ) //SHOULD BE IMPOSSIBLE
                                //etThread.traceF( tinP , T("maybe sunk into stPathToYear [now,psttPathToYear]:    ")+TF2(st OldPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttPathToYear) ) ;
                                stPathToYear.sinkF( tinP , idSlotPathToYear , psttPathToYear , flSTACKsINK_UNIQUE ) ;
                                ZE( countT , idSlotPathToYear ) ;

                                etThread.strMakeF( tinP , LF , psttPathToYear , psttc1 ) ; ___( psttPathToYear ) ;
                                ZE( strokeS* , psttPathToYear ) ;
                            {
                            if( idPass == 1 )
                        {
                        FORsTRINGSiN1( pstt1PathToYear )

                        //etThread.traceF( tinP , T("[pstt1PathToYear]:    ")+T(pstt1PathToYear) ) ;
                        etThread.strConvertToLowerCaseF( tinP , pstt1PathToYear ) ;

                        }
                            }
                                break ;
                                bAbortP = 1 ;
                                etThread.traceF( tinP , T("!exception:  diskFindFileOrDirF ; aborting [tPathToArchive]:    ")+tPathToArchive ) ;
                                POOPRqUIET
                            {
                            if( POOP )
                            tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        patternC pat( tinP , etThread , tYearSlash , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                        ZE( strokeS* , pstt1PathToYear ) ;

                        //if( idPass == 1 ) etThread.traceF( tinP , T("flavor [tPathToArchive]:    ")+tPathToArchive ) ;
                        TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchiveP)+tSlash ;
                        strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveNameP.downF( tinP , hSwsPathToArchives ) ;
                    {
                    do
                    handleC hSwsPathToArchives( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                    }
                        cResultStructsNeeded = 1 + cPathsToYear / cResultsPerStruct ;
                        cPathsToYear = stPathToYear ;
                    {
                    if( idPass == 2 )
                    _IO_
                {
                for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
                stackC stPathToYear( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
            {
            ZE( strokeS** , ppsttPathToYear      ) ;
            ZE( countT    , cResultStructsNeeded ) ;
            ZE( countT    , cPathsToYear         ) ;

            //idNameSkipBeyond = 0xb0 ; //U:: TO FIND A BUG

            }
                ++ s ; ether.osSleepF( tinP , TOCK ) ;
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;

                }
                    }
                        etThread.delF( tinP , posti ) ;
                        }
                            //etThread.traceF( tinP , T("i will skip files recently healed [archive,year,idNameSkipBeyond]:    ")+tArchive+tb4+tYear+tb4+TF2(idNameSkipBeyond,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            idNameSkipBeyond = *(countT*)posti ;
                        {
                        else if( posti && costi == sizeof( countT ) )
                        if( POOP ) POOPRqUIET
                        tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , tLong , 1 ) ; ___( posti ) ;
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".lath.idName.completed.ttt") ;
                {
                if( !bAbortP )
            {
            ZE( countT , idNameSkipBeyond ) ;

            }
                }
                    //etThread.traceF( tinP , T("[pJotSortedShort]:    ")+TF3((countT)pJotSortedShort,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ) ;
                    pJotSortedShort = new( 0 , tinP , LF ) jotC( tinP , tPart2 , flJOTc_DOnOTrEGISTER , 1 , CBdATAbOOKsHORTfILEnAMES , CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ) ;        //flJOTc_DOnOTrEGISTER BECAUSE WILL BE DELETED ON ANOTHER THREAD
                    //etThread.traceF( tinP , T("reusing existing jot of sorted short file names [file]:    ")+tPart2 ) ;
                {
                else
                if( !etThread.diskFileExistsF( tinP , tLongLikeIndex ) || !etThread.diskFileExistsF( tinP , tLongLikeData ) ) ;//etThread.traceF( tinP , T("could not find existing jot of sorted short file names [file]:    ")+tPart2 ) ;

                //if( !etThread.diskFileExistsF( tinP , tLongLikeData  ) ) etThread.traceF( tinP , T("not found [pattern]:    ")+tLongLikeData  ) ;
                //if( !etThread.diskFileExistsF( tinP , tLongLikeIndex ) ) etThread.traceF( tinP , T("not found [pattern]:    ")+tLongLikeIndex ) ;
                //etThread.traceF( tinP , T("looking for [pattern]:    ")+tLongLikeData ) ;
                //etThread.traceF( tinP , T("looking for [pattern]:    ")+tLongLikeIndex ) ;

                TN( tLongLikeData  , "" ) ; tLongLikeData  = tPart1+tPart2+tPart3+tPart4b ;
                TN( tLongLikeIndex , "" ) ; tLongLikeIndex = tPart1+tPart2+tPart3+tPart4a ;
                TN( tPart4b , "" ) ; tPart4b = T("data.booksC.*.bookC" ) ;
                TN( tPart4a , "" ) ; tPart4a = T("index.booksC.*.bookC" ) ;
                TN( tPart3  , "" ) ; tPart3  = T(".jotC." ) ;
                TN( tPart2  , "" ) ; tPart2  = T("healarchive.sorted.short.filenames")+tDot+tArchive+tDot+tYear ;
                TN( tPart1  , "" ) ; tPart1  = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/memorySpaces/")+tUser+T("/")+TF3(ifcIDmEMORYsPACE_APPLICATION,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T("/stateSpaces/")+TF3(ifcIDsTATEsPACE_MULTIPLEaDAMS,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tSlash ;

                TN( tUser , thirdC::postUserNameIF() ) ;
            {
            if( !pJotSortedShort )

            jotC*& pJotSortedShort = *ppJotSortedShort ;
            }
                swJotSortedShortByArchiveYearP.ungrabF( tinP ) ;
                ppJotSortedShort = (jotC**)&(countT&)swJotSortedShortByArchiveYearP ;
                psttzArchiveSlashYearP = tLever ;
                swJotSortedShortByArchiveYearP.grabF( tinP , TAG( TAGiDnULL ) ) ;
                TN( tLever , "" ) ; tLever = tArchive+tSlash+tYear ;
            {
            ZE( jotC** , ppJotSortedShort ) ;
            _IO_
        {
        else
        if( !bDoThisYear ) etThread.traceF( tinP , T("skipping this year because it was recently healed AOK [archive,year]:    ")+tArchive+tb4+tYear ) ;

        }
            etThread.delF( tinP , posti ) ;
            }
                }
                    if( time2E < 0x40 ) bDoThisYear = 0 ;
                    etThread.osTimeSubtractF( tinP , time1E , time2E , time1AOK , time2AOK ) ;

                    }
                        etThread.delF( tinP , pstt1w ) ;
                        }
                            if( cDone == 2 ) break ;
                            *( cDone ++ ? &time2AOK : (sCountT*)&time1AOK ) = etThread.strDigitsToSCountF( tinP , psttc1 ) ;
                            //etThread.traceF( tinP , T("time word:    ")+T(psttc1) ) ;
                        {
                        FORsTRINGSiN1( pstt1w )
                        ZE( countT  , cDone ) ;
                        etThread.strWordsF( tinP , pstt1w , tTimeAOK , sttq , tDot ) ; ___( pstt1w ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        ZE( strokeS* , pstt1w ) ;

                        //etThread.traceF( tinP , T("[archive,year,timeAOK]:    ")+tArchive+tb4+tYear+tb4+tTimeAOK ) ;
                        TN( tTimeAOK , posti ) ;
                        *postc = 0 ;
                    {
                    ZE( sCountT , time2AOK ) ;
                    ZE( countT  , time1AOK ) ;

                    etThread.osTimeNowF( tinP , time1E , time2E ) ;
                    ZE( sCountT , time2E ) ;
                    ZE( countT  , time1E ) ;
                {
                if( postc )
                osTextT* postc = thirdC::c_strstrIF( tinP , posti , "\r\n" ) ;
            {
            else
            if( POOP ) POOPRqUIET
            tinP.pEtScratch->boxGetShadowF( tinP , posti , costi , tLong , 1 ) ; ___( posti ) ;
            TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchive+tDot+tYear+T(".completed.ttt") ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCH
        boolT bDoThisYear = 1 ;

        //etThread.traceF( tinP , T("[archive,year]:    ")+tArchive+tb4+tYear ) ;
        TN( tYearSlash , "" ) ; tYearSlash = tYear+T("/") ;
        etThread.delF( tinP , psttYearP ) ;
        TN( tYear , "" ) ; tYear = T(psttYearP) ;

        TN( tArchive , psttzArchiveP ) ;

        TN( tIndent3 , "|           " ) ;
        TN( tIndent2 , "|       " ) ;
        TN( tIndent1 , "|   " ) ;
        TN( tPerTuck , "%" ) ;
        TN( tDot     , "." ) ;
        TN( tcr      , "\r\n" ) ;
        TN( tSlash   , "/" ) ;
        TN( tb4      , "    " ) ;
        TN( tb       , " " ) ;
        _IO_
    {
    if( !POOP )

    // #endif
    //     //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
    // #if defined( IFC tESTING )
    const countT cProcessors = thirdC::osProcessorsIF( tinP ) ;

    __Z( psttzArchiveP->idAdam ) ;
    __Z( psttYearP->idAdam ) ;
    _IO_

    etThread.traceF( tinP , T("[idPhaseP]:    ")+TF2(idPhaseP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    grabC&        grabDiskP                       =        *(grabC*)pTaskP->c31 ;
    grabC&        grabLathFileHealedFilesP        =        *(grabC*)pTaskP->c21 ;
    countT        idPhaseP                        =                 pTaskP->c11 ;
    countT&       cPathsToYearHealingP            =       *(countT*)pTaskP->c01 ;
    switchC&      swJotSortedShortByArchiveYearP  =      *(switchC*)pTaskP->cf  ;
    strokeS*&     psttzArchiveSlashYearP          =     *(strokeS**)pTaskP->ce  ;
    boolT&        bAbortP                         =        *(boolT*)pTaskP->cd  ;
    switchStackC& swsPathToArchivesByArchiveNameP = *(switchStackC*)pTaskP->cc  ;
    strokeS*&     psttzArchiveP                   =     *(strokeS**)pTaskP->cb  ;
    strokeS*      psttYearP                       =       (strokeS*)pTaskP->ca  ;
    textC&        tUniqueP                        =        *(textC*)pTaskP->c9  ;
    countT&       cExecutiveHealYearPausedP       =       *(countT*)pTaskP->c8  ;
    countT&       cExecutiveHealYearP             =       *(countT*)pTaskP->c7  ;
    flagsT        flagsModeP                      =         (flagsT)pTaskP->c6  ;
    countT&       cYearsHealingP                  =       *(countT*)pTaskP->c5  ;
    funnelHornC&  funJobFileInfoP                 =  *(funnelHornC*)pTaskP->c4  ;
    stackC&       stJobCompareP                   =       *(stackC*)pTaskP->c3  ;
    funnelHornC&  funJobHealFileP                 =  *(funnelHornC*)pTaskP->c2  ;
    countT&       cPauseP                         =       *(countT*)pTaskP->c1  ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 && pTaskP->c8 && pTaskP->c9 && pTaskP->ca && pTaskP->cb && pTaskP->cc && pTaskP->cd && pTaskP->ce && pTaskP->cf && pTaskP->c01 && pTaskP->c21 && pTaskP->c31 )
TASK( tmExecutiveHealYearF )

DONE( tmUpdateYearCheckpointF )
}
    }
        ++ s ; thirdC::dosSleepIF( tinP , TOCK >> 1 ) ;
        //etThread.traceF( tinP , T("napping") ) ;
        //if( bDo ) FIREmYSELF ;

        }
            //grabLathFileHealedFilesP.ungrabF( tinP ) ;
            //THREADmODE2rESTORE
            etThread.boxPutF( tinP , tLong , (byteT*)&idNameLathDoneInSequenceNew , sizeof idNameLathDoneInSequenceNew ) ;
            //THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
            //grabLathFileHealedFilesP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            TN( tLong , "" ) ; tLong = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/archives/healing/state/status.")+tArchiveP+tDot+tYearP+T(".lath.idName.completed.ttt") ;

            //etThread.traceF( tinP , T("lath done [idNameLathDoneInSequenceNew]:    ")+TF2(idNameLathDoneInSequenceNew,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            _IO_
        {
        if( idNameLathDoneInSequenceNew )

        st_pzJobHealFileDoneP.ungrabF( tinP ) ;
        }
            while( ~hStk ) ;
            }
                }
                    funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
                    DELzOMBIE( pzJob ) ;
                    jobHealFileS* pzDoomed = pzJob ;
                    idNameLathDoneInSequenceNew = idNameConsecutiveLathDoneP = pzJob->idName ;
                    st_pzJobHealFileDoneP.extractF( 0 , tinP ) ;
                    _IO_
                {
                else if( idNameConsecutiveLathDoneP + 1 == pzJob->idName )
                }
                    funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
                    DELzOMBIE( pzJob ) ;
                    jobHealFileS* pzDoomed = pzJob ;
                    st_pzJobHealFileDoneP.extractF( 0 , tinP ) ;
                    _IO_
                {
                if( ether )  //20231126@2016: ADDED ; IF I'VE BEEN FIRED, tmWorkerHealFileF MIGHT HAVE DELETED SOME JOBS SO I CANNOT RELY ON ALL idName VALUES BEING PRESENT IN st_pzJobHealFileDoneP ; IF ( idNameConsecutiveLathDoneP + 1 ) IS NOT PRESENT THEN THIS LOOP WILL SPIN FOREVER

                //etThread.traceF( tinP , T("walking stack of done jobs [idName,short]:    ")+TF3(pzJob->idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+T(pzJob->psttShort) ) ;
                jobHealFileS* pzJob = (jobHealFileS*)st_pzJobHealFileDoneP.downF( tinP , hStk ) ;
                _IO_
            {
            do
            handleC hStk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            //bDo = 1 ;
            _IO_
        {
        if( st_pzJobHealFileDoneP )
        st_pzJobHealFileDoneP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        ZE( countT , idNameLathDoneInSequenceNew ) ;
        _IO_
    {
    while( !bFireCheckpointUpdateP )
    //ZE( boolT , bDo ) ;
    TN( tDot , "." ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    _IO_

    textC&       tYearP                     =       *(textC*)pTaskP->c6 ;
    textC&       tArchiveP                  =       *(textC*)pTaskP->c5 ;
    countT&      idNameConsecutiveLathDoneP =      *(countT*)pTaskP->c4 ;
    funnelHornC& funJobHealFileP            = *(funnelHornC*)pTaskP->c3 ;
    stackC&      st_pzJobHealFileDoneP      =      *(stackC*)pTaskP->c2 ;
    boolT&       bFireCheckpointUpdateP     =       *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmUpdateYearCheckpointF )

DONE( tmWorkerMemCompareF )
}
    dec02AM( cWorkersCompareP ) ;
    stJobCompareP.ungrabF( tinP ) ;
    }
        DEL( pJob ) ;
        stJobCompareP >> *(countT*)&pJob ;
        ZE( jobCompareOoImagesS* , pJob ) ;
        _IO_
    {
    while( stJobCompareP )
    stJobCompareP.grabF( tinP , TAG( TAGiDnULL ) ) ;

    // #endif
    //     //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
    // #if defined( IFC tESTING )
    }
        stJobCompareP.ungrabF( tinP ) ;

        }
            stJobCompareP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            ++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
            if( cYearsHealingP && !( ++ cIdle % TOCK ) ) etThread.traceF( tinP , T("years are healing but i have nothing to do (no memory compare jobs) [cIdle]:    ")+TF2(++cIdle,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            stJobCompareP.ungrabF( tinP ) ;
            _IO_
        {
        if( !cDone )

        // #endif
        //     //}
        //     //    etThread.traceF( tinP , T("---- watch") ) ;
        //     //    etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
        //     //    bWatching = 0 ;
        //     //{
        //     //if( bWatching )
        // #if defined( IFC tESTING )

        }
            stJobCompareP.grabF( tinP , TAG( TAGiDnULL ) ) ;
            cDone ++ ;
            DEL( pJob ) ;
            }
                //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
                compareOoImagesF( tinP , ether , etThread , bAbortP , cPauseP , pJob->bEqual , flagsModeP , pJob->pbwOuter , pJob->pbwInner , pJob->cbwOuter /*, T(pJob->psttLongOuter) , T(pJob->psttLongInner) , tIndent3*/ ) ; // bEqual MIGHT BE RESET DUE TO A PREVIOUS JOB ; THIS CAN HAPPEN DUE TO RACE BETWEEN ME AND THE THREAD THAT PUSHES JOBS ; SOMETIMES compareOoImagesF WILL BE CALLED UNNECESSARILY BUT THIS IS HARMLESS
                //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
                _IO_
            {
            if( pJob->bEqual )
            stJobCompareP.ungrabF( tinP ) ;

            stJobCompareP >> *(countT*)&pJob ;
            ZE( jobCompareOoImagesS* , pJob ) ;

            // #endif
            //     //}
            //     //    etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
            //     //    etThread.traceF( tinP , T("++++ watch") ) ;
            //     //    bWatching = 1 ;
            //     //{
            //     //if( !bWatching )
            // #if defined( IFC tESTING )
            _IO_
        {
        while( stJobCompareP )
        //ZE( boolT , bWatching ) ;
        ZE( countT , cDone ) ;
        stJobCompareP.grabF( tinP , TAG( TAGiDnULL ) ) ;
        _IO_
    {
    while( !ether )
    ZE( countT , cIdle ) ;
    // #endif
    //     //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
    // #if defined( IFC tESTING )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    TN( tIndent3 , "|           " ) ;

    _IO_

    countT&       cYearsHealingP                  = *(countT*)pTaskP->c6 ;
    flagsT        flagsModeP                      =   (flagsT)pTaskP->c5 ;
    stackC&       stJobCompareP                   = *(stackC*)pTaskP->c4 ;
    countT&       cPauseP                         = *(countT*)pTaskP->c3 ;
    boolT&        bAbortP                         =  *(boolT*)pTaskP->c2 ;
    countT&       cWorkersCompareP                = *(countT*)pTaskP->c1 ;  //U:: cWorkersCompareP IS ALSO NEEDED TO WORKAROUND A DESIGN DEFECT OF etherWhereF (20231126@1005 I NO LONGER REMEMBER WHAT DEFECT THAT WAS)
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmWorkerMemCompareF )

DONE( tmWorkerFileInfoF )
}
    dec02AM( cWorkersFileInfoP ) ;

    }
        funJobFileInfoP.readDoneF( (byteT*)pzDoomed ) ;
        DELzOMBIE( pzJob ) ;
        jobFileInfoS* pzDoomed = pzJob ;
        if( !pzJob ) break ;
        jobFileInfoS* pzJob = (jobFileInfoS*)funJobFileInfoP.readF( tinP , flFUNNELhORNcrEAD_NOwAIT ) ;
        _IO_
    {
    for(;;)

    }
        //etThread.traceF( tinP , tSay2 ) ;

        funJobFileInfoP.readDoneF( (byteT*)pzDoomed ) ;
        DELzOMBIE( pzJob ) ;
        jobFileInfoS* pzDoomed = pzJob ;

        }
            if( !bOk ) pzJob->pInfo = INFOfILEnOTaVAILABLE ; // CLIENT MUST INSPECT FOR THIS SPECIAL VALUE

            }
                }
                    }
                        DEL( pzJob->pInfo ) ;
                        bOk = 0 ;
                        bAbortP = 1 ;
                        etThread.traceF( tinP , T("!exception:  diskFileQueryF [tLong]:    ")+T(pzJob->psttLong) ) ;
                        POOPRqUIET
                        _IO_
                    {
                    else
                    if( !POOP ) pzJob->pInfo = pInfoFile ;
                    tinP.pEtScratch->diskFileQueryF( tinP , pInfoFile , fi ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                    _IO_
                {
                else if( bOk )
                }
                    bOk = 0 ;
                    bAbortP = 1 ;
                    etThread.traceF( tinP , T("!exception:  fileC::fileC [POOP,tLong]:    ")+TF2(save,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(pzJob->psttLong) ) ;
                    POOPRqUIET
                    countT save = POOP ;
                    _IO_
                {
                if( POOP )

                }
                    }
                        break ;
                        bOk = 0 ;
                        /**/etThread.traceF( tinP , T("warning: listed file not found [tLong]:    ")+T(pzJob->psttLong) ) ;
                        POOPRqUIET
                    {
                    case ifcIDiMPOTENCEbASEeRRORcODE_FILEnOTfOUND :
                    }
                        break ;
                        bOk = 0 ;
                        /**/etThread.traceF( tinP , T("warning: listed file path not found [tLong]:    ")+T(pzJob->psttLong) ) ;
                        POOPRqUIET
                    {
                    case ifcIDiMPOTENCEbASEeRRORcODE_PATHnOTfOUND :
                {
                switch( POOP )

                fileC fi( tinP , pzJob->psttLong , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 ) ;

                SCOOPS
                _IO_
            {
            IFsCRATCH
            boolT bOk = 1 ;
            _IO_
        {
        if( !bQuitP )

        //etThread.traceF( tinP , tSay1 ) ;
        //if( timeE1 || timeE2 ) tSay1 += T("    nothing to do for time    ")+TT(timeE1,timeE2) ;
        //TN( tSay2 , "                                                                                                                 -----------------------------------------------------------------------------------------------------------------" ) ;
        //TN( tSay1 , "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++" ) ;

        etThread.osTimeSubtractF( tinP , timeE1 , timeE2 , timeN1 , timeN2 ) ;
        etThread.osTimeNowF( tinP , timeE1 , timeE2 ) ;
        ZE( sCountT , timeE2 ) ;
        ZE( countT  , timeE1 ) ;
        jobFileInfoS* pzJob = (jobFileInfoS*)funJobFileInfoP.readF( tinP ) ;
        etThread.osTimeNowF( tinP , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;
        _IO_
    {
    while( !bQuitP )
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    TN( tb4 , "    " ) ;
    TN( tIndent3 , "|           " ) ;

    _IO_

    flagsT        flagsModeP                      =         (flagsT)pTaskP->c6 ;
    funnelHornC&  funJobFileInfoP                 =  *(funnelHornC*)pTaskP->c5 ;
    countT&       cPauseP                         =       *(countT*)pTaskP->c4 ;
    boolT&        bAbortP                         =        *(boolT*)pTaskP->c3 ;
    countT&       cWorkersFileInfoP               =       *(countT*)pTaskP->c2 ;
    boolT&        bQuitP                          =        *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 )
TASK( tmWorkerFileInfoF )

DONE( tmWorkerHealFileF )
}
    dec02AM( cWorkersHealP ) ;

    }
        funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
        DELzOMBIE( pzJob ) ;
        jobHealFileS* pzDoomed = pzJob ;
        if( !pzJob ) break ;
        jobHealFileS* pzJob = (jobHealFileS*)funJobHealFileP.readF( tinP , flFUNNELhORNcrEAD_NOwAIT ) ;
        _IO_
    {
    for(;;)

    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
    }
        }
            funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
            DELzOMBIE( pzJob ) ;
            jobHealFileS* pzDoomed = pzJob ;
            _IO_
        {
        if( !ids )

        }
            ++ s ; thirdC::dosSleepWinkIF( tinP ) ;
            }
                break ;
                pzJob = 0 ; 
            {
            if( ids )
            pzJob->info.st_pzJobHealFileDone.sinkF( tinP , ids , (countT)pzJob , flSTACKsINK_UNIQUE , subtractHealFileJobF ) ;
            _IO_
        {
        while( !ether )
        ZE( countT , ids ) ;

        }
            // if( bChatter ) etThread.traceF( tinP , T("done [idName,tShort]:    ")+TF2(pzJob->idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShort ) ;
            healShortNameF( tinP , ether , pzJob->info , tShort , flagsModeP , pzJob->idName , pzJob->cShortNames , cToHireHealP , cToHireCompareP , bChatter ) ;
            // /*if( !( idIn % TUCK ) )*/ etThread.traceF( tinP , T("calling healShortNameF [idIn]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            //countT idIn = 1 + incv02AM( idInLath ) ;
            //static countT idInLath ;
            _IO_
        {
        TN( tShort , pzJob->psttShort ) ;

        //U:: LATER: pzJob->info.funJobHealFileDone.writeF( tinP , (byteT*)pzJob ) ;

        //etThread.traceF( tinP , T("pulled from funJobHealFileP [idName]:    ")+TF2(pzJob->idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        }
            break ;
            }
                funJobHealFileP.readDoneF( (byteT*)pzDoomed ) ;
                DELzOMBIE( pzJob ) ;
                jobHealFileS* pzDoomed = pzJob ;
                _IO_
            {
            if( pzJob )
        {
        if( !pzJob || ether )
        jobHealFileS* pzJob = (jobHealFileS*)funJobHealFileP.readF( tinP ) ;
        _IO_
    {
    while( !ether )
    ZE( countT , cIdle ) ;

    //etThread.etherWhereF( tinP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
    ZE( countT , cDoneTotal ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;

    TN( tb4 , "    " ) ;
    TN( tIndent3 , "|           " ) ;

    bChatter = 0 ;
    boolT bChatter = idIn == 1 ;
    countT idIn = 1 + incv02AM( idInLath ) ;
    static countT idInLath ;

    _IO_

    countT        cToHireCompareP                 =                 pTaskP->c8 ;
    countT        cToHireHealP                    =                 pTaskP->c7 ;
    countT&       cYearsHealingP                  =       *(countT*)pTaskP->c6 ;
    flagsT        flagsModeP                      =         (flagsT)pTaskP->c5 ;
    funnelHornC&  funJobHealFileP                 =  *(funnelHornC*)pTaskP->c4 ;
    countT&       cPauseP                         =       *(countT*)pTaskP->c3 ;
    boolT&        bAbortP                         =        *(boolT*)pTaskP->c2 ;
    countT&       cWorkersHealP                   =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TASK( tmWorkerHealFileF )

}
    etherP.delF( tinP , *(byteT**)&pTimeWrittenNewest ) ;
    }
        THREADmODE2rESTORE
        }
            }
                ++ s ; etherP.osSleepF( tinP , TOCK >> 2 ) ;
            {
            while( cDayZippers )
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;

            }
                etherP.osThreadF( TaRG1( tmDayZipperF ) , (countT)&cDayZippers , (countT)&bAbortP , cPathsToYearP , offi , (countT)ppsttPathToYearP , (countT)pTimeWrittenNewest , (countT)&tDayPrefixP ) ;
                inc02AM( cDayZippers ) ;
            {
            for( countT offi = 0 ; offi < cPathsToYearP ; offi ++ )
            ZE( countT , cDayZippers ) ;
        {
        if( !bAbortP && cFilesMax > 1 )

        }
            }
                }
                    if( cFilesMax < idFile ) cFilesMax = idFile ;
                {
                if( idPass == 1 )

                while( ~hFindFile && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        }
                            }
                                }
                                    }
                                        }
                                            etherP.traceF( tinP , T("!exception: could not set file time [name]:    ")+T(pInfoFile->psttIfoName) ) ;
                                            bAbortP = 1 ;
                                            POOPRqUIET
                                        {
                                        if( POOP )

                                        ((thirdC&)etherP).setFileTimeF( tinP , fiw , &pTimeWrittenNewest[ offi ] , &pTimeWrittenNewest[ offi ] , &pTimeWrittenNewest[ offi ] ) ;
                                    {
                                    else
                                    }
                                        etherP.traceF( tinP , T("!exception: could not open file WR 0 [name]:    ")+T(pInfoFile->psttIfoName) ) ;
                                        bAbortP = 1 ;
                                        POOPRqUIET
                                    {
                                    if( POOP )

                                    fileC fiw( tinP , pInfoFile->psttIfoName , ifcOPENaCCESS_WR , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 0 , 0 ) ;

                                    SCOOPS
                                    _IO_
                                {
                                IFsCRATCH
                            {
                            else if( cFilesMax > 1 )
                            }
                                etherP.traceF( tinP , T("[timeWritten,pTimeWrittenNewest[ offi ]]:    ")+TT(timeWritten.time1,timeWritten.time2)+tb4+TT(pTimeWrittenNewest[ offi ].time1,pTimeWrittenNewest[ offi ].time2) ) ;

                                    pTimeWrittenNewest[ offi ] = timeWritten ;
                                if( pTimeWrittenNewest[ offi ].time2 < timeWritten.time2 || ( pTimeWrittenNewest[ offi ].time2 == timeWritten.time2 && pTimeWrittenNewest[ offi ].time1 < timeWritten.time1 ) )

                                }
                                    }
                                        }
                                            }
                                                etherP.traceF( tinP , T("!exception: could not get file time [name]:    ")+T(pInfoFile->psttIfoName) ) ;
                                                bAbortP = 1 ;
                                                POOPRqUIET
                                            {
                                            if( POOP )

                                            thirdC::getFileTimeIF( tinP , fir , &timeWritten , 0 , 0 ) ;
                                        {
                                        else
                                        }
                                            etherP.traceF( tinP , T("!exception: could not open file R R [name]:    ")+T(pInfoFile->psttIfoName) ) ;
                                            bAbortP = 1 ;
                                            POOPRqUIET
                                        {
                                        if( POOP )

                                        fileC fir( tinP , pInfoFile->psttIfoName , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 0 , 0 ) ;

                                        SCOOPS
                                        _IO_
                                    {
                                    IFsCRATCH
                                {
                                timeS timeWritten = timeS() ;
                                idFile ++ ;
                            {
                            if( idPass == 1 )
                        {
                        if( tShort.csF( tinP ) )        // IF NOT A DIRECTORY

                        }
                            etherP.delF( tinP , psttShort ) ;
                            etherP.delF( tinP , psttnu ) ;
                            tShort  = T(psttShort) ;
                            etherP.strBisectF( tinP , psttnu , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShort , "" ) ;
                    {
                    if( !bAbortP && !etPrime && pInfoFile && pInfoFile->psttIfoName )

                    }
                        }
                            etherP.strMakeFromOsTextF( tinP , pInfoFile->psttIfoName , iffn ) ; ___( pInfoFile->psttIfoName ) ;
                            ifFileNameC iffn( tinP , etherP , pInfoFile->postOsName ) ;
                        {
                        if( !bAbortP && pInfoFile && !pInfoFile->psttIfoName )

                        }
                            }
                                etherP.traceF( tinP , T("!exception: find file failed [like]:    ")+T(osfnLike) ) ;
                                bAbortP = 1 ;
                                POOPRqUIET
                            {
                            if( POOP )

                            ((thirdC&)*tinP.pEtScratch).dosFindFileOrDirPrivateF( tinP , pInfoFile , hFindFile , osfnLike ) ;

                            SCOOPS
                            _IO_
                        {
                        IFsCRATCH

                        //etherP.traceF( tinP , T("like:    ")+tLike ) ;
                        osFileNameC osfnLike( tinP , etherP , tLike ) ;
                        TN( tLike , "" )  ; tLike = tPathYear+tPattern ;
                    {
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                handleC hFindFile( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                ZE( countT , idFile ) ;

                if( idPass == 2 && !pTimeWrittenNewest[ offi ] ) break ;
            {
            for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
            pTimeWrittenNewest[ offi ] = timeS() ;
            //PASS 1: GET THE MOST RECENT FILE TIME MODIFIED ; PASS 2: SET ALL FILE TIMES TO THE MOST RECENT TIME

            etherP.traceF( tinP , T("[prefix,device:    ")+tDayPrefixP+tb4+tPathYear ) ;
            TN( tPattern  , "" ) ; tPattern  = tDayPrefixP+sttAsterisk ;
            TN( tPathYear , "" ) ; tPathYear = T(ppsttPathToYearP[offi]) ;
        {
        for( countT offi = 0 ; offi < cPathsToYearP ; offi ++ )
        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
    {
    if( pTimeWrittenNewest )

    etherP.newF( tinP , LF , *(byteT**)&pTimeWrittenNewest , sizeof( timeS ) * cPathsToYearP ) ; ___( pTimeWrittenNewest ) ;
    ZE( timeS* , pTimeWrittenNewest ) ;

    TN( tb4  , "    " ) ;
    TN( tb   , " " ) ;
    strokeS sttAsterisk( '*' ) ;
    ZE( countT , cFilesMax ) ;
    etherC& etPrime = etherC::etPrimeIF() ;
{
voidT chunkDayIfF( tinS& tinP , etherC& etherP , boolT& bAbortP , countT cPathsToYearP , strokeS** ppsttPathToYearP , textC& tDayPrefixP )

DONE( tmDayZipperF )
}
    dec02AM( cDayZippersP ) ;
    if( !bAbortP ) zipDayF( tinP , etThread , bAbortP , cPathsToYearP , ppsttPathToYearP , pTimeWrittenNewestP , tDayPrefixP , offDoP ) ;

    textC&    tDayPrefixP         =   *(textC*)pTaskP->c7 ;
    timeS*    pTimeWrittenNewestP =    (timeS*)pTaskP->c6 ;
    strokeS** ppsttPathToYearP    = (strokeS**)pTaskP->c5 ;
    countT    offDoP              =            pTaskP->c4 ;
    countT    cPathsToYearP       =            pTaskP->c3 ;
    boolT&    bAbortP             =   *(boolT*)pTaskP->c2 ;
    countT&   cDayZippersP        =  *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TASK( tmDayZipperF )

}
    }
        }
            }
                }
                    etherP.traceF( tinP , T("!exception: could not set file time [name]:    ")+tPathYear+tShortDayZip ) ;
                    bAbortP = 1 ;
                    POOPRqUIET
                {
                if( POOP )

                ((thirdC&)etherP).setFileTimeF( tinP , fiw , &pTimeWrittenNewestP[ offi ] , &pTimeWrittenNewestP[ offi ] , &pTimeWrittenNewestP[ offi ] ) ;
            {
            else
            }
                etherP.traceF( tinP , T("!exception: could not open file WR 0 [name]:    ")+tPathYear+tShortDayZip ) ;
                bAbortP = 1 ;
                POOPRqUIET
            {
            if( POOP )

            fileC fiw( tinP , (strokeS*)( tPathYear+tShortDayZip ) , ifcOPENaCCESS_WR , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 0 , 0 ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCH

        etherP.traceF( tinP , T("zipped") ) ;

        __( idDeathType ) ;
        __( value ) ;
        etherP.osProcessWaitF( tinP , value , idDeathType , osPid ) ;
        ZE( countT , idDeathType ) ;
        ZE( countT , value ) ;

        __Z( osPid ) ;
        countT osPid = etherP.ifcHireF( tinP , T("ifcIDaDAM_HEALaRCHIVES") , ifcIDaDAM_HIREwITHOUTdEBUGGING , T("!hireLater pkzipc.exe -max -add -move ")+tShortDayZip+tb+tDayPrefixP+T("@*") , flHIRE_DISPLAYnONE , 0 , 0 , 1 , nicNameC() ) ;
        etherP.traceF( tinP , T("zipping") ) ;

        TN( tShortDayZip , "" ) ; tShortDayZip = tDayPrefixP+T(".!.chunk.day.zip") ;

        //etherP.traceF( tinP , T("[hovered]:     ")+tPathYear ) ;
        hoverC hover( tinP , etherP , tPathYear ) ;
        //etherP.traceF( tinP , T("[hovering]:    ")+tPathYear ) ;

        TN( tPathYear , "" ) ; tPathYear = T(ppsttPathToYearP[offi]) ;

        if( offDoP != -1 && offi != offDoP ) continue ;
    {
    for( countT offi = 0 ; !bAbortP && offi < cPathsToYearP ; offi ++ )
    TN( tb   , " " ) ;
{
voidT zipDayF( tinS& tinP , etherC& etherP , boolT& bAbortP , countT cPathsToYearP , strokeS** ppsttPathToYearP , timeS* pTimeWrittenNewestP , textC& tDayPrefixP , countT offDoP )

}
    return pJob1->idName - pJob2->idName ;

    jobHealFileS* pJob2 = (jobHealFileS*)c2P ;
    jobHealFileS* pJob1 = (jobHealFileS*)c1P ;
{
countT _export subtractHealFileJobF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    // /* if( bChatterP )*/ pP.ether.traceF( tinP , T("healed  ---- [idName]:    ")+TF2(idNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    }
        }
            //tinP.pc Utility[ 0 ] -- ;

            //pP.ether.traceF( tinP , T("    ---- watch") ) ;
            //pP.ether.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
        {
        if( bChatterP )

        //if( !pP.bAbort ) pP.ether.traceF( tinP , T("---- healed  [tShort]:    ")+tShortP ) ;

        }
            //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 00") ) ;
            }
                THREADmODE2rESTORE
                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 10") ) ;
                }
                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 20") ) ;
                    }
                        }
                            //pP.ether.traceF( tinP , T("healed [cShortNames,idName,cRemaining,perTuckDone,timePerTock,timeE1,cbUsedMax,cbUsedHighMax,tShort]:    ")+TF3(cShortNamesP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF3(idNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF3(cRemaining,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF3(perTuckDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,3)+tPerTuck+tb4+TF3(timePerTock,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+TF3(timeE1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF3(cbUsedMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb+TF3(cbUsedHighMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+tShortP ) ;

                            countT perTuckDone = !cShortNamesP ? 0 : ( idNameP << 8 ) / cShortNamesP ;
                            countT cRemaining = cShortNamesP - idNameP ;

                            countT timePerTock = !c4Tock ? 0 : (countT)( c4Time / c4Tock ) ;

                            count04T& c4Time = *(count04T*)pcTime ;
                            countT pcTime[] = { timeE1 , timeE2 } ;

                            count04T  c4Tock = c4Used / TOCK ;
                            count04T& c4Used = *(count04T*)pcUsed ;
                            countT pcUsed[] = { cbUsedMax , cbUsedHighMax } ;

                            pP.ether.osTimeSubtractF( tinP , timeE1 , timeE2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO HEAL THIS SHORT NAME
                            pP.ether.osTimeNowF( tinP , timeE1 , timeE2 ) ;
                            ZE( sCountT , timeE2 ) ;
                            ZE( countT  , timeE1 ) ;
                        {
                        //)
                        //    )
                        //        !( idNameP % ( TUCK >> 2 ) )
                        //        ||
                        //        ( cbUsedHighMax || cbUsedMax > ( TOCK << 2 ) )
                        //    (
                        //    &&
                        //    !pP.bAbort
                        //(
                        //if

                        //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 30") ) ;
                        }
                            //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 40") ) ;
                            }
                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 50") ) ;
                                }
                                    while( ~hStkMeta ) ;
                                    }
                                        DELzOMBIE( pfmOuter ) ;

                                        }
                                            DELzOMBIE( pd ) ;
                                            imageCompareS* pd = picOuter + offd ;
                                        {
                                        for( countT offd = 0 ; offd < pP.cResultStructsNeeded ; offd ++ )

                                        fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + pP.cResultStructsNeeded ) ;
                                        imageCompareS* picOuter  = (imageCompareS*)&stMeta.upF( tinP , hStkMeta ) ;
                                    {
                                    do
                                    handleC hStkMeta( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                {
                                if( stMeta )
                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 60") ) ;
                                //pP.ether.traceF( tinP , T("deleting metadata [cPlates]:    ")+TF2(stMeta,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                //pP.ether.traceF( tinP , T("healed  [result,tArchive,tYear,tShort]:    ")+T(pP.bAbort?"aborted    ":"aok    ")+pP.tArchive+tb4+pP.tYear+tb4+tShortP ) ;

                                //pP.ether.traceF( tinP , T("processed  [tShort]:    ")+tShortP ) ;

                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // ****                                                                                                                                  *******************************************************************
                                // ****  END:    COMPARE ALL COPIES OF THIS SHORT FILE NAME.  THIS IS RETRIED UNTIL ALL COMPARISONS COMPLETE WITHOUT AN EXCEPTION EVENT  *******************************************************************
                                // ****                                                                                                                                  *******************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************
                            {
                            if( !pP.bAbort )

                            //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 70") ) ;
                            }
                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 80") ) ;
                                }
                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                *************************************************************************************************************************************************************************************
                                    // ****  END:    HEAL  *************************************************************************************************************************************************************************************
                                    // ****                *************************************************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************

                                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 90") ) ;
                                    }
                                        //if( bChatterP ) pP.ether.traceF( tinP , T("healing / a0") ) ;
                                        }
                                            //if( bChatterP ) pP.ether.traceF( tinP , T("healing / b0") ) ;
                                            }
                                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / c0") ) ;
                                                }
                                                    }
                                                        pP.ether.delF( tinP , psttFrom ) ;
                                                        pP.ether.delF( tinP , psttTo   ) ;

                                                        }
                                                            }
                                                                //if( !pP.bAbort ) pP.ether.traceF( tinP , T("copied [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;

                                                                }
                                                                    }
                                                                        }
                                                                            break ;
                                                                            pP.bAbort = 1 ;
                                                                            pP.ether.traceF( tinP , T("!exception:  unexpected impotence copy [POOP,to,from]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                            POOPRqUIET
                                                                            countT rc = POOP ;
                                                                        {
                                                                        else
                                                                        }
                                                                            thirdC::dosSleepWinkIF( tinP , 2 ) ;
                                                                            pP.ether.traceF( tinP , T("!exception:  could not copy file ; will retry until fired [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                            POOPRqUIET
                                                                        {
                                                                        else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_ACCESSdENIED )
                                                                        }
                                                                            break ;
                                                                            pP.ether.traceF( tinP , T("!exception: could not copy file because destination device is write protected [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                            POOPRqUIET
                                                                        {
                                                                        else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_WRITEpROTECT )
                                                                        if( !POOP ) break ;
                                                                        tinP.pEtScratch->diskCopyFileF( tinP , psttTo , psttFrom , 1 ) ;
                                                                        SCOOPS
                                                                    {
                                                                    IFsCRATCH
                                                                {
                                                                while( !etPrime )

                                                                pP.ether.traceF( tinP , T("copying [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                            {
                                                            else
                                                            }
                                                                else pP.ether.traceF( tinP , T("flHEALmODE_NOmOVEoRrEPLACE is set so the target file exists and was not moved out of the way and am not copying to target [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                }
                                                                    pP.ether.traceF( tinP , T("!exception: bizarre!  there is still a file in the way, so not copying [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                    pP.bAbort = 1 ;
                                                                {
                                                                else if( !( F(flagsModeP) & flHEALmODE_NOmOVEoRrEPLACE ) )
                                                                if( bReadOnly ) ;
                                                            {
                                                            else if( bExists )
                                                            }
                                                                }
                                                                    pP.ether.traceF( tinP , T("!exception: after rejecting a file out of the way, not copying because could not obtain bExists (probable drive failure) [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                {
                                                                if( !( F(flagsModeP) & flHEALmODE_NOmOVEoRrEPLACE ) )
                                                            {
                                                            if( pP.bAbort )

                                                            }
                                                                }
                                                                    }
                                                                        pP.bAbort = 1 ;
                                                                        pP.ether.traceF( tinP , T("!exception: diskFileExistsF failed FOR psttTol 2 [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                        POOPRqUIET
                                                                    {
                                                                    if( POOP )
                                                                    bExists = tinP.pEtScratch->diskFileExistsF( tinP , psttTo ) ;

                                                                    SCOOPS
                                                                {
                                                                IFsCRATCH
                                                            {
                                                            if( !( F(flagsModeP) & flHEALmODE_NOmOVEoRrEPLACE ) )

                                                            // *********************************************************************************************************************************************************************************************************
                                                            // ****                                                  ***************************************************************************************************************************************************
                                                            // ****  COPY AUTHORITATIVE FILE TO WO RECIPIENT VOLUME  ***************************************************************************************************************************************************
                                                            // ****                                                  ***************************************************************************************************************************************************
                                                            // *********************************************************************************************************************************************************************************************************

                                                            }
                                                                pP.ether.delF( tinP , psttLongInRejects ) ;

                                                                }
                                                                    if( bDone ) pP.ether.traceF( tinP , T("moved [toInRejects,to]:    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;

                                                                    }
                                                                        }
                                                                            }
                                                                                break ;
                                                                                pP.bAbort = 1 ;
                                                                                pP.ether.traceF( tinP , T("!exception:  unexpected impotence [POOP,toInRejects,to]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;
                                                                                POOPRqUIET
                                                                                countT rc = POOP ;
                                                                            {
                                                                            else
                                                                            }
                                                                                thirdC::dosSleepWinkIF( tinP , 2 ) ;
                                                                                pP.ether.traceF( tinP , T("!exception:  could not move file ; will retry until fired [toInRejects,to]:    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;
                                                                                POOPRqUIET
                                                                            {
                                                                            else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_ACCESSdENIED )
                                                                            }
                                                                                break ;
                                                                                bReadOnly = 1 ;
                                                                                pP.ether.traceF( tinP , T("!exception: could not move file out of the way because destination device is write protected [to,from]:    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;
                                                                                POOPRqUIET
                                                                            {
                                                                            else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_WRITEpROTECT )
                                                                            }
                                                                                break ;
                                                                                bDone = 1 ;
                                                                            {
                                                                            if( !POOP )
                                                                            tinP.pEtScratch->diskMoveFileOrDirF( tinP , psttLongInRejects , psttTo , 1 ) ;
                                                                            SCOOPS
                                                                        {
                                                                        IFsCRATCH
                                                                    {
                                                                    while( !etPrime )
                                                                    ZE( boolT , bDone ) ;
                                                                {
                                                                else
                                                                if( F(flagsModeP) & flHEALmODE_NOmOVEoRrEPLACE ) pP.ether.traceF( tinP , T("flHEALmODE_NOmOVEoRrEPLACE is set and the target file exists so i will not move file [toInRejects,to]:    ")+T(psttLongInRejects)+T("    ")+T(psttTo) ) ;

                                                                pP.ether.strReplaceF( tinP , psttLongInRejects , psttTo , pP.tPathArchives , pP.tPathRejects ) ; ___( psttLongInRejects ) ;
                                                                ZE( strokeS* , psttLongInRejects ) ;
                                                            {
                                                            if( bExists )
                                                            ZE( boolT , bReadOnly ) ;
                                                        {
                                                        if( !pP.bAbort )

                                                        }
                                                            }
                                                                pP.bAbort = 1 ;
                                                                pP.ether.traceF( tinP , T("!exception: diskFileExistsF failed FOR psttTo [to,from]:    ")+T(psttTo)+T("    ")+T(psttFrom) ) ;
                                                                POOPRqUIET
                                                            {
                                                            if( POOP )
                                                            bExists = tinP.pEtScratch->diskFileExistsF( tinP , psttTo ) ;

                                                            SCOOPS
                                                        {
                                                        IFsCRATCH
                                                        ZE( boolT , bExists ) ;

                                                        // *********************************************************************************************************************************************************************************************************
                                                        // ****                                   ******************************************************************************************************************************************************************
                                                        // ****  MOVE TARGET FILE OUT OF THE WAY  ******************************************************************************************************************************************************************
                                                        // ****                                   ******************************************************************************************************************************************************************
                                                        // *********************************************************************************************************************************************************************************************************

                                                        //pP.ether.traceF( tinP , T("new      [psttTo,psttFrom]:    ")+TF2((countT)psttTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)psttFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                                        //pP.ether.traceF( tinP , T("copying [idFrom,to,from]:    ")+TF2(idFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttTo)+tb4+T(psttFrom) ) ;

                                                        pP.ether.strMakeF( tinP , LF , psttFrom , (strokeS*)stFrom[ idFrom ] ) ; ___( psttFrom ) ;
                                                        ZE( strokeS* , psttFrom ) ;

                                                        countT idFrom = 1 + ( cDone ++ % cFrom ) ;

                                                        stTo >> psttTo ;
                                                        ZE( strokeS* , psttTo ) ;
                                                    {
                                                    while( !pP.bAbort && stTo )
                                                    ZE( countT , cDone ) ;
                                                    countT cFrom = stFrom ;

                                                    // *********************************************************************************************************************************************************************************************************
                                                    // ****                                              *******************************************************************************************************************************************************
                                                    // ****  COPY AUTHORITATIVE FILES TO TARGET VOLUMES  *******************************************************************************************************************************************************
                                                    // ****                                              *******************************************************************************************************************************************************
                                                    // *********************************************************************************************************************************************************************************************************
                                                {
                                                if( !pP.bAbort )
                                                pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / d0") ) ;

                                                }
                                                    }
                                                        if( !idSlot ) pP.ether.delF( tinP , psttLong ) ;
                                                        stTo.sinkF( tinP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ;
                                                        ZE( countT , idSlot ) ;
                                                        // //pP.ether.traceF( tinP , T("sinking to stTo 2 [long]:    ")+T(psttLong) ) ;
                                                    {
                                                    else
                                                    if( stFrom( psttLong ) ) pP.ether.delF( tinP , psttLong ) ;

                                                    pP.ether.strMakeF( tinP , LF , psttLong , T(psttPathToYear)+tShortP ) ; ___( psttLong ) ;
                                                    ZE( strokeS* , psttLong ) ;

                                                    const strokeS* psttPathToYear = pP.pzpsttPathToYear[ offi ] ;
                                                {
                                                for( countT offi = 0 ; !pP.bAbort && offi < pP.cPathsToYear ; offi ++ )

                                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / e0") ) ;

                                                // *********************************************************************************************************************************************************************************************************
                                                // ****                                            *********************************************************************************************************************************************************
                                                // ****  LOAD stTo WITH LONG FILE NAMES NOT FOUND  *********************************************************************************************************************************************************
                                                // ****                                            *********************************************************************************************************************************************************
                                                // *********************************************************************************************************************************************************************************************************

                                                while( !pP.bAbort && ~hStUnique ) ;
                                                }
                                                    }
                                                        while( ~hStkInner ) ;
                                                        }
                                                            }
                                                                if( !idSlot ) pP.ether.delF( tinP , psttLong ) ;
                                                                }
                                                                    stTo.sinkF( tinP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                                    // //pP.ether.traceF( tinP , pP.tIndent3+T("sunk into stTo [cPlatesBefore,long]:    ")+TF2(stTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                                {
                                                                else
                                                                }
                                                                    stFrom.sinkF( tinP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                                    // //pP.ether.traceF( tinP , pP.tIndent3+T("sunk into stFrom [cPlatesBefore,long]:    ")+TF2(stFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                                {
                                                                if( bYoungestUse && bWinner )
                                                                ZE( countT , idSlot ) ;

                                                                pP.ether.strMakeF( tinP , LF , psttLong , T(pP.pzpsttPathToYear[pfmInner->idSlotPathToYear-1])+tShortP ) ; ___( psttLong ) ;
                                                                ZE( strokeS* , psttLong ) ;
                                                            {
                                                            if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) )

                                                            }
                                                                }
                                                                    break ;
                                                                    bMatchImage = 0 ;
                                                                {
                                                                if( picUnique[ offc ] - picInner[ offc ] )
                                                            {
                                                            for( countT offc = 0 ; offc < pP.cResultStructsNeeded ; offc ++ )
                                                            boolT bMatchImage = 1 ;

                                                            //picInner->traceF( tinP , pP.tIndent3+T("inner :    ") ) ;
                                                            fileMetaS*     pfmInner = (fileMetaS*)( picInner + pP.cResultStructsNeeded ) ;
                                                            imageCompareS* picInner  = (imageCompareS*)&stMeta.upF( tinP , hStkInner ) ;
                                                        {
                                                        do
                                                        handleC hStkInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                    {

                                                    //pfmUnique->traceF( tinP , pP.st O ldPathToYear , T(bYoungestUse?"reporting tallies (youngestNotAlone):    ":"reporting tallies            (other):    ") ) ;

                                                    // //pP.ether.traceF( tinP , pP.tIndent2+T("[bYoungestUse,bWinner,cVotes]:    ")+TF2(bYoungestUse,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bWinner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pfmUnique->cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    boolT bWinner      = pfmUnique->cVotes         == cVotesMaxUse      ;
                                                    boolT bYoungestUse = pfmUnique->timeModRounded == timeModRoundedUse ;

                                                    //for( countT offc = 0 ; offc < pP.cResultStructsNeeded ; offc ++ ) picUnique[ offc ].traceF( tinP , pP.tIndent3+T("reporting tallies:    ") ) ;

                                                    //picUnique->traceF( tinP , pP.tIndent2+T("unique:    ") ) ;
                                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hStUnique ) ;
                                                {
                                                do
                                                handleC hStUnique( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                                stackC stTo(     tinP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                                                stackC stFrom(   tinP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

                                                // *********************************************************************************************************************************************************************************************************
                                                // ****                                               ******************************************************************************************************************************************************
                                                // ****  LOAD stTo stFrom WITH LONG FILE NAMES FOUND  ******************************************************************************************************************************************************
                                                // ****                                               ******************************************************************************************************************************************************
                                                // *********************************************************************************************************************************************************************************************************
                                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / f0") ) ;
                                            {
                                            else
                                            }
                                                }
                                                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 01") ) ;
                                                    while( !pP.bAbort && ~hStkInner ) ;
                                                    }
                                                        pP.ether.delF( tinP , psttLongFrom ) ;
                                                        pP.ether.delF( tinP , psttLongTo   ) ;

                                                        }
                                                            }
                                                                if( !etPrime ) pP.bAbort = 1 ;
                                                                pP.ether.traceF( tinP , pP.tIndent3+T("!exception:  i never could move file and either i am now fired or i encountered an unexpected impotence, so will purge the pending jobs and fire myself [to,from]:    ")+T(psttLongTo)+T("    ")+T(psttLongFrom) ) ;
                                                            {
                                                            else
                                                            if( bDone ) pP.ether.traceF( tinP , T("moved [to,from]:    ")+T(psttLongTo)+T("    ")+T(psttLongFrom) ) ;

                                                            }

                                                                }
                                                                    }
                                                                        break ;
                                                                        pP.ether.traceF( tinP , pP.tIndent3+T("!exception:  unexpected impotence [POOP,to,from]:    ")+TF2(POOP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttLongTo)+T("    ")+T(psttLongFrom) ) ;
                                                                        POOPRqUIET
                                                                    {
                                                                    else
                                                                    }
                                                                        thirdC::dosSleepWinkIF( tinP , 2 ) ;
                                                                        pP.ether.traceF( tinP , pP.tIndent3+T("!exception:  could not move file ; will retry until fired [to,from]:    ")+T(psttLongTo)+T("    ")+T(psttLongFrom) ) ;
                                                                        POOPRqUIET
                                                                    {
                                                                    else if( POOP == ifcIDiMPOTENCEbASEeRRORcODE_ACCESSdENIED )
                                                                    }
                                                                        break ;
                                                                        bDone = 1 ;
                                                                    {
                                                                    if( !POOP )
                                                                    tinP.pEtScratch->diskMoveFileOrDirF( tinP , psttLongTo , psttLongFrom , 1 ) ;
                                                                    SCOOPS
                                                                {
                                                                IFsCRATCH
                                                            {
                                                            while( !etPrime )
                                                            ZE( boolT , bDone ) ;
                                                        {

                                                        pP.ether.strReplaceF( tinP , psttLongTo , psttLongFrom , pP.tPathArchives , !bLonely ? pP.tPathRejects : pP.tPathLonely ) ; ___( psttLongTo ) ;
                                                        ZE( strokeS* , psttLongTo ) ;
                                                        //P:PERSONALITY: LONELY FILES (ONLY 1 COPY) ARE MOVED OUT OF ARCHIVE INTO A "LONELY" DIRECTORY

                                                        pP.ether.strMakeF( tinP , LF , psttLongFrom , T(pP.pzpsttPathToYear[pfmInner->idSlotPathToYear-1])+tShortP ) ; ___( psttLongFrom ) ;
                                                        ZE( strokeS* , psttLongFrom ) ;

                                                        fileMetaS*     pfmInner = (fileMetaS*)( picInner + pP.cResultStructsNeeded ) ;
                                                        imageCompareS* picInner  = (imageCompareS*)&stMeta.upF( tinP , hStkInner ) ;
                                                    {
                                                    do
                                                    handleC hStkInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                                    pP.ether.traceF( tinP , pP.tIndent1+T("no, or too many (more than 1), winners (authoritative copies) so i will move all copies [bLonely,file]:    ")+TF2(bLonely,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;
                                                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 11") ) ;

                                                    // *********************************************************************************************************************************************************************************************************
                                                    // ****                                         ************************************************************************************************************************************************************
                                                    // ****  NO UNIQUE WINNER SO REJECT ALL COPIES  ************************************************************************************************************************************************************
                                                    // ****                                         ************************************************************************************************************************************************************
                                                    // *********************************************************************************************************************************************************************************************************
                                                {
                                                else
                                                if( F(flagsModeP) & flHEALmODE_NOmOVEoRrEPLACE ) pP.ether.traceF( tinP , pP.tIndent1+T("no, or too many (more than 1), winners (authoritative copies), but because flHEALmODE_NOmOVEoRrEPLACE is set i will NOT move all copies [bLonely,file]:    ")+TF2(bLonely,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;

                                                boolT bLonely = cCopies <= 1 ;
                                            {
                                            if( !cWinners || cWinners > 1 )
                                        {
                                        if( !pP.bAbort )
                                        pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                        //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 21") ) ;

                                        }
                                            while( !pP.bAbort && ~hSt ) ;
                                            }
                                                cWinners ++ ;
                                                )
                                                    pfmUnique->cVotes == cVotesMaxUse
                                                    &&
                                                    timeModRoundedUse == pfmUnique->timeModRounded
                                                (
                                                if

                                                //picUnique->traceF( tinP , pP.tIndent2+T("unique:    ") ) ;
                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                                            {
                                            do
                                            handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        if( !pP.bAbort && cVotesMaxUse )

                                        ZE( countT , cWinners ) ;
                                        //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 31") ) ;

                                        // RULE; TO WIN, A SLOT MUST HAVE A "YOUNGEST NOT ALONE" AGE AND BE "NOT ALONE" AND HAVE THE MAXIMUM VOTES FOR SLOTS YOUNGEST AND NOT ALONE
                                        //P:PERSONALITY: RULES FOR "WINNING": A stRecUnique SLOT "WINNING" MEANS THAT THE SLOT IS DEEMED TO BE AN AUTHORITATIVE IMAGE FOR THE FILE

                                        // *********************************************************************************************************************************************************************************************************
                                        // ****                  ***********************************************************************************************************************************************************************************
                                        // ****  TALLY cWinners  ***********************************************************************************************************************************************************************************
                                        // ****                  ***********************************************************************************************************************************************************************************
                                        // *********************************************************************************************************************************************************************************************************

                                        ;
                                            : cVotesMaxYoungestNotAlone
                                            ? cVotesMaxYoungest
                                        countT& cVotesMaxUse = F(flagsModeP) & flHEALmODE_LONELYiSoK

                                        ;
                                            : timeModRoundedYoungestNotAlone
                                            ? timeModRoundedYoungest
                                        countT& timeModRoundedUse = F(flagsModeP) & flHEALmODE_LONELYiSoK

                                        }
                                            while( !pP.bAbort && ~hSt ) ;
                                            }
                                                }
                                                    if( pfmUnique->cVotes > 1 && cVotesMaxYoungestNotAlone < pfmUnique->cVotes ) cVotesMaxYoungestNotAlone = pfmUnique->cVotes ;
                                                {
                                                if( timeModRoundedYoungestNotAlone == pfmUnique->timeModRounded )

                                                }
                                                    if(                          cVotesMaxYoungest         < pfmUnique->cVotes ) cVotesMaxYoungest         = pfmUnique->cVotes ;
                                                {
                                                if( timeModRoundedYoungest == pfmUnique->timeModRounded )

                                                //picUnique->traceF( tinP , pP.tIndent2+T("unique:    ") ) ;
                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                                            {
                                            do
                                            handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        if( !pP.bAbort && ( timeModRoundedYoungestNotAlone || F(flagsModeP) & flHEALmODE_LONELYiSoK ) )        // IF ALL ARE ALONE THEN THERE WILL BE NO WINNER (UNLESS flHEALmODE_LONELYiSoK)
                                        ZE( countT , cVotesMaxYoungestNotAlone ) ;
                                        ZE( countT , cVotesMaxYoungest         ) ;
                                        //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 41") ) ;

                                        // *********************************************************************************************************************************************************************************************************
                                        // ****                                                          *******************************************************************************************************************************************
                                        // ****  ACCUMULATE cVotesMaxYoungest cVotesMaxYoungestNotAlone  *******************************************************************************************************************************************
                                        // ****                                                          *******************************************************************************************************************************************
                                        // *********************************************************************************************************************************************************************************************************

                                        }
                                            while( !pP.bAbort && ~hSt ) ;
                                            }
                                                if( pfmUnique->cVotes > 1 && timeModRoundedYoungestNotAlone < pfmUnique->timeModRounded ) timeModRoundedYoungestNotAlone = pfmUnique->timeModRounded ;

                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                                            {
                                            do
                                            handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        if( !pP.bAbort )
                                        ZE( countT , timeModRoundedYoungestNotAlone ) ;
                                        // SET timeModRoundedYoungestNotAlone

                                        // *********************************************************************************************************************************************************************************************************
                                        // ****                                             ********************************************************************************************************************************************************
                                        // ****  ACCUMULATE timeModRoundedYoungestNotAlone  ********************************************************************************************************************************************************
                                        // ****                                             ********************************************************************************************************************************************************
                                        // *********************************************************************************************************************************************************************************************************
                                        //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 51") ) ;

                                        }
                                            while( !pP.bAbort && ~hSt ) ;
                                            }
                                                while( ~hStkInner ) ;
                                                }
                                                    }
                                                        // //pP.ether.traceF( tinP , pP.tIndent3+T("    [cVotes.after]:    ")+TF2(pfmUnique->cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        pfmUnique->cVotes ++ ;
                                                    {
                                                    if( bMatchImage && !bFileMetaDiffer )

                                                    // //pP.ether.traceF( tinP , pP.tIndent3+T(bFileMetaDiffer?"    file meta differ":"    file meta are the same") ) ;
                                                    boolT bFileMetaDiffer = *pfmUnique - *(fileMetaS*)pfmInner ;

                                                    // //pP.ether.traceF( tinP , pP.tIndent3+T(bMatchImage?"    image matches":"    image does not match") ) ;
                                                    }
                                                        }
                                                            break ;
                                                            bMatchImage = 0 ;
                                                        {
                                                        if( picUnique[ offc ] - picInner[ offc ] )
                                                    {
                                                    for( countT offc = 0 ; offc < pP.cResultStructsNeeded ; offc ++ )
                                                    boolT bMatchImage = 1 ;

                                                    //}
                                                    //    pfmInner->traceF( tinP , pP.st O ldPathToYear , pP.tIndent3+T("inner : ") ) ;
                                                    //    picInner->traceF( tinP , pP.tIndent3+T("inner :    ") ) ;
                                                    //{
                                                    //if( bChatter )
                                                    fileMetaS*     pfmInner = (fileMetaS*)( picInner + pP.cResultStructsNeeded ) ;
                                                    imageCompareS* picInner  = (imageCompareS*)&stMeta.upF( tinP , hStkInner ) ;
                                                {
                                                do
                                                handleC hStkInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                                if( timeModRoundedYoungest < pfmUnique->timeModRounded ) timeModRoundedYoungest = pfmUnique->timeModRounded ;

                                                //}
                                                //    pfmUnique->traceF( tinP , pP.st O ldPathToYear , pP.tIndent2+T("unique: ") ) ;
                                                //    picUnique->traceF( tinP , pP.tIndent2+T("unique:    ") ) ;
                                                //{
                                                //if( bChatter )
                                                fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + pP.cResultStructsNeeded ) ;
                                                imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinP , hSt ) ;
                                                // //pP.ether.traceF( tinP , pP.tIndent2+T("tallying votes for a particular image") ) ;
                                            {
                                            do
                                            handleC hSt( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        ZE( countT , timeModRoundedYoungest ) ;
                                        // TALLY cVotes AND SET timeModRoundedYoungest

                                        // *********************************************************************************************************************************************************************************************************
                                        // ****                                                   **************************************************************************************************************************************************
                                        // ****  ACCUMULATE timeModRoundedYoungest ; TALLY VOTES  **************************************************************************************************************************************************
                                        // ****                                                   **************************************************************************************************************************************************
                                        // *********************************************************************************************************************************************************************************************************
                                        //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 61") ) ;

                                        }
                                            bChatter = 1 ;
                                            //pP.ether.traceF( tinP , pP.tIndent1+T("lengths or times or images differ [tShort]:    ")+tShortP ) ;
                                        {
                                        if( stRecUnique > 1 )
                                        ZE( boolT , bChatter ) ;
                                    {
                                    else                            // EVEN IF THERE IS ONLY WO PLATE, THERE IS STILL WORK TO DO BECAUSE THE FILE MIGHT NEED TO BE COPIED TO DESTINATIONS THAT DON'T HAVE IT
                                    }
                                        pP.bAbort = 1 ;
                                        pP.ether.traceF( tinP , T("!exception: stRecUnique is empty") ) ;
                                    {
                                    if( !stRecUnique ) //SHOULD  BE IMPOSSIBLE

                                    while( ~hStkOuter ) ;
                                    do stRecUnique.sinkF( tinP , countTC() , (byteT*)&stMeta.upF( tinP , hStkOuter ) , flSTACKsINK_UNIQUE , subtractFileMetaF ) ;
                                    stackC stRecUnique( tinP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , pP.cPathsToYear * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ;
                                    handleC hStkOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                *************************************************************************************************************************************************************************************
                                    // ****  BEGIN:  HEAL  *************************************************************************************************************************************************************************************
                                    // ****                *************************************************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************
                                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 71") ) ;
                                {
                                if( !pP.bAbort )
                                pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 81") ) ;
                            {
                            if( !etPrime && cCopies )
                            // //pP.ether.traceF( tinP , pP.tIndent1+T("[cFound,file]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;

                            // PHASE 4: COPY TO ALL ARCHIVE CONTAINERS THAT DO NOT HAVE A COPY OF THIS FILE NAME
                            // PHASE 3: OVERWRITE ALL COPIES THAT DO NOT MATCH THIS UNIQUE META
                            // PHASE 2: IS THIS UNIQUE META VERIFIED (cVotes > 1)?
                            // PHASE 1: IDENTIFY THE UNIQUE META WITH THE LATEST FILE DATE
                            // HEALING ACTION HAS PHASES
                            // COMPARE AND FILE META FOR THIS FILE ARE SET AND READY FOR ANALYSIS AND HEALING ACTION
                            // THESE COMMENTS ARE OBSOLETED BY ACTUAL CODE WHICH CONTRADICTS THEM
                        {
                        if( !pP.bAbort )

                        while( !etPrime && !pP.bAbort && ~hStkOuter ) ;
                        }
                            //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 91") ) ;
                            // *********************************************************************************************************************************************************************************************************
                            // ****                                      ***************************************************************************************************************************************************************
                            // ****  END:    FOR EACH COPY OF THIS FILE  ***************************************************************************************************************************************************************
                            // ****                                      ***************************************************************************************************************************************************************
                            // *********************************************************************************************************************************************************************************************************

                            pP.ether.delF( tinP ,            pcBitsShiftLeftHeInMine ) ;
                            pP.ether.delF( tinP ,            pcBitsShiftLeftMeInHis  ) ;
                            pP.ether.delF( tinP , *(byteT**)&ppIdResultHeInMine      ) ;
                            pP.ether.delF( tinP , *(byteT**)&ppIdResultMeInHis       ) ;
                            pP.ether.delF( tinP ,            pcbwInner               ) ;
                            pP.ether.delF( tinP , *(byteT**)&ppbwInner               ) ;

                            }
                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / a1") ) ;
                                deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / b1") ) ;

                                }
                                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / c1") ) ;
                                    }
                                        }
                                            while( ~hStkEqual ) ;
                                            }
                                                //picHe->traceF( tinP , pP.tIndent3+T("he is equal (after) :") ) ;
                                                pP.ether.memCopyF( tinP , (byteT*)picHe , (byteT*)picOuter , sizeof( imageCompareS ) * pP.cResultStructsNeeded ) ;
                                                //picHe->traceF( tinP , pP.tIndent3+T("he is equal (before):") ) ;
                                                imageCompareS* picHe = (imageCompareS*)&stMeta[ cMeta - idHeIsEqual + 1 ] ;

                                                // //pP.ether.traceF( tinP , pP.tIndent3+T("[heIsEqual]:    ")+TF2(idHeIsEqual,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                countT idHeIsEqual = stHeIsEqual.downF( tinP , hStkEqual ) ;
                                            {
                                            do
                                            handleC hStkEqual( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                        {
                                        if( !pP.bAbort )

                                        }
                                            // #endif
                                            //     // //pP.ether.traceF( tinP , pP.tIndent3+T("[idInner,resultHeInMine]:    ")+TF2(1+offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tResultHeInMine ) ;
                                            //     // 
                                            //     // }
                                            //     //     case BITSrESULT_ALLbITS  : { tResultHeInMine = T("allBits")  ; break ; }
                                            //     //     case BITSrESULT_EQUAL    : { tResultHeInMine = T("equal")    ; break ; }
                                            //     //     case BITSrESULT_NOTeQUAL : { tResultHeInMine = T("notEqual") ; break ; }
                                            //     //     case BITSrESULT_UNKNOWN  : { tResultHeInMine = T("unknown")  ; break ; }
                                            //     // {
                                            //     // switch( resultHeInMine )
                                            //     // TN( tResultHeInMine , "" ) ;
                                            // #if defined( IFC tESTING )

                                            }
                                        
                                                if( !ids ) { BLAMMO }
                                                stHeIsEqual.sinkF( tinP , ids , 1 + offi , flSTACKsINK_UNIQUE ) ;
                                                ZE( countT , ids ) ;
                                            {
                                            if( resultHeInMine == BITSrESULT_EQUAL )
                                        
                                            countT  resultHeInMine         = ( bitsResultHeInMine & maskHeInMine ) >> cBitsShiftLeftHeInMine ;
                                            countT  maskHeInMine           = BITSrESULT_ALLbITS << cBitsShiftLeftHeInMine ;
                                            countT  cBitsShiftLeftHeInMine =         ( offi % cResultsPerStruct ) << 1 ;
                                            countT& bitsResultHeInMine     = picOuter[ offi / cResultsPerStruct ].bitsResult ;
                                        {
                                        for( countT offi = 0 ; !pP.bAbort && offi < cMeta ; offi ++ )
                                        countT cMeta = stMeta ;
                                        stackC stHeIsEqual( tinP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE ) ;

                                        //picOuter->traceF( tinP , pP.tIndent2+T("outer (mine):") ) ;

                                        // //pP.ether.traceF( tinP , pP.tIndent2+T("transitivity: copying my results to other rows [idSlotPathToYearOuter]:    ")+TF2(idSlotPathToYearOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    {
                                    if( !pP.bAbort )
                                    //SET OTHER RESULTS TO EXPLOIT TRANSITIVITY (A COPY THAT IS EQUAL TO ME RECEIVES ALL OF MY RESULTS)
                                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / d1") ) ;

                                    //while( ~hStkInner ) ;
                                    //}
                                    //    picInner->traceF( tinP , T("after comparing inners with [tLongOuter]:    ")+tLongOuter ) ;
                                    //    imageCompareS* picInner = (imageCompareS*)&stMeta.upF( tinP , hStkInner ) ;
                                    //{
                                    //do
                                    //handleC hStkInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                    }
                                        // //pP.ether.traceF( tinP , pP.tIndent3+T(pEqual[offo]?"        set other and myself to BITSrESULT_EQUAL because images match [offo]:    ":"        set other and myself to BITSrESULT_NOTeQUAL because images differ [offo]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                        }
                                            // //pP.ether.traceF( tinP , pP.tIndent3+T("after  [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                            *ppIdResultMeInHis[  offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftMeInHis[  offo ] ;
                                            *ppIdResultHeInMine[ offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftHeInMine[ offo ] ;
                                            // //pP.ether.traceF( tinP , pP.tIndent3+T("before [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                        {
                                        else
                                        }
                                            *ppIdResultMeInHis[  offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftMeInHis[  offo ] ;
                                            *ppIdResultHeInMine[ offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftHeInMine[ offo ] ;
                                        {
                                        if( pEqual[ offo ] )
                                    {
                                    for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ )
                                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / e1") ) ;
                                {
                                if( !pP.bAbort )

                                //if( pcz_bUseWorkers ) *pcz_bUseWorkers = 0 ;

                                THREADmODE2rESTORE
                                }
                                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / f1") ) ;
                                    //pP.ether.delF( tinP , *(byteT**)&pfwsOuter ) ;
                                    // //pP.ether.traceF( tinP , pP.tIndent2+T("del [pfwsOuter]:    ")+TF3((countT)pfwsOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;

                                    }
                                        }
                                            }
                                                break ;
                                                deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                                pP.bAbort = 1 ;
                                                pP.ether.traceF( tinP , pP.tIndent2+T("!exception: could not dt pfwsOuter [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                                                POOPRqUIET
                                            {
                                            if( POOP )
                                            DEL( pfwsOuter ) ;
                                            SCOOPS
                                        {

                                        }
                                            break ;
                                            deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                            pP.bAbort = 1 ;
                                            pP.ether.traceF( tinP , pP.tIndent2+T("!exception [cbUsed,cbDone]:    ")+TT(pcbUsed[0],pcbUsed[1])+tb4+TT(pcbDone[0],pcbDone[1])+tb4+tLongOuter ) ;
                                            countT* pcbDone = (countT*)&cbDone ;
                                            countT* pcbUsed = (countT*)&pfmOuter->cbUsed ;
                                        {
                                        if( cbDone != pfmOuter->cbUsed ) //SHOULD BE IMPOSSIBLE
                                    {
                                    if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )

                                    if( pP.bAbort ) break ;
                                    if( etPrime   ) pP.bAbort = 1 ;
                                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 02") ) ;

                                    }
                                        //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 12") ) ;
                                        cbDone += cbwOuter ;

                                        if( pP.bAbort ) break ;

                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>

                                        //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 22: waited  for all pending compare jobs to complete for this file window") ) ;
                                        }
                                            ++ s ; thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) , 0 , flYIELD_ANYtHREADdESIRE ) ;
                                            //++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
                                            //pP.ether.traceF( tinP , T("waiting for pending jobs [cJobsPendingCompare]:    ")+TF2(cJobsPendingCompare,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        {
                                        while( cJobsPendingCompare )
                                        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                                        //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 32: waiting for all pending compare jobs to complete for this file window") ) ;

                                        }
                                            }
                                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 42") ) ;
                                                //pcbwInner[ offi ] = 0 ;  // TELLS TO GET ANOTHER WINDOW
                                                //ppbwInner[ offi ] = 0 ;
                                                //20230623@0922: CONJ: THIS CODE IS OBSOLETE AND HAS NO EFFECT

                                                }
                                                    break ;
                                                    deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                                {
                                                if( pP.bAbort )

                                                }
                                                    }
                                                        }
                                                            pP.stJobCompare.sinkF( tinP , countTC() , (countT)pJob , flSTACKsINK_null , subtract_jobCompareOoImagesS_F , 0 ) ;                                                    
                                                            jobCompareOoImagesS* pJob = new( 0 , tinP , LF ) jobCompareOoImagesS( tinP , pP.ether , cJobsPendingCompare , pEqual[ offi ] , pbwOuter , ppbwInner[ offi ] , cbwOuter , tLongOuter , T(pfwsInner?pfwsInner[offi]:(const strokeS*)0) , cbUsedMax04 ) ; ___( pJob ) ;

                                                            }
                                                                }
                                                                    }
                                                                        ++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
                                                                        pP.ether.traceF( tinP , T("napping: a large file is being processed and i am even larger [cbUsedMax04,cbPendingMax04]:    ")+TF3((countT)cbUsedMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tDot+TF3(((countT*)&cbUsedMax04)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF3((countT)cbPendingMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tDot+TF3(((countT*)&cbPendingMax04)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                                                                        if( !bNapped ) bNapped = 1 ;
                                                                    {
                                                                    else
                                                                    }
                                                                        break ;
                                                                        if( bNapped ) pP.ether.traceF( tinP , T("no longer napping: a large file was being processed and i was even larger [cbUsedMax04,cbPendingMax04]:    ")+TF3((countT)cbUsedMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tDot+TF3(((countT*)&cbUsedMax04)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tb4+TF3((countT)cbPendingMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+tDot+TF3(((countT*)&cbPendingMax04)[1],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                                                                    {
                                                                    if( !cbPendingMax04 || cbPendingMax04 > cbUsedMax04 )

                                                                    pP.stJobCompare.ungrabF( tinP ) ;
                                                                    }
                                                                        cbPendingMax04 = topJob.cbUsedMax04 ;
                                                                        jobCompareOoImagesS& topJob = *(jobCompareOoImagesS*)pP.stJobCompare[ 1 ] ;
                                                                    {
                                                                    if( pP.stJobCompare )
                                                                    pP.stJobCompare.grabF( tinP , TAG( TAGiDnULL ) ) ;
                                                                    ZE( count04T , cbPendingMax04 ) ;
                                                                {
                                                                while( pP.stJobCompare )
                                                                ZE( boolT , bNapped ) ;
                                                            {
                                                            // IF A VERY LARGE FILE IS BEING PROCESSED AND I AM EVEN LARGER, WAIT BEFORE PUSHING
                                                        {
                                                        else
                                                        }
                                                            compareOoImagesF( tinP , etPrimeP , pP.ether , pP.bAbort , pP.cPause , pEqual[ offi ] , flagsModeP , pbwOuter , ppbwInner[ offi ] , cbwOuter /*, tLongOuter , T(pfwsInner?pfwsInner[offi]:(const strokeS*)0) , pP.tIndent3*/ ) ;
                                                            if( !pEqual[ offi ] ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE BECAUSE THIS FILE IS BEING COMPARED SYNCHRONOUSLY
                                                        {
                                                        if( !bLargeFile )

                                                        }
                                                            // //pP.ether.traceF( tinP , pP.tIndent3+T("comparing oo images [cWindows,idWindow,perTuck,offi]:    ")+TF2((countT)cWindows,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tPerTuck+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                            countT perTuck = (countT)( ( idWindow << 8 ) / cWindows ) ;
                                                        {
                                                        if( bChatter )
                                                    {
                                                    if( pEqual[ offi ] )    // DON'T COMPARE BYTES IF ALREADY KNOW THAT A PREVIOUS WINDOW DIDN'T MATCH
                                                {
                                                if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )

                                                }
                                                    break ;
                                                    deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                                {
                                                if( pP.bAbort )
                                                pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;

                                                // *********************************************************************************************************************************************************************************************************
                                                // ****                                                      ***********************************************************************************************************************************************
                                                // ****  COMPARE WINDOWS BYTE BY BYTE TO SET pEqual[ offi ]  ***********************************************************************************************************************************************
                                                // ****                                                      ***********************************************************************************************************************************************
                                                // *********************************************************************************************************************************************************************************************************
                                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 52") ) ;
                                            {
                                            else
                                            }
                                                }
                                                    break ;
                                                    // //pP.ether.traceF( tinP , pP.tIndent3+T("done inspecting images [cInnerImagesToInspect,cImagesInspected,cWindows,idWindow]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cImagesInspected,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)cWindows,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( ++ cImagesInspected == cInnerImagesToInspect )
                                            {
                                            if( !pbwOuter || !cbwOuter )

                                            }
                                                }
                                                    break ;
                                                    deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                                    pP.bAbort = 1 ;
                                                    pP.ether.traceF( tinP , pP.tIndent3+T("!exception: preliminary checks (before byte by byte comparison) failed ; aborting [tLongOuter,tLongInner]:    ")+tLongOuter+tb4+T(pfwsInner?pfwsInner[offi]:(const strokeS*)0) ) ;
                                                {
                                                )
                                                      cbwOuter !=   pcbwInner[ offi ]
                                                    ||
                                                    !!cbwOuter != !!pcbwInner[ offi ]
                                                    ||
                                                    !!pbwOuter != !!ppbwInner[ offi ]
                                                (
                                                if
                                            {
                                            if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )

                                            // //pP.ether.traceF( tinP , pP.tIndent3+T("fed this [(countT)ppbwInner[offi],ppbwInner[offi]]:    ")+TF3((countT)ppbwInner[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+T(ppbwInner[offi]) ) ;

                                            // *********************************************************************************************************************************************************************************************************
                                            // ****                            *************************************************************************************************************************************************************************
                                            // ****  ABORT IF LENGTH MISMATCH  *************************************************************************************************************************************************************************
                                            // ****                            *************************************************************************************************************************************************************************
                                            // *********************************************************************************************************************************************************************************************************
                                            //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 62") ) ;

                                            }
                                                }
                                                    }
                                                        break ;
                                                        deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;

                                                        }
                                                            etRock.traceF( tinP , pP.tIndent3+T("!exception: could not get inner file window (not enough memory) ; traced  pool tallies and memory grain report") ) ;
                                                            etRock.traceMemoryGrainRptF( tinP ) ;
                                                            etRock.tracePoolTalliesF( tinP ) ;
                                                            etRock.traceF( tinP , pP.tIndent3+T("!exception: could not get inner file window (not enough memory) ; tracing pool tallies and memory grain report") ) ;
                                                            etherC& etRock = etherC::etRockIF( tinP ) ;
                                                        {
                                                        if( save == ifcIDiMPOTENCEbASEeRRORcODE_NOTeNOUGHmEMORY )

                                                        pP.bAbort = 1 ;
                                                        pP.ether.traceF( tinP , pP.tIndent3+T("!exception:  pfwsInner[ offi ].getF ; aborting [idInner,tLongInner]:    ")+TF2(offi+1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(pfwsInner?pfwsInner[offi]:(const strokeS*)0) ) ;

                                                        POOPRqUIET
                                                        countT save = POOP ;
                                                    {
                                                    if( POOP )

                                                    pfwsInner[ offi ].getF( tinP , ppbwInner[ offi ] , pcbwInner[ offi ] , cbFileWindow ) ;
                                                    pcbwInner[ offi ] = 0 ;
                                                    ppbwInner[ offi ] = 0 ;

                                                    SCOOPS
                                                {
                                                IFsCRATCH
                                            {
                                            if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )

                                            //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 72") ) ;

                                            // //pP.ether.traceF( tinP , pP.tIndent3+T("     inner [idWindow,tLongInner]:    ")+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE)+tb4+T(pfwsInner?pfwsInner[offi]:(const strokeS*)0) ) ;

                                            // *********************************************************************************************************************************************************************************************************
                                            // ****                       ******************************************************************************************************************************************************************************
                                            // ****  GET AN INNER WINDOW  ******************************************************************************************************************************************************************************
                                            // ****                       ******************************************************************************************************************************************************************************
                                            // *********************************************************************************************************************************************************************************************************
                                        {
                                        for( countT offi = 0 ; !pP.bAbort && offi < cInnerImagesToInspect ; offi ++ )
                                        ZE( countT , cJobsPendingCompare ) ;
                                        //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 82: process each inner window") ) ;

                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>
                                        // <||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||><||>

                                        }
                                            }
                                                }
                                                    break ;
                                                    deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;

                                                    }
                                                        etRock.traceF( tinP , pP.tIndent2+T("!exception: could not get outer file window (not enough memory) ; traced  pool tallies and memory grain report") ) ;
                                                        etRock.traceMemoryGrainRptF( tinP ) ;
                                                        etRock.tracePoolTalliesF( tinP ) ;
                                                        etRock.traceF( tinP , pP.tIndent2+T("!exception: could not get outer file window (not enough memory) ; tracing pool tallies and memory grain report") ) ;
                                                        etherC& etRock = etherC::etRockIF( tinP ) ;
                                                    {
                                                    if( save == ifcIDiMPOTENCEbASEeRRORcODE_NOTeNOUGHmEMORY )

                                                    pP.bAbort = 1 ;
                                                    pP.ether.traceF( tinP , pP.tIndent2+T("!exception:  pfwsOuter->getF ; aborting [tLongOuter]:    ")+T(pfwsOuter?*pfwsOuter:(const strokeS*)0) ) ;

                                                    POOPRqUIET
                                                    countT save = POOP ;
                                                {
                                                if( POOP )
                                                pfwsOuter->getF( tinP , pbwOuter , cbwOuter , cbFileWindow ) ;
                                                SCOOPS
                                            {
                                            IFsCRATCH
                                        {
                                        if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )
                                        ZE( countT , cbwOuter ) ;
                                        ZE( byteT* , pbwOuter ) ;

                                        //TN( tLikeInner , "///ideafarm/tmp/debug.inner." ) ; tLikeInner += TF3((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot ;
                                        //TN( tLikeOuter , "///ideafarm/tmp/debug.outer." ) ; tLikeOuter += TF3((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;

                                        // //pP.ether.traceF( tinP , pP.tIndent2+T("outer      [idWindow,tLongOuter]:    ")+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE)+tb4+T(pfwsOuter?*pfwsOuter:(const strokeS*)0) ) ;

                                        }
                                            }
                                                ++ s ; thirdC::osThreadYieldIF( tinP , TAG( TAGiDnULL ) , 0 , flYIELD_ANYtHREADdESIRE ) ;
                                                if( !( idIn % TOCK ) ) pP.ether.traceF( tinP , T("napping: too many pending compare jobs [idIn]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                countT idIn = 1 + incv02AM( idInLath ) ;
                                            {
                                            while( pP.stJobCompare >= pP.cPathsToYear )
                                            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                                            static countT idInLath ;
                                        {
                                        if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )

                                        //if( cWindowsMax > 1/*( TUCK >> 4 )*/ ) pP.ether.traceF( tinP , T("processing window of large file [cWindowsMax,idWindow,tShortP]:  ")+TF2(cWindowsMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;

                                        //}
                                        //    pP.ether.traceF( tinP , T("processing window [idName,cInnerImagesToInspect,cImagesInspected,cWindowsMax,idWindow,%,tShort]:  ")+TF2(idNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF3(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2)+tb4+TF3(cImagesInspected,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,2)+tb4+TF3(cWindowsMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,4)+tb4+TF3((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,4)+tb4+TF3(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,3)+tPerTuck+tb4+tShortP ) ;
                                        //    countT perTuck = (countT)( ( idWindow << 8 ) / cWindowsMax ) ;
                                        //{            
                                        //if( !( idWindow % ( TUCK >> 4 ) ) )

                                        idWindow ++ ;

                                        // *********************************************************************************************************************************************************************************************************
                                        // ****                       ******************************************************************************************************************************************************************************
                                        // ****  GET AN OUTER WINDOW  ******************************************************************************************************************************************************************************
                                        // ****                       ******************************************************************************************************************************************************************************
                                        // *********************************************************************************************************************************************************************************************************
                                        //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 92: get an outer window") ) ;

                                        }
                                            break ;
                                            deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                        {
                                        if( pP.bAbort )
                                        pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                    {
                                    while( !etPrime && cImagesInspected < cInnerImagesToInspect )
                                    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
                                    ZE( count04T , idWindow ) ;
                                    ZE( boolT , cImagesInspected ) ;
                                    ZE( count04T , cbDone ) ;
                                    const count04T cWindows = 1 + pfmOuter->cbUsed / cbFileWindow ;
                                    const boolT    bChatter =     pfmOuter->cbUsed > cbFileWindow ;

                                    // //pP.ether.traceF( tinP , pP.tIndent2+T("inspecting images [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;

                                    }
                                        }
                                            }
                                                break ;
                                                pP.bAbort = 1 ;
                                                deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                                DEL( pfwsOuter ) ;
                                                pP.ether.traceF( tinP , pP.tIndent2+T("!exception: could not ct pfwsOuter [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                                                POOPRqUIET
                                            {
                                            if( POOP )
                                            new( 0 , tinP , (byteT*)pfwsOuter , sizeof( fileWindowsC ) ) fileWindowsC( tinP , *tinP.pEtScratch , tLongOuter ) ;
                                            SCOOPS
                                        {

                                        // //pP.ether.traceF( tinP , pP.tIndent2+T("new [pfwsOuter]:    ")+TF3((countT)pfwsOuter,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                                        pP.ether.newF( tinP , LF , *(byteT**)&pfwsOuter , sizeof( fileWindowsC ) ) ; ___( pfwsOuter ) ;
                                    {
                                    if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )
                                    ZE( fileWindowsC* , pfwsOuter ) ;

                                    // *********************************************************************************************************************************************************************************************************
                                    // ****                                  *******************************************************************************************************************************************************************
                                    // ****  CT OUTER fileWindowsC INSTANCE  *******************************************************************************************************************************************************************
                                    // ****                                  *******************************************************************************************************************************************************************
                                    // *********************************************************************************************************************************************************************************************************
                                {
                                IFsCRATCH
                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / a2") ) ;

                                }
                                    }
                                        if( pP.bAbort ) break ;

                                        }
                                            pP.ether.delF( tinP , psttLongInner ) ;

                                            }
                                                }
                                                    break ;
                                                    pP.bAbort = 1 ;
                                                    deleteEqualArrayFwsInnerArrayF( tinP , pP.ether , pEqual , pfwsInner , cInnerImagesToInspect ) ;
                                                    DELzOMBIE( pDoomed ) ;
                                                    fileWindowsC* pDoomed = &pfwsInner[ offi ] ;
                                                    pP.ether.traceF( tinP , pP.tIndent3+T("!exception: could not ct a fileWindowsC instance ; aborting [tLongInner]:    ")+T(psttLongInner) ) ;
                                                    POOPRqUIET
                                                {
                                                if( POOP )
                                                new( 0 , tinP , (byteT*)( pfwsInner + offi ) , sizeof( fileWindowsC ) ) fileWindowsC( tinP , *tinP.pEtScratch , psttLongInner ) ;
                                                SCOOPS
                                            {
                                            IFsCRATCH

                                            // //pP.ether.traceF( tinP , pP.tIndent3+T("[cInnerImagesToInspect,idInner,tLongInner]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi+1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLongInner) ) ;
                                            stLongInner >> psttLongInner ;
                                            ZE( strokeS* , psttLongInner ) ;
                                        {
                                        for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )
                                    {
                                    if( pfwsInner )
                                {
                                if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) )
                                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                                for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ ) pEqual[ offi ] = 1 ;
                                pP.ether.newF( tinP , LF , pEqual , cInnerImagesToInspect ) ; ___( pEqual ) ;
                                ZE( boolT* , pEqual ) ;

                                if( !( F(flagsModeP) & flHEALmODE_NOiMAGEcOMPARE ) ) pP.ether.newF( tinP , LF , *(byteT**)&pfwsInner , cInnerImagesToInspect * sizeof( fileWindowsC ) ) ; ___( pfwsInner ) ;
                                ZE( fileWindowsC* , pfwsInner ) ;

                                }
                                    break ;
                                    pP.bAbort = 1 ;                                
                                    pP.ether.traceF( tinP , pP.tIndent3+T("!exception [cInnerImagesToInspect,stLongInner]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+TF2(stLongInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                {
                                if( stLongInner != cInnerImagesToInspect ) //SHOULD BE IMPOSSIBLE

                                // *********************************************************************************************************************************************************************************************************
                                // ****                                                             ****************************************************************************************************************************************
                                // ****  CT INNER fileWindowsC INSTANCES ; INITIALIZE pEqual ARRAY  ****************************************************************************************************************************************
                                // ****                                                             ****************************************************************************************************************************************
                                // *********************************************************************************************************************************************************************************************************

                                //}
                                //    }
                                //        }
                                //            break ;
                                //            pcz_bUseWorkers = &bOk[ offs ] ;
                                //        {
                                //        if( !setIfZeAM( bOk[ offs ] , 1 ) )
                                //    {
                                //    for( countT offs = 0  ; offs < sizeof bOk / sizeof bOk[ 0 ] ; offs ++ )
                                //    static boolT bOk[ 4 ] ;        // ARRAY SIZE IS HARDCODED NUMBER OF YEARS TO ALLOW TO USE WORKERS SIMULTANEOUSLY
                                //{
                                //if( bLargeFile )
                                //ZE( countT* , pcz_bUseWorkers ) ;         // WILL BE SET TO &bOk[ offs ]
                                //20230807@1408: pcz_bUseWorkers IS NOT USED ; CONJ: THIS CODE IS LEFT OVER FROM A CRAFTWORK IDEA THAT I BEGAN TO CODE BUT THEN DID NOT COMPLETE

                                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / b2") ) ;
                            {
                            if( !etPrime && !pP.bAbort && cInnerImagesToInspect )

                            }
                                if( pP.bAbort ) break ;

                                }
                                    // /**/if( bChatterP ) pP.ether.traceF( tinP , T("healing / c2 /                         DDDDDDDD [idPass]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    while( !etPrime && !pP.bAbort && ~hStkInner ) ;
                                    }
                                        // /**/if( bChatterP ) pP.ether.traceF( tinP , T("healing / c2") ) ;
                                        }
                                            }
                                                break ;

                                                }
                                                    // /**/if( bChatterP ) pP.ether.traceF( tinP , T("healing / d2 / maked  and sinked  psttLongInner") ) ;
                                                    }
                                                        pP.bAbort = 1 ;                                                    
                                                        pP.ether.traceF( tinP , pP.tIndent3+T("!exception: iSlotLongInnr is null") ) ;
                                                        pP.ether.delF( tinP , psttLongInner ) ;
                                                    {
                                                    if( !idSlotLongInner ) //SHOULD BE IMPOSSIBLE
                                                    stLongInner.sinkF( tinP , idSlotLongInner , psttLongInner , flSTACKsINK_UNIQUE ) ;
                                                    ZE( countT , idSlotLongInner ) ;

                                                    pP.ether.strMakeF( tinP , LF , psttLongInner , tLongInner ) ; ___( psttLongInner ) ;
                                                    ZE( strokeS* , psttLongInner ) ;
                                                    // /**/if( bChatterP ) pP.ether.traceF( tinP , T("healing / d2 / making and sinking psttLongInner") ) ;

                                                    offResult ++ ;

                                                    pcBitsShiftLeftHeInMine[ offResult ] = cBitsShiftLeftHeInMine ;
                                                    pcBitsShiftLeftMeInHis[  offResult ] = cBitsShiftLeftMeInHis  ;
                                                    ppIdResultHeInMine[      offResult ] = &bitsResultHeInMine    ;
                                                    ppIdResultMeInHis[       offResult ] = &bitsResultMeInHis     ;
                                                {
                                                if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                            {
                                            case 3 :
                                            }
                                                break ;

                                                }
                                                    cInnerImagesToInspect ++ ;
                                                    // //pP.ether.traceF( tinP , pP.tIndent3+T("incrementing") ) ;
                                                {
                                                if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )

                                                // //pP.ether.traceF( tinP , pP.tIndent3+T("        maybe incrementing cInnerImagesToInspect [bitsResultHeInMine,maskHeInMine,masked,cBitsShiftLeftHeInMine,inner]:    ")+TF2(bitsResultHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(maskHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((bitsResultHeInMine&maskHeInMine),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                            {
                                            case 2 :    // COUNT THE NUMBER OF INNER FILES FOR WHICH I MUST INSPECT THE IMAGE (I SET cInnerImagesToInspect HERE)
                                            }
                                                break ;

                                                }
                                                    }
                                                        bitsResultHeInMine |= BITSrESULT_NOTeQUAL << cBitsShiftLeftHeInMine ;
                                                        bitsResultMeInHis  |= BITSrESULT_NOTeQUAL << cBitsShiftLeftMeInHis  ;
                                                        // //pP.ether.traceF( tinP , pP.tIndent3+T("        set other and myself to BITSrESULT_NOTeQUAL because cbUsed differs") ) ;
                                                    {
                                                    if( pfmOuter->cbUsed != pfmInner->cbUsed )

                                                    //U:: SET TO NOTeQUAL HERE IF DATETIME DIFFERS ; THIS WOULD BE AN OPTIMIZATION TO AVOID DOING IMAGE COMPARISON FOR COPIES THAT HAVE DIFFERENT TIMESTAMPS ; IN PRACTICE, THIS OPTIMIZATION WOULD NOT MAKE MUCH DIFFERENCE BECAUSE INTENTIONAL UPDATES TO A FILE ALMOST ALWAYS CHANGE ITS SIZE
                                                {
                                                else if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                                }
                                                    // //pP.ether.traceF( tinP , pP.tIndent3+T("        setted  myself to BITSrESULT_EQUAL [bitsResultMeInHis]:    ")+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    bitsResultMeInHis |= BITSrESULT_EQUAL << cBitsShiftLeftMeInHis ;
                                                    // //pP.ether.traceF( tinP , pP.tIndent3+T("        setting myself to BITSrESULT_EQUAL [&bitsResultMeInHis,bitsResultMeInHis,&cBitsShiftLeftMeInHis,cBitsShiftLeftMeInHis]:    ")+TF2(&bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(&cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( pfmInner == pfmOuter )
                                            {
                                            case 1 :    // SET bitsResult WITHOUT COMPARING FILE IMAGES
                                        {
                                        switch( idPass )

                                        // /*if( idPass == 3 )*/ pP.ether.traceF( tinP , pP.tIndent3+T("    [idPass,idInner,tLongInner]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(++idInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                        // /**/if( bChatterP ) pP.ether.traceF( tinP , T("healing / d2 / calculated  tLongInner by querying stack[]") ) ;
                                        TN( tLongInner , "" ) ; tLongInner = T(pP.pzpsttPathToYear[pfmInner->idSlotPathToYear-1])+tShortP ;
                                        // /**/if( bChatterP ) pP.ether.traceF( tinP , T("healing / d2 / calculating tLongInner by querying stack[]") ) ;

                                        countT maskHeInMine = BITSrESULT_ALLbITS << cBitsShiftLeftHeInMine ;
                                        countT maskMeInHis  = BITSrESULT_ALLbITS << cBitsShiftLeftMeInHis  ;

                                        countT  cBitsShiftLeftHeInMine =           ( ( pfmInner->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;
                                        countT  cBitsShiftLeftMeInHis  =           ( ( pfmOuter->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;
                                        countT& bitsResultHeInMine     = picOuter[ ( pfmInner->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;
                                        countT& bitsResultMeInHis      = picInner[ ( pfmOuter->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;

                                        }
                                            break ;
                                            pP.bAbort = 1 ;
                                            pP.ether.traceF( tinP , pP.tIndent3+T("!exception / !pfmInner->idSlotPathToYear [tShort]:    ")+tShortP ) ;
                                        {
                                        if( !pfmInner->idSlotPathToYear )

                                        //picInner->traceF( tinP , pP.tIndent3+T("    inner :    ") ) ;
                                        //pfmInner->traceF( tinP , pP.st O ldPathToYear , pP.tIndent3+T("    inner: ") ) ;
                                        fileMetaS*     pfmInner = (fileMetaS*)( picInner + pP.cResultStructsNeeded ) ;

                                        // //pP.ether.traceF( tinP , pP.tIndent3+T("    [picInner]:    ")+TF2((countT)picInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        imageCompareS* picInner = (imageCompareS*)&stMeta.upF( tinP , hStkInner ) ;

                                        if( pP.bAbort ) break ;
                                        pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;
                                        // /**/if( bChatterP ) pP.ether.traceF( tinP , T("healing / d2") ) ;
                                    {
                                    do
                                    // /**/if( bChatterP ) pP.ether.traceF( tinP , T("healing / e2 /                 CCCCCCCC         [idPass]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    handleC hStkInner( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    ZE( countT , idInner ) ;
                                {
                                if( idPass != 3 || cInnerImagesToInspect )

                                }
                                    pP.ether.memSetF( tinP , (byteT*)pcBitsShiftLeftHeInMine , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                    pP.ether.memSetF( tinP , (byteT*)pcBitsShiftLeftMeInHis  , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                    pP.ether.memSetF( tinP , (byteT*)ppIdResultHeInMine      , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                    pP.ether.memSetF( tinP , (byteT*)ppIdResultMeInHis       , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                    pP.ether.memSetF( tinP , (byteT*)pcbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                    pP.ether.memSetF( tinP , (byteT*)ppbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;

                                    pP.ether.newF( tinP , LF ,             pcBitsShiftLeftHeInMine , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftHeInMine ) ;
                                    pP.ether.newF( tinP , LF ,             pcBitsShiftLeftMeInHis  , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftMeInHis  ) ;
                                    pP.ether.newF( tinP , LF , *(countT**)&ppIdResultHeInMine      , cInnerImagesToInspect ) ; ___( ppIdResultHeInMine      ) ;
                                    pP.ether.newF( tinP , LF , *(countT**)&ppIdResultMeInHis       , cInnerImagesToInspect ) ; ___( ppIdResultMeInHis       ) ;
                                    pP.ether.newF( tinP , LF ,             pcbwInner               , cInnerImagesToInspect ) ; ___( pcbwInner               ) ;
                                    pP.ether.newF( tinP , LF , *(countT**)&ppbwInner               , cInnerImagesToInspect ) ; ___( ppbwInner               ) ;
                                {
                                if( idPass == 3 && cInnerImagesToInspect )
                            {
                            for( countT idPass = 1 ; !etPrime && !pP.bAbort && idPass <= 3 ; idPass ++ )
                            ZE( countT   , offResult               ) ;
                            ZE( countT*  , pcBitsShiftLeftHeInMine ) ;
                            ZE( countT*  , pcBitsShiftLeftMeInHis  ) ;
                            ZE( countT** , ppIdResultHeInMine      ) ;
                            ZE( countT** , ppIdResultMeInHis       ) ;
                            ZE( countT*  , pcbwInner               ) ;
                            ZE( byteT**  , ppbwInner               ) ;
                            ZE( countT   , cInnerImagesToInspect   ) ;
                            stackC stLongInner( tinP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;

                            // *********************************************************************************************************************************************************************************************************
                            // ****                                                *****************************************************************************************************************************************************
                            // ****  LOAD stLongInner AND INITIALIZE ACCUMULATORS  *****************************************************************************************************************************************************
                            // ****                                                *****************************************************************************************************************************************************
                            // *********************************************************************************************************************************************************************************************************

                            //pfmOuter->traceF( tinP , pP.st O ldPathToYear , pP.tIndent2+T("outer: ") ) ;
                            // //pP.ether.traceF( tinP , pP.tIndent2+T("[tLongOuter]:    ")+tLongOuter ) ;
                            TN( tLongOuter , "" ) ; tLongOuter = T(pP.pzpsttPathToYear[idSlotPathToYearOuter-1])+tShortP ;
                            countT idSlotPathToYearOuter = pfmOuter->idSlotPathToYear ;

                            }
                                break ;
                                pP.bAbort = 1 ;
                                pP.ether.traceF( tinP , pP.tIndent2+T("!exception / !pfmOuter->idSlotPathToYear [tShort]:    ")+tShortP ) ;
                            {
                            if( !pfmOuter->idSlotPathToYear )

                            // //picOuter->traceF( tinP , pP.tIndent2+T("outer :    ") ) ;
                            fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + pP.cResultStructsNeeded ) ;
                            imageCompareS* picOuter  = (imageCompareS*)&stMeta.upF( tinP , hStkOuter ) ;

                            if( pP.bAbort ) break ;
                            if( etPrime ) pP.bAbort = 1 ;
                            pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;

                            // *********************************************************************************************************************************************************************************************************
                            // ****                                      ***************************************************************************************************************************************************************
                            // ****  BEGIN:  FOR EACH COPY OF THIS FILE  ***************************************************************************************************************************************************************
                            // ****                                      ***************************************************************************************************************************************************************
                            // *********************************************************************************************************************************************************************************************************
                            //if( bChatterP ) pP.ether.traceF( tinP , T("healing / e2") ) ;
                        {
                        do
                        handleC hStkOuter( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                        // SET ALL COMPARE META ELEMENTS FOR EACH FILE'S IMAGE COMPARE META ARRAY

                        if( !pP.bAbort && ( cbUsedHighMax || cbUsedMax > TOCK ) ) pP.ether.osTimeNowF( tinP , timeA1 , timeA2 ) ;
                        ZE( sCountT , timeA2 ) ;
                        ZE( countT  , timeA1 ) ;

                        //pP.ether.traceF( tinP , T("[cbUsedMax04,cWindowsMax]:    ")+TF2((countT)cbUsedMax04,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cWindowsMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        countT   cWindowsMax = (countT)( 1 + cbUsedMax04 / cbFileWindow ) ;
                        count04T cbUsedMax04 = ( (count04T)cbUsedHighMax << 0x20 ) | (count04T)cbUsedMax ;      //A:ASSUME: sizeof( countT) IS 0x20

                        //OPTIMIZATION: FASTER IF DO NOT DO THIS: if( cbUsedHighMax || cbUsedMax > TOCK ) bLargeFile = 1 ;    //20230918@1130: TOCK <-- TUCK
                        ZE( boolT  , bLargeFile ) ;

                        //pP.ether.traceF( tinP , T("[cCopies,cbFileWindow]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+TF3(cbFileWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
                        }
                                   cbFileWindow         =   cbFileWindowsPerCopy                                                    ;

                                   cbFileWindowsPerCopy = ( cbFileWindowsPerCopy / cbGrain ) * cbGrain                              ;        //ENFORCES GRAINSIZE
                            //countT cbFileWindowsPerCopy =   cbAllFileWindows     / cCopies   /* / ( cToHireHealP + cToHireCompareP ) */ ;  // INTENTION IS TO PEG CPU WHEN FEW WINDOWS WHILE PREVENTING ADDRESS SPACE EXHAUSTION WHEN MANY WINDOWS ; COMPARES ARE DONE ON tmWorkerCompareF FOR LARGE FILES AND ON tmWorkerHealF FOR SMALL FILES

                              //countT cbFileWindowsPerCopy =   cbAllFileWindows     / cCopies   /* / pP.cPathsToYear            */ ;
                                countT cbFileWindowsPerCopy =   cbAllFileWindows     / cCopies      / CtOhIREhEAL                   ;  //U:: THIS LINE IS FOR EXPERIMENT: ALL COMPARE IN LINE

                            countT cbAllFileWindows     = ( CBaLLfILEwINDOWS     / cbGrain ) * cbGrain                              ;        //ENFORCES GRAINSIZE
                            countT cbGrain              = thirdC::os_cbAllocationGrain_IF( tinP )                                   ;
                        {
                        ZE( countT , cbFileWindow ) ;                                                           //A:ASSUME: THE MAX NUMBER OF FILE WINDOWS THAT WILL EXIST FOR A FILE AT ANY TIME IS pP.cPathsToYear
     
                        pP.ether.traceF( tinP , T("processing [idName,tShort]:    ")+TF2(idNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;
                    {
                    if( !pP.bAbort )
                    pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;

                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // ****                                                                                                                                  *******************************************************************
                    // ****  BEGIN:  COMPARE ALL COPIES OF THIS SHORT FILE NAME.  THIS IS RETRIED UNTIL ALL COMPARISONS COMPLETE WITHOUT AN EXCEPTION EVENT  *******************************************************************
                    // ****                                                                                                                                  *******************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                    // *********************************************************************************************************************************************************************************************************
                {
                else
                else if( !cCopies ) pP.ether.traceF( tinP , T("!exception: i found 0 copies of this listed file [tShort]:    ")+tShortP ) ;
                if( etPrime ) ;
                ////pP.ether.traceF( tinP , T("healing / f2") ) ;

                // //pP.ether.traceF( tinP , T("[cCopies,tShort]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tShortP ) ;

                countT cCopies = stMeta ;
            {
            if( !pP.bAbort )
            //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 03") ) ;

            pP.ether.delF( tinP , *(countT**)&ppInfoFile ) ;
            }
                DEL( ppInfoFile[ offh ] ) ;
            {
            for( countT offh = 0 ; offh < pP.cPathsToYear ; offh ++ )

            }
                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 13 / 0") ) ;

                DEL( ppInfoFile[ offh ] ) ;
                }
                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 13 / ") ) ;
                    new( 0 , tinP , (byteT*)pCursor , sizeof( fileMetaS ) ) fileMetaS( tinP , pP.bAbort , offh + 1 , time1Mod , time2Mod , cbUsed ) ;
                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 13 / 1") ) ;

                    pCursor += pP.cResultStructsNeeded ;

                    bitsResultMeInMine = BITSrESULT_EQUAL << cBitsShiftLeftMeInMine ;   // INITIALIZE RESULT TO SAY THAT I MATCH MYSELF

                    countT  cBitsShiftLeftMeInMine =        ( offh % cResultsPerStruct ) << 1 ;
                    countT& bitsResultMeInMine     = pCursor[ offh / cResultsPerStruct ].bitsResult ;
                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 13 / 2") ) ;

                    for( countT offs = 0 ; offs < pP.cResultStructsNeeded ; offs ++ ) new( 0 , tinP , (byteT*)( pCursor + offs ) , sizeof( imageCompareS ) ) imageCompareS ;
                    imageCompareS* pCursor = (imageCompareS*)&(stMeta)[ 1 ] ;
                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 13 / 3") ) ;

                    stMeta << (byteT*)0 ;

                    count04T cbUsed = (count04T)ppInfoFile[ offh ]->cbUsedHigh << sizeof( count02T ) * SB | ppInfoFile[ offh ]->cbUsed ;

                    sCountT time2Mod = ppInfoFile[ offh ]->timeWritten2 ;
                    countT  time1Mod = ppInfoFile[ offh ]->timeWritten1 ;

                    }
                        cbUsedHighMax = ppInfoFile[ offh ]->cbUsedHigh ;
                        cbUsedMax     = ppInfoFile[ offh ]->cbUsed     ;
                    {
                    if( cbUsedHighMax < ppInfoFile[ offh ]->cbUsedHigh || ( cbUsedHighMax == ppInfoFile[ offh ]->cbUsedHigh && cbUsedMax < ppInfoFile[ offh ]->cbUsed ) )
                    //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 13 / 4") ) ;
                {
                if( ppInfoFile[ offh ] )

                // //pP.ether.traceF( tinP , T("processing a path to this file [idPath,cPathsToYear,tLong]:    ")+TF2(1+offh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+pP.tb4+TF2(pP.cPathsToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+pP.tb4+tLong ) ;

                TN( tLong , "" ) ; tLong = T(pP.pzpsttPathToYear[offh])+tShortP ;
                //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 13 / a") ) ;
            {
            for( countT offh = 0 ; !pP.bAbort && !etPrime && offh < pP.cPathsToYear ; offh ++ )
            ZE( countT , cbUsedHighMax ) ;
            ZE( countT , cbUsedMax ) ;
            // /**/if( bChatterP ) pP.ether.traceF( tinP , T("healing / 13 /         BBBBBBBB") ) ;

            if( etPrime ) pP.bAbort = 1 ;

            }
                //tinP.pc Utility[ 0 ] ++ ;

                //pP.ether.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
                //pP.ether.traceF( tinP , T("   +     watch") ) ;
            {
            if( bChatterP )

            pP.grabDisk.ungrabF( tinP ) ;

            }
                //++ s ; thirdC::dosSleepWinkIF( tinP , 0 ) ;
                Sleep( 0 ) ;

                }
                    break ;
                    }
                        }
                            pP.ether.traceF( tinP , T("!exception: file not found or i could not obtain file info [tLong]:    ")+tLong ) ;
                            TN( tLong , "" ) ; tLong = T(pP.pzpsttPathToYear[offh])+tShortP ;
                            ppInfoFile[ offh ] = 0 ;
                        {
                        if( ppInfoFile[ offh ] == INFOfILEnOTaVAILABLE )
                    {
                    for( countT offh = 0 ; offh < pP.cPathsToYear ; offh ++ )
                {
                if( offh == pP.cPathsToYear )

                }
                    if( !ppInfoFile[ offh ] ) break ;
                {
                for( ; offh < pP.cPathsToYear ; offh ++ )
                ZE( countT , offh ) ;
            {
            for(;;)                                                                         // NAP UNTIL ALL ELEMENTS ARE SET ; THEN SMUDGE THE "INFOfILEnOTaVAILABLE" VALUES TO 0
            sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            // /**/if( bChatterP ) pP.ether.traceF( tinP , T("healing / 23 / AAAAAAAA") ) ;

            }
                pP.funJobFileInfo.writeF( tinP , pbz ) ;
                new( 0 , tinP , pbz , sizeof pbz ) jobFileInfoS( tinP , pP.ether , tLong , ppInfoFile[ offh ] ) ;
                byteT pbz[ sizeof( jobFileInfoS ) ] ;

                TN( tLong , "" ) ; tLong = T(pP.pzpsttPathToYear[offh])+tShortP ;
            {
            for( countT offh = 0 ; offh < pP.cPathsToYear ; offh ++ )
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
            //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 33") ) ;

            pP.grabDisk.grabF( tinP , TAG( TAGiDnULL ) ) ;

            }
                //tinP.pc Utility[ 0 ] -- ;

                //pP.ether.traceF( tinP , T("    -    watch") ) ;
                //pP.ether.etherWhereF( tinP , ifcIDaCTIONwHERE_UNWATCH ) ;
            {
            if( bChatterP )

            pP.ether.memSetF( tinP , (byteT*)ppInfoFile , sizeof( countT ) * pP.cPathsToYear ) ;
            pP.ether.newF( tinP , LF , *(countT**)&ppInfoFile , pP.cPathsToYear ) ; ___( ppInfoFile ) ;
            ZE( infoFileS** , ppInfoFile ) ;
            //if( bChatterP ) pP.ether.traceF( tinP , T("healing / 43") ) ;
        {
        if( !pP.bAbort )
        pauseIfF( tinP , pP.bAbort , pP.cExecutiveHealYearPaused , pP.cPause ) ;

        stackC stMeta( tinP , pP.ether , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB | flSTACKc_ALLOWzE , pP.cResultStructsNeeded * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ;

        //pP.ether.traceF( tinP , T("++++ healing [tShort]:    ")+tShortP ) ;

        const countT cProcessors = thirdC::osProcessorsIF( tinP ) ;

        etherC& etRock  = etherC::etRockIF( tinP ) ;
        etherC& etText  = etherC::etTextIF( tinP ) ;
        etherC& etPrime = etherC::etPrimeIF() ;
        TN( tPerTuck , " %" ) ;
        TN( tDot , "." ) ;
        TN( tb4  , "    " ) ;
        TN( tb   , " " ) ;

        }
            //tinP.pc Utility[ 0 ] ++ ;

            //pP.ether.etherWhereF( tinP , ifcIDaCTIONwHERE_WATCH ) ;
            //pP.ether.traceF( tinP , T("++++     watch") ) ;
        {
        if( bChatterP )
    {

    //)
    //    && !pP.ether.strIdF( tinP , T("!ideafarm.a."       ) , tShortP , 1 )
    //    && !pP.ether.strIdF( tinP , T(".meta.datafiletimes") , tShortP , 1 )
    //       !pP.ether.strIdF( tinP , T(".fset.zip"          ) , tShortP , 1 )
    //(
    //if
    /*U::COMMENT OUT IN PRODUCTION:*/

    // /* if( bChatterP )*/ pP.ether.traceF( tinP , T("healing ++++ [idName]:    ")+TF2(idNameP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    //bChatterP = 1 ; //U:: TO FIND A BUG
{
voidT healShortNameF( tinS& tinP , etherC& etPrimeP , paramHealFileS& pP , textC& tShortP , const flagsT flagsModeP , const countT idNameP , const countT cShortNamesP , const countT cToHireHealP , const countT cToHireCompareP , boolT bChatterP )

}
    //etherP.traceF( tinP , T("compareOoImagesF / ----") ) ;
    }
        }
            //if( !( idIn % ( TUCK << 4 ) ) ) etherP.traceF( tinP , T("images match [idIn]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        else
        }
            //etherP.delF( tinP , psttGen ) ;
            //etherP.traceF( tinP , tIndent3P+T("wrote inner [gen]:    ")+T(psttGen) ) ;
            //etherP.boxPutGenerationF( tinP , psttGen , tLikeInner+TF3(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) , TUCK , ppbwInner[ offi ] , cbwOuter ) ; ___( psttGen ) ;
    
            //etherP.delF( tinP , psttGen ) ;
            //etherP.traceF( tinP , tIndent3P+T("wrote outer [gen]:    ")+T(psttGen) ) ;
            //etherP.boxPutGenerationF( tinP , psttGen , tLikeOuter , TUCK , pbwOuter , cbwOuter ) ; ___( psttGen ) ;
            //ZE( strokeS* , psttGen ) ;
    
            //etherP.traceF( tinP , tIndent3P+T("difference detected between unique and inner [idWindow,offi]:    ")+TF2((countT)idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    
            bEqualP = 0 ;
        {
        if( sgn )

        }
            if( cbWas == setIfEqualsAM( cbNewlyCompared , cbNow , cbWas ) ) break ;
            countT cbNow = cbWas + cbwOuterP ;
            countT cbWas = cbNewlyCompared ;
        {
        for(;;)
    {
    if( !bAbortP )
    
    //countT idIn = 1 + incv02AM( idInLath ) ;
    //static countT idInLath ;
    
    if( etPrimeP ) bAbortP = 1 ;

    }
        }
            }
                }
                    etherP.traceF( tinP , T("decremented cPause after nap after exception [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    was = decv02AM( cPauseP ) ;
                    ++ s ; etPrimeP.osSleepF( tinP , TIMEpAUSEoNfAIL ) ;
                    etherP.traceF( tinP , T("incremented cPause on exception [was]:    ")+TF2(was,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT was = incv02AM( cPauseP ) ;
                {
                else
                }
                    break ;
                    bAbortP = 1 ;
                {
                else if( !cTries )
                if( bAbortP ) break ;

                if( etPrimeP ) bAbortP = 1 ;

                //etherP.traceF( tinP , tIndent3P+T("!exception / memCompareF impotence ; aborting if !cTries [cTries,idCulprit,tLongOuter,tLongInner]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idCulprit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuterP+tb4+tLongInnerP ) ;
                POOPRqUIET
    
                }
                    default                             : { etherP.traceF( tinP , T("!exception: software error: unknown impotence code (ifcIDiMPOTENCEmEMcMP)") ) ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_COMPARE2  : { idCulprit = 2 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_COMPARE1  : { idCulprit = 1 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_COMPARE0  : {                 break ; }
                    case ifcIDiMPOTENCEmEMcMP_LATHbYTE2 : { idCulprit = 2 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_WOTHbYTE2 : { idCulprit = 2 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_LATHbYTE1 : { idCulprit = 1 ; break ; }
                    case ifcIDiMPOTENCEmEMcMP_WOTHbYTE1 : { idCulprit = 1 ; break ; }
                    //CS:CODEsYNC: 510007e9 112005be
                {
                switch( POOP )
                ZE( countT , idCulprit ) ;
            {
            else
            if( !POOP ) break ;
            //etherP.traceF( tinP , tIndent3P+T("called  memCompareF [cb]:    ")+TF2(cbwOuterP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            sgn = tinP.pEtScratch->memCompareF( tinP , pbwOuterP , pbwInnerP , cbwOuterP ) ;
            //etherP.traceF( tinP , tIndent3P+T("calling memCompareF [cb]:    ")+TF2(cbwOuterP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        while( bEqualP && !etPrimeP && !bAbortP && cTries -- )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        countT cTries = ( F(flagsModeP) & flHEALmODE_STRICT ) ? 1 : CtRIESiFnOTsTRICT ;
    
        SCOOPS
    {
    IFsCRATCH
    ZE( sCountT , sgn ) ;
    //etherP.traceF( tinP , tIndent3P+tLongInnerP ) ;
    //etherP.traceF( tinP , tIndent3P+tLongOuterP ) ;
    //etherP.traceF( tinP , T("compareOoImagesF / ++++" /*U::" [idIn,cbwOuterP]:"*/ "    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)/*U::+tb4+TF2(cbwOuterP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)*/ ) ;
    //TN( tb4 , "    " ) ;

    countT idIn = 1 + incv02AM( idInLath ) ;
    static countT idInLath ;
{
voidT compareOoImagesF( tinS& tinP , etherC& etPrimeP , etherC& etherP , boolT& bAbortP , countT& cPauseP , boolT& bEqualP , const flagsT flagsModeP , const byteT* pbwOuterP , const byteT* pbwInnerP , countT cbwOuterP /*, const textC& tLongOuterP , const textC& tLongInnerP , textC& tIndent3P*/ )

countT cbNewlyCompared ;

}
    etherP.delF( tinP , pEqualP ) ;

    }
        etherP.delF( tinP , *(byteT**)&pfwsInnerP ) ;

        }
            DELzOMBIE( pDoomed ) ;
            fileWindowsC* pDoomed = pfwsInnerP + offi ;
        {
        for( countT offi = 0 ; offi < cInnerImagesToInspectP ; offi ++ )
    {
    if( pfwsInnerP )
{
voidT deleteEqualArrayFwsInnerArrayF( tinS& tinP , etherC& etherP , boolT*& pEqualP , fileWindowsC*& pfwsInnerP , countT cInnerImagesToInspectP )

}
    if( ether ) bAbortP = 1 ;

    }
        dec02AM( cExecutiveHealYearPausedP ) ;
        }
            ++ s ; ether.osSleepF( tinP , TOCK ) ;
        {
        while( cPauseP && !ether )
        sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        inc02AM( cExecutiveHealYearPausedP ) ;
    {
    if( cPauseP && !ether && !bAbortP )
    etherC& ether = etherC::etPrimeIF( tinP ) ;
{
voidT pauseIfF( tinS& tinP , boolT& bAbortP , countT& cExecutiveHealYearPausedP , countT& cPauseP )

}
    return *pfr1 - *pfr2 ;

    fileMetaS* pfr2 = (fileMetaS*)c2P ;
    fileMetaS* pfr1 = (fileMetaS*)c1P ;
{
/*1*/countT subtractFileMetaF( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    return - sgn ;                          //SORT IN DECREASING ORDER OF SIZE SO THAT THE LARGEST FILES ARE PROCESSED WOTH
    sCountT sgn = *pJob1 - *pJob2 ;

    jobCompareOoImagesS* pJob2 = (jobCompareOoImagesS*)c2P ;
    jobCompareOoImagesS* pJob1 = (jobCompareOoImagesS*)c1P ;
{
/*1*/countT subtract_jobCompareOoImagesS_F( tinS& tinP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    tPathLonely  += tUniqueP+tSlash ;
    tPathRejects += tUniqueP+tSlash ;
{
grabDisk( grabDiskP )
funJobHealFileDone( funJobHealFileDoneP ) ,
st_pzJobHealFileDone( st_pzJobHealFileDoneP ) ,
pzpsttPathToYear( ppsttPathToYearP ) ,
cResultStructsNeeded( cResultStructsNeededP ) ,
cPathsToYear( cPathsToYearP ) ,
funJobFileInfo( funJobFileInfoP ) ,
stJobCompare( stJobCompareP ) ,
cExecutiveHealYearPaused( cExecutiveHealYearPausedP ) ,
cProcessors( thirdC::osProcessorsIF( tinP ) ) ,
tArchive( tArchiveP ) ,
tYear( tYearP ) ,
tPathLonely(    tinP , TAG( TAGiDnULL ) , flTEXTc_null , "/ideafarm.archives.lonely/" ) ,
tPathRejects(   tinP , TAG( TAGiDnULL ) , flTEXTc_null , "/ideafarm.archives.rejects/" ) ,
tPathArchives(  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "/ideafarm.archives/" ) ,
tIndent3(  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "|           " ) ,
tIndent2(  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "|       " ) ,
tIndent1(  tinP , TAG( TAGiDnULL ) , flTEXTc_null , "|   " ) ,
tSlash( tinP , TAG( TAGiDnULL ) , flTEXTc_null , "/" ) ,
tDot( tinP , TAG( TAGiDnULL ) , flTEXTc_null , "." ) ,
tb4( tinP , TAG( TAGiDnULL ) , flTEXTc_null , "    " ) ,
tn( tinP , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
cPause( cPauseP ) ,
bAbort( bAbortP ) ,
etPrime( etherC::etPrimeIF() ) ,
ether( etherP ) ,
paramHealFileS::paramHealFileS( tinS& tinP , etherC& etherP , boolT& bAbortP , countT& cPauseP , textC& tYearP , textC& tArchiveP , textC& tUniqueP , countT& cExecutiveHealYearPausedP , stackC& stJobCompareP , funnelHornC& funJobFileInfoP , const countT cPathsToYearP , const countT cResultStructsNeededP , const strokeS** const ppsttPathToYearP , stackC& st_pzJobHealFileDoneP , funnelHornC& funJobHealFileDoneP , grabC& grabDiskP ) :

}
    tinP.pEther->traceF( tinP , T(psttP)+T(" [bitsResult]:    ")+TF4(bitsResult,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
{
voidT imageCompareS::traceF( tinS& tinP , const strokeS* const psttP )

}
    //traceF( tinP , T("ct      :    ") ) ;
    TINSL
{
bitsResult( BITSrESULT_UNKNOWN )
imageCompareS::imageCompareS( voidT ) :

NEWdELcLASS( 5 , imageCompareS ) ;

}
    return tinP.pEther->memCompareF( tinP , (byteT*)this , (byteT*)&frP , sizeof( countT ) + sizeof( count04T ) ) ;    //CS:CODEsYNC 1 1
    TINSL
{
sCountT fileMetaS::operator -( const fileMetaS& frP ) const

}
    //tinP.pEther->traceF( tinP , T(psttP)+T(" [timeModRounded,timeMod,cbUsed,cVotes,idSlotPathToYear,path]:    ")+TF3(timeModRounded,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T("    ")+TT(time1Mod,time2Mod)+T("    ")+TT(((countT*)&cbUsed)[0],((countT*)&cbUsed)[1])+T("    ")+TF2(cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idSlotPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((strokeS*)st O ldPathToYearP[idSlotPathToYear]) ) ;
{
voidT fileMetaS::traceF( tinS& tinP , const strokeS* const psttP )

}
    timeModRounded = *(countT*)( (byteT*)pc2 + 3 ) + bRoundUp ;
    countT pc2[ 2 ] = { time1Mod , time2Mod } ;

    boolT bRoundUp = !!( ( time1Mod & 0xffffff ) > 0x800000 ) ;

    }
        bAbortP = 1 ;
        tinP.pEther->traceF( tinP , T("fileMetaS::fileMetaS / !exception: idSlotPathToYear is null") ) ;
    {
    if( !idSlotPathToYear )
{
idSlotPathToYear( idSlotPathToYearP )
cVotes( 0 ) ,
time2Mod( time2ModP ) ,
time1Mod( time1ModP ) ,
cbUsed( cbUsedP ) ,
timeModRounded( 0 ) ,
fileMetaS::fileMetaS( tinS& tinP , boolT& bAbortP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) :

NEWdELcLASS( 4 , fileMetaS ) ;

}
{
pInfo( *(infoFileS**)0 )
psttLong( 0 ) ,
ether( *(etherC*)0 ) ,
jobFileInfoS::jobFileInfoS( voidT ) :

}
    ether.strMakeF( tinP , LF , psttLong , psttLongP ) ; ___( psttLong ) ;
{
pInfo( pInfoP )
psttLong( 0 ) ,
ether( etherP ) ,
jobFileInfoS::jobFileInfoS( tinS& tinP , etherC& etherP , const strokeS* const psttLongP , infoFileS*& pInfoP ) :

}
    ether.delF( tinP , psttLong ) ;
    TINSL
{
jobFileInfoS::~jobFileInfoS( voidT )

NEWdELcLASS( 3 , jobFileInfoS ) ;

}
{
cShortNames( 0 )
idName( 0 ) ,
psttShort( 0 ) ,
info( *(paramHealFileS*)0 ) ,
cJobsPendingHeal( *(countT*)0 ) ,
ether( *(etherC*)0 ) ,
jobHealFileS::jobHealFileS( voidT ) :

}
    //etherC::etRockIF( tinP ).traceF( tinP , T("++++ [cJobsPendingHealAfterCt,idName,short]:    ")+TF3(cJobsPendingHealNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(" ")+T(psttShort) ) ;
    ether.strMakeF( tinP , LF , psttShort , psttShortP ) ; ___( psttShort ) ;

    countT cJobsPendingHealNow = 1 + incv02AM( cJobsPendingHeal ) ;
{
cShortNames( cShortNamesP )
idName( idNameP ) ,
psttShort( 0 ) ,
info( infoP ) ,
cJobsPendingHeal( cJobsPendingHealP ) ,
ether( etherP ) ,
jobHealFileS::jobHealFileS( tinS& tinP , etherC& etherP , countT& cJobsPendingHealP , paramHealFileS& infoP , const strokeS* const psttShortP , const countT idNameP , const countT cShortNamesP ) :

}
    ether.delF( tinP , psttShort ) ;
    //etherC::etRockIF( tinP ).traceF( tinP , T("---- [cJobsPendingHealAfterDt,idName,short]:    ")+TF3(cJobsPendingHealNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(idName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+T(" ")+T(psttShort) ) ;
    countT cJobsPendingHealNow = decv02AM( cJobsPendingHeal ) - 1 ;
    if( !pEther ) { BLAMMO ; }              // IT IS ILLEGAL TO CT USING THE DEFAULT CT'OR WITHOUT IMMEDIATELY OVERWRITING THE IMAGE TO MAKE IT VALID
    etherC* pEther = &ether ;
    TINSL
{
jobHealFileS::~jobHealFileS( voidT )

NEWdELcLASS( 2 , jobHealFileS ) ;

}
{
psttLongInner( 0 )
psttLongOuter( 0 ) ,
cbwOuter( 0 ) ,
pbwInner( 0 ) ,
pbwOuter( 0 ) ,
bEqual( *(boolT*)0 ) ,
cJobsPendingCompare( *(countT*)0 ) ,
ether( *(etherC*)0 ) ,
jobCompareOoImagesS::jobCompareOoImagesS( voidT ) :

}
    ether.strMakeF( tinP , LF , psttLongInner , psttLongInnerP ) ; ___( psttLongInner ) ;
    ether.strMakeF( tinP , LF , psttLongOuter , psttLongOuterP ) ; ___( psttLongOuter ) ;

    inc02AM( cJobsPendingCompare ) ;
{
psttLongInner( 0 )
psttLongOuter( 0 ) ,
cbwOuter( cbwOuterP ) ,
pbwInner( pbwInnerP ) ,
pbwOuter( pbwOuterP ) ,
bEqual( bEqualP ) ,
cJobsPendingCompare( cJobsPendingCompareP ) ,
ether( etherP ) ,
jobCompareOoImagesS::jobCompareOoImagesS( tinS& tinP , etherC& etherP , countT& cJobsPendingCompareP , boolT& bEqualP , const byteT* pbwOuterP , const byteT* pbwInnerP , countT cbwOuterP , const strokeS* const psttLongOuterP , const strokeS* const psttLongInnerP , count04T cbUsedMax04P ) :

}
    dec02AM( cJobsPendingCompare ) ;
    ether.delF( tinP , psttLongInner ) ;
    ether.delF( tinP , psttLongOuter ) ;
    if( !pEther ) { BLAMMO ; }              // IT IS ILLEGAL TO CT USING THE DEFAULT CT'OR WITHOUT IMMEDIATELY OVERWRITING THE IMAGE TO MAKE IT VALID
    etherC* pEther = &ether ;
    TINSL
{
jobCompareOoImagesS::~jobCompareOoImagesS( voidT )

NEWdELcLASS( 1 , jobCompareOoImagesS ) ;

osTextT* postDebugLever ;

countT cYearsInParallelHeal = CyEARSiNpARALLELhEAL ;
const countT cResultsPerStruct = sizeof( countT ) * SB / 2 ;     // 2 BITS ARE USED TO STORE A RESULT, SO 4 RESULTS FIT INTO A BYTE AND 01 RESULTS FIT INTO A count02T ; MY CODE SHOULD BE WRITTEN WITHOUT ASSUMING countT IS count02T

;
}
    voidT traceF( tinS& tinP , const strokeS* const psttP = 0 ) ;
    inline sCountT operator -( imageCompareS& picP ) { return bitsResult - picP.bitsResult ; }
    imageCompareS( voidT ) ;
    NEWdELcLASSpROTOS

    countT bitsResult ;
{
struct imageCompareS

;
}
    sCountT operator -( const fileMetaS& frP ) const ;
    voidT traceF( tinS& tinP , const strokeS* const psttP = 0 ) ;
    fileMetaS( tinS& tinP , boolT& bAbortP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) ;
    NEWdELcLASSpROTOS

    countT   idSlotPathToYear ;
    countT   cVotes ;
    sCountT  time2Mod ;
    countT   time1Mod ;
    count04T cbUsed ;
    countT   timeModRounded ;   //CS:CODEsYNC 1 1
{
struct fileMetaS

;
}
    jobFileInfoS( voidT ) ;
    jobFileInfoS( tinS& tinP , etherC& etherP , const strokeS* const psttLongP , infoFileS*& pInfoP ) ;
    ~jobFileInfoS( voidT ) ;
    NEWdELcLASSpROTOS

    infoFileS*&         pInfo    ;      //NOTE THAT THIS IS A REFERENCE TO ANOTHER LOCATION WHERE A POINTER VALUE IS TO BE STORED
    strokeS*            psttLong ;
    etherC&             ether    ;
{
struct jobFileInfoS

;
}
    }
        ;
                : 0
                ? - 1
            : cbUsedMax04 < heP.cbUsedMax04
            ? 1
        return cbUsedMax04 > heP.cbUsedMax04
    {
    inline sCountT operator -( jobCompareOoImagesS& heP ) const
    inline operator countT( voidT ) const { return cbwOuter << 1 ; }

    jobCompareOoImagesS( voidT ) ;
    jobCompareOoImagesS( tinS& tinP , etherC& etherP , countT& cJobsPendingCompareP , boolT& bEqualP , const byteT* pbwOuterP , const byteT* pbwInnerP , countT cbwOuterP , const strokeS* const psttLongOuterP , const strokeS* const psttLongInnerP , count04T cbUsedMax04P ) ;
    ~jobCompareOoImagesS( voidT ) ;
    NEWdELcLASSpROTOS


    count04T     cbUsedMax04         ;
    strokeS*     psttLongInner       ;
    strokeS*     psttLongOuter       ;
    countT       cbwOuter            ;
    const byteT* pbwInner            ;
    const byteT* pbwOuter            ;
    boolT&       bEqual              ;
    countT&      cJobsPendingCompare ;
    etherC&      ether               ;
{
struct jobCompareOoImagesS

;
}
    jobHealFileS( voidT ) ;
    jobHealFileS( tinS& tinP , etherC& etherP , countT& cJobsPendingHealP , paramHealFileS& infoP , const strokeS* const psttShortP , const countT idNameP , const countT cShortNamesP ) ;
    ~jobHealFileS( voidT ) ;
    NEWdELcLASSpROTOS

    const countT        cShortNames      ;
    const countT        idName           ;
    strokeS*            psttShort        ;
    paramHealFileS&     info             ;
    countT&             cJobsPendingHeal ;
    etherC&             ether            ;
{
struct jobHealFileS

;
}
    paramHealFileS( tinS& tinP , etherC& etherP , boolT& bAbortP , countT& cPauseP , textC& tYearP , textC& tArchiveP , textC& tUniqueP , countT& cExecutiveHealYearPausedP , stackC& stJobCompareP , funnelHornC& funJobFileInfoP , const countT cPathsToYearP , const countT cResultStructsNeededP , const strokeS** const ppsttPathToYearP , stackC& st_pzJobHealFileDoneP , funnelHornC& funJobHealFileDoneP , grabC& grabDiskP ) ;

    grabC&                  grabDisk ;
    funnelHornC&            funJobHealFileDone ;
    stackC&                 st_pzJobHealFileDone  ;
    const strokeS** const   pzpsttPathToYear ;
    const countT            cResultStructsNeeded ;
    const countT            cPathsToYear ;
    funnelHornC&            funJobFileInfo ;
    stackC&                 stJobCompare ;
    countT&                 cExecutiveHealYearPaused ;
    const countT            cProcessors ;

    textC&                  tArchive ;
    textC&                  tYear ;

    textC                   tPathLonely ;
    textC                   tPathRejects ;
    textC                   tPathArchives ;
    textC                   tIndent3 ;
    textC                   tIndent2 ;
    textC                   tIndent1 ;
    textC                   tSlash ;
    textC                   tDot ;
    textC                   tb4 ;
    textC                   tn ;

    countT&                 cPause ;
    boolT&                  bAbort ;
    etherC&                 etPrime ;
    etherC&                 ether ;
{
struct paramHealFileS

#define OFFpHASE_CHUNKfILESbYdAY 0x2
#define OFFpHASE_HEAL            0x1
#define OFFpHASE_GETnAMESoNLY    0x0

#define CpHASES 3

#define IDtYPEjOB_COPY       0x3
#define IDtYPEjOB_MOVEuNIQUE 0x2
#define IDtYPEjOB_NULL       0x1

//#define CyEARSiNpARALLELhEAL  0x1
//B:#define CyEARSiNpARALLELhEAL  0x2
//B:#define CyEARSiNpARALLELhEAL  0x4
//G:#define CyEARSiNpARALLELhEAL  0x1
//U:: TO TEST WITH 32_9 DEVICES WITH SUSPECTED INADEQUATE POWER

//B: WORSE:  CPU NOT PEGGED: #define CyEARSiNpARALLELhEAL  0x1

#define CyEARSiNpARALLELhEAL          0x1
#define CyEARSiNpARALLELgETnAMESoNLY  0x10

//20240526@0904: CONJ: WO YEAR AT A TIME IS OPTIMAL BECAUSE DISK I/O IS THE BOTTLENECK SO IT IS OPTIMAL TO MAKE DISK I/O AS EFFICIENT AS POSSIBLE ; WO YEAR AT A TIME ELIMINATES CONTENTION ON EACH DISK, WHICH CAUSES MUCH HEAD SEEK MOVEMENT

//20240526@0903: SORTA AOK BUT SOME FAILS: #define CyEARSiNpARALLELhEAL  0x4
//20240508@1121: AOK:  #define CyEARSiNpARALLELhEAL  0x2
//20240507@1823: FAIL: #define CyEARSiNpARALLELhEAL  0x8

//B:MEMORY EXHAUSTION: #define CyEARSiNpARALLELhEAL  0x10

//B:MEMORY EXHAUSTION: #define CyEARSiNpARALLELhEAL  0x18

//B:DOES NOT PEG CPU WITH 4 YEARS: #define CyEARSiNpARALLELhEAL  0x18

//#define CyEARSiNpARALLELhEAL  8
//20231022@1244: 8 <-- 4
//20230922@0852: STUDY DOING 1 YEAR AT A TIME WITH ALL FILES PROCESSED ASYNCHRONOUSLY (BY PUSHING TO JOB stackC's)

//#define CyEARSiNpARALLELhEAL  0x8
//B: cpu only 1/3 used:#define CyEARSiNpARALLELhEAL  0x8

//NO IMPROVEMENT IN SWAPPING AND NOT PEGGED: #define CyEARSiNpARALLELhEAL  0x2
//OK BUT LOTS OF SWAPPING: #define CyEARSiNpARALLELhEAL  0x4
//B:"!exception: napping: too many pending job bytes: #define CyEARSiNpARALLELhEAL  0x8

//BAD:20230709@1002: #define CyEARSiNpARALLELhEAL  0x10
//BAD:#define CyEARSiNpARALLELhEAL  0x20
//AOK:#define CyEARSiNpARALLELhEAL  0x1
//AOK:#define CyEARSiNpARALLELhEAL  0x4
//AOK:#define CyEARSiNpARALLELhEAL  0x8
//AOK:#define CyEARSiNpARALLELhEAL  0x10
//U::TO FIND A BUG

#define CeXTRAcYCLESiFpAUSE 1

#define CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ( TOCK << 2 )
#define CBdATAbOOKsHORTfILEnAMES           ( TICK << 1 )
// THESE ARE TUNED TO BE LARGE ENOUGH FOR THE YEAR 2014, WHICH HAS THE LARGEST NUMBER OF SHORT FILE NAMES

#define CwORKERStHRESHOLDdOnOTlAUNCHmORE   ( TUCK >> 4 )

#define TIMEpAUSEoNfAIL ( TOCK << 4 )

//AMAZINGLY, IT WORKS!: #define CBfILEwINDOW   ( TICK << 1 )
// JUST FOR SHITS AND GIGGLES, TRY THIS
//20231010@1313: AOK BITCH ASS FAST.  FOR 01 VOLUMES, USES 1/2 OF USABLE ADDRESS SPACE:            ( TICK >> 0 )
//20231010@1250: AOK (WO YEAR AT A TIME, WO FILE AT A TIME, 22_9 VOLUMES, 2099, LARGE FILES WOTH): ( TICK >> 4 )
//20230819@1143: MEMORY EXHAUSTED WITH 5 YEARS AND f DEVICES PER YEAR: #define CBfILEwINDOW        ( TICK >> 2 )
//20230708@0837: MEMORY EXHAUSTED WITH a YEARS AND 6 DEVICES PER YEAR: #define CBfILEwINDOW        ( TICK >> 1 )
//20231010@1431: CBfILEwINDOW IS OBSOLETED BY USE OF CBaLLfILEwINDOWS

#define INFOfILEnOTaVAILABLE ( (infoFileS*)( - 1 ) )

#endif

    #define CtOhIREhEAL    0xc
    #define CtOhIREcOMPARE 0x1

    //#define CtOhIREhEAL    0x1
    //#define CtOhIREcOMPARE 0x20

    //#define CtOhIREhEAL    0x2
    //#define CtOhIREcOMPARE 0x10

    //.#define CtOhIREhEAL    0x1
    //#define CtOhIREcOMPARE 0xb

    //#define CtOhIREhEAL    0x1
    //#define CtOhIREcOMPARE 0x20

    //#define CtOhIREhEAL    0x10
    //#define CtOhIREcOMPARE 8

#else

    #define CtOhIREhEAL    0xc
    #define CtOhIREcOMPARE 0x1

#if defined( IFCtESTING )


//U::G: #define CtOhIREhEAL    8
//U::G: BUT DOES NOT PEG CPU: #define CtOhIREhEAL    4

#define CBaLLfILEwINDOWS ( TICK << 5 )
//20240527@1601: NOPE: #define CBaLLfILEwINDOWS ( TICK << 6 )
//20240527@1600: AOK: #define CBaLLfILEwINDOWS ( TICK << 5 )
//20231010@1601: NOPE: TRY TICK << 6, WHICH IS 1/2 OF USER ADDRESS SPACE

#define BITSrESULT_ALLbITS        3
#define BITSrESULT_EQUAL          2
#define BITSrESULT_NOTeQUAL       1
#define BITSrESULT_UNKNOWN        0

#define CtRIESiFnOTsTRICT   ( TUCK >> 5 )

#define flHEALmODE_LONELYiSoK         0xe00020ff
#define flHEALmODE_NOmOVEoRrEPLACE    0xe00010ff
#define flHEALmODE_NOiMAGEcOMPARE     0xe00008ff
#define flHEALmODE_STRICT             0xe00004ff
#define flHEALmODE_FIREoS             0xe00002ff
#define flHEALmODE_KEEPnAMES          0xe00001ff
#define flHEALmODE_null               0xe00000ff

#define FUNNELhORNcAPACITY       ( TUCK )

#define IFCtESTING

//#define OVERRIDElONELYiSoK
//#define OVERRIDEkEEPnAMES
  #define OVERRIDEnOfIREoS
//#define OVERRIDEdOnOTmOVEoRrEPLACEfILES
//#define OVERRIDEnOiMAGEcOMPARE
//THESE SHOULD BE COMMENTED OUT IN PRODUCTION ; THEY ARE USED FOR EXTRA SAFETY WHEN E.G. RECOVERING DATA

//FOR NORMAL PRODUCTION, IMAGE COMPARE SHOULD NEVER BE SUPPRESSED, BECAUSE THAT CAN RESULT IN THE PROPOGATION OF CORRUPT FILES
//THIS IS ONLY FOR SPECIAL APPLICATIONS

// AN ARRAY OF [cb4Used,idJot] SORTED BY cb4Used IS WRITTEN TO DISK AND REUSED FROM DISK
// LIKE 804 BUT PROCESSES SHORT NAMES IN DESCENDING ORDER OF SIZE
//OBSOLETES 804

/*1*/WAKEhIDE( "ifcIDaDAM_HEALaRCHIVES" )/*1*/
/**/
*/
i look for ///?/ideafarm.archives/ folders and, if found, i heal them
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
