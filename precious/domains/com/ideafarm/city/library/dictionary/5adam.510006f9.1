
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.traceF( tin0P , T("ok") ) ;

}
    while( ~hFind && !ether && !POOP ) ;
    }
        DEL( pInfo ) ;
        }
            etThread.delF( tin0P , psttShort ) ;
            }
                etThread.delF( tin0P , posti ) ;
                }
                    etThread.delF( tin0P , psttTime ) ;
                    etThread.traceF( tin0P , tIdFile ) ;
                    etThread.boxPutF( tin0P , tPathOut+T(psttTime)+tDot+tIdFile+tDotExt , posti , costi ) ;
                    TN( tIdFile , "" ) ; tIdFile = TF3(++idFile,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;

                    getTimeStringF( tin0P , etThread , psttTime , posti , costi ) ;
                    ZE( strokeS* , psttTime ) ;
                {
                if( posti && costi )
            
                etThread.boxGetShadowF( tin0P , posti , costi , pInfo->psttIfoName ) ; ___( posti ) ;
                ZE( countT   , costi ) ;
                ZE( osTextT* , posti ) ;
            {

            etThread.delF( tin0P , psttPath ) ;
            ___( psttShort ) ;
            ___( psttPath ) ;
            etThread.strBisectF( tin0P , psttPath , psttShort , pInfo->psttIfoName , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
            ZE( strokeS* , psttShort ) ;
            ZE( strokeS* , psttPath ) ;
        {
        if( pInfo && pInfo->psttIfoName && pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam != '/' )
        etThread.diskFindFileOrDirOldF( tin0P , pInfo , hFind , tLike ) ; ___( pInfo ) ;
        ZE( infoFileS* , pInfo ) ;
    {
    do
    handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    TN( tDotExt , ".eml" ) ;
    TN( tDot   , "." ) ;
    TN( tSlash , "/" ) ;
    ZE( countT , idFile ) ;
    TN( tPathOut , "///d/tmp/gmail.download/3.renamed/" ) ;

    TN( tLike    , "///d/tmp/gmail.download/2.unwrapped/*") ;
    //TN( tLike    , "///d/tmp/gmail.download/2.unwrapped/mail.00000001.eml") ;
{

TODO

}
    etherP.delF( tin0P , psttHead ) ;
    }
        etherP.delF( tin0P , pstt1Lines ) ;
        }
            }
                //20180228@1443: DISABLED SO THAT FILENAME WILL CONTAIN A RECOGNIZEABLE TIMESTAMP (NO SECONDS): etherP.strFuseF( tin0P , psttTimeP , TF4(second,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa) ) ;
                etherP.strFuseF( tin0P , psttTimeP , TF4(minute,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa) ) ;
                etherP.strFuseF( tin0P , psttTimeP , TF4(hour  ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa) ) ;
                etherP.strFuseF( tin0P , psttTimeP , tAt ) ;
                etherP.strFuseF( tin0P , psttTimeP , TF4(date  ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa) ) ;
                etherP.strFuseF( tin0P , psttTimeP , TF4(month ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa) ) ;
                etherP.strFuseF( tin0P , psttTimeP , TF4(year  ,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,4,0xa) ) ;
                etherP.strMakeF( tin0P , LF , psttTimeP , 0 , 0xf ) ; ___( psttTimeP ) ;
                TN( tAt , "@" ) ;

                etherP.delF( tin0P , pstt1Words ) ;

                }
                    }
                        }
                            break ;
                            year = etherP.strDigitsToSCountF( tin0P , psttc2 , 0xa , 1 ) ;
                        {
                        case 8 :
                        }
                            break ;
                            if( etherP.strCompareF( tin0P , psttc2 , tZone ) ) { BLAMMO ; }
                        {
                        case 7 :
                        }
                            break ;

                            etherP.delF( tin0P , pstt1HMS ) ;

                            }
                                else               pTo = &second ;
                                if( pTo == &hour ) pTo = &minute ;

                                *pTo = etherP.strDigitsToSCountF( tin0P , psttc3 , 0xa , 1 ) ;
                            {
                            FORsTRINGSiN3( pstt1HMS )
                            countT* pTo = &hour ;

                            etherP.strWordsF( tin0P , pstt1HMS , psttc2 , sttq , T(":") ) ; ___( pstt1HMS ) ;
                            ZE( strokeS* , pstt1HMS ) ;
                        {
                        case 6 :
                        }
                            break ;
                            date = etherP.strDigitsToSCountF( tin0P , psttc2 , 0xa , 1 ) ;
                        {
                        case 5 :
                        }
                            break ;

                            else if( !etherP.strCompareF( tin0P , psttc2 , tDec ) ) { month = 12 ; }
                            else if( !etherP.strCompareF( tin0P , psttc2 , tNov ) ) { month = 11 ; }
                            else if( !etherP.strCompareF( tin0P , psttc2 , tOct ) ) { month = 10 ; }
                            else if( !etherP.strCompareF( tin0P , psttc2 , tSep ) ) { month =  9 ; }
                            else if( !etherP.strCompareF( tin0P , psttc2 , tAug ) ) { month =  8 ; }
                            else if( !etherP.strCompareF( tin0P , psttc2 , tJul ) ) { month =  7 ; }
                            else if( !etherP.strCompareF( tin0P , psttc2 , tJun ) ) { month =  6 ; }
                            else if( !etherP.strCompareF( tin0P , psttc2 , tMay ) ) { month =  5 ; }
                            else if( !etherP.strCompareF( tin0P , psttc2 , tApr ) ) { month =  4 ; }
                            else if( !etherP.strCompareF( tin0P , psttc2 , tMar ) ) { month =  3 ; }
                            else if( !etherP.strCompareF( tin0P , psttc2 , tFeb ) ) { month =  2 ; }
                                 if( !etherP.strCompareF( tin0P , psttc2 , tJan ) ) { month =  1 ; }
                        {
                        case 4 :
                        }
                            break ;
                            if( etherP.strCompareF( tin0P , psttc2 , tFrom ) ) { BLAMMO ; }
                        {
                        case 1 :
                    {
                    switch( ++ idw )
                {
                FORsTRINGSiN2( pstt1Words )
                ZE( countT , second ) ;
                ZE( countT , minute ) ;
                ZE( countT , hour ) ;
                ZE( countT , date ) ;
                ZE( countT , month ) ;
                ZE( countT , year ) ;
                TN( tDec , "Dec" ) ;
                TN( tNov , "Nov" ) ;
                TN( tOct , "Oct" ) ;
                TN( tSep , "Sep" ) ;
                TN( tAug , "Aug" ) ;
                TN( tJul , "Jul" ) ;
                TN( tJun , "Jun" ) ;
                TN( tMay , "May" ) ;
                TN( tApr , "Apr" ) ;
                TN( tMar , "Mar" ) ;
                TN( tFeb , "Feb" ) ;
                TN( tJan , "Jan" ) ;
                TN( tZone , "+0000" ) ;
                TN( tFrom , "From" ) ;
                ZE( countT , idw ) ;

                // "From 1491490795542294696@xxx Tue Jan 27 22:07:44 +0000 2015"
                //  1    2                       3   4   5  6        7     8
                            
                etherP.strWordsF( tin0P , pstt1Words , psttc1 , sttq , T(" \t") ) ; ___( pstt1Words ) ;
                ZE( strokeS* , pstt1Words ) ;

                bArmed = 0 ;
            {
            if( bArmed )

            //etherP.traceF( tin0P , psttc1 ) ;
        {
        FORsTRINGSiN1( pstt1Lines )
        boolT bArmed = 1 ;
        etherP.strWordsF( tin0P , pstt1Lines , psttHead , sttq , T("\r\n") ) ; ___( pstt1Lines ) ;
        ZE( strokeS* , pstt1Lines ) ;
    {
    if( psttHead && psttHead->idAdam )
    boolT bFound = etherP.strSubstringF( tin0P , psttHead , idf , sttq , T("\r\n\r\n") , T(postP) ) ; ___( psttHead ) ;
    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    countT idf = 1 ;
    ZE( strokeS* , psttHead ) ;
{
voidT getTimeStringF( tin0S& tin0P , etherC& etherP , strokeS*& psttTimeP , const osTextT* const postP , const countT costP )

/*1*/WAKEsHOWtEXT( "tool.email.rename.to.time" )/*1*/
/**/
*/
i rename the files so that the file system will sort them chronologically
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

