
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

while( cThreads ) OSsLEEPf( 500 ) ;
bQuit = 1 ;

#endif

    etThread.loafIF( tinBaseP ) ;
    etThread.osThreadF( tinBaseP , countTC() , tmGorillaF , 0 , 0 , 0  , flTHREADlAUNCH_ORPHAN ) ;

#else

    }
        etThread.loafIF( tinBaseP ) ;
        BOSpOOP
        BOS( WHATgbo , BOSoK , CloseHandle( osht ) )
    {
    else
    if( !osht ) dec02AM( cThreads ) ;
    HANDLE osht = (HANDLE)((tinFullS&)tinBaseP).brcRaw ;
    BOSpOOP
    BOS( WHATgbo , BOSoK , CreateThread( 0 , 0 , tmGorillaRawF , 0 , 0 , 0 ) )

#if defined( RAW )

inc02AM( cThreads ) ;

pTinMain = &tinBaseP ;

TODO

//#define RAW

}
    return 0 ;
    dec02AM( cThreads ) ;

    BOSpOOP
    BOS( WHATgbo , BOSoK , CloseHandle( osht ) )

    }
        }
            OSsLEEPf( 1000 ) ;
            LOGrAW5( "Could not create thread [idt,idTry]: " , idt , " " , idTry , ".  Napping for 1 second.\r\n" ) ;
            dec02AM( cThreads ) ;
        {
        else
        if( osht ) break ;
        osht = (HANDLE)((tinFullS&)tinBaseP).brcRaw ;
        BOSpOOP
        BOS( WHATgbo , BOSoK , CreateThread( 0 , 0 , tmGorillaRawF , 0 , 0 , 0 ) )
        inc02AM( cThreads ) ;
        idTry ++ ;
    {
    while( !bQuit )
    ZE( countT , idTry ) ;
    ZE( HANDLE , osht ) ;

    }
        CONoUTrAW5( "[msSinceBoot,idt]:    " , ((tinFullS&)tinBaseP).brcRaw - msAtBoot , "    " , idt , "\r\n" ) ;
        BOSdOnOTtEST( WHATgbo , GetTickCount() )
    {
    if( !( idt % TUCK ) )
    OSsLEEPf( 0 ) ;

    tinBaseS&   tinBaseP     = *pTinMain ;
    countT  idt      = 1 + incv02AM( idtLath ) ;
{
DWORD WINAPI tmGorillaRawF( LPVOID pvArgP )






        }
            return threadLocalStorageF( ifcIDtYPEtLS_KID , tmGorillaF_workF , (countT)argP , 0 , 0 , 0 , 0 , "tmGorillaF" ) ;
        {
        countT __export OSF tmGorillaF( voidT* argP )

        }
            return POOP ? ifcEXITcODE_THREADiMPOTENT : ifcEXITcODE_THREADaOK ;
            }
                CONoUTrAW5( "[idt,idSubType]: " , idt , " " , idSubType , "\r\n" ) ;
                idSubType = POOP ;_
                TINSL ;_
            {
            ZE( countT , idSubType ) ;_
            }
                }
                    dec02AM( cAllThreads ) ; /* MUST BE THE VERY LAST THING THAT THIS THREAD DOES */
                    if( !bFake ) { DEL( pTaskP ) ; } /* MUST BE AS LATE AS POSSIBLE BECAUSE IT GIVES THE SIGN THAT THE THREAD IS DONE.  THE PROCESS MUST SLEEP AFTER RECEIVING THIS SIGN BEFORE ENDING, SO THAT THIS THREAD CAN COMPLETE */
                    if( ((tinFullS&)tinBaseP).monitor.idThread <= ClOWtHREADS ) processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tinFullS&)tinBaseP).monitor.idThread ] = - 1 ;_
                    TELL( "DONE0: i am outa here" )
                    ;_
                        : thirdC::os_cAllKidThreadsI_IF( tinBaseP )
                        ? thirdC::os_cAllOrphanThreadsI_IF( tinBaseP )
                    countT& cAllThreads = bOrphan
                    boolT bFake   = pTaskP ? !!( F(pTaskP->flags) & flTHREADlAUNCH_FAKE   ) : 0 ;_
                    boolT bOrphan = pTaskP ? !!( F(pTaskP->flags) & flTHREADlAUNCH_ORPHAN ) : 0 ;_
                    TELL( "DONE0: deregistering myself from either cAllOrphanThreadsI or cAllKidThreadsI (my final act)" )
                    TINSL /*THIS IS NEEDED BECAUSE tinBaseP WAS DELETED IF I AM tmWindowsF */
                {

                }
                    }
                        }
                            }
                                pEtThread = 0 ;_
                                THREADmODE3rESTORE
                                TINSL
                                delete pEtThread ; /* tinBaseP IS DESTROYED HERE */
                                THREADmODE3oFF( flTHREADmODE3_DOnOTcaLLdELif )
                            {
                            if( *(countT*)&pEtThread )
                            DEL( ((tinFullS&)tinBaseP).pEtScratch ) ;_
                            DEL( ((tinFullS&)tinBaseP).pScoopEtThread ) ; /*CODEsYNC: 0010056 1020171 */
                            TELL( "DONE0: deleting etThread (and tinBaseP)" ) ;_
                            ((tinFullS&)tinBaseP).pEther = 0 ;_
                            TELL( "DONE0: testing poolOld" ) ;_

                            }
                                ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , psttThreadFile ) ;_
                                ((tinFullS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , psttThreadFile ) ;_
                                TELL( "DONE0: deleting thread file" ) ;_
                            {
                            if( psttThreadFile )
                        {
                        if( pEtThread ) /*THREADS THAT DELETE etThread EARLY: tmWindowsF*/
                        TINSL /*THIS IS NEEDED BECAUSE tinBaseP WAS DELETED IF I AM tmWindowsF */
                    {

                    }
                        }
                            if( ((tinFullS&)tinBaseP).monitor.idThread <= ClOWtHREADS && !( ++ processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tinFullS&)tinBaseP).monitor.idThread ] ) ) { BLAMMO ; }
                            if( ((tinFullS&)tinBaseP).idPhase1 < ifcIDpHASEtHREAD_EPILOGnOkIDS ) ((tinFullS&)tinBaseP).idPhase1 = ifcIDpHASEtHREAD_EPILOGnOkIDS ;_
                            }
                                TELL( "DONE0: destroying all adam objects that remain on the thread stack" ) ;_
                                }
                                    while( ((tinFullS&)tinBaseP).cKidThreads ) { ++ s ; thirdC::dosSleepRawIF( tinBaseP , 250 ) ; }
                                    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ; /* WILL BLAMMO IF ANYTHING IS GRABBED (THIS IS DESIRABLE BEHAVIOR) */
                                {
                                TELL( "DONE0: waiting for my kid threads to end" ) ;_

                                if( F(thirdC::third_flagsModeAdam1I_IF(tinBaseP)) & flADAMmODE1_WHEREaLL && !( F(((tinFullS&)tinBaseP).monitor.flagsThreadMode1) & flTHREADmODE1_NOwHERE ) ) etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_UNWATCH ) ;_
                                TELL( "DONE0: conditionally calling etherWhereF" ) ;_
                            {
                            else
                            if( !pEtThread ) ; /*THIS IS NEEDED BECAUSE tinBaseP WAS DELETED IF I AM tmWindowsF */

                            TELL( "DONE0: after returning from application code" ) ;_
                            ((tinFullS&)tinBaseP).idPhase2 = 0 ;_
                            if( ((tinFullS&)tinBaseP).idPhase1 < ifcIDpHASEtHREAD_EPILOGkIDS ) ((tinFullS&)tinBaseP).idPhase1 = ifcIDpHASEtHREAD_EPILOGkIDS ;_
                            if( ((tinFullS&)tinBaseP).monitor.idThread <= ClOWtHREADS && !( ++ processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tinFullS&)tinBaseP).monitor.idThread ] ) ) { BLAMMO ; }
                            TINSL /*THIS IS NEEDED BECAUSE tinBaseP WAS DELETED IF I AM tmWindowsF */
                        {

                        etThread.osThreadSwitchingDesireF( tinBaseP , ifcTHREADpRIORITY_PUSHY ) ; /*TO PREVENT LAME DUCK THREADS FROM ACCUMULATING AND CLOGGING SYS*/

                        /*DO NOT CLOSE THE CODE BLOCK HERE BECAUSE KID THREADS MIGHT BE USING OBJECTS THAT WOULD DT HERE*/




}
    dec02AM( cThreads ) ;_

    }
        }
            }
                OSsLEEPf( 1000 ) ;_
                CONoUTrAW5( "Could not create thread [idt,idTry]: " , idt , " " , idTry , ".  Napping for 1 second.\r\n" ) ;_
                dec02AM( cThreads ) ;_
                POOPR

                CONoUTrAW( "X" ) ;_
            {
            else
            }
                break ;
                CONoUTrAW( "." ) ;_
            {
            if( !POOP )

            ((tinFullS&)tinBaseP).pEtScratch->osThreadF( tinBaseP , countTC() , tmGorillaF , 0 , 0 , 0  , flTHREADlAUNCH_ORPHAN ) ;_

            inc02AM( cThreads ) ;_
            idTry ++ ;_
        {
        while( !bQuit )
        ZE( countT , idTry ) ;_

        }
            CONoUTrAW5( "[msSinceBoot,idt]:    " , ((tinFullS&)tinBaseP).brcRaw - msAtBoot , "    " , idt , "\r\n" ) ;
            BOSdOnOTtEST( WHATgbo , GetTickCount() )
        {
        if( !( idt % TOCK ) )
        OSsLEEPf( 0 ) ;_
    {
    IFsCRATCH

    CONoUTrAW3( "tmGorillaF [idt]: " , idt , "\r\n" ) ;_

    idt      = 1 + incv02AM( idtLath ) ;_
{
if( pTaskP )




                    if( ((tinFullS&)tinBaseP).monitor.idThread <= ClOWtHREADS && !( ++ processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tinFullS&)tinBaseP).monitor.idThread ] ) ) { BLAMMO ; }
                    _IO_
                    if( ((tinFullS&)tinBaseP).idPhase1 < ifcIDpHASEtHREAD_WORKING ) ((tinFullS&)tinBaseP).idPhase1 = ifcIDpHASEtHREAD_WORKING ;_
                    (countT&)_stackTop = espAM() ;_
                    tlsBlobC _stackTop( tinBaseP , "appStackTop" , "tin" ) ;_
                    TELL( "TASK0: entering application code" )
                    if( F(thirdC::third_flagsModeAdam1I_IF(tinBaseP)) & flADAMmODE1_WHEREaLL && !( F(((tinFullS&)tinBaseP).monitor.flagsThreadMode1) & flTHREADmODE1_NOwHERE ) ) etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_WATCH ) ;_
                    }
                        etThread.boxPutF( tinBaseP , psttThreadFile , "T" ) ;_
                        etThread.strMakeF( tinBaseP , LF , psttThreadFile , T("///ideafarm/ephemeral/tmp/threads/")+TF1(((tinFullS&)tinBaseP).osPid)+tDot+TF1(DDNUMB)+tDot+T("tmGorillaF")+tDot+TF1(((tinFullS&)tinBaseP).monitor.idThread) ) ; ___( psttThreadFile ) ;_
                        TN( tDot , "." ) ;_
                    {
                    if( F( ((thirdC&)etThread).third_flagsModeAdam1I_IF( tinBaseP ) ) & flADAMmODE1_SEEtHREADSaSfILES )
                    etThread.osTimeNowF( tinBaseP , ((tinFullS&)tinBaseP).time1 , ((tinFullS&)tinBaseP).time2 ) ;_
                    /*etherC::ifcSayIF( T("ADAM CELL (idAdam,osPid): ")+TF1(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T(" ")+TF1(((tinFullS&)tinBaseP).osPid)+T(" ")+TF1(((tinFullS&)tinBaseP).osTid)+T(" \"")+T(((tinFullS&)tinBaseP).postThreadName)+T("\"") , flSAY_APPEND | flSAY_LOG ) ;*/
                {

                ((tinFullS&)tinBaseP).pEther = &etThread ;_
                TELL( "TASK0: final setup" )

                /*POPUP( TF1(((tinFullS&)tinBaseP).monitor.idThread)+T(" ")+T(((tinFullS&)tinBaseP).postThreadName)+T("\r\n") ) ;*/

                ((tinFullS&)tinBaseP).pScoopEtThread = new( 0 , tinBaseP , LF ) scoopC( tinBaseP , etThread ) ; ___( ((tinFullS&)tinBaseP).pScoopEtThread  ) ;_
                etherC& etThread  = *pEtThread ;_
            {
            if( pEtThread && ((tinFullS&)tinBaseP).pEtScratch )
            ZE( strokeS* , psttThreadFile ) ;_
            TELL( "TASK0: after newing etThread" )
            ((tinFullS&)tinBaseP).pEtScratch = new( 0 , tinBaseP , LF ) etherC( tinBaseP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ; ___( ((tinFullS&)tinBaseP).pEtScratch ) ;_
            etherC* pEtThread  = new( 0 , tinBaseP , LF ) etherC( tinBaseP , TAG( TAGiDnULL ) , flTHIRDmODE_TINoWNER | flTHIRDmODE_null ) ; ___( pEtThread ) ;_
            TELL( "TASK0: newing etThread" )

            if( pTaskP && F( pTaskP->flagsThreadMode1Dad ) & flTHREADmODE1_NOwHERE                 ) ((tinFullS&)tinBaseP).monitor.flagsThreadMode1 |= flTHREADmODE1_NOwHERE                 ;_
            if( pTaskP && F( pTaskP->flagsThreadMode2Dad ) & flTHREADmODE2_YELL                    ) ((tinFullS&)tinBaseP).flagsThreadMode2 |= flTHREADmODE2_YELL                    ;_
            if( pTaskP && F( pTaskP->flagsThreadMode2Dad ) & flTHREADmODE2_WATCHfORaSYNCHiMPOTENCE ) ((tinFullS&)tinBaseP).flagsThreadMode2 |= flTHREADmODE2_WATCHfORaSYNCHiMPOTENCE ;_
            if( pTaskP && F( pTaskP->flagsThreadMode2Dad ) & flTHREADmODE2_QUIETiMPOTENCE          ) ((tinFullS&)tinBaseP).flagsThreadMode2 |= flTHREADmODE2_QUIETiMPOTENCE          ;_
            if( pTaskP && F( pTaskP->flagsThreadMode2Dad ) & flTHREADmODE2_SHOWpROGRESS            ) ((tinFullS&)tinBaseP).flagsThreadMode2 |= flTHREADmODE2_SHOWpROGRESS            ;_
            TELL( "TASK0: setting flagsThreadMode2" )
            /*CODEsYNC: 00100df 0010055*/

            ((tinFullS&)tinBaseP).pcQuit = &(const countT&)ether ;_
            ((tinFullS&)tinBaseP).monitor.idProcessOld = thirdC::third_idProcessOldI_IF( tinBaseP ) ;_
            ((tinFullS&)tinBaseP).idlTask  = ifcLINE ;_
            ((tinFullS&)tinBaseP).idiTask  = DDNUMB ;_
            TELL( "TASK0: setting miscellaneous fields in tinBaseP" )
            etherC& etRock = etherC::etRockIF( tinBaseP ) ;_
            etherC& ether = etherC::etPrimeIF( tinBaseP ) ;_
            TINSL
        {
        if( bTinOk )
        ZE( countT , idt ) ;
        TELL( "TASK0: after newing either a tinFullS in the working poolOld" )
        /* AFTER THIS LINE, DO NOT CONSTRUCT ANY OBJECTS THAT HAVE DESTRUCTORS (BECAUSE DECREMENTING cAllKidThreadsI cAllOrphanThreadsI MUST BE THE VERY LAST THING THAT THIS THREAD DOES) */

        }
            }
                ___( pTin ) ;_
                TINSL
                /*pTinF() = pTin ;*/
                bTinOk = 1 ;_
            {
            if( pTin )
            tinBaseS* pTin = new( 0 , tinBaseP , LF ) tinFullS( tinBaseP , TAG( TAGiDnULL ) , pTaskP->idThread , pTinBaseDad , "tmGorillaF" , flTINs_null , ifcIDtINnAMED_tinInPool ) ;_
            TELL( "TASK0: newing a tinFullS in the working poolOld" )
            tinBaseS* const pTinBaseDad = F(pTaskP->flags) & flTHREADlAUNCH_ORPHAN ? 0 : &pTaskP->tinDad ;_
        {
        ZE( boolT , bTinOk ) ;_
        taskS* pTaskP = (taskS*)argP ;_
        TELL( "TASK0: workF+" )

        OStEXTcLEAR( _ostoTmp )
        osTextC _ostRangerTag( _ostoTmp.costF() + 1 , _ostoTmp , _statRangerTag , _statRangerTag.cbF() ) ;_
        tlsBlobC _statRangerTag( tinBaseP , "rangerTag" , "sys" , 2 * sizeof( countT ) + _ostoTmp.costF() + 1 , ifcIDtYPEtLSbLOBc_FOOT ) ;_
        OStEXTC(  _ostoTmp , ((tinFullS&)tinBaseP).monitor.idThread , 0 )
        OStEXTAK( _ostoTmp , "." )
        OStEXTA(  _ostoTmp , ((tinFullS&)tinBaseP).postThreadName )
        OStEXTAK( _ostoTmp , "RangerTag:threadStack." )
        OStEXTAK( _ostoTmp , "!ifc" )
        OStEXT(   _ostoTmp , 0x80 )

        _IO_ TELLsYSlIFInAME( "tmGorillaF" )
        if( ((tinFullS&)tinBaseP).monitor.idThread <= ClOWtHREADS && !( ++ processGlobal2S::_processGlobal2I_IF().pcPhaseLow[ ((tinFullS&)tinBaseP).monitor.idThread ] ) ) { BLAMMO ; }
        TINSL
    {
    countT tmGorillaF_workF( countT argP )

//TASK( tmGorillaF )

TASK0PROTO( tmGorillaF ) ;

//#define _ if( idtLath >= 0x162 ){ CONoUTrAW3( "[ifcLINE]: " , ifcLINE , "\r\n" ) ; }
#define _
//#define _ { CONoUTrAW3( "[ifcLINE]: " , ifcLINE , "\r\n" ) ; }

countT cThreads ;
boolT  bQuit ;
tinBaseS*  pTinMain ;
countT msAtBoot = ((tinFullS&)tinBaseP).brcRaw ;
BOSdOnOTtEST( WHATgbo , GetTickCount() )
countT idtLath ;

//20140915@1840: MOVED FROM SCRATCH 6 TO PERMANENT ADAM ID

/*1*/WAKEsHOW( "scr" )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

