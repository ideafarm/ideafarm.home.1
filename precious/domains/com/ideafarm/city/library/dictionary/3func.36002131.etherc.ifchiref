

//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return c4Result ;
    count4S c4Result( osTid , osPid , value , idDeathType ) ;

    }
        }
            }
                }
                    #endif
                
                        }
                            ifcJobF( tin0P , stCourses , ifcIDaDAM_2GLASS2 , sOrder , stOrders , psttOldCommentP , cTriesP , nicNameP ) ;
                            //ifcSayIF( T("hiring a ")+TF1(idAdamP)+T(" cell on ")+T(nicNameP) , flSAY_APPEND | flSAY_LOG ) ;
                            if( !nicNameP ) nicNameP = socketC::nicNameIF( tin0P , *this ) ;
                        
                            stOrders << new( 0 , tin0P , LF ) soulC( tin0P , *this , TAG( TAGiDnULL ) ) ;
                            stackC stOrders( tin0P , third , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                            sOrder << (countT)time2LimitP ;
                            sOrder << time1LimitP ;
                            sOrder << flagsP ;
                            sOrder << psttArgsP ;
                            sOrder << idAdamP ;
                            soulC sOrder( tin0P , *this , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDjOBoRDER_CONSTRUCTlOCALcELL ) ;
                            stackC stCourses( tin0P , third , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) ;
                        {
                        else
                        if( !third.ifc CellIsWorkingIF( tin0P , ifcIDaDAM_2GLASS2 , ".monitored" ) )
                        //THIS CODE IS OBSOLETE NOW THAT 6a4 IS NOT USED
                
                    #if defined( NEVERdEFINED )

                    }
                        else                                     osProcessF( tin0P , osTid , osPid , idAdamP                           , T("!idHome ")+TF1(processGlobal2I.idHome)+tPostscript+tb+(F(flProcessHire)&flPROCESShIRE_VISIBLE?tArgsUse:T("!quietConsole ")+tArgsUse) , flProcessHire ) ;
                        if( F(flagsP) & flHIRE_DISPLAYgRAPHICS ) osSessionF( tin0P , osTid , osPid , idAdamP                           , T("!idHome ")+TF1(processGlobal2I.idHome)+tb+tArgsUse , 0 , 0 , 0 , 0 , flSESSION_REGISTERpROCESShANDLE | flSESSION_REGISTERtHREADhANDLE | flSESSION_MAXIMIZE/*flSESSION_MINIMIZE*/ ) ;
                    {
                    else
                    }
                        else                                     osProcessF( tin0P , osTid , osPid , value , idDeathType , idAdamP , T("!idHome ")+TF1(processGlobal2I.idHome)+tPostscript+tb+(F(flProcessHire)&flPROCESShIRE_VISIBLE?tArgsUse:T("!quietConsole ")+tArgsUse) , flProcessHire ) ;
                        if( F(flagsP) & flHIRE_DISPLAYgRAPHICS ) osSessionF( tin0P , osTid , osPid , value , idDeathType , idAdamP , T("!idHome ")+TF1(processGlobal2I.idHome)+tb+tArgsUse , 0 , 0 , 0 , 0 , flSESSION_REGISTERpROCESShANDLE | flSESSION_REGISTERtHREADhANDLE | flSESSION_MAXIMIZE/*flSESSION_MINIMIZE*/ ) ;
                    {
                    else if( F(flagsP) & flHIRE_WAIT )
                    }
                        delF( tin0P , psttMapped ) ;
                        osProcessF( tin0P , osTid , osPid , T("wdw") , T(osfn)+T(" ")+TF3(idAdamP,flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(" !debug !idHome ")+TF1(processGlobal2I.idHome)+tPostscript+tb+tArgsUse , flProcessHire ) ;
                        osFileNameC osfn( tin0P , *this , T(psttMapped) ) ;
                        }
                            delF( tin0P , psttm ) ;
                            diskMapFileNameHoverF( tin0P , psttMapped , psttm ) ; ___( psttMapped ) ;
                            else                                     { diskMapFileNameF( tin0P , psttm , T("///ideafarm/ephemeral/city/park/exedll/1/hover/ideafarm.41000002.ipdos-we") ) ; ___( psttm ) ; }
                            if( F(flagsP) & flHIRE_DISPLAYgRAPHICS ) { diskMapFileNameF( tin0P , psttm , T("///ideafarm/ephemeral/city/park/exedll/1/hover/ideafarm.41000003.ipdos-we") ) ; ___( psttm ) ; }
                            ZE( strokeS* , psttm ) ;
                        {
                        ZE( strokeS* , psttMapped ) ;
                    {
                    if( F(flagsP) & flHIRE_DEBUG )
                    TN( tb , " " ) ;
                    TN( tPostscript , "" ) ; //NORMALLY NULL STRING; CONVENIENT FOR DEBUGGING

                    if( psttArgsP ) tArgsUse += /*tb+*/T(psttArgsP) ;
                    TN( tArgsUse , "" ) ; //U:: USE THIS ONLY IF NOT "PUSHY"; THIS IS SUPPRESSED MAINLY BECAUSE THE LONG ARGUMENT LIST MESSES UP THE DISPLAY OF PROCESS EXPLORER:  tArgsUse = tArgDesireProcess+tb+tArgDesireThread ;
                
                    //if( idAdamP == ifcIDaDAM_SECRETsERVICE                 && processGlobal2I.idHome != 3 ) flProcessHire &= ~( F(flPROCESShIRE_VISIBLE) ) ;
                    //if( idAdamP == ifcIDaDAM_3BANG   && processGlobal2I.idHome != 2 && processGlobal2I.idHome != 3 ) flProcessHire &= ~( F(flPROCESShIRE_VISIBLE) ) ;

                    else flProcessHire |= flPROCESShIRE_REGISTERpROCESShANDLE | flPROCESShIRE_REGISTERtHREADhANDLE ;        //A:ASSUME: CALLER WILL (EXPLICITLY OR IMPLICITELY) CALL dosWaitChildF (IF THIS IS NOT DONE THEN THESE 2 HANDLES WILL LEAK BY REMAINING REGISTERED)
                    }
                        if( F(flagsP) & flHIRE_MONITORkIDS ) flProcessHire |= flPROCESShIRE_MONITORkIDS ;
                        flProcessHire |= flPROCESShIRE_MONITORtHIS ;
                        //traceF( tin0P , T("ifcHireF: setting process flags to emit monitoring (debug) events") ) ;
                    {
                    if( F(flagsP) & flHIRE_MONITORtHIS )

                    ;
                            : flPROCESShIRE_VISIBLE
                            ? flPROCESShIRE_VISIBLE /*| flHIRE_DEBUG*/
                        : idAdamP == ifcIDaDAM_TIME
                        ? flPROCESShIRE_null
                    flagsT flProcessHire = F(flagsP) & flHIRE_DISPLAYnONE && !bSandbox

                    boolT bSandbox = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ;
                {
                if( !POOP )
            
                }
                    }
                        }
                            flagsP &= ~( F(flHIRE_DEBUG) ) ;
                            )
                                )
                                    // )
                                    //     ( processGlobal2I.idHome & 0x00ffffff ) != 2
                                    //     &&
                                    //     idAdamP == ifcIDaDAM_SUPERrANDOMnUMBERS
                                    // (
                                    // ||
                                    !( processGlobal2I.idHome & 0xff000000 )
                                (
                                &&
                                ( F(flagsP) & flHIRE_DEBUG )
                            (
                            if
                
                            //flagsP |= flHIRE_DISPLAYtEXT ;    // DISABLE IN PRODUCTION.
                            //flagsP |= flHIRE_DEBUG       ;    // DISABLE IN PRODUCTION.  ENABLE TO ALWAYS HIRE USING wdw
                
                            else if( !strCompareF( tin0P , tDisplay , T("none"   ) ) ) flagsP |= flHIRE_DISPLAYnONE     ;
                            else if( !strCompareF( tin0P , tDisplay , T("text"   ) ) ) flagsP |= flHIRE_DISPLAYtEXT     ;
                                 if( !strCompareF( tin0P , tDisplay , T("strokes") ) ) flagsP |= flHIRE_DISPLAYgRAPHICS ;
                                 if( !strCompareF( tin0P , tDebug   , T("yes"    ) ) ) flagsP |= flHIRE_DEBUG           ;
                
                            tDisplay = T(info2.psttDirectivesReplied) ;
                            tDebug   = T(info1.psttDirectivesReplied) ;
                            (*pPeekF)( &info2 ) ;
                            (*pPeekF)( &info1 ) ;
                
                            peekS info2( tin0P , *this , T("!display") ) ;
                            peekS info1( tin0P , *this , T("!debug") ) ;
                        {
                        if( pPeekF )
                        __Z( pPeekF ) ;
                        dllEntryF( tin0P , pPeekF , hDll , T("peekF") ) ;
                        ZE( peekFT , pPeekF ) ;
                    {
                    if( !POOP )

                    __( !hDll ) ;
                    }
                        dllOpenF( tin0P , hDll , tDll , cTriesP ) ;
                        TN( tDll , "" ) ; tDll = T("///ideafarm/ephemeral/city/park/exedll/1/hover/ideafarm.")+TF3(idAdamP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+T(".ipdos-wd") ;
                        _IO_
                    {
                    TN( tDisplay , "" ) ;
                    TN( tDebug , "" ) ;

                    flagsP &= ~( F( flHIRE_DEBUG | flHIRE_DISPLAYgRAPHICS | flHIRE_DISPLAYtEXT | flHIRE_DISPLAYnONE ) ) ;  // THESE ARE THE FLAGS THAT WILL BE SET "AUTOMATICALLY" I.E. BY QUERYING THE DLL
                {
                if( F(flagsP) & flHIRE_DISPLAYaUTO )
            
                handleC hDll( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_DLL ) ; //LEAVE THIS OPEN UNTIL AFTER osSessionF/osProcessF RETURNS, SO BASE OS DOES NOT LOAD IT 2 TIMES
            {
            if( /*((tin1S&)tin0P).pag1->idSerialAdam == 1 &&*/ !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_DOnOThIREaDAMS ) ) // SUPPRESSED FOR IN PROCESS KID ADAMS IN ORDER TO MAKE IT EASY TO SWITCH A SYSTEM'S RECONFIGURATON FROM SINGLEPROCESS TO MULTIPROCESS

            }
                POPUP( "I am trying to hire ifcIDaDAM_SMUDGEsOIXLoLDdEFS!" ) ;
                CONoUTrAW( "I am trying to hire ifcIDaDAM_SMUDGEsOIXLoLDdEFS!" ) ;
            {
            if( idAdamP == ifcIDaDAM_SMUDGEsOIXLoLDdEFS ) //U:: REMOVE AFTER TESTING FULL BUILD
        {
        //U:: TO FIND A BUG: if( !( F(thirdC::third_flagsModeProcess1I_IF()) & flMODEpROCESS1_DEBUG ) )

        TN( tArgDesireThread  , "" ) ; tArgDesireThread  = T("!idDesireThread "  )+TF2(ifcTHREADpRIORITY_PUSHY,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ; //U:: ADD AN OPTIONAL PAIR OF PARAMETERS TO SPECIFY THE PROCESS AND (MAIN) THREAD DESIRE ; THESE ARGUMENTS ARE PASSED ONLY IF NOT "PUSHY", SINCE "PUSHY" IS THE DEFAULT SET IN CT'OR FOR processGlobal2S
        TN( tArgDesireProcess , "" ) ; tArgDesireProcess = T("!idDesireProcess " )+TF2(ifcTHREADpRIORITY_PUSHY,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ; //U:: ADD AN OPTIONAL PAIR OF PARAMETERS TO SPECIFY THE PROCESS AND (MAIN) THREAD DESIRE ; THESE ARGUMENTS ARE PASSED ONLY IF NOT "PUSHY", SINCE "PUSHY" IS THE DEFAULT SET IN CT'OR FOR processGlobal2S

        TN( tb , " " ) ;

        //flagsP |= flHIRE_DEBUG ; //TO FIND A BUG

        if( !idAdamP ) idAdamP = ((tin1S&)tin0P).pag1->idAdam ;
    {
    if( !bSandbox )
    ZE( countT , idDeathType ) ;
    ZE( countT , value       ) ;
    ZE( countT , osPid       ) ;
    ZE( countT , osTid       ) ;

    }
        }
            break ;
            bSandbox = 0 ;
        {
        default                :
        }
            break ;
            bSandbox = 0 ;
        {
        case ifcIDaDAM_2GLASS2 :
        case ifcIDaDAM_GLASS1  :
        case ifcIDaDAM_CLOAK   :
        case ifcIDaDAM_ELF     :
        case ifcIDaDAM_EVE     :
        case ifcIDaDAM_ADAM    :
        // THIS IS FOR DEBUGGING CONVENIENCE ; ENABLING AND DISABLING THE case AND default LINES WILL NOT AFFECT PRODUCTION EXECUTION SINCE !fliIDhOME_HOMELESS
    {
    if( bSandbox ) switch( processGlobal1I.idAdamRoot )
    boolT bSandbox = !!( etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS ) ;

    _IO_

    }
        if( POOP ) return count4S() ;
        __( !psttOldCommentP->idAdam ) ;
        if( POOP ) return count4S() ;
        FV( flHIRE , flagsP ) ;
        __Z( psttOldCommentP ) ;
        if( POOP ) return count4S() ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/count4S etherC::ifcHireF( tin0S& tin0P , const strokeS* const psttOldCommentP , countT idAdamP , const strokeS* const psttArgsP , flagsT flagsP , const countT time1LimitP , const sCountT time2LimitP , const countT cTriesP , nicNameC nicNameP )/*1*/

/**/
*/
  defaults to nicNameC(), which implies the local host
 nicNameP
 cTriesP
 time2LimitP
 time1LimitP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.0010160.flHIRE!||
 flagsP
  can be 0
 psttArgsP
  if 0 then i hire myself
 idAdamP
  this title or comment is intended to facilitate debugging of ifc chat and can appear on ifc chat logs and console displays
  place the most unique and important words woth, as reports will truncate
  can be made unique by including time
  should be an informative short title for the current job
  must not be 0 and must not be null length
 psttOldCommentP
 tin0P
arguments
\<A HREF=\"5.1030170.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$ifcHireF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

