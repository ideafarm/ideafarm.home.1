
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tm_sessionsC_watchF )
}
    sessionsP.bQuitWatching = 0 ;

    }
        }
            //U::PROD: ++ s ; etThread.osSleepF( tinBaseP , TOCK >> 3 ) ;
            ++ s ; etThread.osSleepF( tinBaseP , TUCK << 2 ) ;
        {
        while( !sessionsP.bQuitWatching && cToDo -- )
        countT cToDo = TUCK ;
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        //etThread.traceF( tinBaseP , T("napping") ) ;

        }
            }
                DEL( pSession ) ;
                st_pSession >> *(countT*)&pSession ;
                ZE( sessionC* , pSession ) ;
            {
            while( st_pSession )
            etThread.traceF( tinBaseP , T("destroying sessions that have been idle too long") ) ;
        {
        if( st_pSession )

        sessionsP.baton.ungrabF( tinBaseP ) ;
        sessionsP.swSession.freeNullsF( tinBaseP ) ;
        }
            }
                c_pSession = 0 ;
                st_pSession << c_pSession ;
                countT& c_pSession = sessionsP.swSession ;
            {
            if( idle.time2 || idle.time1 > ifcTIMEtIMEOUTsESSION )
            timeS idle = session.idleF( tinBaseP ) ;

            sessionC& session = *(sessionC*)(countT)sessionsP.swSession ;
            sessionsP.nnLever_peer = *(nicNameC*)sessionsP.swSession.leverF( tinBaseP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = sessionsP.swSession.cFlavorsF( tinBaseP ) ;
        sessionsP.baton.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        _IO_

        //etThread.traceF( tinBaseP , T("inspecting sessions looking for those idle for a long time") ) ;
    {
    while( !etThread && !sessionsP.bQuitWatching )
    stackC st_pSession( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_XRAY ) ;

    sessionsC& sessionsP = *(sessionsC*)cArgThreadP ;

    countT& cArgThreadP = *(countT*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
/*1*/TASK( tm_sessionsC_watchF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

