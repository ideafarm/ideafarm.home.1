
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //}
    //    if( pEtherContainsMe ) pEtherContainsMe->ifcSayIF( tNNP+T(" NOT connected") , flSAY_APPEND | flSAY_LOG ) ;
    //{
    //else
    //}
    //    if( pEtherContainsMe ) pEtherContainsMe->ifcSayIF( tNNP+T(" connected") , flSAY_APPEND | flSAY_LOG ) ;
    //{
    //if( !POOP )

    }
        __1
        #endif

            __( ((tinFullS&)tinBaseP).brcRaw - WSABASEERR ) ;
            BOSdOnOTtEST( WHATgbo , WSAGetLastError() )

        #elif defined( __NT__ )

            __( ((tinFullS&)tinBaseP).brcRaw - SOCBASEERR ) ;
            BOSdOnOTtEST( WHATgbo , sock_errno() )

        #if defined( __OS2__ )
    {
    if( bFail )

    if( pks ) { __( s_unregisterTimeoutF( tinBaseP , handleP ) ) ; }
    }
        while( !*this && ( !pks || !pks->bKilled ) && ( bNoQuit || ( bNoQuitEarly && !thPrimeIF( tinBaseP ) ) || ( cTriesP && -- cTriesP ) ) ) ;
        }
            }
                break ;
                bFail = 0 ;

                //}
                //    ((tinFullS&)tinBaseP).pEther->traceF( tinBaseP , T("s_connectF / connect aok") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_1 ) ;
                //{
                //if( idPortP == 0x50 )   //U:: TO FIND A BUG
            {
            else
            }
                dosSleepIF( tinBaseP , TUCK * 0x40 ) ;
                ++ s ;

                #endif
                    if( ((tinFullS&)tinBaseP).brcLath == WSAENOTSOCK ) break ; //THIS WILL HAPPEN IF thirdC::s_cancelF IS CALLED ON handleP
                #elif defined( __NT__ )
                    //U:
                #if defined( __OS2__ )

                //}
                //    ((tinFullS&)tinBaseP).pEther->traceF( tinBaseP , T("s_connectF / connect failed") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_1 ) ;
                //{
                //if( idPortP == 0x50 )   //U:: TO FIND A BUG
            {
            if( ((tinFullS&)tinBaseP).bosFail )

            //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("s_connect [bFail,bKilled]:    ")+TF3(((tinFullS&)tinBaseP).bosFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,3)+T("    ")+TF2(pks->bKilled,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG

            //}
            //    ((tinFullS&)tinBaseP).brcRaw = _brcRawExp ;
            //    ((tinFullS&)tinBaseP).monitor.idWhat1 = _idWhatSaveBos ;
            //    }
            //        }
            //            /*if( F(POOP.flagsF()) & flPOOP_SMELLY ) { LOGrAW7( "BOS0   [brcLath,idLine,idiFile]: " , ((tinFullS&)tinBaseP).brcLath , " " , ((tinFullS&)tinBaseP).idLine_brcLath , " " , ((tinFullS&)tinBaseP).idiFile_brcLath , "\r\n" ) ; }*/
            //            ((tinFullS&)tinBaseP).idiFile_brcLath = DDNUMB ;
            //            ((tinFullS&)tinBaseP).idLine_brcLath = ifcLINE ;
            //            ((tinFullS&)tinBaseP).brcLath = ((tinFullS&)tinBaseP).brcQuery ;
            //        {
            //        if( ((tinFullS&)tinBaseP).brcQuery )
            //        ((tinFullS&)tinBaseP).brcQuery = _brcRaw ;
            //        _brcRaw -= WSABASEERR ;
            //        }
            //            }
            //                if( !( tally % CbOStALLYpERlOG ) ) logTallyIF( tally , LF , 0 , idMe , "WSAGetLastError()" ) ;
            //                countT tally = pg1.pHome->tallyHo.tallyF( idMe ) ;
            //                static countT idMe ;
            //            {
            //            if( pg1.pHome )
            //            processGlobal1S& pg1 = processGlobal1S::_processGlobal1I_IF() ;
            //            _brcRaw = (countT)(WSAGetLastError()) ;
            //        {
            //        ZE( countT , _brcRaw ) ;
            //    {
            //    if( ((tinFullS&)tinBaseP).bosFail )
            //    }
            //        if( !( tally % CbOStALLYpERlOG ) ) logTallyIF( tally , LF , ((tinFullS&)tinBaseP).bosFail , ((tinFullS&)tinBaseP).bosFail ? idMeFail : idMeOk , "connect( handleP.osF( ifcIDtYPEhANDLE_SOCKET ) , (sockaddr*)&info , sizeof info )" ) ;
            //        countT tally = processGlobal1I.pHome->tallyHo.tallyF( ((tinFullS&)tinBaseP).bosFail ? idMeFail : idMeOk ) ;
            //        static countT idMeFail ;
            //        static countT idMeOk ;
            //    {
            //    if( processGlobal1I.pHome )
            //    processGlobal1S& pg1 = processGlobal1S::_processGlobal1I_IF() ;
            //
            //
            //
            //
            //    }
            //        }
            //            s_setupIF( tinBaseP ) ;
            //            s_shutdown2IF( tinBaseP ) ;
            //        {
            //        if( rc == WSAECONNREFUSED )
            //        ((tinFullS&)tinBaseP).bosFail = 1 ;
            //        countT rc = WSAGetLastError() ;
            //    {
            //    if( _brcRawExp )
            //
            //    //((tinFullS&)tinBaseP).bosFail = !!_brcRawExp ;
            //
            //
            //
            //
            //    countT _brcRawExp = (countT)( connect( handleP.osF( ifcIDtYPEhANDLE_SOCKET ) , (sockaddr*)&info , sizeof info ) ) ;
            //    WHATsir
            //    countT _idWhatSaveBos = ((tinFullS&)tinBaseP).monitor.idWhat1 ;
            //{
            //20141124@1644: WEIRD BEHAVIOR: THE ((tinFullS&)tinBaseP).bosFail = !!_brcRawExp ; LINE WAS OBSERVED IN WDW TO SET handleP.osh TO -1 (THE VALUE OF _brcRawExp)

            BOSS( WHATsir , BOSfAIL , connect( handleP.osF( ifcIDtYPEhANDLE_SOCKET ) , (sockaddr*)&info , sizeof info ) )




            //}
            //    ((tinFullS&)tinBaseP).pEther->traceF( tinBaseP , T("s_connectF / connecting to port 05") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_1 ) ;
            //{
            //if( idPortP == 0x50 )   //U:: TO FIND A BUG


            //CONoUTrAW5( "" , ((tinFullS&)tinBaseP).pag1->idAdam , ": connecting to port " , idPortP , "\r\n" ) ;
    
            if( !handleP ) break ;
        {
        do
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    {
    boolT bFail = 1 ;
    boolT bNoQuitEarly = !cTriesP ;
    boolT bNoQuit = cTriesP == - 1 ;

    killSocketS* pks = time1P || time2P ? s_registerTimeoutF( tinBaseP , handleP , time1P , time2P ) : 0 ;

    //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("s_connect [sin_addr.s_addr,sin_port]: ")+TF3((countT)info.sin6_addr.s_addr,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,3)+T("    ")+TF2((countT)info.sin6_port,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    }
        pcTo[ 3 - offi ] = ((tinFullS&)tinBaseP).brcRaw ;
        BOSdOnOTtEST( WHATgbo , htonl( pcFrom[ offi ] ) )
    {
    for( countT offi = 0 ; offi < 4 ; offi ++ )
    const countT* pcFrom = nicName ;
    countT* pcTo   = (countT*)info.sin6_addr.u.Byte ;
    //CS:CODEsYNC: 350011ab 36001036

    info.sin6_port = (count01T)((tinFullS&)tinBaseP).brcRaw ;
    BOSdOnOTtEST( WHATgbo , htons( (count01T)idPortP ) )
    info.sin6_family = AF_INET6 ;
    c_memsetIF( tinBaseP , (byteT* const)&info , sizeof info ) ;
    sockaddr_in6 info ;
    if( !time1P && !time2P ) time1P = nicNameP ? TOCK * 2 : TUCK * 0x80 ;
    const nicNameC nicName = nicNameP ? nicNameP : nicNameC( NICnAMElOCAL ) ;
    //if( pEtherContainsMe ) pEtherContainsMe->ifcSayIF( tNNP+T(" connecting") , flSAY_APPEND | flSAY_LOG ) ;
    //TN( tNNP , "" ) ; tNNP = TF1(nicNameP)+T("(")+TF1(idPortP)+T(")") ;
    _IO_

    }
        if( POOP ) return ;
        IFsIMULATEoFFLINEpOOP
        __Z( idPortP ) ;
        __Z( handleP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT thirdC::s_connectF( tinBaseS& tinBaseP , handleC& handleP , const countT idPortP , const nicNameC nicNameP , countT cTriesP , countT time1P , const sCountT time2P )/*1*/

/**/
*/
  can be 0
 time2P
  if 0 then will default to a value that depends upon whether nicNameP is null
  can be 0
 time1P
  regardless of cTriesP, i will discontinue retrying if [time1P,time2P] elapses or if s_cancelF is called (by another thread) for handleP
  if - 1 then will retry forever even if thPrimeIF( tinBaseP ) is impotent
  if not 0 then will try cTriesP times (even if thPrimeIF( tinBaseP ) is impotent)
  if 0 then will retry forever unless thPrimeIF( tinBaseP ) is impotent
  can be 0
 cTriesP
  if 0 then the local host is implied
  can be 0
 nicNameP
  must not be 0
 idPortP
  must not be 0
 handleP
 tinBaseP
arguments
  \<A HREF=\"5.f840104.1.1.0.html\"\>f840104:  WAKEsHOW( "example.simplest.func.102003b.thirdC.s_connectF" )\</A\>
  \<A HREF=\"5.8e00104.1.1.0.html\"\>8e00104:  WAKEsHOW( "example.simplest.func.102003b.thirdC.s_connectF" )\</A\>
 simplest
examples
\<A HREF=\"5.102003b.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$s_connectF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

