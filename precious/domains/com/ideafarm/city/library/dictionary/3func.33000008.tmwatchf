
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmWatchF )

//((tin1S&)tin0P).pc Utility[ 0 ] -- ; //U::TO FIND A BUG
}
    TELL( "tmWatchF: cleaning up" ) ;
    
    //}
    //    }
    //        }
    //            pRootI->letRefF() ;
    //            ((thirdC&)etp).winPostMessageF( tin0P , *pRootI , idwm_CLOSE ) ;
    //        {
    //        if( pRootI )
    //        windowOldC* pRootI = windowOldC::getRefIF( tin0P ) ;
    //
    //        etherC etp( tin0P , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ;
    //        TELL( "posting CLOSE window message to the root window" ) ;
    //    {
    //    if( !( F(thirdC::third_flagsProcessStateI_IF(tin0P)) & flPROCESSsTATE_WM_CLOSE_RECEIVED ) )
    //{
    //if( b_tmWindows )
    //U::CONJ: THIS IS OBSOLETED BY displayC AND IS NOW REDUNDANT WITH THE PRECEDING LINE

    if( pDisplay) ((thirdC&)etThread).winPostMessageF( tin0P , *pDisplay , idwm_CLOSE ) ;
    displayC* pDisplay = displayC::pDisplayIF() ;
    
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //********                                 *****************************************************************************************************************************************************************************************************************************************
    //********    CLOSE THE DISPLAY WINDOW     *****************************************************************************************************************************************************************************************************************************************
    //********                                 *****************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************

    while( !etThread && ( thirdC::third_idPhaseAdam_IF( tin0P ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAIN2 || cAllKidThreadsI + cAllOrphanThreadsI > 1 + 2 * b_tmWindows ) ) ; // tmWatchF tmWindowsF tmAnimateSadamsOnPaperF
    }
        }
            //U: MAYBE POPUP A BOX SAYING THAT I BECAME IMPOTENT BUT AM NOW POTENT AND WILL TRY AGAIN
            etThread = 0 ;
        {
        if( etThread )
    
        #endif
        }
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLpURGE  ) 
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLrEPORT ) 
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLoFF    ) 
            }
                ++ s ; etThread.osSleepF( tin0P , TOCK * 4 ) ;
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            {
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLoN     ) 
            bArmed = 0 ;
            _IO_
        {
        if( bArmed && ++ idTry >= 0x8 && !etThread && cAllKidThreadsI + cAllOrphanThreadsI > 1 + 2 * b_tmWindows )
        static boolT bArmed = 1 ;
        static countT idTry ;
        #if defined( NEVERdEFINED )
        //U:: DISABLED PENDING DEBUG AND TUNE OF 6a4
        TELL( "cleaning up for this cycle" ) ;
    
        }
            while( cAllKidThreadsI + cAllOrphanThreadsI > 1 + 2 * b_tmWindows && cTries -- ) { ++ s ; etThread.osSleepF( tin0P , TUCK * 0x40 ) ; } // tmWindowsF tmAnimateSadamsOnPaperF
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            _IO_
        {
        countT cTries = 0x10 ;
        TELL( "waiting until i and tmWindowsF and tmAnimateSadamsOnPaperF are the only child threads" ) ;
    
        if( stTasksWhenQuitting.third ) stTasksWhenQuitting.third = 0 ;
        //THIS BLOCK CAN RACE WITH OTHER THREADS, AFFECTING WHETHER THEY CAN REGISTER ACCEPTORS, CATCHERS, QUITTERS, ETC.
        //THIS IS BAD STYLE.  IT IS DONE HERE TO GIVE tmWatchF EVERY CHANCE TO SUCCEED
        _IO_
    {
    do
    
    countT& cFaceClientsI            = ((tin1S&)tin0P).pag1->_etherC_.cFaceClients ;
    batonC& batFiringKids            = *((tin1S&)tin0P).pag1->_etherC_.pBatFiringKids ;
    boolT&  bNoNewKids               = ((tin1S&)tin0P).pag1->_etherC_.bNoNewKids ;
    stackC& stTasksWhenQuitting      = *((tin1S&)tin0P).pag1->_thirdC_.pStkTasksWhenQuitting ;
    flagsT& flQuittingI              = ((tin1S&)tin0P).pag1->_thirdC_.flQuitting ;
    countT& cAllOrphanThreadsI       = thirdC::os_cAllOrphanThreadsI_IF( tin0P ) ;
    countT& cAllKidThreadsI          = thirdC::os_cAllKidThreadsI_IF( tin0P ) ;
    TELL( "initializing references" ) ;
    
    ((thirdC&)etThread).thirdLaunchLateThreadsF( tin0P ) ;
    TELL( "launching late threads" ) ;

    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //********                            **********************************************************************************************************************************************************************************************************************************************
    //********    LAUNCH LATE THREADS     **********************************************************************************************************************************************************************************************************************************************
    //********                            **********************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************

    }
        if( ((tin1S&)tin0P).pag1->_etherC_.pCalledWhenFiredF ) (*((tin1S&)tin0P).pag1->_etherC_.pCalledWhenFiredF)( tin0P , ((tin1S&)tin0P).pag1->_etherC_.pCalledWhenFiredArg ? *((tin1S&)tin0P).pag1->_etherC_.pCalledWhenFiredArg : ze ) ;
        ZE( countT , ze ) ;
    {

    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //********                                   ***************************************************************************************************************************************************************************************************************************************
    //********    CALL "CALLBACK WHEN FIRED"     ***************************************************************************************************************************************************************************************************************************************
    //********                                   ***************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************

    ((tin1S&)tin0P).pag1->flagsAdam |= flADAM_FIRED ;
    etThread.osThreadSwitchingDesireF( tin0P , desireSave ) ;

    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //********                                                 *************************************************************************************************************************************************************************************************************************
    //********    POP THREAD PRIORITY AND SET flADAM_FIRED     *************************************************************************************************************************************************************************************************************************
    //********                                                 *************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************

    //}
    //    home.flags &= ~( F(flHOMEs_INoUTtRACE) ) ;
    //{
    //TELL( "resetting control flags (to default behavior)" ) ;

    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //********                                 *****************************************************************************************************************************************************************************************************************************************
    //********    CLEAR flHOMEs_INoUTtRACE     *****************************************************************************************************************************************************************************************************************************************
    //********                                 *****************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************

    }
        BLAMMO ;
        //homeS::homeIF().flags |= flHOMEs_KILLsELFiMMEDIATELY ;
        //thirdC::osFireIF( tin0P ) ;
        /**/etRock.traceF( tin0P , T("calling osFireIF, setting flHOMEs_KILLsELFiMMEDIATELY, and then calling BLAMMO because a file existed in ")+tDirBlammo ) ;
        etThread.diskFileOrDirDeleteF( tin0P , tDirBlammo , flFILEoRdIRdELETE_RECURSE , 1 ) ;
        _IO_
    {
    if( etThread.diskFileExistsF( tin0P , tDirBlammo+T("*") ) )
    //DUPLICATE CODE: 33000008 33000008

    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //********                                   ***************************************************************************************************************************************************************************************************************************************
    //********    OBEY BLAMMO SEMAPHORE FILE     ***************************************************************************************************************************************************************************************************************************************
    //********                                   ***************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************

    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //********                       ***************************************************************************************************************************************************************************************************************************************************
    //********    L O O P   E N D    ***************************************************************************************************************************************************************************************************************************************************
    //********                       ***************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************

    }
        /**/etRock.traceF( tin0P , T("tmWatchF / loop -- [((tin1S&)tin0P).pag1,((tin1S&)tin0P).pag1->ctWatch]:    ")+TF2((countT)((tin1S&)tin0P).pag1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(((tin1S&)tin0P).pag1->ctWatch,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        }
            ++ s ; etThread.osSleepF( tin0P , !ether ? TOCK : TOCK >> 3 ) ;
            _IO_
        {
        TELL( "napping for a tock" ) ;
        /**/etRock.traceF( tin0P , T("napping") ) ;

        //thirdC::osLogWrongNodeIF( tin0P ) ;

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                              ****************************************************************************************************************************************************************************************************************************
        //********    NAP FOR A TOCK (OR 1/8 TOCK IF FIRED)     ****************************************************************************************************************************************************************************************************************************
        //********                                              ****************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

#endif
        }
            etRock.traceF( tin0P , T("tmWatchF: traced  pool tallies 2") ) ;
            LOGrAW( T("[time,idAdam,tallyAll]: ")+TT(timeN1,timeN2)+T("    ")+TF2(((tin1S&)tin0P).pag1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(tallyAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
        
            etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
        
            }
                LOGrAW( T("    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(tally,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pczLever,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
            
                tallyAll += tally ;
                countT tally = swTally ;
                pczLever = (countT*)swTally.leverF( tin0P , idf ) ;
                _IO_
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swTally.cFlavorsF( tin0P ) ;
            ZE( countT , tallyAll ) ;
            
            poolC::reportIF( tin0P , pczLever , swTally ) ;
            switchC swTally( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , *(const countT**)&pczLever , 0 , 3 * sizeof( countT ) ) ;
            ZE( const countT* , pczLever ) ;
        
            LOGrAW3( "\r\npoolC tally report [idTick]: " , idCycle , "\r\n" ) ;
            etRock.traceF( tin0P , T("tmWatchF: tracing pool tallies 2") ) ;
            _IO_
        {
        if( !( idCycle % ( TUCK << 0 ) ) ) //APPROXIMATELY ONCE PER TICK
        //if( !( idCycle % ( TUCK << 4 ) ) ) //APPROXIMATELY ONCE PER HOUR
#if defined( NEVERdEFINED )
//U:: 20210220@1114: REMOVE THIS OLD CODE, WHICH IS REPLACED WITH THE PRECEDING (OLD: ALL poolC INSTANCES.  NEW: ONLY THE CURRENT poolC INSTANCE

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                                              ************************************************************************************************************************************************************************************************************
        //********    PERIODICALLY TRACE POOL TALLIES (ALL poolC INSTANCES)     ************************************************************************************************************************************************************************************************************
        //********                                                              ************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

#endif
        }
            etRock.traceF( tin0P , T("tmWatchF: traced pool tallies 1") ) ;
            etRock.tracePoolTalliesF( tin0P ) ;
            etRock.traceF( tin0P , T("tmWatchF: tracing pool tallies 1") ) ;
            etherC& etRock = etherC::etRockIF( tin0P ) ;
            _IO_
        {
        if( !( idCycle % ( TUCK << 4 ) ) ) //APPROXIMATELY ONCE PER HOUR
        //if( !( idCycle % ( TUCK >> 6 ) ) )
#if defined( NEVERdEFINED )
//20250527@1347: DISABLED TO DEBUG BASIC FUNCTION OF SERVERS
//20250503@1531: ENABLED TO STUDY WHETHER DNS IS LEAKING
//U:: COMMENTED OUT TO CONSERVE MEMORY WHILE STUDYING MEMORY USAGE

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                                                             *********************************************************************************************************************************************************************************************
        //********    PERIODICALLY TRACE POOL TALLIES (ONLY THE poolC INSTANCE THAT I USE)     *********************************************************************************************************************************************************************************************
        //********                                                                             *********************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

        //20210310@1246: ENABLED TO STUDY CHANNEL I/O BURN-IN TEST
        //20210228@0925: DISABLED
        //20210220@1100: ENABLED IN RESPONSE TO "OUT OF MEMORY" (CODE 8) WINDOWS ERROR
        //20130918@1315: THIS IS CPU COSTLY SO COMMENTED OUT.  AFAIK IT WORKS

        //}
        //    ((tin1S&)tin0P).pag4->_adamC_grab.ungrabF( tin0P ) ;
        //
        //    }
        //        pac = pac->pAdam ;
        //        pac->mannaF( tin0P , 1.0 ) ;
        //    {                
        //    while( pac )
        //    adamC* pac = ((tin1S&)tin0P).pag1->_adamC_pAdam ;
        //
        //    ((tin1S&)tin0P).pag4->_adamC_grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        //{
        //TELL( "distributing manna from heaven to adamC instances" ) ;
        //U::THIS IS DONE ACCORDING TO THE NUMBER OF SHARES THAT EACH adamC INSTANCE OWNS
        //U::SELL THE RESOURCE FLOW AND THEN DISTRIBUTE THE PROCEEDS EQUALLY TO ALL adamC INSTANCES THAT ARE ENTITLED TO A SHARE OF THAT

        //if( !( idCycle % ( TUCK << 0 ) ) ) etThread.trace F( tin0P , tSayTick ) ; //APPROXIMATELY ONCE PER TICK

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                         *************************************************************************************************************************************************************************************************************************************************
        //********    DISTRIBUTE MANNA     *************************************************************************************************************************************************************************************************************************************************
        //********                         *************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

#endif

        }
            /**/etRock.traceF( tin0P , T("cancelled  quitter sockets") ) ;
            }
                }
                    ++ s ; etThread.osSleepF( tin0P , TOCK ) ;
                    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                    _IO_
                {

                stQuitters.ungrabF( tin0P ) ;
                }
                    while( !etThread && !stQuitters.third && ~handle ) ;
                    }
                        }
                            //*((tin1S&)tin0P).pEtScratch = 0 ;
                            hSoc.closeIfF() ; //U::ELIMINATING ALL USAGE OF "shutdown" WIN32 API
                            //CONoUTrAW3( "tmWatchF/closing quitter handle at " , (countT)&hSoc , "\r\n" ) ; //U::
                            //((tin1S&)tin0P).pEtScratch->sockCancelF( tin0P , hSoc ) ;
                            //CONoUTrAW3( "********************* cancelling quitter socket " , (countT)pso , "\r\n" ) ;
                            //CONoUTrAW( "tmWatchF/cancelling a quitter socket\r\n" ) ;
                            handleC& hSoc = *(handleC*)&pso->handleF( tin0P ) ;
                            _IO_
                        {
                        if( pso )
                        __Z( pso ) ;
                        socketC* pso = (socketC*)stQuitters.downF( tin0P , handle ) ;
                        _IO_
                    {
                    do
                    handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( !etThread && !stQuitters.third && stQuitters )
                stQuitters.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                _IO_
            {
            while( !etThread && !stQuitters.third && stQuitters )
            TELL( "canceling quitter sockets/+" ) ;
            /**/etRock.traceF( tin0P , T("cancelling quitter sockets") ) ;
                
            //**********************************************************************************************************************************************************************************************************************************************************************************
            //**********************************************************************************************************************************************************************************************************************************************************************************
            //********                                    **************************************************************************************************************************************************************************************************************************************
            //********    CLOSING ALL QUITTER SOCKETS     **************************************************************************************************************************************************************************************************************************************
            //********                                    **************************************************************************************************************************************************************************************************************************************
            //**********************************************************************************************************************************************************************************************************************************************************************************
            //**********************************************************************************************************************************************************************************************************************************************************************************

            /**/etRock.traceF( tin0P , T("released  threads blocked catching socket datagrams") ) ;
            }
                stCatchers.ungrabF( tin0P ) ;
                }
                    while( !etThread && !stCatchers.third && ~handle ) ;
                    }
                        }
                            THREADmODE1rESTORE
                            }
                                if( POOP ) POOPR
                                sock.writeF( tin0P , (countT)*pso , nicNameC( 1 ) , ifcIDtYPEdATAGRAM_LETSaLLqUIT ) ;

                                /**/etRock.traceF( tin0P , T("[&sCatcher,idPortHe]:    ")+TfORsTRING((countT)pso)+tb4+TF4(idPortHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
                                countT idPortHe = (countT)*pso ;
                                socketC sock( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
                                _IO_
                            {
                            SCOOPS
                            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //LEGACYwORKAROUND
                            /**/etRock.traceF( tin0P , T("[&sCatcher]:    ")+TfORsTRING((countT)pso) ) ;
                            _IO_
                        {
                        if( pso ) 
                        __Z( pso ) ;
                        socketC* pso = (socketC*)stCatchers.downF( tin0P , handle ) ;
                        _IO_
                    {
                    do
                    handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    _IO_
                {
                if( !etThread && stCatchers )
                stCatchers.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                TN( tb4 , "    " ) ;
                _IO_
            {
            IFsCRATCHoK
            TELL( "releasing threads blocked catching socket datagrams" ) ;
            /**/etRock.traceF( tin0P , T("releasing threads blocked catching socket datagrams") ) ;
                
            //**********************************************************************************************************************************************************************************************************************************************************************************
            //**********************************************************************************************************************************************************************************************************************************************************************************
            //********                                                                **********************************************************************************************************************************************************************************************************
            //********    THROW DATAGRAMS TO ALL CATCHING SOCKETS TO RELEASE THEM     **********************************************************************************************************************************************************************************************************
            //********                                                                **********************************************************************************************************************************************************************************************************
            //**********************************************************************************************************************************************************************************************************************************************************************************
            //**********************************************************************************************************************************************************************************************************************************************************************************

            /**/etRock.traceF( tin0P , T("released  threads blocked listening for new socket client connections") ) ;
            stAcceptors.ungrabF( tin0P ) ;
            }
                while( !etThread && !stAcceptors.third && ~handle ) ;
                }
                    }
                        THREADmODE1rESTORE
                        }
                            if( POOP ) POOPR
                            sock.connectF( tin0P , (countT)*pso ) ;
                            socketC sock( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
                            SCOOPS
                            _IO_
                        {
                        IFsCRATCHoK
                        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) //LEGACYwORKAROUND
                        _IO_
                    {
                    if( pso ) 
                    __Z( pso ) ;
                    socketC* pso = (socketC*)stAcceptors.downF( tin0P , handle ) ;
                    _IO_
                {
                do
                handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                _IO_
            {
            if( !etThread && stAcceptors )
            stAcceptors.grabF( tin0P , TAG( TAGiDnULL ) ) ;
            /**/etRock.traceF( tin0P , T("releasing threads blocked listening for new socket client connections") ) ;
            TELL( "releasing threads blocked listening for new socket client connections" ) ;
            _IO_

            //**********************************************************************************************************************************************************************************************************************************************************************************
            //**********************************************************************************************************************************************************************************************************************************************************************************
            //********                                                         *****************************************************************************************************************************************************************************************************************
            //********    CONNECT TO ALL ACCEPTING SOCKETS TO RELEASE THEM     *****************************************************************************************************************************************************************************************************************
            //********                                                         *****************************************************************************************************************************************************************************************************************
            //**********************************************************************************************************************************************************************************************************************************************************************************
            //**********************************************************************************************************************************************************************************************************************************************************************************
        {
        if( ether )    

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                ******************************************************************************************************************************************************************************************************************************************
        //********    IF I HAVE BEEN FIRED...     ******************************************************************************************************************************************************************************************************************************************
        //********                                ******************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

        /**/etRock.traceF( tin0P , T("cancelled  sockets that are timed out idle") ) ;
        stIdleTimeouters.ungrabF( tin0P ) ;
        }
            while( !etThread && !stIdleTimeouters.third && ~handle ) ;
            }
                if( pso ) pso->cancelIfTimedOutF( tin0P ) ;
                __Z( pso ) ;
                socketC* pso = (socketC*)stIdleTimeouters.downF( tin0P , handle ) ;
            {
            do
            handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            _IO_
        {
        if( !etThread && stIdleTimeouters )
        stIdleTimeouters.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        if( stIdleTimeouters.third    ) stIdleTimeouters.third    = 0 ;
        TELL( "canceling sockets that are timed out" ) ;
        /**/etRock.traceF( tin0P , T("cancelling sockets that are timed out idle") ) ;

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                          ********************************************************************************************************************************************************************************************************************************
        //********    CANCEL SOCKETS THAT ARE TIMED OUT     ********************************************************************************************************************************************************************************************************************************
        //********                                          ********************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

#if defined( NEVERdEFINED )
//20250617@1512: ENABLED TO FIND ANOTHER BUG (DUT: SCRATCH f ON DNS1 AND GO1 SERVERS)
//U::20241124@1205: TO FIND A BUG ; ENABLE IN PRODUCTION

        /**/etRock.traceF( tin0P , T("setted /resetted  control flags") ) ;
        }
            }
                home.flags &= ~( F(flHOMEs_INoUTtRACE) ) ;
                if( F(home.flags) & flHOMEs_INoUTtRACE ) etRock.traceF( tin0P , T("flHOMEs_INoUTtRACE turned off") ) ;
            {
            else
            }
                home.flags |= flHOMEs_INoUTtRACE ;
                if( !( F(home.flags) & flHOMEs_INoUTtRACE ) ) etRock.traceF( tin0P , T("flHOMEs_INoUTtRACE turned on") ) ;
            {
            else if( etThread.diskFileExistsF( tin0P , tFileControlTraceOn ) )
            }
                etRock.traceF( tin0P , T("flHOMEs_INoUTtRACE off (control file created)") ) ;
                etThread.boxPutF( tin0P , tFileControlTraceOff , "The contents of this file do not matter.\r\nTo save space, use any plain text editor to make this an empty file.\r\nIf you delete this file, it wll be recreated in its default control directory.\r\nTo turn this control on or off, move this file to the \"on\" or the \"off\" folder." ) ;
                _IO_
            {
            if( !etThread.diskFileExistsF( tin0P , tFileControlTraceOff ) && !etThread.diskFileExistsF( tin0P , tFileControlTraceOn ) )
            _IO_
        {
        TELL( "setting/resetting control flags" ) ;
        /**/etRock.traceF( tin0P , T("setting/resetting control flags") ) ;
        
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                                                       ***************************************************************************************************************************************************************************************************
        //********    SET OR CLEAR flHOMEs_INoUTtRACE IN OBEDIENCE TO SEMAPHORE FILE     ***************************************************************************************************************************************************************************************************
        //********                                                                       ***************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

        }
            pRootI->letRefF() ;
                
            //Shell_NotifyIcon( NIM_ADD , &info ) ;
            //    
            //thirdC::c_strncpyIF( tin0P , info.szTip , oston , sizeof info.szTip ) ;
            //}
            //    OStEXTAK( oston , ")" )
            //    OStEXTC(  oston , processGlobal2I.idHome , 0 )
            //    OStEXTAK( oston , " (Home " )
            //{
            //if( processGlobal2I.idHome > 1 )
            //OStEXTAK( oston , "IPDOS (tm) IdeaFarm " "(tm) Piggyback Distributed Operating System" )
            //OStEXT( oston , 0x80 )
            //    
            //info.hIcon = LoadIcon( (HINSTANCE)thirdC::third_hWindowingClientIF( tin0P ).osF( ifcIDtYPEhANDLE_WINDOWINGcLIENT ) , MAKEINTRESOURCE( 1 ) ) ;
            //info.uCallbackMessage = idwm_TASKbARiCON ;
            //info.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP ;
            //info.uID = 0x1 ;
            //info.hWnd = (HWND)( (const handleC&)*pRootI ).osF( ifcIDtYPEhANDLE_WINDOW ) ;
            //info.cbSize = sizeof info ;
            //NOTIFYICONDATA info ;
        {
        if( pRootI )
        windowOldC* pRootI = windowOldC::getRefIF( tin0P ) ;

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                              ****************************************************************************************************************************************************************************************************************************
        //********    DECREMENT ROOT WINDOW REFERENCE COUNT     ****************************************************************************************************************************************************************************************************************************
        //********                                              ****************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

        //((tin1S&)tin0P).pag5->grabGrabWatch.ungrabF( tin0P ) ;
        //if( ((tin1S&)tin0P).pag1->pGrabWatch ) etRock.traceF( tin0P , T("U:: 20240706@1136: WHY WAS I B" "EEPING HERE?") ) ;
        //((tin1S&)tin0P).pag5->grabGrabWatch.grabF( tin0P , TAG( TAGiDnULL ) ) ;

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                      ************************************************************************************************************************************************************************************************************************************
        //********    TRACE EXCEPTION IF pGrabWatch     ************************************************************************************************************************************************************************************************************************************
        //********                                      ************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

        /**/etRock.traceF( tin0P , T("maybe fired  self (if version refused or cannot see driver or glass1 or glass2)") ) ;
        }
            }
                }
                    }
                        FIREmYSELF ;
                        LOGrAW3( "adam " , ((tin1S&)tin0P).pag1->idAdam ,  "'s tmWatchF cannot see the driver\r\n" ) ; // ifcIDaDAM_CLOAK AND ifcIDaDAM_GLASS1 ARE EXEMPT BECAUSE CLOAK LAUNCHES ifcIDaDAM_GLASS1 WHICH LAUNCHES THE ifcIDaDAM_2GLASS2
                    {
                    if( !( processGlobal2I.idHome & 0xff000000 ) && !thirdC::osTestWaterIF( tin0P , ifcIDtYPEtESTwATER_LOOKfORdRIVER ) )
                    _IO_
                {

                }
                    FIREmYSELF ; // 20200620@1605: ENABLED THIS WITHOUT ANALYSIS (VERSIONING ENFORCEMENT USES A DNS RECORD)
                    LOGrAW3( "adam " , ((tin1S&)tin0P).pag1->idAdam ,  "'s tmWatchF sees that this version has been refused\r\n" ) ;
                {
                if( F(home.flags) & flHOMEs_VERSIONrEFUSED )
                _IO_
            {
            )
                )
                    && !thirdC::osTestWaterIF( tin0P , ifcIDtYPEtESTwATER_LOOKfORdRIVER )
                    && !( processGlobal2I.idHome & 0xff000000 )
                       ( ((tin1S&)tin0P).pag1->idAdam != ifcIDaDAM_CLOAK && ((tin1S&)tin0P).pag1->idAdam != ifcIDaDAM_GLASS1 )
                (
                ||
                F(home.flags) & flHOMEs_VERSIONrEFUSED
            (
            /*else*/ if
            //THIS APPEARS TO BE NECESSARY BECAUSE GUI PROCESS GetCommandLine() DOES NOT PROVIDE THE EXE FILE'S PATH, SO IS FLAGGED AS HOMELESS (BUT NOT WHEN RUN IN WDW)
            //U::COMMENTED OUT AS A WORKAROUND WHILE GETTING GUI PROCESS TO WORK

            //if( cSkip && cSkip -- ) ; //GIVES THIS PROCESS TIME TO GET STARTED AOK (SOME PROCESSES FAIL IF FIRED VERY EARLY DURING STARTUP)
            //S: SECURITY HOLE: SKIPPING LIKE THIS WILL ALLOW CODE TO DO LOTS OF WORK IN THE 02 TOCKS BEFORE THE VERSION REFUSAL BECOMES EFFECTIVE
            _IO_
        {
        /**/etRock.traceF( tin0P , T("maybe firing self (if version refused or cannot see driver or glass1 or glass2)") ) ;

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                                                                         *********************************************************************************************************************************************************************************
        //********    FIRE MYSELF IF VERSION REFUSED OR CANNOT SEE DRIVER (DRIVER OR GLASS1 OR GLASS2)     *********************************************************************************************************************************************************************************
        //********                                                                                         *********************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

        /**/etRock.traceF( tin0P , T("maybe fired  self (if my fireall group has been fired)") ) ;
        }
            if( ether ) ;
            FIREmYSELF ;
            etRock.traceF( tin0P , T("my fireAll group has been fired") ) ;
        {
        if( ((tin1S&)tin0P).pag1->idGroupFireAll && ((tin1S&)tin0P).pag1->idGroupFireAll <= CfIREaLLrANKS && home.pFireAll[ ((tin1S&)tin0P).pag1->idGroupFireAll - 1 ].bFire )
        thirdC::dosPriorityProcessIF( tin0P ) ; //THIS ENFORCES RULE THAT USER CANNOT CHANGE THE PRIORITY CLASS OF AN IFC PROCESS; (IFC MAKES THIS ASSUMPTION SO THAT IT CAN USE YIELD WITHOUT HAVING CPU SPINS)
        /**/etRock.traceF( tin0P , T("maybe firing self (if my fireall group has been fired)") ) ;

        //CONoUTrAW5( "tmWatchF [ether,cThreadsFor _tmWatchF_toWatch]: " , ether , " " , ((tin1S&)tin0P).pag1->cThreadsFor _tmWatchF_toWatch , "\r\n" ) ;

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                                       *******************************************************************************************************************************************************************************************************************
        //********    FIRE MYSELF IF MY FIREaLL GROUP HAS BEEN FIRED     *******************************************************************************************************************************************************************************************************************
        //********                                                       *******************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

#endif
        }
            /**/etRock.traceF( tin0P , T("traced  a memory readability map") ) ;
            }
                }
                    }
                        etRock.traceF( tin0P , (strokeS*)postr , flTRACE_PARAMETERiSoStEXT /*| flTRACE_NOpREFIX*/ | flTRACE_KEEPcRlF ) ;
                        etherC::ifcBitDumpIF( tin0P , postr + sizeof postProlog - 1 , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;
                
                        thirdC::c_strcpyIF( tin0P , postr , postProlog ) ;
                        static osTextT postProlog[] = "memory readability dump:\r\n" ;
                        static byteT postr[ TUCK + CBrEADABILITYmAPdUMP ] ; // NOT THREAD SAFE WHEN A PROCESS IS RUNNING MULTIPLE ADAMS  U:: USE THE STACK SO IS THREAD SAFE
                    {
                    if( cbaNeeded == CBrEADABILITYmAPdUMP )
                                    
                    countT cbaNeeded = etherC::ifcBitDumpIF( tin0P , 0 , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;
                    countT cbGrain = thirdC::osMemoryReadabilityMapIF( tin0P , pbBits , sizeof pbBits ) ;
                                    
                    static byteT pbBits[ TUCK << 4 ] ; //EACH LINE OF REPORT WILL REPRESENT 1 TICK OF MEMORY
                    _IO_
                {
                // TRACE OUT A MEMORY READABILITY MAP TO SHOW HOW MUCH MEMORY OF THE ADDRESS SPACE IS NOT YET COMMITTED
        
                etRock.traceF( tin0P , T("tmWatchF: traced  pool tallies") ) ;
                etRock.tracePoolTalliesF( tin0P ) ;
                etRock.traceF( tin0P , T("tmWatchF: tracing pool tallies") ) ;
        
                etherC& etRock = etherC::etRockIF( tin0P ) ;
                _IO_
            {
            else
            if( !bTraceMemoryReadability ) /*;*/ etRock.traceF( tin0P , T("not tracing memory usage [idAdam]:    ")+TF2(((tin1S&)tin0P).pag1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            _IO_
            /**/etRock.traceF( tin0P , T("tracing a memory readability map") ) ;
        {
        if( !( idCycle % ( TUCK >> 1 ) ) )

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                           *******************************************************************************************************************************************************************************************************************************
        //********    TRACE OUT A MEMORY READABILITY MAP     *******************************************************************************************************************************************************************************************************************************
        //********                                           *******************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
#if defined( NEVERdEFINED )
//U::TO FIND A BUG (COMMENTED OUT TO STFU

        /**/etRock.traceF( tin0P , T("maybe fired  self (if key does not exist)") ) ;
        }
            FIREmYSELF ;
            etRock.traceF( tin0P , T("firing myself since keys not found") ) ;
        {
        if( bFireSelf )

        }
            }
                }
                    }
                        bFireSelf = 1 ;
                        etRock.traceF( tin0P , T("!exception: IdeaFarm (tm) keys not found") ) ;
                    {
                    else if( !idKeys )
                    }
                        etRock.traceF( tin0P , T("!exception: could not obtain idIdeaFarmKeys [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc) ) ;
                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )

                    count04T idKeys = ((tin1S&)tin0P).pEtScratch->idIdeaFarmKeysF( tin0P ) ;
                {
                if( !ether && !home.idIdeaFarmKeys )

                if( ((tin1S&)tin0P).pag1->idAdam == ifcIDaDAM_2GLASS2 ) home.idIdeaFarmKeys = etThread.idIdeaFarmKeysF( tin0P ) ;   //O: THIS OPTIMIZATION REDUCES CALLS TO WO PER TOCK WHEN GLASS2 IS RUNNING IN THE CURRENT HOME
                _IO_
            {

            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        ZE( boolT , bFireSelf ) ;
        /**/etRock.traceF( tin0P , T("maybe firing self (if key does not exist)") ) ;

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                                         *****************************************************************************************************************************************************************************************************************
        //********    FIRE SELF IF AN IdeaFarm (tm) Key DOES NOT EXIST     *****************************************************************************************************************************************************************************************************************
        //********                                                         *****************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

        }
            }
                /**/etRock.traceF( tin0P , T("cleared  sexC deleted bits") ) ;
                stPoolNames.ungrabF( tin0P ) ;
                }
                    while( ~hWalk ) ;
                    }
                        }
                            }
                                }
                                    reg.timeDeletedBitsClearedC2 = timeN2 ;
                                    reg.timeDeletedBitsClearedC1 = timeN1 ;

                                    thirdC::c_memsetIF( tin0P , reg.pbSexDeletedBits , sizeof reg.pbSexDeletedBits ) ;                               //ALL OF THIS RACES WITH OTHER PROCESSES BUT THAT DOES NOT MATTER
                                {
                                if( timeE2 || ( timeE1 > TICK ) )

                                etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , reg.timeDeletedBitsClearedC1 , reg.timeDeletedBitsClearedC2 ) ;
                                sCountT timeE2 = timeN2 ;
                                countT  timeE1 = timeN1 ;
                                _IO_
                            {
                            if( !thirdC::c_strcmpIF( tin0P , postName , reg.postPoolName ) )
                            
                            poolRegistrationS& reg = pRegs[ offr ] ;
                            _IO_
                        {
                        for( countT offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )
                        poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;

                        /**/etRock.traceF( tin0P , T(postName) ) ;
                        const osTextT* postName = (osTextT*)stPoolNames.downF( tin0P , hWalk ) ;
                        _IO_
                    {
                    do
                    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    _IO_
                {
                if( stPoolNames )
                stPoolNames.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT  , timeN1 ) ;

                /**/etRock.traceF( tin0P , T("clearing sexC deleted bits") ) ;
                _IO_
            {
            if( !( idCycle % TUCK ) )

            /**/etRock.traceF( tin0P , T("deleted  poolC empties") ) ;
            poolC::deleteEmptiesIfIF( tin0P ) ;
            /**/etRock.traceF( tin0P , T("deleting poolC empties") ) ;
            _IO_
        {
        if( ++ idCycle && !( idCycle % ( TUCK >> 4 ) ) )                                                                                                                           // SUPPRESSED FOR WOTH 01 TOCK TO ALLOW adamMainF TO CALL pMainF AND pMainF TO DO ITS INITIALIZATION ; THIS IS AN OPTIMIZATION TO AVOID UNNECESSARY DT/CT OF sexC INSTANCES WITH SAME SPECIFICATIONS

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                                                          ************************************************************************************************************************************************************************************************
        //********    OCCASIONALLY DELETE poolC EMPTIES AND CLEAR THE sexC DELETED BITS     ************************************************************************************************************************************************************************************************
        //********                                                                          ************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

        }
            BLAMMO ;
            //homeS::homeIF().flags |= flHOMEs_KILLsELFiMMEDIATELY ;
            //thirdC::osFireIF( tin0P ) ;
            /**/etRock.traceF( tin0P , T("calling osFireIF, setting flHOMEs_KILLsELFiMMEDIATELY, and then calling BLAMMO because a file existed in ")+tDirBlammo ) ;
            etThread.diskFileOrDirDeleteF( tin0P , tDirBlammo , flFILEoRdIRdELETE_RECURSE , 1 ) ;
            _IO_
        {
        if( etThread.diskFileExistsF( tin0P , tDirBlammo+T("*") ) )
        //DUPLICATE CODE: 33000008 33000008

        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //********                                   ***************************************************************************************************************************************************************************************************************************************
        //********    OBEY BLAMMO SEMAPHORE FILE     ***************************************************************************************************************************************************************************************************************************************
        //********                                   ***************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************
        //**********************************************************************************************************************************************************************************************************************************************************************************

        }
            BLAMMO ;
            etRock.traceF( tin0P , T("etRock is impotent") ) ;
        {
        if( etRock )

        /**/etRock.traceF( tin0P , T("tmWatchF / loop ++ [((tin1S&)tin0P).pag1,((tin1S&)tin0P).pag1->ctWatch]:    ")+TF2((countT)((tin1S&)tin0P).pag1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(((tin1S&)tin0P).pag1->ctWatch,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        _IO_
    {
    )
        )
            ((tin1S&)tin0P).pag1->ctWatch
            ||
            !ether
        (
        &&
        !etThread
    (
    while
    TN( tSayTick , "tick" ) ;
    TN( tDirBlammo , "" ) ; tDirBlammo = T("///ideafarm/controls/")+tUser+T("/blammo/") ;

    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //********                           ***********************************************************************************************************************************************************************************************************************************************
    //********    L O O P   B E G I N    ***********************************************************************************************************************************************************************************************************************************************
    //********                           ***********************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************
    //**********************************************************************************************************************************************************************************************************************************************************************************

//etherC::loafIF( tin0P ) ;  //20250622@1441: TO STUDY CPU CONSUMPTION BY tmWatchF, WHICH APPEARS TO BE A CPU HOG

    //}
    //    }
    //        if( !etThread.strCompareF( tin0P , psttc1 , tHit ) ) bTraceMemoryReadability = 1 ;
    //    {
    //    FORsTRINGSiN1( pstt1Param )
    //    TN( tHit , "zap..CDN_ACCESS_LOGS" ) ;
    //    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tin0P ) ;
    //{
    //if( ((tin1S&)tin0P).pag1->idAdam == ifcIDaDAM_CLOUD )

    //ZE( boolT , bTraceMemoryReadability ) ;

    ;
        ((tin1S&)tin0P).pag1->idAdam == ifcIDaDAM_2GLASS2
           //((tin1S&)tin0P).pag1->idAdam == ifcIDaDAM_ROOThTTPsERVER
    boolT bTraceMemoryReadability =                                  //U:: TO FIND A LEAK (DISABLE THIS IN PRODUCTION)

    countT desireSave = etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZY ) ;

    etThread.diskMakeDirIfNeededF( tin0P , tFileControlTraceOn  ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFileControlTraceOff ) ;
    TN( tFileControlTraceOn  , ""  ) ; tFileControlTraceOn  = T("///ideafarm/controls/")+tUser+T("/on"  "/in.out.trace.txt") ;
    TN( tFileControlTraceOff , ""  ) ; tFileControlTraceOff = T("///ideafarm/controls/")+tUser+T("/off" "/in.out.trace.txt") ;
    TN( tUser , thirdC::postUserNameIF() ) ;

    const boolT b_tmWindows = !!( F(thirdC::third_flagsModeAdam1I_IF(tin0P)) & flADAMmODE1_tmWindows ) ;
    //if( stQuitters.third          ) stQuitters.third          = 0 ;
    //if( stCatchers.third          ) stCatchers.third          = 0 ;
    //if( stAcceptors.third         ) stAcceptors.third         = 0 ;
    stackC& stPoolNames              = *((tin1S&)tin0P).pag1->_etherC_.pStkPoolNames ;
    stackC& stQuitters               = *((tin1S&)tin0P).pag1->_etherC_.pStkQuitters ;
    stackC& stCatchers               = *((tin1S&)tin0P).pag1->_etherC_.pStkCatchers ;
    stackC& stAcceptors              = *((tin1S&)tin0P).pag1->_etherC_.pStkAcceptors ;
    stackC& stIdleTimeouters = *((tin1S&)tin0P).pag1->_etherC_.pStkIdleTimeouters ;
    ZE( countT , idCycle ) ;
    //countT cSkip = 0x20 ;
    TN( tb4 , "    " ) ;
    TN( tb  , " "    ) ;

    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    ZE( countT , idLook ) ;

    ((tin123S&)tin0P).tell_tmWatchF_toIgnoreMeF() ;

    //U:://--------------------------------------------------------------------------
    //U::
    //U::    else if( getNegAM( pcn[ 0 ] ) != FINGERnEG_NAPfIREcELLmONITOR ) { BLAMMO ; }
    //U::    else if( napFireAll != 2 * sizeof( countT ) + CfIREaLLrANKS * sizeof( fireAllS ) ) { BLAMMO ; }
    //U::    }
    //U::        napFireAll.formattingIsDoneF( tin0P ) ;
    //U::        putNegAM( pcn[ 0 ] , FINGERnEG_NAPfIREcELLmONITOR ) ;
    //U::        pcn[ 1 ] = processGlobal1I.idAdamRoot ;
    //U::
    //U::        for( countT off = 0 ; off < CfIREaLLrANKS ; off ++ ) home.pFireAll[ off ].bFire = home.pFireAll[ off ].cHeartBeats = home.pFireAll[ off ].cHearts = 0 ;
    //U::        fireAllS* home.pFireAll = (fireAllS*)( pcn + 2 ) ;
    //U::    {
    //U::    else if( !( F(napFireAll.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
    //U::    if( !pcn ) { BLAMMO ; }
    //U::    countT* pcn = (countT*)(byteT*)napFireAll ;
    //U::    /* THIS IS CREATE SO THAT THE CELL MONITOR CAN BE RUN WITHOUT THE DRIVER (FOR DEBUGGING) */
    //U::    napkinC napFireAll( tin0P , LF , (byteT*)bits , "tmWatchF/napFireAll" , 0 , 2 * sizeof( countT ) + CfIREaLLrANKS * sizeof( fireAllS ) ) ;
    //U::    bitsC bits( tin0P , CbITSlIFI , 0 , 1 ) ;
    //U::    /*CODE SYNCH: 1610009 0010262*/
    //U::
    //U:://--------------------------------------------------------------------------

    homeS& home = homeS::homeIF() ;

    TELL( "waiting for asynch impotence" ) ;
    //__( ((tin1S&)tin0P).glass.idThread - ifcIDtHREADlOW_tmWatchF ) ;

    }
        sgnWatchReady.giveF( tin0P ) ;
        sgnWindowsReady.waitF( tin0P ) ;

        signC& sgnWindowsReady = *(signC*)pTaskP->c2 ;
        signC& sgnWatchReady   = *(signC*)pTaskP->c1 ;
    {
    //I CANNOT JUST LAUNCH tmWatchF LATER BECAUSE THAT WOULD CHANGE idThread VALUES FOR SYSTEM THREADS (MY idThread WOULD DEPEND UPON WINDOWING AND PROBABLY ALSO ON A RACE CONDITION INVOLVING THREAD STARTUP)
    //THIS BLOCK IS TO ENSURE THAT tmWindowsF AND tmAnimateSadamsF GET STARTED BEFORE I CHECK FOR THEIR PRESENCE

    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
//((tin1S&)tin0P).pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
/*1*/TASK( tmWatchF )/*1*/
/**/
*/
/*

/**/
*/
then i cause tmWindowsF to end
i wait for all other child threads other than tmWindowsF to end
\<A HREF=\"5.0b00013.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$tmWatchF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

