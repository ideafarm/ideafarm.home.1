
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmWatchF )

//((tinNormalS&)tinBaseP).pc Utility[ 0 ] -- ; //U::TO FIND A BUG
}
    TELL( "tmWatchF: cleaning up" ) ;
    
    //}
    //    }
    //        }
    //            pRootI->letRefF() ;
    //            ((thirdC&)etp).winPostMessageF( tinBaseP , *pRootI , idwm_CLOSE ) ;
    //        {
    //        if( pRootI )
    //        windowOldC* pRootI = windowOldC::getRefIF( tinBaseP ) ;
    //
    //        etherC etp( tinBaseP , TAG( TAGiDnULL ) , flTHIRDmODE_IMPOTENCEeXPECTED ) ;
    //        TELL( "posting CLOSE window message to the root window" ) ;
    //    {
    //    if( !( F(thirdC::third_flagsProcessStateI_IF(tinBaseP)) & flPROCESSsTATE_WM_CLOSE_RECEIVED ) )
    //{
    //if( b_tmWindows )
    //U::CONJ: THIS IS OBSOLETED BY displayC AND IS NOW REDUNDANT WITH THE PRECEDING LINE

    if( pDisplay) ((thirdC&)etThread).winPostMessageF( tinBaseP , *pDisplay , idwm_CLOSE ) ;
    displayC* pDisplay = displayC::pDisplayIF() ;
    
    while( !etThread && ( thirdC::third_idPhaseAdam_IF( tinBaseP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAIN2 || cAllKidThreadsI + cAllOrphanThreadsI > 1 + 2 * b_tmWindows ) ) ; // tmWatchF tmWindowsF tmAnimateSadamsOnPaperF
    }
        }
            //U: MAYBE POPUP A BOX SAYING THAT I BECAME IMPOTENT BUT AM NOW POTENT AND WILL TRY AGAIN
            etThread = 0 ;
        {
        if( etThread )
    
        #endif
        }
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLpURGE  ) 
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLrEPORT ) 
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLoFF    ) 
            }
                ++ s ; etThread.osSleepF( tinBaseP , TOCK * 4 ) ;
                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
            {
            ;//TELLsYSc1( ifcIDtYPEtELLsYS_WHEREaLLoN     ) 
            bArmed = 0 ;
        {
        if( bArmed && ++ idTry >= 0x8 && !etThread && cAllKidThreadsI + cAllOrphanThreadsI > 1 + 2 * b_tmWindows )
        static boolT bArmed = 1 ;
        static countT idTry ;
        #if defined( NEVERdEFINED )
        //U:: DISABLED PENDING DEBUG AND TUNE OF 6a4
        TELL( "cleaning up for this cycle" ) ;
    
        }
            while( cAllKidThreadsI + cAllOrphanThreadsI > 1 + 2 * b_tmWindows && cTries -- ) { ++ s ; etThread.osSleepF( tinBaseP , TUCK * 0x40 ) ; } // tmWindowsF tmAnimateSadamsOnPaperF
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        {
        countT cTries = 0x10 ;
        TELL( "waiting until i and tmWindowsF and tmAnimateSadamsOnPaperF are the only child threads" ) ;
    
        if( stTasksWhenQuitting.third ) stTasksWhenQuitting.third = 0 ;
        //THIS BLOCK CAN RACE WITH OTHER THREADS, AFFECTING WHETHER THEY CAN REGISTER ACCEPTORS, CATCHERS, QUITTERS, ETC.
        //THIS IS BAD STYLE.  IT IS DONE HERE TO GIVE tmWatchF EVERY CHANCE TO SUCCEED
        _IO_
    {
    do
    
    countT& cFaceClientsI            = ((tinNormalS&)tinBaseP).pag1->_etherC_.cFaceClients ;
    batonC& batFiringKids            = *((tinNormalS&)tinBaseP).pag1->_etherC_.pBatFiringKids ;
    boolT&  bNoNewKids               = ((tinNormalS&)tinBaseP).pag1->_etherC_.bNoNewKids ;
    stackC& stTasksWhenQuitting      = *((tinNormalS&)tinBaseP).pag1->_thirdC_.pStkTasksWhenQuitting ;
    flagsT& flQuittingI              = ((tinNormalS&)tinBaseP).pag1->_thirdC_.flQuitting ;
    countT& cAllOrphanThreadsI       = thirdC::os_cAllOrphanThreadsI_IF( tinBaseP ) ;
    countT& cAllKidThreadsI          = thirdC::os_cAllKidThreadsI_IF( tinBaseP ) ;
    TELL( "initializing references" ) ;
    
    ((thirdC&)etThread).thirdLaunchLateThreadsF( tinBaseP ) ;
    TELL( "launching late threads" ) ;

    }
        if( ((tinNormalS&)tinBaseP).pag1->_etherC_.pCalledWhenFiredF ) (*((tinNormalS&)tinBaseP).pag1->_etherC_.pCalledWhenFiredF)( tinBaseP , ((tinNormalS&)tinBaseP).pag1->_etherC_.pCalledWhenFiredArg ? *((tinNormalS&)tinBaseP).pag1->_etherC_.pCalledWhenFiredArg : ze ) ;
        ZE( countT , ze ) ;
    {

    ((tinNormalS&)tinBaseP).pag1->flagsAdam |= flADAM_FIRED ;
    etThread.osThreadSwitchingDesireF( tinBaseP , desireSave ) ;

    //}
    //    home.flags &= ~( F(flHOMEs_INoUTtRACE) ) ;
    //{
    //TELL( "resetting control flags (to default behavior)" ) ;

    }
        BLAMMO ;
        //homeS::homeIF().flags |= flHOMEs_KILLsELFiMMEDIATELY ;
        //thirdC::osFireIF( tinBaseP ) ;
        //etThread.traceF( tinBaseP , T("calling osFireIF, setting flHOMEs_KILLsELFiMMEDIATELY, and then calling BLAMMO because a file existed in ")+tDirBlammo ) ;
        etThread.diskFileOrDirDeleteF( tinBaseP , tDirBlammo , flFILEoRdIRdELETE_RECURSE , 1 ) ;
        _IO_
    {
    if( etThread.diskFileExistsF( tinBaseP , tDirBlammo+T("*") ) )
    //DUPLICATE CODE: 33000008 33000008

    }
        ++ s ; etThread.osSleepF( tinBaseP , !ether ? TOCK : TOCK >> 3 ) ;
        TELL( "napping for a tock" ) ;

        //thirdC::osLogWrongNodeIF( tinBaseP ) ;

#endif
        }
            LOGrAW( T("[time,idAdam,tallyAll]: ")+TT(timeN1,timeN2)+T("    ")+TF2(((tinNormalS&)tinBaseP).pag1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(tallyAll,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
        
            etThread.osTimeNowF( tinBaseP , timeN1 , timeN2 ) ;
            ZE( sCountT , timeN2 ) ;
            ZE( countT , timeN1 ) ;
        
            }
                LOGrAW( T("    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(tally,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pczLever,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("\r\n") ) ;
            
                tallyAll += tally ;
                countT tally = swTally ;
                pczLever = (countT*)swTally.leverF( tinBaseP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swTally.cFlavorsF( tinBaseP ) ;
            ZE( countT , tallyAll ) ;
            
            poolC::reportIF( tinBaseP , pczLever , swTally ) ;
            switchC swTally( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , *(const countT**)&pczLever , 0 , 3 * sizeof( countT ) ) ;
            ZE( const countT* , pczLever ) ;
        
            LOGrAW3( "\r\npoolC tally report [idTick]: " , idCycle , "\r\n" ) ;
            _IO_
        {
        if( !( idCycle % ( TUCK << 0 ) ) ) //APPROXIMATELY ONCE PER TICK
        //if( !( idCycle % ( TUCK << 4 ) ) ) //APPROXIMATELY ONCE PER HOUR
#if defined( NEVERdEFINED )
//U:: 20210220@1114: REMOVE THIS OLD CODE, WHICH IS REPLACED WITH THE PRECEDING (OLD: ALL poolC INSTANCES.  NEW: ONLY THE CURRENT poolC INSTANCE

#endif
        }
            etRock.traceF( tinBaseP , T("tmWatchF: traced pool tallies") ) ;
            etRock.tracePoolTalliesF( tinBaseP ) ;
            etRock.traceF( tinBaseP , T("tmWatchF: tracing pool tallies") ) ;
            etherC& etRock = etherC::etRockIF( tinBaseP ) ;
        {
        //U::if( !( idCycle % ( TUCK << 4 ) ) ) //APPROXIMATELY ONCE PER HOUR
        if( !( idCycle % ( TUCK >> 6 ) ) )
#if defined( NEVERdEFINED )
//U:: COMMENTED OUT TO CONSERVE MEMORY WHILE STUDYING MEMORY USAGE

        //20210310@1246: ENABLED TO STUDY CHANNEL I/O BURN-IN TEST
        //20210228@0925: DISABLED
        //20210220@1100: ENABLED IN RESPONSE TO "OUT OF MEMORY" (CODE 8) WINDOWS ERROR
        //20130918@1315: THIS IS CPU COSTLY SO COMMENTED OUT.  AFAIK IT WORKS

        //}
        //    ((tinNormalS&)tinBaseP).pag4->_adamC_grab.ungrabF( tinBaseP ) ;
        //
        //    }
        //        pac = pac->pAdam ;
        //        pac->mannaF( tinBaseP , 1.0 ) ;
        //    {                
        //    while( pac )
        //    adamC* pac = ((tinNormalS&)tinBaseP).pag1->_adamC_pAdam ;
        //
        //    ((tinNormalS&)tinBaseP).pag4->_adamC_grab.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        //{
        //TELL( "distributing manna from heaven to adamC instances" ) ;
        //U::THIS IS DONE ACCORDING TO THE NUMBER OF SHARES THAT EACH adamC INSTANCE OWNS
        //U::SELL THE RESOURCE FLOW AND THEN DISTRIBUTE THE PROCEEDS EQUALLY TO ALL adamC INSTANCES THAT ARE ENTITLED TO A SHARE OF THAT

        if( !( idCycle % ( TUCK << 0 ) ) ) etThread.traceF( tinBaseP , tSayTick ) ; //APPROXIMATELY ONCE PER TICK

        }
            }
                }
                    ++ s ; etThread.osSleepF( tinBaseP , TOCK ) ;
                    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                {

                stQuitters.ungrabF( tinBaseP ) ;
                }
                    while( !etThread && !stQuitters.third && ~handle ) ;
                    }
                        }
                            //*((tinNormalS&)tinBaseP).pEtScratch = 0 ;
                            hSoc.closeIfF() ; //U::ELIMINATING ALL USAGE OF "shutdown" WIN32 API
                            //CONoUTrAW3( "tmWatchF/closing quitter handle at " , (countT)&hSoc , "\r\n" ) ; //U::
                            //((tinNormalS&)tinBaseP).pEtScratch->sockCancelF( tinBaseP , hSoc ) ;
                            //CONoUTrAW3( "********************* cancelling quitter socket " , (countT)pso , "\r\n" ) ;
                            //CONoUTrAW( "tmWatchF/cancelling a quitter socket\r\n" ) ;
                            handleC& hSoc = *(handleC*)&pso->handleF( tinBaseP ) ;
                        {
                        if( pso )
                        __Z( pso ) ;
                        socketC* pso = (socketC*)stQuitters.downF( tinBaseP , handle ) ;
                    {
                    do
                    handleC handle( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( !etThread && !stQuitters.third && stQuitters )
                stQuitters.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                _IO_
            {
            while( !etThread && !stQuitters.third && stQuitters )
            TELL( "canceling quitter sockets/+" ) ;
                
            }
                stCatchers.ungrabF( tinBaseP ) ;
                }
                    while( !etThread && !stCatchers.third && ~handle ) ;
                    }
                        }
                            THREADmODE2rESTORE
                            }
                                if( POOP ) POOPR
                                sock.writeF( tinBaseP , (countT)*pso , nicNameC( 1 ) , ifcIDtYPEdATAGRAM_LETSaLLqUIT ) ;

                                //etThread.traceF( tinBaseP , T("[&sCatcher,idPortHe]:    ")+TfORsTRING((countT)pso)+tb4+TF4(idPortHe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa) ) ;
                                countT idPortHe = (countT)*pso ;
                                socketC sock( tinBaseP , *((tinNormalS&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
                            {
                            SCOOPS
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING ) //LEGACYwORKAROUND
                            //etThread.traceF( tinBaseP , T("[&sCatcher]:    ")+TfORsTRING((countT)pso) ) ;
                        {
                        if( pso ) 
                        __Z( pso ) ;
                        socketC* pso = (socketC*)stCatchers.downF( tinBaseP , handle ) ;
                    {
                    do
                    handleC handle( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( !etThread && stCatchers )
                stCatchers.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                TN( tb4 , "    " ) ;
                _IO_
            {
            IFsCRATCH
            TELL( "releasing threads blocked catching socket datagrams" ) ;
                
            stAcceptors.ungrabF( tinBaseP ) ;
            }
                while( !etThread && !stAcceptors.third && ~handle ) ;
                }
                    }
                        THREADmODE2rESTORE
                        }
                            if( POOP ) POOPR
                            sock.connectF( tinBaseP , (countT)*pso ) ;
                            socketC sock( tinBaseP , *((tinNormalS&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) ) ;
                            SCOOPS
                        {
                        IFsCRATCH
                        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING ) //LEGACYwORKAROUND
                    {
                    if( pso ) 
                    __Z( pso ) ;
                    socketC* pso = (socketC*)stAcceptors.downF( tinBaseP , handle ) ;
                {
                do
                handleC handle( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                _IO_
            {
            if( !etThread && stAcceptors )
            stAcceptors.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
            TELL( "releasing threads blocked listening for new socket client connections" ) ;
            _IO_
        {
        if( ether )    

        stIdleTimeouters.ungrabF( tinBaseP ) ;
        }
            while( !etThread && !stIdleTimeouters.third && ~handle ) ;
            }
                if( pso ) pso->cancelIfTimedOutF( tinBaseP ) ;
                __Z( pso ) ;
                socketC* pso = (socketC*)stIdleTimeouters.downF( tinBaseP , handle ) ;
            {
            do
            handleC handle( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            _IO_
        {
        if( !etThread && stIdleTimeouters )
        stIdleTimeouters.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        if( stIdleTimeouters.third    ) stIdleTimeouters.third    = 0 ;
        TELL( "canceling sockets that are timed out" ) ;

        }
            }
                home.flags &= ~( F(flHOMEs_INoUTtRACE) ) ;
                if( F(home.flags) & flHOMEs_INoUTtRACE ) etThread.traceF( tinBaseP , T("flHOMEs_INoUTtRACE turned off") ) ;
            {
            else
            }
                home.flags |= flHOMEs_INoUTtRACE ;
                if( !( F(home.flags) & flHOMEs_INoUTtRACE ) ) etThread.traceF( tinBaseP , T("flHOMEs_INoUTtRACE turned on") ) ;
            {
            else if( etThread.diskFileExistsF( tinBaseP , tOn ) )
            }
                etThread.traceF( tinBaseP , T("flHOMEs_INoUTtRACE off (control file created)") ) ;
                etThread.boxPutF( tinBaseP , tOff , "The contents of this file do not matter.\r\nTo save space, use any plain text editor to make this an empty file.\r\nIf you delete this file, it wll be recreated in its default control directory.\r\nTo turn this control on or off, move this file to the \"on\" or the \"off\" folder." ) ;
            {
            if( !etThread.diskFileExistsF( tinBaseP , tOff ) && !etThread.diskFileExistsF( tinBaseP , tOn ) )

            etThread.diskMakeDirIfNeededF( tinBaseP , tOn  ) ;
            etThread.diskMakeDirIfNeededF( tinBaseP , tOff ) ;
            TN( tOn  , ""  ) ; tOn  = T("///ideafarm/controls/")+tUser+T("/on/in.out.trace.txt") ;
            TN( tOff , ""  ) ; tOff = T("///ideafarm/controls/")+tUser+T("/off/in.out.trace.txt") ;
            TN( tUser , thirdC::postUserNameIF() ) ;
            _IO_
        {
        TELL( "setting/resetting control flags" ) ;
        
        }
            pRootI->letRefF() ;
                
            //Shell_NotifyIcon( NIM_ADD , &info ) ;
            //    
            //thirdC::c_strncpyIF( tinBaseP , info.szTip , oston , sizeof info.szTip ) ;
            //}
            //    OStEXTAK( oston , ")" )
            //    OStEXTC(  oston , processGlobal2I.idHome , 0 )
            //    OStEXTAK( oston , " (Home " )
            //{
            //if( processGlobal2I.idHome > 1 )
            //OStEXTAK( oston , "IPDOS (tm) IdeaFarm " "(tm) Piggyback Distributed Operating System" )
            //OStEXT( oston , 0x80 )
            //    
            //info.hIcon = LoadIcon( (HINSTANCE)thirdC::third_hWindowingClientIF( tinBaseP ).osF( ifcIDtYPEhANDLE_WINDOWINGcLIENT ) , MAKEINTRESOURCE( 1 ) ) ;
            //info.uCallbackMessage = idwm_TASKbARiCON ;
            //info.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP ;
            //info.uID = 0x1 ;
            //info.hWnd = (HWND)( (const handleC&)*pRootI ).osF( ifcIDtYPEhANDLE_WINDOW ) ;
            //info.cbSize = sizeof info ;
            //NOTIFYICONDATA info ;
        {
        if( pRootI )
        windowOldC* pRootI = windowOldC::getRefIF( tinBaseP ) ;

        ((tinNormalS&)tinBaseP).pag5->grabGrabWatch.ungrabF( tinBaseP ) ;
        if( ((tinNormalS&)tinBaseP).pag1->pGrabWatch ) etThread.traceF( tinBaseP , T("U:: 20240706@1136: WHY WAS I B" "EEPING HERE?") ) ;
        ((tinNormalS&)tinBaseP).pag5->grabGrabWatch.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

        }
            }
                }
                    }
                        FIREmYSELF ;
                        LOGrAW3( "adam " , ((tinNormalS&)tinBaseP).pag1->idAdam ,  "'s tmWatchF cannot see the driver\r\n" ) ; // ifcIDaDAM_CLOAK AND ifcIDaDAM_GLASS1 ARE EXEMPT BECAUSE CLOAK LAUNCHES ifcIDaDAM_GLASS1 WHICH LAUNCHES THE ifcIDaDAM_2GLASS2
                    {
                    if( !( processGlobal2I.idHome & 0xff000000 ) && !thirdC::osTestWaterIF( tinBaseP , ifcIDtYPEtESTwATER_LOOKfORdRIVER ) )
                    _IO_
                {

                }
                    FIREmYSELF ; // 20200620@1605: ENABLED THIS WITHOUT ANALYSIS (VERSIONING ENFORCEMENT USES A DNS RECORD)
                    LOGrAW3( "adam " , ((tinNormalS&)tinBaseP).pag1->idAdam ,  "'s tmWatchF sees that this version has been refused\r\n" ) ;
                {
                if( F(home.flags) & flHOMEs_VERSIONrEFUSED )
                _IO_
            {
            )
                )
                    && !thirdC::osTestWaterIF( tinBaseP , ifcIDtYPEtESTwATER_LOOKfORdRIVER )
                    && !( processGlobal2I.idHome & 0xff000000 )
                       ( ((tinNormalS&)tinBaseP).pag1->idAdam != ifcIDaDAM_CLOAK && ((tinNormalS&)tinBaseP).pag1->idAdam != ifcIDaDAM_GLASS1 )
                (
                ||
                F(home.flags) & flHOMEs_VERSIONrEFUSED
            (
            /*else*/ if
            //THIS APPEARS TO BE NECESSARY BECAUSE GUI PROCESS GetCommandLine() DOES NOT PROVIDE THE EXE FILE'S PATH, SO IS FLAGGED AS HOMELESS (BUT NOT WHEN RUN IN WDW)
            //U::COMMENTED OUT AS A WORKAROUND WHILE GETTING GUI PROCESS TO WORK

            //if( cSkip && cSkip -- ) ; //GIVES THIS PROCESS TIME TO GET STARTED AOK (SOME PROCESSES FAIL IF FIRED VERY EARLY DURING STARTUP)
            //S: SECURITY HOLE: SKIPPING LIKE THIS WILL ALLOW CODE TO DO LOTS OF WORK IN THE 02 TOCKS BEFORE THE VERSION REFUSAL BECOMES EFFECTIVE
            _IO_
        {

        }
            if( ether ) ;
            FIREmYSELF ;
            etThread.traceF( tinBaseP , T("my fireAll group has been fired") ) ;
        {
        if( ((tinNormalS&)tinBaseP).pag1->idGroupFireAll && ((tinNormalS&)tinBaseP).pag1->idGroupFireAll <= CfIREaLLrANKS && home.pFireAll[ ((tinNormalS&)tinBaseP).pag1->idGroupFireAll - 1 ].bFire )
        thirdC::dosPriorityProcessIF( tinBaseP ) ; //THIS ENFORCES RULE THAT USER CANNOT CHANGE THE PRIORITY CLASS OF AN IFC PROCESS; (IFC MAKES THIS ASSUMPTION SO THAT IT CAN USE YIELD WITHOUT HAVING CPU SPINS)

        //CONoUTrAW5( "tmWatchF [ether,cThreadsFor _tmWatchF_toWatch]: " , ether , " " , ((tinNormalS&)tinBaseP).pag1->cThreadsFor _tmWatchF_toWatch , "\r\n" ) ;

#endif
        }
            }
                }
                    }
                        etRock.traceF( tinBaseP , (strokeS*)postr , flTRACE_PARAMETERiSoStEXT /*| flTRACE_NOpREFIX*/ | flTRACE_KEEPcRlF ) ;
                        etherC::ifcBitDumpIF( tinBaseP , postr + sizeof postProlog - 1 , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;
                
                        thirdC::c_strcpyIF( tinBaseP , postr , postProlog ) ;
                        static osTextT postProlog[] = "memory readability dump:\r\n" ;
                        static byteT postr[ TUCK + CBrEADABILITYmAPdUMP ] ; // NOT THREAD SAFE WHEN A PROCESS IS RUNNING MULTIPLE ADAMS  U:: USE THE STACK SO IS THREAD SAFE
                    {
                    if( cbaNeeded == CBrEADABILITYmAPdUMP )
                                    
                    countT cbaNeeded = etherC::ifcBitDumpIF( tinBaseP , 0 , pbBits , sizeof pbBits * SB , TUCK , cbGrain ) ;
                    countT cbGrain = thirdC::osMemoryReadabilityMapIF( tinBaseP , pbBits , sizeof pbBits ) ;
                                    
                    static byteT pbBits[ TUCK << 4 ] ; //EACH LINE OF REPORT WILL REPRESENT 1 TICK OF MEMORY
                {
                // TRACE OUT A MEMORY READABILITY MAP TO SHOW HOW MUCH MEMORY OF THE ADDRESS SPACE IS NOT YET COMMITTED
        
                etRock.traceF( tinBaseP , T("tmWatchF: traced  pool tallies") ) ;
                etRock.tracePoolTalliesF( tinBaseP ) ;
                etRock.traceF( tinBaseP , T("tmWatchF: tracing pool tallies") ) ;
        
                etherC& etRock = etherC::etRockIF( tinBaseP ) ;
            {
            else
            if( !bTraceMemoryReadability ) ; // etRock.traceF( tinBaseP , T("not tracing memory usage [idAdam]:    ")+TF2(((tinNormalS&)tinBaseP).pag1->idAdam,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            _IO_
        {
        if( !( idCycle % ( TUCK >> 1 ) ) )
#if defined( NEVERdEFINED )
//U::TO FIND A BUG (COMMENTED OUT TO STFU

        }
            FIREmYSELF ;
            etThread.traceF( tinBaseP , T("firing myself since keys not found") ) ;
        {
        if( bFireSelf )

        }
            }
                }
                    }
                        bFireSelf = 1 ;
                        etThread.traceF( tinBaseP , T("!exception: IdeaFarm (tm) keys not found") ) ;
                    {
                    else if( !idKeys )
                    }
                        etThread.traceF( tinBaseP , T("!exception: could not obtain idIdeaFarmKeys [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc) ) ;
                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )

                    count04T idKeys = ((tinNormalS&)tinBaseP).pEtScratch->idIdeaFarmKeysF( tinBaseP ) ;
                {
                if( !ether && !home.idIdeaFarmKeys )

                if( ((tinNormalS&)tinBaseP).pag1->idAdam == ifcIDaDAM_2GLASS2 ) home.idIdeaFarmKeys = etThread.idIdeaFarmKeysF( tinBaseP ) ;   //O: THIS OPTIMIZATION REDUCES CALLS TO WO PER TOCK WHEN GLASS2 IS RUNNING IN THE CURRENT HOME

                homeS& home = homeS::homeIF() ;
                _IO_
            {

            SCOOPS
            _IO_
        {
        IFsCRATCH
        ZE( boolT , bFireSelf ) ;

        }
            }
                stPoolNames.ungrabF( tinBaseP ) ;
                }
                    while( ~hWalk ) ;
                    }
                        }
                            }
                                }
                                    reg.timeDeletedBitsClearedC2 = timeN2 ;
                                    reg.timeDeletedBitsClearedC1 = timeN1 ;

                                    thirdC::c_memsetIF( tinBaseP , reg.pbSexDeletedBits , sizeof reg.pbSexDeletedBits ) ;                               //ALL OF THIS RACES WITH OTHER PROCESSES BUT THAT DOES NOT MATTER
                                {
                                if( timeE2 || ( timeE1 > TICK ) )

                                etThread.osTimeSubtractF( tinBaseP , timeE1 , timeE2 , reg.timeDeletedBitsClearedC1 , reg.timeDeletedBitsClearedC2 ) ;
                                sCountT timeE2 = timeN2 ;
                                countT  timeE1 = timeN1 ;
                            {
                            if( !thirdC::c_strcmpIF( tinBaseP , postName , reg.postPoolName ) )
                            
                            poolRegistrationS& reg = pRegs[ offr ] ;
                        {
                        for( countT offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )
                        poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;
                        homeS& home = homeS::homeIF() ;

                        //etThread.traceF( tinBaseP , T(postName) ) ;
                        const osTextT* postName = (osTextT*)stPoolNames.downF( tinBaseP , hWalk ) ;
                    {
                    do
                    handleC hWalk( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( stPoolNames )
                stPoolNames.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                etThread.osTimeNowF( tinBaseP , timeN1 , timeN2 ) ;
                ZE( sCountT , timeN2 ) ;
                ZE( countT  , timeN1 ) ;
            {
            if( !( idCycle % TUCK ) )

            poolC::deleteEmptiesIfIF( tinBaseP ) ;
        {
        if( ++ idCycle && !( idCycle % ( TUCK >> 4 ) ) )                                                              // SUPPRESSED FOR WOTH 01 TOCK TO ALLOW adamMainF TO CALL pMainF AND pMainF TO DO ITS INITIALIZATION ; THIS IS AN OPTIMIZATION TO AVOID UNNECESSARY DT/CT OF sexC INSTANCES WITH SAME SPECIFICATIONS

        }
            BLAMMO ;
            //homeS::homeIF().flags |= flHOMEs_KILLsELFiMMEDIATELY ;
            //thirdC::osFireIF( tinBaseP ) ;
            //etThread.traceF( tinBaseP , T("calling osFireIF, setting flHOMEs_KILLsELFiMMEDIATELY, and then calling BLAMMO because a file existed in ")+tDirBlammo ) ;
            etThread.diskFileOrDirDeleteF( tinBaseP , tDirBlammo , flFILEoRdIRdELETE_RECURSE , 1 ) ;
            _IO_
        {
        if( etThread.diskFileExistsF( tinBaseP , tDirBlammo+T("*") ) )
        //DUPLICATE CODE: 33000008 33000008

        }
            BLAMMO ;
            etThread.traceF( tinBaseP , T("etRock is impotent") ) ;
        {
        if( etRock )

        //etThread.traceF( tinBaseP , T("tmWatchF / loop ++ [((tinNormalS&)tinBaseP).pag1,((tinNormalS&)tinBaseP).pag1->ctWatch]:    ")+TF2((countT)((tinNormalS&)tinBaseP).pag1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(((tinNormalS&)tinBaseP).pag1->ctWatch,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        _IO_
    {
    )
        )
            ((tinNormalS&)tinBaseP).pag1->ctWatch
            ||
            !ether
        (
        &&
        !etThread
    (
    while
    TN( tSayTick , "tick" ) ;
    TN( tDirBlammo , "" ) ; tDirBlammo = T("///ideafarm/controls/")+tUser+T("/blammo/") ;
    TN( tUser , thirdC::postUserNameIF() ) ;

    //}
    //    }
    //        if( !etThread.strCompareF( tinBaseP , psttc1 , tHit ) ) bTraceMemoryReadability = 1 ;
    //    {
    //    FORsTRINGSiN1( pstt1Param )
    //    TN( tHit , "zap..CDN_ACCESS_LOGS" ) ;
    //    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tinBaseP ) ;
    //{
    //if( ((tinNormalS&)tinBaseP).pag1->idAdam == ifcIDaDAM_CLOUD )

    //ZE( boolT , bTraceMemoryReadability ) ;

    ;
        ((tinNormalS&)tinBaseP).pag1->idAdam == ifcIDaDAM_2GLASS2
           //((tinNormalS&)tinBaseP).pag1->idAdam == ifcIDaDAM_ROOThTTPsERVER
    boolT bTraceMemoryReadability =                                  //U:: TO FIND A LEAK (DISABLE THIS IN PRODUCTION)

    countT desireSave = etThread.osThreadSwitchingDesireF( tinBaseP , ifcTHREADpRIORITY_LAZY ) ;

    const boolT b_tmWindows = !!( F(thirdC::third_flagsModeAdam1I_IF(tinBaseP)) & flADAMmODE1_tmWindows ) ;
    //if( stQuitters.third          ) stQuitters.third          = 0 ;
    //if( stCatchers.third          ) stCatchers.third          = 0 ;
    //if( stAcceptors.third         ) stAcceptors.third         = 0 ;
    stackC& stPoolNames              = *((tinNormalS&)tinBaseP).pag1->_etherC_.pStkPoolNames ;
    stackC& stQuitters               = *((tinNormalS&)tinBaseP).pag1->_etherC_.pStkQuitters ;
    stackC& stCatchers               = *((tinNormalS&)tinBaseP).pag1->_etherC_.pStkCatchers ;
    stackC& stAcceptors              = *((tinNormalS&)tinBaseP).pag1->_etherC_.pStkAcceptors ;
    stackC& stIdleTimeouters = *((tinNormalS&)tinBaseP).pag1->_etherC_.pStkIdleTimeouters ;
    ZE( countT , idCycle ) ;
    //countT cSkip = 0x20 ;
    TN( tb4 , "    " ) ;
    TN( tb  , " "    ) ;

    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    ZE( countT , idLook ) ;
    homeS& home = homeS::homeIF() ;

    ((tinNormalS&)tinBaseP).tell_tmWatchF_toIgnoreMeF() ;

    //U:://--------------------------------------------------------------------------
    //U::
    //U::    else if( getNegAM( pcn[ 0 ] ) != FINGERnEG_NAPfIREcELLmONITOR ) { BLAMMO ; }
    //U::    else if( napFireAll != 2 * sizeof( countT ) + CfIREaLLrANKS * sizeof( fireAllS ) ) { BLAMMO ; }
    //U::    }
    //U::        napFireAll.formattingIsDoneF( tinBaseP ) ;
    //U::        putNegAM( pcn[ 0 ] , FINGERnEG_NAPfIREcELLmONITOR ) ;
    //U::        pcn[ 1 ] = processGlobal1I.idAdamRoot ;
    //U::
    //U::        for( countT off = 0 ; off < CfIREaLLrANKS ; off ++ ) home.pFireAll[ off ].bFire = home.pFireAll[ off ].cHeartBeats = home.pFireAll[ off ].cHearts = 0 ;
    //U::        fireAllS* home.pFireAll = (fireAllS*)( pcn + 2 ) ;
    //U::    {
    //U::    else if( !( F(napFireAll.flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
    //U::    if( !pcn ) { BLAMMO ; }
    //U::    countT* pcn = (countT*)(byteT*)napFireAll ;
    //U::    /* THIS IS CREATE SO THAT THE CELL MONITOR CAN BE RUN WITHOUT THE DRIVER (FOR DEBUGGING) */
    //U::    napkinC napFireAll( tinBaseP , LF , (byteT*)bits , "tmWatchF/napFireAll" , 0 , 2 * sizeof( countT ) + CfIREaLLrANKS * sizeof( fireAllS ) ) ;
    //U::    bitsC bits( tinBaseP , CbITSlIFI , 0 , 1 ) ;
    //U::    /*CODE SYNCH: 1610009 0010262*/
    //U::
    //U:://--------------------------------------------------------------------------

    TELL( "waiting for asynch impotence" ) ;
    //__( ((tinNormalS&)tinBaseP).monitor.idThread - ifcIDtHREADlOW_tmWatchF ) ;

    }
        sgnWatchReady.giveF( tinBaseP ) ;
        sgnWindowsReady.waitF( tinBaseP ) ;

        signC& sgnWindowsReady = *(signC*)pTaskP->c2 ;
        signC& sgnWatchReady   = *(signC*)pTaskP->c1 ;
    {
    //I CANNOT JUST LAUNCH tmWatchF LATER BECAUSE THAT WOULD CHANGE idThread VALUES FOR SYSTEM THREADS (MY idThread WOULD DEPEND UPON WINDOWING AND PROBABLY ALSO ON A RACE CONDITION INVOLVING THREAD STARTUP)
    //THIS BLOCK IS TO ENSURE THAT tmWindowsF AND tmAnimateSadamsF GET STARTED BEFORE I CHECK FOR THEIR PRESENCE

    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
//((tinNormalS&)tinBaseP).pc Utility[ 0 ] ++ ; //U::TO FIND A BUG
/*1*/TASK( tmWatchF )/*1*/
/**/
*/
/*

/**/
*/
then i cause tmWindowsF to end
i wait for all other child threads other than tmWindowsF to end
\<A HREF=\"5.0b00013.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$tmWatchF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

