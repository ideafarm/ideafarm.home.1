
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    bQuit = 1 ;
    thirdC::osHireThenMonitorIF( tin0P , ifcIDaDAM_2GLASS2 , T("ifcIDaDAM_GLASS1") , T("!ignoreFireByOperator") ) ;

    etThread.osThreadF( TaRG2cBsTACK( tmLaunchBatExeFilesF , CBsTACKmIN << 1 ) , (countT)&bQuit ) ;
    ZE( boolT , bQuit ) ;

//    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE ) ;
//    thirdC::dosPriorityProcessIF(      tin0P , ifcTHREADpRIORITY_RUDE ) ;
{
if( pTaskP )
TASK( tmWorkF )

DONE( tmLaunchBatExeFilesF )
}
    }
        ++ s ; etThread.osSleepF( tin0P , TOCK >> 0 ) ;    //THIS IS FOR SAFETY TO PREVENT CPU PEGGING AT MY PUSHY DESIRE

        if( bCallingWait ) etRock.traceF( tin0P , T("calling diskWaitDirF") ) ;
        }
            if( bWoth ) bWoth = 0 ;

            }
                FORsTRINGSiNsPANNEDcOMBINEDtAIL1
                }
                    }
                        }
                            etThread.diskMoveFileOrDirF( tin0P , tLongTo , tLong ) ;

                            }
                                etThread.delF( tin0P , psttld ) ;
                                tLongTo = T(psttld) ;
                                etThread.strReplaceF( tin0P , psttld , tLong , T("/drop.executables/") , T(bWoth?"/ignored.executables/":"/done.executables/") ) ; ___( psttld ) ;
                                ZE( strokeS* , psttld ) ;
                            {
                            TN( tLongTo , "" ) ;

                            }
                                }
                                    }
                                        etThread.traceF( tin0P , T("!exception / could not launch [tLong]:    ")+tLong ) ;
                                        POOPRqUIET
                                    {
                                    if( POOP )

                                    CONoUTrAW( "\r\n" ) ;
                                    ((tin1S&)tin0P).pEtScratch->osProcessF( tin0P , countTC() , countTC() , countTC() , countTC() , tLong ) ;
                                    CONoUTrAW( "\r\n" ) ;

                                    SCOOPS
                                {
                                IFsCRATCHoK
                                etThread.traceF( tin0P , T("launching [tLong]:    ")+tLong ) ;
                            {                                                                       //A:ASSUME: FILES ARE STATELESS, IN THAT A FILE CAN BE OMITTED WITHOUT CHANGING THE OUTCOME OF THE PASS
                            if( !bWoth )                                                            //P:PERSONALITY: I PURGE ALL FILES THAT ARE WAITING FOR ME WHEN I START UP ; I ONLY HIRE FILES THAT ARE NEWLY DROPPED AFTER I START

                            etThread.delF( tin0P , psttm ) ;
                            TN( tLong , psttm ) ;
                            etThread.diskMapFileNameF( tin0P , psttm , psttc1 ) ; ___( psttm ) ;
                            ZE( strokeS* , psttm ) ;
                        {
                        if( etThread.strIdF( tin0P , tDotBat , psttc1 ) && !etThread.strIdF( tin0P , tDotHeyWritingDot , psttc1 ) )
                    {
                    if( psttc1[ CSpREFIX - 1 + psttc1->idAdam ].idAdam != '/' )                                 // IF NOT DIRECTORY
                {
                FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
                etThread.boxMenuF( tin0P , soul1m , tDrop+T("*") , 0 , TUCK ) ;
                soulC soul1m( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.launch.bat.and.exe" ) ;
            {
            if( bWoth || bChanged )

            if( !bWoth ) etThread.traceF( tin0P , T("waited  for a change [tDrop]:    ")+tDrop ) ;

            if( bQuitP ) break ;
            bCallingWait = 0 ;
            if( bCallingWait ) etRock.traceF( tin0P , T("called diskWaitDirF") ) ;
        {
        if( bWoth || ( bChanged = etThread.diskWaitDirF( tin0P , hWait , bQuitP , tDrop , TOCK << 4 , flWAITdIR_RECURSE | flWAITdIR_FILEnAME | flWAITdIR_DIRnAME ) , bChanged ) )     //P:PERSONALITY: FIRING ME HAS NO EFFECT ; I KEEP WORKING UNTIL THE KID PROCESS ENDS
        if( bCallingWait ) etRock.traceF( tin0P , T("calling diskWaitDirF") ) ;
        if( !bWoth ) etThread.traceF( tin0P , T("waiting for a change [tDrop]:    ")+tDrop ) ;
        boolT bCallingWait = !bWoth ;
        ZE( boolT , bChanged ) ;
    {
    while( !bQuitP && !POOP )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    boolT bWoth = 1 ;
    TN( tDotHeyWritingDot , ".!writing." ) ;
    TN( tDotBat , ".bat" ) ;

    etThread.diskMakeDirIfNeededF( tin0P , tIgnored ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tDone    ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tDrop    ) ;
    TN( tIgnored , "///ideafarm/controls/ignored.executables/" ) ;
    TN( tDone    , "///ideafarm/controls/done.executables/"    ) ;
    TN( tDrop    , "///ideafarm/controls/drop.executables/"    ) ;

    boolT& bQuitP = *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmLaunchBatExeFilesF )                    //P:PERSONALITY: I LAUNCH (AND EAT) BAT AND EXE FILES SO THAT THEY WON'T BE DEBUGGED, SO WILL SURVIVE EVEN IF WO OF THEM CAUSES ME TO DIE

//CS:CODEsYNC: PSEUDOdUPLICATE: 5100083a 510008b5

/*1*/WAKEhIDE( "ifcIDaDAM_GLASS1" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
