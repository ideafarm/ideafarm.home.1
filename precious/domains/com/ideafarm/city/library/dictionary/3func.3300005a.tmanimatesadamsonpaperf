
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#undef MSsLEEPmIN

DONE( tmAnimateSadamsOnPaperF )
}
    }
        if( POOP ) POOPR

        paperOldC::obeyAnimateCbfStrokesIF( tin0P , etThread , 0 , ether ) ;

        }
            if( !( idCycle % cyclesPerSleep ) ) { ++ s ; thirdC::dosSleepRawIF( tin0P , msSleep ) ; }
            if( F(paperOldC::flagsModeIF( tin0P )) & flPAPERmODEi_ANIMATIONtHREADfIRED ) break ;

#endif
            }
                }
                    pRootI->letRefF() ;
                    }

                        paperOldC::ungrabIF( tin0P ) ;
                        paper.flushF( tin0P ) ;
                        paperOldC& paper = (paperOldC&)pRootI->selectPaperF(tin0P,ifcIDcMDpAPERsELECT_QUERYsHOW) ;
                        //paperOldC& paper = (paperOldC&)pRootI->selectPaperF( tin0P , ifcIDcMDpAPERsELECT_QUERYrENDER ) ;

                        }
                            sadamsC::pSadamsIF( tin0P )->tabFreshF( tin0P , etThread ) ;
                            //LOGrAWtID( "calling tabFreshF" ) ;
                        {
                        if( paperOldC::queryResetTabFreshIF( tin0P ) || !( idCycle % TUCK ) )
                        //LOGrAWtID( T("[idCycle]: ")+TF1(idCycle) ) ;
            
                        }
                            sadamsC::pSadamsIF( tin0P )->highlightIfF( tin0P ) ;
                            paperOldC::freshVolatileTextIF( tin0P , etThread , pcNotes , idCycle ) ;
                            paperOldC::obeyAnimateCbfStrokesIF( tin0P , etThread , idCycle , ether ) ;
                            paperOldC::beforeAnimatingIF( tin0P , etThread , idCycle ) ;
                        {
                        if( !( F(paperOldC::flagsModeIF( tin0P )) & flPAPERmODEi_SUPPRESSaNIMATION ) && !( F(paperOldC::flagsModeIF( tin0P )) & flPAPERmODEi_ANIMATIONtHREADfIRED ) )
                        paperOldC::grabIF( tin0P , TAG( TAGiDnULL ) ) ;

                        }
                            etThread.osTimeNowF( tin0P , timeL1 , timeL2 ) ;
                            timeL2 = timeL1 = 0 ;
            
                            }
                                //LOGrAW5( "too slow [cyclesPerSleep,msSleep]: " , cyclesPerSleep , " " , msSleep , "\r\n" ) ; //U::
                                if( bLathUp ) bLathUp = 0 ;
                                bLathUpLag = bLathUp ;
            
                                }
                                    if( !bLathUp && !bJump ) bJump = 1 ;
            
                                    msStep = msPowerAbove >= 0x10 ? msPowerAbove >> 4 : 1 ;
                                    msPowerAbove >>= 1 ;
                                    msPowerBelow >>= 1 ;
                                {
                                if( msSleep == msPowerBelow )
            
                                }
                                    if( !( cyclesPerSleep & BM_HIGH ) ) cyclesPerSleep <<= 1 ;
                                    msSleep = MSsLEEPmIN ;
                                {
                                if( msSleep < MSsLEEPmIN )
            
                                else         msSleep = msPowerBelow ;
                                if( !bJump ) msSleep -= msStep ;
            
                                if( bLathUp && bJump && idCycle != 0x20 ) bJump = 0 ;
            
                                if( !bJump && bLathUp && !bLathUpLag && msStep < ( msPowerAbove >> 4 ) ) msStep <<= 1 ;
                            {
                            else if( timeE1 > timeTarget1 )
                            }
                                //LOGrAW5( "too fast [cyclesPerSleep,msSleep]: " , cyclesPerSleep , " " , msSleep , "\r\n" ) ; //U::
                                if( !bLathUp ) bLathUp = 1 ;
                                bLathUpLag = bLathUp ;
            
                                }
                                    }
                                        if( bLathUp && !bJump ) bJump = 1 ;
                
                                        msStep = msPowerAbove >> 4 ;
                                        msPowerAbove <<= 1 ;
                                        msPowerBelow <<= 1 ;
                                    {
                                    if( msSleep == msPowerAbove )
                
                                    else         msSleep = msPowerAbove ;
                                    if( !bJump ) msSleep += msStep ;
            
                                    if( !bJump && !bLathUp && bLathUpLag && msStep > 1 ) msStep >>= 1 ;
                                {
                                else
                                if( cyclesPerSleep > 1 ) cyclesPerSleep >>= 1 ;
            
                                if( !bLathUp && bJump && idCycle != 0x20 ) bJump = 0 ;
                            {
                            if( timeE1 < timeTarget1 )
            
                            etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeL1 , timeL2 ) ;
                            etThread.osTimeNowF( tin0P , timeE1 , timeE2 ) ;
                            ZE( sCountT , timeE2 ) ;
                            ZE( countT , timeE1 ) ; //U::MOVE ALL OF THIS ADJUSTMENT LOGIC INTO BASE LIBRARY
                        {
                        if( !( idCycle % 0x20 ) )

                        //LOGrAW3( "back is reportedly not absent [idCycle]: " , idCycle , "\r\n" ) ;
                    {
                    if( !pRootI->backAbsentF() )
                {
                if( pRootI )
                windowOldC* pRootI = windowOldC::getRefIF( tin0P ) ;
            {
            
            backOldC::freshJoyIfIF( tin0P , etThread ) ;

            //SPECIAL APPLICATIONS SUCH AS SCREEN CAPTURE CAN SET flPAPERbACKmODE_POLLjOYeVENwHENcONSOLEhIDDEN TEMPORARILY
            //JOYSTICK IS NORMALLY NOT POLLED WHEN CONSOLE IS NOT ACTIVE (HENCE NOT VISIBLE); THIS IS TO MINIMIZE CPU LOAD WHEN OPERATOR IS NOT INTERACTING WITH CONSOLE
#if defined( NEVERdEFINED )

            if( !( ++ pcNotes[ 2 ] ) ) ++ pcNotes[ 3 ] ;
            if( !( ++ idCycle ) ) ++ idCycle ;
        {
        while( !( F(paperOldC::flagsModeIF( tin0P )) & flPAPERmODEi_ANIMATIONtHREADfIRED ) )
        ZE( sCountT , timeTarget2 ) ;
        countT msStep = msPowerAbove >> 4 ;
        ZE( boolT , bLathUpLag ) ;
        ZE( boolT , bLathUp ) ;
        countT timeTarget1 = TOCK << 0 ;
        countT bJump = 1 ; // 0=SINGLEsTEP 1=POWERoF2
        countT msPowerAbove = 0x80 ;
        countT msSleep = 0x40 ; //NOT ALLOWED TO GO BELOW 8
        countT msPowerBelow = 0x20 ;
        countT cyclesPerSleep = 1 ;
        TN( tb , " " ) ;
        TN( tcr , "\r\n" ) ;
        etThread.osTimeNowF( tin0P , timeL1 , timeL2 ) ;
        ZE( sCountT , timeL2 ) ;
        ZE( countT , timeL1 ) ;
        ZE( countT , idCycle ) ;
        countT pcNotes[ 5 ] = { 1 , 2 , 0 , 0 , 0 } ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        SCOOPS
    {
    IFsCRATCH

    ((tin9S&)tin0P).tell_tmWatchF_toIgnoreMeF() ;

    thirdC::dosPriorityIF( tin0P , ifcTHREADpRIORITY_LAZIEST ) ;
{
if( pTaskP )
/*1*/TASK( tmAnimateSadamsOnPaperF )/*1*/

//#define MSsLEEPmIN 8
#define MSsLEEPmIN 1

/**/
*/
i also poll the joysticks
my main job is to animate
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

