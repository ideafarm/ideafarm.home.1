
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tin0P , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    }
        etThread.delF( tin0P , pbd ) ;
        byteT* pbd = (byteT*)cpbd ;
        stStringsOfBytesToDelete >> cpbd ;
        ZE( countT , cpbd ) ;
    {
    while( !etThread && stStringsOfBytesToDelete )

    }
        DEL( ptbld ) ;
        tableC* ptbld = (tableC*)cptbld ;
        stTablesToDelete >> cptbld ;
        ZE( countT , cptbld ) ;
    {
    while( !etThread && stTablesToDelete )

    }
        DEL( pstd ) ;
        stackC* pstd = (stackC*)cpstd ;
        stStacksToDelete >> cpstd ;
        ZE( countT , cpstd ) ;
    {
    while( !etThread && stStacksToDelete )

    stComments.ungrabF( tin0P ) ;
    }
        }
            etThread.delF( tin0P , pc4d ) ;
            etThread.delF( tin0P , psttOldComment ) ;
            strokeS* psttOldComment = (strokeS*)pc4d->c4 ;
        {
        if( pc4d )
        stComments >> pc4d ;
        ZE( count4S* , pc4d ) ;
    {
    while( !etThread && stComments )
    stComments.grabF( tin0P , TAG( TAGiDnULL ) ) ;

    stAlerts.ungrabF( tin0P ) ;
    }
        }
            etThread.delF( tin0P , pc4d ) ;
            etThread.delF( tin0P , psttAlert ) ;
            strokeS* psttAlert = (strokeS*)pc4d->c4 ;
        {
        if( pc4d )
        stAlerts >> pc4d ;
        ZE( count4S* , pc4d ) ;
    {
    while( !etThread && stAlerts )
    stAlerts.grabF( tin0P , TAG( TAGiDnULL ) ) ;

    stLeads.ungrabF( tin0P ) ;
    }
        }
            etThread.delF( tin0P , pc4d ) ;
            etThread.delF( tin0P , psttExtEmail ) ;
            strokeS* psttExtEmail = (strokeS*)pc4d->c4 ;
        {
        if( pc4d )
        stLeads >> pc4d ;
        ZE( count4S* , pc4d ) ;
    {
    while( !etThread && stLeads )
    stLeads.grabF( tin0P , TAG( TAGiDnULL ) ) ;

    bLever.ungrabF( tin0P ) ;
    swsPeerLog.ungrabF( tin0P ) ;
    }
        }
            etThread.delF( tin0P , psttd ) ;
            swsPeerLog >> psttd ;
            ZE( strokeS* , psttd ) ;
        {
        while( !etThread && swsPeerLog )

        lever = swsPeerLog.leverF( tin0P , idl ) ;
    {
    for( countT idl = 1 ; idl <= cLevers ; idl ++ )
    const countT cLevers = swsPeerLog.cFlavorsF( tin0P ) ;
    swsPeerLog.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    bLever.grabF( tin0P , TAG( TAGiDnULL ) ) ;

    snapshotF( tin0P , etThread , tPeerLog , tLeads , tAlerts , tComments , bLever , lever , swsPeerLog , stLeads , stAlerts , stComments ) ;

    }
        etThread.delF( tin0P , pstt1mAds ) ;

        }
            etThread.strokeF( tin0P , TF3(++cIn,0,3)+T(" ") ) ;

            }
                }
                    { ZE( countT , tnu ) ; etThread.osThreadF( tin0P , tnu , tmServeHttpF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)pcp ) ; }

                    pcp[ 9 ] = cAds ;
                    pcp[ 8 ] = (countT)pstt1mAds ;
                    pcp[ 7 ] = (countT)&stComments ;
                    pcp[ 6 ] = (countT)&stAlerts ;
                    pcp[ 5 ] = (countT)&stLeads ;
                    pcp[ 4 ] = (countT)&swsPeerLog ;
                    pcp[ 3 ] = (countT)&lever ;
                    pcp[ 2 ] = (countT)&bLever ;
                    pcp[ 1 ] = (countT)pso ;
                    pcp[ 0 ] = 9 ;
                {
                if( pcp )
                etThread.newF( tin0P , LF , pcp , 10 ) ;
                ZE( countT* , pcp ) ;
            {
            else        
            if( ether || etThread ) { DEL( pso ) ; }
            socket.acceptF( tin0P , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            ZE( socketC* , pso ) ;
        {
        while( !ether && !etThread )
        ZE( countT , cIn ) ;

        const countT cAds = etThread.boxMenuF( tin0P , soul1mAds , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/image/gif/ad.00000001.*") ) ;
        ZE( strokeS* , pstt1mAds ) ;
    {

    }
        }
            etThread.osThreadF( tin0P , tnu , tmSnapshotF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)pstp , (countT)&lever , (countT)&bLever , (countT)&swsPeerLog , (countT)&stLeads , (countT)&stAlerts , (countT)&stComments ) ;
            ZE( countT , tnu ) ;

            *pstp << (countT)&tComments ;
            *pstp << (countT)&tAlerts ;
            *pstp << (countT)&tLeads ;
            *pstp << (countT)&tPeerLog ;
        {
        if( pstp )
        stackC* pstp = new( 0 , tin0P , LF ) stackC( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;
    {

    loadDataF( tin0P , etThread , stStringsOfBytesToDelete , stTablesToDelete , stStacksToDelete , tPeerLog , tLeads , tAlerts , tComments , bLever , lever , swsPeerLog , stLeads , stAlerts , stComments ) ;
    TN( tComments , "///ideafarm/ephemeral/domains/com/ideafarm/city/data/base/5e30104.comments"  ) ;
    TN( tAlerts   , "///ideafarm/ephemeral/domains/com/ideafarm/city/data/base/5e30104.alerts"  ) ;
    TN( tLeads    , "///ideafarm/ephemeral/domains/com/ideafarm/city/data/base/5e30104.leads"  ) ;
    TN( tPeerLog  , "///ideafarm/ephemeral/domains/com/ideafarm/city/data/base/5e30104.peerLog") ;

    stackC stStacksToDelete( tin0P , etThread , TAG( TAGiDnULL ) ) ;
    stackC stTablesToDelete( tin0P , etThread , TAG( TAGiDnULL ) ) ;
    stackC stStringsOfBytesToDelete( tin0P , etThread , TAG( TAGiDnULL ) ) ;

    stackC       stComments( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC       stAlerts( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    stackC       stLeads( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    switchStackC swsPeerLog( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , lever , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    ZE( countT , lever ) ;
    batonC bLever( tin0P , TAG( TAGiDnULL ) ) ;

    socket.listenF( tin0P ) ;    
    countT idPort = socket.bindF( tin0P , ifcIDpORT_HTTP ) ;
    socketC socket( tin0P , etThread , TAG( TAGiDnULL ) ) ;

    etThread.strokeF( tin0P , T("IdeaFarm " "(tm) City Http Server\r\ni fill http requests\r\n") ) ;
{
else
}
    etThread.strokeF( tin0P , T("Another 5e30104 appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tin0P , TAG( TAGiDnULL ) , T("5e30104") ) ;

//U:((thirdC&)etThread).third_bCareful_F( tin0P ) = 0 ;
//U:ENABLE THIS ONCE FIX THE ACCESS VIOLATION THAT OCCURS WHEN A PAGE IS NOT FOUND.  (OCCURS ONLY IF NOT CAREFUL.)

//etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUSH ) ;

TODO

}
    bLeverP.ungrabF( tin0P ) ;

    }
        stCommentsP.ungrabF( tin0P ) ;

        }
            }
                stCommentsP << pc4l ;

                pc4l->c4 = (countT)psttOldComment ;
                pc4l->c3 = (countT)tbl._CT1_04F( idr , 3 ) ;
                pc4l->c2 = (countT)tbl._CT1_04F( idr , 2 ) ;
                pc4l->c1 = (countT)tbl._CT1_04F( idr , 1 ) ;

                etThread.strMakeF( tin0P , LF , psttOldComment , tbl._CT1_07F( idr , 4 ) ) ; ___( psttOldComment ) ;
                ZE( strokeS* , psttOldComment ) ;
            {
            if( pc4l )
            etThread.newF( tin0P , LF , pc4l ) ; ___( pc4l ) ;
            ZE( count4S* , pc4l ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tin0P ) ;

        tbl.readF( tin0P , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttOldCommentsP ) ;
        tableC tbl( tin0P , etThread ) ;

        stCommentsP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {
    if( etThread.diskFileExistsF( tin0P , psttOldCommentsP ) )

    }
        stAlertsP.ungrabF( tin0P ) ;

        }
            }
                stAlertsP << pc4l ;

                pc4l->c4 = (countT)psttAlert ;
                pc4l->c3 = (countT)tbl._CT1_04F( idr , 3 ) ;
                pc4l->c2 = (countT)tbl._CT1_04F( idr , 2 ) ;
                pc4l->c1 = (countT)tbl._CT1_04F( idr , 1 ) ;

                etThread.strMakeF( tin0P , LF , psttAlert , tbl._CT1_07F( idr , 4 ) ) ; ___( psttAlert ) ;
                ZE( strokeS* , psttAlert ) ;
            {
            if( pc4l )
            etThread.newF( tin0P , LF , pc4l ) ; ___( pc4l ) ;
            ZE( count4S* , pc4l ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tin0P ) ;

        tbl.readF( tin0P , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttAlertsP ) ;
        tableC tbl( tin0P , etThread ) ;

        stAlertsP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {
    if( etThread.diskFileExistsF( tin0P , psttAlertsP ) )

    }
        stLeadsP.ungrabF( tin0P ) ;

        }
            }
                stLeadsP << pc4l ;

                pc4l->c4 = (countT)psttExtEmail ;
                pc4l->c3 = (countT)tbl._CT1_04F( idr , 3 ) ;
                pc4l->c2 = (countT)tbl._CT1_04F( idr , 2 ) ;
                pc4l->c1 = (countT)tbl._CT1_04F( idr , 1 ) ;

                etThread.strMakeF( tin0P , LF , psttExtEmail , tbl._CT1_07F( idr , 4 ) ) ; ___( psttExtEmail ) ;
                ZE( strokeS* , psttExtEmail ) ;
            {
            if( pc4l )
            etThread.newF( tin0P , LF , pc4l ) ; ___( pc4l ) ;
            ZE( count4S* , pc4l ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tin0P ) ;

        tbl.readF( tin0P , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttLeadsP ) ;
        tableC tbl( tin0P , etThread ) ;

        stLeadsP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {
    if( etThread.diskFileExistsF( tin0P , psttLeadsP ) )

    }
        swsPeerLogP.ungrabF( tin0P ) ;

        }
            swsPeerLogP << tbl._CT1_07F( idr , 2 ) ;
            leverP =  tbl._CT1_04F( idr , 1 ) ;
        {
        for( countT idr = 1 ; idr <= cRows ; idr ++ )
        const countT cRows = tbl.cRowsF( tin0P ) ;

        tbl.readF( tin0P , stStringsOfBytesToDeleteP , stTablesToDeleteP , stStacksToDeleteP , psttPeerLogP ) ;
        tableC tbl( tin0P , etThread ) ;

        swsPeerLogP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {
    if( etThread.diskFileExistsF( tin0P , psttPeerLogP ) )

    bLeverP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
{
voidT loadDataF( tin0S& tin0P , etherC& etThread , stackC& stStringsOfBytesToDeleteP , stackC& stTablesToDeleteP , stackC& stStacksToDeleteP , const strokeS* const psttPeerLogP , const strokeS* const psttLeadsP , const strokeS* const psttAlertsP , const strokeS* const psttOldCommentsP , batonC& bLeverP , countT& leverP , switchStackC& swsPeerLogP , stackC& stLeadsP , stackC& stAlertsP , stackC& stCommentsP )

DONE( tmSnapshotF )
}
    }
        etThread.osSleepF( tin0P , TOCK ) ;
        if( !( idTry % 0x40 ) ) snapshotF( tin0P , etThread , tPeerLog , tLeads , tAlerts , tComments , bLever , lever , swsPeerLog , stLeads , stAlerts , stComments ) ;

        idTry ++ ;
    {
    while( !etThread )
    ZE( countT , idTry ) ;

    DEL( pstkSKH ) ;
    textC&        tComments  = *(textC*)( *pstkSKH )[ 4 ] ;
    textC&        tAlerts    = *(textC*)( *pstkSKH )[ 3 ] ;
    textC&        tLeads     = *(textC*)( *pstkSKH )[ 2 ] ;
    textC&        tPeerLog   = *(textC*)( *pstkSKH )[ 1 ] ;

    stackC&       stComments = *(stackC*)      pTaskP->c7 ;
    stackC&       stAlerts   = *(stackC*)      pTaskP->c6 ;
    stackC&       stLeads    = *(stackC*)      pTaskP->c5 ;
    switchStackC& swsPeerLog = *(switchStackC*)pTaskP->c4 ;
    batonC&       bLever     = *(batonC*)      pTaskP->c3 ;
    countT&       lever      = *(countT*)      pTaskP->c2 ;
    stackC*       pstkSKH    =  (stackC*)      pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 )
TASK( tmSnapshotF )

}
    }
        tbl.writeF( tin0P , psttOldCommentsP ) ;

        stCommentsP.ungrabF( tin0P ) ;

        }
            while( !etThread && handle ) ;
            }
                }
                    tbl.newObjectF( tin0P , psttOldComment ) ;
                    tbl.newObjectF( tin0P , pc4l->c3 ) ;
                    tbl.newObjectF( tin0P , pc4l->c2 ) ;
                    tbl.newObjectF( tin0P , pc4l->c1 ) ;
                    tbl.newEventF( tin0P ) ;

                    __Z( psttOldComment ) ;
                    strokeS* psttOldComment = (strokeS*)pc4l->c4 ;
                {
                if( pc4l )
                __Z( pc4l ) ;
                count4S* pc4l = (count4S*)stCommentsP.downF( tin0P , handle ) ;
            {
            do
            handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( stCommentsP )

        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tableC tbl( tin0P , etThread ) ;

        stCommentsP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {

    }
        tbl.writeF( tin0P , psttAlertsP ) ;

        stAlertsP.ungrabF( tin0P ) ;

        }
            while( !etThread && handle ) ;
            }
                }
                    tbl.newObjectF( tin0P , psttAlert ) ;
                    tbl.newObjectF( tin0P , pc4l->c3 ) ;
                    tbl.newObjectF( tin0P , pc4l->c2 ) ;
                    tbl.newObjectF( tin0P , pc4l->c1 ) ;
                    tbl.newEventF( tin0P ) ;

                    __Z( psttAlert ) ;
                    strokeS* psttAlert = (strokeS*)pc4l->c4 ;
                {
                if( pc4l )
                __Z( pc4l ) ;
                count4S* pc4l = (count4S*)stAlertsP.downF( tin0P , handle ) ;
            {
            do
            handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( stAlertsP )

        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tableC tbl( tin0P , etThread ) ;

        stAlertsP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {

    }
        tbl.writeF( tin0P , psttLeadsP ) ;

        stLeadsP.ungrabF( tin0P ) ;

        }
            while( !etThread && handle ) ;
            }
                }
                    tbl.newObjectF( tin0P , psttExtEmail ) ;
                    tbl.newObjectF( tin0P , pc4l->c3 ) ;
                    tbl.newObjectF( tin0P , pc4l->c2 ) ;
                    tbl.newObjectF( tin0P , pc4l->c1 ) ;
                    tbl.newEventF( tin0P ) ;

                    __Z( psttExtEmail ) ;
                    strokeS* psttExtEmail = (strokeS*)pc4l->c4 ;
                {
                if( pc4l )
                __Z( pc4l ) ;
                count4S* pc4l = (count4S*)stLeadsP.downF( tin0P , handle ) ;
            {
            do
            handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        if( stLeadsP )

        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tableC tbl( tin0P , etThread ) ;

        stLeadsP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {

    bLeverP.ungrabF( tin0P ) ;

    }
        tbl.writeF( tin0P , psttPeerLogP ) ;

        swsPeerLogP.ungrabF( tin0P ) ;

        }
            while( !etThread && handle ) ;
            }
                }
                    tbl.newObjectF( tin0P , psttEntry ) ;
                    tbl.newObjectF( tin0P , leverP ) ;
                    tbl.newEventF( tin0P ) ;
                {
                if( psttEntry )
                __Z( psttEntry ) ;
                strokeS* psttEntry = (strokeS*)swsPeerLogP.downF( tin0P , handle ) ;
            {
            do
            handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

            leverP = swsPeerLogP.leverF( tin0P , idl ) ;
        {
        for( countT idl = 1 ; idl <= cLevers ; idl ++ )

        tbl.newColF( tin0P ) ;
        tbl.newColF( tin0P ) ;
        tableC tbl( tin0P , etThread ) ;

        const countT cLevers = swsPeerLogP.cFlavorsF( tin0P ) ;

        swsPeerLogP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {

    bLeverP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
{
voidT snapshotF( tin0S& tin0P , etherC& etThread , const strokeS* const psttPeerLogP , const strokeS* const psttLeadsP , const strokeS* const psttAlertsP , const strokeS* const psttOldCommentsP , batonC& bLeverP , countT& leverP , switchStackC& swsPeerLogP , stackC& stLeadsP , stackC& stAlertsP , stackC& stCommentsP )

DONE( tmServeHttpF )

}
    etThread.delF( tin0P , pcp ) ;

    }
        etThread = 0 ; // SUPPRESSES THE LOGGING OF ALL ERRORS THAT OCCUR WHILE SERVICING THIS THREAD'S PEER
        etThread.delF( tin0P , psttRequest ) ;

        #endif
            etThread.delF( tin0P , postRequest ) ;
            { countT pcPart[] = { 0x5e30104 , nicNamePeer , 0 } ; etThread.ifcDatumF( tin0P , flDATUM1_CLASSwORK , flDATUM2_osTextT , bApproved , pcPart , postRequest ) ; }
            etThread.strMakeF( tin0P , LF , postRequest , psttRequest ) ; ___( postRequest ) ;
            ZE( osTextT* , postRequest ) ;
        #if defined( NEVERdEFINED )

        DEL( pso ) ;
        }
            etThread.delF( tin0P , posti ) ;
            etThread = 0 ;
            pso->readF( tin0P , posti , 0x10000 ) ;
            etThread.newF( tin0P , LF , posti        , 0x10000 ) ;
            ZE( osTextT* , posti ) ;
        {
        if( pso )

        etThread.delF( tin0P , psttPeerName ) ;
        etThread.delF( tin0P , psttPeerNum ) ;
        etThread.delF( tin0P , psttQuery ) ;
        etThread.delF( tin0P , psttBox ) ;
        etThread.delF( tin0P , psttOldCmd ) ;
        }
            if( pb ) etThread.delF( tin0P , pb ) ;
            else                  pso->writeF( tin0P , pb , cb ) ;
            else if( !pb        ) pso->writeF( tin0P , postNotFound    ) ;
                 if( !bApproved ) pso->writeF( tin0P , postNotApproved ) ;
            pso->writeF( tin0P , (osTextT*)T("Last-modified: Sat, 09 May 1998 02:36:28 GMT\r\nAccept-Ranges"": bytes\r\n\r\n") ) ;
            //if( bAd ) pso->writeF( tin0P , (osTextT*)T("Pragma: no-cache\r\n") ) ;
            pso->writeF( tin0P , (osTextT*)T("\r\n") ) ;
            etThread.delF( tin0P , postLength ) ;
            pso->writeF( tin0P , postLength ) ;
            pso->writeF( tin0P , (osTextT*)T("\r\nContent-Length: ") ) ;
            else            pso->writeF( tin0P , (osTextT*)T("text/html") ) ;
            else if( bImageJpg ) pso->writeF( tin0P , (osTextT*)T("image/jpeg") ) ;
                 if( bImageGif ) pso->writeF( tin0P , (osTextT*)T("image/gif") ) ;
            pso->writeF( tin0P , (osTextT*)T("HTTP/1.0 200 OK\r\nDate: Sat, 09 May 1998 02:36:28 GMT\r\nServer: IDEAFARM/1.0\r\nMIME-version: 1.0\r\nContent-Type: ") ) ;
            //U: CALCULATE THE DATE AND TIME
            }
                etThread.delF( tin0P , psttLength ) ;
                etThread.strMakeF( tin0P , LF , postLength , psttLength ) ;
                else                  etThread.strFromF( tin0P , psttLength , cb                                               , flFORMAT_NObASE|flFORMAT_FOREIGN , 0 , 10 ) ;
                else if( !pb        ) etThread.strFromF( tin0P , psttLength , etThread.strBodyLengthF( tin0P , postNotFound    ) , flFORMAT_NObASE|flFORMAT_FOREIGN , 0 , 10 ) ;
                     if( !bApproved ) etThread.strFromF( tin0P , psttLength , etThread.strBodyLengthF( tin0P , postNotApproved ) , flFORMAT_NObASE|flFORMAT_FOREIGN , 0 , 10 ) ;
                ZE( strokeS* , psttLength ) ;
            {
            ZE( osTextT* , postLength ) ;

            }
                etThread.delF( tin0P , psttShort ) ;

                else __1
                }
                    }
                        etThread.delF( tin0P , psttReply ) ;
                        cb = etThread.strMakeF( tin0P , LF , pb , psttReply ) ; ___( pb ) ;
                        etThread.delF( tin0P , psttReport ) ;
                        etThread.strFuseF( tin0P , psttReply , T(postPart1) + T(psttReport) + T(postPart3) ) ; ___( psttReply ) ;
                        ZE( strokeS* , psttReply ) ;
                        osTextT* postPart3 = "\r\n</PRE></BODY>\r\n</HTML>\r\n" ;
                        etThread.delF( tin0P , psttPassword ) ;
                        etThread.strMakeF( tin0P , LF , psttReport , T("That is not the correct password.\r\nIn order to protect the privacy of my references, I cannot release their\r\nidentity to you until you specify the correct password.\r\n\r\nPlease call me at US 650-533-8096 to obtain it, or send email to " ifcEMAIL_OLDfROM " .\r\nThank you.") ) ; ___( psttReport ) ;
                        ZE( strokeS* , psttReport ) ;
                        osTextT* postPart1 = "<HTML>\r\n<HEAD>\r\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n<TITLE>references</TITLE>\r\n</HEAD>\r\n<BODY>\r\n<PRE>" ;
                    {
                    else
                    }
                        etThread.delF( tin0P , psttReply ) ;
                        cb = etThread.strMakeF( tin0P , LF , pb , psttReply ) ; ___( pb ) ;
                        etThread.delF( tin0P , psttReport ) ;
                        etThread.strFuseF( tin0P , psttReply , T(postPart1) + T(psttReport) + T(postPart3) ) ; ___( psttReply ) ;
                        ZE( strokeS* , psttReply ) ;
                        osTextT* postPart3 = "\r\n</PRE></BODY>\r\n</HTML>\r\n" ;
                        etThread.delF( tin0P , psttPassword ) ;
                        etThread.strMakeF( tin0P , LF , psttReport , T(postReferences) ) ; ___( psttReport ) ;
                        ZE( strokeS* , psttReport ) ;
                        osTextT* postPart1 = "<HTML>\r\n<HEAD>\r\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n<TITLE>references</TITLE>\r\n</HEAD>\r\n<BODY>\r\n<PRE>" ;

                        ;
                            "<A HREF=\"mailto:fisher@anava.com\">fisher@anava.com</A>\r\n"
                            "telephone: US 408-734-9805\r\n"
                            "Santa Clara, CA, USA\r\n"
                            "<A HREF=\"http://www.anava.com/\">ANAVA Corporation</A>\r\n"
                            "Dr. William Fisher\r\n"
                            "\r\n"
                            "<A HREF=\"mailto:smithson@anava.com\">smithson@anava.com</A>\r\n"
                            "telephone: US 408-734-9805\r\n"
                            "Santa Clara, CA, USA\r\n"
                            "<A HREF=\"http://www.anava.com/\">ANAVA Corporation</A>\r\n"
                            "Dr. Bob Smithson\r\n"
                        osTextT* postReferences =
                    {
                    if( !etThread.strCompareF( tin0P , psttPassword , T("jon") ) )
                    etThread.strFromUrlF( tin0P , psttPassword ) ;
                    etThread.strSubstringF( tin0P , psttPassword , idf , idl , psttQuery ) ; ___( psttPassword ) ;
                    ZE( countT , idl ) ;
                    ZE( strokeS* , psttPassword ) ;
                {
                else if( idf = 1 , /*sttq = ze ,*/ 1 == etThread.strIdF( tin0P , idf , sttq , T("references=") , psttQuery ) )
                }
                    etThread.delF( tin0P , psttReply ) ;
                    cb = etThread.strMakeF( tin0P , LF , pb , psttReply ) ; ___( pb ) ;
                    etThread.strFuseF( tin0P , psttReply , T(postHeadHttp)+T(postBody)+T(psttOldComment)+T(postFootHttp) ) ; ___( psttReply ) ;
                    ZE( strokeS* , psttReply ) ;

                    osTextT* postFootHttp = "\r\n</PRE></BODY>\r\n</HTML>\r\n" ;

                    ;
                        "\r\n"
                        "Your comment message has been received and added to the IdeaFarm " "(tm) City Knowledge Tree:\r\n"
                    osTextT* postBody = 

                    ;
                        "<BODY><PRE>"
                        "</HEAD>\r\n"
                        "<TITLE>new comment received</TITLE>\r\n"
                        "<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n"
                        "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n"
                        "<HEAD>\r\n"
                        "<HTML>\r\n"
                    osTextT* postHeadHttp = 

                    }
                        }
                            stComments.sinkF( tin0P , idSlot , pc4l ) ;
                            ZE( countT , idSlot ) ;

                            pc4l->c4 = (countT)psttOldComment ;
                            pc4l->c3 = nicNamePeer ;
                            pc4l->c2 = time1 ;
                            pc4l->c1 = time2 ;

                            etThread.osTimeNowF( tin0P , time1 , time2 ) ;
                            ZE( sCountT , time2 ) ;
                            ZE( countT , time1 ) ;
                        {
                        if( pc4l )
                        etThread.newF( tin0P , LF , pc4l ) ; ___( pc4l ) ;
                        ZE( count4S* , pc4l ) ;
                    {

                    ((thirdC&)etThread).logF( tin0P , T("from nicNamePeer=")+TF3(nicNamePeer,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(", comment=\"")+T(psttOldComment)+T("\"") ) ;
                    etThread.strFromUrlF( tin0P , psttOldComment ) ; ___( psttOldComment ) ;
                    etThread.strSubstringF( tin0P , psttOldComment , idf , idl , psttQuery ) ; ___( psttOldComment ) ;
                    ZE( countT , idl ) ;
                    ZE( strokeS* , psttOldComment ) ;
                {
                else if( idf = 1 , /*sttq = ze ,*/ 1 == etThread.strIdF( tin0P , idf , sttq , T("comment=") , psttQuery ) )
                }
                    etThread.delF( tin0P , psttReply ) ;
                    cb = etThread.strMakeF( tin0P , LF , pb , psttReply ) ; ___( pb ) ;
                    etThread.strFuseF( tin0P , psttReply , T(postHeadHttp)+T(postBody)+T(psttAlert)+T(postFootHttp) ) ; ___( psttReply ) ;
                    ZE( strokeS* , psttReply ) ;

                    osTextT* postFootHttp = "\r\n</PRE></BODY>\r\n</HTML>\r\n" ;

                    ;
                        "\r\n"
                        "Your alert message has been received and added to the IdeaFarm " "(tm) City Knowledge Tree:\r\n"
                    osTextT* postBody = 

                    ;
                        "<BODY><PRE>"
                        "</HEAD>\r\n"
                        "<TITLE>new alert received</TITLE>\r\n"
                        "<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n"
                        "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n"
                        "<HEAD>\r\n"
                        "<HTML>\r\n"
                    osTextT* postHeadHttp = 

                    }
                        }
                            stAlerts.sinkF( tin0P , idSlot , pc4l ) ;
                            ZE( countT , idSlot ) ;

                            pc4l->c4 = (countT)psttAlert ;
                            pc4l->c3 = nicNamePeer ;
                            pc4l->c2 = time1 ;
                            pc4l->c1 = time2 ;

                            etThread.osTimeNowF( tin0P , time1 , time2 ) ;
                            ZE( sCountT , time2 ) ;
                            ZE( countT , time1 ) ;
                        {
                        if( pc4l )
                        etThread.newF( tin0P , LF , pc4l ) ; ___( pc4l ) ;
                        ZE( count4S* , pc4l ) ;
                    {

                    ((thirdC&)etThread).logF( tin0P , T("from nicNamePeer=")+TF3(nicNamePeer,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(", alert=\"")+T(psttAlert)+T("\"") ) ;
                    etThread.strFromUrlF( tin0P , psttAlert ) ; ___( psttAlert ) ;
                    etThread.strSubstringF( tin0P , psttAlert , idf , idl , psttQuery ) ; ___( psttAlert ) ;
                    ZE( countT , idl ) ;
                    ZE( strokeS* , psttAlert ) ;
                {
                else if( idf = 1 , /*sttq = ze ,*/ 1 == etThread.strIdF( tin0P , idf , sttq , T("alert=") , psttQuery ) )
                }
                    etThread.delF( tin0P , psttReply ) ;
                    cb = etThread.strMakeF( tin0P , LF , pb , psttReply ) ; ___( pb ) ;
                    etThread.strFuseF( tin0P , psttReply , T(postHeadHttp)+T(postBody)+T(psttOldChat)+T(postFootHttp) ) ; ___( psttReply ) ;
                    ZE( strokeS* , psttReply ) ;

                    osTextT* postFootHttp = "\r\n</PRE></BODY>\r\n</HTML>\r\n" ;

                    ;
                        "\r\n"
                        "Your chat line has been received and sent to all citizens\r\n\r\nEach citizen will receive an email message.\r\nYour line of text will be used as the subject line.\r\nThere will be no message body.\r\nPlease keep these messages short and crisp.\r\nPut explanatory material on a web page, and refer to that page by\r\nending the text line with a reference of the form\r\n\r\n    \"(http://www.mySite.com)\"\r\n"
                    osTextT* postBody = 

                    ;
                        "<BODY><PRE>"
                        "</HEAD>\r\n"
                        "<TITLE>new chat line received</TITLE>\r\n"
                        "<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n"
                        "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n"
                        "<HEAD>\r\n"
                        "<HTML>\r\n"
                    osTextT* postHeadHttp = 

                    }
                        etThread.delF( tin0P , postOldChat ) ;
                        etThread.boxPutF( tin0P , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/" ifcEMAIL_OLDfROM "") , postOldChat , costChat , 1 ) ;
                        countT costChat = etThread.strMakeF( tin0P , LF , postOldChat , T("Subject:")+T(psttOldChat) ) ; ___( postOldChat ) ;
                        ZE( osTextT* , postOldChat ) ;
                    {

                    //((thirdC&)etThread).logF( tin0P , T("from nicNamePeer=")+TF3(nicNamePeer,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(", alert=\"")+T(psttOldChat)+T("\"") ) ;
                    etThread.strFromUrlF( tin0P , psttOldChat ) ; ___( psttOldChat ) ;
                    etThread.strSubstringF( tin0P , psttOldChat , idf , idl , psttQuery ) ; ___( psttOldChat ) ;
                    ZE( countT , idl ) ;
                    ZE( strokeS* , psttOldChat ) ;
                {
                else if( idf = 1 , /*sttq = ze ,*/ 1 == etThread.strIdF( tin0P , idf , sttq , T("chat=") , psttQuery ) )
                }
                    etThread.delF( tin0P , psttReply ) ;
                    cb = etThread.strMakeF( tin0P , LF , pb , psttReply ) ; ___( pb ) ;
                    etThread.delF( tin0P , psttBodyHttp ) ;
                    else             { etThread.strFuseF( tin0P , psttReply , T(postHeadHttp)+T("Your new citizen id was assigned, but i could not email it to \"")+T(psttExtEmail)+T("\".\r\n\r\nIf this email address was entered incorrectly, please try again.\r\n\r\nOr, report the difficulty that you are experiencing by using the form at the base of this page.\r\n\r\n")+T(postFootHttp) ) ; ___( psttReply ) ; }
                    if( !bBadEmail ) { etThread.strFuseF( tin0P , psttReply , T(postHeadHttp)+T(psttBodyHttp)+T(postNote1)+T(psttExtEmail)+T(postNote2)+T(postFootHttp) ) ; ___( psttReply ) ; }
                    ZE( strokeS* , psttReply ) ;

                    etThread.delF( tin0P , psttBodySmtp ) ;
                    }
                        }
                            bBadEmail = 1 ;
                            etThread = 0 ;
                        {
                        if( etThread )

                        etThread.delF( tin0P , postSmtp ) ;
                        etThread.boxPutF( tin0P , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+T(psttExtEmail) , postSmtp , costSmtp ) ;

                        countT costSmtp = etThread.strMakeF( tin0P , LF , postSmtp , T(postHeadSmtp)+T(psttBodySmtp) ) ; ___( postSmtp ) ;
                        ZE( osTextT* , postSmtp ) ;

                        ;
                            "\r\n"
                            "Subject: Welcome, new city cofounder!\r\n"
                        osTextT* postHeadSmtp =
                    {
                    ZE( boolT , bBadEmail ) ;

                    }
                        ) ) ; ___( psttBodySmtp ) ;

                            "craftsman by occupation\r\n"
                            "economist by training\r\n"
                            "\r\n"
                            "Jon C. Duringer\r\n"
                            "\r\n"
                            "\r\n"
                            "Enjoy IdeaFarm " "(tm) City.  Make it -your- city!\r\n"
                            "\r\n"
                            "to make your first IFC program.  Use \"gett\" and then \"test\" to run it.\r\n"
                            "\"get\" command.  Then use the \"put\" command and the \"make\" command\r\n"
                            "Once you have logged in, you might try the \"new\" command and then the\r\n"
                            "\r\n"
                            "from fraudulent use by others.\r\n"
                            "children's fable; it will defeat city center's effort to secure your id\r\n"
                            "city center.  Locking your id frequently is like \"crying wolf\" in the\r\n"
                            "Please do avoid this, because the locking of citizen ids is monitored by\r\n"
                            "\r\n"
                            "unlock your id and continue to login.\r\n"
                            "key will be sent immediately to your email address, which you can use to\r\n"
                            "id will be locked.  This is not as inconvenient as is sounds, because a\r\n"
                            "If you ever enter a different passcode, or enter the wrong session#, your\r\n"
                            "\r\n"
                            "Be sure to keep your last session# written down.\r\n"
                            "\r\n"
                            "session# of your last session, just press the Enter key.\r\n"
                            "Write your passcode down before you enter it.  Then, when prompted for the\r\n"
                            "\r\n"
                            "omit the spaces.  For example, you would enter 01428724.\r\n"
                            "numbers.  For example, 01 42 87 24 would be ok.  When you enter your passcode,\r\n"
                            "When you are prompted for a passcode, make one up.  Choose four nonze""ro 2-digit\r\n"
                            "the Service Window, use the \"login\" command.  Enter your id when prompted.\r\n"
                            "Open a gate into IdeaFarm " "(tm) City, if you have not already done so.  Then, in\r\n"
                            "\r\n"
                            "Your permanent citizen id is"":    ")+TF1(idCitizen)+T("\r\n"

                        etThread.strMakeF( tin0P , LF , psttBodySmtp , T(postBody1)+T(

                        etThread.strMakeF( tin0P , LF , psttBodyHttp , T(postBody1)+T("Your new citizen id has been emailed to you in a note that\r\ncontains everything you need to know to login and\r\nmake your first IFC program.  Enjoy!\r\n") ) ; ___( psttBodyHttp ) ;

                        ;
                            "\r\n"
                            "because payments are made via check rather than using expensive credit card processing services.\r\n"
                            "from citizens are paid back out to other citizens; no portion is retained.  This is possible, in part,\r\n"
                            "create software products and then collect money as others use those products.  -All- usage fees collected\r\n"
                            "IdeaFarm " "(tm) City is operated privately, for profit, to create an environment where smart people can\r\n"
                            "\r\n"
                            "Thank you for deciding to become a cofounder of IdeaFarm " "(tm) City.\r\n"
                        osTextT* postBody1 = 
                    {
                    ZE( strokeS* , psttBodyHttp ) ;
                    ZE( strokeS* , psttBodySmtp ) ;

                    }
                        sock.readF( tin0P , (byteT*)&idCitizen , sizeof idCitizen ) ;

                        etThread.delF( tin0P , pstt1o ) ;
                        sock.writeF( tin0P , (byteT*)pstt1o , cbo ) ;
                        sock.writeF( tin0P , (byteT*)&cbo , sizeof cbo ) ;
                        countT cbo = ( CSpREFIX + pstt1o->idAdam ) * sizeof( strokeS ) ;
                        sock.writeF( tin0P , (byteT*)&idCmd , sizeof idCmd ) ;
                        sock.connectF( tin0P , ifcPORToLD1nICKNAME , socketC::nicNameIF( tin0P , etThread , T("city.center.ideafarm.com") ) ) ;
                        socketC sock( tin0P , etThread , TAG( TAGiDnULL ) ) ;

                        countT idCmd = idcNICKNAMEcMD_NEWiD ;

                        etThread.strFuseSeparateF( tin0P , pstt1o , psttExtEmail , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 0x100000 ) ; ___( pstt1o ) ;
                        etThread.strFuseSeparateF( tin0P , pstt1o , psttExtEmail , 0 , 0 , 0 , 0 , /*U::SOUL?*/ 0x100000 ) ; ___( pstt1o ) ;
                        ZE( strokeS* , pstt1o ) ;
                    {
                    ZE( countT , idCitizen ) ;

                    osTextT* postFootHttp = "\r\n</PRE></BODY>\r\n</HTML>\r\n" ;

                    ;
                        "or use the form below to report the difficulty.\r\n"
                        "If you do not receive it, please resubmit your enrollment as a city cofounder,\r\n"
                        "\" via email.\r\n"
                    osTextT* postNote2 =

                    ;
                        "A copy of the above text has just been sent to \""
                        "\r\n"
                        USCORE79 "\r\n"
                        "\r\n"
                    osTextT* postNote1 =

                    ;
                        "<BODY><PRE>"
                        "</HEAD>\r\n"
                        "<TITLE>welcome, new city cofounder</TITLE>\r\n"
                        "<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n"
                        "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n"
                        "<HEAD>\r\n"
                        "<HTML>\r\n"
                    osTextT* postHeadHttp = 

                    }
                        }
                            stLeads.sinkF( tin0P , idSlot , pc4l ) ;
                            ZE( countT , idSlot ) ;

                            pc4l->c4 = (countT)psttExtEmail ;
                            pc4l->c3 = nicNamePeer ;
                            pc4l->c2 = time1 ;
                            pc4l->c1 = time2 ;

                            etThread.osTimeNowF( tin0P , time1 , time2 ) ;
                            ZE( sCountT , time2 ) ;
                            ZE( countT , time1 ) ;
                        {
                        if( pc4l )
                        etThread.newF( tin0P , LF , pc4l ) ; ___( pc4l ) ;
                        ZE( count4S* , pc4l ) ;
                    {

                    ((thirdC&)etThread).logF( tin0P , T("founder=\"")+T(psttExtEmail)+T("\"") ) ;
                    etThread.strFromUrlF( tin0P , psttExtEmail ) ; ___( psttExtEmail ) ;
                    etThread.strSubstringF( tin0P , psttExtEmail , idf , idl , psttQuery ) ; ___( psttExtEmail ) ;
                    ZE( countT , idl ) ;
                    ZE( strokeS* , psttExtEmail ) ;
                {
                else if( idf = 1 , /*sttq = ze ,*/ 1 == etThread.strIdF( tin0P , idf , sttq , T("founder=") , psttQuery ) )
                }
                    etThread.delF( tin0P , psttReply ) ;
                    cb = etThread.strMakeF( tin0P , LF , pb , psttReply ) ; ___( pb ) ;
                    etThread.delF( tin0P , psttBodyHttp ) ;
                    else             { etThread.strFuseF( tin0P , psttReply , T(postHeadHttp)+T("I could not email confirmation \"")+T(psttExtEmail)+T("\".\r\n\r\nIf this email address was entered incorrectly, please try again.\r\n\r\n")+T(postFootHttp) ) ; ___( psttReply ) ; }
                    if( !bBadEmail ) { etThread.strFuseF( tin0P , psttReply , T(postHeadHttp)+T(psttBodyHttp)+T(postNote1)+T(psttExtEmail)+T(postNote2)+T(postFootHttp) ) ; ___( psttReply ) ; }
                    ZE( strokeS* , psttReply ) ;

                    }
                        etThread.delF( tin0P , psttu ) ;
                        etThread.delF( tin0P , postExtEmail ) ;
                        etThread.boxPutUniqueF( tin0P , psttu , T("///ideafarm/ephemeral/domains/com/ideafarm/5e30104/emailList/email") , postExtEmail , costExtEmail ) ;
                        ZE( strokeS* , psttu ) ;
                        countT costExtEmail = etThread.strMakeF( tin0P , LF , postExtEmail , psttExtEmail ) ; ___( postExtEmail ) ;
                        ZE( osTextT* , postExtEmail ) ;
                    {
                    if( !bBadEmail )

                    etThread.delF( tin0P , psttBodySmtp ) ;
                    }
                        }
                            bBadEmail = 1 ;
                            etThread = 0 ;
                        {
                        if( etThread )

                        etThread.delF( tin0P , postSmtp ) ;
                        etThread.boxPutF( tin0P , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+T(psttExtEmail) , postSmtp , costSmtp ) ;

                        countT costSmtp = etThread.strMakeF( tin0P , LF , postSmtp , T(postHeadSmtp)+T(psttBodySmtp) ) ; ___( postSmtp ) ;
                        ZE( osTextT* , postSmtp ) ;

                        ;
                            "\r\n"
                            "Subject: IdeaFarm " "(tm) City Mailing List\r\n"
                        osTextT* postHeadSmtp =
                    {
                    ZE( boolT , bBadEmail ) ;

                    }
                        etThread.strMakeF( tin0P , LF , psttBodySmtp , tWelcome ) ; ___( psttBodySmtp ) ;
                        etThread.strMakeF( tin0P , LF , psttBodyHttp , tWelcome+T("\r\n\r\nA copy of this notice is about to be sent to you via email.") ) ; ___( psttBodyHttp ) ;

                        TN( tWelcome , "Welcome to the IdeaFarm (tm) City mailing list.\r\n\r\nYour email address will not be released to others.  It will not be visible\r\nto other participants of the mailing list.  It will not be used to attempt to\r\nsell anything to you.  It will be used only to connect you with other people who\r\nare interested in the construction and launch of IdeaFarm " "(tm) City." ) ;
                    {
                    ZE( strokeS* , psttBodyHttp ) ;
                    ZE( strokeS* , psttBodySmtp ) ;

                    osTextT* postFootHttp = "</PRE></BODY>\r\n</HTML>\r\n" ;

                    ;
                        "If you do not receive it, please resubmit your email address.\r\n"
                        "\" via email.\r\n"
                    osTextT* postNote2 =

                    ;
                        "A copy of the above text has just been sent to \""
                        "\r\n"
                        USCORE79 "\r\n"
                        "\r\n"
                    osTextT* postNote1 =

                    ;
                        "<BODY><PRE>"
                        "</HEAD>\r\n"
                        "<TITLE>IdeaFarm " "(tm) City Mailing List</TITLE>\r\n"
                        "<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n"
                        "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n"
                        "<HEAD>\r\n"
                        "<HTML>\r\n"
                    osTextT* postHeadHttp = 

                    ((thirdC&)etThread).logF( tin0P , T("emailList=\"")+T(psttExtEmail)+T("\"") ) ;
                    etThread.strFromUrlF( tin0P , psttExtEmail ) ; ___( psttExtEmail ) ;
                    etThread.strSubstringF( tin0P , psttExtEmail , idf , idl , psttQuery ) ; ___( psttExtEmail ) ;
                    ZE( countT , idl ) ;
                    ZE( strokeS* , psttExtEmail ) ;
                {
                else if( idf = 1 , /*sttq = ze ,*/ 1 == etThread.strIdF( tin0P , idf , sttq , T("emailList=") , psttQuery ) )
                }
                    etThread.delF( tin0P , psttReply ) ;
                    cb = etThread.strMakeF( tin0P , LF , pb , psttReply ) ; ___( pb ) ;
                    etThread.strFuseF( tin0P , psttReply , T(postHeadHttp)+T(postBody)+T(postNote1)+T(psttExtEmail)+T(postNote2)+T(postFootHttp) ) ; ___( psttReply ) ;
                    ZE( strokeS* , psttReply ) ;

                    }
                        etThread.delF( tin0P , postb ) ;
                        etThread.boxPutF( tin0P , T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/")+T(psttExtEmail) , postb , costb ) ;

                        etThread.delF( tin0P , psttb ) ;
                        countT costb = etThread.strMakeF( tin0P , LF , postb , psttb ) ; ___( postb ) ;
                        ZE( osTextT* , postb ) ;

                        etThread.strMakeF( tin0P , LF , psttb , T(postHeadSmtp)+T(postBody) ) ; ___( psttb ) ;
                        ZE( strokeS* , psttb ) ;
                    {

                    osTextT* postFootHttp = "\r\n</PRE></BODY>\r\n</HTML>\r\n" ;

                    ;
                        "If you do not receive it, please resubmit your order or use the form below to report the difficulty.\r\n"
                        "\" via email.\r\n"
                    osTextT* postNote2 =

                    ;
                        "A copy of the above text has just been sent to \""
                        "\r\n"
                        USCORE79 "\r\n"
                        "\r\n"
                    osTextT* postNote1 =

                    ;
                        "    San Francisco, CA  94105\r\n"
                        "    564 Mission Street, #307\r\n"
                        "    IdeaFarm " "(tm) City\r\n"
                        "    Jon C. Duringer, Craftsman\r\n"
                        "\r\n"
                        "Send your check to the sole proprietor owner and operator of IdeaFarm " "(tm) City:\r\n"
                        "\r\n"
                        "\r\n"
                        "That is all!  Your new citizen id will be sent to you via email as soon as your payment has been received.\r\n"
                        "\r\n"
                        "    4. NICKNAME:  Write the nickname by which you shall be known in the city.\r\n"
                        "\r\n"
                        "    3. EMAIL:     Write your email address on the check.\r\n"
                        "\r\n"
                        "    2. PAYEE:     \"Jon C. Duringer, Craftsman\".\r\n"
                        "\r\n"
                        "    1. AMOUNT:    Your local equivalent of 100 $US.\r\n"
                        "\r\n"
                        "Please take an ordinary check, drawn on your local bank, and fill it out as follows"":\r\n"
                        "\r\n"
                        "because payments are made via check rather than using expensive credit card processing services.\r\n"
                        "from citizens are paid back out to other citizens; no portion is retained.  This is possible, in part,\r\n"
                        "create software products and then collect money as others use those products.  -All- usage fees collected\r\n"
                        "IdeaFarm " "(tm) City is operated privately, for profit, to create an environment where smart people can\r\n"
                        "\r\n"
                        "Thank you for deciding to become a citizen of IdeaFarm " "(tm) City.\r\n"
                    osTextT* postBody = 

                    ;
                        "\r\n"
                        "Subject: Thank you for your order!\r\n"
                    osTextT* postHeadSmtp =

                    ;
                        "<BODY><PRE>"
                        "</HEAD>\r\n"
                        "<TITLE>thank you for your order</TITLE>\r\n"
                        "<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n"
                        "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n"
                        "<HEAD>\r\n"
                        "<HTML>\r\n"
                    osTextT* postHeadHttp = 

                    }
                        }
                            stLeads.sinkF( tin0P , idSlot , pc4l ) ;
                            ZE( countT , idSlot ) ;

                            pc4l->c4 = (countT)psttExtEmail ;
                            pc4l->c3 = nicNamePeer ;
                            pc4l->c2 = time1 ;
                            pc4l->c1 = time2 ;

                            etThread.osTimeNowF( tin0P , time1 , time2 ) ;
                            ZE( sCountT , time2 ) ;
                            ZE( countT , time1 ) ;
                        {
                        if( pc4l )
                        etThread.newF( tin0P , LF , pc4l ) ; ___( pc4l ) ;
                        ZE( count4S* , pc4l ) ;
                    {

                    ((thirdC&)etThread).logF( tin0P , T("newcitizen=\"")+T(psttExtEmail)+T("\"") ) ;
                    etThread.strFromUrlF( tin0P , psttExtEmail ) ; ___( psttExtEmail ) ;
                    etThread.strSubstringF( tin0P , psttExtEmail , idf , idl , psttQuery ) ; ___( psttExtEmail ) ;
                    ZE( countT , idl ) ;
                    ZE( strokeS* , psttExtEmail ) ;
                {
                else if( idf = 1 , /*sttq = ze ,*/ 1 == etThread.strIdF( tin0P , idf , sttq , T("newcitizen=") , psttQuery ) )
                }
                    etThread.delF( tin0P , psttReply ) ;
                    cb = etThread.strMakeF( tin0P , LF , pb , psttReply ) ; ___( pb ) ;
                    etThread.delF( tin0P , psttReport ) ;
                    etThread.strFuseF( tin0P , psttReply , T(postPart1) + T(psttReport) + T(postPart3) ) ; ___( psttReply ) ;
                    ZE( strokeS* , psttReply ) ;
                    osTextT* postPart3 = "\r\n</PRE></BODY>\r\n</HTML>\r\n" ;
                    ((thirdC&)etThread).logF( tin0P , psttReport ) ;
                    etThread.delF( tin0P , psttDescription ) ;
                    etThread.strMakeF( tin0P , LF , psttReport , T(psttBox) + T(":  ") + T(psttDescription) ) ; ___( psttReport ) ;
                    ZE( strokeS* , psttReport ) ;
                    osTextT* postPart1 = "<HTML>\r\n<HEAD>\r\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n<TITLE>thank you</TITLE>\r\n</HEAD>\r\n<BODY>\r\n<PRE>Thank you for taking the time to describe the problem that you experienced.\r\nYour description has been logged so that it can be used to improve IdeaFarm " "(tm) City.\r\nYour problem report, as received, is"":\r\n\r\n" ;
                    etThread.strFromUrlF( tin0P , psttDescription ) ;
                    etThread.strSubstringF( tin0P , psttDescription , idf , idl , psttQuery ) ; ___( psttDescription ) ;
                    ZE( countT , idl ) ;
                    ZE( strokeS* , psttDescription ) ;
                {
                else if( idf = 1 , /*sttq = ze ,*/ 1 == etThread.strIdF( tin0P , idf , sttq , T("defect=") , psttQuery ) )
                }
                    etThread.delF( tin0P , psttReply ) ;
                    cb = etThread.strMakeF( tin0P , LF , pb , psttReply ) ; ___( pb ) ;
                    etThread.strFuseF( tin0P , psttReply , T(postPart1) + T(psttEntry) + T(postPart3) ) ; ___( psttReply ) ;
                    ZE( strokeS* , psttReply ) ;
                    osTextT* postPart3 = "\r\n</PRE></BODY>\r\n</HTML>\r\n" ;
                    osTextT* postPart1 = "<HTML>\r\n<HEAD>\r\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n<TITLE>new log entry accepted</TITLE>\r\n</HEAD>\r\n<BODY>\r\n<PRE>accepted:\r\n\r\n" ;

                    bLever.ungrabF( tin0P ) ;
                    swsPeerLog << psttEntry ;
                    lever = nicNamePeer ;
                    bLever.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                    #endif
                    }
                        etThread.delF( tin0P , postEntry ) ;
                        etThread.delF( tin0P , psttf ) ;
                        etThread.strokeF( tin0P , T(psttf)+T("\r\n") ) ;
                        etThread.boxPutUniqueF( tin0P , psttf , T("///ideafarm/ephemeral/domains/com/ideafarm/city/data/new/host.log.")+TF3(nicNamePeer,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) , postEntry , costEntry ) ; ___( psttf ) ;
                        ZE( strokeS* , psttf ) ;
                        countT costEntry = etThread.strMakeF( tin0P , LF , postEntry , psttEntry ) ; ___( postEntry ) ;
                        ZE( osTextT* , postEntry ) ;
                    {
                    #if defined( NEVERdEFINED )
                    ((thirdC&)etThread).logF( tin0P , T("5e30104: host ")+TF3(nicNamePeer,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T(" sent \"")+T(psttEntry)+T("\"") ) ;

                    }
                        etThread.delF( tin0P , psttw ) ;
                        etThread.delF( tin0P , psttNow ) ;
                        etThread.strMakeF( tin0P , LF , psttEntry , T(psttNow)+T(": ")+T(psttw) ) ; ___( psttEntry ) ;
                        etThread.strFromUrlF( tin0P , psttw ) ; ___( psttw ) ;
                        etThread.strSubstringF( tin0P , psttw , idf , idl , psttQuery ) ; ___( psttw ) ;
                        ZE( strokeS* , psttw ) ;
                        ZE( countT , idl ) ;

                        etThread.strFromTimeF( tin0P , psttNow , time1 , time2 ) ; ___( psttNow ) ;
                        ZE( strokeS* , psttNow ) ;
                        etThread.osTimeNowF( tin0P , time1 , time2 ) ;
                        ZE( sCountT , time2 ) ;
                        ZE( countT , time1 ) ;
                    {
                    ZE( strokeS* , psttEntry ) ;
                {
                )
                    ( idf = 1 , /*sttq = ze ,*/ 1 == etThread.strIdF( tin0P , idf , sttq , T("entry=") , psttQuery ) )
                    !etThread.strCompareF( tin0P , psttShort , T("host.log.html") ) &&
                    bDynamic &&
                (
                else if
                }
                    }
                        }
                            etThread.delF( tin0P , psttLines ) ;

                            cb = etThread.strMakeF( tin0P , LF , pb , T(postPart1)+TPS("time",0x17,S1C('-'))+TPS("  host",0xa,S1C('-'))+TPS("  comment",0x10,S1C('-'))+T(">\r\n\r\n")+T(psttLines)+T(postPart2) ) ; ___( pb ) ;

                            linesF( tin0P , etThread , psttLines , stComments ) ;
                            ZE( strokeS* , psttLines ) ;

                            osTextT* postPart2 = "\r\n</PRE></BODY>\r\n</HTML>\r\n" ;

                            ;

                                "You can enter a comment on IdeaFarm " "(tm) City in the box above.<HR>"
                                "\r\n"
                                "  1. Use this page only to comment (pro or con) on the city.\r\n"
                                "  2. Do not use this page to converse with others.\r\n"
                                "  3. Do not report defects here; use the field at the base of the relevant page.\r\n"
                                "  4. Please, no sexually explicit or hateful remarks.\r\n"
                                "  5. Be brief, informative, and specific!\r\n"
                                "  6. Type your comment in the box and then press the Enter key.\r\n"
                                "\r\n"
                                "<FORM METHOD=\"GET\"><INPUT NAME=\"comment\" size=\"80\"></FORM>"

                                "<TITLE>Comments on IdeaFarm " "(tm) City</TITLE></HEAD><BODY>\r\n<PRE>"
                                "<META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n"
                                "<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n"
                                "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n"
                                "<HTML><HEAD>\r\n"

                            osTextT* postPart1 = 
                        {
                        else if( !etThread.strCompareF( tin0P , psttShort , T("comment.log.html") ) )
                        }
                            etThread.delF( tin0P , psttLines ) ;

                            cb = etThread.strMakeF( tin0P , LF , pb , T(postPart1)+TPS("time",0x17,S1C('-'))+TPS("  host",0xa,S1C('-'))+TPS("  alert",0x10,S1C('-'))+T(">\r\n\r\n")+T(psttLines)+T(postPart2) ) ; ___( pb ) ;

                            linesF( tin0P , etThread , psttLines , stAlerts ) ;
                            ZE( strokeS* , psttLines ) ;

                            osTextT* postPart2 = "\r\n</PRE></BODY>\r\n</HTML>\r\n" ;

                            ;

                                "You can enter an alert message in the box above.<HR>"
                                "\r\n"
                                "  1. Use this page only for alerts regarding the city.\r\n"
                                "  2. Do not use this page to converse with others.\r\n"
                                "  3. Do not report defects here; use the field at the base of the relevant page.\r\n"
                                "  4. Please, no sexually explicit or hateful remarks.\r\n"
                                "  5. Be brief, informative, and specific!\r\n"
                                "  6. Type your alert in the box and then press the Enter key.\r\n"
                                "\r\n"
                                "<FORM METHOD=\"GET\"><INPUT NAME=\"alert\" size=\"80\"></FORM>"

                                "<TITLE>IdeaFarm " "(tm) City Alerts</TITLE></HEAD><BODY>\r\n<PRE>"
                                "<META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n"
                                "<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n"
                                "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n"
                                "<HTML><HEAD>\r\n"

                            osTextT* postPart1 = 
                        {
                        else if( !etThread.strCompareF( tin0P , psttShort , T("alert.log.html") ) )
                        }
                            etThread.delF( tin0P , psttDot ) ;
                            etThread.delF( tin0P , psttLines ) ;

                            cb = etThread.strMakeF( tin0P , LF , pb , T(postPart1)+T(psttDot)+T(postPart2)+T(psttLines)+T(postPart3) ) ; ___( pb ) ;

                            bLever.ungrabF( tin0P ) ;
                            logLinesF( tin0P , etThread , psttLines , swsPeerLog ) ;
                            ZE( strokeS* , psttLines ) ;
                            lever = nicNamePeer ;
                            bLever.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                            osTextT* postPart3 = "\r\n</PRE></BODY>\r\n</HTML>\r\n" ;
                            osTextT* postPart2 = "</TITLE>\r\n</HEAD>\r\n<BODY>\r\n<PRE>" ;
                            osTextT* postPart1 = "<HTML>\r\n<HEAD>\r\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n<TITLE>Log for Host " ;

                            }
                                etThread.delF( tin0P , psttw ) ;
                                etThread.strFuseF( tin0P , psttDot , psttw ) ; ___( psttDot ) ;
                                etThread.strWordF( tin0P , psttw , psttPeerNum , sttq , S1C(',') , 4 ) ; ___( psttw ) ;

                                etThread.delF( tin0P , psttw ) ;
                                etThread.strFuseF( tin0P , psttDot , S1C('.') ) ; ___( psttDot ) ;
                                etThread.strFuseF( tin0P , psttDot , psttw ) ; ___( psttDot ) ;
                                etThread.strWordF( tin0P , psttw , psttPeerNum , sttq , S1C(',') , 3 ) ; ___( psttw ) ;

                                etThread.delF( tin0P , psttw ) ;
                                etThread.strFuseF( tin0P , psttDot , S1C('.') ) ; ___( psttDot ) ;
                                etThread.strFuseF( tin0P , psttDot , psttw ) ; ___( psttDot ) ;
                                etThread.strWordF( tin0P , psttw , psttPeerNum , sttq , S1C(',') , 2 ) ; ___( psttw ) ;

                                etThread.delF( tin0P , psttw ) ;
                                etThread.strFuseF( tin0P , psttDot , S1C('.') ) ; ___( psttDot ) ;
                                etThread.strFuseF( tin0P , psttDot , psttw , 0 , 0 , strokeS() , 0 , 0 ,/*U::SOUL?*/ 0xc ) ; ___( psttDot ) ;
                                etThread.strWordF( tin0P , psttw , psttPeerNum , sttq , S1C(',') , 1 ) ; ___( psttw ) ;

                                ZE( strokeS* , psttw ) ;
                            {
                            ZE( strokeS* , psttDot ) ;
                        {
                        if( !etThread.strCompareF( tin0P , psttShort , T("host.log.html") ) )
                    {
                    else
                    }
                        etThread = 0 ;
                        }
                            }
                                break ;
                                etThread.boxGetShadowF( tin0P , pb , cb , psttc1 , 1 ) ; ___( pb ) ;

                                if( off -- ) continue ;
                            {
                            FORsTRINGSiN1( pstt1mAds )
                            countT off = cIn % cAds ;
                            cIn ++ ;
                            static countT cIn ;
                            //U: OBSOLETED BY THE CODE FOR THE CURRENT APPROACH TO ROTATING IMAGES, WHICH IS FASTER
                        {
                        else
                        }
                            }
                                // ASSUME: THIS CODE ASSUMES A PARTICULAR LENGTH FOR THE PAGE HEADER AND WILL NEED TO BE EDITED WHENEVER THE PAGE HEADER IS CHANGED
                                // ASSUME: THE PAGE TITLE IS THE ONLY VARIABLE DETERMINING THE POSITIONING OF THE FILE NAME OF THE AD
                                //U: ENABLE WHEN BANNER IS ENABLED (SEE snip.0010*.posthtml*) if( cb > offPatch ) pb[ offPatch ] = (byteT)( '0' + off ) ; // PATCHES THE LOWEST ORDER DIGIT IN THE FILE NAME OF THE AD

                                //}
                                //    etThread.strokeF( tin0P , T("offPatchCorrect = ")+TF1(offPatchCorrect)+T("\r\noffPatchCheat = ")+TF1(offPatch)+T("\r\ndelta = ")+TF1(offPatchCorrect-offPatch)+T("\r\n") ) ;
                                //    countT offPatchCorrect = etThread.strIdF( tin0P , idf , sttq , tos , T(pb) ) + tos.csF( tin0P ) - 2 ;
                                //    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                                //    countT idf = 1 ;
                                //
                                //    TN( tos , "ad.00000001.00000000" ) ;
                                //{
                                //U: COMMENT OUT, BUT RETAIN, THIS CODE

                                countT offPatch = 0x7a9 + costTitle ;

                                // ASSUME: THERE ARE NOT MORE THAN f AD FILES
                                countT off = 1 + cIn % cAds ; // [1,cAds]
                                cIn ++ ;
                                static countT cIn ;

                                }
                                    costTitle = etThread.strDigitsToSCountF( tin0P , T(postc) ) ;
                                    const osTextT postc[] = { 0x5 , 0x6 , 0x7 , 0x8 , 0x9 , 0xa , 0xb , 0xc , 0 } ;
                                    // "<!-- 00000010 -->"
                                {
                                ZE( countT , costTitle ) ;
                            {
                            if( pb && !bImageGif && !bImageJpg )
                            etThread.boxGetShadowF( tin0P , pb , cb , psttBox , 1 ) ; ___( pb ) ;
                        {
                        if( !bAd )
                    {
                    if( !bDynamic )

                    etThread.strokeF( tin0P , T(psttPeerName)/*U:+T(":  ")+T(psttBox)*/+T("\r\n") ) ;
                {
                if( !psttQuery )

                countT idf = 1 ;

                etThread.strWordF( tin0P , psttShort , psttBox , sttq , S1C('/') , - 1 ) ; ___( psttShort ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , psttShort ) ;
            {
            if( bApproved )
            ZE( countT , cb ) ;
            ZE( byteT* , pb ) ;
            osTextT* postNotFound = "Not found." ;
            osTextT* postNotApproved = "<HTML>\r\n<HEAD>\r\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n<TITLE>request denied</TITLE>\r\n</HEAD>\r\n<BODY>\r\naccess denied\r\n</BODY>\r\n</HTML>\r\n" ;
            //osTextT* postNotApproved = "<HTML>\r\n<HEAD>\r\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\r\n<META NAME=\"Author\" CONTENT=\"IdeaFarm " "(tm) City\"><META NAME=\"GENERATOR\" CONTENT=\"IdeaFarm " "(tm) City\">\r\n<TITLE>members only</TITLE>\r\n</HEAD>\r\n<BODY>\r\nThis is a private site.  Sorry.\r\n</BODY>\r\n</HTML>\r\n" ;

            }
                bAd       =                                        ( /*sttq = ze ,*/ idf = 1 , 1 == etThread.strIdF( tin0P , idf , sttq , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/image/gif/ad.rotate") , psttBox ) ) ;
                bApproved =  bDynamic || bImageGif || bImageJpg || ( /*sttq = ze ,*/ idf = 1 , 1 == etThread.strIdF( tin0P , idf , sttq , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/html/"              ) , psttBox ) ) ;
                bImageJpg =                                        ( /*sttq = ze ,*/ idf = 1 , 1 == etThread.strIdF( tin0P , idf , sttq , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/image/jpg/"         ) , psttBox ) ) ;
                bImageGif =                                        ( /*sttq = ze ,*/ idf = 1 , 1 == etThread.strIdF( tin0P , idf , sttq , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/image/gif/"         ) , psttBox ) ) ;
                bDynamic  =                                        ( /*sttq = ze ,*/ idf = 1 , 1 == etThread.strIdF( tin0P , idf , sttq , T("///ideafarm/ephemeral/domains/com/ideafarm/dynamic/"               ) , psttBox ) ) ;

                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( countT , idf ) ;
            {
            ZE( boolT , bAd ) ;
            ZE( boolT , bDynamic ) ;
            ZE( boolT , bImageJpg ) ;
            ZE( boolT , bImageGif ) ;
        {
        if( !etThread && psttOldCmd && !etThread.strCompareF( tin0P , psttOldCmd , T("get") ) && psttBox )

        etThread.strReplaceF( tin0P , psttBox , 0 , T("/~2/") , T("///d/ideafarm.work/backed.up.never/gen/html/") ) ; ___( psttBox ) ;
        etThread.strReplaceF( tin0P , psttBox , 0 , T("/~1/") , T("///d/ideafarm.work/backed.up.daily/html/"    ) ) ; ___( psttBox ) ;
        if( psttBox ) etThread.strConvertToLowerCaseF( tin0P , psttBox ) ;
        if( psttOldCmd ) etThread.strConvertToLowerCaseF( tin0P , psttOldCmd ) ;

        }
            etThread.strMakeF( tin0P , LF , psttBox , T("///ideafarm/ephemeral/domains/com/ideafarm/gen/html/ideafarm.html") ) ; ___( psttBox ) ;
            etThread.delF( tin0P , psttBox ) ;
        {
        if( !etThread.strCompareF( tin0P , psttBox , T("/") ) )

        etThread.delF( tin0P , psttBoxAndQuery ) ;
        }
            else __1
            }
                etThread.strSubstringF( tin0P , psttQuery , idf , idl , psttBoxAndQuery ) ;
                idl = 0 ;
                idf = idq + 1 ;

                etThread.strSubstringF( tin0P , psttBox , idf , idl , psttBoxAndQuery ) ;
                countT idl = idq - 1 ;
                countT idf = 1 ;
            {
            else if( idq > 1 && idq < psttBoxAndQuery->idAdam )
            if( !idq ) { etThread.strMakeF( tin0P , LF , psttBox , psttBoxAndQuery ) ; ___( psttBox ) ; }
            countT idq = etThread.strIdF( tin0P , S1C('?') , psttBoxAndQuery ) ;
        {
        ZE( strokeS* , psttQuery ) ;
        etThread.strWordF( tin0P , psttBoxAndQuery , psttRequest , sttQuote , S1C(' ') , 2 ) ; ___( psttBoxAndQuery ) ;
        etThread.strWordF( tin0P , psttOldCmd , psttRequest , sttQuote , S1C(' ') , 1 ) ; ___( psttOldCmd ) ;
        strokeS sttQuote ;
        ZE( strokeS* , psttBox ) ;
        ZE( strokeS* , psttBoxAndQuery ) ;
        ZE( strokeS* , psttOldCmd ) ;

        { ZE( strokeS* , psttNU ) ; pso->readWoLineF( tin0P , psttNU , 0x100 ) ; etThread.delF( tin0P , psttNU ) ; }
        pso->readWoLineF( tin0P ,  psttRequest , 0x10000 ) ; // MUST BE ENOUGH TO RECEIVE ENCODED PARAMETERS
        ZE( strokeS* , psttRequest ) ;
        }
            #endif
                bApproved = 1 ;
            #else
                }
                    }
                        break ;
                        etThread.delF( tin0P , psttIP ) ;
                        etThread.strFromIdPortNicNameF( tin0P , psttIP , 0 , nicNamePeer ) ;
                        ZE( strokeS* , psttIP ) ;
                    {
                    default:
                    }
                        break ;
                        bApproved = 1 ;
                    {
                    case 0xd19d6834 : /* 209.157.104.52 ifc lan I00002*/
                    case 0xd19d6833 : /* 209.157.104.51 ifc lan I00001*/
                    case 0xd118e916 : /* 209.24.233.22  ifc colo account Best Internet*/
                    case 0xceb8a420 : /* 206.184.164.32 ifc ppp account Best Internet acct*/
                    // INSERT "case" LINES IMMEDIATELY ABOVE, IN NUMERIC ORDER, TO APPROVE A NEW CLIENT IP ADDRESS
                {
                switch( nicNamePeer )
            #if defined( ifcIPsECURE )

            etThread.delF( tin0P , psttMe ) ;

            if( !psttPeerName ) { etThread.strMakeF( tin0P , LF , psttPeerName , psttPeerNum ) ; ___( psttPeerName ) ; }
            etThread.sockPsttHostF( tin0P , psttPeerName , nicNamePeer ) ;

            etThread.strFromIdPortNicNameF( tin0P , psttPeerNum , idPortPeer , nicNamePeer ) ;
            pso->peerNameF( tin0P , idPortPeer , nicNamePeer ) ;
            ZE( countT , idPortPeer ) ;

            etThread.strFromIdPortNicNameF( tin0P , psttMe , idPortMe , nicNameMe ) ;
            ZE( strokeS* , psttMe ) ;
            pso->myNameF( tin0P , idPortMe , nicNameMe ) ;
            ZE( countT , idPortMe ) ;
            nicNameC nicNameMe ;
        {
        ZE( strokeS* , psttPeerName ) ;
        ZE( strokeS* , psttPeerNum ) ;
        nicNameC nicNamePeer ;
        ZE( boolT , bApproved ) ;
        pso->etherF( tin0P , etThread ) ;

        countT               cAds       =                       pcp[ 9 ] ;
        const strokeS* const pstt1mAds  = (const strokeS* const)pcp[ 8 ] ;
        stackC&              stComments = *(stackC*)            pcp[ 7 ] ;
        stackC&              stAlerts   = *(stackC*)            pcp[ 6 ] ;
        stackC&              stLeads    = *(stackC*)            pcp[ 5 ] ;
        switchStackC&        swsPeerLog = *(switchStackC*)      pcp[ 4 ] ;
        countT&              lever      = *(countT*)            pcp[ 3 ] ;
        batonC&              bLever     = *(batonC*)            pcp[ 2 ] ;
        socketC*             pso        = (socketC*)            pcp[ 1 ] ;
    {
    if( !etThread )

    __( !pcp[ 9 ] ) ;
    __( !pcp[ 8 ] ) ;
    __( !pcp[ 7 ] ) ;
    __( !pcp[ 6 ] ) ;
    __( !pcp[ 5 ] ) ;
    __( !pcp[ 4 ] ) ;
    __( !pcp[ 3 ] ) ;
    __( !pcp[ 2 ] ) ;
    __( !pcp[ 1 ] ) ;
    countT* pcp = (countT*)pTaskP->c1 ;
{
if( !etThread )
__( !pTaskP && !pTaskP->c1 && *(countT*)(pTaskP->c1) == 9 ) ;

TASK( tmServeHttpF )

}
    stP.ungrabF( tin0P ) ;

    else etThread.strMakeF( tin0P , LF , psttP , T("there are no entries\r\n") ) ;
    }
        while( !etThread && handle ) ;
        }
            }
                etThread.strFuseF( tin0P , psttP , TT(time1,time2)+T("  ")+TF3(nicName,flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T("  ")+T(psttEntry)+T("\r\n") ) ;

                strokeS* psttEntry = (strokeS*)pc4l->c4 ;
                nicNameC  nicName    =           pc4l->c3 ;
                countT   time1     =           pc4l->c2 ;
                sCountT  time2     =           pc4l->c1 ;
            {
            if( pc4l )
            __Z( pc4l ) ;
            count4S* pc4l = (count4S*)stP.upF( tin0P , handle ) ;
        {
        do
        handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

        etThread.strMakeF( tin0P , LF , psttP , T("") , stP * 0x1000 ) ;
    {
    if( stP )

    stP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
{
voidT linesF( tin0S& tin0P , etherC& etThread , strokeS*& psttP , stackC& stP )

}
    else etThread.strMakeF( tin0P , LF , psttP , T("there are no entries in the log for this host\r\n") ) ;
    }
        while( !etThread && handle ) ;
        }
            etThread.strFuseF( tin0P , psttP , T(psttl)+T("\r\n") ) ;
            strokeS* psttl = (strokeS*)swsPeerLogP.downF( tin0P , handle ) ;
        {
        do
        handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

        etThread.strMakeF( tin0P , LF , psttP , T("") , swsPeerLogP * 0x100 ) ;    
    {
    if( swsPeerLogP )
{
voidT logLinesF( tin0S& tin0P , etherC& etThread , strokeS*& psttP , switchStackC& swsPeerLogP )

//U: THIS HAS NOT YET BEEN EDITED TO USE nicNameC CORRECTLY

/*1*/WAKEhIDE( "city.http.server" )/*1*/
/**/
*/
UPON CONNECTION, THIS SERVER READS A "GET <FILE>" LINE, SENDS THE CONTENTS OF THE SPECIFIED FILE, AND THEN WAITS FOR THE CLIENT TO DISCONNECT
 strFuseSeparateF
this function can fail due to hardcoded capacity limits
emits hardcoded timestamp rather than the current time
then disconnects
then waits for receipt of acknowledgement
replies with the contents of the requested file or sends a nonfile reply
monitors port 80, the wkp for http, for requests
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

