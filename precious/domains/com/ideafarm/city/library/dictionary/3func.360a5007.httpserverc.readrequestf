
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return ostEscaped ;

    ether.delF( tinBaseP , postHeadPlus ) ;
    }
        TESTsCRATCH //U:: TO FIND A BUG

        //ether.traceF( tinBaseP , T("readRequestF [name]:    ")+T(psttNameP) , flTRACE_null , ifcIDtRACEdIVERT_7 ) ; //U:: TO FIND A BUG

        }
            ether.delF( tinBaseP , postBodyP ) ;
            ether.delF( tinBaseP , psttAgentP ) ;
            ether.delF( tinBaseP , psttQueryKVP ) ;
            ether.delF( tinBaseP , psttNameP ) ;
        {
        if( bFailP )

        if( !psttNameP ) bFailP = 1 ;
        ether.delF( tinBaseP , psttAction ) ;

        }
            TESTsCRATCH //U:: TO FIND A BUG
            }
                ether.delF( tinBaseP , pstt1e ) ;
                }
                    ether.delF( tinBaseP , psttv ) ;
                    ether.delF( tinBaseP , psttk ) ;
                    }
                        psttLeverKVP = 0 ;
                        swKVP = (countT)psttv ; psttv = 0 ;
                        //LOGrAW( T("value registered:\r\n--------\r\n")+T(psttv)+T("\r\n--------\r\n") ) ; //U::
                        psttLeverKVP = psttk ;

                        //ether.traceF( tinBaseP , T("form field [key,value]:    ")+T(psttk)+T("    \"")+T(psttv)+T("\"") ) ;
                        //LOGrAW( T("form value:\r\n-------------------\r\n")+T(psttv)+T("\r\n-------------------\r\n") ) ;
                        
                        }
                            ether.delF( tinBaseP , psttd ) ;
                            ether.strSubstringF( tinBaseP , psttv , idf , idl , psttd ) ; ___( psttv ) ;
                            countT idl = csMax ;
                            countT idf = 1 ;
                            strokeS* psttd = psttv ; psttv = 0 ;
                        {
                        if( psttv->idAdam > csMax ) 

                        countT csMax = TOCK ; //20200703@1637: ELIMINATE THIS CHOKE IN ORDER TO ACCOMMODATE Wo'O's Table Talk POSTS ; (note comment peanut ARE NOT CURRENTLY USED)

                        //;
                        //                : TUCK
                        //                ? TUCK << 2
                        //            !ether.strCompareF( tinBaseP , psttk , T("comment") )
                        //            !ether.strCompareF( tinBaseP , psttk , T("peanut" ) ) ||
                        //            !ether.strCompareF( tinBaseP , psttk , T("note"   ) ) ||
                        //        :
                        //        ? TOCK
                        //const countT csMax = 1 == ether.strIdF( tinBaseP , T("autoresponse.") , psttk )

                        }
                            ether.delF( tinBaseP , psttd ) ;
                            ether.strSubstringF( tinBaseP , psttk , idf , idl , psttd ) ; ___( psttk ) ;
                            countT idl = TUCK ;
                            countT idf = 1 ;
                            strokeS* psttd = psttk ; psttk = 0 ;
                        {
                        if( psttk->idAdam > TUCK ) 
                    
                        ether.strTrimF( tinBaseP , psttk , 0 , T(TbLACKnEWlINE) ) ; ___( psttk ) ;
                        ether.strConvertToLowerCaseF( tinBaseP , psttk ) ; ___( psttk ) ;
                        //LOGrAW( T("value after translation from url:\r\n--------\r\n")+T(psttv)+T("\r\n--------\r\n") ) ; //U::
                        ether.strFromUrlF( tinBaseP , psttv ) ; ___( psttv ) ;
                        ether.strFromUrlF( tinBaseP , psttk ) ; ___( psttk ) ;
                    {
                    if( psttk && psttk->idAdam && psttv ) //KEY MUST BE NONZE LENGTH SO THAT strIdF WON'T FAIL ; VALUE MAY BE ZE LENGTH WITHOUT BREAKING THIS CODE
                            
                    //LOGrAW( T("raw value:\r\n--------\r\n")+T(psttv)+T("\r\n--------\r\n") ) ; //U::
                    if( idf ) ether.strSubstringF( tinBaseP , psttv , idf , sttq , sttEq , psttc1 ) ; ___( psttv ) ;
                              ether.strSubstringF( tinBaseP , psttk , idf , sttq , sttEq , psttc1 ) ; ___( psttk ) ;
                    ZE( strokeS* , psttv ) ;
                    ZE( strokeS* , psttk ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf = 1 ;
                    _IO_
                {
                FORsTRINGSiN1( pstt1e )
                strokeS sttEq( '=' ) ;
                ether.strWordsOldF( tinBaseP , pstt1e , psttQueryKVP , sttq , T("&") ) ; ___( pstt1e ) ;
                strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , pstt1e ) ;
                _IO_
            {
            if( !bFailP && !POOP && psttQueryKVP ) // STORE THE KEY/VALUE PAIRS

            }
                }
                    }
                        ether.delF( tinBaseP , psttd ) ;
                        ether.strMakeF( tinBaseP , LF , psttQueryKVP , ( psttd ? T(psttd)+T("&") : T("") )+tBody ) ; ___( psttQueryKVP ) ; //ASSUME: psttQueryKVP IS OF FORM T("aaaa=1111&bbbb=2222&cccc=3333&dddd=4444")
                        psttQueryKVP = 0 ;
                        strokeS* psttd = psttQueryKVP ;
                        TN( tBody , "" ) ; tBody = T(postBodyP) ;
                                
                        //CONoUTrAW( T("--------\r\n")+T(postBodyP)+T("\r\n--------\r\n") ) ; //U::
                        //LOGrAW( T("raw body:\r\n--------\r\n")+T(postBodyP)+T("\r\n--------\r\n") ) ; //U::

                        if( postBodyP ) postBodyP[ costBody ] = 0 ;
                        _IO_
                    {
                    if( !bFailP )

                    }
                        }
                            }
                                }
                                    bFailP = 1 ;
                                    ether.delF( tinBaseP , postBodyP ) ;
                                    //ether.traceF( tinBaseP , T("readRequestF: could not read socket 175") ) ;
                                    POOPRqUIET
                                {
                                if( POOP )
                                psoP->readF( tinBaseP , postc , costToDo ) ;
                                SCOOPS
                            {
                            IFsCRATCH
                        {
                        if( costToDo )
                        countT costToDo = costBody - costzBodySome ;

                        if( costzBodySome ) { ether.memCopyF( tinBaseP , postc , postzBodySome , costzBodySome ) ; postc += costzBodySome ; }
                        osTextT* postc = postBodyP ;
                        _IO_
                    {
                    _IO_
                {
                if( postBodyP )
                ether.newF( tinBaseP , LF , postBodyP , costBody + 1 ) ; ___( postBodyP ) ;

                }
                    costBody = costzBodySome ;
                    ether.traceF( tinBaseP , T("readRequestF / apparent memory corruption attack (incorrect content length declaration) / costBody < costzBodySome [costBody,costzBodySome]:    ")+TF2(costBody,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(costzBodySome,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( costBody < costzBodySome )

                _IO_
            {
            if( costBody )
            TESTsCRATCH //U:: TO FIND A BUG
        {
        if( !bFailP )

        }
            ether.delF( tinBaseP , pstt1Line ) ;
            }
                TESTsCRATCH //U:: TO FIND A BUG
                }
                    ether.delF( tinBaseP , psttValue ) ;
                    ether.delF( tinBaseP , psttKey ) ;
                
                    }
                        }
                            ether.strMakeF( tinBaseP , LF , psttAgentP , psttValue ) ; ___( psttAgentP ) ;
                            if( psttAgentP ) ether.delF( tinBaseP , psttAgentP ) ;
                        {
                        else if( !ether.strCompareF( tinBaseP , psttKey , tKeyUserAgent     ) )
                        }
                            bCloseP = !ether.strCompareF( tinBaseP , psttValue , T("close") ) ;
                            //ether.traceF( tinBaseP , tKeyConnection+T(" header line encountered:   ")+T(psttValue) ) ;
                        {
                        else if( !ether.strCompareF( tinBaseP , psttKey , tKeyConnection    ) )
                             if( !ether.strCompareF( tinBaseP , psttKey , tKeyContentLength ) ) costBody = ether.strDigitsToSCountF( tinBaseP , psttValue , 0xa , 1 ) ;
                    
                        ether.strTrimF( tinBaseP , psttValue , 0 , T(TbLACKnEWlINE) ) ; ___( psttValue ) ;
                        ether.strSubstringF( tinBaseP , psttValue , idf , countTC() , psttc1 ) ; ___( psttValue ) ;
                    {
                    if( idf )
                    ether.strConvertToLowerCaseF( tinBaseP , psttKey ) ; ___( psttKey ) ;
                    ether.strSubstringF( tinBaseP , psttKey , idf , sttq , tColonWhite , psttc1 , 1 ) ; ___( psttKey ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    countT idf = 1 ;
                    ZE( strokeS* , psttValue ) ;
                    ZE( strokeS* , psttKey ) ;
                {
                else  // HEADER LINE ASSUMED TO BE OF THE FORM, FOR EXAMPLE,  "Content-Length:1234"
                }
                    }
                        swMapUrl.ungrabF( tinBaseP ) ;

                        }
                            }
                                }
                                    ether.strWordF( tinBaseP , psttQueryKVP , psttUrlNew , sttq , sttQuest , 2 ) ; ___( psttQueryKVP ) ;
                                    ether.strWordF( tinBaseP , psttNameP    , psttUrlNew , sttq , sttQuest , 1 ) ; ___( psttNameP    ) ;
                                {
                                else
                                }
                                    ether.strMakeF( tinBaseP , LF , psttNameP , psttUrlNew ) ; ___( psttNameP ) ;
                                {
                                if( !ether.strIdF( tinBaseP , sttQuest , psttUrlNew ) ) // HTTP/1.0 KEYvALUE PAIRS
                                strokeS sttQuest( '?' ) ;

                                ether.delF( tinBaseP , psttQueryKVP ) ;
                                ether.delF( tinBaseP , psttNameP ) ;
                            {
                            if( psttUrlNew && psttUrlNew->idAdam )

                            ether.traceF( tinBaseP , T("readRequestF / overriding Url [new]:    ")+T(psttUrlNew) ) ;
                            ether.traceF( tinBaseP , T("readRequestF / overriding Url [old]:    ")+tUrlOld       ) ;
                            strokeS*& psttUrlNew = *(strokeS**)&(countT&)swMapUrl ;
                        {
                        if( swMapUrl.idSlotOfLeverF( tinBaseP , (countT)psttLeverUrlMap ) )

                        psttLeverUrlMap = tUrlOld ;

                        swMapUrl.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                        TN( tUrlOld , "Rb" ) ; tUrlOld = T(psttNameP)+T("?")+T(psttQueryKVP) ;
                    {
                    if( !bFailP )

                    }
                        ether.delF( tinBaseP , psttw ) ;

                        //LOGrAW( T("from url[psttQueryKVP]: \"")+T(psttQueryKVP)+T("\"\r\n") ) ;

                        ether.strWordF( tinBaseP , psttQueryKVP , psttw , sttq , sttQuest , 2 ) ; ___( psttQueryKVP   ) ;
                        ether.strWordF( tinBaseP , psttNameP    , psttw , sttq , sttQuest , 1 ) ; ___( psttNameP      ) ;
                        psttNameP = 0 ;
                        strokeS* psttw = psttNameP ;
                    {
                    else if( ether.strIdF( tinBaseP , sttQuest , psttNameP ) ) // HTTP/1.0 KEYvALUE PAIRS
                    if( !psttNameP || !psttNameP->idAdam ) bFailP = 1 ;
                    strokeS sttQuest( '?' ) ;
                
                    ether.strWordF( tinBaseP , psttNameP , psttc1 , sttq , sttb , 2 ) ; ___( psttNameP ) ;
                    ether.strConvertToLowerCaseF( tinBaseP , psttAction ) ; ___( psttAction ) ;
                    ether.strWordF( tinBaseP , psttAction , psttc1 , sttq , sttb , 1 ) ; ___( psttAction ) ;
                    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
                    strokeS sttb( ' ' ) ;

                    //if( !bCloseP ) ether.traceF( tinBaseP , T("i did not set bCloseP") ) ;

                    }
                        ether.delF( tinBaseP , pstt1w ) ;
                        }
                            }
                                }
                                    bCloseP = 1 ;
                                    //ether.traceF( tinBaseP , T("    setting bClose") ) ;
                                {
                                if( !ether.strCompareF( tinBaseP , psttc1 , T("http/1.0") ) || !ether.strCompareF( tinBaseP , psttc1 , T("HTTP/1.0") ) )
                            {
                            if( BlATHsTRING1 )
                            //ether.traceF( tinBaseP , tb4+T(psttc1) ) ;
                        {
                        FORsTRINGSiN1( pstt1w )
                        ether.strWordsOldF( tinBaseP , pstt1w , psttc1 , sttq , T(" ") ) ; ___( pstt1w ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        ZE( strokeS* , pstt1w ) ;
                    {

                    //ether.traceF( tinBaseP , psttc1 ) ;
                {
                if( !psttAction ) // IF WO'TH LINE
            {
            FORsTRINGSiN1( pstt1Line )

            }
                ether.strWordsF( tinBaseP , pstt1Line , T(postHeadPlus) , sttq , T("\r\n") ) ; ___( pstt1Line ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            {
            ZE( strokeS* , pstt1Line ) ;
        {
        TN( tb4 , "    " ) ;
        TN( tKeyConnection    , "connection"     ) ;
        TN( tKeyUserAgent     , "user-agent"     ) ;
        TN( tKeyContentLength , "content-length" ) ;
        TN( tColonWhite , ": " ) ;
        ZE( strokeS* , psttAction ) ;
        ZE( countT , costBody ) ;

        }
            costzBodySome = costHeadPlus - costHead - 4 ;
            postzBodySome = postHeadPlus + costHead + 4 ;
        {
        if( costHeadPlus - costHead > 4 )
        ZE( countT   , costzBodySome ) ;
        ZE( osTextT* , postzBodySome ) ;
    {
    if( !bFailP )
    ZE( osTextT  , ostEscaped ) ; //U:: ELIMINATE THIS SINCE I NO LONGER SET IT (I NO LONGER USE readWoLineF)

    }
        }
            //CONoUTrAW( "\r\n" USCORE127 "\r\n" ) ;
            }
                }
                    break ;
                    ether.traceF( tinBaseP , T("readRequestF / woth mouthful did not contain a complete request") ) ;
                    bFailP = 1 ;    //P:PERSONALITY: TO PREVENT STALL ATTACK, I REQUIRE THAT THE WOTH MOUTHFUL CONTAIN A COMPLETE REQUEST
                {
                if( !bEnd && !( -- cMouthfulsAllowed ) )
                //BROWSERS TRIGGER THIS (FIREFOX EDGE SAMSUNG)

                }
                    //CONoUTrAW( postcWas ) ;

                    costHead += delta ;

                    }
                        *poste = 0 ;
                        delta = poste - postcWas ;
                        bEnd = 1 ;
                    {
                    if( poste )

                    costRemain   -= delta ;
                    postc        += delta ;
                    costHeadPlus += delta ;

                    osTextT* postcWas = postc ;

                    osTextT* poste = thirdC::c_strstrIF( tinBaseP , postc , "\r\n\r\n" ) ;
                {
                else
                if( !delta ) break ;

                }
                    }
                        break ;
                        bFailP = 1 ;
                        //ether.traceF( tinBaseP , T("readRequestF: could not read socket 175") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    delta = psoP->readF( tinBaseP , postc , costRemain , flSOCKETcrEAD_JUSToNEmOUTHFUL | flSOCKETcrEAD_STILLhUNGRYiSoK ) ;
                    SCOOPS
                {
                IFsCRATCH
                ZE( countT , delta ) ;
            {
            while( !bEnd && costRemain )
            countT cMouthfulsAllowed = 2 ;
            ZE( boolT , bEnd ) ;
            countT   costRemain = costaHeadPlus ;        
            osTextT* postc      = postHeadPlus  ;
            //CONoUTrAW( "\r\n" USCORE127 "\r\n" ) ;

            //ether.memSetF( tinBaseP , postHeadPlus , costaHeadPlus ) ;
        {
        if( postHeadPlus )
        ether.newF( tinBaseP , LF , postHeadPlus , costaHeadPlus ) ; ___( postHeadPlus ) ;
        const countT costaHeadPlus = ifcCBdATAGRAMmAX ;
    {
    ZE( countT   , costHead     ) ;
    ZE( countT   , costHeadPlus ) ;
    ZE( osTextT* , postHeadPlus ) ;

    _IO_

    __( bCloseP ) ;

    TESTsCRATCH //U:: TO FIND A BUG
    scoopC scoop( tinBaseP , LF , ether ) ;  //U:: 20201021@1350: ADDED WITHOUT ANALYSIS.  ALL MEMBER FUNCTIONS OF CLASSES WITH AN ether MEMBER SHOULD DO THIS
{
/*1*/osTextT httpServerC::readRequestF( tin0S& tinBaseP , boolT& bFailP , strokeS*& psttNameP , strokeS*& psttQueryKVP , switchC& swKVP , strokeS*& psttLeverKVP , strokeS*& psttAgentP , osTextT*& postBodyP , boolT& bCloseP , socketC* psoP , const osTextT* const postEscapeP )/*1*/
/**/
*/
/*


//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

