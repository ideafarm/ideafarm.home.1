
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("ok") ) ;

THREADmODE4rESTORE

etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_SHUTDOWN ) ;
etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_UNREGISTERtHREAD ) ;
etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_UNWATCH ) ;
}
    }
        bitTree.walkF( tinBaseP , pbBuffer , sizeof pbBuffer , countTC() ) ;
        byteT pbBuffer[ TOCK ] ;

        bitTree.traceF( tinBaseP , countTC() ) ;

        //else etThread.traceF( tinBaseP , T("[bUp,cDo]: ")+T(bUp?"up   ":"down ")+TF3(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9) ) ;
        //}
        //    cNewLag = cNew ;
        //    etThread.traceF( tinBaseP , T("[bUp,cDo,cNew]: ")+T(bUp?"up   ":"down ")+TF3(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(cNew,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9) ) ;
        //    countT cNew = bitTree.cRemainingF() / sizeof( bitNodeS ) ;
        //{
        //if( bitTree.cRemainingF() )

        //etThread.traceF( tinBaseP , psttSay2 ) ;

        }
            }
                }
                    //else -- pbTuck[ offt ] ;
                    //}
                    //    offt = 0 ;
                    //    etThread.traceF( tinBaseP , T("resetting offt [offDoInner,offt]: ")+TF3(offDoInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9)+TF3(offt,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,9) ) ;
                    //{
                    //if( !( offDoInner % TUCK ) && !( offt -- ) )
                    //U::OBSOLETE: REWRITE USING bUp CODE AS BASELINE
                {
                else
                }
                    }
                        if( ++ offt == sizeof pbTuck ) break ;
                    {
                    while( !( ++ pbTuck[ offt ] ) )
                    ZE( countT , offt ) ;                           //ADD 1 TO pbTuck
                {
                if( bUp )

                }
                    break ;
                    etThread.traceF( tinBaseP , T("error detected.  aborting") ) ;
                    POOPR
                {
                if( POOP )

                //REVERSEbITS
                bitTree.newF( tinBaseP , LF , pbTuck , 0 , sizeof pbTuck * SB ) ;
                //REVERSEbITS

                //etThread.traceF( tinBaseP , T("[*(countT*)pbTuck]: ")+TF2(*(countT*)pbTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                //if( !( offDoInner % ( TOCK >> 4 ) ) ) etThread.traceF( tinBaseP , TF2(capacity,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(bitTree.cRemainingF(),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            for( countT offDoInner = 0 ; offDoInner < cDo ; offDoInner ++ )

            SCOOPS
        {
        IFsCRATCH

        const countT capacity = bitTree.cRemainingF() ;

        //bitTreeC bitTree( tinBaseP , "bt" ) ;
        bitTreeC bitTree( tinBaseP , "bt" , 0 ) ;

        //etThread.traceF( tinBaseP , psttSay1 ) ;

        thirdC::c_memsetIF( tinBaseP , pbTuck , sizeof pbTuck , 0 ) ;
        //byteT pbTuck[ TUCK ] ;
        byteT pbTuck[ 1 ] ;

        //B:countT cDo = - 1 ;
        //G:countT cDo = TOCK ;
        countT cDo = 0x8 ;
    {
    for( boolT bUp = 1 ; bUp <= 1 ; bUp ++ )
    ZE( countT , cNewLag ) ;

    const strokeS* const psttSay2 = tSay2 ;
    const strokeS* const psttSay1 = tSay1 ;
    TN( tSay2 , "loaded" ) ;
    TN( tSay1 , "loading" ) ;
{
etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_WATCH ) ;
etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_REGISTERtHREAD ) ;
etThread.etherWhereF( tinBaseP , ifcIDaCTIONwHERE_SETUP , flETHERwHERE_null , 1 ) ;

THREADmODE4oN( flTHREADmODE4_DOnOTrEGISTERpAGEc )

TODO

#define REVERSEbITS for( countT offr = 0 ; offr < sizeof pbTuck ; offr ++ ) pbTuck[ offr ] = reverseBitsF( pbTuck[ offr ] ) ;


/*1*/WAKEsHOWtEXT( "example.other.1snip.15000175.bitTreeC" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

