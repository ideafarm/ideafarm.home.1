
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    bQuit = 1 ;
    etherC::loafIF( tin0P ) ;

    }
        ++ s ; ether.osSleepF( tin0P , TICK >> 4 ) ;        // PRUNING IS DONE EACH MINUTE, SO A GIVEN ATTACKER MUST WAIT AT LEAST A MINUTE BEFORE HAVING ANOTHER CHANCE TO GET A PACKET INTO THE TARGET

        }
            }
                etThread.delF( tin0P , psttd ) ;

                countT rc = thirdC::c_systemIF( tin0P , tCommand ) ;
                //etThread.traceF( tin0P , tCommand ) ;
                TN( tCommand , "netsh advfirewall firewall delete rule name=\"" ) ; tCommand += T(psttd)+T("\"") ;

                stRule >> psttd ;
                ZE( strokeS* , psttd ) ;
            {
            while( !ether && stRule > 0x10 )              // PULL THE RULE NAMES CONTAINING THE EARLIEST (SMALLEST VALUE) DATETIMES AND DELETE THEM

            //}
            //    while( ~hWalk ) ;
            //    }
            //        //etThread.traceF( tin0P , T("    [rule]:    ")+T(psttr) ) ;
            //        __Z( psttr ) ;
            //        strokeS* psttr = (strokeS*)stRule.downF( tin0P , hWalk ) ;
            //    {
            //    do
            //    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            //{
            //if( stRule )
            //etThread.traceF( tin0P , T("[cRules]:    ")+TF2(stRule,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                }
                    }
                        }
                            }
                                etThread.delF( tin0P , pstts ) ;                                                                // DUPLICATE NAMES WILL ONLY EXIST IF THE USER MANUALLY COPIES AND PASTES RULES
                                etThread.traceF( tin0P , T("!exception: sink unique failed [ruleName]:    ")+T(pstts) ) ;       // RULES WITH DUPLICATE NAMES COULD BE DELETED HERE, BUT THEY WILL BE DELETED ANYWAY AS NEW RULES WITH LATER DATES ARE ADDED
                            {                                                                                                   // P:PERSONALITY: I IGNORE DUPLICATE RULE NAMES
                            else
                            if( ids ) ;
                            stRule.sinkF( tin0P , ids , pstts , flSTACKsINK_UNIQUE , 0 , 0 ) ;          // RULE NAMES CONTAINING THE MOST RECENT (LARGEST VALUE) DATETIMES WILL SINK TO THE BOTTOM
                            ZE( countT , ids ) ;

                            //etThread.traceF( tin0P , T("sinking [name]:    ")+T(pstts) ) ;
                        {
                        if( 1 == etThread.strIdF( tin0P , tIPDOS , pstts ) )
                        etThread.strTrimF( tin0P , pstts ) ; ___( pstts ) ;
                    {
                    if( bFound )
                    bFound = etThread.strSubstringF( tin0P , pstts , idf , sttq , tCRLF , tList , 1 ) ; ___( pstts ) ;
                    etThread.delF( tin0P , pstts ) ;
                {
                if( bFound && idf )
                boolT bFound = etThread.strSubstringF( tin0P , pstts , idf , sttq , tRuleName , tList ) ; ___( pstts ) ;
                ZE( strokeS* , pstts ) ;
            {
            while( !ether && idf )
            stackC stRule( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            TN( tCRLF     , "\r\n"       ) ;
            TN( tRuleName , "Rule Name:" ) ;
            TN( tIPDOS    , "IPDOS(tm) osFirewallBlockF" ) ;

            }
                etThread.delF( tin0P , posti ) ;
                tList = T(posti) ;
                etThread.boxGetF( tin0P , posti , costi , tLongMapped ) ; ___( posti ) ;
                ZE( countT   , costi ) ;
                ZE( osTextT* , posti ) ;
            {
            TN( tList , "" ) ;
        {
        if( !ether )

        //  
        //  Action:                               Allow
        //  Edge traversal:                       No
        //  Protocol:                             Any
        //  RemoteIP:                             Any
        //  LocalIP:                              Any
        //  Grouping:                             Solitaire & Casual Games
        //  Profiles:                             Domain,Private,Public
        //  Direction:                            Out
        //  Enabled:                              Yes
        //  ----------------------------------------------------------------------
        //  Rule Name:                            Solitaire & Casual Games
        //  

        countT rc = thirdC::c_systemIF( tin0P , tCommand ) ;
        //etThread.traceF( tin0P , tCommand ) ;
    {
    while( !ether )             // PERIODICALLY DELETE OLD BLOCK RULES IN FIREWALL
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    TN( tCommand , "netsh advfirewall firewall show rule name=all > " ) ; tCommand += T(osfnLongList) ;
    TN( tb4  , "    " ) ;
    TN( tb  , " " ) ;

    osFileNameC osfnLongList( tin0P , etThread , tLongMapped ) ;

    etThread.diskMakeDirIfNeededF( tin0P , tLongMapped    ) ;
    }
        etThread.delF( tin0P , psttm ) ;
        tLongMapped = T(psttm) ;
        etThread.diskMapFileNameF( tin0P , psttm , tLongList ) ; ___( psttm ) ;
        TN( tLongList , "///ideafarm/tmp/" ) ; tLongList += TfORsTRING(ifcIDaDAM_TOOLdOmANUALLY) + T("/rules.raw.ttt") ;
        ZE( strokeS* , psttm ) ;
    {
    TN( tLongMapped , "" ) ;

    etThread.osThreadF( TaRG2cBsTACK( tmLaunchBatExeFilesF , CBsTACKmIN << 1 ) , (countT)&bQuit ) ;
    ZE( boolT , bQuit ) ;
{
if( pTaskP )
TASK( tmWorkF )

DONE( tmLaunchBatExeFilesF )
}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK >> 0 ) ;    //THIS IS FOR SAFETY TO PREVENT CPU PEGGING AT MY PUSHY DESIRE

        if( bCallingWait ) ;//etRock.traceF( tin0P , T("calling diskWaitDirF") ) ;
        }
            if( bWoth ) bWoth = 0 ;

            }
                FORsTRINGSiNsPANNEDcOMBINEDtAIL1
                }
                    }
                        }
                            etThread.diskMoveFileOrDirF( tin0P , tLongTo , tLong ) ;
                            //etThread.traceF( tin0P , T("moving [to]:    ")+tLongTo ) ;

                            }
                                etThread.delF( tin0P , psttld ) ;
                                tLongTo = T(psttld) ;
                                etThread.strReplaceF( tin0P , psttld , tLong , tSlashDropSuffix , bWoth ? tSlashIgnoredSuffix : tSlashDoneSuffix ) ; ___( psttld ) ;
                                ZE( strokeS* , psttld ) ;
                            {
                            TN( tLongTo , "" ) ;

                            }
                                }
                                    }
                                        etThread.traceF( tin0P , T("!exception / could not launch [tLong]:    ")+tLong ) ;
                                        POOPRqUIET
                                    {
                                    if( POOP )

                                    CONoUTrAW( "\r\n" ) ;
                                    ((tin1S&)tin0P).pEtScratch->osProcessF( tin0P , countTC() , countTC() , countTC() , countTC() , tLong ) ;
                                    CONoUTrAW( "\r\n" ) ;

                                    SCOOPS
                                {
                                IFsCRATCHoK
                                etThread.traceF( tin0P , T("launching [tLong]:    ")+tLong ) ;
                            {                                                                       //A:ASSUME: FILES ARE STATELESS, IN THAT A FILE CAN BE OMITTED WITHOUT CHANGING THE OUTCOME OF THE PASS
                            if( !bWoth )                                                            //P:PERSONALITY: I PURGE ALL FILES THAT ARE WAITING FOR ME WHEN I START UP ; I ONLY HIRE FILES THAT ARE NEWLY DROPPED AFTER I START

                            //etThread.traceF( tin0P , tLong ) ;

                            etThread.delF( tin0P , psttm ) ;
                            TN( tLong , psttm ) ;
                            etThread.diskMapFileNameF( tin0P , psttm , psttc1 ) ; ___( psttm ) ;
                            ZE( strokeS* , psttm ) ;
                        {
                        if( etThread.strIdF( tin0P , tDotBat , psttc1 ) && !etThread.strIdF( tin0P , tDotHeyWritingDot , psttc1 ) )
                    {
                    if( psttc1[ CSpREFIX - 1 + psttc1->idAdam ].idAdam != '/' )                                 // IF NOT DIRECTORY
                {
                FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
                etThread.boxMenuF( tin0P , soul1m , tLongDrop+T("*") , 0 , TUCK ) ;
                soulC soul1m( tin0P , etThread , TAG( TAGiDnULL ) , flSOUL_null , "soul.launch.bat.and.exe" ) ;
            {
            if( bWoth || bChanged )

            if( !bWoth ) ;//etThread.traceF( tin0P , T("waited  for a change [tLongDrop]:    ")+tLongDrop ) ;

            if( bQuitP ) break ;
            bCallingWait = 0 ;
            if( bCallingWait ) ;//etRock.traceF( tin0P , T("called diskWaitDirF") ) ;
        {
        if( bWoth || ( bChanged = etThread.diskWaitDirF( tin0P , hWait , bQuitP , tLongDrop , TOCK << 2 , flWAITdIR_RECURSE | flWAITdIR_FILEnAME | flWAITdIR_DIRnAME ) , bChanged ) )     //P:PERSONALITY: FIRING ME HAS NO EFFECT ; I KEEP WORKING UNTIL THE KID PROCESS ENDS
        if( bCallingWait ) ;//etRock.traceF( tin0P , T("calling diskWaitDirF") ) ;
        if( !bWoth ) ;//etThread.traceF( tin0P , T("waiting for a change [tLongDrop]:    ")+tLongDrop ) ;
        boolT bCallingWait = !bWoth ;
        ZE( boolT , bChanged ) ;
    {
    while( !bQuitP && !POOP )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    boolT bWoth = 1 ;
    TN( tDotHeyWritingDot , ".!writing." ) ;
    TN( tDotBat , ".bat" ) ;

    etThread.diskMakeDirIfNeededF( tin0P , tLongIgnored ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tLongDone    ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tLongDrop    ) ;

    TN( tSlashIgnoredSuffix , "/ignored"                                ) ; tSlashIgnoredSuffix += tSuffix ;
    TN( tSlashDoneSuffix    , "/done"                                   ) ; tSlashDoneSuffix    += tSuffix ;
    TN( tSlashDropSuffix    , "/drop"                                   ) ; tSlashDropSuffix    += tSuffix ;
    TN( tLongIgnored        , "///d/ideafarm.home.101/controls/ignored" ) ; tLongIgnored        += tSuffix ;
    TN( tLongDone           , "///d/ideafarm.home.101/controls/done"    ) ; tLongDone           += tSuffix ;
    TN( tLongDrop           , "///d/ideafarm.home.101/controls/drop"    ) ; tLongDrop           += tSuffix ;
    TN( tSuffix             , ".executables.manual/" ) ;

    boolT& bQuitP = *(boolT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmLaunchBatExeFilesF )                    //P:PERSONALITY: I LAUNCH (AND EAT) BAT AND EXE FILES SO THAT THEY WON'T BE DEBUGGED, SO WILL SURVIVE EVEN IF WO OF THEM CAUSES ME TO DIE

//CS:CODEsYNC: PSEUDOdUPLICATE: 5100083a 510008b5

//BASELINE: ifcIDaDAM_TOOLwATCHfOLDER

/*1*/WAKEhIDE( "ifcIDaDAM_TOOLdOmANUALLY" )/*1*/
/**/
*/
\<A HREF=\"5.d840104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

