
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tin0P , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    }
        etThread.osSleepF( tin0P , TOCK ) ;

        }
            etThread.strokeF( tin0P , T("connecting to data eater\r\n") ) ;
            etThread = 0 ;
            sOut.writeMsgF( tin0P , "!amDry" ) ;
            etThread = 0 ;

            etThread.strokeF( tin0P , T("sending termination to data eater\r\n") ) ;
            }
                etThread.osSleepF( tin0P , TUCK * 32 ) ;
            {
            while( !ether && etThread.os_cAllKidThreadsI_IF( tin0P ) > !!( ether & fliEC_QUITTING ) )

            etThread.strokeF( tin0P , T("a failure has been detected.  waiting for all kid threads to end\r\n") ) ;
            }
                else        { ZE( countT , tnu ) ; etThread.osThreadF( tin0P , tnu , tmRouteF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)pso , (countT)&sOut ) ; }
                if( ether ) { DEL( pso ) ; }

                sIn.acceptF( tin0P , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
                ZE( countT , idPortPeer ) ;
                nicNameC nnPeer ;
                ZE( socketC* , pso ) ;
            {
            while( !etThread )

            sIn.listenF( tin0P ) ;
            sIn.bindF( tin0P , ifcPORToLD1rIVERrESERVED ) ;
            socketC sIn( tin0P , etThread , TAG( TAGiDnULL ) ) ;

            sOut.connectF( tin0P , ifcPORToLD1dATAeATER ) ;
            socketC sOut( tin0P , etThread , TAG( TAGiDnULL ) ) ;
        {
    {
    while( !ether )

    etThread.strokeF( tin0P , T("IdeaFarm " "(tm) City Data Router to Handler Process\r\ni route incoming data (normally from remote hosts) to the (normally local)\r\nsocket that handles its type\r\n") ) ;
{
else
}
    etThread.strokeF( tin0P , T("Another ")+textIdFileC( tin0P , DDNAME )+T(" appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tin0P , TAG( TAGiDnULL ) , T("1f30104") ) ;

__1 // RETIRED

TODO

DONE( tmRouteF )

}
    DEL( pso ) ;

    while( !bDry ) ;
    }
        etThread.delF( tin0P , pbMsg ) ;
        if( !bDry ) sOut.writeMsgF( tin0P , pbMsg , cbMsg ) ; // CAN INSPECT DATA TYPE AND SELECT AMONG MULTIPLE POSSIBLE RECIPIENTS, INCLUDING RECIPIENTS AT HOSTS MAINTAINED BY OTHER HUMAN CITIZENS.  (NOTE: pbMsg MIGHT CONTAIN MORE THAN ONE DATUM)
        bDry = cbMsg == tDry.csF( tin0P ) && !etThread.strCompareF( tin0P , T(pbMsg) , tDry ) ;
        pso->readMsgOkF( tin0P ) ;
        countT cbMsg = pso->readMsgF( tin0P , pbMsg ) ;
        ZE( byteT* , pbMsg ) ;
    {
    do
    ZE( boolT , bDry ) ;
    TN( tDry , "!amDry" ) ;

    pso->etherF( tin0P , etThread ) ;
    socketC& sOut = *(socketC*)pTaskP->c2 ;
    socketC* pso  =  (socketC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmRouteF )

/*1*/WAKEhIDE( "city.data.router.to.handler.process" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

