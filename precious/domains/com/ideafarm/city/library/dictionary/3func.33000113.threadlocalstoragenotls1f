
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return rc ;

    dec02AM( processGlobal2I.cTls ) ;

    }
        rc = sf.rc ;

        }
            processGlobal2I.flDt |= flCTdTg_THREADlOCALsTORAGE ;



            }
                }
                    }
                        ++ s ; thirdC::dosSleepWinkIF( tin0P ) ;
                        ((etherC*)0)->traceF( tin0P , (strokeS*)"--------------------------------------------------------------------- threadLocalStorageNoTls1F   napping for a wink" , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                    {
                    while( processGlobal2I.cTls > 1 )
                    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                {
                _IO_
                TINSL
            {
        {
        if( /*!( F(processGlobal2I._thirdC_flagsProcessState) & flPROCESSsTATE_ RECEIVEDsIGNALtObEfIRED ) &&*/ ( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WINDOW || idTypeP == ifcIDtYPEtLS_BENCH ) )
    
        }
            else                                                                                                         sf.rc = 1 ;
            else if( idTypeP == ifcIDtYPEtLS_KID || idTypeP == ifcIDtYPEtLS_EXCEPTION || idTypeP == ifcIDtYPEtLS_BENCH ) sf.rc = (*pThreadWorkF)( cArgP ) ;
            }
                ((etherC*)0)->traceF( tin0P , (strokeS*)"--------------------------------------------------------------------- threadLocalStorageNoTls1F   ----" , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
                sf.rc = mainThreadWorkF( idTypeP , cHowP , ppostHowP , hWindowingClientIP , hPreviousWindowingClientP , postP , idCmdShowP ) ;
                ((etherC*)0)->traceF( tin0P , (strokeS*)"--------------------------------------------------------------------- threadLocalStorageNoTls1F   ++++" , flTRACE_PARAMETERiSoStEXT | flTRACE_FORCEnOsILENCE ) ;
            {
            if( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WINDOW )
            _IO_
            TINSL
        {
    
        }
            if( pTinF() != &sf.tinEarlyLate ) { BLAMMO ; }
            sf.pTin = pTinMainI_IF() ;
            bTlsEarlyLateIF() = 0 ; if( &pTinF() != &sf.pTin        ) { BLAMMO ; }
                                    if( &pTinF() != &pTinMainI_IF() ) { BLAMMO ; }

            // THE JOB DONE BY THE FOLLOWING LINES CANNOT EASILY BE DONE AT tin1S   CT TIME BECAUSE offFingerVerify123I CANNOT BE SET THERE; IT MUST BE SET IN THIS STACK FRAME
            // ALL OF THIS IS UNWOUND BY THE NORMAL UNWINDING CODE THAT IS EXECUTED DURING ~tin1S  , AND THAT CODE ALSO SETS bTlsEarlyLateI
            // WHEN sf.tinEarlyLate WAS CT, pTinMainI WAS UPDATED ; NOW THAT offFingerVerify123I IS SET, bTlsEarlyLateI CAN BE RESET, AND pTinMainI LOADED INTO sf.pTin

            processGlobal2I.flCt |= flCTdTg_THREADlOCALsTORAGE ;
        {
        if( idTypeP == ifcIDtYPEtLS_CONSOLE || idTypeP == ifcIDtYPEtLS_WINDOW || idTypeP == ifcIDtYPEtLS_BENCH )

        //IF WDW EVER FAILS TO LOAD ITS INFO, DEBUG STARTUP (IF YOU CAN); ELSE USE OTHER MEANS (WRITE TO CONSOLE) TO SEE THE NEW OFFSETS
        //I HAVE SEEN WDW FAIL TO LOAD SYMBOLIC INFO BECAUSE THE OFFSET OF sf FROM [ebp] CHANGED, AND APPARENTLY pTin1AM   CRAPPED EARLY ON SOME DEBUGGING INFO SO WDW COULDN'T EVEN GET THE MODULE LOADED

        tlsStackFrameNoTls1S   sf( idTypeP , ebpAM()         , cArgP ) ; //CODE SYNC: THE OFFSET OF SOME MEMBERS OF sf FROM [ebp] (THE STACK FRAME) IS HARDCODED IN snip.009*
    {
    inc02AM( processGlobal2I.cTls ) ;
    ZE( countT , rc ) ;

    #endif
        }
            }
                processGlobal2I.pbMemoryBitsStack[ offByte ] |= mask ;
                processGlobal2I.pbMemoryBitsAll[   offByte ] |= mask ;
                if( offByte >= sizeof processGlobal2I.pbMemoryBitsPrivate ) { BLAMMO ; }
                byteT  mask     = (byteT)( 1 << offBit ) ;
                countT offBit   = offGrain % SB ;
                countT offByte  = offGrain / SB ;
                countT offGrain = c_pv / TOCK ;
                //CS:PSEUDOdUPLICATE: 35001041 3500105b 3300000d 3300002d
            {
            for( countT c_pv = (countT)info.AllocationBase ; c_pv <= (countT)info.BaseAddress ; c_pv += TOCK )

            VirtualQuery( (voidT*)ebpAM() , &info , sizeof info ) ;
            MEMORY_BASIC_INFORMATION info ;
        {
    #if defined( SHOWmEMgRAINS )
{
/*1*/countT __export threadLocalStorageNoTls1F(   const countT idTypeP , kidFT pThreadWorkF , countT cArgP , countT cHowP , const osTextT** ppostHowP , countT hWindowingClientIP , countT hPreviousWindowingClientP , osTextT* postP , countT idCmdShowP )/*1*/

// NOTE: I MUST BE COMPILED WITH OPTIMIZATIONS DISABLED (-od)

/**/
*/
pTin, if not ze, points to the tin1S  , object for this thread
then the value in pTin can be obtained
my stack frame can be found by walking the stack looking for FINGERnEG_THREADlOCALsTORAGE
i allocate oo objects on the thread's stack so that they can be found at known offsets within the stack frame
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

