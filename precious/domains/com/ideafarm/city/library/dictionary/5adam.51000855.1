
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

THREADmODE2rESTORE
THREADmODE3rESTORE
THREADmODE4rESTORE

}
    }
        etThread.traceF( tinP , T("[pFoo,name]:    ")+TfORsTRING((countT)pFoo)+T("    ")+T(pFoo->sayF(fpp)) ) ;
        fooC* pFoo = &APT( fooC , aptFoo ) ;

        etThread.traceF( tinP , T("[*pcIdApt]:    ")+TF2(*pcIdApt,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        }
            *pcIdApt = aptFoo ;
            aptFoo = aptC( tinP , (byteT*)pFoo ) ;
            fooC* pFoo = new( 0 , tinP , LF ) fooC( fpp ) ;
        {
        else
        if( *pcIdApt ) aptFoo = *(aptC*)pcIdApt ;
        aptC aptFoo ;
        etThread.traceF( tinP , T("[*pcIdApt]:    ")+TF2(*pcIdApt,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        countT*   pcIdApt = vspIdApt ;
        countVSP vspIdApt = listC::countIF( tinP , myRecord , count2S( 1 | BM_HIGH ) ) ;
    {

    recordC myRecord( tinP , pcNameRecord ) ;
    countT pcNameRecord[] = { LISTnAME_ROOT , LISTnAME_APPLICATION , LISTnAME_HOME , 0 } ;

    puseC puseHT( tinP , ifcIDpOOL_HOMEtEMP ) ;
    _IO_
{


THREADmODE4oN( flTHREADmODE4_ALLOWwRITEABLEpOINTERgET                                           )
THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY       | flTHREADmODE3_ALLOWnEWdROPnOTiNaDAMtEMP )
THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING                                             )

fooPerProcessC fpp( "myName" ) ;

TODO

}
    return fppP.postName ;
    CONoUTrAW( "\r\n" ) ;
    CONoUTrAW( fppP.postName ) ;
    CONoUTrAW( "\r\nmy name is:\r\n" ) ;
{
const osTextT* fooC::sayF( fooPerProcessC& fppP )

}
    CONoUTrAW( "\r\n" ) ;
    CONoUTrAW( fppP.postName ) ;
    CONoUTrAW( "\r\n" ) ;
{
fooC::fooC( fooPerProcessC& fppP )

NEWdELcLASS( 1 , fooC ) ;

;
}
    const osTextT* sayF( fooPerProcessC& fppP ) ;
                   fooC( fooPerProcessC& fppP ) ;
                   NEWdELcLASSpROTOS

    public :

{
class fooC

;
}
    friend class fooC ;

    inline fooPerProcessC( const osTextT* const postNameP ) : postName( postNameP ) {}

    public :

    const osTextT* const postName ;
{
class fooPerProcessC

class fooC ;


// OBJECTIVE: BASE CLASS THAT ENABLES A CLASS INSTANCE TO RESIDE IN SHARED MEMORY BUT ALSO HAVE MEMBERS THAT ARE STORED PER PROCESS

/*1*/WAKEsHOWtEXT( "doodle.sharable.class.instance" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
