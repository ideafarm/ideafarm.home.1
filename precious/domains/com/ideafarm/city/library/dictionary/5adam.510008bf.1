
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    DEL( ppSub[ offs ] ) ;
{
for( countT offs = 0 ; offs < sizeof ppSub / sizeof ppSub[ 0 ] ; offs ++ )

}
    ++ s ; ether.osSleepF( tin0P , TUCK >> 6 ) ;

    }
        }
            etThread.traceF( tin0P , T("[time,rc,cmd]:    ")+TT(timeN1,timeN2)+tb4+TF3(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+tCommand ) ;
            countT rc = thirdC::c_systemIF( tin0P , tCommand ) ;
            TN( tCommand , "" ) ; tCommand = tCmd1+tNn+tCmd2 ;

            //etThread.traceF( tin0P , T("[offs,nnNow]:    ")+TF3(offs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+tNn ) ;

            TN( tNn , "" ) ; tNn = T(nnNow) ;
            nicNameC nnNow = ppSub[ offs ]->nnF( tin0P , hash , minute ) ;
            ZE( count04T , hash ) ;
        {
        for( countT offs = 0 ; offs < sizeof ppSub / sizeof ppSub[ 0 ] ; offs ++ )

        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;

        //etThread.traceF( tin0P , tDash ) ;
        minuteLath = minute ;
    {
    if( minuteLath != minute )
    //CONoUTrAW( "." ) ;
    countT minute = timeN1 >> 0x14 ;

    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT  , timeN1 ) ;
{
while( !ether )
sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
ZE( countT , minuteLath ) ;

TN( tDash , DASH256 ) ;

TN( tCmd2 , " store=active validlifetime=2m preferredlifetime=2m" ) ;
TN( tCmd1 , "netsh interface ipv6 add address \"ideanet\" " ) ;

ZE( ideaNetSubscriptionC* , pSub ) ;

}
    welcomeF( tin0P , etThread , ppSub[ offs ] , T("foo@ideafarm.com") ) ; ___( ppSub[ offs ] ) ;
{
for( countT offs = 0 ; offs < sizeof ppSub / sizeof ppSub[ 0 ] ; offs ++ )

thirdC::c_memsetIF( tin0P , (byteT*)ppSub , sizeof ppSub ) ;
//ideaNetSubscriptionC* ppSub[ TUCK << 2 ] ;
ideaNetSubscriptionC* ppSub[ 1 ] ;

TN( tb4 , "    " ) ;

TODO

}
    pSubP = new( 0 , tin0P , LF ) ideaNetSubscriptionC( tin0P , etherP , 1 , idSub , tSecret ) ; ___( pSubP ) ;

    etherP.traceF( tin0P , T("[idBook,idSub,generatedSecret]:    ")+TF2(idBook,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idSub,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tSecret ) ;
    }
        etherP.delF( tin0P , psttMac ) ;
        tSecret = T(psttMac) ;
        etherP.openSslHmacF( tin0P , psttMac , tEmail , tEmail.csF( tin0P ) , (byteT*)&timeN1 , sizeof timeN1 ) ; ___( psttMac ) ;
        ZE( strokeS* , psttMac ) ;
    {
    TN( tSecret , "" ) ;

    TN( tEmail , psttEmailP ) ;
    TN( tb4    , "    " ) ;

    if( idBook != 1 || idSub != 1 ) etherP.osTimeNowF( tin0P , timeN1 , timeN2 ) ;      // FOR BOOK 1 SUB 1, I ALWAYS GENERATE THE SAME SECRET, WHICH IS HARDCODED INTO IDEANET.EXE
    ZE( sCountT , timeN2 ) ;
    ZE( countT  , timeN1 ) ;

    countT idSub = 1 + incv02AM( idSubLath ) ;
    static countT idSubLath ;
    countT idBook = 1 ;
{
voidT welcomeF( tin0S& tin0P , etherC& etherP , ideaNetSubscriptionC*& pSubP , const strokeS* const psttEmailP )

/*1*/WAKEhIDE( "ifcIDaDAM_TOOLrANDOMiPV6" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
