
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    DEL( ppSub[ offs ] ) ;
{
for( countT offs = 0 ; offs < sizeof ppSub / sizeof ppSub[ 0 ] ; offs ++ )

}
    ++ s ; ether.osSleepF( tin0P , TUCK >> 6 ) ;

    }
        }
            etThread.traceF( tin0P , T("[time,rc,cmd]:    ")+TT(timeN1,timeN2)+tb4+TF3(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+tCommand , flTRACE_NOpREFIX | flTRACE_NOcRlFaTbEGINNING ) ;
            countT rc = thirdC::c_systemIF( tin0P , tCommand ) ;
            TN( tCommand , "" ) ; tCommand = tCmd1+tNn+tCmd2 ;

            //etThread.traceF( tin0P , T("[offs,nnNow]:    ")+TF3(offs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4+tNn ) ;

            TN( tNn , "" ) ; tNn = T(nnNow) ;
            nicNameC nnNow = ppSub[ offs ]->nnF( tin0P , minute ) ;
        {
        for( countT offs = 0 ; offs < sizeof ppSub / sizeof ppSub[ 0 ] ; offs ++ )

        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;

        //etThread.traceF( tin0P , tDash ) ;
        minuteLath = minute ;
    {
    if( minuteLath != minute )
    //CONoUTrAW( "." ) ;
    countT minute = timeN1 >> 0x14 ;

    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT  , timeN1 ) ;
{
while( !ether )
sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
ZE( countT , minuteLath ) ;

TN( tDash , DASH256 ) ;

TN( tCmd2 , " store=active validlifetime=2m preferredlifetime=2m" ) ;
TN( tCmd1 , "netsh interface ipv6 add address \"ideanet\" " ) ;

ZE( subC* , pSub ) ;

}
    welcomeF( tin0P , etThread , ppSub[ offs ] , T("foo@ideafarm.com") ) ; ___( ppSub[ offs ] ) ;
{
for( countT offs = 0 ; offs < sizeof ppSub / sizeof ppSub[ 0 ] ; offs ++ )

thirdC::c_memsetIF( tin0P , (byteT*)ppSub , sizeof ppSub ) ;
//subC* ppSub[ TUCK << 2 ] ;
subC* ppSub[ 1 ] ;

TN( tb4 , "    " ) ;

TODO

}
    pSubP = new( 0 , tin0P , LF ) subC( tin0P , etherP , idSub , tSecret ) ; ___( pSubP ) ;

    etherP.traceF( tin0P , T("[generatedSecret]:    ")+tSecret ) ;
    }
        etherP.delF( tin0P , psttMac ) ;
        tSecret = T(psttMac) ;
        etherP.openSslHmacF( tin0P , psttMac , tEmail , tEmail.csF( tin0P ) , (byteT*)&timeN1 , sizeof timeN1 ) ; ___( psttMac ) ;
        ZE( strokeS* , psttMac ) ;
    {
    TN( tSecret , "" ) ;

    TN( tEmail , psttEmailP ) ;

    etherP.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
    ZE( sCountT , timeN2 ) ;
    ZE( countT  , timeN1 ) ;

    countT idSub = 1 + incv02AM( idSubLath ) ;
    static countT idSubLath ;
    countT idBook = 1 ;
{
voidT welcomeF( tin0S& tin0P , etherC& etherP , subC*& pSubP , const strokeS* const psttEmailP )

}
    return nicNameC( pcIdHost[ 0 ] , pcIdHost[ 1 ] , pcSubnet[ 2 ] , pcSubnet[ 3 ] ) ;

    const countT* pcSubnet = nnSubnet ;
    nicNameC nnSubnet =  socketC::nicNameIF( tin0P , ether , tSubnet ) ;
    TN( tSubnet , "2001:19f0:ac00:4cfb::" ) ;

    //ether.traceF( tin0P , T("[idHost]:    ")+tIdHost ) ;
    //TN( tIdHost , "" ) ; tIdHost = TF2(idHost,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;

    countT* pcIdHost = (countT*)&idHost ;

    count04T idHost = (count01T)part1 | ( (count04T)idSub << 0x10 ) | ( (count04T)idBook << 0x30 ) ;

    countT part1 = 0x1234 ; //U::MUST BE RANDOM

    //countT part1 = hashF( tMac1 , tMac1.csF( tin0P ) , minuteP ) ;
    //
    //ether.delF( tin0P , psttMac ) ;
    ////TN( tMac2 , psttMac ) ;
    ////}
    ////                                               psttMac[ CSpREFIX + 1 ].idAdam = save ;
    ////                  psttMac[ CSpREFIX ].idAdam = psttMac[ CSpREFIX + 1 ].idAdam        ;
    ////    countT save = psttMac[ CSpREFIX ].idAdam                                         ;
    ////{
    ////if( psttMac->idAdam >= 2 )
    //TN( tMac1 , psttMac ) ;
    //
    ////ether.traceF( tin0P , psttMac ) ;
    //ether.openSslHmacF( tin0P , psttMac , tSecret , tSecret.csF( tin0P ) , (byteT*)&minuteP , sizeof minuteP ) ; ___( psttMac ) ;       //REWRITE THIS TO AVOID USING OPENSSL SO THAT ideanet.exe DOES NOT NEED TO CALL OPENSSL 
    //ZE( strokeS* , psttMac ) ;
    // 
    //  * tSecret CANNOT BE DISCOVERED BY OBSERVING A SEQUENCE OF [minute,random] PAIRS
    //  * THE countT VALUE CANNOT BE PREDICTED WITHOUT KNOWING tSecret
    // REQUIREMENTS:
    // THIS CODE JUST PRODUCES A "RANDOM" countT VALUE THAT DEPENDS UPON tSecret AND minuteP
    // 
    // THIS WOULD REQUIRE ideanet.exe TO HAVE ACCESS TO THE OPENSSL DLL'S
{
nicNameC subC::nnF( tin0S& tin0P , countT minuteP )

}
{
idSub( idSubP )
idBook( 0x1111 ) ,
tSecret( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , psttSecretP ) ,
ether( etherP ) ,
subC::subC( tin0S& tin0P , etherC& etherP , const countT idSubP , const strokeS* const psttSecretP ) :

NEWdELcLASS( 1 , subC ) ;

;
}
    nicNameC nnF( tin0S& tin0P , countT minuteP ) ;
    subC( tin0S& tin0P , etherC& etherP , const countT idSubP , const strokeS* const psttSecretP ) ;
    NEWdELcLASSpROTOS

    public :

    const countT idSub   ;
    const countT idBook  ;
    textC        tSecret ;
    etherC&      ether   ;
{
class subC

/*1*/WAKEhIDE( "ifcIDaDAM_TOOLrANDOMiPV6" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
