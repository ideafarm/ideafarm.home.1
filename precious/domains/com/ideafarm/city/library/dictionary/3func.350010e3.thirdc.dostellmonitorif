
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //}
    //    if( F(tinP.flagsThreadMode2) & flTHREADmODE2_SUPPRESStELLmONITOR ) POPUP( TF1(processGlobal1I.idAdamRoot)+T(": tell is suppressed for the thread") ) ;
    //    if( F(processGlobal2I._thirdC_flagsModeProcess1) & flMODEpROCESS1_SUPPRESStELLS           ) POPUP( TF1(processGlobal1I.idAdamRoot)+T(": tell is suppressed for the process") ) ;
    //    _bWoth = 0 ;
    //{
    //else if( _bWoth ) //U::
    }
    
        //U::COMMENTED OUT TO DEBUG A BUG: }
        //U::COMMENTED OUT TO DEBUG A BUG:     }
        //U::COMMENTED OUT TO DEBUG A BUG:         thirdC::dosSleepRawIF( tinP , 0x20 ) ; //U::PASS ebp INTO sleepC OBJECT SO THAT IT WON'T USE TINSL
        //U::COMMENTED OUT TO DEBUG A BUG:         ++ s ;
        //U::COMMENTED OUT TO DEBUG A BUG:     {
        //U::COMMENTED OUT TO DEBUG A BUG:     while( head.ipMe )
        //U::COMMENTED OUT TO DEBUG A BUG:     //while( head.ipMe ) { ++ s ; thirdC::dosSleepWinkIF( tinP ) ; }
        //U::COMMENTED OUT TO DEBUG A BUG:     sleepC s( tinP , TAG( TAGiDnULL ) ) ;
        //U::COMMENTED OUT TO DEBUG A BUG: {
        //U::COMMENTED OUT TO DEBUG A BUG: tellS& head = *(tellS*)(byteT*)tellP ;

        #endif

            //}
            //    countT idType = ((tellS*)(byteT*)tellP)->idType ;
            //{
            //if( F(processGlobal2I.flCt) & flCTdTg_THREADlOCALsTORAGE && !( F(processGlobal2I.flDt) & flCTdTg_THREADlOCALsTORAGE ) )
            //U::

            THREADmODE2rESTORE
            THREADmODE3rESTORE

            }
                default : { BLAMMO ; break ; }
                }
                    break ;

#endif
                    }
                        if(  bWroteLath ) { CONoUTrAW( "dosTellMonitorIF aaaaaghhh! (app earlylate book bWroteLath)\r\n" ) ; BLAMMO ; }
                        if( !bWroteAll  ) { CONoUTrAW( "dosTellMonitorIF aaaaaghhh! (app earlylate book !bWroteAll)\r\n" ) ; BLAMMO ; }
                        boolT bWroteAll  =  !( F(flagsResult) & flBOOK0cwRITErESULT_COULDnOTwRITEaLL ) ;
                        boolT bWroteLath = !!( F(flagsResult) & flBOOK0cwRITErESULT_WROTElATHbYTE    ) ;

                        processGlobal4I.bkTelemetryAppEarlyLate.writeF( tinP , flagsResult , tellP , cb1 , 0 , cb2 , flBOOK0cwRITE_ALLoRnONE | flBOOK0cwRITE_ELSEfILLtOeND | flBOOK0cwRITE_HEADfINGER1 | flBOOK0cwRITE_HEADiDfORMAT | flBOOK0cwRITE_HEADcBdATA | flBOOK0cwRITE_HEADfINGER2 | flBOOK0cwRITE_TAILfINGER | flBOOK0cwRITE_FLUSHaFTER | flBOOK0cwRITE_FLUSHaTpAGE ) ; //THESE FLAGS OPTIMIZE FOR DATA INTEGRITY AND WILL PRODUCE 1 DISK WRITE FOR EACH TELEMETRY EVENT PLUS A DISK WRITE AT THE END OF EACH PAGE

                        ZE( countT , cb2 ) ;
                        countT cb1 = tellP ;
                        ZE( flagsT , flagsResult ) ;
                    {
                    else
                    }
                        processGlobal4I.bksTelemetryApp.writeF( tinP , tellP , tellP , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ELSEfILLtOeND | flBOOKScwRITE_HEADfINGER1 | flBOOKScwRITE_HEADiDfORMAT | flBOOKScwRITE_HEADcBdATA | flBOOKScwRITE_HEADfINGER2 | flBOOKScwRITE_TAILfINGER | flBOOKScwRITE_FLUSHaFTER | flBOOKScwRITE_FLUSHaTpAGE ) ; //THESE FLAGS OPTIMIZE FOR DATA INTEGRITY AND WILL PRODUCE 1 DISK WRITE FOR EACH TELEMETRY EVENT PLUS A DISK WRITE AT THE END OF EACH PAGE
                    {
                    if( F(processGlobal2I.flCt) & flCTdTg_bksTelemetryApp && !( F(processGlobal2I.flDt) & flCTdTg_bksTelemetryApp ) )
#if defined( NEVERdEFINED )
//U::20240703@1821: COMMENTED OUT AS WORKAROUND TO PREVENT CHUNKING OF ARCHIVE FROM FILLING DISK
                {
                case ifcIDbOOKStELL_APP :
                }
                    break ;

                    }
                        if(  bWroteLath ) { CONoUTrAW( "dosTellMonitorIF aaaaaghhh! (sys earlylate book bWroteLath)\r\n" ) ; BLAMMO ; }
                        if( !bWroteAll  ) { CONoUTrAW( "dosTellMonitorIF aaaaaghhh! (sys earlylate book !bWroteAll)\r\n" ) ; BLAMMO ; }
                        boolT bWroteAll  =  !( F(flagsResult) & flBOOK0cwRITErESULT_COULDnOTwRITEaLL ) ;
                        boolT bWroteLath = !!( F(flagsResult) & flBOOK0cwRITErESULT_WROTElATHbYTE    ) ;

                        processGlobal4I.bkTelemetrySysEarlyLate.writeF( tinP , flagsResult , tellP , cb1 , 0 , cb2 , flBOOK0cwRITE_ALLoRnONE | flBOOK0cwRITE_ELSEfILLtOeND | flBOOK0cwRITE_HEADfINGER1 | flBOOK0cwRITE_HEADiDfORMAT | flBOOK0cwRITE_HEADcBdATA | flBOOK0cwRITE_HEADfINGER2 | flBOOK0cwRITE_TAILfINGER | flBOOK0cwRITE_FLUSHaFTER | flBOOK0cwRITE_FLUSHaTpAGE ) ; //THESE FLAGS OPTIMIZE FOR DATA INTEGRITY AND WILL PRODUCE 1 DISK WRITE FOR EACH TELEMETRY EVENT PLUS A DISK WRITE AT THE END OF EACH PAGE

                        ZE( countT , cb2 ) ;
                        countT cb1 = tellP ;
                        ZE( flagsT , flagsResult ) ;
                    {
                    else
                    }
                        processGlobal4I.bksTelemetrySys.writeF( tinP , tellP , tellP , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ELSEfILLtOeND | flBOOKScwRITE_HEADfINGER1 | flBOOKScwRITE_HEADiDfORMAT | flBOOKScwRITE_HEADcBdATA | flBOOKScwRITE_HEADfINGER2 | flBOOKScwRITE_TAILfINGER | flBOOKScwRITE_FLUSHaFTER | flBOOKScwRITE_FLUSHaTpAGE ) ; //THESE FLAGS OPTIMIZE FOR DATA INTEGRITY AND WILL PRODUCE 1 DISK WRITE FOR EACH TELEMETRY EVENT PLUS A DISK WRITE AT THE END OF EACH PAGE
                    {
                    if( F(processGlobal2I.flCt) & flCTdTg_bksTelemetrySys && !( F(processGlobal2I.flDt) & flCTdTg_bksTelemetrySys ) )
                {
                case ifcIDbOOKStELL_SYS :
            {
            switch( idBooksP )


            //}
            //    countT foo = 2 ;
            //    BLAMMOiD( 0x4444 ) ;
            //{
            //if( idBooksP != ifcIDbOOKStELL_SYS )        //U:: TO FIND A BUG

            //20201008@1741: ENABLED FOR PRODUCTION
            //20201008@1512: DISABLED TO INVESTIGATE SLOOOOOW EXECUTION
            //20191006@1920: ENABLED TO TEST
            //20180610@1819: DISABLED TO OPTIMIZE SPEED
            //20180607@1731: ENABLED AFTER SEEING LAPTOP STARTUP FAIL TO PROGRESS FOR A LONG TIME IN ae5 (AND THEN PROGRESSING)
            //20180228@0847: DISABLED TO OPTIMIZE SPEED, AFTER OBSERVING PRODUCTION RUNNING AOK THROUGH COMPLETE GENERATION AND PARTIAL UPLOADING OF ARCHIVE HTML
            //20180209@1347: ENABLED AFTER ENHANCING poolC TO DIVERT REQUESTS TO A NEW heapC MEMBER OF processGlobal4I
            //20180131@0447: DISABLED CONJ: CNR NONMONOTONIC GRAB BLAMMO
            //20161112@1449: ENABLED TO DEBUG FACTORY SERVER
            //U::20160711@1316: DISABLED TO ELIMINATE HUGE AMOUNT OF I/O CONJ: DUE TO EPHEMERAL THREADS
            //U::20160525@0920: ENABLED BECAUSE NEED GLASS WALLS TO FIND OTHER BUGS
            //U::20160524@0753: DISABLED; tmReportF FAILS WITH grabitC::ungrabF TRYING TO UNGRAB A BIT THAT IS NOT SET; IT'S ALWAYS THE SAME, ALWAYS WITHIN sexC::sexC, AND ALWAYS TAKES MORE THAN A DAY ; SAMEO USE FULL SERVER PUBLICATION CONFIGURATION ALL YEARS NO GMAIL
            //U::20151116@1526: ENABLED IN THE HOPE THAT I WILL BE ABLE TO DEBUG THIS QUICKLY.  THIS IS A BASIC GLASS WALLS FEATURE; I WANT IT TO WORK SO THAT I CAN DEBUG QUIT QUALITY AND OTHER DEFECTS
            //U::BUG: COMMENTED OUT IN PRODUCTION TO AVOID 6d9 BLAMMO DOCUMENTED IN booksC::writeF (SEE COMMENT CONTAINING: "20141206@0700: OBSERVED WITHIN ifcIDaDAM_CLOUD WHILE 3 INSTANCES EXISTED ; 20151026@2013: DITTO WHILE MORE THAN 3 EXISTED BUT ONLY WO WAS ACTIVE AT A TIME")
            //U:: COMMENT OUT IN PRODUCTION ; ENABLED TO STUDY DEADLOCK IN GRAPHICS TEST ADAM
            //U:: 20141206@2020: COMMENTED OUT BECAUSE SAW TELEMETRY OVERFLOW THE SCRATCH BUFFER ; ALSO, CLOUD ADMINISTRATION GENERATES LOTS OF TELEMETRY, WHICH WOULD FILL AVAILABLE HARD DRIVE SPACE

            //CONoUTrAW3( "\r\nDosTellMonitorIF: calling bksTelemetrySys.writeF [idIn]: " , incv02AM( idInLath ) , "" ) ;
            //static countT idInLath ;
            /* ENABLE WHEN CONFIDENT THAT THIS WORKS RELIABLY OR WHEN NEED IT FOR DEBUGGING: */

            // 2. tmEatTelemetryF READS FILL BYTES AS head.  CURRENT EATING CODE WILL DUMP THE HEAD BYTES TO LOG AND THEN EXCEPT.  FILL BYTE WAS CHANGED FROM 0xFF TO 0xEE BUT NOW CNR.  IT SAMEOD SEVERAL TIMES AT 5 CONVENTIONAL HOURS AND AT WOTH SEEMED TO BE AT WILL, BUT BECAME CNR WHEN THE FILL VALUE WAS CHANGED
            // 1. THE TELEMETRY BOOK'S LAST MODIFIED TIMESTAMP STOPS ADVANCING, APPARENTLY INDICATING THAT WRITING TELEMETRY DEADLOCKS
            //U:: THOROUGHLY BURN-IN TEST, LOOKING FOR THE FOLLOWING DEFECTS
            //U:: SYSTEM FOR PURGING OLD VOLUMES OF THE BOOK SO THAT THE DISK USAGE DOES NOT GROW UNBOUNDEDLY

            //CS:CODEsYNC: 0010506 102010a: THE TOTAL SIZE OF THE HEAD AND TAIL THAT I AM REQUESTING HERE IS HARDCODED IN 0010506
            //CONoUTrAW( "." ) ;
            //CONoUTrAW3( "tell [cb]: " , tellP , "\r\n" ) ;

            //}
            //    LOGrAW3( "cbMax is now " , cbMax , "\r\n" ) ;
            //    CONoUTrAW3( "cbMax is now " , cbMax , "\r\n" ) ;
            //    cbMax = tellP ;
            //{
            //if( cbMax < tellP )
            //static countT cbMax ;

            //U:: }
            //U::     ++ s ; thirdC::thirdWriteToMonitorIF( tinP , tellP , tellP ) ;
            //U::     sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            //U:: {
            //U:: COMMENTED OUT TO FIND A BUG: CONJ: SERVER WILL BE STABLE IF NOTHING IS WRITTEN TO THE MONITOR

            THREADmODE3oN( flTHREADmODE3_DISALLOWpUSE )
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

            //)
            //    OutputDebugString( pbTell ) ;
            //(
            //OSm
            //OBSOLETE

        #elif defined( __NT__ )
            //U:
        #if defined( __OS2__ )

        //byteT* pbTell = tellP ;
                
        thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG
        _IO_
    
        }
            if( POOP ) return ;
            __( !(byteT*)tellP ) ;
            if( POOP ) return ;
        {
        IFbEcAREFUL
    {
    )
        !( F(tinP.flagsThreadMode2) & flTHREADmODE2_SUPPRESStELLmONITOR )
        &&
        !( F(processGlobal2I._thirdC_flagsModeProcess1) & flMODEpROCESS1_SUPPRESStELLS )
    (
    if

    if( F(tinP.flagsThreadMode2) & flTHREADmODE2_DISALLOWtELLmONITOR ) { BLAMMO ; }

    }
        thirdC::dosPriorityIF( tinP ) ; //U:: TO FIND A BUG
        _IO_
    {
{
/*1*/voidT thirdC::dosTellMonitorIF( tinS& tinP , const tellC& tellP , const countT idBooksP )/*1*/

//boolT _bWoth = 1 ; //U::

/**/
*/
even in the system code, use TELLsYSc1 or TELLsYSc3 where practical
use TELLsYSc1 or TELLsYSc3
i work unconditionally (even if impotence has occured on this thread)
it is illegal to refer to this symbol in the definition of an adam
\<A HREF=\"5.102010a.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$dosTellMonitorIF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

