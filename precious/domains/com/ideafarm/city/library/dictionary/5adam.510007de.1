
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

//etThread.osSuspendF( tinBaseP ) ;

etherC::loafIF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("ok") ) ;

}
    }
        etThread.traceF( tinBaseP , T("done for archive ")+T(psttzArchive) ) ;

        DEL( pSwsImageCompareArrayAndFileRecordByYearSlashShort ) ;
        pSwsImageCompareArrayAndFileRecordByYearSlashShort->ungrabF( tinBaseP ) ;

        }
            }
                while( ~handle ) ;
                }
                    DELzOMBIE( pDoomed ) ;
                    fileRecordS* pDoomed = (fileRecordS*)&pSwsImageCompareArrayAndFileRecordByYearSlashShort->downF( tinBaseP , handle ) ;
                {
                do
                handleC handle( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( cFiles )
            countT cFiles = *pSwsImageCompareArrayAndFileRecordByYearSlashShort ;
            psttzYearSlashShort = (strokeS*)pSwsImageCompareArrayAndFileRecordByYearSlashShort->leverF( tinBaseP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cYearSlashShortFileNames ; idf ++ )
        //etThread.traceF( tinBaseP , T("deleting metadata") ) ;

        }
            }
                }
                    while( ~hSt ) ;
                    }
                        pRecUnique->traceF( tinBaseP , stPathToYear , T("reporting tallies:    ") ) ;

                        for( countT offc = 0 ; offc < cic ; offc ++ ) picUnique[ offc ].traceF( tinBaseP , T("reporting tallies:    ") ) ;

                        fileRecordS* pRecUnique = (fileRecordS*)( picUnique + cic ) ;
                        imageCompareS*    picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                    {
                    do
                    handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    // REPORT cbUsed TALLIES

                    }
                        while( ~hSt ) ;
                        }
                            while( ~hSws ) ;
                            }
                                if( bMatchImage && !( *pRecUnique - *(fileRecordS*)pRecInner ) ) pRecUnique->cTally ++ ;

                                }
                                    }
                                        break ;
                                        bMatchImage = 0 ;
                                    {
                                    if( picUnique[ offc ] - picInner[ offc ] )
                                {
                                for( countT offc = 0 ; offc < cic ; offc ++ )
                                boolT bMatchImage = 1 ;

                                fileRecordS*   pRecInner = (fileRecordS*)( picInner + cic ) ;
                                imageCompareS* picInner  = (imageCompareS*)&pSwsImageCompareArrayAndFileRecordByYearSlashShort->downF( tinBaseP , hSws ) ;
                            {
                            do

                            fileRecordS*   pRecUnique = (fileRecordS*)( picUnique + cic ) ;
                            imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                        {
                        do
                        handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    // TALLY cbUsed

                    etThread.traceF( tinBaseP , T("lengths or times or images differ") ) ;
                {
                if( stRecUnique > 1 )

                while( ~hSws ) ;
                do stRecUnique.sinkF( tinBaseP , countTC() , (byteT*)&pSwsImageCompareArrayAndFileRecordByYearSlashShort->downF( tinBaseP , hSws ) , flSTACKsINK_UNIQUE , subtractFileRecordsF ) ;
                stackC stRecUnique( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , stPathToYear * sizeof( imageCompareS ) + sizeof( fileRecordS ) ) ;
            {
            if( !ether && cCopies > 1 )
            //etThread.traceF( tinBaseP , T("[cFound,file]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzYearSlashShort) ) ;

            while( !ether && ~hSws ) ;
            }
                while( !ether && ~hSwsInner ) ;
                }
                    }
                        }
                            etThread.traceF( tinBaseP , T(bEqual?"        set other and myself to IDrESULT_EQUAL because images match":"        set other and myself to IDrESULT_NOTeQUAL because images differ") ) ;

                            ;
                                : IDrESULT_NOTeQUAL
                                ? IDrESULT_EQUAL
                            idResultMeInHis  = idResultHeInMine = bEqual

                            if( bEqual && cbDone != pRecOuter->cbUsed ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE

                            THREADmODE2rESTORE
                            }
                                }
                                    }
                                        cbDone += cbwOuter ;
                                        if( etThread.memCompareF( tinBaseP , pbwOuter , pbwInner , cbwOuter ) ) bEqual = 0 ;
                                    {
                                    else
                                    if( !pbwOuter || !cbwOuter ) break ;

                                    if(   cbwOuter !=   cbwInner ) { BLAMMO ; }     //SHOULD BE IMPOSSIBLE
                                    if( !!cbwOuter != !!cbwInner ) { BLAMMO ; }     //SHOULD BE IMPOSSIBLE
                                    if( !!pbwOuter != !!pbwInner ) { BLAMMO ; }     //SHOULD BE IMPOSSIBLE

                                    RETRY( fwsInner.getF( tinBaseP , pbwInner , cbwInner ) )
                                    ZE( countT , cbwInner ) ;
                                    ZE( byteT* , pbwInner ) ;

                                    RETRY( fwsOuter.getF( tinBaseP , pbwOuter , cbwOuter ) )
                                    ZE( countT , cbwOuter ) ;
                                    ZE( byteT* , pbwOuter ) ;
                                {
                                while( !ether && bEqual )

                                fileWindowsC fwsInner( tinBaseP , etThread , tLongInner ) ;
                                fileWindowsC fwsOuter( tinBaseP , etThread , tLongOuter ) ;         //U:: FOR MANY COPIES OF LARGE FILES, THIS RECIPE IS INEFFICIENT SINCE IT INVOLVES READING THE SAME OUTER FILE MULTIPLE TIMES
                            {
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                            boolT bEqual = 1 ;
                            ZE( count04T , cbDone ) ;
                        {
                        else
                        }
                            idResultMeInHis  = idResultHeInMine = IDrESULT_NOTeQUAL ;
                            etThread.traceF( tinBaseP , T("        set other and myself to IDrESULT_NOTeQUAL because cbUsed differs") ) ;
                        {
                        if( pRecOuter->cbUsed != pRecInner->cbUsed )
                    {
                    else if( idResultHeInMine == IDrESULT_UNKNOWN )
                    }
                        etThread.traceF( tinBaseP , T("        set myself to IDrESULT_EQUAL") ) ;
                        idResultMeInHis = IDrESULT_EQUAL ;
                    {
                    if( pRecInner == pRecOuter )

                    etThread.traceF( tinBaseP , T("    [tLongInner]:    ")+tLongInner ) ;
                    TN( tLongInner , "" ) ; tLongInner = T((strokeS*)stPathToYear[pRecInner->idSlotPathToYear])+tShort ;

                    countT& idResultHeInMine = picOuter[ pRecInner->idSlotPathToYear - 1 ].idResult ;
                    countT& idResultMeInHis  = picInner[ pRecOuter->idSlotPathToYear - 1 ].idResult ;

                    fileRecordS*   pRecInner = (fileRecordS*)( picInner + cic ) ;
                    imageCompareS* picInner  = (imageCompareS*)&pSwsImageCompareArrayAndFileRecordByYearSlashShort->downF( tinBaseP , hSwsInner ) ;
                {
                do
                handleC hSwsInner( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                etThread.traceF( tinBaseP , T("[tLongOuter]:    ")+tLongOuter ) ;
                TN( tLongOuter , "" ) ; tLongOuter = T((strokeS*)stPathToYear[pRecOuter->idSlotPathToYear])+tShort ;

                fileRecordS*   pRecOuter = (fileRecordS*)( picOuter + cic ) ;
                imageCompareS* picOuter  = (imageCompareS*)&pSwsImageCompareArrayAndFileRecordByYearSlashShort->downF( tinBaseP , hSws ) ;
            {
            do
            handleC hSws( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            countT cic = stPathToYear ;
            // SET ALLL idResult ELEMENTS FOR EACH FILE'S ARRAY

            }
                etThread.delF( tinBaseP , psttShort ) ;
                etThread.delF( tinBaseP , psttYear ) ;
                tShort = T(psttShort) ;
                etThread.strBisectF( tinBaseP , psttYear , psttShort , psttzYearSlashShort , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttYear ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttYear ) ;
            {
            TN( tShort , "" ) ;

            countT cCopies = *pSwsImageCompareArrayAndFileRecordByYearSlashShort ;
            psttzYearSlashShort = (strokeS*)pSwsImageCompareArrayAndFileRecordByYearSlashShort->leverF( tinBaseP , idf ) ;
        {
        for( countT idf = 1 ; idf <= cYearSlashShortFileNames ; idf ++ )
        //etThread.traceF( tinBaseP , T("inspecting metadata") ) ;

        countT cYearSlashShortFileNames = pSwsImageCompareArrayAndFileRecordByYearSlashShort->cFlavorsF( tinBaseP ) ;

        pSwsImageCompareArrayAndFileRecordByYearSlashShort->grabF( tinBaseP , TAG( TAGiDnULL ) ) ;      //SHOULD NOT BE NEEDED SINCE ALL KIDS ARE GONE

        // *pSwsImageCompareArrayAndFileRecordByYearSlashShort NOW CONTAINS A FILE RECORD FOR EACH COPY OF EACH FILE, THAT CONTAINS METADATA AND ALSO imageCompareS STRUCTURES INITIALIZED TO ZE

        WAITuNTILaLMOSTaLONE( 1 ) ;

        }
            if( idPass == 1 ) stPathToYear.lockF( tinBaseP ) ;

            while( ~hSwsPathToArchives ) ;
            }
                etThread.delF( tinBaseP , pstt1PathToYear ) ;
                }
                    }
                        etThread.osThreadF( TaRG3fLAGScBtLS( tmYearCollectFileRecordsF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&stPathToYear , idSlotPathToYear , (countT)&psttzYearSlashShort , (countT)pSwsImageCompareArrayAndFileRecordByYearSlashShort ) ;
                        countT idSlotPathToYear = stPathToYear( psttc1 ) ;
                    {
                    else
                    }
                       }
                           BLAMMO ; //U:: SHOULD BE IMPOSSIBLE
                           etThread.delF( tinBaseP , psttPathToYear ) ;
                       {
                       if( !idSlotPathToYear )
                       stPathToYear.sinkF( tinBaseP , idSlotPathToYear , psttPathToYear , flSTACKsINK_UNIQUE ) ;
                       ZE( countT , idSlotPathToYear ) ;

                       etThread.strMakeF( tinBaseP , LF , psttPathToYear , psttc1 ) ; ___( psttPathToYear ) ;
                       ZE( strokeS* , psttPathToYear ) ;
                    {
                    if( idPass == 1 )
                {
                FORsTRINGSiN1( pstt1PathToYear )

                etThread.strConvertToLowerCaseF( tinBaseP , pstt1PathToYear ) ;
                etThread.diskFindFileOrDirF( tinBaseP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                patternC pat( tinBaseP , etThread , tYearPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                ZE( strokeS* , pstt1PathToYear ) ;

                TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchive)+tSlash ;
                strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveName.downF( tinBaseP , hSwsPathToArchives ) ;
            {
            do
            handleC hSwsPathToArchives( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

            if( idPass == 2 ) { pSwsImageCompareArrayAndFileRecordByYearSlashShort = new( 0 , tinBaseP , LF ) switchStackC( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_SINKrEVERSE | flSTACKc_SINKiGNOREtABS , psttzYearSlashShort , flSTACKc_BLOB | flSTACKc_ALLOWzE , stPathToYear * sizeof( imageCompareS ) + sizeof( fileRecordS ) ) ; ___( pSwsImageCompareArrayAndFileRecordByYearSlashShort ) ; }
        {
        for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
        stackC stPathToYear( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
        ZE( switchStackC* , pSwsImageCompareArrayAndFileRecordByYearSlashShort ) ;       // cbData IS NOT KNOWN UNTIL PASS 1 COMPLETES ; WILL BE CT'D IN PASS 2
        ZE( strokeS* , psttzYearSlashShort ) ;
        // FOR EACH YEAR FOLDER, LAUNCH A FILE RECORD COLLECTION THREAD
    {
    if( cArchivesWithThisName /*U:: > 1*/ )
    etThread.traceF( tinBaseP , T("[cArchivesWithThisName,archive]:    ")+TF2(cArchivesWithThisName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzArchive) ) ;
    countT cArchivesWithThisName = swsPathToArchivesByArchiveName ;
    psttzArchive = (strokeS*)swsPathToArchivesByArchiveName.leverF( tinBaseP , idf ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
TN( tYearPattern , "?" "?" "?" "?" "/" ) ;                                                              //20221118@1747: "????/" PROUCES A SPURIOUS COMPILER ERROR INVOLVING TRIGRAPH
countT cFlavors = swsPathToArchivesByArchiveName.cFlavorsF( tinBaseP ) ;

}
    }
        etThread.delF( tinBaseP , pstt1Archives ) ;
        }
            }
                swsPathToArchivesByArchiveName.sinkF( tinBaseP , countTC() , psttPathArchives ) ;

                psttzArchive = tArchive ;

                //etThread.traceF( tinBaseP , T("    [tPathArchives,tArchive]:    ")+T(psttPathArchives)+tb4+tArchive ) ;

                }
                    etThread.delF( tinBaseP , psttShorter ) ;
                    tArchive = T(psttShorter) ;
                    etThread.strSubstringF( tinBaseP , psttShorter , idf , idl , tArchiveSlash ) ; ___( psttShorter ) ;
                    ZE( strokeS* , psttShorter ) ;
                {
                if( idl )
                countT idl = tArchiveSlash.csF( tinBaseP ) ? tArchiveSlash.csF( tinBaseP ) - 1 : 0 ;
                countT idf = 1 ;
                TN( tArchive , "" ) ;

                }
                    etThread.delF( tinBaseP , psttArchiveSlash ) ;
                    tArchiveSlash = T(psttArchiveSlash) ;
                    etThread.strBisectF( tinBaseP , psttPathArchives , psttArchiveSlash , psttc1 , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathArchives ) ; ___( psttArchiveSlash ) ;
                    ZE( strokeS* , psttArchiveSlash ) ;
                {
                TN( tArchiveSlash , "" ) ;
                ZE( strokeS* , psttPathArchives ) ;

                //etThread.traceF( tinBaseP , T("processing archive ")+T(psttc1) ) ;
            {
            FORsTRINGSiN1( pstt1Archives )
            etThread.diskFindFileOrDirF( tinBaseP , pstt1Archives , tLikeArchives ) ; ___( pstt1Archives ) ;
        {
        ZE( strokeS* , pstt1Archives ) ;
    {
    TN( tLikeArchives , "///?/ipdos.archives/" ) ;
{
switchStackC swsPathToArchivesByArchiveName( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzArchive , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
ZE( strokeS* , psttzArchive ) ;

TN( tSlash , "/" ) ;
TN( tb4    , "    " ) ;

TODO

DONE( tmYearCollectFileRecordsF )
}
    etThread.traceF( tinBaseP , T("ended archive pathToYear:    ")+tPathToYearP ) ;

    }
        while( !ether && ~hFindFile && !POOP ) ;
        }
            DEL( pInfoFile ) ;
            }
                swsImageCompareArrayAndFileRecordByYearSlashShortP.ungrabF( tinBaseP ) ;

                new( 0 , tinBaseP , (byteT*)pCursor , sizeof( fileRecordS ) ) fileRecordS( tinBaseP , idSlotPathToYearP , time1Mod , time2Mod , cbUsed ) ;

                pCursor += cSlotsPathToYear ;
                for( countT offs = 0 ; offs < cSlotsPathToYear ; offs ++ ) new( 0 , tinBaseP , (byteT*)( pCursor + offs ) , sizeof( imageCompareS ) ) imageCompareS ;
                imageCompareS* pCursor = (imageCompareS*)&swsImageCompareArrayAndFileRecordByYearSlashShortP[ 1 ] ;
                
                swsImageCompareArrayAndFileRecordByYearSlashShortP << (byteT*)0 ;
                psttzYearSlashShortP = tYearSlashShort ;
                swsImageCompareArrayAndFileRecordByYearSlashShortP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                count04T cbUsed = pInfoFile->cbUsedHigh << sizeof( count02T ) * SB | pInfoFile->cbUsed ;

                sCountT time2Mod = pInfoFile->timeWritten2 ;
                countT  time1Mod = pInfoFile->timeWritten1 ;
                                                           
                //etThread.traceF( tinBaseP , T("[yearShort]:          ")+tYearSlashShort ) ;
                }
                    etThread.delF( tinBaseP , psttYearSlashShort ) ;
                    etThread.delF( tinBaseP , psttPath ) ;
                    tYearSlashShort = T(psttYearSlashShort) ;
                    tPath  = T(psttPath) ;
                    etThread.strBisectF( tinBaseP , psttPath , psttYearSlashShort , tFileName , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttYearSlashShort ) ;
                    ZE( strokeS* , psttYearSlashShort ) ;
                    ZE( strokeS* , psttPath ) ;
                {
                TN( tYearSlashShort , "" ) ;
                TN( tPath  , "" ) ;

                TN( tFileName , pInfoFile->psttIfoName ) ;

                }
                    //etThread.traceF( tinBaseP , T("[perTuck,idFile]:    ")+TF3(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2)+tb+tPerTuck+tb4+TF2(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT perTuck = ( idFile << 8 ) / cFiles ;
                {
                //if( !( idFile % TUCK ) )

                ++ idFile ;
            {
            else
            }
                break ;
                DEL( pInfoFile ) ;
            {
            if( !pInfoFile || !pInfoFile->psttIfoName )

            RETRYsCR( diskFindFileOrDirF( tinBaseP , pInfoFile , hFindFile , tPathToYearP ) )
            ZE( infoFileS* , pInfoFile ) ;
        {
        do
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        handleC hFindFile( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        ZE( countT , idFile ) ;
        TN( tb4 , "    " ) ;
        TN( tb , " " ) ;
        TN( tPerTuck , "%" ) ;
        TN( tDot , "." ) ;
    {

    }
        while( !ether && ~hFindFile && !POOP ) ;
        }
            DEL( pInfoFile ) ;
            else cFiles ++ ;
            }
                break ;
                DEL( pInfoFile ) ;
            {
            if( !pInfoFile || !pInfoFile->psttIfoName )

            RETRYsCR( diskFindFileOrDirF( tinBaseP , pInfoFile , hFindFile , tPathToYearP ) )
            ZE( infoFileS* , pInfoFile ) ;
        {
        do
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        handleC hFindFile( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    {
    ZE( countT , cFiles ) ;

    etThread.traceF( tinBaseP , T("this thread's job: [volume,pathToYear]:    ")+tVolumeName+tb4+tPathToYearP ) ;

    //}
    //    etThread.delF( tinBaseP , pstt1Words ) ;
    //    }
    //        else if( bArm                                               ) bArm -- ;
    //        else if( !etThread.strCompareF( tinBaseP , psttc1 , tArchives ) ) bArm = 2 ;
    //             if( bArm == 1                                          ) tYear = T(psttc1) ;
    //    {
    //    FORsTRINGSiN1( pstt1Words )
    //    TN( tArchives , "ipdos.archives" ) ;
    //    ZE( boolT , bArm ) ;
    //    etThread.strWordsF( tinBaseP , pstt1Words , tPathToYearP , sttq , T("/") ) ; ___( pstt1Words ) ;
    //    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    //    ZE( strokeS* , pstt1Words ) ;
    //{
    //TN( tYear , "" ) ;

    }
        DEL( pInfoDisk ) ;
        tVolumeName = T(pInfoDisk->psttVolumeName) ;
        etThread.strConvertToLowerCaseF( tinBaseP , pInfoDisk->psttVolumeName ) ;
        etThread.delF( tinBaseP , psttDisk ) ;
        etThread.diskInfoF( tinBaseP , pInfoDisk , psttDisk ) ; ___( pInfoDisk ) ;
        ZE( infoDiskS* , pInfoDisk ) ;

        etThread.strSubstringF( tinBaseP , psttDisk , idf , idl , tPathToYearP ) ; ___( psttDisk ) ;
        countT idl = 5 ;
        countT idf = 1 ;
        ZE( strokeS* , psttDisk ) ;
    {
    TN( tVolumeName , "" ) ;

    TN( tPathToYearP , (strokeS*)stPathToYearP[ idSlotPathToYearP ] ) ;
    TN( tb4 , "    " ) ;
    const countT  cSlotsPathToYear = stPathToYearP ;

    switchStackC& swsImageCompareArrayAndFileRecordByYearSlashShortP = *(switchStackC*)pTaskP->c4 ;
    strokeS*&     psttzYearSlashShortP                                  =     *(strokeS**)pTaskP->c3 ;
    countT        idSlotPathToYearP                                     =                 pTaskP->c2 ;
    stackC&       stPathToYearP                                         =       *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
TASK( tmYearCollectFileRecordsF )


}
    return *pfr1 - *pfr2 ;

    fileRecordS* pfr2 = (fileRecordS*)c2P ;
    fileRecordS* pfr1 = (fileRecordS*)c1P ;
{
/*1*/countT subtractFileRecordsF( tin0S& tinBaseP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    ((tin9S&)tinBaseP).pEther->traceF( tinBaseP , T(psttP)+T(" [idResult]:    ")+TF2(idResult,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
{
voidT imageCompareS::traceF( tin0S& tinBaseP , const strokeS* const psttP )

}
{
idResult( IDrESULT_UNKNOWN )
imageCompareS::imageCompareS( voidT ) :

NEWdELcLASS( 2 , imageCompareS ) ;

}
    return ((tin9S&)tinBaseP).pEther->memCompareF( tinBaseP , (byteT*)this , (byteT*)&frP , sizeof( countT ) + sizeof( count04T ) ) ;    //CS:CODEsYNC 1 1
    TINSL
{
sCountT fileRecordS::operator -( const fileRecordS& frP ) const

}
    ((tin9S&)tinBaseP).pEther->traceF( tinBaseP , T(psttP)+T(" [timeModRounded,timeMod,cbUsed,cTally,path]:    ")+TF3(timeModRounded,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T("    ")+TT(time1Mod,time2Mod)+T("    ")+TT(((countT*)&cbUsed)[0],((countT*)&cbUsed)[1])+T("    ")+TF2(cTally,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((strokeS*)stPathToYearP[idSlotPathToYear]) ) ;
{
voidT fileRecordS::traceF( tin0S& tinBaseP , stackC& stPathToYearP , const strokeS* const psttP )

}
    timeModRounded = *(countT*)( (byteT*)pc2 + 3 ) + bRoundUp ;
    countT pc2[ 2 ] = { time1Mod , time2Mod } ;

    boolT bRoundUp = !!( ( time1Mod & 0xffffff ) > 0x800000 ) ;
{
idSlotPathToYear( idSlotPathToYearP )
cTally( 0 ) ,
time2Mod( time2ModP ) ,
time1Mod( time1ModP ) ,
cbUsed( cbUsedP ) ,
timeModRounded( 0 ) ,
fileRecordS::fileRecordS( tin0S& tinBaseP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) :

NEWdELcLASS( 1 , fileRecordS ) ;

;
}
    voidT traceF( tin0S& tinBaseP , const strokeS* const psttP = 0 ) ;
    inline sCountT operator -( imageCompareS& picP ) { return idResult - picP.idResult ; }
    imageCompareS( voidT ) ;
    NEWdELcLASSpROTOS

    countT idResult ;
{
struct imageCompareS

;
}
    sCountT operator -( const fileRecordS& frP ) const ;
    voidT traceF( tin0S& tinBaseP , stackC& stPathToYearP , const strokeS* const psttP = 0 ) ;
    fileRecordS( tin0S& tinBaseP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) ;
    NEWdELcLASSpROTOS

    countT   idSlotPathToYear ;
    countT   cTally ;
    sCountT  time2Mod ;
    countT   time1Mod ;
    count04T cbUsed ;
    countT   timeModRounded ;   //CS:CODEsYNC 1 1
{
struct fileRecordS

#define IDrESULT_EQUAL          3
#define IDrESULT_NOTeQUAL       2
#define IDrESULT_UNKNOWN        1

//OBSOLETES 7c0
//OBSOLETED BY 7df

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_HEALaRCHIVES" )/*1*/
/**/
*/
this works but is not optimized (osTextT lever, avoidance of redundant file image scans)
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
