
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etherC::loafIF( tin0P ) ;
    etThread.traceF( tin0P , T("ok") ) ;

    }
        }
            etThread.traceF( tin0P , T("socket is impotent") ) ;
            POOPRqUIET
        {
        if( POOP )
    
        etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
    
        }
            DEL( pSwPathValue ) ;
            }
                }
                    etThread.delF( tin0P , psttValue ) ;

                    etThread.traceF( tin0P , T("********    ") + T(psttPath) + T("   :    ") + T(psttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

                    strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                    psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                    _IO_
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
            {
            if( !POOP )

            __Z( pSwPathValue ) ;
            etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
            ZE( switchC* , pSwPathValue ) ;
            ZE( strokeS* , psttPath     ) ;
        {

        etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        etThread.traceF( tin0P , T("json response:") ) ;
    
        }
            }
                else if( costj ) break ;
                     if( cNest ) costj ++ ;
    
                else if( postj[ costj ] == '}' ) cNest -- ;
                     if( postj[ costj ] == '{' ) cNest ++ ;
    
                if( !cbIn ) break ;
                countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
            {
            for(;;)
            ZE( countT , cNest ) ;
        {
        ZE( countT , costj ) ;
        thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
        osTextT postj[ TUCK << 1 ] ;
    
        sockc.writeF( tin0P , (osTextT*)tSay ) ;
        etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        etThread.traceF( tin0P , T("request:") ) ;
    
        TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/logout/all HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(0,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;
    
        //sockc.connectF( tin0P , 80 , nnServer ) ;
        //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
    
        sockc.connectF( tin0P , 443 , nnServer ) ;
        socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
    
        countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
        countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
        countT timeAllowedConnected = TICK >> 2 ;
    
        nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
        nicNameC nnServer ;
    
        SCOOPS
    {
    IFsCRATCHoK                                                           // LOGOUT

    }
#endif
        }
            }
                etThread.traceF( tin0P , T("socket is impotent") ) ;
                POOPRqUIET
            {
            if( POOP )
        
            }
                DEL( pSwPathValue ) ;
                
                }
                    }
                        etThread.delF( tin0P , pstpsttValue ) ;
                
                        }
                            }
                                etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                *pptValue[ offe ] = T(pstpsttValue) ;
                            {
                            if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                        {
                        for( countT offe = 0 ; offe < cPaths ; offe ++ )
                
                        if( cPaths - cValues ) { BLAMMO ; }
                        countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                        countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
                
                        etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(pstpsttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                        etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                
                        strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                        psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                
                        _IO_
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                {
                if( !POOP )
                
                ;
                }
                    &tPathEnd     ,
                    &tPathStart  ,
                {
                textC* pptPath[] =
                
                TN( tPathEnd    , "\"end\"/"    ) ;
                TN( tPathStart , "\"start\"/" ) ;
                
                ;
                }
                    &tValueEnd      ,
                    &tValueStart ,
                {
                textC* pptValue[] =
                
                __Z( pSwPathValue ) ;
                etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                ZE( switchC* , pSwPathValue ) ;
                ZE( strokeS* , psttPath     ) ;
            {

            etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("json response [costj]:    ")+TF2(costj,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE) ) ;

            }
                }
                    else if( costj ) break ;
                         if( cNest ) costj ++ ;
        
                    else if( postj[ costj ] == '}' ) cNest -- ;
                         if( postj[ costj ] == '{' ) cNest ++ ;
        
                    if( !cbIn ) break ;
                    countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                {
                for(;;)
                ZE( countT , cNest ) ;
            {
            ZE( countT , costj ) ;

            sockc.writeF( tin0P , (osTextT*)tSay ) ;
            etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("request:") ) ;

            thirdC::c_memsetIF( tin0P , postj , costaj ) ;
            etThread.newF( tin0P , LF , postj , costaj ) ; ___( postj ) ;
            countT costaj = TICK ;
            ZE( osTextT* , postj ) ;
        
            TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!mdggPdOnBbNwmpeHnH:ideafarm.com/messages HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(tBody.csF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;
        
            sockc.connectF( tin0P , 443 , nnServer ) ;
            socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
        
            countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
            countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
            countT timeAllowedConnected = TICK >> 2 ;
        
            nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
            nicNameC nnServer ;
        
            ) ;
            
                "}\r\n"
                "    \"limit\": \"32\"")+tLine1+T(
              //"    \"limit\": \"1\"")+tLine1+T(


                "    \"filter\": {\"types\": [\"m.room.message\"]},\r\n"
              //"    \"filter\": {\"type\": \"m.room.message\"},\r\n"
              //"    \"filter\": {\"types\": [\"m.room.message\"]},\r\n"
              //"    \"filter\": {\"types\": [\"m.room.create\"]},\r\n"
              //"    \"filter\": \""m.room.create"\",\r\n"
              //"    \"filter\": \"m.room.message\",\r\n"
              //"    \"filter\": \"{\"type\": \"m.room.message\"}\",\r\n"
              //"    \"filter\": \"{[{\"type\": \"m.room.message\"}]}\",\r\n"
                "    \"dir\": \"f\",\r\n"
                "{\r\n"
            
            TN( tBody , "" ) ; tBody = T(

            else                          tLine1 = T(",\r\n    \"from\": \"")+tValueEnd+T("\"\r\n") ;
            if( !tValueEnd.csF( tin0P ) ) tLine1 = T( "\r\n") ;
            TN( tLine1 , "" ) ;
        
            SCOOPS
        {
        IFsCRATCHoK
#if defined( NEVERdEFINED )

        }
            }
                etThread.traceF( tin0P , T("socket is impotent") ) ;
                POOPRqUIET
            {
            if( POOP )
        
            }
                DEL( pSwPathValue ) ;
                
                }
                    }
                        etThread.delF( tin0P , pstpsttValue ) ;
                
                        }
                            }
                                etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                *pptValue[ offe ] = T(pstpsttValue) ;
                            {
                            if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                        {
                        for( countT offe = 0 ; offe < cPaths ; offe ++ )
                
                        if( cPaths - cValues ) { BLAMMO ; }
                        countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                        countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
                
                        //etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(pstpsttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                        //etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                
                        strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                        psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                
                        _IO_
                    {
                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                    countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                {
                if( !POOP )
                
                ;
                }
                    &tPathEnd       ,
                    &tPathStart     ,
                    &tPathNextBatch ,
                {
                textC* pptPath[] =
                
                TN( tPathEnd       , "\"end\"/"    ) ;
                TN( tPathStart     , "\"start\"/" ) ;
                TN( tPathNextBatch , "\"next_batch\"/" ) ;
                
                ;
                }
                    &tValueEnd       ,
                    &tValueStart     ,
                    &tValueNextBatch ,
                {
                textC* pptValue[] =
                
        
                }
                    }
                        etThread.traceF( tin0P , T("!exception / could not parse response to sync request") ) ;
                        POOPR
                    {
                    else
                    if( !POOP ) etThread.traceF( tin0P , T("response to sync request was parsed AOK") ) ;

                    __Z( pSwPathValue ) ;

                    ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
        
                    SCOOPS
                {
                IFsCRATCHoK
                ZE( switchC* , pSwPathValue ) ;
                ZE( strokeS* , psttPath     ) ;
            {

            etThread.boxPutF( tin0P , T("///d/tmp/foo.json") , postj , costj ) ;

            etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("json response [costj]:    ")+TF2(costj,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE) ) ;

            }
                }
                    if( cNest ) costj ++ ;
        
                    }
                        }
                            break ;
                            costj ++ ;
                        {
                        if( 1 == cNest -- )
                    {
                    else if( postj[ costj ] == '}' )
                         if( postj[ costj ] == '{' ) cNest ++ ;
        
                    if( !cbIn ) break ;
                    countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                {
                for(;;)
                ZE( countT , cNest ) ;
            {
            ZE( countT , costj ) ;

            sockc.writeF( tin0P , (osTextT*)tSay ) ;
            etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            etThread.traceF( tin0P , T("request:") ) ;

            thirdC::c_memsetIF( tin0P , postj , costaj ) ;
            etThread.newF( tin0P , LF , postj , costaj ) ; ___( postj ) ;
            countT costaj = TICK ;
            ZE( osTextT* , postj ) ;
        
            TN( tSay , "" ) ; tSay = T("GET /_matrix/client/v3/sync")+tQuery+T(" HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer/*+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(tBody.csF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)*/+T("\r\n\r\n")/*+tBody*/ ;

            ) ;

                ""
                "&since=")+tValueNextBatch+T(

            if( tValueNextBatch.csF( tin0P ) ) tQuery += T(
            TN( tQuery , "?timeout=1000" ) ;
        
            sockc.connectF( tin0P , 443 , nnServer ) ;
            socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
        
            countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
            countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
            countT timeAllowedConnected = TICK >> 2 ;
        
            nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
            nicNameC nnServer ;
        
            SCOOPS
        {
        IFsCRATCHoK
    {
    while( !ether && !POOP && cDo && cDo -- )
    countT cDo = 2 ;
    TN( tValueNextBatch , "" ) ;
    TN( tValueEnd       , "" ) ;
    TN( tValueStart     , "" ) ;
    
    }
        }
            etThread.traceF( tin0P , T("socket is impotent") ) ;
            POOPRqUIET
        {
        if( POOP )
    
        etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
    
        }
            DEL( pSwPathValue ) ;
            
            }
                }
                    etThread.delF( tin0P , pstpsttValue ) ;
            
                    }
                        }
                            etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                            *pptValue[ offe ] = T(pstpsttValue) ;
                        {
                        if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                    {
                    for( countT offe = 0 ; offe < cPaths ; offe ++ )
            
                    if( cPaths - cValues ) { BLAMMO ; }
                    countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                    countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
            
                    etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(pstpsttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                    etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
            
                    strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                    psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
            
                    _IO_
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
            {
            if( !POOP )
            
            ;
            }
                &tPathDeviceId     ,
                &tPathAccessToken  ,
            {
            textC* pptPath[] =
            
            TN( tPathDeviceId    , "\"device_id\"/"    ) ;
            TN( tPathAccessToken , "\"access_token\"/" ) ;
            
            ;
            }
                &tValueDeviceId      ,
                &tValueAccessToken ,
            {
            textC* pptValue[] =
            
            __Z( pSwPathValue ) ;
            etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
            ZE( switchC* , pSwPathValue ) ;
            ZE( strokeS* , psttPath     ) ;
        {

        etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        etThread.traceF( tin0P , T("json response:") ) ;
    
        }
            }
                else if( costj ) break ;
                     if( cNest ) costj ++ ;
    
                else if( postj[ costj ] == '}' ) cNest -- ;
                     if( postj[ costj ] == '{' ) cNest ++ ;
    
                if( !cbIn ) break ;
                countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
            {
            for(;;)
            ZE( countT , cNest ) ;
        {
        ZE( countT , costj ) ;
        thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
        osTextT postj[ TUCK << 1 ] ;
    
        sockc.writeF( tin0P , (osTextT*)tSay ) ;
        etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        etThread.traceF( tin0P , T("request:") ) ;
    
        TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/login HTTP/1.1\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;
    
        countT costBody = tBody.csF( tin0P ) ;
    
        //sockc.connectF( tin0P , 80 , nnServer ) ;
        //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
    
        sockc.connectF( tin0P , 443 , nnServer ) ;
        socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
    
        countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
        countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
        countT timeAllowedConnected = TICK >> 2 ;
    
        nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
        nicNameC nnServer ;
    
        ) ;
        
            "}\r\n"
            "    \"password\": \"")+tApiPassword+T("\"\r\n"
            "    },\r\n"
            "        \"user\": \"administrator\"\r\n"
          //"        \"user\": \"a.1\"\r\n"
            "        \"type\": \"m.id.user\",\r\n"
            "    {\r\n"
            "    \"identifier\":\r\n"
            "    \"type\": \"m.login.password\",\r\n"
            "{\r\n"
        
        TN( tBody , "" ) ; tBody = T(
        
        }
            etThread.delF( tin0P , psttApiPassword ) ;
            tApiPassword = T(psttApiPassword) ;
            etThread.traceF( tin0P , T("[password]:    ")+T(psttApiPassword) ) ;
            if( psttApiPassword && psttApiPassword->idAdam ) tApiPassword = T(psttApiPassword) ;

            //ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.ideafarm.com.a.1"          ) ) ; ___( psttApiPassword ) ;
              ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.ideafarm.com.administrator") ) ; ___( psttApiPassword ) ;
            //ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.communick.com.ideafarm"    ) ) ; ___( psttApiPassword ) ;
        {
        TN( tApiPassword , "" ) ;

        SCOOPS
    {
    IFsCRATCHoK                                                           // LOGIN
    TN( tb4               , "    "                 ) ;
    TN( tValueDeviceId    , ""                     ) ;
    TN( tValueAccessToken , ""                     ) ;
    TN( tServer           , "ideafarm.com"         ) ;
  //TN( tServer           , "matrix.communick.com" ) ;
{
if( pTaskP )
TASK( tmWorkF )

/*1*/WAKEhIDE( "doodle.pull.room.messages" )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

