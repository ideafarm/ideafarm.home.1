
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmWhereF )
}
    LOGrAWaDAM( ostoRpt ) ;
    
    }
        OStEXTAK( ostoRpt , "|\r\n" ) ;
        }
            OStEXTAK( ostoRpt , "\r\n" ) ;
            }
                OStEXTA( ostoRpt , postn ) ;
                OStEXTAK( ostoRpt , " " ) ;
            {
            if( postn )
            const osTextT* postn = processGlobal8I.source.postFileTitleF( tin0P , c4s.c4 ) ;
            OStEXTC(   ostoRpt , processGlobal8I.source.idFileImmutableF( tin0P , c4s.c4 ) , ' ' ) ;
            OStEXTAK(  ostoRpt , " " ) ;
            OStEXTC04( ostoRpt , cExitsMe , ' ' ) ;
            OStEXTAK(  ostoRpt , " " ) ;
    
            OStEXTC( ostoRpt , perTuck , ' ' ) ;
            countT   perTuck = (countT)( cExits ? ( cExitsMe * 0x100 ) / cExits : 0 ) ;
            count04T cExitsMe = - *(count04T*)&c4s ;
            OStEXTAK( ostoRpt , "| " ) ;
    
            stSorter04 >> pb_c4s ;
            byteT* pb_c4s = (byteT*)&c4s ;
            count4S c4s ;
            _IO_
        {
        while( stSorter04 )
        OStEXTAK( ostoRpt , "\r\n| [ % , exits , idiFile , fileTitle ]\r\n|\r\n" ) ;
        OStEXTC04( ostoRpt , cExits , 0 ) ;
        OStEXTAK( ostoRpt , "| EXITS\r\n|\r\n| tally: " ) ;
        _IO_
    {

    }
        }
            stSorter04.sinkF( tin0P , countTC() , (byteT*)&c4s , flSTACKsINK_null , subtractTally04F ) ;
            cExits           +=   ((tin1S&)tin0P).pag1->pcExitsWhere[ off ] ;
            *(count04T*)&c4s  = - ((tin1S&)tin0P).pag1->pcExitsWhere[ off ] ;
            count4S c4s( 0 , 0 , 0 , off ) ;
            _IO_
        {
        if( ((tin1S&)tin0P).pag1->pcExitsWhere[ off ] )
        _IO_
    {
    for( countT off = 1 ; off < sizeof ((tin1S&)tin0P).pag1->pcExitsWhere / sizeof ((tin1S&)tin0P).pag1->pcExitsWhere[ 0 ] ; off ++ )
    ZE( count04T , cExits ) ;

    stackC stSorter04( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( count4S ) ) ;

    }
        OStEXTAK( ostoRpt , "|\r\n" ) ;
        }
            OStEXTAK( ostoRpt , "\r\n" ) ;
            }
                OStEXTA( ostoRpt , postn ) ;
                OStEXTAK( ostoRpt , " " ) ;
            {
            if( postn )
            const osTextT* postn = processGlobal8I.source.postFileTitleF( tin0P , processGlobal8I.source.idFileRankF( tin0P , c3s.c3 ) ) ;
            OStEXTC( ostoRpt , c3s.c3 , ' ' ) ;
            OStEXTAK( ostoRpt , "_9) " ) ;
            OStEXTC9( ostoRpt , c3s.c2 ) ;
            OStEXTAK( ostoRpt , " (" ) ;
            OStEXTC( ostoRpt , c3s.c2 , ' ' ) ;
            OStEXTAK( ostoRpt , " " ) ;
            OStEXTC( ostoRpt , tally , ' ' ) ;
            OStEXTAK( ostoRpt , " " ) ;
    
            OStEXTC( ostoRpt , perTuck , ' ' ) ;
            countT perTuck = totalTally ? ( tally * 0x100 ) / totalTally : 0 ;
            countT tally = - c3s.c1 ;
            OStEXTAK( ostoRpt , "| " ) ;
    
            stSorter >> pb_c3s ;
            byteT* pb_c3s = (byteT*)&c3s ;
            count3S c3s ;
            _IO_
        {
        while( stSorter )
        OStEXTAK( ostoRpt , "\r\n|\r\n| [ % , tally , idLine , (idLine_9) , idiFile , fileTitle ]\r\n|\r\n" ) ;
        OStEXTC( ostoRpt , totalTally , 0 ) ;
        OStEXTAK( ostoRpt , "| WHERE\r\n|\r\n| tally: " ) ;
        }
            OStEXTAK( ostoRpt , "\r\n" ) ;
            OStEXTA( ostoRpt , tList ) ;
            OStEXTAK( ostoRpt , "FOCUS: CALLER OF " ) ;
            TN( tList , "" ) ; tList = T((countT*)c8idiFileFocus) ;
            _IO_
        {
        if( cFoci )
        _IO_
    {

    }
        }
            stSorter.sinkF( tin0P , countTC() , (byteT*)&c3s , flSTACKsINK_null , subtractTallyF ) ;
            totalTally -= c3s.c1 ;
            count3S c3s( - swTally , c2Lever.c1 , c2Lever.c2 ) ;
            etThread.memCopyF( tin0P , (byteT*)&c2Lever , (byteT*)swTally.leverF( tin0P , idf ) , sizeof c2Lever ) ;
            _IO_
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        _IO_
    {
    countT cFlavors = swTally.cFlavorsF( tin0P ) ;
    ZE( countT , totalTally ) ;

    }
        }
            OStEXTAK( ostoRpt , "|\r\n" ) ;
            }
                OStEXTAK( ostoRpt , "\r\n" ) ;
                else        { OStEXTC( ostoRpt , c3s.c2 , ' ' ) ; }
                if( postn ) { OStEXTA( ostoRpt , postn ) ; }

                if( !postn && cToDo ) postn = processGlobal4I.mapGroup( c3s.c2 ) ;

                const osTextT* postn = processGlobal4I.mapWhat( c3s.c2 ) ;
                OStEXTAK( ostoRpt , " " ) ;
                OStEXTC( ostoRpt , tally , ' ' ) ;
                OStEXTAK( ostoRpt , " " ) ;
        
                OStEXTC( ostoRpt , perTuck , ' ' ) ;
                countT perTuck = totalTallyWhat ? ( tally * 0x100 ) / totalTallyWhat : 0 ;
                countT tally = - c3s.c1 ;
                OStEXTAK( ostoRpt , "| " ) ;
        
                stSorter >> pb_c3s ;
                byteT* pb_c3s = (byteT*)&c3s ;
                count3S c3s ;
                _IO_
            {
            while( stSorter )
            OStEXTAK( ostoRpt , "\r\n|\r\n| [ % , tally , postWhat ]\r\n|\r\n" ) ;
            OStEXTC( ostoRpt , totalTallyWhat , 0 ) ;
            OStEXTA( ostoRpt , cToDo ? "THREAD WHEREABOUTS REPORT\r\n|\r\n| WHAT 1 (PREDEFINED CATEGORIES)\r\n|\r\n| tally: " : "THREAD WHEREABOUTS REPORT\r\n|\r\n| WHAT 2 (AD HOC CATEGORIES)\r\n|\r\n| tally: " ) ;
            _IO_
        {
    
        }
            stSorter.sinkF( tin0P , countTC() , (byteT*)&c3s , flSTACKsINK_null , subtractTallyF ) ;
            totalTallyWhat -= c3s.c1 ;
            count3S c3s( - swTallyWhat12 , idWhat12 ) ;
            idWhat12 = swTallyWhat12.leverF( tin0P , idf ) ;
            _IO_
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swTallyWhat12.cFlavorsF( tin0P ) ;
        ZE( countT , totalTallyWhat ) ;

        switchC& swTallyWhat12 = cToDo ? swTallyWhat1 : swTallyWhat2 ;
        countT&  idWhat12 = cToDo ? idWhat1 : idWhat2 ;
        _IO_
    {
    while( cToDo -- )
    countT cToDo = 2 ;
    OStEXT( ostoRpt , TOCK << 4 )        // 20180123@1526: TOCK -> TOCK << 4

    stackC stSorter( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_BLOB , sizeof( count3S ) ) ;

    processGlobal2S::_processGlobal2I_IF().cDozeSprint = cDozeSprintWas ;

    }
        if( bNap ) thirdC::dosSleepWinkIF( tin0P ) ;

        }
            grabWhere.ungrabF( tin0P ) ;
            //etRock.traceF( tin0P , tSay0 ) ; //U:: COMMENT OUT IN PRODUCTION
            }
                }
                    }
                        //CONoUTrAW( ">" ) ;
                        }
                            }
                                }
                                    ++ ( (countT&)swTally ) ;
        
                                    }
                                        countT foo = 2 ;
                                    {
                                    if( c2Lever.c2 == 0x36004002 )

                                    c2Lever.c2 = where.pLFnest[ ( ( ( where.cInNest - cFoci ) & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
                                    c2Lever.c1 = where.pLFnest[ ( ( ( where.cInNest - cFoci ) & OFFsLOTtINnESTmAX ) << 1 )     ] ;
                                    _IO_
                                {
                                if( bDo )

                                }
                                        if( pczFocus[ offFocus ] != where.pLFnest[ ( ( ( where.cInNest - offFocus ) & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ) bDo = 0 ;
                                    for( countT offFocus = 0 ; bDo && offFocus < cFoci ; offFocus ++ )
                                    countT* pczFocus = c8idiFileFocus ;
                                    _IO_
                                {
                                else
                                if( cFoci >= where.cInNest ) bDo = 0 ;
                                boolT bDo = 1 ;
                                _IO_
                            {
                            else
                            }
                                ++ ( (countT&)swTally ) ;

                                }
                                    countT foo = 2 ;
                                {
                                if( c2Lever.c2 == 0x36004002 )

                                c2Lever.c2 = where.pLFnest[ ( ( where.cInNest & OFFsLOTtINnESTmAX ) << 1 ) + 1 ] ;
                                c2Lever.c1 = where.pLFnest[ ( ( where.cInNest & OFFsLOTtINnESTmAX ) << 1 )     ] ;
                                _IO_
                            {
                            if( !cFoci )

                            if( !( ++ cSamples % ( TICK >> 4 ) ) ) etRock.traceF( tin0P , tSaySamples+TF2(cSamples,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            //++ ( (countT&)swTallyWhat1 ) ;
                            _IO_
                        {
                        //if( idWhat1 <= ifcIDwHAT_GOaDAM )
                        //if( idWhat1 <= 0x100 ) //CAN USE TO INVESTIGATE FIND LOCATION WITHIN A CODE SNIPPET

                        ++ ( (countT&)swTallyWhat2 ) ;
                        idWhat2 = where.idWhat2 ;

                        ++ ( (countT&)swTallyWhat1 ) ;
                        idWhat1 = where.idWhat1 ;
                        //CONoUTrAW( "<" ) ;
                        _IO_
                    {
                    if( F(where.flagsThreadModeWhere) & flTHREADmODEwHERE_WHEREiSwATCHING )

                    }
                        while( where.idDirty % 2 || where.idDirty != idDirtyVerify ) ;
                        }
                            idDirtyVerify = ((tin123S*)ppTin0WhereI[ off ])->where.idDirty ;
                            thirdC::c_memcpyIF( tin0P , pbWhere , (byteT*)&((tin123S*)ppTin0WhereI[ off ])->where , sizeof( whereS ) ) ;
                        {
                        do
                        countT idDirtyVerify ; //INTENTIONALLY NOT INITIALIZED, FOR SPEED
                    {
                    whereS& where = *(whereS*)pbWhere ;
                    byteT pbWhere[ sizeof( whereS ) ] ;                    
                    _IO_
                {
                if( ppTin0WhereI[ off ] ) //U:: USE A grabC TO SERIALIZE SO DON'T GET BIT BY A DANGLING POINTER TO A DOOMED tin123S, OBJECT
                _IO_
            {
            for( countT off = 0 ; off < cThreadsMaxWhereI ; off ++ )
            //etRock.traceF( tin0P , tSay1 ) ; //U:: COMMENT OUT IN PRODUCTION
            grabWhere.grabF( tin0P , TAG( TAGiDnULL ) ) ;
            //etRock.traceF( tin0P , tSay2 ) ; //U:: COMMENT OUT IN PRODUCTION
            _IO_
        {
        if( cEnabledWhereI )
        _IO_
    {
    while( !etThread && !bQuitWhereI && !ether ) //COMMENT OUT !ether IF WANT TO LOOK AT QUIT BEHAVIOR
    TN( tSaySamples , "[cSamples]:    " ) ;
    ZE( countT , cSamples ) ;
    /**/etRock.traceF( tin0P , T(bNap?"i will nap between samples to avoid pegging cpu [cProcessors]:    ":"i will not nap between samples since there are multiple cpus [cProcessors]:    ")+TF2(cProcessors,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    const boolT  bNap = !!( cProcessors < 2 ) ;
    const countT cProcessors = thirdC::osProcessorsIF( tin0P ) ;
    //TN( tSay0 , "where is looking 0 napping " ) ; //U:: COMMENT OUT IN PRODUCTION
    //TN( tSay1 , "where is looking 1 got" ) ; //U:: COMMENT OUT IN PRODUCTION
    //TN( tSay2 , "where is looking 2 grabbing" ) ; //U:: COMMENT OUT IN PRODUCTION
    sgnReady.giveF( tin0P ) ;
    switchC swTally( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , pbLever , sizeof c2Lever ) ;
    const byteT* pbLever = (const byteT*)&c2Lever ;
    count2S c2Lever ;
    switchC swTallyWhat2( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , idWhat2 ) ;
    ZE( countT , idWhat2 ) ;
    switchC swTallyWhat1( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , idWhat1 ) ;
    ZE( countT , idWhat1 ) ;
    countT  cFoci = etThread.strBodyLengthF( tin0P , (countT*)c8idiFileFocus ) ;
    count8S c8idiFileFocus ;
    //count8S c8idiFileFocus( 0x4000611 ) ;
    //count8S c8idiFileFocus( 0x6000f71 , 0x5000a01 , 0x6000021 , 0x5000511 ) ;

                                  processGlobal2S::_processGlobal2I_IF().cDozeSprint = PERIODSpERdOZEcYCLE ;        // SPRINT EVERY PERIOD (THIS DISABLES DOZING COMPLETELY)
    const countT cDozeSprintWas = processGlobal2S::_processGlobal2I_IF().cDozeSprint ;

    etherC& etRock = etherC::etRockIF( tin0P ) ;

    grabC&  grabWhere          =  *(grabC*)pTaskP->c7 ;
    countT& cThreadsMaxWhereI  = *(countT*)pTaskP->c6 ;
    tin0S** ppTin0WhereI       =  (tin0S**)pTaskP->c5 ;
    countT& idTypeReportWhereI = *(countT*)pTaskP->c4 ;
    countT& cEnabledWhereI     = *(countT*)pTaskP->c3 ;
    signC&  sgnReady           =  *(signC*)pTaskP->c2 ;
    boolT&  bQuitWhereI        =  *(boolT*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 )
etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE ) ;   //20250712@1550: ifcTHREADpRIORITY_RUDE <- ifcTHREADpRIORITY_SPINLOCK
/*1*/TASK( tmWhereF )/*1*/

}
    ;
            : 0
            ? - 1
        : tally1 < tally2
        ? 1
    return tally1 > tally2

    count04T tally2 = *(count04T*)c2P ;
    count04T tally1 = *(count04T*)c1P ;

    }
        if( !c1P || !c2P ) return 0 ;
    {
    IFbEcAREFUL
{
countT subtractTally04F( tin0S& tin0P , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

}
    ;
            : 0
            ? - 1
        : tally1 < tally2
        ? 1
    return tally1 > tally2

    countT tally2 = *(countT*)c2P ;
    countT tally1 = *(countT*)c1P ;

    }
        if( !c1P || !c2P ) return 0 ;
    {
    IFbEcAREFUL
{
countT subtractTallyF( tin0S& tin0P , countT& pEther , countT& c1P , countT& c2P , countT& c3P )

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

