
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

REST
etThread.osProcessIdPhaseAdamF( tinBaseP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;
etThread.strokeF( tinBaseP , T("ok\r\n") ) ;

}
    }
        askToGoF( tinBaseP , etThread , T("press the enter key to fire this intermediate node on the river (in reverse sequence): ") ) ;
        riverC river( tinBaseP , etThread , nicNameNext ) ;
    {
    else
    }
        }
            DEL( pso ) ;

            }
                }
                    pso->readMsgOkF( tinBaseP ) ;
                    etThread.delF( tinBaseP , pbMsg ) ;
                    bDry = !etThread.strCompareF( tinBaseP , tAmDry , T(pbMsg) ) ;
                    etThread.strokeF( tinBaseP , T("tmSinkF: received \"")+T(pbMsg)+T("\"\r\n") ) ;
                    pso->readMsgF( tinBaseP , pbMsg ) ; ___( pbMsg ) ;
                    ZE( byteT* , pbMsg ) ;
                {
                while( !bDry )
            {
            if( pso )

            }
                sIn.acceptF( tinBaseP , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
                ZE( countT , idPortPeer ) ;
                nicNameC nnPeer ;
                sIn.listenF( tinBaseP ) ;
                sIn.bindF( tinBaseP , ifcPORToLD1rIVERdEFAULT ) ;
                socketC sIn( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
            {
            ZE( socketC* , pso ) ;
        {
        while( !bDry )
        TN( tAmDry , "!amDry" ) ;
        ZE( boolT , bDry ) ;
    {
    if( nicNameSink == nicNameMe )

    if( nicNameSource == nicNameMe ) { ZE( countT , tnu ) ; etThread.osThreadF( tinBaseP , tnu , tmSourceF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&nicNameMe , (countT)&nicNameNext , (countT)&nicNameSink ) ; }

    askToGoF( tinBaseP , etThread , T("press the enter key here on each node, in reverse sequence, from the sink to the source: ") ) ;

    nicNameSink = askF( tinBaseP , etThread , T("enter the ip address of the computer that is to be the final sink into which the river flows"": ") ) ;
    nicNameNext = askF( tinBaseP , etThread , T("enter the ip address of the computer that i flow to: ") ) ;
    nicNameSource = askF( tinBaseP , etThread , T("enter the ip address of the computer that is to be the source of the river: ") ) ;

    etThread.strokeF( tinBaseP , T("nicNameMe = ")+TF1(nicNameMe)+T("\r\n") ) ;
    const nicNameC nicNameMe = socketC::nicNameIF( tinBaseP , etThread ) ;
{
if( !( F(etThread.flagsMode) & flTHIRDmODE_TESTaUTO ) )

nicNameC nicNameSink ;
nicNameC nicNameNext ;
nicNameC nicNameSource ;

TODO

DONE( tmSourceF )
}
    sOut.writeMsgF( tinBaseP , "!amDry" ) ;
    sOut.writeMsgF( tinBaseP , "four" ) ;
    sOut.writeMsgF( tinBaseP , "three" ) ;
    sOut.writeMsgF( tinBaseP , "two" ) ;
    sOut.writeMsgF( tinBaseP , "one" ) ;
    sOut.connectF( tinBaseP , ifcPORToLD1rIVERdEFAULT , nicNameNext ) ;
    socketC sOut( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;

    if( nicNameSink == nicNameMe ) askToGoF( tinBaseP , etThread , T("press the enter key again to begin the flow") ) ;

    nicNameC& nicNameSink = *(nicNameC*)pTaskP->c3 ;
    nicNameC& nicNameNext = *(nicNameC*)pTaskP->c2 ;
    nicNameC& nicNameMe   = *(nicNameC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmSourceF )

}
    etThread.delF( tinBaseP , pstth ) ;
    etThread.faceHearF( tinBaseP , pstth ) ; ___( pstth ) ;
    etThread.strokeF( tinBaseP , psttP ) ;

    ZE( strokeS* , pstth ) ;
{
voidT askToGoF( tin0S& tinBaseP , etherC& etThread , const strokeS* const psttP )

}
    return nicName ;

    etThread.strokeF( tinBaseP , TF1(nicName)+T("\r\n") ) ;
    etThread.delF( tinBaseP , pstth ) ;
    nicNameC nicName = etThread.strDigitsToNicNameF( tinBaseP , pstth ) ;
    etThread.faceHearF( tinBaseP , pstth ) ; ___( pstth ) ;
    etThread.strokeF( tinBaseP , psttP ) ;

    ZE( strokeS* , pstth ) ;
{
nicNameC askF( tin0S& tinBaseP , etherC& etThread , const strokeS* const psttP )

/*1*/WAKEhIDE( "example.simplest.func.1370002.riverC.dt_riverC" )/*1*/
/**/
*/
\<A HREF=\"5.3a30104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

