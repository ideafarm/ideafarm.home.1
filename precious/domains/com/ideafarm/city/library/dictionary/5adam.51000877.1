
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK << 4 ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        while( !ether && ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                }
                    etThread.traceF( tin0P , (!F(flagsFail)?T("aok"):T("flagsFail:")+TF2(flagsFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)) ) ;

                    }
                        }
                            flagsFail |= flFAIL_COULDnOTmOVEfILE ;
                            POOPR
                        {
                        if( POOP )
                        ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tWhere+tShort , tIfoName ) ;

                        SCOOPS
                    {
                    IFsCRATCHoK

                    ;
                            : tFolderDone
                            ? tFolderToRetry
                        : F(flagsFail)
                        ? tFolderAbandoned
                    TN( tWhere , "" ) ; tWhere = bFailPermanent

                    etThread.traceF( tin0P , T("moving the file") ) ;

                    etThread.traceF( tin0P , T("cleaning up 3") ) ;

                    }
                        etThread.traceF( tin0P , T("unknown error") ) ;
                        flagsFail |= flFAIL_UNKNOWNeRROR ;
                        POOPR
                    {
                    if( POOP )
                    etThread.traceF( tin0P , T("cleaning up 2") ) ;

                    }
                        // ********************************************** THE WORK IS DONE HERE ***************************************

                        //sIn >> psttHost ; ___( psttHost ) ;
                        ZE( strokeS* , psttHost ) ;
                    {
                    if( !( F(flagsFail) & flFAIL_COULDnOTgETsHADOW ) )
                    ZE( boolT , bFailPermanent ) ;

                    }
                        }
                            etThread.traceF( tin0P , TT(timeN1,timeN2)+T(" | could not get shadow of ")+T((strokeS*)tIfoName)+T(": ") ) ;
                            flagsFail |= flFAIL_COULDnOTgETsHADOW ;
                            POOPR ;
                        {
                        if( POOP )
                        ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , sIn , tIfoName ) ;
                        SCOOPS
                    {
                    IFsCRATCHoK
                    soulC sIn( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
                    IFsCRATCHoK{}

                    ZE( flagsT , flagsFail ) ;
                    etThread.traceF( tin0P , TT(timeN1,timeN2)+T(" | receiving ")+T((strokeS*)tIfoName)+T(": ") ) ;

                    etThread.traceF( tin0P , tShort ) ;

                    }
                        etThread.delF( tin0P , psttShort ) ;
                        tShort = T(psttShort) ;
                        etThread.delF( tin0P , psttnu ) ;
                        etThread.strBisectF( tin0P , psttnu , psttShort , tIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShort , "" ) ;

                    TN( tIfoName , pInfo->psttIfoName ) ;
                {
                if( !bDir )

                const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirF( tin0P , pInfo , hFind , tFolderIncoming ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

        }
            while( !ether && ~hFind && !POOP ) ;
            }
                DEL( pInfo ) ;
                }
                    }
                        etThread.traceF( tin0P , tShort ) ;
                        etThread.diskMoveFileOrDirF( tin0P , tFolderIncoming+tShort , pInfo->psttIfoName ) ;

                        }
                            etThread.delF( tin0P , psttShort ) ;
                            tShort = T(psttShort) ;
                            etThread.delF( tin0P , psttnu ) ;
                            etThread.strBisectF( tin0P , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShort , "" ) ;
                    {
                    if( !bDir )

                    const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
                {
                else
                }
                    break ;
                    DEL( pInfo ) ;
                {
                if( !pInfo || !pInfo->psttIfoName )

                etThread.diskFindFileOrDirF( tin0P , pInfo , hFind , tFolderToRetry ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            do
            handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

            timeL2 = timeN2 ;
            timeL1 = timeN1 ;
        {
        if( timeE2 || timeE1 > TICK )

        etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeL1 , timeL2 ) ;
        sCountT timeE2 = timeN2 ;
        countT  timeE1 = timeN1 ;

        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;
    {
    while( !ether && !etThread )
    ZE( sCountT , timeL2 ) ;
    ZE( countT  , timeL1 ) ;
    TN( tSlash , "/" ) ;

    etThread.diskMakeDirIfNeededF( tin0P , tFolderAbandoned ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFolderToRetry   ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFolderDone      ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFolderIncoming  ) ;

    TN( tFolderAbandoned , "" ) ; tFolderAbandoned = T("///ideafarm/ephemeral/ipdos/email.notsentabandoned/") ;
    TN( tFolderToRetry   , "" ) ; tFolderToRetry   = T("///ideafarm/ephemeral/ipdos/email.notsent/"         ) ;
    TN( tFolderDone      , "" ) ; tFolderDone      = T("///ideafarm/ephemeral/ipdos/email.sent/"            ) ;
    TN( tFolderIncoming  , "" ) ; tFolderIncoming  = T("///ideafarm/ephemeral/ipdos/email.to.send/"         ) ;
{
if( pTaskP )
TASK( tmWorkF )

}
    return bFail ;
    }
        }
            }
                DEL( pInfo ) ;
                }
                    }
                        etherP.delF( tin0P , posti ) ;
                        }
                            etherP.strFuseF( tin0P , psttP , T(posti) ) ; ___( psttP ) ;
                            etherP.fileReadF( tin0P , posti , cToDo , hFileBody ) ;
                        {
                        if( posti )
                        etherP.newF( tin0P , LF , posti , costa ) ; ___( posti ) ;
                        ZE( osTextT* , posti ) ;
            
                        const countT costa = cToDo ;

                        if( cToDo > csttMaxP ) cToDo = csttMaxP ;

                        countT cToDo = pInfo->cbUsed ;
                        //CONoUTrAW3( "writing data: body file is " , pInfo->cbUsed , " bytes\r\n" ) ;
                    {
                    if( !bFail )
    
                    }
                        bFail = 1 ;
                        DEL( pInfo ) ;
                        //CONoUTrAW( "writing data: body file is too large\r\n" ) ;
                        POOPR
                    {
                    if( pInfo->cbUsedHigh )
                {
                if( !bFail && pInfo )
        
                }
                    bFail = 1 ;
                    //CONoUTrAW( "writing data: could not get info for body file\r\n" ) ;
                    POOPR
                {
                if( POOP )
                ((tin1S&)tin0P).pEtScratch->diskFileQueryF( tin0P , pInfo , hFileBody ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            if( !bFail )
    
            }
                bFail = 1 ;
                //CONoUTrAW( "writing data: could not open the body file\r\n" ) ;
                POOPR
            {
            if( POOP )
            ((tin1S&)tin0P).pEtScratch->fileOpenF( tin0P , hFileBody , countTC() , psttFileBodyP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
            handleC hFileBody( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            //CONoUTrAW( T("opening body file\r\n") ) ;

            SCOOPS
        {
        IFsCRATCHoK
    {
    else
    }
        bFail = 1 ;
    {
    else if( !etherP.diskFileExistsF( tin0P , psttFileBodyP ) )
    }
        }
            etherP.strMakeF( tin0P , LF , psttP , tBody ) ; ___( psttP ) ;
            etherP.delF( tin0P , psttb ) ;
            TN( tBody , "" ) ; tBody = T(psttb) ;
            etherP.strSubstringF( tin0P , psttb , idf , idl , psttFileBodyP ) ; ___( psttb ) ;
            ZE( countT , idl ) ;
            countT idf = tLit.csF( tin0P ) + 1 ;
            ZE( strokeS* , psttb ) ;
        {
        if( tLit.csF( tin0P ) < psttFileBodyP->idAdam )
    {
    if( 1 == etherP.strIdF( tin0P , tLit , psttFileBodyP ) )
    TN( tLit , "!literal:" ) ;

    ZE( boolT , bFail ) ;
    _IO_
{
boolT getBodySnipFromFileF( tin0S& tin0P , etherC& etherP , strokeS*& psttP , const strokeS* const psttFileBodyP , const countT csttMaxP = TOCK )

}
    return bFail ;
    }
        //U::CANNOT DO THIS HERE BECAUSE THERE MIGHT BE MUTLIPLE RECIPIENTS, EACH OF WHICH NEEDS THIS FILE TO EXIST: if( !bFail && etherP.diskFileExistsF( tin0P , psttFileBodyP ) ) etherP.boxZapF( tin0P , psttFileBodyP ) ;

        }
            }
                DEL( pInfo ) ;
                }
                    }
                        etherP.delF( tin0P , posti ) ;
                        }
                            }
                                }
                                    }
                                        }
                                            break ;
                                            if( bNew ) bNew = 0 ;
                                        {
                                        default :
                                        }
                                            break ;
                                            }
                                                //CONoUTrAW( "." ) ;
                                                bNew = 0 ;
                                            {
                                            if( bNew )
                                        {
                                        case '.' :
                                        }
                                            break ;
                                            if( !bNew ) bNew = 1 ;
                                        {
                                        case '\n' :
                                        case '\r' :
                                    {
                                    switch( posti[ offi ] )
                                    //CONoUTrAW( post2 ) ;
                                    osTextT post2[] = { posti[ offi ] , 0 } ;
                                {
                                for( countT offi = 0 ; offi < cNibble ; offi ++ )
            
                                cToDo -= cNibble ;
                                etherP.fileReadF( tin0P , posti , cNibble , hFileBody ) ;
                                countT cNibble = costa < cToDo ? costa : cToDo ;
                            {
                            while( cToDo )
                            boolT bNew = 1 ;
                        {
                        if( posti )
                        etherP.newF( tin0P , LF , posti , costa ) ; ___( posti ) ;
                        ZE( osTextT* , posti ) ;
            
                        const countT costa = TOCK < cToDo ? TOCK : cToDo ;
                        countT cToDo = pInfo->cbUsed ;
                        //CONoUTrAW3( "writing data: body file is " , pInfo->cbUsed , " bytes\r\n" ) ;
                    {
                    if( !bFail )
    
                    }
                        bFail = 1 ;
                        DEL( pInfo ) ;
                        //CONoUTrAW( "writing data: body file is too large\r\n" ) ;
                        POOPR
                    {
                    if( pInfo->cbUsedHigh )
                {
                if( !bFail && pInfo )
        
                }
                    bFail = 1 ;
                    //CONoUTrAW( "writing data: could not get info for body file\r\n" ) ;
                    POOPR
                {
                if( POOP )
                ((tin1S&)tin0P).pEtScratch->diskFileQueryF( tin0P , pInfo , hFileBody ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            if( !bFail )
    
            }
                bFail = 1 ;
                //CONoUTrAW( "writing data: could not open the body file\r\n" ) ;
                POOPR
            {
            if( POOP )
            ((tin1S&)tin0P).pEtScratch->fileOpenF( tin0P , hFileBody , countTC() , psttFileBodyP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
            handleC hFileBody( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            //CONoUTrAW( T("opening body file\r\n") ) ;

            SCOOPS
        {
        IFsCRATCHoK
    {
    else
    }
        bFail = 1 ;
    {
    else if( !etherP.diskFileExistsF( tin0P , psttFileBodyP ) )
    }
        }
            //CONoUTrAW( tBody ) ;
            etherP.delF( tin0P , psttb ) ;
            TN( tBody , "" ) ; tBody = T(psttb) ;
            etherP.strSubstringF( tin0P , psttb , idf , idl , psttFileBodyP ) ; ___( psttb ) ;
            ZE( countT , idl ) ;
            countT idf = tLit.csF( tin0P ) + 1 ;
            ZE( strokeS* , psttb ) ;
        {
        if( tLit.csF( tin0P ) < psttFileBodyP->idAdam )
        //CONoUTrAW( T("sending literal value\r\n") ) ;
    {
    if( 1 == etherP.strIdF( tin0P , tLit , psttFileBodyP ) )
    TN( tLit , "!literal:" ) ;

    //CONoUTrAW( T("processing body file \"")+T(psttFileBodyP)+T("\"\r\n") ) ;
    ZE( boolT , bFail ) ;
    _IO_
{
boolT logBodySnipFromFileF( tin0S& tin0P , etherC& etherP , const strokeS* const psttFileBodyP )

}
    return bFail ;

    }
        //U::CANNOT DO THIS HERE BECAUSE THERE MIGHT BE MUTLIPLE RECIPIENTS, EACH OF WHICH NEEDS THIS FILE TO EXIST: if( !bFail && etherP.diskFileExistsF( tin0P , psttFileBodyP ) ) etherP.boxZapF( tin0P , psttFileBodyP ) ;

        }
            }
                DEL( pInfo ) ;
                }
                    }
                        etherP.delF( tin0P , posti ) ;
                        }
                            }
                                }
                                    }
                                        }
                                            break ;
                                            if( bNew ) bNew = 0 ;
                                        {
                                        default :
                                        }
                                            break ;
                                            }
                                                sockP.writeF( tin0P , "." , 1 ) ;
                                                bNew = 0 ;
                                            {
                                            if( bNew )
                                        {
                                        case '.' :
                                        }
                                            break ;
                                            if( !bNew ) bNew = 1 ;
                                        {
                                        case '\n' :
                                        case '\r' :
                                    {
                                    switch( posti[ offi ] )
                                    sockP.writeF( tin0P , posti + offi , 1 ) ;
                                {
                                for( countT offi = 0 ; offi < cNibble ; offi ++ )
            
                                cToDo -= cNibble ;
                                etherP.fileReadF( tin0P , posti , cNibble , hFileBody ) ;
                                countT cNibble = costa < cToDo ? costa : cToDo ;
                            {
                            while( cToDo )
                            boolT bNew = 1 ;
                        {
                        if( posti )
                        etherP.newF( tin0P , LF , posti , costa ) ; ___( posti ) ;
                        ZE( osTextT* , posti ) ;
            
                        const countT costa = TOCK < cToDo ? TOCK : cToDo ;
                        countT cToDo = pInfo->cbUsed ;
                        //CONoUTrAW3( "writing data: body file is " , pInfo->cbUsed , " bytes\r\n" ) ;
                    {
                    if( !bFail )
    
                    }
                        bFail = 1 ;
                        DEL( pInfo ) ;
                        //CONoUTrAW( "writing data: body file is too large\r\n" ) ;
                        flagsFailP |= flFAIL_DATAbODYfILEtOOlARGE ;
                        POOPR
                    {
                    if( pInfo->cbUsedHigh )
                {
                if( !bFail && pInfo )
        
                }
                    bFail = 1 ;
                    //CONoUTrAW( "writing data: could not get info for body file\r\n" ) ;
                    flagsFailP |= flFAIL_DATAcANNOTgETbODYfILEiNFO ;
                    POOPR
                {
                if( POOP )
                ((tin1S&)tin0P).pEtScratch->diskFileQueryF( tin0P , pInfo , hFileBody ) ; ___( pInfo ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            if( !bFail )
    
            }
                bFail = 1 ;
                //CONoUTrAW( "writing data: could not open the body file\r\n" ) ;
                flagsFailP |= flFAIL_DATAcANNOToPENfILE ;
                POOPR
            {
            if( POOP )
            ((tin1S&)tin0P).pEtScratch->fileOpenF( tin0P , hFileBody , countTC() , psttFileBodyP , ifcOPENaCCESS_R , 0 , flOPENdETAILS_LOCsEQ | flOPENdETAILS_DOnOTvALIDATE , ifcOPENhOW_nFeO ) ;
            handleC hFileBody( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            //CONoUTrAW( T("opening body file\r\n") ) ;

            SCOOPS
        {
        IFsCRATCHoK
    {
    else
    }
        bFail = 1 ;
        flagsFailP |= flFAIL_DATAfILEdOESnOTeXIST ;
    {
    else if( !etherP.diskFileExistsF( tin0P , psttFileBodyP ) )
    }
        }
            sockP.writeF( tin0P , (osTextT*)tBody , tBody.csF( tin0P ) ) ;
            etherP.delF( tin0P , psttb ) ;
            TN( tBody , "" ) ; tBody = T(psttb) ;
            etherP.strSubstringF( tin0P , psttb , idf , idl , psttFileBodyP ) ; ___( psttb ) ;
            ZE( countT , idl ) ;
            countT idf = tLit.csF( tin0P ) + 1 ;
            ZE( strokeS* , psttb ) ;
        {
        if( tLit.csF( tin0P ) < psttFileBodyP->idAdam )
        //CONoUTrAW( T("sending literal value\r\n") ) ;
    {
    if( 1 == etherP.strIdF( tin0P , tLit , psttFileBodyP ) )
    TN( tLit , "!literal:" ) ;

    etherP.traceF( tin0P , T("processing body file \"")+T(psttFileBodyP)+T("\"") ) ;
    ZE( boolT , bFail ) ;
{
boolT writeBodySnipFromFileF( tin0S& tin0P , etherC& etherP , socketC& sockP , const strokeS* const psttFileBodyP , flagsT& flagsFailP )

#define flFAIL_COULDnOTzAPsENTfILE                  0xe80000ff
#define flFAIL_STARTtlsrEJECTED                     0xe40000ff
#define flFAIL_UNAUTHORIZEDrELAYsERVER              0xe20000ff
#define flFAIL_DATAfILEdOESnOTeXIST                 0xe10000ff
#define flFAIL_DATAbODYfILEtOOlARGE                 0xe08000ff
#define flFAIL_DATAcANNOTgETbODYfILEiNFO            0xe04000ff
#define flFAIL_DATAcANNOToPENfILE                   0xe02000ff
#define flFAIL_COULDnOTmOVEfILE                     0xe01000ff
#define flFAIL_COULDnOTgETsHORTfILEnAME             0xe00800ff
#define flFAIL_UNKNOWNeRROR                         0xe00400ff
#define flFAIL_QUITcOMMANDrEJECTED                  0xe00200ff
#define flFAIL_BODYrEJECTED                         0xe00100ff
#define flFAIL_DATAcOMMANDrREJECTED                 0xe00080ff
#define flFAIL_RCPTtOrEJECTED                       0xe00040ff
#define flFAIL_MAILfROMrEJECTED                     0xe00020ff
#define flFAIL_HELLOaCCEPTED                        0xe00010ff
#define flFAIL_HELLOrEJECTED                        0xe00008ff
#define flFAIL_COULDnOTcONNECT                      0xe00004ff
#define flFAIL_DURINGpARSING                        0xe00002ff
#define flFAIL_COULDnOTgETsHADOW                    0xe00001ff

/*1*/WAKEhIDE( "revision.of.ifcIDaDAM_EATiNCOMINGoRDERSoLD" )/*1*/

/**/
*/
/*

// NEW APPLICATION (NO PRIOR REVISIONS)

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

