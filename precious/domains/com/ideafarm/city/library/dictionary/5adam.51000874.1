
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.traceF( tin0P , T("i've been fired") ) ;

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    }
        }
            etThread.traceF( tin0P , T("socket is impotent") ) ;
            POOPRqUIET
        {
        if( POOP )

        etThread.traceF( tin0P , T("[nonce]:    ")+tValueNonce ) ;
        TN( tb4 , "    " ) ;

        }
            DEL( pSwPathValue ) ;

            }
                }
                    etThread.delF( tin0P , psttValue ) ;

                    }
                        }
                            etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                            *pptValue[ offe ] = T(psttValue) ;
                        {
                        if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                    {
                    for( countT offe = 0 ; offe < cPaths ; offe ++ )

                    if( cPaths - cValues ) { BLAMMO ; }
                    countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                    countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                    etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                    etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

                    strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                    psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                    _IO_
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
            {
            if( !POOP )

            //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

            ;
            }
                &tPathNonce     ,
                &tPathError     ,
                &tPathErrorCode ,
            {
            textC* pptPath[] =

            TN( tPathNonce     , "\"nonce\"/"   ) ;
            TN( tPathError     , "\"error\"/"   ) ;
            TN( tPathErrorCode , "\"errcode\"/" ) ;

            ;
            }
                &tValueNonce     ,
                &tValueError     ,
                &tValueErrorCode ,
            {
            textC* pptValue[] =

            TN( tValueError     , "" ) ;
            TN( tValueErrorCode , "" ) ;

            __Z( pSwPathValue ) ;
            etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
            ZE( switchC* , pSwPathValue ) ;
            ZE( strokeS* , psttPath     ) ;
        {
        TN( tValueNonce     , "" ) ;

        etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        etThread.traceF( tin0P , T("json response:") ) ;

        }
            }
                else if( costj ) break ;
                     if( cNest ) costj ++ ;

                else if( postj[ costj ] == '}' ) cNest -- ;
                     if( postj[ costj ] == '{' ) cNest ++ ;

                if( !cbIn ) break ;
                countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
            {
            for(;;)
            ZE( countT , cNest ) ;
        {
        ZE( countT , costj ) ;
        osTextT postj[ TUCK << 1 ] ;

        sockc.writeF( tin0P , (osTextT*)tSay ) ;
        etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        etThread.traceF( tin0P , T("request:") ) ;

        TN( tSay , "" ) ; tSay = T("POST /_synapse/admin/v1/register HTTP/1.1")/*+T("\r\nAuthorization: Bearer ")+tValueSharedSecret*/+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;

        countT costBody = tBody.csF( tin0P ) ;

        sockc.connectF( tin0P , 443 , nnServer ) ;
        socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

        countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
        countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
        countT timeAllowedConnected = TICK >> 2 ;

        nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
        nicNameC nnServer ;

        ) ;

            "}\r\n"
            "    \"mac\": \"")+tMac                 +T("\"\r\n"
//            "    \"admin\": \"false"                   "\",\r\n"
            "    \"password\": \"")+tPass           +T("\",\r\n"
            "    \"username\": \"")+tUser           +T("\",\r\n"
            "    \"nonce\": \"")+tValueNonce        +T("\",\r\n"
            "{\r\n"

        TN( tBody , "" ) ; tBody = T(

        etThread.traceF( tin0P , T("[mac]:    ")+tMac ) ;

        //NOT GONE:etThread.osSleepF( tin0P , TICK >> 3 ) ;
        //GONE:    etThread.osSleepF( tin0P , TICK >> 2 ) ;
        //GONE:    etThread.osSleepF( tin0P , TICK << 0 ) ;
        //NOT GONE:etThread.osSleepF( tin0P , TOCK << 5 ) ;
        //NOT GONE:etThread.osSleepF( tin0P , TOCK << 3 ) ;

        }
            etThread.delF( tin0P , posti ) ;
            tMac = T(posti) ;
            etThread.boxGetShadowF( tin0P , posti , costi , tIn ) ; ___( posti ) ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;

            etThread.traceF( tin0P , T("calculate the MAC and put it into ")+tIn ) ;
            TN( tIn , "///d/tmp/mac.ttt" ) ;
        {
#endif


        }
            etThread.delF( tin0P , postim ) ;
            }
                }
                    tMac = T(++postc) ;
                {
                if( postc )
                osTextT* postc = thirdC::c_strstrIF( tin0P , postim , " " ) ;
                postim[ costim - 2 ] = 0 ;    //REMOVE TRAILING UNIX LINEFEED
            {
            if( postim && costim )
            etThread.boxGetShadowF( tin0P , postim , costim , tFileResult ) ; ___( postim ) ;
            ZE( countT   , costim ) ;
            ZE( osTextT* , postim ) ;

            countT rc = thirdC::c_systemIF( tin0P , postCmd ) ;         // "HMAC-SHA1(d:\tmp\raw.ttt)= 7665adce3fb57df2eda381c345558242f08996a0"
            
            thirdC::c_strcatIF( tin0P , postCmd , osfnResult ) ;
            thirdC::c_strcatIF( tin0P , postCmd , " > " ) ;
            thirdC::c_strcatIF( tin0P , postCmd , osfnRaw ) ;
            thirdC::c_strcatIF( tin0P , postCmd , " " ) ;
            thirdC::c_strcatIF( tin0P , postCmd , tValueSharedSecret ) ;
            thirdC::c_strcpyIF( tin0P , postCmd , "openssl sha1 -hmac " ) ;
            postCmd[ 0 ] = 0 ;
            osTextT postCmd[ TUCK << 1 ] ;

            etThread.boxPutF( tin0P , tFileRaw , postRaw , costRaw ) ;

            osFileNameC osfnResult( tin0P , etThread , tFileResult ) ;
            osFileNameC osfnRaw(    tin0P , etThread , tFileRaw    ) ;

            TN( tFileResult , "///d/tmp/result.ttt" ) ;
            TN( tFileRaw    , "///d/tmp/raw.ttt"    ) ;

            countT costRaw = postc - postRaw ;
            //thirdC::c_strcpyIF( tin0P , postc , posti ) ; postc += costi     ;
            //costi = tNote.csF( tin0P ) ;
            //posti = tNote ;

            thirdC::c_strcpyIF( tin0P , postc , posti ) ; postc += costi + 1 ;
            costi = tPass.csF( tin0P ) ;
            posti = tPass ;

            thirdC::c_strcpyIF( tin0P , postc , posti ) ; postc += costi + 1 ;
            costi = tUser.csF( tin0P ) ;
            posti = tUser ;

            thirdC::c_strcpyIF( tin0P , postc , posti ) ; postc += costi + 1 ;
            countT   costi = tValueNonce.csF( tin0P ) ;
            osTextT* posti = tValueNonce ;

            osTextT* postc = postRaw ;
            thirdC::c_memsetIF( tin0P , postRaw , sizeof postRaw , 0 ) ;
            osTextT postRaw[ TUCK ] ;
        {
#if defined( NEVERdEFINED )
        TN( tMac , "" ) ;

  //      TN( tNote , "notadmin"  ) ;
        TN( tPass , "pizza"     ) ;
        TN( tUser , "pepperoni" ) ;

        SCOOPS
    {
    IFsCRATCH

    }
        }
            etThread.traceF( tin0P , T("socket is impotent") ) ;
            POOPRqUIET
        {
        if( POOP )

        etThread.traceF( tin0P , T("[nonce]:    ")+tValueNonce ) ;

        }
            DEL( pSwPathValue ) ;

            }
                }
                    etThread.delF( tin0P , psttValue ) ;

                    }
                        }
                            etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                            *pptValue[ offe ] = T(psttValue) ;
                        {
                        if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                    {
                    for( countT offe = 0 ; offe < cPaths ; offe ++ )

                    if( cPaths - cValues ) { BLAMMO ; }
                    countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                    countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                    etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                    etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

                    strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                    psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                    _IO_
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
            {
            if( !POOP )

            //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

            ;
            }
                &tPathNonce     ,
                &tPathError     ,
                &tPathErrorCode ,
            {
            textC* pptPath[] =

            TN( tPathNonce     , "\"nonce\"/"   ) ;
            TN( tPathError     , "\"error\"/"   ) ;
            TN( tPathErrorCode , "\"errcode\"/" ) ;

            ;
            }
                &tValueNonce     ,
                &tValueError     ,
                &tValueErrorCode ,
            {
            textC* pptValue[] =

            TN( tValueError     , "" ) ;
            TN( tValueErrorCode , "" ) ;

            __Z( pSwPathValue ) ;
            etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
            ZE( switchC* , pSwPathValue ) ;
            ZE( strokeS* , psttPath     ) ;
        {

        etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        etThread.traceF( tin0P , T("json response:") ) ;

        }
            }
                else if( costj ) break ;
                     if( cNest ) costj ++ ;

                else if( postj[ costj ] == '}' ) cNest -- ;
                     if( postj[ costj ] == '{' ) cNest ++ ;

                if( !cbIn ) break ;
                countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
            {
            for(;;)
            ZE( countT , cNest ) ;
        {
        ZE( countT , costj ) ;
        osTextT postj[ TUCK << 1 ] ;

        sockc.writeF( tin0P , (osTextT*)tSay ) ;
        etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        etThread.traceF( tin0P , T("request:") ) ;

        TN( tSay , "" ) ; tSay = T("GET /_synapse/admin/v1/register HTTP/1.1")+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;

        countT costBody = tBody.csF( tin0P ) ;

        sockc.connectF( tin0P , 443 , nnServer ) ;
        socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

        countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
        countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
        countT timeAllowedConnected = TICK >> 2 ;

        nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
        nicNameC nnServer ;

        TN( tBody , "" ) ;

        SCOOPS
    {
    IFsCRATCH
    TN( tValueNonce , "" ) ;
{
else
if( !tValueSharedSecret.csF( tin0P ) ) etThread.traceF( tin0P , T("could not retrieve shared secret") ) ;

TN( tServer , "m.ideafarm.com" ) ;

}
    etThread.traceF( tin0P , T("[sharedSecret]:    ")+tValueSharedSecret ) ;
    etThread.delF( tin0P , psttSharedSecret ) ;
    if( psttSharedSecret && psttSharedSecret->idAdam ) tValueSharedSecret = T(psttSharedSecret) ;

    ZE( strokeS* , psttSharedSecret ) ; etThread.querySettingF( tin0P , psttSharedSecret , T("!ipdos.password.matrix.ideafarm.com.shared.secret")  ) ; ___( psttSharedSecret ) ;
{
TN( tValueSharedSecret , "" ) ;

TODO

// BASELINE: 872_

/*1*/WAKEsHOWtEXT( "doodle.create.user.with.kludge.python.function" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
