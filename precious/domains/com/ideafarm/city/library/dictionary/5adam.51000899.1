
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        }
            }
                IFsCRATCHoK{}

                etThread.delF( tin0P , pbq ) ;
                }
                    }
                        }
                            etThread.delF( tin0P , pbr ) ;
                            }
                                }
                                    }
                                        etRock.traceF( tin0P , T("!exception / could not write reply") ) ;
                                        POOPRqUIET
                                    {
                                    else
                                    if( !POOP ) /*;*/etRock.traceF( tin0P , T("wrote reply") ) ;
                                    sockd.writeF( tin0P , idp , nnPeer , pbr , cbr ) ;
                                    /**/etRock.traceF( tin0P , T("replying / 1 [cbr]:    ")+TF2(cbr,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    _IO_
                                {
                                else
                                }
                                    etRock.traceF( tin0P , T("!exception / could not build reply [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    POOPRqUIET
                                    countT rc = POOP ;
                                    _IO_
                                {
                                if( POOP )
                                ((tin1S&)tin0P).pEtScratch->dnsReplyF( tin0P , pbr , cbr , pbq , stsReplies , 1 , idError ) ;
                                SCOOPS
                                _IO_
                            {
                            IFsCRATCHoK
                            ZE( countT , cbr ) ;
                            ZE( byteT* , pbr ) ;
                            /**/etRock.traceF( tin0P , T("replying / 2") ) ;

                            else                          /*;*/etRock.traceF( tin0P , T("replying [error]:    ")+TF2(idError,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            if( postError && *postError ) /*;*/etRock.traceF( tin0P , T("replying [error]:    ")+T(postError)                                          ) ;
                            const osTextT* postError = processGlobal4S::_processGlobal4I_IF().mapIdErrorDns( idError ) ;
                        {
                        if( !bSilent || bForceReply )

                        }
                            }
                                }
                                    if( !stsReplies ) idError = ifcIDeRRORdNS_NAMEnOTdEFINED ;

                                    }
                                        DEL( ps ) ;
                                        }
                                            }
                                                }
                                                    break ;
                                                
                                                    }
                                                        rec_AAAA_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut ) ;
                                                        bSilent = 0 ;
                                                    {
                                                    if( ~nnOut )
                                                
                                                           if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tTarget      ) ) nnOut = nnHostWebLag0 ;
                                                    //else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHook1    ) ) nnOut = nnWebHook1    ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                                    //     if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHooks    ) ) nnOut = nnWebHook1    ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...

                                                    //etRock.traceF( tin0P , T("U:: debug    [tTarget]:    \"")+tTarget+T("\"") ) ;
                                                    //etRock.traceF( tin0P , T("U:: debug [tDomainNet]:    \"")+tDomainNet+T("\"") ) ;
                                                
                                                    nicNameC nnOut ;
                                                    /**/etRock.traceF( tin0P , T("AAAA request [tDomainNet]:    ")+tDomainNet ) ;
                                                    _IO_
                                                {
                                                case ifcIDtYPEdNSqUERY_AAAA :
                                                }
                                                    break ;

                                                    }
                                                        rec_A_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut ) ;
                                                        bSilent = 0 ;
                                                    {
                                                    if( ~nnOut )

                                                    }
                                                        else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHook1    ) ) nnOut = nnWebHook1 ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                                             if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHooks    ) ) nnOut = nnWebHook1 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...
                                                    {
                                                    else
                                                    }
                                                             if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHooks    ) ) nnOut = nnWebHook2 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...
                                                    {
                                                    if( bDivert )

                                                    nicNameC nnOut ;
                                                    /**/etRock.traceF( tin0P , T("A request [tDomainNet]:    ")+tDomainNet ) ;
                                                    _IO_
                                                {
                                                case ifcIDtYPEdNSqUERY_A :
                                                }
                                                    break ;
                                                {
                                                case ifcIDtYPEdNSqUERY_CAA :
                                            {
                                            if( idClass == 1 ) switch( idType )

                                            *ps >> idClass ;
                                            ZE( countT , idClass ) ;

                                            *ps >> idType ;
                                            ZE( countT , idType ) ;

                                            etThread.delF( tin0P , psttw ) ;
                                            TN( tDomainNet , psttw ) ;
                                            }
                                                etThread.delF( tin0P , psttSuffix ) ;

                                                }
                                                    }
                                                        etThread.osTimeNowF( tin0P , timeUsed1 , timeUsed2 ) ;
                                                        timeUsed2 = timeUsed1 = 0 ;
                                                        cUsed = 1 ;

                                                        grab_tWoTimePassword.ungrabF( tin0P ) ;
                                                                              tGorillaSuffix = tWoTimePassword+tDotHiddenDotIdeafarmDotCom ;
                                                        tGorillaSuffixUsed  = tGorillaSuffix ; 
                                                                              tWoTimePassword = tPasswordPrefix+TF4((countT)ruPassword,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FILLzE,0,0x24) ;
                                                        tWoTimePasswordUsed = tWoTimePassword ;
                                                        grab_tWoTimePassword.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                                                        cUsed = 0 ;
                                                    {
                                                    if( bNewPassword )

                                                    }
                                                        bNewPassword = 1 ;
                                                        bDivert = 0 ;
                                                    {
                                                    else if( !etThread.strCompareF( tin0P , psttSuffix , tGorillaSuffix ) )
                                                    }
                                                        if( ++ cUsed > 0x8 || timeE2 || timeE1 > TOCK ) bNewPassword = 1 ;

                                                        etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeUsed1 , timeUsed2 ) ;
                                                        etThread.osTimeNowF(      tin0P , timeE1 , timeE2 ) ;
                                                        ZE( sCountT , timeE2 ) ;
                                                        ZE( countT  , timeE1 ) ;

                                                        bDivert = 0 ;                                                                       //PS:PERSONALITY: THE DUPLICATE USAGE IS ALWAYS HONORED, BUT THEN WILL BE RETIRED IF USED TOO MANY TIMES OR TOO MUCH TIME HAS ELAPSED SINCE WOTH USE
                                                    {
                                                    if( !etThread.strCompareF( tin0P , psttSuffix , tGorillaSuffixUsed ) )
                                                    ZE( boolT , bNewPassword ) ;
                                                {
                                                if( bDivert )                                                                               //PS:PERSONALITY: HONOR THE USED SUFFIX SO THAT DUPLICATE QUERIES ALL RECEIVE THE SAME wh1 ANSWER UNTIL THE CURRENT PASSWORD IS USED

                                                /**/etRock.traceF( tin0P , T("[domainNet,suffix,peer]:      \"")+T(psttw)+T("\"    \"")+T(psttSuffix)+T("\"    \"")+tDomainPeer+T("\"") ) ;

                                                etThread.strMakeF( tin0P , LF , psttw , tDomainNet ) ; ___( psttw ) ;
                                                TN( tDomainNet , "" ) ; tDomainNet = T(psttNet)+T(".hidden.ideafarm.com") ;

                                                etThread.delF( tin0P , psttw ) ;
                                                if( bDivert ) { etThread.strSubstringF( tin0P , psttSuffix , idf , countTC()    , psttw , 0     ) ; ___( psttSuffix ) ; }
                                                etThread.strSubstringF( tin0P , psttNet    , idf , sttq , tDash , psttw , 0 , 0 ) ; ___( psttNet    ) ;
                                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                countT idf = 1 ;
                                                ZE( strokeS* , psttSuffix ) ;
                                                ZE( strokeS* , psttNet ) ;
                                                _IO_
                                            {
                                            if( psttw && etThread.strIdF( tin0P , tHidden , psttw , 1 ) && etThread.strIdF( tin0P , tDash , psttw , 1 ) )

                                            /**/etRock.traceF( tin0P , T("[domainGross,peer]:    \"")+tDomainGross+T("\"    \"")+tDomainPeer+T("\"") ) ;
                                            TN( tDomainGross , psttw ) ;
                                            if( psttw ) ((tin1S&)tin0P).pEtScratch->strConvertToLowerCaseF( tin0P , psttw ) ; ___( psttw ) ;
                                            *ps >> psttw ;
                                            ZE( strokeS* , psttw ) ;
                                            _IO_
                                        {
                                        if( ps )
                                        stsQueries >> ps ;
                                        ZE( soulC* , ps ) ;
                                        _IO_
                                    {
                                    while( stsQueries )
                                    _IO_
                                {
                                else
                                }
                                    idError = ifcIDeRRORdNS_CANNOTpARSEqUERY ;
                                    etRock.traceF( tin0P , T("!exception / could not parse query") ) ;
                                    POOPRqUIET
                                {
                                if( POOP )
                                etThread.delF( tin0P , pbNU ) ;
                                ((tin1S&)tin0P).pEtScratch->dnsParseF( tin0P , pbNU , countTC() , stsQueries , stsRepliesNU , pbq , cbq ) ;
                                SCOOPS
                                _IO_
                            {
                            IFsCRATCHoK
                            ZE( byteT* , pbNU ) ;

                            stsRepliesNU.purgeF( tin0P ) ;
                            stsQueries.purgeF( tin0P ) ;
                            _IO_
                        {

                        ++ idClient ;

                        //}
                        //    /**/etRock.traceF( tin0P , TT(timeN1,timeN2)+tb4+tTimeOld+tb4+T(nnPeer)+(bDivert?tSayDiverting:tSayGranting)+tDomainPeer ) ;
                        //
                        //    }
                        //        etThread.delF( tin0P , psttSay ) ;
                        //        tTimeOld = T(psttSay) ;
                        //        etThread.strFromOldTimeF( tin0P , psttSay , mm , hh , d , m , y , dow , 0 ) ; ___( psttSay ) ;
                        //        ZE( strokeS* , psttSay ) ;
                        //    {
                        //    TN( tTimeOld , "" ) ;
                        //
                        //    etThread.osTimeToOldTimeF( tin0P , ms , ss , mm , hh , d , m , y , dow , timeN1 , timeN2 , flOStIMEtOoLDtIME_null ) ;
                        //    ZE(  countT , dow ) ;
                        //    ZE( sCountT , y   ) ;
                        //    ZE(  countT , m   ) ;
                        //    ZE(  countT , d   ) ;
                        //    ZE(  countT , hh  ) ;
                        //    ZE(  countT , mm  ) ;
                        //    ZE(  countT , ss  ) ;
                        //    ZE(  countT , ms  ) ;
                        //
                        //    etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                        //    ZE( sCountT , timeN2 ) ;
                        //    ZE( countT  , timeN1 ) ;
                        //{

                        countT idError = ifcIDeRRORdNS_AOK ;
                        _IO_
                    {
                    if( pbq && cbq )
                    _IO_
                {

                }
                    }
                        etRock.traceF( tin0P , T("::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: not diverting") ) ;
                        bDivert = 0 ;                                                                                                                                   //P:PERSONALITY: SUPPRESS DIVERSION IF RECENT QUERY FROM LETSENCRYPT
                    {
                    else
                    if( !timeLetsEncryptLath2 && !timeLetsEncryptLath1 ) etRock.traceF( tin0P , T("||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| * * * * D I V E R T I N G * * * *") ) ;
                {
                if( bDivert )

                }
                    }
                        etRock.traceF( tin0P , T("----------------------------------------------------------------------------------- DIVERSION ENABLED") ) ;
                        bForceReply = timeLetsEncryptLath2 = timeLetsEncryptLath1 = 0 ;
                    {
                    if( timeE2 || timeE1 > TICK << 0 )

                    etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeLetsEncryptLath1 , timeLetsEncryptLath2 ) ;
                    etThread.osTimeNowF( tin0P , timeE1 , timeE2 ) ;
                    ZE( sCountT , timeE2 ) ;
                    ZE( countT  , timeE1 ) ;
                {
                else if( timeLetsEncryptLath2 || timeLetsEncryptLath1 )
                }
                    etRock.traceF( tin0P , T(bSuppressed?"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ DIVERSION SUPPRESSION REFRESHED":"+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ DIVERSION SUPPRESSED") ) ;
                    etThread.osTimeNowF( tin0P , timeLetsEncryptLath1 , timeLetsEncryptLath2 ) ;
                    timeLetsEncryptLath2 = timeLetsEncryptLath1 = 0 ;
                    countT bSuppressed = timeLetsEncryptLath2 || timeLetsEncryptLath1 ;
                    bForceReply = 1 ;
                {
                if( 1 + tDomainPeer.csF( tin0P ) - tDotLetsEncryptDotOrg.csF( tin0P ) == etThread.strIdF( tin0P , tDotLetsEncryptDotOrg , tDomainPeer ) )

                }
                    }
                        /**/etRock.traceF( tin0P , tSayPrefix+T(nnPeer)+tSayUnknownDomain+tb4+tDomainPeer ) ;
                        bDivert = 1 ;
                    {
                    if( !bStripeWebHookNotifier && !bListedDomain )         //P:PERSONALITY: TRUSTED PEERS ARE DIRECTED TO wh1 ; UNTRUSTED PEERS ARE DIRECTED TO wh2

                    }
                        mySettings.grabMe.ungrabF( tin0P ) ;
                        }
                            }
                                }
                                    break ;
                                    bStripeWebHookNotifier = 1 ;
                                {
                                if( mySettings.pnnSubnetAllowedStripe[ offn ] == nnPeer( 0x40 ) )
                            {
                            else
                            }
                                }
                                    break ;
                                    bStripeWebHookNotifier = 1 ;
                                {
                                if( mySettings.pnnSubnetAllowedStripe[ offn ] == nnPeer( 0x18 ) )
                            {
                            if( nnPeer.isIPv4F() )
                            _IO_
                        {
                        for( countT offn = 0 ; offn < mySettings.cnnSubnetAllowedStripe ; offn ++ )
                        mySettings.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                        _IO_
                    {
                    if( !bListedDomain )
                    ZE( boolT , bStripeWebHookNotifier ) ;

                    }
                        etThread.delF( tin0P , psttPeer ) ;
                        }
                            mySettings.grabMe.ungrabF( tin0P ) ;
                            }
                                }
                                    break ;
                                    bListedDomain ++ ;
                                {
                                if( idHit && idHit == 1 + psttPeer->idAdam - mySettings.pptListedDomain[ offt ]->csF( tin0P ) )
                                countT idHit  = etThread.strIdF( tin0P , *mySettings.pptListedDomain[ offt ] , psttPeer , 1 ) ;
                            {
                            for( countT offt = 0 ; offt < mySettings.cListedDomain ; offt ++ )
                            mySettings.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                            /**/etRock.traceF( tin0P , T("[tPeer]:    ")+T(psttPeer) ) ;
                            tDomainPeer = T(psttPeer) ;
                            _IO_
                        {
                        else
                        if( !psttPeer ) /*;*/etRock.traceF( tin0P , T("!exception / reverse DNS lookup failed") ) ;
                        etThread.sockPsttHostF( tin0P , psttPeer , nnPeer ) ; ___( psttPeer ) ;
                        ZE( strokeS* , psttPeer ) ;
                    {
                    ZE( boolT , bListedDomain ) ;
                    _IO_
                {
                TN( tDomainPeer , "" ) ;
                ZE( boolT , bDivert ) ;
                boolT bSilent = 1 ;         //PS:PERSONALITY: I DO NOT RESPOND UNLESS I KNOW THE ANSWER TO THE QUERY ; THIS IS INTENDED TO CAUSE THE REQUESTING PEER TO FAILOVER TO MAKE THE REQUEST FROM ITS ALTERNATE DNS SERVER

                mySettings.grabMe.ungrabF( tin0P ) ;

                nicNameC nnWebHook2 = etThread.sockNicNameF( tin0P , mySettings.tIpWebHook2 ) ;
                nicNameC nnWebHook1 = etThread.sockNicNameF( tin0P , mySettings.tIpWebHook1 ) ;

                TN( tb4            , "    "                          ) ;
                TN( tTarget        , "target.ipv6-only.ideafarm.com" ) ;
                TN( tWebHook1      , ""                              ) ; tWebHook1 = mySettings.tDomainLeafWebHook1Net+T(".hidden.ideafarm.com") ;
                TN( tWebHooks      , ""                              ) ; tWebHooks = mySettings.tDomainLeafWebHooksNet+T(".hidden.ideafarm.com") ;

                mySettings.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                }
                    etThread.traceF( tin0P , T("incoming [idIn,timeE]:    ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TT(timeE1,timeE2) ) ;
                    etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeStart1 , timeStart2 ) ;
                    etThread.osTimeNowF( tin0P , timeE1 , timeE2 ) ;
                    ZE( sCountT , timeE2 ) ;
                    ZE( countT  , timeE1 ) ;
                {
                if( !( ++ idIn % ( TUCK >> 4 ) ) )

                /**/etRock.traceF( tin0P , T("waited for a packet [nnPeer,cbq]:    ")+T(nnPeer)+tb4+TF2(cbq,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                }
                    }
                        break ;
                        ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                        etRock.traceF( tin0P , T("!exception / socket read failed") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    sockd.readF( tin0P , pbq , cbq , idp , nnPeer ) ; ___( pbq ) ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                /**/etRock.traceF( tin0P , T("waiting for a packet") ) ;
                nicNameC nnPeer ;
                ZE( countT , idp ) ;
                ZE( countT , cbq ) ;
                ZE( byteT* , pbq ) ;

                etRock.traceF( tin0P , T("inner loop begun") ) ;
                _IO_
            {
            while( !POOP && !ether )
            ZE( boolT   , bForceReply          ) ;
            ZE( sCountT , timeLetsEncryptLath2 ) ;
            ZE( countT  , timeLetsEncryptLath1 ) ;
            TN( tDotLetsEncryptDotOrg , ".letsencrypt.org"                     ) ;
            TN( tSayGranting          , "    granting information    "         ) ;
            TN( tSayDiverting         , "    diverting information    "        ) ;
            TN( tSayUnknownDomain     , "    !exception / unknown peer domain" ) ;
            TN( tSayPrefix            , "[nnPeer]:    "                        ) ;

            }
                }
                    continue ;
                    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                    etRock.traceF( tin0P , T("!exception / could not bind socket to the dns port") ) ;
                    POOPRqUIET
                {
                if( POOP )
                sockd.bindF( tin0P , ifcPORToLD2_DNS ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK

            }
                }
                    continue ;
                    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                    etRock.traceF( tin0P , T("!exception / could not construct socket") ) ;
                    POOPRqUIET
                {
                if( POOP )

                new( 0 , tin0P , pbSocket , sizeof pbSocket ) socketC( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

                SCOOPS
                _IO_
            {
            IFsCRATCHoK
            socketC& sockd = *(socketC*)pbSocket ;
            byteT pbSocket[ sizeof( socketC ) ] ;

            stsReplies.purgeF( tin0P ) ;
            stsQueries.purgeF( tin0P ) ;

            etRock.traceF( tin0P , T("outer loop begun") ) ;
            _IO_
        {
        while( !POOP && !ether )
        etThread.osTimeNowF( tin0P , timeStart1 , timeStart2 ) ;
        ZE( sCountT , timeStart2 ) ;
        ZE( countT  , timeStart1 ) ;
        ZE( countT , idIn ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        TN( tHidden , ".hidden.ideafarm.com" ) ;
        TN( tb4 , "    " ) ;
        stackC stsQueries(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
        stackC stsReplies(   tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
        stackC stsRepliesNU( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
        ZE( countT , idClient ) ;

        mySettings.grabMe.ungrabF( tin0P ) ;
        _IO_
    {
    else
    }
        /**/etRock.traceF( tin0P , T("!exception / a required setting is missing") ) ;
        mySettings.grabMe.ungrabF( tin0P ) ;
        _IO_
    {
    if( !mySettings )
    mySettings.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

    etherC& etRock = etherC::etRockIF( tin0P ) ;
    TN( tDash , "-" ) ;

    etThread.traceF( tin0P , T("the settings are ready") ) ;
    sgnSettingsReady.waitF( tin0P ) ;

//    etThread.osThreadF( TaRG2cBsTACK( tmUpdateNnHostsF , CBsTACKmIN << 1 ) , (countT)&nnHostWebLath , (countT)&nnHostWebLag0 , (countT)&nnHostWebLag1 , (countT)&nnHostWebLag2 , (countT)&nnHostWebLag3 ) ;

    nicNameC nnHostWebLag3 ;
    nicNameC nnHostWebLag2 ;
    nicNameC nnHostWebLag1 ;

//U::PROD: nicNameC nnHostWebLag0 = etThread.sockNicNameF( tin0P , T("2001:19f0:0000:7077:5400:05ff:fe59:278d") ) ;        //U:: PUT THIS INTO A SETTING ; THIS IS THE IPv6 ASSIGNED TO web1
    nicNameC nnHostWebLag0 = etThread.sockNicNameF( tin0P , T("2001:19f0:0:7077::1") ) ;        //U:: FOR TESTING

    nicNameC nnHostWebLath = etThread.sockNicNameF( tin0P , T("2001:19f0:0:7077::") ) ;                             //U:: PUT THIS INTO A SETTING ; THIS IS THE BEGINNING VALUE THAT IS INCREMENTED BY tmUpdateNnHostsF TO OBTAIN AN EPHEMERAL (AND EVENTUALLY RANDOM) IPv6 VALUE FOR web1

    etThread.osThreadF( TaRG2cBsTACK( tmDispenseWoTimeWebHookSuffixF , CBsTACKmIN << 1 ) , (countT)&tWoTimePassword , (countT)&grab_tWoTimePassword ) ;
    etThread.osThreadF( TaRG2cBsTACK( tmFreshSettingsF               , CBsTACKmIN << 1 ) , (countT)&mySettings      , (countT)&sgnSettingsReady     ) ;

    grab_tWoTimePassword.ungrabF( tin0P ) ;
    ZE( sCountT , timeUsed2 ) ;
    ZE( countT  , timeUsed1 ) ;
    ZE( countT  , cUsed ) ;
    TN( tGorillaSuffixUsed          , ""                     ) ;
    TN( tWoTimePasswordUsed         , ""                     ) ;
    TN( tGorillaSuffix              , ""                     ) ; tGorillaSuffix  = tWoTimePassword+tDotHiddenDotIdeafarmDotCom ;
    TN( tWoTimePassword             , ""                     ) ; tWoTimePassword = tPasswordPrefix+TF4((countT)ruPassword,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FILLzE,0,0x24) ;  //0x24: [0-9,a-z]
    TN( tPasswordPrefix             , "password"             ) ;            // THIS PREFIX IS FOR CONVENIENCE WHEN SEARCHING TRACE LOGS 
    TN( tDotHiddenDotIdeafarmDotCom , ".hidden.ideafarm.com" ) ;
    grab_tWoTimePassword.grabF( tin0P , TAG( TAGiDnULL )     ) ;
    grabC grab_tWoTimePassword( tin0P , TAG( TAGiDnULL )     ) ;

    ranUniC ruPassword( tin0P , (measure04T)MAXcOUNTT + 1 , processGlobal1S::_processGlobal1I_IF().trueRandom ) ;

    signC sgnSettingsReady( tin0P , TAG( TAGiDnULL ) ) ;
    mySettingsS mySettings( tin0P , etThread ) ;

    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIEST ) ;    // RUDE WOULD BE AN ATTACK SURFACE
    thirdC::dosPriorityProcessIF(      tin0P , ifcTHREADpRIORITY_RUDE    ) ;    // THIS IS SO PASSWORD (WEBHOOK SUFFIX) UPDATES ARE NOTICED TIMELY

    _IO_
{
if( pTaskP )
TASK( tmWorkF )

DONE( tmDispenseWoTimeWebHookSuffixF )
}
    }
        etThread.boxPutF( tin0P , T("///d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T("/idpListen") , (byteT*)&nu , sizeof nu ) ;
        ZE( countT , nu ) ;

        }
            }
                etThread.traceF( tin0P , T("!exception / could not destroy sListen") ) ;
                POOPRqUIET
            {
            if( POOP )
            DELzOMBIE( psDoomed ) ;
            socketC* psDoomed = (socketC*)pb_sListen ;
            SCOOPS
        {
        IFsCRATCHoK

        }
            DEL( pso ) ;
            }
                break ;
                }
                    ++ s ; ether.osSleepF( tin0P , TOCK >> 0 ) ;
                    etThread.traceF( tin0P , T("wrote [tWoTimePassword]:    ")+tWoTimePasswordP ) ;

                    }
                        }
                            break ;
                            etThread.traceF( tin0P , T("could not write to client so closing the connection") ) ;
                            POOPRqUIET
                        {
                        if( POOP )
                        pso->writeF( tin0P , sOut ) ;
                        SCOOPS
                    {
                    IFsCRATCHoK

                    grab_tWoTimePasswordP.ungrabF( tin0P ) ;
                    sOut << (strokeS*)tWoTimePasswordP ;
                    grab_tWoTimePasswordP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                    soulC sOut( tin0P , etThread , TAG( TAGiDnULL ) ) ;
                {
                while( !ether )
            {
            if( pso && nnPeer == nnHe )
            etThread.traceF( tin0P , T("client accepted") ) ;

            }
                }
                    break ;
                    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                    etThread.traceF( tin0P , T("!exception / could not accept a client connection ; will replace sListen and retry") ) ;
                    POOPRqUIET
                {
                if( POOP )
                sListen.acceptF( tin0P , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
                SCOOPS
            {
            IFsCRATCHoK
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            ZE( socketC* , pso ) ;
        {
        while( !ether )

        }
            continue ;
            DELzOMBIE( psDoomed ) ;
            socketC* psDoomed = (socketC*)pb_sListen ;
            ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
        {
        if( bFail )

        }
            }
                bFail = 1 ;
                etThread.traceF( tin0P , T("!exception / could not listen ; will retry") ) ;
                POOPRqUIET
            {
            if( POOP )
            sListen.listenF( tin0P ) ;
            SCOOPS
        {
        IFsCRATCHoK

        }
            continue ;

            }
                }
                    etThread.traceF( tin0P , T("!exception / could not destroy sListen") ) ;
                    POOPRqUIET
                {
                if( POOP )
                DELzOMBIE( psDoomed ) ;
                socketC* psDoomed = (socketC*)pb_sListen ;
                SCOOPS
            {
            IFsCRATCHoK

            ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
        {
        if( bFail )

        }
            etThread.boxPutF( tin0P , T("///d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T("/idpListen") , (byteT*)&idpListen , sizeof idpListen ) ;

            }
                }
                    bFail = 1 ;
                    etThread.traceF( tin0P , T("!exception / could not bind to port ifcIDpORT_DNSwEBhOOKsUFFIX ; will retry") ) ;
                    POOPRqUIET
                {
                else
                if( !POOP ) /*;*/etThread.traceF( tin0P , T("[idpListen]:    ")+TF2(idpListen,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                idpListen = sListen.bindF( tin0P ) ;
                SCOOPS
            {
            IFsCRATCHoK
            ZE( countT , idpListen ) ;
        {

        }
            continue ;

            }
                }
                    etThread.traceF( tin0P , T("!exception / could not destroy sListen") ) ;
                    POOPRqUIET
                {
                if( POOP )
                DELzOMBIE( psDoomed ) ;
                socketC* psDoomed = (socketC*)pb_sListen ;
                SCOOPS
            {
            IFsCRATCHoK

            ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
        {
        if( bFail )
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        }
            }
                bFail = 1 ;
                etThread.traceF( tin0P , T("!exception / could not construct sListen ; will retry") ) ;
                POOPRqUIET
            {
            if( POOP )
            new( 0 , tin0P , pb_sListen , sizeof pb_sListen ) socketC( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_DOnOTrEGISTERtIMEoUT ) ;
            SCOOPS
        {
        IFsCRATCHoK
        ZE( boolT , bFail ) ;
        socketC& sListen = *(socketC*)pb_sListen ;
        byteT pb_sListen[ sizeof( socketC ) ] ;
    {
    while( !ether )

    nicNameC nnHe = etThread.sockNicNameF( tin0P , T("10.0.3.1") ) ;
    nicNameC nnMe = etThread.sockNicNameF( tin0P , T("10.0.2.1") ) ;

    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE ) ;

    grabC& grab_tWoTimePasswordP = *(grabC*)pTaskP->c2 ;
    textC& tWoTimePasswordP      = *(textC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmDispenseWoTimeWebHookSuffixF )

DONE( tmUpdateNnHostsF )
}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;

        }
            }
                etRock.traceF( tin0P , T("!exception / could not write batch file [tLong]:    ")+tLong ) ;
                POOPRqUIET
            {
            else
            if( !POOP ) /*;*/etRock.traceF( tin0P , T("wrote batch file aok [tLong]:    ")+tLong ) ;
            ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , tBatFileImage , tBatFileImage.csF( tin0P ) ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        TN( tBatFileImage , "" ) ; tBatFileImage = T("@echo off\r\n")+tBefore2+tNnHostWeb+tAfter2+T("\r\n") ;
        tLong = T("////web1/d/ideafarm.home.101/controls/drop.executables/new.ipv6.netsh.from.dns.")+TfORsTRING(++idFileOut)+T(".bat" ) ;
        //etThread.traceF( tin0P , T("new  [nnHostWebLag0]:    ")+tNnHostWeb ) ;
        TN( tNnHostWeb , "" ) ; tNnHostWeb = T(nnHostWebLag0P) ;

                                                           nnHostWebLag0P = nnHostWebLathP ;
                                          nnHostWebLag1P = nnHostWebLag0P ;
                         nnHostWebLag2P = nnHostWebLag1P ;
        nnHostWebLag3P = nnHostWebLag2P ;

        ( *(count04T*)&nnHostWebLathP ) ++ ;

        }
            }
                }
                    etRock.traceF( tin0P , T("!exception / could not write batch file [tLong]:    ")+tLong ) ;
                    POOPRqUIET
                {
                else
                if( !POOP ) /*;*/etRock.traceF( tin0P , T("wrote batch file aok [tLong]:    ")+tLong ) ;
                ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , tBatFileImage , tBatFileImage.csF( tin0P ) ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK
            TN( tBatFileImage , "" ) ; tBatFileImage = T("@echo off\r\n")+tBefore1+tNnHostWeb+tAfter1+T("\r\n") ;
            tLong = T("////web1/d/ideafarm.home.101/controls/drop.executables/new.ipv6.netsh.from.dns.")+TfORsTRING(++idFileOut)+T(".bat" ) ;

            //etThread.traceF( tin0P , T("doomed [nnHostWebLag3]:    ")+tNnHostWeb ) ;
            TN( tNnHostWeb , "" ) ; tNnHostWeb = T(nnHostWebLag3P) ;
        {
        if( ~nnHostWebLag3P )
        TN( tLong , "" ) ; 
    {
    while( !ether )
    ZE( countT , idFileOut ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    TN( tAfter2  , "/64\"" ) ;
    TN( tAfter1  , "\"" ) ;
    TN( tBefore2 , "netsh interface ipv6 add    address interface=\"outer\" address=\"" ) ;

    ) ;

        "netsh interface ipv6 delete address interface=\"outer\" address=\""
        "netsh interface ipv6 delete address interface=\"outer\" address=\"2001:19f0:0:7077:5400:5ff:fe59:278d\"\r\n"            //U:: PUT THIS INTO A SETTING

    TN( tBefore1 ,

    //
    // ADD    THE YOUNGEST ADDRESS (LAG 0)
    // SET    THE YOUNGEST ADDRESS (LAG 0)
    // SHIFT  THE DATA TO LAG
    // DELETE THE OLDEST   ADDRESS (LAG 3)
    //
    // RECIPE

    nicNameC& nnHostWebLag3P = *(nicNameC*)pTaskP->c5 ;
    nicNameC& nnHostWebLag2P = *(nicNameC*)pTaskP->c4 ;
    nicNameC& nnHostWebLag1P = *(nicNameC*)pTaskP->c3 ;
    nicNameC& nnHostWebLag0P = *(nicNameC*)pTaskP->c2 ;

    nicNameC& nnHostWebLathP = *(nicNameC*)pTaskP->c1 ;     // WILL ALWAYS BE THE SAME AS nnHostWebLag0P ; IS USED TO MAKE THE CODE EASIER TO UNDERSTAND

    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
TASK( tmUpdateNnHostsF )

}
    }
        stsRepliesP << ps ;

        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // cSerial
        *ps << (countT)0 ; // cSerial
        *ps << psttEmailP ;
        *ps << psttNsP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_SOA ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_SOA_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttNsP , const strokeS* const psttEmailP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_NS ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_NS_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;
        *ps << (countT)0 ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_MX ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_MX_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_AAAA ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_AAAA_F [nn,name]:    ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_AAAA_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_A ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_A_F [nn,name]:    ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , etherP , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
    _IO_
{
voidT rec_A_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )

DONE( tmFreshSettingsF )
}
    }
        }
            }
                sgnSettingsReadyP.giveF( tin0P , ifcIDmODEsIGNgIVE_ON ) ;       //U::ifcIDmODEsIGNgIVE_ON IS A WORKAROUND TO AN APPARENT RACE CONDITION IN WHICH I HANG TRYING FUTILELY TO grabF()
                bWoth = 0 ;
                _IO_
            {
            if( bWoth )

            }
                __NZ( !mySettingsP ) ;

                }
                    if( ~mySettingsP ) break ;

                    mySettingsP.grabMe.ungrabF( tin0P ) ;
                    /**/etThread.traceF( tin0P , T(!mySettingsP?"the new settings are incomplete":"the new settings are aok")+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    mySettingsP.freshenF( tin0P ) ;
                    /**/etThread.traceF( tin0P , T(!mySettingsP?"the stale settings are incomplete":"the stale settings are aok")+tb4+TF2(++idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    mySettingsP.grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                    ++ s ; etThread.osSleepF( tin0P , TOCK << 2 ) ; // TIME FOR PISS TO FINISH UPDATING SETTINGS
                {
                while( !POOP )
                ZE( countT , idTry ) ;
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                /**/etThread.traceF( tin0P , T("the timestamp of the settings files has changed ; napping and then calling freshenF") ) ;
                timeWrittenLath = timeWritten ;
                _IO_
            {
            if( timeWrittenLath.time1 != timeWritten.time1 || timeWrittenLath.time2 != timeWritten.time2 )

            }
                }
                    }
                        }
                            continue ;
                            /**/etThread.traceF( tin0P , T("!exception / could not get file time [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongFile ) ;
                            POOPRqUIET
                            countT rc = POOP ;
                        {
                        else
                        }
                            break ;
                            //etThread.traceF( tin0P , T(" [timeWritten]:    ")+TT(timeWritten.time1,timeWritten.time2) ) ;
                        {
                        if( !POOP )

                        thirdC::getFileTimeIF( tin0P , fir , &timeWritten , 0 , 0 ) ;
                    {
                    else
                    }
                        continue ;
                        /**/etThread.traceF( tin0P , T("!exception / could not open settings file to get file time [rc,tLong]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongFile ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )

                    fileC fir( tin0P , (strokeS*)tLongFile , ifcOPENaCCESS_R , ifcOPENsHARE_WR , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;

                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                _IO_
            {
            while( !ether )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            timeS timeWritten ;
            _IO_
        {
        if( bWoth || etThread.etherC::diskWaitDirF( tin0P , hWait , ether , tLongPath , flWAITdIR_ATTRIBUTE | flWAITdIR_SIZE | flWAITdIR_WRITE ) )
        _IO_
    {
    while( !ether && !POOP )
    timeS timeWrittenLath ;
    handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    TN( tb4 , "    " ) ;
    boolT bWoth = 1 ;

    TN( tLongFile , "" ) ; tLongFile = tLongPath + T("kv.settings.ipdos.jotC.data.booksC.1.book.00000001.00000001.bookC") ;

    }
        tLongPath = T(ifFile) ;
        ifFileNameC ifFile( tin0P , etThread , postPath ) ;

        __Z( *postPath ) ;
        thirdC::postPathStateSpaceIF( tin0P , postPath , sizeof postPath , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
        osTextT postPath[ TUCK << 1 ] ;
        _IO_
    {
    TN( tLongPath , "" ) ;

    signC&       sgnSettingsReadyP =       *(signC*)pTaskP->c2 ;
    mySettingsS& mySettingsP       = *(mySettingsS*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmFreshSettingsF )

}
    THREADmODE1rESTORE
    grabMe.ungrabF( tin0P ) ;

    }
        }
            else                                                                break ;
            if( etherMe.strCompareF( tin0P , *pptListedDomain[ offt ] , tnu ) ) cListedDomain ++ ;
        {
        for( countT offt = 0 ; offt < sizeof pptListedDomain / sizeof pptListedDomain[ 0 ] ; offt ++ )
        cListedDomain = 0 ;
        TN( tnu , ".not.used.ideafarm.com" ) ;                                                          //P:PERSONALITY: I IGNORE ALL ELEMENTS NOT BEFORE THE WO'TH ELEMENT THAT CONTAINS THE "NOT USED" VALUE ; THIS IS FOR SPEED
        _IO_
    {

    }
        /**/etRock.traceF( tin0P , T("allowed (Stripe) [subnet]:    ")+T(pnnSubnetAllowedStripe[offn]) ) ;
    {
    for( countT offn = 0 ; offn < cnnSubnetAllowedStripe ; offn ++ )

    }
        }
            while( ~hWalk ) ;
            }
                pnnSubnetAllowedStripe[ offo ++ ] = nnSubnet ;
                nicNameC& nnSubnet = (nicNameC&)stNnSubnet.downF( tin0P , hWalk ) ;
            {
            do
            handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , offo ) ;
            _IO_
        {
        if( pnnSubnetAllowedStripe )
        etherMe.newF( tin0P , LF , pnnSubnetAllowedStripe , cnnSubnetAllowedStripe ) ; ___( pnnSubnetAllowedStripe ) ;
        cnnSubnetAllowedStripe = stNnSubnet ;

        }
            etherMe.delF( tin0P , pstt1Nn ) ;
            }
                stNnSubnet.sinkF( tin0P , countTC() , nnSubnet , flSTACKsINK_UNIQUE ) ;

                ;
                    : nnIPv46( 0x40 )
                    ? nnIPv46( 0x18 )
                nicNameC nnSubnet = nnIPv46.isIPv4F()
                nicNameC nnIPv46  = etherMe.sockNicNameF( tin0P , psttc1 ) ;

                /**/etRock.traceF( tin0P , psttc1 ) ;
                _IO_
            {
            FORsTRINGSiN1( pstt1Nn )

            countT cNn = etherMe.strWordsF( tin0P , pstt1Nn , tNnTrusted  , sttq , T(" ,") ) ; ___( pstt1Nn ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            ZE( strokeS* , pstt1Nn ) ;
            _IO_
        {
        stackC stNnSubnet( tin0P , etherMe , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_nicNameC ) ;
        _IO_
    {

    zapF( tin0P ) ;

    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed8]:    \"")+tDomainRootAllowed8+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed7]:    \"")+tDomainRootAllowed7+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed6]:    \"")+tDomainRootAllowed6+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed5]:    \"")+tDomainRootAllowed5+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed4]:    \"")+tDomainRootAllowed4+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed3]:    \"")+tDomainRootAllowed3+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed2]:    \"")+tDomainRootAllowed2+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed1]:    \"")+tDomainRootAllowed1+T("\"") ) ;

    /**/etRock.traceF( tin0P , T("settings [tIpWebHook1,tIpWebHook2,tDomainLeafWebHooksNet,tDomainLeafWebHook1Net]:    \"")+tIpWebHook1+T("\"    \"")+tIpWebHook2+T("\"    \"")+tDomainLeafWebHooksNet+T("\"    \"")+tDomainLeafWebHook1Net ) ;

    /**/etRock.traceF( tin0P , T("[tNnTrusted]:    ")+tNnTrusted ) ;
    }
        etherMe.delF( tin0P , psttEat ) ;
        tNnTrusted = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.nn.trusted")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed8 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.8")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed7 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.7")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed6 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.6")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed5 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.5")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed4 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.4")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed3 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.3")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed2 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.2")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tDomainRootAllowed1 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.1")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tIpWebHook2 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh2")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tIpWebHook1 = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1")  ) ; ___( psttEat ) ;
        _IO_
    {

    //}
    //    etherMe.delF( tin0P , pstt1w ) ;
    //    }
    //        }
    //            break ;
    //            tIpWebHook1 = T(psttc1) ;
    //        {
    //        else if( bArmed )
    //        if( !etherMe.strCompareF( tin0P , tStatic , psttc1 ) ) bArmed = 1 ;
    //    {
    //    FORsTRINGSiN1( pstt1w )
    //    ZE( boolT , bArmed ) ;
    //    etherMe.strWordsF( tin0P , pstt1w , tNetshCommandIpv4 , sttq ) ; ___( pstt1w ) ;
    //    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
    //    TN( tStatic , "static" ) ;
    //    ZE( strokeS* , pstt1w ) ;
    //
    //    // {kv: dns.wh1.netsh.command.ipv4.1 "netsh interface ip set address "outer" static 1.2.3.4 255.255.254.0 1.2.3.1"     }
    //
    //    _IO_
    //{
    //20250530@1618: NOW THAT dhcp IS USED, tIpWebHook1 MUST BE INCLUDED AS A SETTING RATHER THAN EXTRACTED BY PARSING ANOTHER SETTING dns.wh1.netsh.command.ipv4.1

    }
        etherMe.delF( tin0P , psttEat ) ;
        }
            etherMe.delF( tin0P , psttNet ) ;
            tDomainLeafWebHook1Net = T(psttNet) ;
            etherMe.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
            _IO_
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.wh1")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        }
            etherMe.delF( tin0P , psttNet ) ;
            tDomainLeafWebHooksNet = T(psttNet) ;
            etherMe.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
            _IO_
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.webhooks")  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        }
            }
                }
                    /**/etRock.traceF( tin0P , T("!exception / could not write batch file [tLong]:    ")+tLong ) ;
                    POOPRqUIET
                {
                else
                if( !POOP ) /*;*/etRock.traceF( tin0P , T("wrote batch file aok [tLong]:    ")+tLong ) ;
                ((tin1S&)tin0P).pEtScratch->boxPutF( tin0P , tLong , tBatFileImage , tBatFileImage.csF( tin0P ) ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK

            TN( tLong , "" ) ; tLong = T("////wh1/d/ideafarm.home.101/controls/drop.executables/new.ipv4.netsh.from.dns.")+TfORsTRING(idFreshen)+T(".bat" ) ;
            TN( tBatFileImage , "" ) ; tBatFileImage = T("@echo off\r\n")+tNetshCommandIpv4+T("\r\n") ;

            tNetshCommandIpv4 = T(psttEat) ;
            etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.")+tNetshCommandIpv4SettingKey  ) ; ___( psttEat ) ;
        _IO_
    {

    }
        etherMe.delF( tin0P , psttEat ) ;
        tNetshCommandIpv4SettingKey = T(psttEat) ;
        if( psttEat ) etherMe.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etherMe.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1.netsh.command.ipv4.settingkey")  ) ; ___( psttEat ) ;
        _IO_
    {

    grabMe.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

    countT idFreshen = 1 + incv02AM( idFreshenLath ) ;
    static countT idFreshenLath ;

    TN( tDash   , "-" ) ;
    etherC& etRock = etherC::etRockIF( tin0P ) ;
    _IO_
{
voidT mySettingsS::freshenF( tin0S& tin0P )

}
    cnnSubnetAllowedStripe = 0 ;

    }
        etherMe.delF( tin0P , pnnSubnetAllowedStripe ) ;
        }
            DELzOMBIE( pDoomed ) ;
            nicNameC* pDoomed = pnnSubnetAllowedStripe + offn ;
        {
        for( countT offn = 0 ; offn < cnnSubnetAllowedStripe ; offn ++ )
    {
    if( pnnSubnetAllowedStripe )
    _IO_
{
voidT mySettingsS::zapF( tin0S& tin0P )

}
    return bMissing ;

    ) ;
        !tDomainRootAllowed8.csF( tin0P )
        ||
        !tDomainRootAllowed7.csF( tin0P )
        ||
        !tDomainRootAllowed6.csF( tin0P )
        ||
        !tDomainRootAllowed5.csF( tin0P )
        ||
        !tDomainRootAllowed4.csF( tin0P )
        ||
        !tDomainRootAllowed3.csF( tin0P )
        ||
        !tDomainRootAllowed2.csF( tin0P )
        ||
        !tDomainRootAllowed1.csF( tin0P )
        ||
        !tDomainLeafWebHook1Net.csF( tin0P )
        ||
        !tDomainLeafWebHooksNet.csF( tin0P )
        ||
        !tIpWebHook2.csF( tin0P )
        ||
        !tIpWebHook1.csF( tin0P )
        ||
        !tNetshCommandIpv4.csF( tin0P )
        ||
        !tNetshCommandIpv4SettingKey.csF( tin0P )
    (
    boolT bMissing =
    TINSL
{
boolT mySettingsS::operator !( voidT )


}
    *(textC**)&pptListedDomain[ 7 ] = &tDomainRootAllowed8 ;
    *(textC**)&pptListedDomain[ 6 ] = &tDomainRootAllowed7 ;
    *(textC**)&pptListedDomain[ 5 ] = &tDomainRootAllowed6 ;
    *(textC**)&pptListedDomain[ 4 ] = &tDomainRootAllowed5 ;
    *(textC**)&pptListedDomain[ 3 ] = &tDomainRootAllowed4 ;
    *(textC**)&pptListedDomain[ 2 ] = &tDomainRootAllowed3 ;
    *(textC**)&pptListedDomain[ 1 ] = &tDomainRootAllowed2 ;
    *(textC**)&pptListedDomain[ 0 ] = &tDomainRootAllowed1 ;
{
cListedDomain(               0                                                                  )
cnnSubnetAllowedStripe(      0                                                                  ) ,
pnnSubnetAllowedStripe(      0                                                                  ) ,
tNnTrusted(                  tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed8(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed7(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed6(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed5(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed4(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed3(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed2(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainRootAllowed1(         tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tIpWebHook2(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tIpWebHook1(                 tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainLeafWebHook1Net(      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tDomainLeafWebHooksNet(      tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tNetshCommandIpv4(           tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
tNetshCommandIpv4SettingKey( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , ""                       ) ,
grabMe(                      tin0P , TAG( TAGiDnULL ) , flGRABc_SHARElAYER | flGRABc_NOTjEALOUS ) ,
etherMe(                     etherP                                                             ) ,
mySettingsS::mySettingsS( tin0S& tin0P , etherC& etherP ) :

}
    zapF( tin0P ) ;
    TINSL
{
mySettingsS::~mySettingsS( voidT )

;
}
    inline boolT operator ~( voidT ) { return !!*this ; }
    boolT operator !( voidT                         ) ;
    voidT freshenF(   tin0S& tin0P                  ) ;
    mySettingsS(      tin0S& tin0P , etherC& etherP ) ;
    ~mySettingsS(     voidT                         ) ;

    countT       cnnSubnetAllowedStripe      ;
    nicNameC*    pnnSubnetAllowedStripe      ;

    countT       cListedDomain               ;
    textC* const pptListedDomain[ 8 ]        ;

    textC        tNnTrusted                  ;
    textC        tIpWebHook2                 ;
    textC        tIpWebHook1                 ;
    textC        tDomainLeafWebHook1Net      ;
    textC        tDomainLeafWebHooksNet      ;

    textC        tNetshCommandIpv4           ;

    grabC        grabMe                      ;

    public :

    voidT zapF( tin0S& tin0P ) ;

    textC        tDomainRootAllowed8         ;
    textC        tDomainRootAllowed7         ;
    textC        tDomainRootAllowed6         ;
    textC        tDomainRootAllowed5         ;
    textC        tDomainRootAllowed4         ;
    textC        tDomainRootAllowed3         ;
    textC        tDomainRootAllowed2         ;
    textC        tDomainRootAllowed1         ;

    textC        tNetshCommandIpv4SettingKey ;

    etherC&      etherMe                     ;

    private :
{
struct mySettingsS

//  
// CERTBOT CANNOT BE USED TO RENEW A CERTIFICATE FOR THE LEAF DOMAIN, BECAUSE I DO NOT HAVE CERTBOT'S SERVERS ON MY ALLOWLIST
// I ASSUME THAT A "SHIELDS DOWN" FUNCTION IS NOT NEEDED BECAUSE THE DOMAIN NAME LEAF IS CHANGED FREQUENTLY
//  
//P:PERSONALITY: I KEEP IP ADDRESSES CONFIDENTIAL, BY TREATING THE REQUESTED DOMAIN NAME LEAF AS A PASSWORD, AND BY APPLYING AN ALLOWLIST TO nnPeer

// OBSOLETES 895_ (LIKE 895_ BUT 895_ KEPT AS A SNAPSHOT OF CODE THAT WORKS)

/*1*/WAKEhIDE( "ifcIDaDAM_DNS" )/*1*/

/**/
*/
 i simply map names (many to 1 and 1 to many) into ip addresses and tell the client to not cache
i do not use the canonical name concept
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

