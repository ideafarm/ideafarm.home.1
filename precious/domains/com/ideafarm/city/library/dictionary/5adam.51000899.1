
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        etThread.delF( tin0P , pnnSubnetAllowedStripe ) ;
        }
            DELzOMBIE( pDoomed ) ;
            nicNameC* pDoomed = pnnSubnetAllowedStripe + offn ;
        {
        for( countT offn = 0 ; offn < cnnSubnetAllowedStripe ; offn ++ )

        }
            }
                *((tin1S&)tin0P).pEtScratch = 0 ; //U: WORKAROUND TO SEE WHETHER PREVENTS BLOCK IN bindF
                }
                    ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbq ) ;
                    }
                        }
                            ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbr ) ;
                            sockd.writeF( tin0P , idp , nnPeer , pbr , cbr ) ;

                            ((tin1S&)tin0P).pEtScratch->dnsReplyF( tin0P , pbr , cbr , pbq , stsReplies , 1 , idError ) ;
                            ZE( countT , cbr ) ;
                            ZE( byteT* , pbr ) ;

                            else                          /*;*/etRock.traceF( tin0P , T("replying [error]:    ")+TF2(idError,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            if( postError && *postError ) /*;*/etRock.traceF( tin0P , T("replying [error]:    ")+T(postError)                                          ) ;
                            const osTextT* postError = processGlobal4S::_processGlobal4I_IF().mapIdErrorDns( idError ) ;

                            }
                                if( !stsReplies ) idError = ifcIDeRRORdNS_NAMEnOTdEFINED ;

                                }
                                    DEL( ps ) ;
                                    }
                                        }
                                            //}
                                            //    break ;
                                            //
                                            //    if( ~nnOut ) rec_AAAA_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut ) ;
                                            //
                                            //    else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHook1    ) ) nnOut = nnWebHook1 ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                            //         if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHooks    ) ) nnOut = nnWebHook1 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...
                                            //
                                            //    nicNameC nnOut ;
                                            //{
                                            //case ifcIDtYPEdNSqUERY_AAAA :
                                            }
                                                break ;

                                                if( ~nnOut ) rec_A_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut ) ;

                                                }
                                                    else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHook1    ) ) nnOut = nnWebHook1 ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                                         if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHooks    ) ) nnOut = nnWebHook1 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...
                                                {
                                                else
                                                }
                                                         if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHooks    ) ) nnOut = nnWebHook2 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...
                                                {
                                                if( bDivert )

                                                nicNameC nnOut ;
                                            {
                                            case ifcIDtYPEdNSqUERY_A :
                                            }
                                                break ;
                                            {
                                            case ifcIDtYPEdNSqUERY_CAA :
                                        {
                                        if( idClass == 1 ) switch( idType )

                                        *ps >> idClass ;
                                        ZE( countT , idClass ) ;

                                        *ps >> idType ;
                                        ZE( countT , idType ) ;

                                        etThread.delF( tin0P , psttw ) ;
                                        TN( tDomainNet , psttw ) ;
                                        }
                                            /**/etRock.traceF( tin0P , T("[domainNet,peer]:      \"")+T(psttw)+T("\"    \"")+tDomainPeer+T("\"") ) ;

                                            etThread.strMakeF( tin0P , LF , psttw , tDomainNet ) ; ___( psttw ) ;
                                            TN( tDomainNet , "" ) ; tDomainNet = T(psttNet)+T(".hidden.ideafarm.com") ;

                                            etThread.delF( tin0P , psttw ) ;
                                            etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttw , 0 , 0 ) ;
                                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                            countT idf = 1 ;
                                            ZE( strokeS* , psttNet ) ;
                                        {
                                        if( psttw && etThread.strIdF( tin0P , tDash , psttw , 1 ) )

                                        /**/etRock.traceF( tin0P , T("[domainGross,peer]:    \"")+tDomainGross+T("\"    \"")+tDomainPeer+T("\"") ) ;
                                        TN( tDomainGross , psttw ) ;
                                        if( psttw ) ((tin1S&)tin0P).pEtScratch->strConvertToLowerCaseF( tin0P , psttw ) ; ___( psttw ) ;
                                        *ps >> psttw ;
                                        ZE( strokeS* , psttw ) ;
                                    {
                                    if( ps )
                                    stsQueries >> ps ;
                                    ZE( soulC* , ps ) ;
                                {
                                while( stsQueries )
                            {
                            else
                            }
                                idError = ifcIDeRRORdNS_CANNOTpARSEqUERY ;
                                /**/etRock.traceF( tin0P , T("!exception / dnsParseF failed") ) ;
                                POOPRqUIET ;
                            {
                            if( POOP )

                            }
                                ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbNU ) ;
                                ((tin1S&)tin0P).pEtScratch->dnsParseF( tin0P , pbNU , countTC() , stsQueries , stsRepliesNU , pbq , cbq ) ;
                                ZE( byteT* , pbNU ) ;

                                stsRepliesNU.purgeF( tin0P ) ;
                                stsQueries.purgeF( tin0P ) ;
                            {

                            ++ idClient ;

                            /**/etRock.traceF( tin0P , TT(timeN1,timeN2)+tb4+tTimeOld+tb4+T(nnPeer)+(bDivert?tSayDiverting:tSayGranting)+tDomainPeer ) ;

                            }
                                etThread.delF( tin0P , psttSay ) ;
                                tTimeOld = T(psttSay) ;
                                etThread.strFromOldTimeF( tin0P , psttSay , mm , hh , d , m , y , dow , 0 ) ; ___( psttSay ) ;
                                ZE( strokeS* , psttSay ) ;
                            {
                            TN( tTimeOld , "" ) ;

                            etThread.osTimeToOldTimeF( tin0P , ms , ss , mm , hh , d , m , y , dow , timeN1 , timeN2 , flOStIMEtOoLDtIME_null ) ;
                            ZE(  countT , dow ) ;
                            ZE( sCountT , y   ) ;
                            ZE(  countT , m   ) ;
                            ZE(  countT , d   ) ;
                            ZE(  countT , hh  ) ;
                            ZE(  countT , mm  ) ;
                            ZE(  countT , ss  ) ;
                            ZE(  countT , ms  ) ;

                            etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                            ZE( sCountT , timeN2 ) ;
                            ZE( countT  , timeN1 ) ;

                            countT idError = ifcIDeRRORdNS_AOK ;
                        {
                        if( pbq && cbq )
                    {
                    //if( etThread.strIdF( tin0P , T(".letsencrypt.org") , tDomainPeer ) )    //TO FIND A BUG (PROD: COMMENT OUT THIS if() CONDITION SO THAT THE BLOCK IS ALWAYS EXECUTED

                    }
                        }
                            /**/etRock.traceF( tin0P , tSayPrefix+T(nnPeer)+tSayUnknownDomain+tb4+tDomainPeer ) ;
                            bDivert = 1 ;
                        {
                        if( !bStripeWebHookNotifier && !bListedDomain )         //P:PERSONALITY: TRUSTED PEERS ARE DIRECTED TO wh1 ; UNTRUSTED PEERS ARE DIRECTED TO wh2

                        }
                            }
                                }
                                    }
                                        break ;
                                        bStripeWebHookNotifier = 1 ;
                                    {
                                    if( pnnSubnetAllowedStripe[ offn ] == nnPeer( 0x40 ) )
                                {
                                else
                                }
                                    }
                                        break ;
                                        bStripeWebHookNotifier = 1 ;
                                    {
                                    if( pnnSubnetAllowedStripe[ offn ] == nnPeer( 0x18 ) )
                                {
                                if( nnPeer.isIPv4F() )
                            {
                            for( countT offn = 0 ; offn < cnnSubnetAllowedStripe ; offn ++ )
                        {
                        if( !bListedDomain )
                        ZE( boolT , bStripeWebHookNotifier ) ;

                        }
                            ether.delF( tin0P , psttPeer ) ;
                            }
                                }
                                    }
                                        break ;
                                        bListedDomain ++ ;
                                    {
                                    if( idHit && idHit == 1 + psttPeer->idAdam - pptListedDomain[ offt ]->csF( tin0P ) )
                                    countT idHit  = etThread.strIdF( tin0P , *pptListedDomain[ offt ] , psttPeer , 1 ) ;
                                {
                                for( countT offt = 0 ; offt < cListedDomains ; offt ++ )

                                //etRock.traceF( tin0P , T("[tPeer]:    ")+T(psttPeer) ) ;
                                tDomainPeer = T(psttPeer) ;
                            {
                            else
                            if( !psttPeer ) /*;*/etRock.traceF( tin0P , T("!exception / reverse DNS lookup failed") ) ;
                            ether.sockPsttHostF( tin0P , psttPeer , nnPeer ) ; ___( psttPeer ) ;
                            ZE( strokeS* , psttPeer ) ;
                        {
                        ZE( boolT , bListedDomain ) ;
                    {
                    TN( tDomainPeer , "" ) ;
                    ZE( boolT , bDivert ) ;

                    sockd.readF( tin0P , pbq , cbq , idp , nnPeer ) ; ___( pbq ) ;
                    nicNameC nnPeer ;
                    ZE( countT , idp ) ;
                    ZE( countT , cbq ) ;
                    ZE( byteT* , pbq ) ;
                {
                while( !POOP && !ether && !etThread && !*((tin1S&)tin0P).pEtScratch )
                TN( tSayGranting  , "    granting information    " ) ;
                TN( tSayDiverting , "    diverting information    " ) ;
                TN( tSayUnknownDomain , "    !exception / unknown peer domain" ) ;
                TN( tSayPrefix  , "[nnPeer]:    " ) ;

                grabSettings.ungrabF( tin0P ) ;

                nicNameC nnWebHook2       = etThread.sockNicNameF( tin0P , mySettings.tIpWebHook2 ) ;
                nicNameC nnWebHook1       = etThread.sockNicNameF( tin0P , mySettings.tIpWebHook1 ) ;

                TN( tb4    , "    " ) ;
                TN( tWebHook1 , "" ) ; tWebHook1 = mySettings.tDomainLeafWebHook1Net+T(".hidden.ideafarm.com") ;
                TN( tWebHooks , "" ) ; tWebHooks = mySettings.tDomainLeafWebHooksNet+T(".hidden.ideafarm.com") ;

                grabSettings.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                sockd.bindF( tin0P , ifcPORToLD2_DNS ) ;
                socketC sockd( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
                stsReplies.purgeF( tin0P ) ;
                stsQueries.purgeF( tin0P ) ;
                *((tin1S&)tin0P).pEtScratch = 0 ;
            {
            while( !POOP && !ether && !etThread )
            stackC stsQueries(   tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            stackC stsReplies(   tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            stackC stsRepliesNU( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            ZE( countT , idClient ) ;

            SCOOPS
        {
        IFsCRATCHoK

        }
            }
                else                                                                 break ;
                if( etThread.strCompareF( tin0P , *pptListedDomain[ offt ] , tnu ) ) cListedDomains ++ ;
            {
            for( countT offt = 0 ; offt < sizeof pptListedDomain / sizeof pptListedDomain[ 0 ] ; offt ++ )
            TN( tnu , ".not.used.ideafarm.com" ) ;
        {
        ZE( countT , cListedDomains ) ;                             //P:PERSONALITY: I IGNORE ALL ELEMENTS NOT BEFORE THE WO'TH ELEMENT THAT CONTAINS THE "NOT USED" VALUE ; THIS IS FOR SPEED

        } ;
            &tListedDomain8 ,
            &tListedDomain7 ,
            &tListedDomain6 ,
            &tListedDomain5 ,
            &tListedDomain4 ,
            &tListedDomain3 ,
            &tListedDomain2 ,
            &tListedDomain1 ,
        {
        textC* pptListedDomain[] =

        grabSettings.ungrabF( tin0P ) ;
        TN( tListedDomain8 , (strokeS*)mySettings.tDomainRootAllowed8 ) ;
        TN( tListedDomain7 , (strokeS*)mySettings.tDomainRootAllowed7 ) ;
        TN( tListedDomain6 , (strokeS*)mySettings.tDomainRootAllowed6 ) ;
        TN( tListedDomain5 , (strokeS*)mySettings.tDomainRootAllowed5 ) ;
        TN( tListedDomain4 , (strokeS*)mySettings.tDomainRootAllowed4 ) ;
        TN( tListedDomain3 , (strokeS*)mySettings.tDomainRootAllowed3 ) ;
        TN( tListedDomain2 , (strokeS*)mySettings.tDomainRootAllowed2 ) ;
        TN( tListedDomain1 , (strokeS*)mySettings.tDomainRootAllowed1 ) ;
        grabSettings.grabF( tin0P , TAG( TAGiDnULL ) ) ;

        }
            etThread.traceF( tin0P , T("allowed (Stripe) [subnet]:    ")+T(pnnSubnetAllowedStripe[offn]) ) ;
        {
        for( countT offn = 0 ; offn < cnnSubnetAllowedStripe ; offn ++ )

        }
            }
                while( ~hWalk ) ;
                }
                    pnnSubnetAllowedStripe[ offo ++ ] = nnSubnet ;
                    nicNameC& nnSubnet = (nicNameC&)stNnSubnet.downF( tin0P , hWalk ) ;
                {
                do
                handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , offo ) ;
            {
            if( pnnSubnetAllowedStripe )
            etThread.newF( tin0P , LF , pnnSubnetAllowedStripe , cnnSubnetAllowedStripe ) ; ___( pnnSubnetAllowedStripe ) ;
            cnnSubnetAllowedStripe = stNnSubnet ;

            }
                etThread.delF( tin0P , pstt1Nn ) ;
                }
                    stNnSubnet.sinkF( tin0P , countTC() , nnSubnet , flSTACKsINK_UNIQUE ) ;

                    ;
                        : nnIPv46( 0x40 )
                        ? nnIPv46( 0x18 )
                    nicNameC nnSubnet = nnIPv46.isIPv4F()
                    nicNameC nnIPv46  = etThread.sockNicNameF( tin0P , psttc1 ) ;

                    etThread.traceF( tin0P , psttc1 ) ;
                {
                FORsTRINGSiN1( pstt1Nn )

                grabSettings.ungrabF( tin0P ) ;
                countT cNn = etThread.strWordsF( tin0P , pstt1Nn , mySettings.tNnTrusted  , sttq , T(" ,") ) ; ___( pstt1Nn ) ;
                grabSettings.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , pstt1Nn ) ;
            {
            stackC stNnSubnet( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_nicNameC ) ;
        {
        ZE( countT    , cnnSubnetAllowedStripe ) ;
        ZE( nicNameC* , pnnSubnetAllowedStripe ) ;

        grabSettings.ungrabF( tin0P ) ;
    {
    else
    }
        etRock.traceF( tin0P , T("a required setting is missing") ) ;           //P:PERSONALITY: THIS VERIFICATION IS ONLY DONE NOW ; IT IS NOT DONE WHEN SETTINGS ARE RELOADED BECAUSE THE FILE TIME HAS CHANGED, SO SETTINGS ERRORS THEN WILL JUST CAUSE ME TO FAIL
        grabSettings.ungrabF( tin0P ) ;
    {
    )
        !mySettings.tDomainRootAllowed8.csF( tin0P )
        ||
        !mySettings.tDomainRootAllowed7.csF( tin0P )
        ||
        !mySettings.tDomainRootAllowed6.csF( tin0P )
        ||
        !mySettings.tDomainRootAllowed5.csF( tin0P )
        ||
        !mySettings.tDomainRootAllowed4.csF( tin0P )
        ||
        !mySettings.tDomainRootAllowed3.csF( tin0P )
        ||
        !mySettings.tDomainRootAllowed2.csF( tin0P )
        ||
        !mySettings.tDomainRootAllowed1.csF( tin0P )
        ||
        !mySettings.tDomainLeafWebHook1Net.csF( tin0P )
        ||
        !mySettings.tDomainLeafWebHooksNet.csF( tin0P )
        ||
        !mySettings.tIpWebHook2.csF( tin0P )
        ||
        !mySettings.tIpWebHook1.csF( tin0P )
    (
    if
    grabSettings.grabF( tin0P , TAG( TAGiDnULL ) ) ;

    etherC& etRock = etherC::etRockIF( tin0P ) ;
    TN( tDash , "-" ) ;

    etThread.traceF( tin0P , T("the settings are ready") ) ;
    sgnSettingsReady.waitF( tin0P ) ;

    etThread.osThreadF( TaRG2cBsTACK( tmFreshSettingsF , CBsTACKmIN << 1 ) , (countT)&mySettings , (countT)&sgnSettingsReady , (countT)&grabSettings ) ;

    grabC grabSettings(     tin0P , TAG( TAGiDnULL ) , flGRABc_SHARElAYER | flGRABc_NOTjEALOUS ) ;
    signC sgnSettingsReady( tin0P , TAG( TAGiDnULL ) ) ;
    mySettingsS mySettings( tin0P ) ;

    _IO_
{
if( pTaskP )
TASK( tmWorkF )

}
    }
        stsRepliesP << ps ;

        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // cSerial
        *ps << (countT)0 ; // cSerial
        *ps << psttEmailP ;
        *ps << psttNsP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_SOA ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_SOA_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttNsP , const strokeS* const psttEmailP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_NS ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_NS_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;
        *ps << (countT)0 ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_MX ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_MX_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_AAAA ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_AAAA_F [nn,name]:    ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_AAAA_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_A ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_A_F [nn,name]:    ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_A_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )

DONE( tmFreshSettingsF )
}
    }
        }
            }
                sgnSettingsReadyP.giveF( tin0P , ifcIDmODEsIGNgIVE_ON ) ;       //U::ifcIDmODEsIGNgIVE_ON IS A WORKAROUND TO AN APPARENT RACE CONDITION IN WHICH I HANG TRYING FUTILELY TO grabF()
                bWoth = 0 ;
                _IO_
            {
            if( bWoth )

            }
                THREADmODE1rESTORE
                grabSettingsP.ungrabF( tin0P ) ;

                /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed8]:    \"")+mySettingsP.tDomainRootAllowed8+T("\"") ) ;
                /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed7]:    \"")+mySettingsP.tDomainRootAllowed7+T("\"") ) ;
                /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed6]:    \"")+mySettingsP.tDomainRootAllowed6+T("\"") ) ;
                /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed5]:    \"")+mySettingsP.tDomainRootAllowed5+T("\"") ) ;
                /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed4]:    \"")+mySettingsP.tDomainRootAllowed4+T("\"") ) ;
                /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed3]:    \"")+mySettingsP.tDomainRootAllowed3+T("\"") ) ;
                /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed2]:    \"")+mySettingsP.tDomainRootAllowed2+T("\"") ) ;
                /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed1]:    \"")+mySettingsP.tDomainRootAllowed1+T("\"") ) ;

                /**/etRock.traceF( tin0P , T("settings [tIpWebHook1,tIpWebHook2,tDomainLeafWebHooksNet,tDomainLeafWebHook1Net]:    \"")+mySettingsP.tIpWebHook1+T("\"    \"")+mySettingsP.tIpWebHook2+T("\"    \"")+mySettingsP.tDomainLeafWebHooksNet+T("\"    \"")+mySettingsP.tDomainLeafWebHook1Net ) ;

                etThread.traceF( tin0P , T("[tNnTrusted]:    ")+mySettingsP.tNnTrusted ) ;
                }
                    etThread.delF( tin0P , psttEat ) ;
                    mySettingsP.tNnTrusted = T(psttEat) ;
                    if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.nn.trusted")  ) ; ___( psttEat ) ;
                    _IO_
                {

                }
                    etThread.delF( tin0P , psttEat ) ;
                    mySettingsP.tDomainRootAllowed8 = T(psttEat) ;
                    if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.8")  ) ; ___( psttEat ) ;
                    _IO_
                {

                }
                    etThread.delF( tin0P , psttEat ) ;
                    mySettingsP.tDomainRootAllowed7 = T(psttEat) ;
                    if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.7")  ) ; ___( psttEat ) ;
                    _IO_
                {

                }
                    etThread.delF( tin0P , psttEat ) ;
                    mySettingsP.tDomainRootAllowed6 = T(psttEat) ;
                    if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.6")  ) ; ___( psttEat ) ;
                    _IO_
                {

                }
                    etThread.delF( tin0P , psttEat ) ;
                    mySettingsP.tDomainRootAllowed5 = T(psttEat) ;
                    if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.5")  ) ; ___( psttEat ) ;
                    _IO_
                {

                }
                    etThread.delF( tin0P , psttEat ) ;
                    mySettingsP.tDomainRootAllowed4 = T(psttEat) ;
                    if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.4")  ) ; ___( psttEat ) ;
                    _IO_
                {

                }
                    etThread.delF( tin0P , psttEat ) ;
                    mySettingsP.tDomainRootAllowed3 = T(psttEat) ;
                    if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.3")  ) ; ___( psttEat ) ;
                    _IO_
                {

                }
                    etThread.delF( tin0P , psttEat ) ;
                    mySettingsP.tDomainRootAllowed2 = T(psttEat) ;
                    if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.2")  ) ; ___( psttEat ) ;
                    _IO_
                {

                }
                    etThread.delF( tin0P , psttEat ) ;
                    mySettingsP.tDomainRootAllowed1 = T(psttEat) ;
                    if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.1")  ) ; ___( psttEat ) ;
                    _IO_
                {

                }
                    etThread.delF( tin0P , psttEat ) ;
                    mySettingsP.tIpWebHook2 = T(psttEat) ;
                    if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh2")  ) ; ___( psttEat ) ;
                    _IO_
                {

                }
                    etThread.delF( tin0P , psttEat ) ;
                    mySettingsP.tIpWebHook1 = T(psttEat) ;
                    if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1")  ) ; ___( psttEat ) ;
                    _IO_
                {

                }
                    etThread.delF( tin0P , psttEat ) ;
                    }
                        etThread.delF( tin0P , psttNet ) ;
                        mySettingsP.tDomainLeafWebHook1Net = T(psttNet) ;
                        etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        countT idf = 1 ;
                        ZE( strokeS* , psttNet ) ;

                        etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                        _IO_
                    {
                    if( psttEat )
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.wh1")  ) ; ___( psttEat ) ;
                    _IO_
                {

                }
                    etThread.delF( tin0P , psttEat ) ;
                    }
                        etThread.delF( tin0P , psttNet ) ;
                        mySettingsP.tDomainLeafWebHooksNet = T(psttNet) ;
                        etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                        countT idf = 1 ;
                        ZE( strokeS* , psttNet ) ;

                        etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
                        _IO_
                    {
                    if( psttEat )
                    ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.webhooks")  ) ; ___( psttEat ) ;
                    _IO_
                {
                grabSettingsP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING   )

                timeWrittenLath = timeWritten ;
                _IO_
            {
            if( timeWrittenLath.time1 != timeWritten.time1 || timeWrittenLath.time2 != timeWritten.time2 )

            }
                }
                    }
                        }
                            etThread.traceF( tin0P , T("could not get file time") ) ;
                            POOPRqUIET
                        {
                        else
                        if( !POOP ) etThread.traceF( tin0P , T(" [timeWritten]:    ")+TT(timeWritten.time1,timeWritten.time2) ) ;

                        thirdC::getFileTimeIF( tin0P , fir , &timeWritten , 0 , 0 ) ;
                    {
                    else
                    }
                        etThread.traceF( tin0P , T("could not open settings file to get file time") ) ;
                        POOPRqUIET
                    {
                    if( POOP )

                    fileC fir( tin0P , (strokeS*)tLongFile , ifcOPENaCCESS_R , ifcOPENsHARE_WR , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                _IO_
            {
            timeS timeWritten ;
            _IO_
        {
        if( bWoth || etThread.etherC::diskWaitDirF( tin0P , hWait , ether , tLongPath , flWAITdIR_ATTRIBUTE | flWAITdIR_SIZE | flWAITdIR_WRITE ) )
        _IO_
    {
    while( !ether && !POOP )
    timeS timeWrittenLath ;
    handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    TN( tDash , "-" ) ;
    boolT bWoth = 1 ;

    TN( tLongFile , "" ) ; tLongFile = tLongPath + T("kv.settings.ipdos.jotC.data.booksC.1.book.00000001.00000001.bookC") ;

    }
        tLongPath = T(ifFile) ;
        ifFileNameC ifFile( tin0P , etThread , postPath ) ;

        __Z( *postPath ) ;
        thirdC::postPathStateSpaceIF( tin0P , postPath , sizeof postPath , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;
        osTextT postPath[ TUCK << 1 ] ;
        _IO_
    {
    TN( tLongPath , "" ) ;

    grabC&       grabSettingsP     =       *(grabC*)pTaskP->c3 ;
    signC&       sgnSettingsReadyP =       *(signC*)pTaskP->c2 ;
    mySettingsS& mySettingsP       = *(mySettingsS*)pTaskP->c1 ;
    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmFreshSettingsF )

}
{
tNnTrusted(             tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" )
tDomainRootAllowed8(    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
tDomainRootAllowed7(    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
tDomainRootAllowed6(    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
tDomainRootAllowed5(    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
tDomainRootAllowed4(    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
tDomainRootAllowed3(    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
tDomainRootAllowed2(    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
tDomainRootAllowed1(    tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
tIpWebHook2(            tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
tIpWebHook1(            tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
tDomainLeafWebHook1Net( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
tDomainLeafWebHooksNet( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , "" ) ,
mySettingsS::mySettingsS( tin0S& tin0P ) :

;
}
    mySettingsS( tin0S& tin0P ) ;

    textC tNnTrusted ;
    textC tDomainRootAllowed8 ;
    textC tDomainRootAllowed7 ;
    textC tDomainRootAllowed6 ;
    textC tDomainRootAllowed5 ;
    textC tDomainRootAllowed4 ;
    textC tDomainRootAllowed3 ;
    textC tDomainRootAllowed2 ;
    textC tDomainRootAllowed1 ;
    textC tIpWebHook2 ;
    textC tIpWebHook1 ;
    textC tDomainLeafWebHook1Net ;
    textC tDomainLeafWebHooksNet ;
{
struct mySettingsS

//  
// CERTBOT CANNOT BE USED TO RENEW A CERTIFICATE FOR THE LEAF DOMAIN, BECAUSE I DO NOT HAVE CERTBOT'S SERVERS ON MY ALLOWLIST
// I ASSUME THAT A "SHIELDS DOWN" FUNCTION IS NOT NEEDED BECAUSE THE DOMAIN NAME LEAF IS CHANGED FREQUENTLY
//  
//P:PERSONALITY: I KEEP IP ADDRESSES CONFIDENTIAL, BY TREATING THE REQUESTED DOMAIN NAME LEAF AS A PASSWORD, AND BY APPLYING AN ALLOWLIST TO nnPeer

// OBSOLETES 895_ (LIKE 895_ BUT 895_ KEPT AS A SNAPSHOT OF CODE THAT WORKS)

/*1*/WAKEhIDE( "ifcIDaDAM_DNS" )/*1*/

/**/
*/
 i simply map names (many to 1 and 1 to many) into ip addresses and tell the client to not cache
i do not use the canonical name concept
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

