
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        etThread.delF( tin0P , pnnSubnetAllowedStripe ) ;
        }
            DELzOMBIE( pDoomed ) ;
            nicNameC* pDoomed = pnnSubnetAllowedStripe + offn ;
        {
        for( countT offn = 0 ; offn < cnnSubnetAllowedStripe ; offn ++ )

        }
            }
                *((tin1S&)tin0P).pEtScratch = 0 ; //U: WORKAROUND TO SEE WHETHER PREVENTS BLOCK IN bindF
                }
                    ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbq ) ;
                    }
                        }
                            ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbr ) ;
                            sockd.writeF( tin0P , idp , nnPeer , pbr , cbr ) ;

                            ((tin1S&)tin0P).pEtScratch->dnsReplyF( tin0P , pbr , cbr , pbq , stsReplies , 1 , idError ) ;
                            ZE( countT , cbr ) ;
                            ZE( byteT* , pbr ) ;

                            else                          /*;*/etRock.traceF( tin0P , T("replying [error]:    ")+TF2(idError,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            if( postError && *postError ) /*;*/etRock.traceF( tin0P , T("replying [error]:    ")+T(postError)                                          ) ;
                            const osTextT* postError = processGlobal4S::_processGlobal4I_IF().mapIdErrorDns( idError ) ;

                            }
                                }
                                    if( !stsReplies ) idError = ifcIDeRRORdNS_NAMEnOTdEFINED ;

                                    }
                                        DEL( ps ) ;
                                        }
                                            }
                                                //}
                                                //    break ;
                                                //
                                                //    if( ~nnOut ) rec_AAAA_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut ) ;
                                                //
                                                //    else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHook1    ) ) nnOut = nnWebHook1 ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                                //         if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHooks    ) ) nnOut = nnWebHook1 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...
                                                //
                                                //    nicNameC nnOut ;
                                                //{
                                                //case ifcIDtYPEdNSqUERY_AAAA :
                                                }
                                                    break ;

                                                    if( ~nnOut ) rec_A_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut ) ;

                                                    else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHook1    ) ) nnOut = nnWebHook1 ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                                         if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHooks    ) ) nnOut = nnWebHook1 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...

                                                    nicNameC nnOut ;
                                                {
                                                case ifcIDtYPEdNSqUERY_A :
                                                }
                                                    break ;
                                                {
                                                case ifcIDtYPEdNSqUERY_CAA :
                                            {
                                            if( idClass == 1 ) switch( idType )

                                            *ps >> idClass ;
                                            ZE( countT , idClass ) ;

                                            *ps >> idType ;
                                            ZE( countT , idType ) ;

                                            etThread.delF( tin0P , psttw ) ;
                                            TN( tDomainNet , psttw ) ;
                                            }
                                                /**/etRock.traceF( tin0P , T("[domainNet,peer]:      \"")+T(psttw)+T("\"    \"")+tDomainPeer+T("\"") ) ;

                                                etThread.strMakeF( tin0P , LF , psttw , tDomainNet ) ; ___( psttw ) ;
                                                TN( tDomainNet , "" ) ; tDomainNet = T(psttNet)+T(".hidden.ideafarm.com") ;

                                                etThread.delF( tin0P , psttw ) ;
                                                etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttw , 0 , 0 ) ;
                                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                countT idf = 1 ;
                                                ZE( strokeS* , psttNet ) ;
                                            {
                                            if( psttw )

                                            /**/etRock.traceF( tin0P , T("[domainGross,peer]:    \"")+tDomainGross+T("\"    \"")+tDomainPeer+T("\"") ) ;
                                            TN( tDomainGross , psttw ) ;
                                            if( psttw ) ((tin1S&)tin0P).pEtScratch->strConvertToLowerCaseF( tin0P , psttw ) ; ___( psttw ) ;
                                            *ps >> psttw ;
                                            ZE( strokeS* , psttw ) ;
                                        {
                                        if( ps )
                                        stsQueries >> ps ;
                                        ZE( soulC* , ps ) ;
                                    {
                                    while( stsQueries )
                                {
                                else
                                }
                                    idError = ifcIDeRRORdNS_CANNOTpARSEqUERY ;
                                    /**/etRock.traceF( tin0P , T("!exception / dnsParseF failed") ) ;
                                    POOPRqUIET ;
                                {
                                if( POOP )

                                }
                                    ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbNU ) ;
                                    ((tin1S&)tin0P).pEtScratch->dnsParseF( tin0P , pbNU , countTC() , stsQueries , stsRepliesNU , pbq , cbq ) ;
                                    ZE( byteT* , pbNU ) ;

                                    stsRepliesNU.purgeF( tin0P ) ;
                                    stsQueries.purgeF( tin0P ) ;
                                {

                                ++ idClient ;

                                /**/etRock.traceF(            tin0P , TT(timeN1,timeN2)+tb4+tTimeOld+tb4+T(nnPeer)+tSayGranting+tDomainPeer ) ;
                            {
                            else
                            if( bRefuse ) /*;*/etRock.traceF( tin0P , TT(timeN1,timeN2)+tb4+tTimeOld+tb4+T(nnPeer)+tSayRefusing+tDomainPeer ) ;

                            }
                                etThread.delF( tin0P , psttSay ) ;
                                tTimeOld = T(psttSay) ;
                                etThread.strFromOldTimeF( tin0P , psttSay , mm , hh , d , m , y , dow , 0 ) ; ___( psttSay ) ;
                                ZE( strokeS* , psttSay ) ;
                            {
                            TN( tTimeOld , "" ) ;

                            etThread.osTimeToOldTimeF( tin0P , ms , ss , mm , hh , d , m , y , dow , timeN1 , timeN2 , flOStIMEtOoLDtIME_null ) ;
                            ZE(  countT , dow ) ;
                            ZE( sCountT , y   ) ;
                            ZE(  countT , m   ) ;
                            ZE(  countT , d   ) ;
                            ZE(  countT , hh  ) ;
                            ZE(  countT , mm  ) ;
                            ZE(  countT , ss  ) ;
                            ZE(  countT , ms  ) ;

                            etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                            ZE( sCountT , timeN2 ) ;
                            ZE( countT  , timeN1 ) ;

                            countT idError = ifcIDeRRORdNS_AOK ;
                        {
                        if( pbq && cbq )
                    {
                    if( etThread.strIdF( tin0P , T(".letsencrypt.org") , tDomainPeer ) )    //U:: TO FIND A BUG (PROD: COMMENT OUT THIS if() CONDITION SO THAT THE BLOCK IS ALWAYS EXECUTED

                    }
                        }
                            //etRock.traceF( tin0P , tSayPrefix+T(nnPeer)+tSayUnknownDomain+tb4+tDomainPeer ) ;
                            bRefuse = 1 ;
                        {
                        if( !bStripeWebHookNotifier && !bListedDomain )

                        }
                            }
                                }
                                    }
                                        break ;
                                        bStripeWebHookNotifier = 1 ;
                                    {
                                    if( pnnSubnetAllowedStripe[ offn ] == nnPeer( 0x40 ) )
                                {
                                else
                                }
                                    }
                                        break ;
                                        bStripeWebHookNotifier = 1 ;
                                    {
                                    if( pnnSubnetAllowedStripe[ offn ] == nnPeer( 0x18 ) )
                                {
                                if( nnPeer.isIPv4F() )
                            {
                            for( countT offn = 0 ; offn < cnnSubnetAllowedStripe ; offn ++ )
                        {
                        if( !bListedDomain )
                        ZE( boolT , bStripeWebHookNotifier ) ;

                        }
                            ether.delF( tin0P , psttPeer ) ;
                            }
                                }
                                    }
                                        break ;
                                        bListedDomain ++ ;
                                    {
                                    if( idHit && idHit == 1 + psttPeer->idAdam - pptListedDomain[ offt ]->csF( tin0P ) )
                                    countT idHit  = etThread.strIdF( tin0P , *pptListedDomain[ offt ] , psttPeer , 1 ) ;
                                {
                                for( countT offt = 0 ; offt < cListedDomains ; offt ++ )

                                //etRock.traceF( tin0P , T("[tPeer]:    ")+T(psttPeer) ) ;
                                tDomainPeer = T(psttPeer) ;
                            {
                            else
                            if( !psttPeer ) /*;*/etRock.traceF( tin0P , T("!exception / reverse DNS lookup failed") ) ;
                            ether.sockPsttHostF( tin0P , psttPeer , nnPeer ) ; ___( psttPeer ) ;
                            ZE( strokeS* , psttPeer ) ;
                        {
                        ZE( boolT , bListedDomain ) ;
                    {
                    TN( tDomainPeer , "" ) ;
                    ZE( boolT , bRefuse ) ;

                    sockd.readF( tin0P , pbq , cbq , idp , nnPeer ) ; ___( pbq ) ;
                    nicNameC nnPeer ;
                    ZE( countT , idp ) ;
                    ZE( countT , cbq ) ;
                    ZE( byteT* , pbq ) ;
                {
                while( !POOP && !ether && !etThread && !*((tin1S&)tin0P).pEtScratch )
                TN( tSayGranting , "    granting information    " ) ;
                TN( tSayRefusing , "    refusing information    " ) ;
                TN( tSayUnknownDomain , "    !exception / unknown peer domain" ) ;
                TN( tSayPrefix  , "[nnPeer]:    " ) ;

                nicNameC nnWebHook1       = etThread.sockNicNameF( tin0P , tIpWebHook1 ) ;

                TN( tb4    , "    " ) ;
                TN( tWebHook1 , "" ) ; tWebHook1 = tDomainLeafWebHook1Net+T(".hidden.ideafarm.com") ;
                TN( tWebHooks , "" ) ; tWebHooks = tDomainLeafWebHooksNet+T(".hidden.ideafarm.com") ;

                sockd.bindF( tin0P , ifcPORToLD2_DNS ) ;
                socketC sockd( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
                stsReplies.purgeF( tin0P ) ;
                stsQueries.purgeF( tin0P ) ;
                *((tin1S&)tin0P).pEtScratch = 0 ;
            {
            while( !POOP && !ether && !etThread )
            stackC stsQueries(   tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            stackC stsReplies(   tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            stackC stsRepliesNU( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            ZE( countT , idClient ) ;

            SCOOPS
        {
        IFsCRATCHoK

        }
            }
                else                                                                 break ;
                if( etThread.strCompareF( tin0P , *pptListedDomain[ offt ] , tnu ) ) cListedDomains ++ ;
            {
            for( countT offt = 0 ; offt < sizeof pptListedDomain / sizeof pptListedDomain[ 0 ] ; offt ++ )
            TN( tnu , ".not.used.ideafarm.com" ) ;
        {
        ZE( countT , cListedDomains ) ;                             //P:PERSONALITY: I IGNORE ALL ELEMENTS NOT BEFORE THE WO'TH ELEMENT THAT CONTAINS THE "NOT USED" VALUE ; THIS IS FOR SPEED

        } ;
            &tListedDomain8 ,
            &tListedDomain7 ,
            &tListedDomain6 ,
            &tListedDomain5 ,
            &tListedDomain4 ,
            &tListedDomain3 ,
            &tListedDomain2 ,
            &tListedDomain1 ,
        {
        textC* pptListedDomain[] =

        TN( tListedDomain8 , (strokeS*)tDomainRootAllowed8 ) ;
        TN( tListedDomain7 , (strokeS*)tDomainRootAllowed7 ) ;
        TN( tListedDomain6 , (strokeS*)tDomainRootAllowed6 ) ;
        TN( tListedDomain5 , (strokeS*)tDomainRootAllowed5 ) ;
        TN( tListedDomain4 , (strokeS*)tDomainRootAllowed4 ) ;
        TN( tListedDomain3 , (strokeS*)tDomainRootAllowed3 ) ;
        TN( tListedDomain2 , (strokeS*)tDomainRootAllowed2 ) ;
        TN( tListedDomain1 , (strokeS*)tDomainRootAllowed1 ) ;

        }
            etThread.traceF( tin0P , T("allowed (Stripe) [subnet]:    ")+T(pnnSubnetAllowedStripe[offn]) ) ;
        {
        for( countT offn = 0 ; offn < cnnSubnetAllowedStripe ; offn ++ )

        }
            }
                while( ~hWalk ) ;
                }
                    pnnSubnetAllowedStripe[ offo ++ ] = nnSubnet ;
                    nicNameC& nnSubnet = (nicNameC&)stNnSubnet.downF( tin0P , hWalk ) ;
                {
                do
                handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                ZE( countT , offo ) ;
            {
            if( pnnSubnetAllowedStripe )
            etThread.newF( tin0P , LF , pnnSubnetAllowedStripe , cnnSubnetAllowedStripe ) ; ___( pnnSubnetAllowedStripe ) ;
            cnnSubnetAllowedStripe = stNnSubnet ;

            }
                stNnSubnet.sinkF( tin0P , countTC() , nnSubnet , flSTACKsINK_UNIQUE ) ;

                ;
                    : nnIPv46( 0x40 )
                    ? nnIPv46( 0x18 )
                nicNameC nnSubnet = nnIPv46.isIPv4F()
                nicNameC nnIPv46  = etThread.sockNicNameF( tin0P , T(pptIPv46[offt]) ) ;
            {
            for( countT offt = 0 ; offt < sizeof pptIPv46 / sizeof pptIPv46[ 0 ] ; offt ++ )
            stackC stNnSubnet( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_nicNameC ) ;

            } ;
                "44.242.180.165" ,
                "44.242.180.123" ,
                "44.242.179.92" ,
                "44.242.179.63" ,
                "44.242.179.48" ,
                "44.242.179.102" ,
                "44.242.178.79" ,
                "44.242.178.255" ,
                "44.242.178.138" ,
                "44.242.177.78" ,
                "44.242.177.38" ,
                "35.80.48.246" ,
                "35.80.48.213" ,
                "35.80.48.209" ,
                "35.80.48.143" ,
                "35.80.40.20" ,
                "35.80.40.163" ,
                "34.223.47.204" ,
                "34.223.47.156" ,
                "34.223.47.138" ,
                "34.223.46.51" ,
                "34.223.46.31" ,
                "34.223.46.120" ,
                "34.223.46.110" ,
                "34.223.45.181" ,
                "34.223.45.175" ,
                "34.223.45.164" ,
                "34.223.37.241" ,
                "34.223.112.29" ,
                "34.223.112.248" ,
                "34.223.112.241" ,
                "34.223.112.206" ,
                "34.222.66.86" ,          //ADDED 20250304@2027 (NOT VERIFIED TO BE STRIPE)
                "34.221.183.247" ,
                "34.218.119.80" ,
                "34.218.119.132" ,
                "34.218.119.120" ,
                "34.216.226.194" ,
                "3.19.147.71" ,
                "3.19.147.64" ,
                "3.19.147.5" ,
                "3.19.147.31" ,
                "3.19.147.210" ,
                "3.19.147.208" ,
                "3.19.147.166" ,
                "3.19.147.152" ,
                "3.18.132.41" ,
                "3.18.132.37" ,
                "3.18.132.35" ,
                "3.18.132.27" ,
                "3.142.4.130" ,
                "3.141.252.139" ,
                "3.140.136.146" ,
                "3.140.136.139" ,
                "3.140.136.135" ,
                "3.139.136.242" ,
                "3.139.136.196" ,      //ADDED 20250228@1320
                "3.139.136.145" ,
                "3.139.136.133" ,      //ADDED 20250303@2239
                "18.217.41.98" ,
                "18.217.41.68" ,
                "18.217.41.199" ,
                "18.188.9.89" ,
                "18.188.9.80" ,
                "104.238.131.45" ,     //ADDED 20250303@2216

                //20250225@1730: THESE VALUES WERE OBTAINED BY SETTING STRIPE TO USE AN EASILY RECOGNIZED INVALID URI LIKE piddle.hidden.ideafarm.com, TELLING STRIPE TO RESEND AN EVENT NOTICE, AND THEN OBSERVING ALL OF THE QUERIES THAT HIT THE HIDDEN DNS SERVER (ME)
            {
            osTextT* pptIPv46[] =
        {
        ZE( countT    , cnnSubnetAllowedStripe ) ;
        ZE( nicNameC* , pnnSubnetAllowedStripe ) ;
    {
    else
    }
        etRock.traceF( tin0P , T("a required setting is missing") ) ;
    {
    )
        !tDomainRootAllowed8.csF( tin0P )
        ||
        !tDomainRootAllowed7.csF( tin0P )
        ||
        !tDomainRootAllowed6.csF( tin0P )
        ||
        !tDomainRootAllowed5.csF( tin0P )
        ||
        !tDomainRootAllowed4.csF( tin0P )
        ||
        !tDomainRootAllowed3.csF( tin0P )
        ||
        !tDomainRootAllowed2.csF( tin0P )
        ||
        !tDomainRootAllowed1.csF( tin0P )
        ||
        !tIpWebHook1.csF( tin0P )
        ||
        !tDomainLeafWebHook1Net.csF( tin0P )
        ||
        !tDomainLeafWebHooksNet.csF( tin0P )
        ||
        !tIpWebHook1.csF( tin0P )
    (
    if

    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed8]:    \"")+tDomainRootAllowed8+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed7]:    \"")+tDomainRootAllowed7+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed6]:    \"")+tDomainRootAllowed6+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed5]:    \"")+tDomainRootAllowed5+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed4]:    \"")+tDomainRootAllowed4+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed3]:    \"")+tDomainRootAllowed3+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed2]:    \"")+tDomainRootAllowed2+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed1]:    \"")+tDomainRootAllowed1+T("\"") ) ;

    /**/etRock.traceF( tin0P , T("settings [tIpWebHook1,tDomainLeafWebHooksNet,tDomainLeafWebHook1Net]:    \"")+tIpWebHook1+T("\"    \"")+tDomainLeafWebHooksNet+T("\"    \"")+tDomainLeafWebHook1Net ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed8 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.8")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed8 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed7 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.7")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed7 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed6 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.6")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed6 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed5 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.5")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed5 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed4 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.4")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed4 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed3 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.3")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed3 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed2 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.2")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed2 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed1 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.1")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed1 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tIpWebHook1 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1")  ) ; ___( psttEat ) ;
    {
    TN( tIpWebHook1 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        }
            etThread.delF( tin0P , psttNet ) ;
            tDomainLeafWebHook1Net = T(psttNet) ;
            etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.wh1")  ) ; ___( psttEat ) ;
    {
    TN( tDomainLeafWebHook1Net , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        }
            etThread.delF( tin0P , psttNet ) ;
            tDomainLeafWebHooksNet = T(psttNet) ;
            etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.webhooks")  ) ; ___( psttEat ) ;
    {
    TN( tDomainLeafWebHooksNet , "" ) ;

    etherC& etRock = etherC::etRockIF( tin0P ) ;
    TN( tDash , "-" ) ;

    _IO_
{
if( pTaskP )
TASK( tmWorkF )

}
    }
        stsRepliesP << ps ;

        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // cSerial
        *ps << (countT)0 ; // cSerial
        *ps << psttEmailP ;
        *ps << psttNsP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_SOA ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_SOA_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttNsP , const strokeS* const psttEmailP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_NS ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_NS_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;
        *ps << (countT)0 ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_MX ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_MX_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_AAAA ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_AAAA_F [nn,name]:    ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_AAAA_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_A ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_A_F [nn,name]:    ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_A_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )

//  
// CERTBOT CANNOT BE USED TO RENEW A CERTIFICATE FOR THE LEAF DOMAIN, BECAUSE I DO NOT HAVE CERTBOT'S SERVERS ON MY ALLOWLIST
// I ASSUME THAT A "SHIELDS DOWN" FUNCTION IS NOT NEEDED BECAUSE THE DOMAIN NAME LEAF IS CHANGED FREQUENTLY
//  
//P:PERSONALITY: I KEEP IP ADDRESSES CONFIDENTIAL, BY TREATING THE REQUESTED DOMAIN NAME LEAF AS A PASSWORD, AND BY APPLYING AN ALLOWLIST TO nnPeer

// OBSOLETES 895_ (LIKE 895_ BUT 895_ KEPT AS A SNAPSHOT OF CODE THAT WORKS)

/*1*/WAKEhIDE( "ifcIDaDAM_DNS" )/*1*/

/**/
*/
 i simply map names (many to 1 and 1 to many) into ip addresses and tell the client to not cache
i do not use the canonical name concept
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

