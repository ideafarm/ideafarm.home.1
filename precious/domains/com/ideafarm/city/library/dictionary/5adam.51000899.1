
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        }
            }
                *((tin1S&)tin0P).pEtScratch = 0 ; //U: WORKAROUND TO SEE WHETHER PREVENTS BLOCK IN bindF
                }
                    ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbq ) ;
                    }
                        }
                            ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbr ) ;
                            sockd.writeF( tin0P , idp , nnPeer , pbr , cbr ) ;

                            ((tin1S&)tin0P).pEtScratch->dnsReplyF( tin0P , pbr , cbr , pbq , stsReplies , 1 , idError ) ;
                            ZE( countT , cbr ) ;
                            ZE( byteT* , pbr ) ;
                            /**/etRock.traceF( tin0P , T("replying [idError]:    ")+TF2(idError,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                            }
                                }
                                    if( !stsReplies ) idError = ifcIDeRRORdNS_NAMEnOTdEFINED ;

                                    }
                                        DEL( ps ) ;
                                        }
                                            }
                                                }
                                                    break ;

                                                    if( ~nnOut ) rec_AAAA_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut ) ;

                                                    else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHook1    ) ) nnOut = nnWebHook1 ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                                         if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHooks    ) ) nnOut = nnWebHook1 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...

                                                    nicNameC nnOut ;
                                                {
                                                case ifcIDtYPEdNSqUERY_AAAA :
                                                }
                                                    break ;

                                                    if( ~nnOut ) rec_A_F( tin0P , etThread , stsReplies , ifcIDtYPEdNSrEPLY_ANSWER , tDomainGross , nnOut ) ;

                                                    else if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHook1    ) ) nnOut = nnWebHook1 ;        //THIS IS NEEDED BECAUSE, DURING CERTBOT CERT RENEWAL, CHALLENGES RECEIVED BY wh2 wh3 ... ARE REDIRECTED TO wh1
                                                         if( !((tin1S&)tin0P).pEtScratch->strCompareF( tin0P , tDomainNet , tWebHooks    ) ) nnOut = nnWebHook1 ;        //WHEN THERE ARE MULTIPLE WH [wh1, wh2, wh3, ...] THEN RETURN ALL VALUES nnWebHook1 nnWebHook2 nnWebHook3 ...

                                                    nicNameC nnOut ;
                                                {
                                                case ifcIDtYPEdNSqUERY_A :
                                                }
                                                    break ;
                                                {
                                                case ifcIDtYPEdNSqUERY_CAA :
                                            {
                                            if( idClass == 1 ) switch( idType )

                                            *ps >> idClass ;
                                            ZE( countT , idClass ) ;

                                            *ps >> idType ;
                                            ZE( countT , idType ) ;

                                            etThread.delF( tin0P , psttw ) ;
                                            TN( tDomainNet , psttw ) ;
                                            }
                                                //etRock.traceF( tin0P , T("[domainNet,peer]:      \"")+T(psttw)+T("\"    \"")+tDomainPeer+T("\"") ) ;

                                                etThread.strMakeF( tin0P , LF , psttw , tDomainNet ) ; ___( psttw ) ;
                                                TN( tDomainNet , "" ) ; tDomainNet = T(psttNet)+T(".hidden.ideafarm.com") ;

                                                etThread.delF( tin0P , psttw ) ;
                                                etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttw , 0 , 0 ) ;
                                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                                countT idf = 1 ;
                                                ZE( strokeS* , psttNet ) ;
                                            {
                                            if( psttw )

                                            //etRock.traceF( tin0P , T("[domainGross,peer]:    \"")+tDomainGross+T("\"    \"")+tDomainPeer+T("\"") ) ;
                                            TN( tDomainGross , psttw ) ;
                                            if( psttw ) ((tin1S&)tin0P).pEtScratch->strConvertToLowerCaseF( tin0P , psttw ) ; ___( psttw ) ;
                                            *ps >> psttw ;
                                            ZE( strokeS* , psttw ) ;
                                        {
                                        if( ps )
                                        stsQueries >> ps ;
                                        ZE( soulC* , ps ) ;
                                    {
                                    while( stsQueries )
                                {
                                else
                                }
                                    idError = ifcIDeRRORdNS_CANNOTpARSEqUERY ;
                                    /**/etRock.traceF( tin0P , T("!exception / dnsParseF failed") ) ;
                                    POOPRqUIET ;
                                {
                                if( POOP )

                                }
                                    ((tin1S&)tin0P).pEtScratch->delF( tin0P , pbNU ) ;
                                    ((tin1S&)tin0P).pEtScratch->dnsParseF( tin0P , pbNU , countTC() , stsQueries , stsRepliesNU , pbq , cbq ) ;
                                    ZE( byteT* , pbNU ) ;

                                    stsRepliesNU.purgeF( tin0P ) ;
                                    stsQueries.purgeF( tin0P ) ;
                                {

                                ++ idClient ;
                            {
                            else
                            if( bRefuse ) /*;*/etRock.traceF( tin0P , T(nnPeer)+tSayRefusing+tb4+tDomainPeer ) ;

                            countT idError = ifcIDeRRORdNS_AOK ;
                        {
                        if( pbq && cbq )

                        /**/etRock.traceF( tin0P , tSayPrefix+T(nnPeer)+tb4+tDomainPeer ) ;
                    {

                    }
                        }
                            /**/etRock.traceF( tin0P , tSayPrefix+T(nnPeer)+tSayUnknownDomain+tb4+tDomainPeer ) ;
                            bRefuse = 1 ;
                        {
                        if( !bStripeWebHookNotifier && !bListedDomain )

                        }
                            }
                                }
                                    break ;
                                    bStripeWebHookNotifier = 1 ;
                                {
                                if( maskedPeer == pcMaskSubnetAllowedStripe[ offm ] )
                            {
                            for( countT offm = 0 ; offm < sizeof pcMaskSubnetAllowedStripe / sizeof pcMaskSubnetAllowedStripe[ 0 ] ; offm ++ )
                            countT maskedPeer = *(const count02T*)nnPeer & 0xffffff00 ;
                        {
                        if( !bListedDomain )
                        ZE( boolT , bStripeWebHookNotifier ) ;

                        }
                            ether.delF( tin0P , psttPeer ) ;
                            }
                                }
                                    }
                                        break ;
                                        bListedDomain ++ ;
                                    {
                                    if( idHit && idHit == 1 + psttPeer->idAdam - pptListedDomain[ offt ]->csF( tin0P ) )
                                    countT idHit  = etThread.strIdF( tin0P , *pptListedDomain[ offt ] , psttPeer , 1 ) ;
                                {
                                for( countT offt = 0 ; offt < cListedDomains ; offt ++ )

                                /**/etRock.traceF( tin0P , T("[tPeer]:    ")+T(psttPeer) ) ;
                                tDomainPeer = T(psttPeer) ;
                            {
                            else
                            if( !psttPeer ) /*;*/etRock.traceF( tin0P , T("!exception / reverse DNS lookup failed") ) ;
                            ether.sockPsttHostF( tin0P , psttPeer , nnPeer ) ; ___( psttPeer ) ;
                            ZE( strokeS* , psttPeer ) ;
                        {
                        ZE( boolT , bListedDomain ) ;
                    {
                    TN( tDomainPeer , "" ) ;
                    ZE( boolT , bRefuse ) ;

                    sockd.readF( tin0P , pbq , cbq , idp , nnPeer ) ; ___( pbq ) ;
                    nicNameC nnPeer ;
                    ZE( countT , idp ) ;
                    ZE( countT , cbq ) ;
                    ZE( byteT* , pbq ) ;
                {
                while( !POOP && !ether && !etThread && !*((tin1S&)tin0P).pEtScratch )
                TN( tSayRefusing , "    !exception / refusing information    " ) ;
                TN( tSayUnknownDomain , "    !exception / unknown peer domain" ) ;
                TN( tSayPrefix  , "[nnPeer]:    " ) ;

                nicNameC nnWebHook1       = etThread.sockNicNameF( tin0P , tIpWebHook1 ) ;

                TN( tb4    , "    " ) ;
                TN( tWebHook1 , "" ) ; tWebHook1 = tDomainLeafWebHook1Net+T(".hidden.ideafarm.com") ;
                TN( tWebHooks , "" ) ; tWebHooks = tDomainLeafWebHooksNet+T(".hidden.ideafarm.com") ;

                sockd.bindF( tin0P , ifcPORToLD2_DNS ) ;
                socketC sockd( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
                stsReplies.purgeF( tin0P ) ;
                stsQueries.purgeF( tin0P ) ;
                *((tin1S&)tin0P).pEtScratch = 0 ;
            {
            while( !POOP && !ether && !etThread )
            stackC stsQueries(   tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            stackC stsReplies(   tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            stackC stsRepliesNU( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_soulC ) ;
            ZE( countT , idClient ) ;

            SCOOPS
        {
        IFsCRATCHoK

        }
            }
                else                                                                 break ;
                if( etThread.strCompareF( tin0P , *pptListedDomain[ offt ] , tnu ) ) cListedDomains ++ ;
            {
            for( countT offt = 0 ; offt < sizeof pptListedDomain / sizeof pptListedDomain[ 0 ] ; offt ++ )
            TN( tnu , ".not.used.ideafarm.com" ) ;
        {
        ZE( countT , cListedDomains ) ;                             //P:PERSONALITY: I IGNORE ALL ELEMENTS NOT BEFORE THE WO'TH ELEMENT THAT CONTAINS THE "NOT USED" VALUE ; THIS IS FOR SPEED

        } ;
            &tListedDomain8 ,
            &tListedDomain7 ,
            &tListedDomain6 ,
            &tListedDomain5 ,
            &tListedDomain4 ,
            &tListedDomain3 ,
            &tListedDomain2 ,
            &tListedDomain1 ,
        {
        textC* pptListedDomain[] =

        TN( tListedDomain8 , (strokeS*)tDomainRootAllowed8 ) ;
        TN( tListedDomain7 , (strokeS*)tDomainRootAllowed7 ) ;
        TN( tListedDomain6 , (strokeS*)tDomainRootAllowed6 ) ;
        TN( tListedDomain5 , (strokeS*)tDomainRootAllowed5 ) ;
        TN( tListedDomain4 , (strokeS*)tDomainRootAllowed4 ) ;
        TN( tListedDomain3 , (strokeS*)tDomainRootAllowed3 ) ;
        TN( tListedDomain2 , (strokeS*)tDomainRootAllowed2 ) ;
        TN( tListedDomain1 , (strokeS*)tDomainRootAllowed1 ) ;

        } ;
            pcSubnetAllowedStripe_3f[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_3b[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_38[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_36[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_32[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_30[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_2d[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_29[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_26[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_25[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_21[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_20[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_1d[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_1c[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_14[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_10[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_0f[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_0e[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_0b[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_07[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_04[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_02[ 0 ] & 0xffffff00 ,
            pcSubnetAllowedStripe_01[ 0 ] & 0xffffff00 ,
        {
        const countT pcMaskSubnetAllowedStripe[] =

        const count02T* pcSubnetAllowedStripe_3f = nnAllowedStripe_3f ;
        const count02T* pcSubnetAllowedStripe_3b = nnAllowedStripe_3b ;
        const count02T* pcSubnetAllowedStripe_38 = nnAllowedStripe_38 ;
        const count02T* pcSubnetAllowedStripe_36 = nnAllowedStripe_36 ;
        const count02T* pcSubnetAllowedStripe_32 = nnAllowedStripe_32 ;
        const count02T* pcSubnetAllowedStripe_30 = nnAllowedStripe_30 ;
        const count02T* pcSubnetAllowedStripe_2d = nnAllowedStripe_2d ;
        const count02T* pcSubnetAllowedStripe_29 = nnAllowedStripe_29 ;
        const count02T* pcSubnetAllowedStripe_26 = nnAllowedStripe_26 ;
        const count02T* pcSubnetAllowedStripe_25 = nnAllowedStripe_25 ;
        const count02T* pcSubnetAllowedStripe_21 = nnAllowedStripe_21 ;
        const count02T* pcSubnetAllowedStripe_20 = nnAllowedStripe_20 ;
        const count02T* pcSubnetAllowedStripe_1d = nnAllowedStripe_1d ;
        const count02T* pcSubnetAllowedStripe_1c = nnAllowedStripe_1c ;
        const count02T* pcSubnetAllowedStripe_14 = nnAllowedStripe_14 ;
        const count02T* pcSubnetAllowedStripe_10 = nnAllowedStripe_10 ;
        const count02T* pcSubnetAllowedStripe_0f = nnAllowedStripe_0f ;
        const count02T* pcSubnetAllowedStripe_0e = nnAllowedStripe_0e ;
        const count02T* pcSubnetAllowedStripe_0b = nnAllowedStripe_0b ;
        const count02T* pcSubnetAllowedStripe_07 = nnAllowedStripe_07 ;
        const count02T* pcSubnetAllowedStripe_04 = nnAllowedStripe_04 ;
        const count02T* pcSubnetAllowedStripe_02 = nnAllowedStripe_02 ;
        const count02T* pcSubnetAllowedStripe_01 = nnAllowedStripe_01 ;
        //FROM PRECEDING LIST, TAKING UNIQUE /24 SUBNETS

        nicNameC nnAllowedStripe_40 = etThread.sockNicNameF( tin0P , T("44.242.180.165") ) ;
        nicNameC nnAllowedStripe_3f = etThread.sockNicNameF( tin0P , T("44.242.180.123") ) ;
        nicNameC nnAllowedStripe_3e = etThread.sockNicNameF( tin0P , T("44.242.179.92") ) ;
        nicNameC nnAllowedStripe_3d = etThread.sockNicNameF( tin0P , T("44.242.179.63") ) ;
        nicNameC nnAllowedStripe_3c = etThread.sockNicNameF( tin0P , T("44.242.179.48") ) ;
        nicNameC nnAllowedStripe_3b = etThread.sockNicNameF( tin0P , T("44.242.179.102") ) ;
        nicNameC nnAllowedStripe_3a = etThread.sockNicNameF( tin0P , T("44.242.178.79") ) ;
        nicNameC nnAllowedStripe_39 = etThread.sockNicNameF( tin0P , T("44.242.178.255") ) ;
        nicNameC nnAllowedStripe_38 = etThread.sockNicNameF( tin0P , T("44.242.178.138") ) ;
        nicNameC nnAllowedStripe_37 = etThread.sockNicNameF( tin0P , T("44.242.177.78") ) ;
        nicNameC nnAllowedStripe_36 = etThread.sockNicNameF( tin0P , T("44.242.177.38") ) ;
        nicNameC nnAllowedStripe_35 = etThread.sockNicNameF( tin0P , T("35.80.48.246") ) ;
        nicNameC nnAllowedStripe_34 = etThread.sockNicNameF( tin0P , T("35.80.48.213") ) ;
        nicNameC nnAllowedStripe_33 = etThread.sockNicNameF( tin0P , T("35.80.48.209") ) ;
        nicNameC nnAllowedStripe_32 = etThread.sockNicNameF( tin0P , T("35.80.48.143") ) ;
        nicNameC nnAllowedStripe_31 = etThread.sockNicNameF( tin0P , T("35.80.40.20") ) ;
        nicNameC nnAllowedStripe_30 = etThread.sockNicNameF( tin0P , T("35.80.40.163") ) ;
        nicNameC nnAllowedStripe_2f = etThread.sockNicNameF( tin0P , T("34.223.47.204") ) ;
        nicNameC nnAllowedStripe_2e = etThread.sockNicNameF( tin0P , T("34.223.47.156") ) ;
        nicNameC nnAllowedStripe_2d = etThread.sockNicNameF( tin0P , T("34.223.47.138") ) ;
        nicNameC nnAllowedStripe_2c = etThread.sockNicNameF( tin0P , T("34.223.46.51") ) ;
        nicNameC nnAllowedStripe_2b = etThread.sockNicNameF( tin0P , T("34.223.46.31") ) ;
        nicNameC nnAllowedStripe_2a = etThread.sockNicNameF( tin0P , T("34.223.46.120") ) ;
        nicNameC nnAllowedStripe_29 = etThread.sockNicNameF( tin0P , T("34.223.46.110") ) ;
        nicNameC nnAllowedStripe_28 = etThread.sockNicNameF( tin0P , T("34.223.45.181") ) ;
        nicNameC nnAllowedStripe_27 = etThread.sockNicNameF( tin0P , T("34.223.45.175") ) ;
        nicNameC nnAllowedStripe_26 = etThread.sockNicNameF( tin0P , T("34.223.45.164") ) ;
        nicNameC nnAllowedStripe_25 = etThread.sockNicNameF( tin0P , T("34.223.37.241") ) ;
        nicNameC nnAllowedStripe_24 = etThread.sockNicNameF( tin0P , T("34.223.112.29") ) ;
        nicNameC nnAllowedStripe_23 = etThread.sockNicNameF( tin0P , T("34.223.112.248") ) ;
        nicNameC nnAllowedStripe_22 = etThread.sockNicNameF( tin0P , T("34.223.112.241") ) ;
        nicNameC nnAllowedStripe_21 = etThread.sockNicNameF( tin0P , T("34.223.112.206") ) ;
        nicNameC nnAllowedStripe_20 = etThread.sockNicNameF( tin0P , T("34.221.183.247") ) ;
        nicNameC nnAllowedStripe_1f = etThread.sockNicNameF( tin0P , T("34.218.119.80") ) ;
        nicNameC nnAllowedStripe_1e = etThread.sockNicNameF( tin0P , T("34.218.119.132") ) ;
        nicNameC nnAllowedStripe_1d = etThread.sockNicNameF( tin0P , T("34.218.119.120") ) ;
        nicNameC nnAllowedStripe_1c = etThread.sockNicNameF( tin0P , T("34.216.226.194") ) ;
        nicNameC nnAllowedStripe_1b = etThread.sockNicNameF( tin0P , T("3.19.147.71") ) ;
        nicNameC nnAllowedStripe_1a = etThread.sockNicNameF( tin0P , T("3.19.147.64") ) ;
        nicNameC nnAllowedStripe_19 = etThread.sockNicNameF( tin0P , T("3.19.147.5") ) ;
        nicNameC nnAllowedStripe_18 = etThread.sockNicNameF( tin0P , T("3.19.147.31") ) ;
        nicNameC nnAllowedStripe_17 = etThread.sockNicNameF( tin0P , T("3.19.147.210") ) ;
        nicNameC nnAllowedStripe_16 = etThread.sockNicNameF( tin0P , T("3.19.147.208") ) ;
        nicNameC nnAllowedStripe_15 = etThread.sockNicNameF( tin0P , T("3.19.147.166") ) ;
        nicNameC nnAllowedStripe_14 = etThread.sockNicNameF( tin0P , T("3.19.147.152") ) ;
        nicNameC nnAllowedStripe_13 = etThread.sockNicNameF( tin0P , T("3.18.132.41") ) ;
        nicNameC nnAllowedStripe_12 = etThread.sockNicNameF( tin0P , T("3.18.132.37") ) ;
        nicNameC nnAllowedStripe_11 = etThread.sockNicNameF( tin0P , T("3.18.132.35") ) ;
        nicNameC nnAllowedStripe_10 = etThread.sockNicNameF( tin0P , T("3.18.132.27") ) ;
        nicNameC nnAllowedStripe_0f = etThread.sockNicNameF( tin0P , T("3.142.4.130") ) ;
        nicNameC nnAllowedStripe_0e = etThread.sockNicNameF( tin0P , T("3.141.252.139") ) ;
        nicNameC nnAllowedStripe_0d = etThread.sockNicNameF( tin0P , T("3.140.136.146") ) ;
        nicNameC nnAllowedStripe_0c = etThread.sockNicNameF( tin0P , T("3.140.136.139") ) ;
        nicNameC nnAllowedStripe_0b = etThread.sockNicNameF( tin0P , T("3.140.136.135") ) ;
        nicNameC nnAllowedStripe_0a = etThread.sockNicNameF( tin0P , T("3.139.136.242") ) ;
        nicNameC nnAllowedStripe_09 = etThread.sockNicNameF( tin0P , T("3.139.136.196") ) ;      //ADDED 20250228@1320
        nicNameC nnAllowedStripe_08 = etThread.sockNicNameF( tin0P , T("3.139.136.145") ) ;
        nicNameC nnAllowedStripe_07 = etThread.sockNicNameF( tin0P , T("3.139.136.133") ) ;      //ADDED 20250303@2239
        nicNameC nnAllowedStripe_06 = etThread.sockNicNameF( tin0P , T("18.217.41.98") ) ;
        nicNameC nnAllowedStripe_05 = etThread.sockNicNameF( tin0P , T("18.217.41.68") ) ;
        nicNameC nnAllowedStripe_04 = etThread.sockNicNameF( tin0P , T("18.217.41.199") ) ;
        nicNameC nnAllowedStripe_03 = etThread.sockNicNameF( tin0P , T("18.188.9.89") ) ;
        nicNameC nnAllowedStripe_02 = etThread.sockNicNameF( tin0P , T("18.188.9.80") ) ;
        nicNameC nnAllowedStripe_01 = etThread.sockNicNameF( tin0P , T("104.238.131.45") ) ;     //ADDED 20250303@2216
        //20250225@1730: THESE VALUES WERE OBTAINED BY SETTING STRIPE TO USE AN EASILY RECOGNIZED INVALID URI LIKE piddle.hidden.ideafarm.com, TELLING STRIPE TO RESEND AN EVENT NOTICE, AND THEN OBSERVING ALL OF THE QUERIES THAT HIT THE HIDDEN DNS SERVER (ME)
    {
    else
    }
        etRock.traceF( tin0P , T("a required setting is missing") ) ;
    {
    )
        !tDomainRootAllowed8.csF( tin0P )
        ||
        !tDomainRootAllowed7.csF( tin0P )
        ||
        !tDomainRootAllowed6.csF( tin0P )
        ||
        !tDomainRootAllowed5.csF( tin0P )
        ||
        !tDomainRootAllowed4.csF( tin0P )
        ||
        !tDomainRootAllowed3.csF( tin0P )
        ||
        !tDomainRootAllowed2.csF( tin0P )
        ||
        !tDomainRootAllowed1.csF( tin0P )
        ||
        !tIpWebHook1.csF( tin0P )
        ||
        !tDomainLeafWebHook1Net.csF( tin0P )
        ||
        !tDomainLeafWebHooksNet.csF( tin0P )
        ||
        !tIpWebHook1.csF( tin0P )
    (
    if

    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed8]:    \"")+tDomainRootAllowed8+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed7]:    \"")+tDomainRootAllowed7+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed6]:    \"")+tDomainRootAllowed6+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed5]:    \"")+tDomainRootAllowed5+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed4]:    \"")+tDomainRootAllowed4+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed3]:    \"")+tDomainRootAllowed3+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed2]:    \"")+tDomainRootAllowed2+T("\"") ) ;
    /**/etRock.traceF( tin0P , T("settings [tDomainRootAllowed1]:    \"")+tDomainRootAllowed1+T("\"") ) ;

    /**/etRock.traceF( tin0P , T("settings [tIpWebHook1,tDomainLeafWebHooksNet,tDomainLeafWebHook1Net]:    \"")+tIpWebHook1+T("\"    \"")+tDomainLeafWebHooksNet+T("\"    \"")+tDomainLeafWebHook1Net ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed8 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.8")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed8 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed7 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.7")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed7 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed6 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.6")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed6 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed5 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.5")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed5 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed4 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.4")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed4 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed3 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.3")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed3 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed2 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.2")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed2 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tDomainRootAllowed1 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.root.allowed.1")  ) ; ___( psttEat ) ;
    {
    TN( tDomainRootAllowed1 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        tIpWebHook1 = T(psttEat) ;
        if( psttEat ) etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.wh1")  ) ; ___( psttEat ) ;
    {
    TN( tIpWebHook1 , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        }
            etThread.delF( tin0P , psttNet ) ;
            tDomainLeafWebHook1Net = T(psttNet) ;
            etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.wh1")  ) ; ___( psttEat ) ;
    {
    TN( tDomainLeafWebHook1Net , "" ) ;

    }
        etThread.delF( tin0P , psttEat ) ;
        }
            etThread.delF( tin0P , psttNet ) ;
            tDomainLeafWebHooksNet = T(psttNet) ;
            etThread.strSubstringF( tin0P , psttNet , idf , sttq , tDash , psttEat , 0 , 0 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttNet ) ;

            etThread.strConvertToLowerCaseF( tin0P , psttEat ) ;
        {
        if( psttEat )
        ZE( strokeS* , psttEat ) ; etThread.querySettingF( tin0P , psttEat , T("!ipdos.dns.domain.leaf.webhooks")  ) ; ___( psttEat ) ;
    {
    TN( tDomainLeafWebHooksNet , "" ) ;

    etherC& etRock = etherC::etRockIF( tin0P ) ;
    TN( tDash , "-" ) ;

    _IO_
{
if( pTaskP )
TASK( tmWorkF )

}
    }
        stsRepliesP << ps ;

        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sTTLMinimum
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sExpire
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRetry
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // sRefresh
        *ps << (countT)0 ; // cSerial
        *ps << (countT)0 ; // cSerial
        *ps << psttEmailP ;
        *ps << psttNsP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_SOA ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_SOA_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttNsP , const strokeS* const psttEmailP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_NS ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_NS_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        *ps << psttDataP ;
        *ps << (countT)0 ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_MX ;
        *ps << psttP ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_MX_F( tin0S& tin0P , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const strokeS* const psttDataP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_AAAA ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_AAAA_F [nn,name]:    ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_AAAA_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )

}
    }
        stsRepliesP << ps ;

        nicNameP >> *ps ;

        *ps << (countT&)time2 ;
        *ps << time1 ;
        ZE( sCountT , time2 ) ;
        ZE( countT  , time1 ) ;
        *ps << (countT)1 ;
        *ps << (countT)ifcIDtYPEdNSqUERY_A ;
        *ps << psttP ;

        /**/etherP.traceF( tin0P , T("rec_A_F [nn,name]:    ")+T(nicNameP)+T("    \"")+T(psttP)+T("\"") ) ;
    {
    if( ps )
    soulC* ps = new( 0 , tin0P , LF ) soulC( tin0P , TAG( TAGiDnULL ) , flSOUL_null , idTypeDnsReplyP ) ; ___( ps ) ;
{
voidT rec_A_F( tin0S& tin0P , etherC& etherP , stackC& stsRepliesP , const countT idTypeDnsReplyP , const strokeS* const psttP , const nicNameC& nicNameP )

//  
// CERTBOT CANNOT BE USED TO RENEW A CERTIFICATE FOR THE LEAF DOMAIN, BECAUSE I DO NOT HAVE CERTBOT'S SERVERS ON MY ALLOWLIST
// I ASSUME THAT A "SHIELDS DOWN" FUNCTION IS NOT NEEDED BECAUSE THE DOMAIN NAME LEAF IS CHANGED FREQUENTLY
//  
//P:PERSONALITY: I KEEP IP ADDRESSES CONFIDENTIAL, BY TREATING THE REQUESTED DOMAIN NAME LEAF AS A PASSWORD, AND BY APPLYING AN ALLOWLIST TO nnPeer

// OBSOLETES 895_ (LIKE 895_ BUT 895_ KEPT AS A SNAPSHOT OF CODE THAT WORKS)

/*1*/WAKEhIDE( "ifcIDaDAM_DNS" )/*1*/

/**/
*/
 i simply map names (many to 1 and 1 to many) into ip addresses and tell the client to not cache
i do not use the canonical name concept
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

