
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmRelayOldServerWrapToAppF )
}
    }
        }
            }
                etThread.delF( tin0P , pc2WrapRef ) ;
                DEL( *(soulC**)&pc2WrapRef->c1 ) ;
            {
            if( 1 == decv02AM( pc2WrapRef->c2 ) )

            }
                }
                    }
                        bQuitP = 1 ;
                        etThread.traceF( tin0P , T("could not write soul") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    psoP->writeF( tin0P , *(soulC*)pc2WrapRef->c1 ) ;
                    scoopC scoop( tin0P , LF , psoP->etherF( tin0P ) ) ;
                    //etThread.traceF( tin0P , T("writing soul") ) ;

                    }
                        }
                            portTimeC idptOrigin = portTimeC::fieldF( tin0P , sWrap , ifcOLDiDfIELDwRAP_IDPToRIGIN ) ;
                        {
                        if( idType == ifcOLDiDtYPEwRAP_GIFT )
                        countT idType = sWrap.cFieldF( tin0P , ifcOLDiDfIELDwRAP_IDtYPE ) ;
                        soulC& sWrap = *(soulC*)pc2WrapRef->c1 ;
                    {
                    //CONoUTrAW( "tmRelayOldServerWrapToAppF: trapping a bug\r\n" ) ;
                    //U::TO TRAP A BUG

                    //if( pczChannel && pczChannel[ 0 ] == ifcOLDiDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcOLDiDcHANNELfUNCTION_MEDIATORrEGISTRATION ) { CONoUTrAW( "tmRelayOldServerWrapToAppF: survived filters; writing to client\r\n" ) ; } //U::
                {
                if( bWrite )
    
                }
                    stChannelExcludeP.ungrabF( tin0P ) ;
                    }
                        while( !stChannelExcludeP.third && ~hDown ) ;
                        }
                            }
                                break ;
                                bWrite = 0 ;
                            {
                            if( !etThread.strCompareF( tin0P , pczChannel , pczTest , 0 , ccTestMax , pcFilter , ccFilter ) )
        
                            countT   ccFilter  =             pc4c->c4 ;
                            countT*& pcFilter  = *(countT**)&pc4c->c3 ;
                            countT   ccTestMax =             pc4c->c2 ;
                            countT*& pczTest   = *(countT**)&pc4c->c1 ;
                            count4S*& pc4c = *(count4S**)&stChannelExcludeP.downF( tin0P , hDown ) ;
                        {
                        do
                        handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( stChannelExcludeP )
                    stChannelExcludeP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                {
                if( bWrite )
    
                stChannelIncludeP.ungrabF( tin0P ) ;
                }
                    while( !stChannelIncludeP.third && ~hDown ) ;
                    }
                        }
                            break ;
                            bWrite = 1 ;
                        {
                        if( !etThread.strCompareF( tin0P , pczChannel , pczTest , 0 , ccTestMax , pcFilter , ccFilter ) )
    
                        countT   ccFilter  =             pc4c->c4 ;
                        countT*& pcFilter  = *(countT**)&pc4c->c3 ;
                        countT   ccTestMax =             pc4c->c2 ;
                        countT*& pczTest   = *(countT**)&pc4c->c1 ;
                        count4S*& pc4c = *(count4S**)&stChannelIncludeP.downF( tin0P , hDown ) ;
                    {
                    do
                    handleC hDown( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    bWrite = 0 ;
                {
                if( stChannelIncludeP )
                stChannelIncludeP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
                boolT bWrite = 1 ;

                //if( pczChannel && pczChannel[ 0 ] == ifcOLDiDcHANNEL1_BYfUNCTION && pczChannel[ 1 ] == ifcOLDiDcHANNELfUNCTION_MEDIATORrEGISTRATION ) { CONoUTrAW( "tmRelayOldServerWrapToAppF: this push is on the mediator reg channel\r\n" ) ; } //U::
    
                countT* pczChannel = (countT*)((soulC*)pc2WrapRef->c1)->pbFieldF( tin0P , countTC() , countTC() , countTC() , ifcOLDiDfIELDwRAP_CHANNEL ) ;
            {
            if( !bQuitP )

            stWrapRefP >> *(countT*)&pc2WrapRef ;
            ZE( count2S* , pc2WrapRef ) ;
        {
        while( stWrapRefP )

        if( bQuitP ) break ;
            { ((tin9S&)tin0P).pEther->traceF( tin0P , T("tmRelayOldServerWrapToAppF: see a push for ifcIDaDAM_CONSOLE") ) ; }
        if( idAdamClient == ifcIDaDAM_CONSOLE )
        stWrapRefP.waitF( tin0P ) ;
    {
    while( !ether && !bQuitP && !etThread && !stWrapRefP.third )

    countT        idAdamClient         =                 pTaskP->c6 ;
    stackC&       stChannelExcludeP    =       *(stackC*)pTaskP->c5 ;
    stackC&       stChannelIncludeP    =       *(stackC*)pTaskP->c4 ;
    stackC&       stWrapRefP           =       *(stackC*)pTaskP->c3 ;
    socketC*&     psoP                 =     *(socketC**)pTaskP->c2 ;
    boolT&        bQuitP               =        *(boolT*)pTaskP->c1 ;    
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 )
/*1*/TASK( tmRelayOldServerWrapToAppF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

