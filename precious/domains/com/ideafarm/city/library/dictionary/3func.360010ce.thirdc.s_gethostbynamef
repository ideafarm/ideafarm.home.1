
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            }
                break ;

                if( pYou ) stP << pYou ;
                nicNameC* pYou = new( 0 , tin0P , LF ) nicNameC( nn1 , nn2 , nn3 , nn4 ) ;

                countT nn1 = ((tin1S&)tin0P).brcRaw ;
                BOSdOnOTtEST( WHATgbo , ntohl( pca[ ++ offi ] ) )

                countT nn2 = ((tin1S&)tin0P).brcRaw ;
                BOSdOnOTtEST( WHATgbo , ntohl( pca[ ++ offi ] ) )

                countT nn3 = ((tin1S&)tin0P).brcRaw ;
                BOSdOnOTtEST( WHATgbo , ntohl( pca[ ++ offi ] ) )

                countT nn4 = ((tin1S&)tin0P).brcRaw ;
                BOSdOnOTtEST( WHATgbo , ntohl( pca[ ++ offi ] ) )
            {
            case 0x66666666 :
            }
                break ;

                }
                    stP << pYou ;
                    //if( ((tin1S&)tin0P).pEther ) ((tin1S&)tin0P).pEther->traceF( tin0P , T("s_getHostByNameF [*pYou,postP]:    ")+T(*pYou)+T("    ")+T(postP) ) ;
                {
                if( pYou )
                nicNameC* pYou = new( 0 , tin0P , LF ) nicNameC( nn1 , 0xffff ) ;    //0xffff IS TO MAP THIS IPv4 ADDRESS TO IPv6

                countT nn1 = ((tin1S&)tin0P).brcRaw ;
                BOSdOnOTtEST( WHATgbo , ntohl( pca[ ++ offi ] ) )
            {
            case 0x44444444 :
            }
                break ;
                bDone = 1 ;
            {
            case 0x11111111 :
        {
        switch( pca[ offi ] )
    {
    for( countT offi = 0 ; !bDone && offi < sizeof pca / sizeof pca[ 0 ] ; offi ++ )
    ZE( boolT , bDone ) ;

    __( rc ) ;
    while( rc == WSATRY_AGAIN ) ;
    }
        Sleep( 100 ) ;
        rc = c_getaddrinfoF( (byteT*)pca , sizeof pca , postP ) ;
    {
    do
    ZE( countT , rc ) ;
                                    //WO WAY TO DO THIS IS TO USE OO POWER ALLOCATION (ADD A RETURN VALUE TO c_getaddrinfoF TO REVEAL HOW MUCH BUFFER LENGTH IS NEEDED)
    countT pca[ TUCK >> 2 ] ;       //THIS WILL NEED TO BE ENLARGED TO SUPPORT A NAME WITH MANY ADDRESSES

    _IO_

    }
        if( POOP ) return ;
        IFsIMULATEoFFLINEpOOP
        __( stP.idTypeF( tin0P ) - ifcSTACKtYPE_PTR_nicNameC ) ;
        __( stP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT thirdC::s_getHostByNameF( tin0S& tin0P , stackC& stP , const osTextT* const postP )/*1*/

//CODEsYNCH: 00100de 10200f5: NICnAMElOCAL MUST BE THE VALUE THAT IS RETURNED BY gethostbyname WHEN NO ADAPTERS ARE ACTIVE

/**/
*/
use dnsNicNamesF instead
it is illegal to refer to this symbol in the definition of an adam
 if a plate is present, it is guaranteed to contain a nonze nicName value
caller must test to see whether stP contains a plate
impotence will not occur if the domain name server replies "not found"
\<A HREF=\"5.10200f5.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$s_getHostByNameF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

