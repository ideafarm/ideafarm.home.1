
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    for( countT offDock = 0 ; offDock < cDocks ; offDock ++ ) (*this)[ offDock * cItemsPerNapkin ] ;
    countT cItemsPerNapkin   = 1 << expItemsPerNapkin ;
    countT expItemsPerNapkin = expCbPerNapkinP - expCbPerItemP ;
    //PREALLOCATE TO FILL THE DOCKS (IF ALLOCATION IS GOING TO FAIL, LET'S FIND OUT NOW)

    }
        }
            ((tinNormalS&)tinBaseP).pEther->delF( tinBaseP , pstt1f ) ;
            }
                //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("deleted : ")+T(psttc1) ) ;
                ((tinNormalS&)tinBaseP).pEther->diskFileOrDirDeleteF( tinBaseP , psttc1 ) ;
                //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("deleting: ")+T(psttc1) ) ;
            {
            FORsTRINGSiN1( pstt1f )

            ((tinNormalS&)tinBaseP).pcQuit = pcQuitSave ;

            countT cFound = ((tinNormalS&)tinBaseP).pEther->diskFindFileOrDirF( tinBaseP , pstt1f , fnLike.pathF() , &pat , flDISKfIND_null , 0 , 0 , 0 , 8 ) ; ___( pstt1f ) ;
            ZE( strokeS* , pstt1f ) ;

            patternC pat( tinBaseP , *((tinNormalS&)tinBaseP).pEther , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
            fileNameC fnLike( tinBaseP , *((tinNormalS&)tinBaseP).pEther , tLike ) ;

                                       ((tinNormalS&)tinBaseP).pcQuit = 0 ;
            const countT* pcQuitSave = ((tinNormalS&)tinBaseP).pcQuit ;

            //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("deleting: ")+tLike ) ;

            TN( tLike , "" ) ; tLike = T(iffn)+T(postName)+T(".*") ;

            ifFileNameC iffn( tinBaseP , *((tinNormalS&)tinBaseP).pEther , postPath ) ;
        {
        if( !POOP )

        __Z( *postPath ) ;
        thirdC::postPathStateSpaceIF( tinBaseP , postPath , sizeof postPath , idStateSpace , idMemorySpaceCt ) ;
        osTextT postPath[ TUCK << 1 ] ;
    {
    if( F(flagsCt) & flNAPKINSc_PURGEoNcT )

    thirdC::c_strncpyIF( tinBaseP , postName , postP , sizeof postName ) ;

    thirdC::c_memsetIF( tinBaseP , (byteT*)pcDockOffNapkin , sizeof pcDockOffNapkin , - 1 ) ;

    else            thirdC::c_memsetIF( tinBaseP , (byteT*)pbBitsCt , sizeof pbBitsCt ) ;
    if( pbBitsCtP ) thirdC::c_memcpyIF( tinBaseP , (byteT*)pbBitsCt , (byteT*)pbBitsCtP , sizeof pbBitsCt ) ;

    _IO_

    SCOOP
{
flagsCt( flagsP )
expCbPerItem( expCbPerItemP ) ,
expCbPerNapkin( expCbPerNapkinP ) ,
idStateSpace( idStateSpaceP ? idStateSpaceP : ifcIDsTATEsPACE_SINGLEaDAM( tinBaseP ) ) ,
offDockNextCt( 0 ) ,
cDocks( sizeof pbDockNapkin / SIZEOF_napkinC ) ,
idMemorySpaceCt( idMemorySpaceP ) ,
idiFileCt( idiFileCtP ) ,
idLineCt( idLineCtP ) ,
/*1*/napkinsC::napkinsC( tinBaseS& tinBaseP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postP , countT expCbPerNapkinP , countT expCbPerItemP , const countT idStateSpaceP , const flagsT flagsP , const countT idMemorySpaceP ) :/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

