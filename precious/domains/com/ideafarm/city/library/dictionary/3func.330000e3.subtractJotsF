
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return sgn ;

    }
        ether.delF( tin0P , pb1Copy ) ;
        }
            }
                }
                    bFailP = 1 ;
                    ether.traceF( tin0P , T("subtractJotsF / unexpected duplicate found [idJot1,idJot2]:    ")+TF2(c1P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(c2P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( !sgn && F(flagsModeP) & flSORTERc_REQUIREuNIQUE )

                if( !sgn && !bFailP ) sgn = cb1Copy - cb2 ;
                sgn = bFailP ? 0 : thirdC::c_memcmpIF( tin0P , pb1Copy + cbIgnoreP , pb2 + cbIgnoreP , cbCompare ) ;
                countT cbCompare = ( cb1Copy < cb2 ? cb1Copy : cb2 ) - cbIgnoreP ;
            {
            else
            }
                bFailP = 1 ;
                ether.traceF( tin0P , T("subtractJotsF / blob for 2 (cursor) is too short [idJot]:    ")+TF2(c2P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            else if( cb2 < cbIgnoreP )
            }
                bFailP = 1 ;
                ether.traceF( tin0P , T("subtractJotsF / could not obtain blob for 2 (cursor) [idJot]:    ")+TF2(c2P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            if( !pb2 )

            }
                }
                    cb2 = page2 ;
                    pb2 = page2 ;
                {
                else
                }
                    ((tin1S&)tin0P).pEther->traceF( tin0P , T("subtractJotsF / jotC::readIF became impotent for 2 (cursor) [idJot,idReason]:    ")+TF2(c2P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idReason,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                    countT idReason = POOP ;
                {
                if( POOP )
                pageC page2 = jotC::readIF( tin0P , c2P ) ;

                SCOOPS
            {
            IFsCRATCH
            ZE( countT       , cb2 ) ;
            ZE( const byteT* , pb2 ) ;
        {
        if( !bFailP )

        }
            }
                thirdC::c_memcpyIF( tin0P , pb1Copy , pb1 , cb1Copy ) ;    
                ether.newF( tin0P , LF , pb1Copy , cb1Copy ) ; ___( pb1Copy ) ;
                cb1Copy = cb1 ;
            {
            else
            }
                bFailP = 1 ;
                ether.traceF( tin0P , T("subtractJotsF / blob for 1 (new) is too short [idJot]:    ")+TF2(c1P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            else if( cb1 < cbIgnoreP )
            }
                bFailP = 1 ;
                ether.traceF( tin0P , T("subtractJotsF / could not obtain blob for 1 (new) [idJot]:    ")+TF2(c1P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            if( !pb1 )

            }
                }
                    cb1 = page1 ;
                    pb1 = page1 ;
                {
                else
                }
                    ((tin1S&)tin0P).pEther->traceF( tin0P , T("subtractJotsF / jotC::readIF became impotent for 1 (new) [idJot,idReason]:    ")+TF2(c1P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idReason,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                    countT idReason = POOP ;
                {
                if( POOP )
                pageC page1 = jotC::readIF( tin0P , c1P ) ;

                SCOOPS
            {
            IFsCRATCH
            ZE( countT       , cb1 ) ;
            ZE( const byteT* , pb1 ) ;
        {
        ZE( countT , cb1Copy ) ;
        ZE( byteT* , pb1Copy ) ;

        }
            countT foo = 2 ;
        {
        if( c1P == 0x80001555 ||  c2P == 0x80001555 )

        countT  cbIgnoreP  = pc3p[ 2 ] ;
        flagsT  flagsModeP = pc3p[ 1 ] ;
        countT& bFailP     = pc3p[ 0 ] ;
        countT* pc3p       = (countT*)c3P ;
        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther && c3P )
    ZE( sCountT , sgn ) ;

    }
    {
    IFbEcAREFUL
{
/*1*/countT subtractJotsF( tin0S& tin0P , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/


/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

