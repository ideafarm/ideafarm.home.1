
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


DONE( tmRegisterPortF )
}
    if( POOP ) POOPR
    }
        if( POOP ) POOPR

        TELL( "tmRegisterPortF: cleaning up" )
        if( bSgnRegisteredVirgin ) sgnRegistered.giveF( tinBaseP ) ;
        }
            }
                ++ s ; ether.osSleepF( tinBaseP , TOCK * 40 ) ; // THIS IS USED RATHER THAN THE SIGN SO THAT CALLER REMAINS REGISTERED EVEN IF 1140104 DIES AND IS REPLACED
                sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
            {
    
            TELL( "in outer loop: sleeping for 04 tock" )
            }
                if( !idPort ) break ;
                }
                    bSgnRegisteredVirgin = 0 ;
                    sgnRegistered.giveF( tinBaseP ) ;
                {
                if( bSgnRegisteredVirgin )
                TELL( "in outer loop: cleaning up" )
                }
                    }
                        }
                            ++ s ; ether.osSleepF( tinBaseP , ru ) ;
                            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
                        {
                        TELL( "sleeping for ru time" )
                        POOPR
                    {
                    else
                    if( !POOP && !etThread ) bFail = 0 ;
        
                    }
                        sChat2.writeF( tinBaseP , soulo3 ) ;
                        TELL( "writing a ifcIDcMDsESSION_BYE soulC" )
                        soulC soulo3( tinBaseP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_BYE ) ;
        
                        __( idReply - ifcIDcMDsESSION_REGISTERiDpORTlOCALcHATrEPLY ) ;
                        souli2 >> idReply ;
                        ZE( countT , idReply ) ;
                        sChat2.readF( tinBaseP , souli2 ) ;
                        TELL( "reading a ifcIDcMDsESSION_REGISTERiDpORTlOCALcHATrEPLY soulC" )
                        soulC souli2( tinBaseP , TAG( TAGiDnULL ) ) ;
        
                        sChat2.writeF( tinBaseP , soulo2 ) ;
                        TELL( "writing a ifcIDcMDsESSION_REGISTERiDpORTlOCALcHAT soulC" )
                        soulo2 << idPort ;
                        soulo2 << processGlobal1I.idAdamRoot ;
                        soulC soulo2( tinBaseP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_REGISTERiDpORTlOCALcHAT ) ;
    
                        sChat2.connectF( tinBaseP , idPort2 ) ;
                        TELL( "connecting to the port that the local IdeaFarm " "(tm) chat server referred me to" )
                        socketC sChat2( tinBaseP , *((tinFullS&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) ) ;
        
                        }
                            souli >> idPort2 ;
                            __( idReply - ifcIDcMDsESSION_NEWsOCKETrEPLY ) ;
                            souli >> idReply ;
                            ZE( countT , idReply ) ;
                            sChat.readF( tinBaseP , souli ) ;
                            TELL( "reading a soulC from the local IdeaFarm " "(tm) chat server" )
                            soulC souli( tinBaseP , TAG( TAGiDnULL ) ) ;
        
                            sChat.writeF( tinBaseP , soulo ) ;
                            TELL( "writing a ifcIDcMDsESSION_NEWsOCKET soulC to the local IdeaFarm " "(tm) chat server" )
                            soulC soulo( tinBaseP , TAG( TAGiDnULL ) , flSOUL_null , ifcIDcMDsESSION_NEWsOCKET ) ;
        
                            sChat.connectF( tinBaseP , ifcPORToLD2_CHAT ) ;
                            TELL( "connecting to the local IdeaFarm " "(tm) chat server to get a port referral" )
                            socketC sChat( tinBaseP , *((tinFullS&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) ) ;
                        {
                        ZE( countT , idPort2 ) ;
                    {
                {
                while( !ether && !etThread && bFail )
                ranUniC ru( tinBaseP , TOCK * 8 ) ;
                boolT bFail = 1 ;
                TELL( "in outer loop, setting up *((tinFullS&)tinBaseP).pEtScratch ru" )
            {
            if( idPort )
    
            sgnIdPortReplaced.waitF( tinBaseP ) ;
            TELL( "waiting for sgnIdPortReplaced" )
        {
        while( !ether && !etThread )
        SCOOPS
    {
    IFsCRATCH

    boolT   bSgnRegisteredVirgin = 1 ;
    signC&  sgnRegistered      =  *(signC*)pTaskP->c3 ;
    countT& idPort             = *(countT*)pTaskP->c2 ;
    signC&  sgnIdPortReplaced  =  *(signC*)pTaskP->c1 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
/*1*/TASK( tmRegisterPortF )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

