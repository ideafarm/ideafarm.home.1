
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        //20221228@1019: DISABLED THIS SO CALLER CAN HANDLE GRACEFULLY: BLAMMO ;

        //THREADmODE4rESTORE
    
//        etRock.traceF( tinP , T("napkinC::napkinC: traced  pool tallies and memory grain report") ) ;
//        etRock.traceMemoryGrainRptF( tinP ) ;
//        etRock.tracePoolTalliesF( tinP ) ;
//        etRock.traceF( tinP , T("napkinC::napkinC: tracing pool tallies and memory grain report") ) ;
//        etRock.traceF( tinP , T("napkinC::napkinC: could not allocate pbNapkin [idLineCtP,idiFileCtP,cbP,postP]: ")+TF2(idLineCtP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(idiFileCtP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" ")+T(postP) ) ;

        //THREADmODE4oFF( flTHREADmODE4_SUPPRESStRACING )

        etherC& etRock = etherC::etRockIF( tinP ) ;
    {
    if( POOP || !pbNapkin )

    }
        TELLsYSc3LIFI( ifcIDtYPEtELLsYS_NAPKINaTTACH , (byteT*)&ti , sizeof ti , idLineCt , idiFileCt )
        ti.idiFileCt = idiFileCt ;
        ti.idLineCt  = idLineCt ;
        ti.cbData    = ((napkinHeaderS*)pbNapkin)->cbData ;
        ti.pbData    = pbNapkin + sizeof( napkinHeaderS ) ;    // IF flNAPKINc_DOnOTcOMMIT THEN MONITOR WILL DISCOVER THE HARD WAY THAT IT CANNOT READ THIS MEMORY
        ti.costName  = thirdC::c_strlenIF( tinP , ti.postName ) ;
        thirdC::c_strncpyIF( tinP , ti.postName , postName , sizeof ti.postName ) ;
        ti.osPid     = tinP.osPid ;
        tellInfoSysNapkinS ti ;
    {
    if( pbNapkin && F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED && this != &processGlobal4I.napHome ) //ASSUME: napHome IS CT WOTH
    
    }
        else if( *this != sizeof( countT ) * ( 4 + CCwORD ) ) { BLAMMO ; }
        }
            formattingIsDoneF( tinP ) ;
            //pch[ 4 ]                                      // BEGINNING OF BUFFER AREA (USED AS CIRCULAR BUFFER)
            pch[ 3 ] = CCwORD ;                             // CsLOTS (NUMBER OF WORDS CAPACITY)
            //pch[ 2 ]                                      // NUMBER OF WORDS WRITTEN (MIGHT WRAP)
            //pch[ 1 ]                                      // idThreadOwner (WILL BE SET BY THE CLAIMANT THREAD)
            putNegAM( pch[ 0 ] , FINGERnEG_NAPwORD ) ;      // FINGERPRINT
            thirdC::c_memsetIF( tinP , (byteT*)pch , *this ) ;
            //LOGrAW5( "formatting data area of word napkin that contains " , *this , " bytes (memory space " , rootAdamGlobal1I.idMemorySpace , ")\r\n" )
        {
        else if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
        if( !pch ) { BLAMMO ; }
        countT* pch = (countT*)(byteT*)*this ;
    {
    else if( bWord )
    }
        if( bNew ) processGlobal8I._socketC_napIpMapHome.formattingIsDoneF( tinP ) ;

        }
            }
                //LOGrAW( ostoLog ) ;
                //
                //OStEXTAK( ostoLog , " will be mapped to ports selected at run time rather than specified in code\r\n" ) ;
                //OStEXTC( ostoLog , etherC::ifc_idHomeIdisk_IF() , 0 ) ;
                //OStEXTAK( ostoLog , "/napkinC: home " ) ;
                //OStEXTC( ostoLog , tinP.pag1->idAdam , 0 ) ;
                //OStEXT( ostoLog , TUCK << 2 ) ;

                pMap->nnHome = nnHome ;
                thirdC::c_strncpyIF( tinP , pMap->postMxName     , postzMx     , sizeof pMap->postMxName     ) ;
                thirdC::c_strncpyIF( tinP , pMap->postDomainName , postzDomain , sizeof pMap->postDomainName ) ;
            {
            else
            }
                //LOGrAW5( "" , tinP.pag1->idAdam , "/napkinC: no mapping for home  " , etherC::ifc_idHomeIdisk_IF() , "\r\n" ) ;
                pMap->flagsHome |= flIPmAPhOMEs_NOmAPPING ;
            {
            if( !nnHome )

            }
                }
                    }
                        off += thirdC::c_strlenIF( tinP , posti + off ) + 1 ;
    
                        else      nnHome = thirdC::c_atoiIF( tinP , posti + off ) ; //U::SUPPORT IPv6
                        if( ppo ) *ppo = posti + off ;
    
                        else if( !postzMx     ) ppo = &postzMx     ;
                             if( !postzDomain ) ppo = &postzDomain ;
                        ZE( osTextT** , ppo ) ;
    
                        if( !posti[ off ] ) continue ;
                    {
                    for( countT off = 0 ; off < costi ; off ++ )
    
                    }}
                        if( thirdC::c_strchrIF( tinP , TbLACK , posti[ off ] ) ) posti[ off ] = 0 ;
                    {
                    {for( countT off = 0 ; off < costi ; off ++ )
                {
                if( costi )
    
                }
                    }
                        costi = 0 ;
                        POOPR ;
                    {
                    if( POOP )
                    THREADmODE2rESTORE
                    thirdC::dosReadIF( tinP , posti , costi , ostoName ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                    POOPIE
                {
                countT  costi = sizeof( posti ) ;
    
                OStEXTAK( ostoName , ".setting.keyValue.ipmap" ) ;
                OStEXTC(  ostoName , etherC::ifc_idHomeIdisk_IF() , 0 ) ;
                OStEXTAK( ostoName , "c" ":\\ideafarm.home." ) ;
                OStEXT(   ostoName , TUCK << 2 ) ;
            {
            nicNameC nnHome ;
            ZE( osTextT* , postzMx ) ;
            ZE( osTextT* , postzDomain ) ;
            osTextT posti[ TUCK ] ;
        {
        if( pMap && !pMap->nnHome && !( F(pMap->flagsHome) & flIPmAPhOMEs_NOmAPPING ) )

        }
            if( offm < CiPmAPhOME ) pMap = pMapArray + offm ;

            }
                }
                    if( !setIfZeAM( pMapArray[ offm ].idHome , etherC::ifc_idHomeIdisk_IF() ) ) break ;
                {
                for( offm = 0 ; offm < CiPmAPhOME ; offm ++ )
            {
            if( offm == CiPmAPhOME )

            }
                if( pMapArray[ offm ].idHome == etherC::ifc_idHomeIdisk_IF() ) break ;
            {
            for( offm = 0 ; offm < CiPmAPhOME ; offm ++ )
            ZE( countT , offm ) ;
    
            ipMapHomeS* const pMapArray = (ipMapHomeS*)(byteT*)processGlobal8I._socketC_napIpMapHome ;
        {
        else
        }
            }
                }
                    break ;
                    pMap = pMapArray + offm ;
                {
                if( !setIfZeAM( pMapArray[ offm ].idHome , etherC::ifc_idHomeIdisk_IF() ) )
            {
            for( countT offm = 0 ; offm < CiPmAPhOME ; offm ++ )
        
            ipMapHomeS* const pMapArray = (ipMapHomeS*)(byteT*)processGlobal8I._socketC_napIpMapHome ;
        {
        if( bNew )
        ZE( ipMapHomeS* , pMap ) ;
                
        }
            while( cToDo -- ) new( 0 , tinP , (byteT*)( pCursor ++ ) , sizeof( ipMapHomeS ) ) ipMapHomeS( tinP ) ;
            countT cToDo = CiPmAPhOME ;
            ipMapHomeS* pCursor = (ipMapHomeS*)(byteT*)*this ;
            bNew = 1 ;
        {
        if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
        ZE( boolT , bNew ) ;
    {
    else if( this == &processGlobal8I._socketC_napIpMapHome )
    }
        }
            formattingIsDoneF( tinP ) ;
            new( 0 , tinP , (byteT*)*this , sizeof( grabotC ) ) grabotC( tinP , idLineCt , idiFileCt , pbBitsCt , flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES | flGRABITc_SHARElAYER , 0 , ifcIDgRABlAYER_8POOL5nEW ) ;
            thirdC::c_memsetIF( tinP , (byteT*)*this , (countT)*this ) ;
        {
        if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
    {
    else if( this == &processGlobal8I._sexC_napGlobalRegistry )
    }
        }
            formattingIsDoneF( tinP ) ;
            thirdC::c_memsetIF( tinP , (byteT*)*this , (countT)*this ) ;
        {
        if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
    {
    else if( this == &processGlobal5I._marketC_napGoodRegistry )
    }
        ph->grabSuperRandom.flags &= ~( F(flGRABc_DISABLED) ) ;
        ph->grabTimeUnique.flags  &= ~( F(flGRABc_DISABLED) ) ;
        homeS* ph = (homeS*)(byteT*)processGlobal4I.napHome ;
    
        }
            formattingIsDoneF( tinP ) ;

            //LOGrAW3( "ct'ed all grabWantS in array [cgw]:    " , processGlobal2I._grabC_cgw , "\r\n" ) ; //U:: TO FIND A BUG
            //CONoUTrAW3( "ct'ed all grabWantS in array [cgw]:    " , processGlobal2I._grabC_cgw , "\r\n" ) ; //U:: TO FIND A BUG

            }
                new( 0 , tinP , (byteT*)( processGlobal2I._grabC_pgw + ogw ) , sizeof( grabWantS ) ) grabWantS( tinP ) ;

                }
                    countT foo = 2 ;
                {
                if( ogw == 0x1a56 )
                //CONoUTrAW5( "" , processGlobal2I._grabC_cgw , "    " , ogw , "\r\n" ) ; //U:: 20221024@0859 TO FIND A BUG
            {
            for( countT ogw = 0 ; ogw < processGlobal2I._grabC_cgw ; ogw ++ )

            //LOGrAW3( "ct'ing all grabWantS in array [cgw]:    " , processGlobal2I._grabC_cgw , "\r\n" ) ; //U:: TO FIND A BUG
            //CONoUTrAW3( "ct'ing all grabWantS in array [cgw]:    " , processGlobal2I._grabC_cgw , "\r\n" ) ; //U:: TO FIND A BUG

            thirdC::c_memsetIF( tinP , (byteT*)processGlobal2I._grabC_pgw , *this ) ;
        {
        if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
    
        if( setIfZeAM( *(countT*)&processGlobal2I._grabC_pgw , (countT)(byteT*)*this ) ) { BLAMMO ; }
        if( processGlobal2I._grabC_cgw * sizeof( grabWantS ) - cbP ) { BLAMMO ; }
    {
    else if( this == &processGlobal4I._grabC_napGrabWant )
    }
        processGlobal1I.pSlab = (slabS*)(byteT*)*this ;

        //}
        //    CONoUTrAW3( "\r\nnot formatting slab [id PortUdpFileCatcher]:    " , ps->id PortUdpFileCatcher , "\r\n" ) ;
        //{
        //else
        else if( *this != sizeof( slabS ) ) { BLAMMO ; }
        }
            formattingIsDoneF( tinP ) ;
            new( 0 , tinP , (byteT*)*this , sizeof( slabS ) ) slabS ;
            //CONoUTrAW( "\r\nformatting slab\r\n" ) ;
        {
        else if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
        if( !ps ) { CONoUTrAW( "napkinC::napkinC/napSlab/ps is null\r\n" ) ; BLAMMO ; }
        slabS* ps = (slabS*)(byteT*)*this ;
    {
    else if( this == &processGlobal4I.napSlab )
    }
        //CONoUTrAW( ostol ) ;
        //OStEXTAK( ostol , "\r\n" )
        //OStEXTC( ostol , rootAdamGlobal1I.idMemorySpace , 0 )
        //OStEXTAK( ostol , " idMemorySpace: " )
        //OStEXT( ostol , 0x80 )

        processGlobal1I.pHome = (homeS*)(byteT*)*this ;

        }
            }
                new( 0 , tinP , (byteT*)&processGlobal5I.bMemorySpace , sizeof processGlobal5I.bMemorySpace ) batonC( tinP , TAG( TAGiDnULL ) , "bMemorySpace" , ifcIDgRABlAYER_eGRABmEMORYsPACEc | flBATONc_NOTjEALOUS , flBATONc_DOnOTsERIALIZEnAPKIN ) ;
                DELzOMBIE( pbu ) ;
                batonC* pbu = &processGlobal5I.bMemorySpace ;
            {
            if( !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT ) )

            new( 0 , tinP , (byteT*)&processGlobal4I.grabMemorySpace , sizeof processGlobal4I.grabMemorySpace ) grabMemorySpaceC( tinP , ifcIDgRABlAYER_eGRABmEMORYsPACEc ) ;
            DELzOMBIE( pgu ) ;
            grabMemorySpaceC* pgu = &processGlobal4I.grabMemorySpace ;
        {
        if( bMemorySpaceChanged )

        //CONoUTrAW5( "napkinC::napkinC/napHome/[idCell,idMemorySpace]: " , rootAdamGlobal1I.idCell , " " , rootAdamGlobal1I.idMemorySpace , "\r\n" ) ;

        }
            }
                break ;
                //conGF( "memory space changed\r\n" ) ;
                bMemorySpaceChanged = 1 ;
                *(countT*)&tinP.pag1->idMemorySpace = ifcIDmEMORYsPACE_WATCH ;
            {
            case ifcIDaDAM_PREPARElISTS : //THIS LINE FACILITATES DEBUGGING AND HAS NO EFFECT IN PRODUCTION
            case ifcIDaDAM_WATCHiDLEcPU :
            case ifcIDaDAM_WATCH :
            }
                break ;
                //conGF( "memory space changed\r\n" ) ;
                bMemorySpaceChanged = 1 ;
                *(countT*)&tinP.pag1->idMemorySpace = ifcIDmEMORYsPACE_MEMBRANE ; //ifcIDmEMORYsPACE_MEMBRANE IS WRITTEN BY GLASS2 AND READ BY ifcIDaDAM_MEMBRANEgLASS; NO OTHER PROCESS MAY ACCESS THE MEMBRANE SPACE
            {
            case ifcIDaDAM_MEMBRANEgLASS :
            //case 0x4010fff : //REMOVE IN PRODUCTION
            }
                break ;
                //conGF( "memory space changed\r\n" ) ;
                bMemorySpaceChanged = 1 ;
                *(countT*)&tinP.pag1->idMemorySpace = ifcIDmEMORYsPACE_GLASS2 ; //ifcIDmEMORYsPACE_GLASS2 IS RESERVED FOR THE EXCLUSIVE USE OF GLASS2
            {
            case ifcIDaDAM_2GLASS2 :
            case ifcIDaDAM_1DRIVER :
            }
                break ;
                //conGF( "memory space changed\r\n" ) ;
                bMemorySpaceChanged = 1 ;
                *(countT*)&tinP.pag1->idMemorySpace = ifcIDmEMORYsPACE_GLASS1 ; //ifcIDmEMORYsPACE_GLASS1 IS RESERVED FOR THE EXCLUSIVE USE OF GLASS1
            {
            case ifcIDaDAM_GLASS1 :
            }
                break ;
                //conGF( "memory space changed\r\n" ) ;
                bMemorySpaceChanged = 1 ;
                *(countT*)&tinP.pag1->idMemorySpace = ifcIDmEMORYsPACE_CLOAK ; //ifcIDmEMORYsPACE_CLOAK IS RESERVED FOR THE EXCLUSIVE USE OF ifcIDaDAM_CLOAK (ANTI-MALWARE SYSTEM INTEGRITY CHECKER)
            {
            case ifcIDaDAM_CLOAK :
        {
        switch( processGlobal1I.idAdamRoot )
        ZE( boolT , bMemorySpaceChanged ) ;

        //conGF( "\r\n" ) ;
        //conGF( processGlobal1I.idAdamRoot ) ;
        //conGF( "napkinC [idAdamRoot]: " ) ;

        //}
        //    thirdC::osSelectProcessorsIF( tinP , idType ) ;
        //    ;
        //            : ifcIDtYPEtHREAD_SHOWpONY
        //            ? ifcIDtYPEtHREAD_GLASS2
        //        : rootAdamGlobal1I.idCell < 3
        //        ? ifcIDtYPEtHREAD_WORKhORSE
        //    countT idType = etherC::ifc_idHomeI_IF() & fliIDhOME_HOMELESS || etherC::ifc_idHomeIdisk_IF() < 0x100
        //{
        //20170213@1454: COMMENTED OUT WITHOUT ANALYSIS TO PERHAPS FIX UNEXPECTED PROCESSOR AFFINITY FOR GLASS2 ADAM

        *(countT*)&rootAdamGlobal1I.idCell = 1 + incv02AM( ph->idCellLath ) ;

        //}
        //    CONoUTrAW3( "\r\nprocessGlobal4I.napHome: existed [pc Utility[0]]:    " , ph->pc Utility[ 0 ] , "\r\n" ) ; //U:: TO FIND A BUG
        //{
        //else    
        else if( *this != sizeof( homeS ) ) { BLAMMO ; }
        }
            formattingIsDoneF( tinP ) ;
            new( 0 , tinP , (byteT*)*this , sizeof( homeS ) ) homeS( tinP ) ;
            //CONoUTrAW( "\r\nprocessGlobal4I.napHome: did not exist so is being formatted\r\n" ) ; //U:: TO FIND A BUG
        {
        else if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )
        if( !ph ) { CONoUTrAW( "napkinC::napkinC/napHome/ph is null\r\n" ) ; BLAMMO ; }
        homeS* ph = (homeS*)(byteT*)*this ;
    {
    else if( this == &processGlobal4I.napHome )
    if( POOP ) ;
    // FORMAT THE INSTANCES CONSTRUCTED DURING CT OF PROCESS GLOBALS

    }
        }
            thirdC::dosPriorityIF( tinP , idDesireCtSave ) ;
            tinP.cYield = 0 ;
    
            //THREADmODE4oFF( flTHREADmODE4_SUPPRESStRACING )

            }
                }
                    ++ s ; thirdC::dosSleepWinkIF( tinP ) ;
                {
                while( getNegAM( ((napkinHeaderS*)pbNapkin)->bFormatted ) != FINGERnEG_NAPKINiSfORMATTED )
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            else
            }
                //CONoUTrAW( "\r\n" ) ;
                //CONoUTrAW( postP ) ;
                //CONoUTrAW( "memory space ungrabbed:  " ) ;
                THREADmODE5rESTORE0( flThreadMode5Save )
                pzbMemorySpaceUse->ungrabF( tinP ) ;
            {
            if( !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT ) )

            }
                //LOGrAW(   ostoSay ) ;
                //OStEXTAK( ostoSay , "\r\n" ) ;
                //OStEXTA(  ostoSay , postName ) ;
                //OStEXTAK( ostoSay , "    " ) ;
                //OStEXTC(  ostoSay , idMemorySpaceP ? idMemorySpaceP : tinP.pag1->idMemorySpace , '0' ) ;
                //OStEXTAK( ostoSay , "    " ) ;
                //OStEXTC(  ostoSay , tinP.pag1->idAdam , '0' ) ;
                //OStEXTAK( ostoSay , "    " ) ;
                //OStEXTC(  ostoSay , ((napkinHeaderS*)pbNapkin)->cRef , '0' ) ;
                //OStEXTAK( ostoSay , "napkinC 3: ++++ [cRef after ++++    ,idAdam,postP]:    " ) ;
                //OStEXT(   ostoSay , TUCK ) ;
                //TO FIND A BUG

                inc02AM( ((napkinHeaderS*)pbNapkin)->cRef ) ;

                }
                    BLAMMO ;
                    //tinP.pc Utility[ 3 ] = ((napkinHeaderS*)pbNapkin)->cRef ;
                    //tinP.pc Utility[ 2 ] = ((napkinHeaderS*)pbNapkin)->cRef ;
                    //tinP.pc Utility[ 1 ] = ((napkinHeaderS*)pbNapkin)->cRef ;
                    //tinP.pc Utility[ 0 ] = ((napkinHeaderS*)pbNapkin)->cRef ;

                    //LOGrAW(   ostoSay ) ;
                    //OStEXTAK( ostoSay , "\r\n" ) ;
                    //OStEXTA(  ostoSay , postName ) ;
                    //OStEXTAK( ostoSay , "    " ) ;
                    //OStEXTC(  ostoSay , idMemorySpaceP ? idMemorySpaceP : tinP.pag1->idMemorySpace , '0' ) ;
                    //OStEXTAK( ostoSay , "    " ) ;
                    //OStEXTC(  ostoSay , tinP.pag1->idAdam , '0' ) ;
                    //OStEXTAK( ostoSay , "    " ) ;
                    //OStEXTC(  ostoSay , ((napkinHeaderS*)pbNapkin)->cRef , '0' ) ;
                    //OStEXTAK( ostoSay , "napkinC 2: ++++ [cRef BEFORE ++++ !!!,idAdam,postP]:    " ) ;
                    //OStEXT(   ostoSay , TUCK ) ;
                    //TO FIND A BUG
                {
                if( (sCountT)((napkinHeaderS*)pbNapkin)->cRef < 0 )  //IT MIGHT BE 0, BUT IT SURE AS HELL BETTER NOT BE NEGATIVE!

                //if( !((napkinHeaderS*)pbNapkin)->cRef       ) { BLAMMO ; }
                //CANNOT TEST FOR THIS BECAUSE RACE; ANOTHER THREAD MIGHT HAVE JUST DEC BUT NOT YET CLOSED HANDLE: 
            {
            if( !( F(flagsCt) & flNAPKINc_DOnOTcOMMIT ) )

            //}
            //    CONoUTrAW( "\r\n" ) ;
            //    CONoUTrAW(  postP ) ;
            //    CONoUTrAW( "\r\nnapkinC / shared memory         existed [postP]:    " ) ;
            //{
            //if( thirdC::c_strstrIF( tinP , postP , "home.temp." ) )
        {
        else                                                                                // THE SHARED MEMORY ALREADY EXISTED
        }
            }
                //THREADmODE4oFF( flTHREADmODE4_SUPPRESStRACING )

                }
                    //20240813@1644: UNGRAB MOVED TO HERE
                {
                if( !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT ) )          //20201030@1142: BUG?: CONJ: SHOULD NOT BE UNGRABBING HERE (MUST REMAIN GRABBED UNTIL formattingIsDoneF IS CALLED)
            {
            else
            }
                //LOGrAW(   ostoSay ) ;
                //OStEXTAK( ostoSay , "\r\n" ) ;
                //OStEXTA(  ostoSay , postName ) ;
                //OStEXTAK( ostoSay , "    " ) ;
                //OStEXTC(  ostoSay , idMemorySpaceP ? idMemorySpaceP : tinP.pag1->idMemorySpace , '0' ) ;
                //OStEXTAK( ostoSay , "    " ) ;
                //OStEXTC(  ostoSay , tinP.pag1->idAdam , '0' ) ;
                //OStEXTAK( ostoSay , "    " ) ;
                //OStEXTC(  ostoSay , ((napkinHeaderS*)pbNapkin)->cRef , '0' ) ;
                //OStEXTAK( ostoSay , "napkinC 1: +**+ [cRef after set to 1,idAdam,postP]:    " ) ;
                //OStEXT(   ostoSay , TUCK ) ;
                //TO FIND A BUG

                ((napkinHeaderS*)pbNapkin)->bFormatted = 0   ;
                ((napkinHeaderS*)pbNapkin)->cRef       = 1   ;
                ((napkinHeaderS*)pbNapkin)->cbData     = cbP ;
            {
            if( !( F(flagsCt) & flNAPKINc_DOnOTcOMMIT ) )

            //}
            //    CONoUTrAW( "\r\n" ) ;
            //    CONoUTrAW(  postP ) ;
            //    CONoUTrAW( "\r\nnapkinC / shared memory did not exist   [postP]:    " ) ;
            //{
            //if( thirdC::c_strstrIF( tinP , postP , "home.temp." ) )
        {
        if( !( F(flagsSharedMemory) & flOPENsHAREDmEMORYrESULT_ALREADYeXISTED ) )           // I CREATED THE SHARED MEMORY
        //CS:CODEsYNC: 3603e003 3603e007
    {
    else
    }
        thirdC::dosPriorityIF( tinP , idDesireCtSave ) ;
        tinP.cYield = 0 ;

        //THREADmODE4oFF( flTHREADmODE4_SUPPRESStRACING )
        }
            //CONoUTrAW( "\r\n" ) ;
            //CONoUTrAW( postP ) ;
            //CONoUTrAW( "memory space ungrabbed:  " ) ;
            THREADmODE5rESTORE0( flThreadMode5Save )
            pzbMemorySpaceUse->ungrabF( tinP ) ;
        {
        if( !pbNapkin && !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT ) )         // IF pbNapkin THEN CALLER MUST CALL formattingIsDoneF, WHICH WILL UNGRAB, UNLESS I HAVE ALREADY MADE THAT CALL
    {
    if( POOP || !pbNapkin )
    
    }
        __( bFail ) ;

        if( bNoQuit ) { __Z( pbNapkin ) ; }
    
        }
            BLAMMO
            //DOES NOT WORK:LOGrAW3( "napkinC::napkinC: blammo [cbP]: " , cbP , "\r\n" ) ;
        {
        if( POOP )

        }
            BLAMMO ; // I DO THIS TO FORCE THE FUNCTIONS THAT I CALL TO DELIVER A SENSIBLE RESULT
        {
        if( bFail && pbNapkin )
    
        }
            }
                //THREADmODE4rESTORE

//                etRock.traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;

                etherC& etRock = etherC::etRockIF( tinP ) ;

                OStEXTC(  ostoSay , save , 0 ) ;
                OStEXTAK( ostoSay , "    " ) ;
                OStEXTC(  ostoSay , cTriesP , 0 ) ;
                OStEXTAK( ostoSay , "    " ) ;
                OStEXTC(  ostoSay , cbData , 0 ) ;
                OStEXTAK( ostoSay , "napkinC::napkinC / could not allocate [cbData,cTries,POOP]:    " ) ;
                OStEXT(   ostoSay , TUCK << 0 ) ;

                //THREADmODE4oFF( flTHREADmODE4_SUPPRESStRACING )

                POOPRqUIET
                countT save = POOP ;
            {
            if( POOP )

            THREADmODE2rESTORE ;
            bFail = !!POOP ;
            }
                }
                    else break ;
                    }
                        //BLAMMO ; //U:: TO FIND A BUG 20171201@1438

                        thirdC::dosSleepRWinkIF( tinP ) ;

                        //THREADmODE4rESTORE

                        etRock.traceMemoryGrainRptF( tinP ) ;
                        etRock.tracePoolTalliesF( tinP ) ;

//                        etRock.traceF( tinP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;

                        etherC& etRock = etherC::etRockIF( tinP ) ;

                        OStEXTA(  ostoSay , postName ) ;
                        OStEXTAK( ostoSay , "    " ) ;
                        OStEXTC(  ostoSay , cTriesP , 0 ) ;
                        OStEXTAK( ostoSay , "    " ) ;
                        OStEXTC(  ostoSay , cbData , 0 ) ;
                        OStEXTAK( ostoSay , "napkinC::napkinC / tracing pool tallies and memory grain report then napping for a wink [cbData,cTries]:    " ) ;
                        OStEXT(   ostoSay , TUCK << 2 ) ;

                        //THREADmODE4oFF( flTHREADmODE4_SUPPRESStRACING )

                        LOGcALLnEST( "!exception: napkinC::napkinC / could not open shared memory" ) ;
                        LOGrAW( "\r\n" ) ;
                        LOGrAW( postName ) ;
                        LOGrAW( "\r\nnapkinC::napkinC [postName]:    " ) ;

                        TRACEcALLnEST( "!exception: napkinC::napkinC / could not open shared memory" ) ;

                        //20240813@1644: UNGRAB MOVED FROM HERE

                        POOPRqUIET
                        ++ s ;
                    {
                    )
                        )
                            )
                                -- cTriesP
                                &&
                                cTriesP
                            (
                            ||
                            )
                                !thirdC::thPrimeIF( tinP )
                                &&
                                thirdC::thPrimeExistsIF( tinP )                      // thPrimeExistsIF( tinP ) IS CHECKED BECAUSE IT WILL BE 0 WHEN I AM CALLED TO CONSTRUCT poolOldRoot AND poolOld (AFTER poolC IS EDITED TO USE napkinC)
                                &&
                                bNoQuitEarly
                            (
                            ||
                            bNoQuit
                        (
                        &&
                        POOP
                    (
                    if

                    }
                        if( cNote ) pbNapkin = (byteT*)cNote + cbaHeader - sizeof( napkinHeaderS ) ;
                        countT cNote = hNapkin.cNoteF() ;
                    {
                    if( !POOP )

                    }
                        BLAMMO ;
                    {
                    if( POOP && ~hNapkin )

                    thirdC::dosOpenSharedMemIF( tinP , hNapkin , (flagsT&)flagsSharedMemory , postName , phFileP , cbP ? cbaHeader + cbP : 0 , idHowP , idMemorySpaceP , flagsOpen | flOPENsHAREDmEMORY_DOnOTsERIALIZE ) ;

                    //20240813@1644: GRAB MOVED FROM HERE

                    //CONoUTrAW( ostoSay ) ;
                    ////processGlobal4S::_processGlobal4I_IF().bksTrace.writeF( tinP , ostoSay , thirdC::c_strlenIF( tinP , ostoSay ) , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                    //OStEXTC(  ostoSay , cbP+cbaHeader , 0 ) ;
                    //OStEXTAK( ostoSay , "    " ) ;
                    //OStEXTC(  ostoSay , cbaHeader , 0 ) ;
                    //OStEXTAK( ostoSay , "    " ) ;
                    //OStEXTC(  ostoSay , cbP , 0 ) ;
                    //OStEXTAK( ostoSay , "\r\nnapkinC::napkinC [cbData,cbHeader,cbAlloc]:    " ) ;
                    //OStEXT(   ostoSay , TUCK << 2 ) ;
                {
                for(;;)
                sleepC s( tinP , TAG( TAGiDnULL ) ) ;
            {
            POOPIE
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING ) ;
        {
        ZE( boolT , bFail ) ;
        boolT bNoQuitEarly = !cTriesP ;
        boolT bNoQuit = cTriesP == - 1 ;
    {

    }
        //CONoUTrAW( "\r\n" ) ;
        //CONoUTrAW( postP ) ;
        //CONoUTrAW( "memory space GRABBED:  " ) ;
        pzbMemorySpaceUse->grabF( tinP , TAG( TAGiDnULL ) ) ;
        THREADmODE5oN0( flTHREADmODE5_INoUTfRAMEdEFERwRITINGaPPtELEMETRY )
        THREADmODE5sAVE0( flThreadMode5Save )
        tinP.flushPendingInOutFrameTelemetryIfF() ;
    {
    if( !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT ) )
    //20240813@1644: GRAB MOVED TO HERE

    thirdC::c_strncpyIF( tinP , postName , ostoNapkinName , sizeof postName ) ;

    ;
        : sizeof( napkinHeaderS )
        ? 1 << thirdC::os_expCbPage_IF( tinP )
    const countT cbaHeader = F(flagsCt) & flNAPKINc_PAGEaLIGNdATA

    tinP.cYield = 0 ;
    thirdC::dosPriorityIF( tinP , ifcTHREADpRIORITY_SPINLOCK ) ;

    }
        if( !POOP ) pzbMemorySpaceUse = pbMemorySpaceOverride ;
        __Z( pbMemorySpaceOverride ) ;
        pbMemorySpaceOverride = new( 0 , tinP , pbz_bMemorySpaceOverride , sizeof pbz_bMemorySpaceOverride ) batonC( tinP , TAG( TAGiDnULL ) , "bMemorySpace" , ifcIDgRABlAYER_eGRABmEMORYsPACEc , flBATONc_DOnOTsERIALIZEnAPKIN | flBATONc_NOTjEALOUS , 0 , 0 , idMemorySpaceP ) ;

        //}
        //    countT foo = 2 ;
        //{
        //if( idIn == 2 )
        //CONoUTrAW3( "napkinC [idIn]: " , idIn , "\r\n" ) ;
        //countT idIn = 1 + incv02AM( idInLath ) ;
        //static countT idInLath ;
    {
    )
        )
            F(flagsCt) & flNAPKINc_USEgRABmEMORYsPACEoVERRIDE
            ||
            ( idMemorySpaceP && idMemorySpaceP != tinP.pag1->idMemorySpace )
        (
        &&
        !( F(flagsCt) & flNAPKINc_DOnOTsERIALIZEcT )
    (
    if

    //}
    //    //LOGrAW( "\"\r\n" ) ;
    //    //LOGrAW( ostoNapkinName ) ;
    //{
    //if( thirdC::c_strstrIF( ostoNapkinName , "sexC/data/" ) )
        
    }
        OStEXTC( ostoNapkinName , tinP.osPid , 0 ) ;
        OStEXTAK( ostoNapkinName , "." ) ;
    {
    else if( bSexReg )      //U:: THIS IS A WORKAROUND TO ELIM OVERFLOW WHEN HAVE MANY PROCESS INSTANCES OF THE SAME ADAM ; THE WORKAROUND DEFEATS THE IDEA OF A GLOBAL REGISTRY
    }
        //CONoUTrAW( "\r\n" )
        //CONoUTrAW( ostoNapkinName )
        
        //LOGrAW( "\r\n" )
        //LOGrAW( ostoNapkinName )
        
        OStEXTC( ostoNapkinName , ++ idLath , 0 ) ;
        OStEXTAK( ostoNapkinName , "." ) ;
        OStEXTC( ostoNapkinName , tinP.osPid , 0 ) ;
        OStEXTAK( ostoNapkinName , "." ) ;
        OStEXTC( ostoNapkinName , processGlobal1I.idAdamRoot , 0 ) ;
        
        static countT idLath ;
    {
    if( bWord )

    const boolT bSexReg = &processGlobal8I._sexC_napGlobalRegistry == this ;

    const boolT bWord   = &processGlobal7I.napWord1 <= this && this <= &processGlobal7I.napWord2 ; //CODEsYNC: 15e0003 0a00001

    //}
    //    }
    //        //U::THINK ABOUT HOW BEST TO ALLOW MONITOR TO KISS GRABBERS WHO REGISTERED THEMSELVES IN OTHER SPACES
    //        idMemorySpaceP = ifcIDmEMORYsPACE_APPLICATION ;
    //    {
    //    if( idMemorySpaceP == ifcIDmEMORYsPACE_GLASS2 )
    //{
    //if( this == &processGlobal4I._grabC_napGrabWant )

    //if( !idMemorySpaceP ) idMemorySpaceP = tinP.pag1->idMemorySpace ;
    //20200417@1855: KEEP idMemorySpaceP NULL SO THAT CALLER DOES NOT HAVE TO SET flTHREADmODE4_ALLOWeXPLICITmEMORYsPACE

    //}
    //    cbP += sizeof( countT ) ;
    //
    //    if( !cbP ) cbP = CBdROPmEANdEFAULT ;
    //
    //    }
    //        }
    //            }
    //                }
    //                    if( off ) cbP <<= 4 ;
    //
    //                    else break ;
    //                    else if( post9[ off ] >= 'a' && post9[ off ] <= 'f' ) cbP += 0xa + post9[ off ] - 'a' ;
    //                         if( post9[ off ] >= '0' && post9[ off ] <= '9' ) cbP +=       post9[ off ] - '0' ;
    //                {
    //                for( sCountT off = cbToRead - 1 ; off >= 0 ; off -- )
    //            {
    //            if( cbToRead == 8 )
    //            thirdC::fileReadIF( tinP , post9 , cbToRead , ostoFileName ) ;
    //            thirdC::c_memsetIF( tinP , post9 , sizeof post9 ) ;
    //            osTextT post9[ 0x9 ] ;
    //            if( cbToRead > 8 ) cbToRead = 8 ;
    //        {
    //        if( !bFail )
    //
    //        }
    //            bFail = !!POOP ;
    //            tinP.flagsThreadMode2 = fSave ;
    //            cbToRead = thirdC::fileReadIF( tinP , 0 , cbRead , ostoFileName ) ;
    //            tinP.flagsThreadMode2 |= flTHREADmODE2_QUIETiMPOTENCE ;
    //            flagsT fSave = tinP.flagsThreadMode2 ;
    //            ZE( countT , cbRead ) ;
    //            POOPIE
    //        {
    //        ZE( countT , cbToRead ) ;
    //        ZE( boolT , bFail ) ;
    //    {
    //{
    //if( !cbP && !thirdC::c_strcmpIF( tinP , postP , "root" ) )
    //
    //OStEXTAK( ostoFileName , ".setting.keyValue.cbPoolRoot" ) ;
    //OStEXTC( ostoFileName , etherC::ifc_idHomeIdisk_IF() , 0 ) ;
    //OStEXTAK( ostoFileName , "c" ":\\ideafarm.home." ) ;
    //OStEXT( ostoFileName , TUCK << 2 )
    //U::CONJ: OBSOLETED BY REWRITE OF poolC

    if( F(flagsCt) & flNAPKINc_DOnOTcOMMIT     ) *(flagsT*)&flagsOpen |= flOPENsHAREDmEMORY_DOnOTcOMMIT     ;
    if( F(flagsCt) & flNAPKINc_LOCK            ) *(flagsT*)&flagsOpen |= flOPENsHAREDmEMORY_LOCK            ;
    if( F(flagsCt) & flNAPKINc_ALLmEMORYsPACES ) *(flagsT*)&flagsOpen |= flOPENsHAREDmEMORY_ALLmEMORYsPACES ;
    if( F(flagsCt) & flNAPKINc_ALLhOMES        ) *(flagsT*)&flagsOpen |= flOPENsHAREDmEMORY_ALLhOMES        ;
    if( F(flagsCt) & flNAPKINc_ALLuSERS        ) *(flagsT*)&flagsOpen |= flOPENsHAREDmEMORY_ALLuSERS        ;
    if( F(flagsCt) & flNAPKINc_ALLsESSIONS     ) *(flagsT*)&flagsOpen |= flOPENsHAREDmEMORY_ALLsESSIONS     ;

    if( F(flagsCt) & flNAPKINc_PAGEaLIGNdATA ) { BLAMMO ; } //U::BUG: 20170121@1439: SOME CODE DOES NOT SUPPORT THIS BECAUSE DATA IS ASSUMED TO IMMEDIATELY FOLLOW THE HEADER

    ;
        : flOPENsHAREDmEMORY_null
        ? flOPENsHAREDmEMORY_READoNLY
    const flagsT flagsOpen = F(flagsCt) & flNAPKINc_READoNLY

    OStEXTA(  ostoNapkinName , postP ) ;
    OStEXTAK( ostoNapkinName , "//napkinC/" ) ;
    OStEXT(   ostoNapkinName , COSTnAPKINnAMEmAX )

    }
        if( POOP ) BLAMMO ;
        __( idMemorySpaceP && !( F(tinP.flagsThreadMode4) & flTHREADmODE4_ALLOWeXPLICITmEMORYsPACE ) && thirdC::third_idPhaseAdam_IF( tinP ) >= ifcIDpHASEaDAM_EXEpROLOGaDAMmAIN1 && thirdC::third_idPhaseAdam_IF( tinP ) < ifcIDpHASEaDAM_EXEePILOGaDAMmAINa1 ) ;
        if( POOP ) BLAMMO ; //U:: TO FIND A BUG
        //__( F(tinP.flagsThreadMode4) & flTHREADmODE4_SUPPRESStRACING ) ;  // I USE THIS FLAG IN A WAY THAT DOES NOT SUPPORT RECURSION (I AND formattingIsDoneF RESET THE FLAG RATHER THAN USE RESTORE)
        if( POOP ) BLAMMO ; //U:: TO FIND A BUG
        FV(flNAPKINc,flagsCt)
        if( POOP ) BLAMMO ; //U:: TO FIND A BUG
        __( phFileP && F(flagsCt) & flNAPKINc_DOnOTcOMMIT ) ;
        if( POOP ) BLAMMO ; //U:: TO FIND A BUG
        __Z( idHowP ) ;
        if( POOP ) BLAMMO ; //U:: TO FIND A BUG
        __Z( postP ) ;
        if( POOP ) BLAMMO ;
    {
    IFbEcAREFUL

    //if( tinP.pc Utility[ 0 ] ) thirdC::third_pcDebugI_IF( tinP ) ; //U:: SHOULD BE COMMENTED OUT IN PRODUCTION; TO FACILITATE DEBUGGING USING WDW

    else            thirdC::c_memsetIF( tinP , (byteT*)pbBitsCt , sizeof pbBitsCt ) ;
    if( pbBitsCtP ) thirdC::c_memcpyIF( tinP , (byteT*)pbBitsCt , (byteT*)pbBitsCtP , sizeof pbBitsCt ) ;

    THREADmODE5rESTORE0( flagsSave4 ) ;
    _IO_                                                         // EARLY SO THAT napkinC BEHAVIOR CANNOT BE AFFECTED BY FOREIGN IMPOTENCE      U::20201112@1927: THIS COMMENT MAKES NO SENSE
    THREADmODE5oN0( flTHREADmODE5_INoUTfRAMEdEFERwRITINGaPPtELEMETRY ) ;
    THREADmODE5sAVE0( flagsSave4 ) ;
    ZE( flagsT , flagsSave4 ) ;
    tinP.flushPendingInOutFrameTelemetryIfF() ;
    // THE EFFECT OF THIS CODE IS THAT MY _IO_ NEVER EMITS TELEMETRY
    // inOutFrameC TELEMETRY BEHAVIOR IS DETERMINED BY THE STATE OF THE FLAG DURING CT, EVEN THOUGH EMISSION OCCURS DURING DT
    // THIS IS NEEDED BECAUSE NORMALLY I SET flTHREADmODE5_INoUTfRAMEdEFERwRITINGaPPtELEMETRY SINCE I GRAB THE MEMORY SPACE AND EXIT WITH IT STILL GRABBED (TO BE UNGRABBED BY formattingIsDoneF)

    //}
    //    }
    //        countT foo = 2 ;
    //    {
    //    if( idIn == 3 )
    //    CONoUTrAW3( "\r\n[idIn]:    " , idIn , "\r\n" ) ;
    //    countT idIn = 1 + incv02AM( idInLath ) ;
    //    static countT idInLath ;
    //{
    //if( tinP.pcUtility[ 0 ] )

    SCOOP
{
idMemorySpace( idMemorySpaceP ? idMemorySpaceP : tinP.pag1->idMemorySpace )
phFile( phFileP ) ,
flagsState( F(flagsP) & flNAPKINc_DOnOTcOMMIT ? flNAPKINcsTATE_NOTyETcOMMITTED : flNAPKINcsTATE_null ) ,
flThreadMode5Save( flTHREADmODE5_null ) ,
idDesireCtSave( thirdC::dosPriorityIF( tinP ) ) ,
osTidCt( tinP.osTid ) ,
pzbMemorySpaceUse( &processGlobal5I.bMemorySpace ) ,
pbMemorySpaceOverride( 0 ) ,
bDataAreaFormatted( 0 ) ,
flagsSharedMemory( 0 ) ,
cbData( cbP ) ,
pbNapkin( 0 ) ,
hNapkin( tinP , idLineCtP , idiFileCtP , (byteT*)bitsC( tinP , CbITSlIFI , 0 , (countT)(0+1) ) , ifcIDtYPEhANDLE_SHAREDmEMORY ) ,
flagsCt( flagsP ) ,
idiFileCt( idiFileCtP ) ,
idLineCt( idLineCtP ) ,
/*1*/napkinC::napkinC( tinS& tinP , const countT idLineCtP , const countT idiFileCtP , const byteT* const pbBitsCtP , const osTextT* const postP , const handleC* const phFileP , countT cbP , const countT idHowP , const flagsT flagsP , countT cTriesP , countT idMemorySpaceP )/*1*/ :

/**/
*/
  normal apps never specify a value other than -1, 0, or 1
  > 0: the number of times that i should try before quitting
  0: no quit early: will not quit unless etPrimeIF() is impotent (the adam has been fired)
  - 1: no quit (even when the adam has been fired)
 cTriesP
 flagsP
  can be 0
 cbP
 idHowP
 postP
 ecP
   TAG creates a bitsC instance that is dt as soon as i return, resulting in a non lifo d elete on the tls, which is illegal (enforced)
   i create a tls item that is not dt until i am dt
  if idMemorySpaceP and idMemorySpaceP is not the default memory space then TAG() cannot be used
 pbBitsCtP
 idiFileCtP
 idLineCtP
 tinP
arguments
warning: application code must verify that "operator byteT*()" returns a nonze value, unless cTriesP == -1 is specified
the calling code -must- call formattingIsDoneF after constructing me to indicate that it has finished formatting the data area
\<A HREF=\"5.15e0003.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

