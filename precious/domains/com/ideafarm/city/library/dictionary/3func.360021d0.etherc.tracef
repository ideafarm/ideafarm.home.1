
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return timeMe1 ;

    }
        ((tin12S&)tin0P).pCyclesTraceEndLath[ idDivertP - ifcIDtRACEdIVERT_min ] = thirdC::cpuCyclesIF() ;

        osTimeSubtractF( tin0P , timeMe1 , timeMe2 , timeStart1 , timeStart2 ) ;
        timeMe2 = timeEnd2 ;
        timeMe1 = timeEnd1 ;

        ((tin12S&)tin0P).ptTraceEndLath[ idDivertP - ifcIDtRACEdIVERT_min ] = end ;

        timeS end( timeEnd1 , timeEnd2 ) ;
        osTimeNowF( tin0P , timeEnd1 , timeEnd2 ) ;
        ZE( sCountT , timeEnd2 ) ;
        ZE( countT  , timeEnd1 ) ;
    {
    if( bEndTime )

    }
        }
            }
                DELzOMBIE( pScoop ) ;
                }
                    THREADmODE3rESTORE

                    if( !( F(flagsP) & flTRACE_NOcONSOLE ) ) { CONoUTrAW( ostoSay ) ; }

                    }
                        }
                            LOGrAW( ostoSay ) ;
                            LOGrAW( "\r\ntraceF: logging because exception handler is not registered\r\n" ) ;
                            _IO_
                        {
                        else
                        }
                            }
                                }
                                    THREADmODE3rESTORE
                                    processGlobal4S::_processGlobal4I_IF().bksTraceHomeEchoGorillaHome.writeF( tin0P , ostoSay , cb1 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                                    THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                                    countT cb1 = ostoSay.costF() ;
                                    _IO_
                                {
                                if( F(flagsP) & flTRACE_HOMEeCHOgORILLAhOME )

                                }
                                    THREADmODE3rESTORE
                                    processGlobal4S::_processGlobal4I_IF().bksTraceHomeEchoDeadman1.writeF( tin0P , ostoSay , cb1 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                                    THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                                    countT cb1 = ostoSay.costF() ;
                                    _IO_
                                {
                                if( F(flagsP) & flTRACE_HOMEeCHOdEADMAN1 )

                                }
                                    THREADmODE3rESTORE
                                    processGlobal4S::_processGlobal4I_IF().bksTraceHomeEcho.writeF( tin0P , ostoSay , cb1 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                                    THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                                    countT cb1 = ostoSay.costF() ;
                                    _IO_
                                {
                                if( F(flagsP) & flTRACE_HOMEeCHO )

                                }
                                    }
                                        pBksUse->writeF( tin0P , ostoSay , cb1 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                                        countT cb1 = ostoSay.costF() ;
                                    {
                                    if( pBksUse )

                                    }
                                        }
                                            __( idDivertP ) ;
                                        {
                                        default :
                                        case ifcIDtRACEdIVERT_10 : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert10 ; break ; }
                                        case ifcIDtRACEdIVERT_f  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0f ; break ; }
                                        case ifcIDtRACEdIVERT_e  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0e ; break ; }
                                        case ifcIDtRACEdIVERT_d  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0d ; break ; }
                                        case ifcIDtRACEdIVERT_c  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0c ; break ; }
                                        case ifcIDtRACEdIVERT_b  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0b ; break ; }
                                        case ifcIDtRACEdIVERT_a  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0a ; break ; }
                                        case ifcIDtRACEdIVERT_9  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert09 ; break ; }
                                        case ifcIDtRACEdIVERT_8  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert08 ; break ; }
                                        case ifcIDtRACEdIVERT_7  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert07 ; break ; }
                                        case ifcIDtRACEdIVERT_6  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert06 ; break ; }
                                        case ifcIDtRACEdIVERT_5  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert05 ; break ; }
                                        case ifcIDtRACEdIVERT_4  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert04 ; break ; }
                                        case ifcIDtRACEdIVERT_3  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert03 ; break ; }
                                        case ifcIDtRACEdIVERT_2  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert02 ; break ; }
                                        case ifcIDtRACEdIVERT_1  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert01 ; break ; }
                                        case ifcIDtRACEdIVERT_0  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTrace         ; break ; }
                                    {
                                    else switch( idDivertP )
                                    if( !bDivertOk ) pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTrace ;
                                    ZE( booksC* , pBksUse ) ;
                                    _IO_
                                {
                                if( !( F(flagsP) & flTRACE_ECHOoNLY ) )
                                _IO_
                            {
                            else
                            }
                                processGlobal4S::_processGlobal4I_IF().bkTraceLoop.writeF( tin0P , flagsResult , ostoSay , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLOWoDDlENGTH | flBOOK0cwRITE_ALLoRnONE | flBOOK0cwRITE_PURGEiFfULL ) ;
                                countT cb1 = ostoSay.costF() ;
                                ZE( flagsT , flagsResult ) ;
                                _IO_
                            {
                            else if( F(flagsP) & flTRACE_LOOP )
                            }
                                LOGrAW( "\r\ntraceF: logged  because exception caught while attempting to write to bksTraceUse\r\n" ) ;
                                LOGrAW( ostoSay ) ;
                                LOGrAW( "\r\ntraceF: logging because exception caught while attempting to write to bksTraceUse\r\n" ) ;
                                _IO_
                            {
                            if( _restart )

                            _restart.flags |= flRESTARTc_QUIET ;
                            RESTART
                            _IO_
                        {
                        else if( F(processGlobal2I._thirdC_flagsModeProcess1) & flMODEpROCESS1_DEBUG || ( F(processGlobal2I.flCt) & flCTdTg_EXCEPTIONhANDLERrEGISTERED && !( F(processGlobal2I.flDt) & flCTdTg_EXCEPTIONhANDLERrEGISTERED ) ) )
                        }
                            //U:: DO THIS, AND WHEN I SEE !bDelayPushToFifoInHeap, FLUSH THE FIFO TO booksC
                        {
                        if( bDelayPushToFifoInHeap )

                        _IO_
                    {
                    if( !( F(flagsP) & flTRACE_NObOOK ) )

                    //if( !( F(processGlobal2I._thirdC_flagsProcessState) & flPROCESSsTATE_ RECEIVEDsIGNALtObEfIRED ) )
                    //20240328@2327: NO CAN DO
                    //20240328@2326: NEVER LOG ; THIS IS TO ELIMINATE LOG FILE CLUTTER ; IF EXCEPTIONS ARE OBSERVED, THE TEST CAN  BE ENABLED TO USE SAFE LOGGING RATHER THAN UNSAFE booksC WRITING

                    }
                        }
                            if( !( F(flagsP) & flTRACE_NOtELL ) ) { TELL( (const osTextT*)ostoSay + costBefore ) ; }
                            }
                                }
                                    }
                                        OStEXTA(  ostoSay , post2 ) ;

                                        }
                                            countT foo = 2 ;
                                        {
                                        if( *post2 == '\r' )
                                    {
                                    )
                                        ( bKeepCrLf && ( *post2 == '\r' || *post2 == '\n' ) )
                                        ||
                                        ( *post2 >= 0x20 && *post2 <= 0x7f )
                                    (
                                    if
                                    osTextT post2[] = { (osTextT)psttP[ offi ].idAdam , 0 } ;
                                    _IO_
                                {
                                )
                                    psttP[ offi ].idAdam < TUCK
                                    &&
                                    )
                                        )
                                            bKeepCrLf
                                            &&
                                            psttP[ offi ].idCaste == sc_cFROMcONTROL
                                        (
                                        ||
                                        psttP[ offi ].idCaste == sc_cALPHABET1
                                        ||
                                        psttP[ offi ].idCaste == sc_cFROMaSCII
                                    (
                                (
                                if
                                _IO_
                            {
                            for( countT offi = CSpREFIX ; offi < offEnd ; offi ++ )

                            const boolT bKeepCrLf = F(flagsP) & flTRACE_KEEPcRlF ;

                            countT offEnd = CSpREFIX + ( psttP->idAdam < TUCK << 4 ? psttP->idAdam : TUCK << 4 ) ; //CS:CODEsYNC: 360020 3600204

                            countT costBefore = ostoSay.costF() ;
                            _IO_
                        {
                        else
                        }
                            OStEXTA(  ostoSay , (osTextT*)psttP ) ;
                            if( !( F(flagsP) & flTRACE_NOtELL ) ) { TELL( (osTextT*)psttP ) ; }
                            _IO_
                        {
                        if( F(flagsP) & flTRACE_PARAMETERiSoStEXT )
                        _IO_
                    {
                    if( psttP )

                    }
                        OStEXTAK( ostoSay , " | " ) ;
                        while( costPad1 -- ) { OStEXTAK( ostoSay , " " ) ; }
                        if( tin0P.idTypeTin == ifcIDtYPEtIN_123 ) OStEXTA(  ostoSay , ((tin123S&)tin0P).postThreadName ) ;
                        OStEXTAK( ostoSay , " + " ) ;
                        OStEXTC(  ostoSay , ((tin1S&)tin0P).glass.idThread , ' ' ) ;
                        OStEXTAK( ostoSay , " * " ) ;
                        OStEXTC(  ostoSay , ((tin1S&)tin0P).pag1->idCell , ' ' ) ;
                        OStEXTAK( ostoSay , " & " ) ;
                        OStEXTA(  ostoSay , ostoCyclesDeltaNet ) ;
                        OStEXTAK( ostoSay , " ^ " ) ;
                        OStEXTA(  ostoSay , ostoCyclesDeltaGross ) ;
                        OStEXTAK( ostoSay , " % " ) ;
                        OStEXTA(  ostoSay , ostoCyclesThread ) ;
                        OStEXTAK( ostoSay , " $ " ) ;
                        while( costPad2 -- ) { OStEXTAK( ostoSay , " " ) ; }
                        OStEXTA(  ostoSay , postComputerLanName ) ;
                        OStEXTAK( ostoSay , " # " ) ;
                        OStEXTA(  ostoSay , ostoTimeDeltaNet ) ;
                        OStEXTAK( ostoSay , " @ " ) ;
                        OStEXTA(  ostoSay , ostoTimeDeltaGross ) ;
                        OStEXTAK( ostoSay , " ! " ) ;
                        OStEXTA(  ostoSay , ostoTimeThread ) ;
                        OStEXTAK( ostoSay , " ~ " ) ;
                        OStEXTA(  ostoSay , ostoTimeNow ) ;

                        //OStEXTAK( ostoSay , " ! " ) ;
                        //OStEXTA(  ostoSay , ostoCyclesStart ) ;
                        // THIS IS NOT USEFULL AND IT OCCUPIES VALUABLE REAL ESTATE IN THE LINE ; ostoCyclesStart - ostoCyclesThread IS THE NUMBER OF CYCLES CONSUMED BY THE THREAD AT THE WO'TH CALL TO traceF

                        if( costPad2 < 0 ) costPad2 = 0 ;
                        sCountT costPad2 = ( TUCK >> 4 ) - thirdC::c_strlenIF( postComputerLanName ) ;

                        thirdC::computerLanNameIF( tin0P , postComputerLanName , costComputerLanName ) ;
                        countT costComputerLanName = sizeof postComputerLanName ;
                        osTextT postComputerLanName[ TUCK >> 3 ] ;

                        if( costPad1 < 0 ) costPad1 = 0 ;
                        sCountT costPad1 = tin0P.idTypeTin != ifcIDtYPEtIN_123 ? 0 : ( TUCK >> 3 ) - thirdC::c_strlenIF( ((tin123S&)tin0P).postThreadName ) ;       //20221204@092: DOUBLED FIELD WIDTH TO ( TUCK >> 3 ) TO IMPROVE TRACE READABILITY

                        }
                            OStEXTCF( ostoCyclesDeltaNet   , pcCyclesDeltaNet[  0 ] , '0' ) ;
                            OStEXTAK( ostoCyclesDeltaNet   , "," ) ;
                            OStEXTCF( ostoCyclesDeltaNet   , pcCyclesDeltaNet[  1 ] , '0' ) ;

                            OStEXTCF( ostoCyclesDeltaGross , pcCyclesDeltaGross[  0 ] , '0' ) ;
                            OStEXTAK( ostoCyclesDeltaGross , "," ) ;
                            OStEXTCF( ostoCyclesDeltaGross , pcCyclesDeltaGross[  1 ] , '0' ) ;

                            OStEXTCF( ostoCyclesThread     , pcCyclesThread[ 0 ] , '0' ) ;
                            OStEXTAK( ostoCyclesThread     , "," ) ;
                            OStEXTCF( ostoCyclesThread     , pcCyclesThread[ 1 ] , '0' ) ;

                          //OStEXTCF( ostoCyclesStart        , pcCyclesStart[    0 ] , '0' ) ;
                          //OStEXTAK( ostoCyclesStart        , "," ) ;
                          //OStEXTCF( ostoCyclesStart        , pcCyclesStart[    1 ] , '0' ) ;

                            ((tin12S&)tin0P).pCyclesTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ] = cyclesStart ;

                            countT* pcCyclesThread     = (countT*)&cyclesThread     ;
                            countT* pcCyclesDeltaNet   = (countT*)&cyclesDeltaNet   ;
                            countT* pcCyclesDeltaGross = (countT*)&cyclesDeltaGross ;
                            countT* pcCyclesLath       = (countT*)&cyclesLath       ;
                            countT* pcCyclesWoth       = (countT*)&cyclesWoth       ;
                            countT* pcCyclesStart        = (countT*)&cyclesStart        ;

                            count04T cyclesDeltaNet    = cyclesStart - cyclesEndLath  ;
                            count04T cyclesDeltaGross  = cyclesStart - cyclesLath     ;
                            count04T cyclesThread      = cyclesStart - cyclesWoth     ;

                            count04T cyclesEndLath     = ((tin12S&)tin0P).pCyclesTraceEndLath[ idDivertP - ifcIDtRACEdIVERT_min ] ;
                            count04T cyclesLath        = ((tin12S&)tin0P).pCyclesTraceLath[    idDivertP - ifcIDtRACEdIVERT_min ] ;
                            count04T cyclesWoth        = ((tin12S&)tin0P).pCyclesTraceWoth[    idDivertP - ifcIDtRACEdIVERT_min ] ;

                            ((tin12S&)tin0P).pCyclesTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ] = ((tin12S&)tin0P).pCyclesTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ] = cyclesStart ;
                            )
                                F(flagsP) & flTRACE_RESET
                                ||
                                !((tin12S&)tin0P).pCyclesTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ]
                            (
                            if
                        {
                        else
                        }
                            OStEXTAK( ostoCyclesDeltaNet   , "--------,--------" ) ;
                            OStEXTAK( ostoCyclesDeltaGross , "--------,--------" ) ;
                            OStEXTAK( ostoCyclesThread     , "--------,--------" ) ;
                          //OStEXTAK( ostoCyclesStart      , "--------,--------" ) ;
                        {
                        if( !bEndTime )

                        OStEXT( ostoCyclesDeltaNet   , TUCK >> 3 ) ;
                        OStEXT( ostoCyclesDeltaGross , TUCK >> 3 ) ;
                        OStEXT( ostoCyclesThread     , TUCK >> 3 ) ;
                      //OStEXT( ostoCyclesStart        , TUCK >> 3 ) ;

                        }
                            OStEXTCF( ostoTimeDeltaNet , timeDeltaNet1 , '0' ) ;
                            OStEXTAK( ostoTimeDeltaNet , "." ) ;
                            OStEXTCF( ostoTimeDeltaNet , timeDeltaNet2 , '0' ) ;

                            OStEXTCF( ostoTimeDeltaGross , timeDeltaGross1 , '0' ) ;
                            OStEXTAK( ostoTimeDeltaGross , "." ) ;
                            OStEXTCF( ostoTimeDeltaGross , timeDeltaGross2 , '0' ) ;

                            OStEXTCF( ostoTimeThread , timeT1 , '0' ) ;
                            OStEXTAK( ostoTimeThread , "." ) ;
                            OStEXTCF( ostoTimeThread , timeT2 , '0' ) ;

                            OStEXTCF( ostoTimeNow , ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ].time1 , '0' ) ;
                            OStEXTAK( ostoTimeNow , "." ) ;
                            OStEXTCF( ostoTimeNow , ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ].time2 , '0' ) ;

                            osTimeSubtractF( tin0P , timeT1 , timeT2 , ((tin12S&)tin0P).ptTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ].time1 , ((tin12S&)tin0P).ptTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ].time2 ) ;
                            sCountT timeT2 = ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ].time2 ;
                            countT  timeT1 = ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ].time1 ;

                                                                                         ((tin12S&)tin0P).ptTraceLath[    idDivertP - ifcIDtRACEdIVERT_min ] = start ;

                            osTimeSubtractF( tin0P , timeDeltaGross1 , timeDeltaGross2 , ((tin12S&)tin0P).ptTraceLath[    idDivertP - ifcIDtRACEdIVERT_min ].time1 , ((tin12S&)tin0P).ptTraceLath[    idDivertP - ifcIDtRACEdIVERT_min ].time2 ) ;
                            osTimeSubtractF( tin0P , timeDeltaNet1   , timeDeltaNet2   , ((tin12S&)tin0P).ptTraceEndLath[ idDivertP - ifcIDtRACEdIVERT_min ].time1 , ((tin12S&)tin0P).ptTraceEndLath[ idDivertP - ifcIDtRACEdIVERT_min ].time2 ) ;

                            ((tin12S&)tin0P).ptTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ] = ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ] = start ;
                            )
                                F(flagsP) & flTRACE_RESET
                                ||
                                )
                                    !((tin12S&)tin0P).ptTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ].time1
                                    &&
                                    !((tin12S&)tin0P).ptTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ].time2
                                (
                            (
                            if

                            sCountT timeDeltaNet2   = timeStart2 ;
                            countT  timeDeltaNet1   = timeStart1 ;

                            sCountT timeDeltaGross2 = timeStart2 ;
                            countT  timeDeltaGross1 = timeStart1 ;

                            timeS start( timeStart1 , timeStart2 ) ;

                            bEndTime ++ ;
                        {
                        else
                        }
                            OStEXTAK( ostoTimeDeltaNet   , "--------.--------" ) ;
                            OStEXTAK( ostoTimeDeltaGross , "--------.--------" ) ;
                            OStEXTAK( ostoTimeThread     , "--------.--------" ) ;
                            OStEXTAK( ostoTimeNow        , "--------.--------" ) ;
                        {
                        if( !c_this )

                        OStEXT( ostoTimeDeltaNet   , TUCK >> 3 ) ;
                        OStEXT( ostoTimeDeltaGross , TUCK >> 3 ) ;
                        OStEXT( ostoTimeThread     , TUCK >> 3 ) ;
                        OStEXT( ostoTimeNow        , TUCK >> 3 ) ;

                        _IO_
                    {
                    if( !( F(flagsP) & flTRACE_NOpREFIX ) )
                                                                             //20250711@1713: ADDED "0x30" FOR DELTA NET TIME AND CYCLES
                    OStEXTAK( ostoSay , "\r\n" ) ;                           //20250622@1742: ADDED "0x20" FOR THE COMPUTER LAN NAME ADDED TODAY TO THE PREFIX
                    OStEXT( ostoSay , TUCK + 0x50 + CBrEADABILITYmAPdUMP ) ; //CS:CODEsYNC: 360020 360020 ; 20171225@1122: INCREASED TO BE BIG ENOUGH FOR MEMORY READABILITY MAP DUMP

                    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )                         // MY CALLER MIGHT HAVE GRABBED LISTnAMEsYS_ROOT, WHICH COULD DEADLOCK sexC::sexC

                    }
                        //if( POOP ) return 0 ;
                        FV( flTRACE , flagsP ) ;
                        //if( POOP ) return 0 ;
                        //20160530@1034: I AM NOW CALLED BY poopC::gruntF SO MUST DO MY JOB EVEN IF IMPOTENCE
                    {
                    IFbEcAREFUL
                {

                if( c_this ) pScoop = new( 0 , tin0P , pbScoop , sizeof pbScoop ) scoopC( tin0P , LF , poop ) ; 
                byteT pbScoop[ sizeof( scoopC ) ] ;
                ZE( scoopC* , pScoop ) ;

                _IO_
            {
            else
            }
                //LOGrAW( "\r\n" ) ;
                //}
                //    LOGrAW( T(psttP) ) ;
                //{
                //else
                //}
                //    LOGrAW( (osTextT*)psttP ) ;
                //{
                //if( F(flagsP) & flTRACE_PARAMETERiSoStEXT )
                //LOGrAW( "\r\ntraceF: suppressing trace:  " ) ;
                //U:: ENHANCE TO POSTPONE BY WRITING TO A TEMPORARY BUFFER THAT IS FLUSHED BY booksC WHEN IT CAN DO SO

                //CONoUTrAW3( "[F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_SUPPRESStRACING         ]:    " , F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_SUPPRESStRACING , "\r\n" ) ; //U:: TO FIND A BUG
                //CONoUTrAW3( "[F(thirdC::third_flagsModeAdam1I_IF(tin0P)) & flADAMmODE1_NOtRACING]:    " , F(thirdC::third_flagsModeAdam1I_IF(tin0P)) & flADAMmODE1_NOtRACING , "\r\n" ) ; //U:: TO FIND A BUG
                //CONoUTrAW3( "[!bTraceOk                                                        ]:    " , !bTraceOk , "\r\n" ) ; //U:: TO FIND A BUG

                //CONoUTrAW3( "[((tin1S&)tin0P).flagsThreadMode3                                            ]:    " , ((tin1S&)tin0P).flagsThreadMode3 , "\r\n" ) ; //U:: TO FIND A BUG
                //CONoUTrAW3( "[thirdC::third_flagsModeAdam1I_IF(tin0P)                           ]:    " , thirdC::third_flagsModeAdam1I_IF(tin0P) , "\r\n" ) ; //U:: TO FIND A BUG
                //CONoUTrAW3( "[bTraceOk                                                         ]:    " , bTraceOk , "\r\n" ) ; //U:: TO FIND A BUG
                _IO_
            {
            if( !bForceTrace && ( !bTraceOk || F(thirdC::third_flagsModeAdam1I_IF(tin0P)) & flADAMmODE1_NOtRACING || F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_SUPPRESStRACING ) )
            //if( !thirdC::c_strcmpIF( tin0P , ((tin123S&)tin0P).postThreadName , "tmGetIdHomeF" ) )

            //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) { CONoUTrAWb( "\r\ntraceF [idAdam,flagsP,home.flags,bTraceOk,bDivertOk]:    " , ((tin1S&)tin0P).pag1->idAdam , "    " , flagsP , "    " , home.flags , "    " , bTraceOk , "    " , bDivertOk , "\r\n" ) ; } //U:: TO FIND A BUG

            //LOGrAWb( "\r\ntraceF [idAdam,flagsP,home.flags,bTraceOk,bDivertOk]:    " , ((tin1S&)tin0P).pag1->idAdam , "    " , flagsP , "    " , home.flags , "    " , bTraceOk , "    " , bDivertOk , "\r\n" ) ; //U:: TO FIND A BUG

            ;
                : 1
                ? F(flagsP) & flTRACE_FORCEdIVERT    || !( F(home.flags) & flHOMEs_TRACEnOdIVERT )
            boolT bDivertOk = c_pHome

            ;
                : 1
                ? F(flagsP) & flTRACE_FORCEnOsILENCE || !( F(home.flags) & flHOMEs_TRACEsILENCED )
            boolT bTraceOk = c_pHome

            boolT bForceTrace = !!( F(flagsP) & flTRACE_FORCEnOsILENCE ) ;

            countT c_pHome = (countT)&home ;
            homeS& home = homeS::homeIF() ;
            _IO_
        {
        if( bTrace )

        }
            }
                if( strIdF( tin0P , T(processGlobal2I.postSuppressTraceIf) , psttP ) ) bTrace = 0 ;
            {
            else
            }
                if( thirdC::c_strstrIF( tin0P , (osTextT*)psttP , processGlobal2I.postSuppressTraceIf ) ) bTrace = 0 ;
            {
            if( F(flagsP) & flTRACE_PARAMETERiSoStEXT )
            _IO_
        {
        if( processGlobal2I.postSuppressTraceIf[ 0 ] && psttP )

        }
            if( bAll ) bTrace ++ ;

            }
                }
                    }
                        break ;
                        bTrace ++ ;
                    {
                    if( ((tin1S&)tin0P).pag1->pcIdThreadTrace[ offi ] == ((tin1S&)tin0P).glass.idThread )
                    if( bAll ) bAll -- ;
                {
                if( ((tin1S&)tin0P).pag1->pcIdThreadTrace[ offi ] )
                _IO_
            {
            for( countT offi = 0 ; offi < CiDtHREADtRACE ; offi ++ )
            boolT bAll = 1 ;
            _IO_
        {
        if( !bTrace )
        boolT bTrace = !!( F(flagsP) & flTRACE_FORCEnOsILENCE ) ;

        }
            }
                bDelayPushToFifoInHeap = 1 ;
                CONoUTrAW3( "\r\ntraceF [idGrabLayerMax]:    " , idGrabLayerMax , "\r\n" ) ;
            {
            if( ifcIDgRABlAYER_bBOOKSc < idGrabLayerMax )

            countT idGrabLayerMax = baseGrabC::idGrabLayerMaxIF( tin0P ) ;
        {
        ZE( boolT , bDelayPushToFifoInHeap ) ;

        if( idDivertP < ifcIDtRACEdIVERT_min || idDivertP > ifcIDtRACEdIVERT_max ) { BLAMMOiD( idDivertP ) ; }

        _IO_
    {
    ZE( sCountT , timeMe2  ) ;
    ZE( countT  , timeMe1  ) ;
    ZE( boolT   , bEndTime ) ;

    if( c_this ) osTimeNowF( tin0P , timeStart1 , timeStart2 ) ;
    ZE( sCountT , timeStart2 ) ;
    ZE( countT  , timeStart1 ) ;
    const countT c_this = (countT)this ;

    const count04T cyclesStart = thirdC::cpuCyclesIF() ;
{
/*1*/countT etherC::traceF( tin0S& tin0P , const strokeS* const psttP , const flagsT flagsP , const countT idDivertP )/*1*/

//DON'T USE _ IN HERE (WILL BLOW STACK)

/**/

*/
  may be 0
 psttP
 tin0P
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

