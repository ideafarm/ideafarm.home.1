
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        }
            DELzOMBIE( pScoop ) ;
            }
                THREADmODE3rESTORE

                if( !( F(flagsP) & flTRACE_NOcONSOLE ) ) { CONoUTrAW( ostoSay ) ; }

                }
                    }
                        LOGrAW( ostoSay ) ;
                        LOGrAW( "\r\ntraceF: logging because exception handler is not registered\r\n" ) ;
                        _IO_
                    {
                    else
                    }
                        }
                            }
                                THREADmODE3rESTORE
                                processGlobal4S::_processGlobal4I_IF().bksTraceHomeEchoGorillaHome.writeF( tin0P , ostoSay , cb1 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                                THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                                countT cb1 = ostoSay.costF() ;
                                _IO_
                            {
                            if( F(flagsP) & flTRACE_HOMEeCHOgORILLAhOME )

                            }
                                THREADmODE3rESTORE
                                processGlobal4S::_processGlobal4I_IF().bksTraceHomeEchoDeadman1.writeF( tin0P , ostoSay , cb1 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                                THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                                countT cb1 = ostoSay.costF() ;
                                _IO_
                            {
                            if( F(flagsP) & flTRACE_HOMEeCHOdEADMAN1 )

                            }
                                THREADmODE3rESTORE
                                processGlobal4S::_processGlobal4I_IF().bksTraceHomeEcho.writeF( tin0P , ostoSay , cb1 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                                THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )
                                countT cb1 = ostoSay.costF() ;
                                _IO_
                            {
                            if( F(flagsP) & flTRACE_HOMEeCHO )

                            }
                                }
                                    pBksUse->writeF( tin0P , ostoSay , cb1 , 0 , 0 , flBOOKScwRITE_ALLoRnONE | flBOOKScwRITE_ALLOWoDDlENGTH ) ;
                                    countT cb1 = ostoSay.costF() ;
                                {
                                if( pBksUse )

                                }
                                    }
                                        __( idDivertP ) ;
                                    {
                                    default :
                                    case ifcIDtRACEdIVERT_10 : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert10 ; break ; }
                                    case ifcIDtRACEdIVERT_f  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0f ; break ; }
                                    case ifcIDtRACEdIVERT_e  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0e ; break ; }
                                    case ifcIDtRACEdIVERT_d  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0d ; break ; }
                                    case ifcIDtRACEdIVERT_c  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0c ; break ; }
                                    case ifcIDtRACEdIVERT_b  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0b ; break ; }
                                    case ifcIDtRACEdIVERT_a  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert0a ; break ; }
                                    case ifcIDtRACEdIVERT_9  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert09 ; break ; }
                                    case ifcIDtRACEdIVERT_8  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert08 ; break ; }
                                    case ifcIDtRACEdIVERT_7  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert07 ; break ; }
                                    case ifcIDtRACEdIVERT_6  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert06 ; break ; }
                                    case ifcIDtRACEdIVERT_5  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert05 ; break ; }
                                    case ifcIDtRACEdIVERT_4  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert04 ; break ; }
                                    case ifcIDtRACEdIVERT_3  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert03 ; break ; }
                                    case ifcIDtRACEdIVERT_2  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert02 ; break ; }
                                    case ifcIDtRACEdIVERT_1  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTraceDivert01 ; break ; }
                                    case ifcIDtRACEdIVERT_0  : { pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTrace         ; break ; }
                                {
                                else switch( idDivertP )
                                if( !bDivertOk ) pBksUse = &processGlobal4S::_processGlobal4I_IF().bksTrace ;
                                ZE( booksC* , pBksUse ) ;
                                _IO_
                            {
                            if( !( F(flagsP) & flTRACE_ECHOoNLY ) )
                            _IO_
                        {
                        else
                        }
                            processGlobal4S::_processGlobal4I_IF().bkTraceLoop.writeF( tin0P , flagsResult , ostoSay , cb1 , 0 , countTC() , flBOOK0cwRITE_ALLOWoDDlENGTH | flBOOK0cwRITE_ALLoRnONE | flBOOK0cwRITE_PURGEiFfULL ) ;
                            countT cb1 = ostoSay.costF() ;
                            ZE( flagsT , flagsResult ) ;
                            _IO_
                        {
                        else if( F(flagsP) & flTRACE_LOOP )
                        }
                            LOGrAW( "\r\ntraceF: logged  because exception caught while attempting to write to bksTraceUse\r\n" ) ;
                            LOGrAW( ostoSay ) ;
                            LOGrAW( "\r\ntraceF: logging because exception caught while attempting to write to bksTraceUse\r\n" ) ;
                            _IO_
                        {
                        if( _restart )

                        _restart.flags |= flRESTARTc_QUIET ;
                        RESTART
                        _IO_
                    {
                    else if( F(processGlobal2I._thirdC_flagsModeProcess1) & flMODEpROCESS1_DEBUG || ( F(processGlobal2I.flCt) & flCTdTg_EXCEPTIONhANDLERrEGISTERED && !( F(processGlobal2I.flDt) & flCTdTg_EXCEPTIONhANDLERrEGISTERED ) ) )
                    }
                        //U:: DO THIS, AND WHEN I SEE !bDelayPushToFifoInHeap, FLUSH THE FIFO TO booksC
                    {
                    if( bDelayPushToFifoInHeap )

                    _IO_
                {
                if( !( F(flagsP) & flTRACE_NObOOK ) )

                //if( !( F(processGlobal2I._thirdC_flagsProcessState) & flPROCESSsTATE_ RECEIVEDsIGNALtObEfIRED ) )
                //20240328@2327: NO CAN DO
                //20240328@2326: NEVER LOG ; THIS IS TO ELIMINATE LOG FILE CLUTTER ; IF EXCEPTIONS ARE OBSERVED, THE TEST CAN  BE ENABLED TO USE SAFE LOGGING RATHER THAN UNSAFE booksC WRITING

                }
                    }
                        if( !( F(flagsP) & flTRACE_NOtELL ) ) { TELL( (const osTextT*)ostoSay + costBefore ) ; }
                        }
                            }
                                }
                                    OStEXTA(  ostoSay , post2 ) ;

                                    }
                                        countT foo = 2 ;
                                    {
                                    if( *post2 == '\r' )
                                {
                                )
                                    ( bKeepCrLf && ( *post2 == '\r' || *post2 == '\n' ) )
                                    ||
                                    ( *post2 >= 0x20 && *post2 <= 0x7f )
                                (
                                if
                                osTextT post2[] = { (osTextT)psttP[ offi ].idAdam , 0 } ;
                                _IO_
                            {
                            )
                                psttP[ offi ].idAdam < TUCK
                                &&
                                )
                                    )
                                        bKeepCrLf
                                        &&
                                        psttP[ offi ].idCaste == sc_cFROMcONTROL
                                    (
                                    ||
                                    psttP[ offi ].idCaste == sc_cALPHABET1
                                    ||
                                    psttP[ offi ].idCaste == sc_cFROMaSCII
                                (
                            (
                            if
                            _IO_
                        {
                        for( countT offi = CSpREFIX ; offi < offEnd ; offi ++ )

                        const boolT bKeepCrLf = F(flagsP) & flTRACE_KEEPcRlF ;

                        countT offEnd = CSpREFIX + ( psttP->idAdam < TUCK << 4 ? psttP->idAdam : TUCK << 4 ) ; //CS:CODEsYNC: 360020 3600204

                        countT costBefore = ostoSay.costF() ;
                        _IO_
                    {
                    else
                    }
                        OStEXTA(  ostoSay , (osTextT*)psttP ) ;
                        if( !( F(flagsP) & flTRACE_NOtELL ) ) { TELL( (osTextT*)psttP ) ; }
                        _IO_
                    {
                    if( F(flagsP) & flTRACE_PARAMETERiSoStEXT )
                    _IO_
                {
                if( psttP )

                }
                    OStEXTAK( ostoSay , " | " ) ;
                    while( costPad1 -- ) { OStEXTAK( ostoSay , " " ) ; }
                    if( tin0P.idTypeTin == ifcIDtYPEtIN_123 ) OStEXTA(  ostoSay , ((tin123S&)tin0P).postThreadName ) ;
                    OStEXTAK( ostoSay , " & " ) ;
                    OStEXTC(  ostoSay , ((tin1S&)tin0P).glass.idThread , ' ' ) ;
                    OStEXTAK( ostoSay , " ^ " ) ;
                    OStEXTC(  ostoSay , ((tin1S&)tin0P).pag1->idCell , ' ' ) ;
                    OStEXTAK( ostoSay , " % " ) ;
                    OStEXTA(  ostoSay , ostoCyclesDelta ) ;
                    OStEXTAK( ostoSay , " $ " ) ;
                    OStEXTA(  ostoSay , ostoCyclesNet ) ;
                    OStEXTAK( ostoSay , " # " ) ;
                    while( costPad2 -- ) { OStEXTAK( ostoSay , " " ) ; }
                    OStEXTA(  ostoSay , postComputerLanName ) ;
                    OStEXTAK( ostoSay , " @ " ) ;
                    OStEXTA(  ostoSay , ostoTimeDelta ) ;
                    OStEXTAK( ostoSay , " ! " ) ;
                    OStEXTA(  ostoSay , ostoTimeNet ) ;
                    OStEXTAK( ostoSay , " ~ " ) ;
                    OStEXTA(  ostoSay , ostoTimeNow ) ;

                    //OStEXTAK( ostoSay , " ! " ) ;
                    //OStEXTA(  ostoSay , ostoCyclesNow ) ;
                    // THIS IS NOT USEFULL AND IT OCCUPIES VALUABLE REAL ESTATE IN THE LINE ; ostoCyclesNow - ostoCyclesNet IS THE NUMBER OF CYCLES CONSUMED BY THE THREAD AT THE WO'TH CALL TO traceF

                    if( costPad2 < 0 ) costPad2 = 0 ;
                    sCountT costPad2 = ( TUCK >> 4 ) - thirdC::c_strlenIF( postComputerLanName ) ;

                    thirdC::computerLanNameIF( tin0P , postComputerLanName , costComputerLanName ) ;
                    countT costComputerLanName = sizeof postComputerLanName ;
                    osTextT postComputerLanName[ TUCK >> 3 ] ;

                    if( costPad1 < 0 ) costPad1 = 0 ;
                    sCountT costPad1 = tin0P.idTypeTin != ifcIDtYPEtIN_123 ? 0 : ( TUCK >> 3 ) - thirdC::c_strlenIF( ((tin123S&)tin0P).postThreadName ) ;       //20221204@092: DOUBLED FIELD WIDTH TO ( TUCK >> 3 ) TO IMPROVE TRACE READABILITY

                    }
                        OStEXTCF( ostoCyclesNet   , pcCyclesNet[   0 ] , '0' ) ;
                        OStEXTAK( ostoCyclesNet   , "," ) ;
                        OStEXTCF( ostoCyclesNet   , pcCyclesNet[   1 ] , '0' ) ;

                        //OStEXTCF( ostoCyclesNow   , pcCyclesNow[   0 ] , '0' ) ;
                        //OStEXTAK( ostoCyclesNow   , "," ) ;
                        //OStEXTCF( ostoCyclesNow   , pcCyclesNow[   1 ] , '0' ) ;

                        OStEXTCF( ostoCyclesDelta , pcCyclesDelta[ 0 ] , '0' ) ;
                        OStEXTAK( ostoCyclesDelta , "," ) ;
                        OStEXTCF( ostoCyclesDelta , pcCyclesDelta[ 1 ] , '0' ) ;

                        ((tin12S&)tin0P).pCyclesTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ] = cyclesNow ;

                        countT* pcCyclesNet    = (countT*)&cyclesNet   ;
                        countT* pcCyclesDelta  = (countT*)&cyclesDelta ;
                        countT* pcCyclesLath   = (countT*)&cyclesLath  ;
                        countT* pcCyclesWoth   = (countT*)&cyclesWoth  ;
                        countT* pcCyclesNow    = (countT*)&cyclesNow   ;

                        count04T cyclesNet     = cyclesNow - cyclesWoth ;
                        count04T cyclesDelta   = cyclesNow - cyclesLath ;

                        count04T cyclesLath    = ((tin12S&)tin0P).pCyclesTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ] ;
                        count04T cyclesWoth    = ((tin12S&)tin0P).pCyclesTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ] ;

                        if( bReset ) ((tin12S&)tin0P).pCyclesTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ] = ((tin12S&)tin0P).pCyclesTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ] = cyclesNow ;
                        boolT bReset = !((tin12S&)tin0P).pCyclesTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ] || F(flagsP) & flTRACE_RESET ;

                        count04T cyclesNow = thirdC::cpuCyclesIF() ;
                    {
                    else
                    }
                        OStEXTAK( ostoCyclesNet   , "--------,--------" ) ;
                        //OStEXTAK( ostoCyclesNow   , "--------,--------" ) ;
                        OStEXTAK( ostoCyclesDelta , "--------,--------" ) ;
                    {
                    if( !c_this )

                    OStEXT( ostoCyclesNet   , TUCK >> 3 ) ;
                    //OStEXT( ostoCyclesNow   , TUCK >> 3 ) ;
                    OStEXT( ostoCyclesDelta , TUCK >> 3 ) ;

                    }
                        OStEXTCF( ostoTimeNet , timeE1 , '0' ) ;
                        OStEXTAK( ostoTimeNet , "." ) ;
                        OStEXTCF( ostoTimeNet , timeE2 , '0' ) ;

                        osTimeSubtractF( tin0P , timeE1 , timeE2 , ((tin12S&)tin0P).ptTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ].time1 , ((tin12S&)tin0P).ptTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ].time2 ) ;
                        sCountT timeE2 = ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ].time2 ;
                        countT  timeE1 = ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ].time1 ;

                        OStEXTCF( ostoTimeNow , ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ].time1 , '0' ) ;
                        OStEXTAK( ostoTimeNow , "." ) ;
                        OStEXTCF( ostoTimeNow , ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ].time2 , '0' ) ;

                        OStEXTCF( ostoTimeDelta , timeDelta1 , '0' ) ;
                        OStEXTAK( ostoTimeDelta , "." ) ;
                        OStEXTCF( ostoTimeDelta , timeDelta2 , '0' ) ;

                        ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ] = now ;
                        osTimeSubtractF( tin0P , timeDelta1 , timeDelta2 , ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ].time1 , ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ].time2 ) ;
                        if( bReset ) ((tin12S&)tin0P).ptTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ] = ((tin12S&)tin0P).ptTraceLath[ idDivertP - ifcIDtRACEdIVERT_min ] = now ;
                        timeS now( timeDelta1 , timeDelta2 ) ;
                        osTimeNowF( tin0P , timeDelta1 , timeDelta2 ) ;
                        ZE( sCountT , timeDelta2 ) ;
                        ZE( countT  , timeDelta1 ) ;

                        boolT bReset = ( !((tin12S&)tin0P).ptTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ].time2 && !((tin12S&)tin0P).ptTraceWoth[ idDivertP - ifcIDtRACEdIVERT_min ].time1 ) || F(flagsP) & flTRACE_RESET ;
                    {
                    else
                    }
                        OStEXTAK( ostoTimeNet   , "--------.--------" ) ;
                        OStEXTAK( ostoTimeNow   , "--------.--------" ) ;
                        OStEXTAK( ostoTimeDelta , "--------.--------" ) ;
                    {
                    if( !c_this )

                    OStEXT( ostoTimeNet   , TUCK >> 3 ) ;
                    OStEXT( ostoTimeNow   , TUCK >> 3 ) ;
                    OStEXT( ostoTimeDelta , TUCK >> 3 ) ;

                    _IO_
                {
                if( !( F(flagsP) & flTRACE_NOpREFIX ) )

                OStEXTAK( ostoSay , "\r\n" ) ;                           //20250622@1742: ADDED "0x20" FOR THE COMPUTER LAN NAME ADDED TODAY TO THE PREFIX
                OStEXT( ostoSay , TUCK + 0x20 + CBrEADABILITYmAPdUMP ) ; //CS:CODEsYNC: 360020 360020 ; 20171225@1122: INCREASED TO BE BIG ENOUGH FOR MEMORY READABILITY MAP DUMP

                THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )                         // MY CALLER MIGHT HAVE GRABBED LISTnAMEsYS_ROOT, WHICH COULD DEADLOCK sexC::sexC

                }
                    //if( POOP ) return ;
                    FV( flTRACE , flagsP ) ;
                    //if( POOP ) return ;
                    //20160530@1034: I AM NOW CALLED BY poopC::gruntF SO MUST DO MY JOB EVEN IF IMPOTENCE
                {
                IFbEcAREFUL
            {

            if( c_this ) pScoop = new( 0 , tin0P , pbScoop , sizeof pbScoop ) scoopC( tin0P , LF , poop ) ; 
            byteT pbScoop[ sizeof( scoopC ) ] ;
            ZE( scoopC* , pScoop ) ;

            countT c_this = (countT)this ;
            _IO_
        {
        else
        }
            //LOGrAW( "\r\n" ) ;
            //}
            //    LOGrAW( T(psttP) ) ;
            //{
            //else
            //}
            //    LOGrAW( (osTextT*)psttP ) ;
            //{
            //if( F(flagsP) & flTRACE_PARAMETERiSoStEXT )
            //LOGrAW( "\r\ntraceF: suppressing trace:  " ) ;
            //U:: ENHANCE TO POSTPONE BY WRITING TO A TEMPORARY BUFFER THAT IS FLUSHED BY booksC WHEN IT CAN DO SO

            //CONoUTrAW3( "[F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_SUPPRESStRACING         ]:    " , F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_SUPPRESStRACING , "\r\n" ) ; //U:: TO FIND A BUG
            //CONoUTrAW3( "[F(thirdC::third_flagsModeAdam1I_IF(tin0P)) & flADAMmODE1_NOtRACING]:    " , F(thirdC::third_flagsModeAdam1I_IF(tin0P)) & flADAMmODE1_NOtRACING , "\r\n" ) ; //U:: TO FIND A BUG
            //CONoUTrAW3( "[!bTraceOk                                                        ]:    " , !bTraceOk , "\r\n" ) ; //U:: TO FIND A BUG

            //CONoUTrAW3( "[((tin1S&)tin0P).flagsThreadMode3                                            ]:    " , ((tin1S&)tin0P).flagsThreadMode3 , "\r\n" ) ; //U:: TO FIND A BUG
            //CONoUTrAW3( "[thirdC::third_flagsModeAdam1I_IF(tin0P)                           ]:    " , thirdC::third_flagsModeAdam1I_IF(tin0P) , "\r\n" ) ; //U:: TO FIND A BUG
            //CONoUTrAW3( "[bTraceOk                                                         ]:    " , bTraceOk , "\r\n" ) ; //U:: TO FIND A BUG
            _IO_
        {
        if( !bForceTrace && ( !bTraceOk || F(thirdC::third_flagsModeAdam1I_IF(tin0P)) & flADAMmODE1_NOtRACING || F(((tin1S&)tin0P).flagsThreadMode3) & flTHREADmODE3_SUPPRESStRACING ) )
        //if( !thirdC::c_strcmpIF( tin0P , ((tin123S&)tin0P).postThreadName , "tmGetIdHomeF" ) )

        //if( ((tin1S&)tin0P).pc Utility[ 0 ] ) { CONoUTrAWb( "\r\ntraceF [idAdam,flagsP,home.flags,bTraceOk,bDivertOk]:    " , ((tin1S&)tin0P).pag1->idAdam , "    " , flagsP , "    " , home.flags , "    " , bTraceOk , "    " , bDivertOk , "\r\n" ) ; } //U:: TO FIND A BUG

        //LOGrAWb( "\r\ntraceF [idAdam,flagsP,home.flags,bTraceOk,bDivertOk]:    " , ((tin1S&)tin0P).pag1->idAdam , "    " , flagsP , "    " , home.flags , "    " , bTraceOk , "    " , bDivertOk , "\r\n" ) ; //U:: TO FIND A BUG

        ;
            : 1
            ? F(flagsP) & flTRACE_FORCEdIVERT    || !( F(home.flags) & flHOMEs_TRACEnOdIVERT )
        boolT bDivertOk = c_pHome

        ;
            : 1
            ? F(flagsP) & flTRACE_FORCEnOsILENCE || !( F(home.flags) & flHOMEs_TRACEsILENCED )
        boolT bTraceOk = c_pHome

        boolT bForceTrace = !!( F(flagsP) & flTRACE_FORCEnOsILENCE ) ;

        countT c_pHome = (countT)&home ;
        homeS& home = homeS::homeIF() ;
        _IO_
    {
    if( bTrace )

    }
        if( bAll ) bTrace ++ ;

        }
            }
                }
                    break ;
                    bTrace ++ ;
                {
                if( ((tin1S&)tin0P).pag1->pcIdThreadTrace[ offi ] == ((tin1S&)tin0P).glass.idThread )
                if( bAll ) bAll -- ;
            {
            if( ((tin1S&)tin0P).pag1->pcIdThreadTrace[ offi ] )
            _IO_
        {
        for( countT offi = 0 ; offi < CiDtHREADtRACE ; offi ++ )
        boolT bAll = 1 ;
        _IO_
    {
    if( !bTrace )
    boolT bTrace = !!( F(flagsP) & flTRACE_FORCEnOsILENCE ) ;

    }
        }
            bDelayPushToFifoInHeap = 1 ;
            CONoUTrAW3( "\r\ntraceF [idGrabLayerMax]:    " , idGrabLayerMax , "\r\n" ) ;
        {
        if( ifcIDgRABlAYER_bBOOKSc < idGrabLayerMax )

        countT idGrabLayerMax = baseGrabC::idGrabLayerMaxIF( tin0P ) ;
    {
    ZE( boolT , bDelayPushToFifoInHeap ) ;

    if( idDivertP < ifcIDtRACEdIVERT_min || idDivertP > ifcIDtRACEdIVERT_max ) { BLAMMOiD( idDivertP ) ; }

    _IO_
{
/*1*/voidT etherC::traceF( tin0S& tin0P , const strokeS* const psttP , const flagsT flagsP , const countT idDivertP )/*1*/

//DON'T USE _ IN HERE (WILL BLOW STACK)

/**/

*/
  may be 0
 psttP
 tin0P
parameters
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

