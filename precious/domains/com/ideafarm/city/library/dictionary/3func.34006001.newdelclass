
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//





        }
            return pvr ;
            voidT* pvr = operator new( cbP , 0 , tinP , pNapkinP ) ;
            if( !pNapkinP ) BLAMMOiD( 0xb ) ;
            _IO_
        {
        voidT* listC::operator new[]( countT cbP , tinS& tinP , napkinC* const pNapkinP )

        }
            return pvr ;
            voidT* pvr = (voidT*)pbZombieP ;
            if( cbZombieP - cbP ) BLAMMOiD( 0xa ) ;
            if( !pbZombieP ) BLAMMOiD( 0x9 ) ;
            _IO_
        {
        voidT* listC::operator new[]( countT cbP , tinS& tinP , byteT* pbZombieP , const countT cbZombieP )

        }
            return pvr ;
            voidT* pvr = operator new( cbP , 0 , tinP , idLineP , idiFileP ) ;
            _IO_
        {
        voidT* listC::operator new[]( countT cbP , tinS& tinP , const countT idLineP , const countT idiFileP )

        }
            return pvr ;
            voidT* pvr = (voidT*)( (byteT*)pvn + cbaFoot ) ;

            }
                putNegAM( *(countT*)( (byteT*)pvn + cbaFoot - sizeof( countT ) ) , FINGERnEG_FOOTc2 ) ;
                putNegAM( *(countT*)pvn , FINGERnEG_FOOTc1 ) ;
                BLAMMOiD( 0x8 ) ;
            {
            if( cbaFoot )
            __Z( pvn ) ;

            if( pNapkinP && *pNapkinP == ( cbaFoot + cbP ) ) pvn = (voidT*)(byteT*)*pNapkinP ;
            ZE( voidT* , pvn ) ;

            countT cbaFoot = cbFootP ? cbFootP + 2 * sizeof( countT ) : 0 ;
            if( !pNapkinP ) BLAMMOiD( 0x7 ) ;
            _IO_
        {
        voidT* listC::operator new( countT cbP , const countT cbFootP , tinS& tinP , napkinC* const pNapkinP )

        }
            return pvr ;
            voidT* pvr = (voidT*)( pbZombieP + cbaFoot ) ;
            }
                putNegAM( *(countT*)( pbZombieP + cbaFoot - sizeof( countT ) ) , FINGERnEG_FOOTc2 ) ;
                putNegAM( *(countT*)pbZombieP , FINGERnEG_FOOTc1 ) ;
                BLAMMOiD( 0x6 ) ;
            {
            if( cbaFoot )
            if( cbZombieP - ( cbaFoot + cbP ) ) BLAMMOiD( 0x5 ) ;
            countT cbaFoot = cbFootP ? cbFootP + 2 * sizeof( countT ) : 0 ;
            if( !pbZombieP ) BLAMMOiD( 0x4 ) ;
            _IO_
        {
        voidT* listC::operator new( countT cbP , const countT cbFootP , tinS& tinP , byteT* pbZombieP , const countT cbZombieP )

        }
            return pvr ;
            voidT* pvr = (voidT*)( (byteT*)pvn + cbaFoot ) ;
            }
                putNegAM( *(countT*)( (byteT*)pvn + cbaFoot - sizeof( countT ) ) , FINGERnEG_FOOTc2 ) ;
                putNegAM( *(countT*)pvn , FINGERnEG_FOOTc1 ) ;
                BLAMMOiD( 0x3 ) ;
            {
            if( cbaFoot )
            __Z( pvn ) ;
            }
                pNote->cbRequested  = pNote->cbUsedReally = cbaFoot + cbP ;
                pNote->idType       = ifciDtYPEdROPnOTE_listC ;
            {
            if( pNote )
            dropNoteS* pNote = !tinP.pPoolUse ? 0 : PUSE.pDropNoteF( tinP , (byteT*)pvn ) ;

            }
                ___LF( pvn , idLineP , idiFileP ) ;
                PUSE.newF( tinP , LF , *(byteT**)&pvn , ( cbaFoot + cbP ) ) ;
            {
            else
            if( !tinP.pPoolUse ) *(byteT**)&pvn = (processGlobal4I).heap.newF( tinP , LF , ( cbaFoot + cbP ) ) ;
            ZE( voidT* , pvn ) ;
            countT cbaFoot = cbFootP ? cbFootP + 2 * sizeof( countT ) : 0 ;
            _IO_
        {
        voidT* listC::operator new( countT cbP , const countT cbFootP , tinS& tinP , const countT idLineP , const countT idiFileP )

        }
            operator delete( pvP ) ;
            _IO_
            TINSL
        {
        voidT listC::operator delete[]( voidT* pvP )

        }
            }
                PUSE( tinP , *(byteT**)&pvP ) ;
            {
            if( pvP && !( F(tinP.flagsThreadMode3) & flTHREADmODE3_DOnOTcaLLdELif ) )

            if( idType == ifciDtYPEdROPnOTE_strokeS && ((strokeS*)pvP)->idCaste != sc_cADAM ) { BLAMMOiD( 0x1 ) ; }
            countT idType = ifciDtYPEdROPnOTE_listC ;
            _IO_
            TINSL
        {
        voidT listC::operator delete( voidT* pvP )

    //#define NEWdELcLASS0(listC,listC,sizeof( listC ),processGlobal4I)


//#define NEWdELcLASSb(classP)  NEWdELcLASS0( classP , classP , sizeof( classP ) , processGlobal4I )

//NEWdELcLASSb(         listC                         )




NEWdELcLASSb(         list_listingVSP_C             )
NEWdELcLASSb(         list_countTstrz_C             )
NEWdELcLASSb(         list_countT_C                 )
NEWdELcLASSb(         list_blob_C                   )
NEWdELcLASSb(         linkedC                       )
NEWdELcLASSb(         link189S                      )
NEWdELcLASSbSIZED(    lexC                          )
NEWdELcLASSb(         jotC                          )
NEWdELcLASSb(         ipMapPortS                    )
NEWdELcLASSb(         ipMapHomeS                    )
NEWdELcLASSb(         infoFileS                     )
NEWdELcLASSb(         infoDiskS                     )
NEWdELcLASSb(         infoDisk1S                    )
NEWdELcLASSb(         in_countTstrz_C               )
NEWdELcLASSb(         in_countT_C                   )
NEWdELcLASSb(         in_byteTstrz_C                )
NEWdELcLASSb(         imageExeDllC                  )
NEWdELcLASSb(         portC                         )
NEWdELcLASSb(         httpReplyRefC                 )
NEWdELcLASSb(         httpReplyS                    )


/*1*//*NEWdELcLASS (all invocations)*//*1*/

/**/
*/
this set of NEWdELcLASSb invocations is split into groups because it takes a long time to compile the whole set, which can cause some cpu's to be idle wastefully
placing all NEWdELcLASS lines here also makes it a bit easier to define a new class, since wo less source file must be created
this is done primarily to accomodate _IO_ in the new delete definitions, which would refer to "this" pointer if the above lines appeared with the member functions for the varous classes
place all uses of NEWdELcLASSb here
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

