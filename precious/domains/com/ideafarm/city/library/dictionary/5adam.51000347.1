
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

REST
etThread.osProcessIdPhaseAdamF( tinBaseP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

HEAReNTER( ether )
etThread.strokeF( tinBaseP , T("\r\n\r\npress the enter key") ) ;

}
    sgnDoneR.waitF( tinBaseP ) ;
    sgnDoneL.waitF( tinBaseP ) ;

    cbDatum = 0 ; sTalk.writeF( tinBaseP , (byteT*)&cbDatum , sizeof cbDatum ) ;
    cbDatum = 4 ; sTalk.writeF( tinBaseP , (byteT*)&cbDatum , sizeof cbDatum ) ; sTalk.writeF( tinBaseP , "dddd" ) ;
    cbDatum = 3 ; sTalk.writeF( tinBaseP , (byteT*)&cbDatum , sizeof cbDatum ) ; sTalk.writeF( tinBaseP , "ccc" ) ;
    cbDatum = 2 ; sTalk.writeF( tinBaseP , (byteT*)&cbDatum , sizeof cbDatum ) ; sTalk.writeF( tinBaseP , "bb" ) ;
    cbDatum = 1 ; sTalk.writeF( tinBaseP , (byteT*)&cbDatum , sizeof cbDatum ) ; sTalk.writeF( tinBaseP , "a" ) ;
    ZE( countT , cbDatum ) ;

    sTalk.connectF( tinBaseP , idPortR ) ;
    socketC sTalk( tinBaseP , ether , TAG( TAGiDnULL ) ) ;

    sgnReadyR.waitF( tinBaseP ) ;
    { ZE( countT , tnu ) ; etThread.osThreadF( tinBaseP , tnu , tmRelayOldF , &sgnDoneR , flTHREADlAUNCH_null , 0 , 0 , (countT)&sRelayOut , (countT)&idPortR , (countT)&sgnReadyR ) ; }
    signC sgnDoneR( tinBaseP , TAG( TAGiDnULL ) ) ;
    signC sgnReadyR( tinBaseP , TAG( TAGiDnULL ) ) ;
    ZE( countT , idPortR ) ;
    sRelayOut.connectF( tinBaseP , idPortL ) ;
    socketC sRelayOut( tinBaseP , ether , TAG( TAGiDnULL ) ) ;

    sgnReadyL.waitF( tinBaseP ) ;
    { ZE( countT , tnu ) ; etThread.osThreadF( tinBaseP , tnu , tmListenF , &sgnDoneL , flTHREADlAUNCH_null , 0 , 0 , (countT)&idPortL , (countT)&sgnReadyL ) ; }
    signC sgnDoneL( tinBaseP , TAG( TAGiDnULL ) ) ;
    signC sgnReadyL( tinBaseP , TAG( TAGiDnULL ) ) ;
    ZE( countT , idPortL ) ;
{

TODO

DONE( tmRelayOldF )
etThread.strokeF( tinBaseP , T("tmRelayOld -\r\n") ) ;
}
    DEL( pso ) ;
    }
        sRelayOut.writeF( tinBaseP , (byteT*)&cbo , sizeof cbo ) ;
        ZE( countT , cbo ) ;
        etThread.sockRelayF( tinBaseP , sRelayOut , *pso ) ;
    {
    if( pso )
    sRelay.acceptF( tinBaseP , pso , idPortPeer , nnPeer , countTC() ) ;
    ZE( countT , idPortPeer ) ;
    nicNameC nnPeer ;
    ++ sgnReadyR ;
    ZE( socketC* , pso ) ;
    sRelay.listenF( tinBaseP ) ;
    idPortRelay = sRelay.bindF( tinBaseP ) ;
    socketC sRelay( tinBaseP , ether , TAG( TAGiDnULL ) ) ;

    signC&   sgnReadyR   = *(signC*)  pTaskP->c3 ;
    countT&  idPortRelay = *(countT*) pTaskP->c2 ;
    socketC& sRelayOut   = *(socketC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
etThread.strokeF( tinBaseP , T("tmRelayOld +\r\n") ) ;
TASK( tmRelayOldF )

DONE( tmListenF )
etThread.strokeF( tinBaseP , T("tmListen -\r\n") ) ;
}
    DEL( pso ) ;
    }
        }
            etThread.delF( tinBaseP , pbDatum ) ;
            }
                etThread.strokeF( tinBaseP , T("tmListen received ")+TF1(cbDatum)+T(" bytes"": \"")+T(pbDatum)+T("\"\r\n") ) ;
                pbDatum[ cbDatum ] = 0 ;
                pso->readF( tinBaseP , pbDatum , cbDatum ) ;
            {
            if( pbDatum )
            etThread.newF( tinBaseP , LF , pbDatum , cbDatum + 1 ) ; ___( pbDatum ) ;
            ZE( byteT* , pbDatum ) ;

            if( !cbDatum ) break ;
            pso->readF( tinBaseP , (byteT*)&cbDatum , sizeof cbDatum ) ;
            ZE( countT , cbDatum ) ;
        {
        while( !ether && !etThread )
    {
    if( pso )
    sL.acceptF( tinBaseP , pso , idPortPeer , nnPeer , countTC() ) ;
    ZE( countT , idPortPeer ) ;
    nicNameC nnPeer ;
    ++ sgnReadyL ;
    ZE( socketC* , pso ) ;

    sL.listenF( tinBaseP ) ;
    idPortL = sL.bindF( tinBaseP ) ;
    socketC sL( tinBaseP , ether , TAG( TAGiDnULL ) ) ;

    signC&  sgnReadyL = *(signC*) pTaskP->c2 ;
    countT& idPortL   = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
etThread.strokeF( tinBaseP , T("tmListen +\r\n") ) ;
TASK( tmListenF )

/*1*/WAKEhIDE( "example.simplest.func.1030109.etherC.sockRelayF" )/*1*/
/**/
*/
\<A HREF=\"5.9430104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

