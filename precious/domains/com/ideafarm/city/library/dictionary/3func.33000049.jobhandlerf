
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        if( POOP ) POOPR
        //etherC::ifcSayIF( T("jobHandlerF/")+TF1(idAdamHandlingP)+T("/")+TF1(idChatSessionP)+T("/-") , flSAY_APPEND | flSAY_LOG ) ;
        }
            }
                }
                    }
                        }
                            sgnDone_tmMakeTrays.waitF( tinBaseP ) ;
                            }
                                if( !sUse ) break ;
                                (*jobHearOrderF)( tinBaseP , ether , etThread , idAdam , idChatSessionP , sUse , cAppArg , c8arg ) ;
                                soulC& sUse = POOP ? sNull : sOrder ;
                                soulC sNull( tinBaseP , TAG( TAGiDnULL ) ) ;
    
                                pso->readF( tinBaseP , sOrder ) ;
                                soulC sOrder( tinBaseP , TAG( TAGiDnULL ) ) ;
                            {
                            while( !POOP && !etThread )
    
                            etThread.osThreadF( tinBaseP , countTC() , tmMakeTraysF , &sgnDone_tmMakeTrays , 0 , flTHREADlAUNCH_null , 0 , 0 , (countT)pso , (countT)&sOrder , idAdam , (countT)&cAppArg , (countT)&c8arg , (countT)jobFillCourseF , idChatSessionP ) ;
                            signC sgnDone_tmMakeTrays( tinBaseP , TAG( TAGiDnULL ) ) ;
                            count8S c8arg ;
                        {
                        if( !POOP )
    
                        sJob >> sOrder ;
                        soulC sOrder( tinBaseP , TAG( TAGiDnULL ) ) ;
    
                        __Z( bAccepted ) ;
                        sJob >> bAccepted ;
                        ZE( boolT  , bAccepted ) ;
    
                        nicNameHint << sJob ;
                        nicNameC nicNameHint ;
    
                        sJob >> idAdam ;
                        ZE( countT , idAdam ) ;
    
                        __( idCmd - ifcIDcMDsESSION_JOB ) ;
                        sJob >> idCmd ;
                        ZE( countT , idCmd ) ;
    
                        __( (countT)sJob - 5 ) ;
                    {
                    else // JOB DOER
                    }
                        }
                            sgnDone_tmRelayOldChatReplies.waitF( tinBaseP ) ;
                            if( POOP ) soUp.stopWaitingF( tinBaseP ) ; // WAD WAC: SERVER (UPWARD) IS NEVER RUDE; CLIENT (DOWNWARD) IS ALWAYS RUDE; SO THIS SOCKET CANCEL IS NOT LOGGED
                            }
                                else                  break ;
                                if( !POOP && sOrder ) soUp.writeF( tinBaseP , sOrder ) ;
    
                                pso->readF( tinBaseP , sOrder ) ;
                                soulC sOrder( tinBaseP , TAG( TAGiDnULL ) ) ;
                            {
                            while( !POOP && !etThread )
    
                            if( !etThread ) sgnReadTested.waitF( tinBaseP ) ;
                            etThread.osThreadF( tinBaseP , countTC() , tmRelayOldChatRepliesF , &sgnDone_tmRelayOldChatReplies , 0 , flTHREADlAUNCH_null , 0 , 0 , (countT)pso , (countT)&soUp , (countT)&sgnReadTested , 0 ) ;
                            signC sgnDone_tmRelayOldChatReplies( tinBaseP , TAG( TAGiDnULL ) ) ;
                            signC sgnReadTested( tinBaseP , TAG( TAGiDnULL ) ) ;
    
                            soUp.writeF( tinBaseP , sRelay ) ;
                            soUp.connectF( tinBaseP ) ;
                            socketC soUp( tinBaseP , *((tin9S&)tinBaseP).pEtScratch , TAG( TAGiDnULL ) ) ;
    
                            etThread.ifcChatRelayPackageF( tinBaseP , sRelay , sJob , idAdamHandlingP , TF1(idAdamHandlingP)+T("/ifcChatF/jobHandlerF/acceptor") , 1 , 0 , nicNameHint ) ;
                            soulC sRelay( tinBaseP , TAG( TAGiDnULL ) ) ;
                        {
                        if( !POOP )
    
                        }
                            ((tin9S&)tinBaseP).pEtScratch->memCopyF( tinBaseP , (byteT*)&nicNameHint , pbNicName + 1 , processGlobal2I.cb_nicNameC_ ) ;
    
                            __Z( pbNicName ) ;
                            __( cbNicName - 1 - processGlobal2I.cb_nicNameC_ ) ; // THE "1" CORRESPONDS TO THE flags2 BYTE
                            __( flags - ( flSOULiTEM_MADEoFcOUNToBJECTS | flSOULiTEM_INCREASINGiNsIGNIFICANCE ) ) ;
                            __( idType - ifcIDtYPEsOULiTEM_nicNameC ) ;
                            const byteT* const pbNicName = sJob.pbFieldF( tinBaseP , idType , flags , cbNicName , 3 ) ;
                            ZE( countT , cbNicName ) ;
                            ZE( flagsT , flags ) ;
                            ZE( countT , idType ) ;
                        {
                        nicNameC nicNameHint ;
    
                        bAccepted = 1 ;
                        __( idAdam - idAdamHandlingP ) ; // TO FACILITATE SECURITY AND SIMPLIFY DESIGN, AN ADAM DEF WILL ONLY ACCEPT JOBS FOR ITS OWN ADAM; IF SUPERVISORY LAYERS ARE DESIRED, THE SAME ADAM DEF MUST DEFINE THE WORKER FUNCTION AND ALL SUPERVISORY FUNCTIONS
                        __( (countT)sJob - 5 ) ;
                    {
                    if( !bAccepted ) // JOB ACCEPTOR
    
                    boolT& bAccepted = sJob.cFieldF( tinBaseP , 4 ) ;
                    countT idAdam    = sJob.cFieldF( tinBaseP , 2 ) ;
                {
                if( !etThread && sJob.cFieldF( tinBaseP ) == ifcIDcMDsESSION_JOB )
    
                //etThread.strokeF( tinBaseP , T("jobHandlerF/")+T(*((tin9S&)tinBaseP).pEtScratch?"impotent":"aok")+T("/tested number of items in sJob\r\n") ) ; //U:
                //__( (countT)sJob - 5 ) ;
    
                pso->readF( tinBaseP , sJob ) ;
                soulC sJob( tinBaseP , TAG( TAGiDnULL ) ) ;
    
                jobHearOrderFT  jobHearOrderF  =  (jobHearOrderFT)c3p_jobHandler.c3 ;
                jobFillCourseFT jobFillCourseF = (jobFillCourseFT)c3p_jobHandler.c2 ;
                countT          cAppArg        =                  c3p_jobHandler.c1 ;
            {
            if( !ether && !etThread && !POOP )
    
            __( !c3p_jobHandler.c3 ) ;
            __( !c3p_jobHandler.c2 ) ;
            count3S& c3p_jobHandler = *(count3S*)cArgP ;
        {
        if( !ether && !etThread )
        //etherC::ifcSayIF( T("jobHandlerF/")+TF1(idAdamHandlingP)+T("/")+TF1(idChatSessionP)+T("/+") , flSAY_APPEND | flSAY_LOG ) ;
        SCOOPS
    {
    IFsCRATCH

    __Z( cArgP ) ;
    __Z( idAdamHandlingP ) ;
    __Z( pso ) ; //IN THIS DEFINITION, AS IN ALL CHAT HANDLERS, TESTS RELATED TO DOWNWARD CHAT USE etScratch; TESTS RELATED TO UPWARD CHAT USE etThread
{
/*1*/voidT jobHandlerF( tin0S& tinBaseP , etherC& ether , etherC& etThread , socketC*& pso , const countT idChatSessionP , countT cArgP , const countT idAdamHandlingP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

