
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

while( ~hFindDir && !ether && !POOP ) ;
}
    DEL( pInfoDir ) ;

    }
        }
            while( ~hFindFile && !ether && !POOP ) ;
            }
                DEL( pInfoFile ) ;

                }
                    }
                        }
                            }
                                }
                                    etThread.traceF( tin0P , T("could not create symbolic link [rc,name,target]: ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb+tOsNameTo+tb+tOsNameFrom ) ;
                                    if( rc ) ;
                                    countT rc = GetLastError() ;
                                {
                                if( !bOk )
                                boolT bOk = CreateSymbolicLink( tOsNameTo , tOsNameFrom , 0 ) ;

                                }
                                    etThread.traceF( tin0P , T("        to: ")+tOsNameTo   ) ;
                                    etThread.traceF( tin0P , T("      from: ")+tOsNameFrom ) ;
                                    etThread.traceF( tin0P , T("name: ")+tName  ) ;
                                {
                                if( bSay ) 
                            {
                            else
                            }
                                etThread.traceF( tin0P , T("link exists [tIfNameTo]: ")+tIfNameTo ) ;
                            {
                            if( etThread.diskFileExistsF( tin0P , tIfNameTo ) )

                            TN( tOsNameTo   , "" ) ; tOsNameTo   = T( osFileNameC( tin0P , etThread , tIfNameTo ) ) ;
                            TN( tIfNameTo   , "" ) ; tIfNameTo   = tPathDirLinks+tShortDir+TF3(++idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+tDot+tName ;
                            TN( tOsNameFrom , "" ) ; tOsNameFrom = T( osFileNameC( tin0P , etThread , tIfoName                                                                                                                     ) ) ;
                            etThread.diskMakeDirIfNeededF( tin0P , tPathDirLinks+tShortDir ) ;

                            //etThread.diskMoveFileOrDirF( tin0P , tPathDir+tShortDir+TF3(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,8)+tDot+tName , tIfoName ) ;

                            //etThread.traceF( tin0P , tShortFile+tb8+tName ) ;

                            }
                                etThread.delF( tin0P , postName ) ;
                                tName = T(postName) ;
                                etThread.boxGetShadowF( tin0P , postName , costName , tFileMetaNameLong ) ; ___( postName ) ;
                                ZE( countT   , costName ) ;
                                ZE( osTextT* , postName ) ;
                            {
                            else
                            if( !etThread.diskFileExistsF( tin0P , tFileMetaNameLong ) ) etThread.traceF( tin0P , T("error / file does not exist: ")+tFileMetaNameLong ) ;
                            TN( tName , "" ) ;

                            TN( tFileMetaNameLong , "" ) ; tFileMetaNameLong = tPathDir+tShortDir+tShortFileMetaName ;

                            etThread.delF( tin0P , psttShortFileRoot ) ;
                            TN( tLongMetaDotStar , "" ) ; tLongMetaDotStar = tPathDir+tShortDir+T(psttShortFileRoot)+tMetaDotStar ;
                            TN( tShortFileMetaName , "" ) ; tShortFileMetaName = T(psttShortFileRoot)+tMetaDotCurrentName ;

                            etThread.strSubstringF( tin0P , psttShortFileRoot , idf , idHit , tShortFile ) ; ___( psttShortFileRoot ) ;
                            countT idf = 1 ;
                            ZE( strokeS* , psttShortFileRoot ) ;
                        {
                        if( idHit )
                        countT idHit = etThread.strIdF( tin0P , countTC( 1 ) , tDotDataDot , tShortFile ) ;

                        boolT bSay = 1 /* !( ++ idFile % TUCK ) || idFile == 1 */ ;
                    {
                    if( !bDir )

                    }
                        etThread.delF( tin0P , psttShortFile ) ;
                        tShortFile = T(psttShortFile) ;
                        etThread.delF( tin0P , psttnu ) ;
                        etThread.strBisectF( tin0P , psttnu , psttShortFile , pInfoFile->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShortFile ) ;
                        ZE( strokeS* , psttShortFile ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShortFile , "" ) ;

                    const boolT bDir = pInfoFile->psttIfoName[ CSpREFIX - 1 + pInfoFile->psttIfoName->idAdam ].idAdam == '/' ;
                    TN( tIfoName , pInfoFile->psttIfoName ) ;
                {
                else
                }
                    break ;
                    DEL( pInfoFile ) ;
                {
                if( !pInfoFile || !pInfoFile->psttIfoName )

                etThread.diskFindFileOrDirOldF( tin0P , pInfoFile , hFindFile , tPathDir+tShortDir+tLikeFile ) ; ___( pInfoFile ) ;
                ZE( infoFileS* , pInfoFile ) ;
            {
            do
            handleC hFindFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            ZE( countT , idFile ) ;

            //etThread.traceF( tin0P , tShortDir ) ;
        {
        if( bDir && etThread.strCompareF( tin0P , tDotSlash , tShortDir ) && etThread.strCompareF( tin0P , tDotDotSlash , tShortDir ) )

        }
            etThread.delF( tin0P , psttShortDir ) ;
            tShortDir = T(psttShortDir) ;
            etThread.delF( tin0P , psttnu ) ;
            etThread.strBisectF( tin0P , psttnu , psttShortDir , pInfoDir->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShortDir ) ;
            ZE( strokeS* , psttShortDir ) ;
            ZE( strokeS* , psttnu ) ;
        {
        TN( tShortDir , "" ) ;

        const boolT bDir = pInfoDir->psttIfoName[ CSpREFIX - 1 + pInfoDir->psttIfoName->idAdam ].idAdam == '/' ;
        TN( tIfoName , pInfoDir->psttIfoName ) ;
    {
    else
    }
        break ;
        DEL( pInfoDir ) ;
    {
    if( !pInfoDir || !pInfoDir->psttIfoName )

    etThread.diskFindFileOrDirOldF( tin0P , pInfoDir , hFindDir , tPathDir+tLikeDir ) ; ___( pInfoDir ) ;
    ZE( infoFileS* , pInfoDir ) ;
{
do
handleC hFindDir( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

TN( tDot , "." ) ;
TN( tDotDotSlash , "../" ) ;
TN( tDotSlash , "./" ) ;
TN( tb8 , "        " ) ;
TN( tb , " " ) ;
TN( tMetaDotStar , "meta.*" ) ;
TN( tMetaDotCurrentName , "meta.currentname" ) ;
TN( tDotDataDot , ".data." ) ;
TN( tSlash , "/" ) ;
TN( tLikeFile , "!ideafarm.8.2.00000000.00000001.*.data.*" ) ;
TN( tLikeDir , "*" ) ;
TN( tPathDirLinks , "///d/archive.links/" ) ;
TN( tPathDir      , "///d/archive/" ) ;

TODO

/*1*/WAKEsHOWtEXT( "tool.file.create.symbolic.links.into.archive" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
