
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
        }
            // U:: REFRESH THE ENCLOSED SNAPSHOT OF OPENSSL TO CURRENT STABLE RELEASE (PERHAPS THIS CRAP BEHAVIOR WILL BE GONE)
            // THIS CODE WILL LEAK IF COULD HAVE FREED ITS CONTEXT SUCCESSFULLY, BUT THERE IS NO WAY TO KNOW (OpenSSL IS SUCH A PIECE OF SHIT)
            THREADmODE5oN( flTHREADmODE5_DOnOTfREEsSLcONTEXT )  // WILL BE DETECTED AND RESET DURING DT OF hSslContext
            etherC::etTextIF( tinBaseP ).traceF( tinBaseP , T("~socketC / suppressing OpenSSL free context call to avoid blocking this thread") ) ;
            etherC::etTextIF( tinBaseP ).traceF( tinBaseP , T("~socketC [this,flagsOpenSslFails]:    ")+TF2((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(flagsOpenSslFails,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            TN( tb4 , "    " ) ;
        {
        if( F(flagsOpenSslFails) )
    
        if( pMapPortBind ) pMapPortBind->idPortSpecified = pMapPortBind->idPortActual = 0 ;
    
        *pEther = ecSave ;
    
        pEther->delF( tinBaseP , psttPemPrivateKey   ) ;
        pEther->delF( tinBaseP , psttPemCertificates ) ;

        }
            }
                pEther->delF( tinBaseP , *pppczKTS[ off ] ) ;
                }
                    }
                        if( POOP ) POOPR
                        ((tinFullS&)tinBaseP).pEtScratch->boxZapF( tinBaseP , tLong , 1 ) ;
                        SCOOPS
                    {
                    IFsCRATCH
            
                    TN( tLong , "" ) ; tLong = T("///desk/" POSTfOLDERsECURITYkEYdEPOSITORY)+(idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/")+tShort ;
                    textC tShort( tinBaseP , TAG( TAGiDnULL ) , flTEXTc_null , *pppczKTS[ off ] , flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE , 8 , 0 , tDot ) ;
                    TN( tDot , "." ) ;
                {                                      //U::ALT: SET A FLAG TO REMEMBER THAT PEER'S KEY ALREADY EXISTED, SO DON'T DELETE IT
                if( /*off == 0 &&*/ *pppczKTS[ off ] ) //U::DELETE MY COPY OF THE PEER'S KEY IFF IT DID NOT OVERWRITE EXISTING COPY
            {
            for( countT off = 0 ; off < 2 ; off ++ )
            countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;
    
            countT** pppczKTS[] = { &pczKeyTopSecret , &pczKeyTopSecretPeer } ;
        {
    
        if( !( F(flags) & flSOCKETc_LEAVEsOCKEToPENwHENdIE ) && ~handle ) handle.closeIfF() ;
    
        bRead.ungrabF( tinBaseP ) ;
        }
            etherC::sockStkIdleTimeoutersF( tinBaseP ).ungrabF( tinBaseP ) ;
            else                                                     __1
            if( etherC::sockStkIdleTimeoutersF( tinBaseP )( (countT)this ) ) etherC::sockStkIdleTimeoutersF( tinBaseP ).extractF( tinBaseP ) ;
            etherC::sockStkIdleTimeoutersF( tinBaseP ).grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        {
        if( !( F(flags) & flSOCKETc_DOnOTrEGISTERtIMEoUT ) )
    
        }
            etherC::sockStkAcceptorsF( tinBaseP ).ungrabF( tinBaseP ) ;
            else                                                     __1
            if( etherC::sockStkAcceptorsF( tinBaseP )( (countT)this ) ) etherC::sockStkAcceptorsF( tinBaseP ).extractF( tinBaseP ) ;
            etherC::sockStkAcceptorsF( tinBaseP ).grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        {
        if( bAcceptor && !( F(flags) & flSOCKETc_DOnOTrEGISTERaCCEPTOR ) )
    
        }
            etherC::sockStkQuittersF( tinBaseP ).ungrabF( tinBaseP ) ;
            else if( !fListening )                                 __1
            if( etherC::sockStkQuittersF( tinBaseP )( (countT)this ) ) etherC::sockStkQuittersF( tinBaseP ).extractF( tinBaseP ) ;
            etherC::sockStkQuittersF( tinBaseP ).grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        {
        if( idType != ifcSOCKETtYPE_DATAgRAM && !( F(flags) & flSOCKETc_DOnOTrEGISTERqUITTER ) )
    
        }
            etherC::sockStkCatchersF( tinBaseP ).ungrabF( tinBaseP ) ;
            else                                                   __1
            if( etherC::sockStkCatchersF( tinBaseP )( (countT)this ) ) etherC::sockStkCatchersF( tinBaseP ).extractF( tinBaseP ) ;
            etherC::sockStkCatchersF( tinBaseP ).grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        {
        if( bCatcher && !( F(flags) & flSOCKETc_DOnOTrEGISTERcATCHER ) )
    
        *pEther = 0 ;
        const countT ecSave = *pEther ;
    
        pEther->delF( tinBaseP , psttName ) ;
    
        bRead.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

        ((tinFullS&)tinBaseP).pag3->_socketC_.grab.ungrabF( tinBaseP ) ;
        }
            DEL( ((tinFullS&)tinBaseP).pag3->_socketC_.pSwOdometer ) ;
    
            }
                //if( ((tinFullS&)tinBaseP).pc Utility[ 0 ] ) { LOGrAW( TD("socketC::~socketC/odometer/")+TF3(pOdometer->cbRead,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+T(" ")+TF3(pOdometer->cbWrite,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+T(((tinFullS&)tinBaseP).pag3->_socketC_.nnLever)+T("\r\n") ) ; }
                pOdometer = (sockOdometerS*)&(countT&)*((tinFullS&)tinBaseP).pag3->_socketC_.pSwOdometer ;
                ((tinFullS&)tinBaseP).pag3->_socketC_.nnLever = *(nicNameC*)((tinFullS&)tinBaseP).pag3->_socketC_.pSwOdometer->leverF( tinBaseP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = ((tinFullS&)tinBaseP).pag3->_socketC_.pSwOdometer->cFlavorsF( tinBaseP ) ;
    
            if( !((tinFullS&)tinBaseP).pag3->_socketC_.pSwOdometer ) { BLAMMO ; }
        {
        if( 1 == decv02AM( ((tinFullS&)tinBaseP).pag3->_socketC_.cRef ) )
        ((tinFullS&)tinBaseP).pag3->_socketC_.grab.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
    
        }
            THREADmODE2rESTORE
            }
                ++ s ; thirdC::dosSleepWinkIF( tinBaseP ) ;
            {
            while( cFunctionsPending > 1 )
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        {
    
        SCOOPP

        //if( ((tinFullS&)tinBaseP).pc Utility[ 0 ] == (countT)this ) ((tinFullS&)tinBaseP).pEther->traceF( tinBaseP , T("~socketC: it's being deleted!") ) ; //U:: TO FIND A BUG
    
        _IO_
        TINSL
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/socketC::~socketC( voidT )/*1*/

/**/
*/
 this is to avoid having an invalid pointer exist
i will deregister myself from stAcceptors even if i am impotent
 i do not refer to bRead or bWrite before closing the socket
i can be called while another thread is blocked on a read or a write
  \<A HREF=\"5.5420104.1.1.0.html\"\>5420104:  WAKEsHOW( "example.simplest.func.1070003.socketC.dt_socketC" )\</A\>
 simplest
examples
\<A HREF=\"5.1070003.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

