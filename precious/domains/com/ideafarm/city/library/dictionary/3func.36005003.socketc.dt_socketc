
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    dec02AM( cFunctionsPending ) ;
    }
        }
            // U:: REFRESH THE ENCLOSED SNAPSHOT OF OPENSSL TO CURRENT STABLE RELEASE (PERHAPS THIS CRAP BEHAVIOR WILL BE GONE)
            // THIS CODE WILL LEAK IF COULD HAVE FREED ITS CONTEXT SUCCESSFULLY, BUT THERE IS NO WAY TO KNOW (OpenSSL IS SUCH A PIECE OF SHIT)
            THREADmODE4oN( flTHREADmODE4_DOnOTfREEsSLcONTEXT )  // WILL BE DETECTED AND RESET DURING DT OF hSslContext
            etherC::etTextIF( tin0P ).traceF( tin0P , T("~socketC / suppressing OpenSSL free context call to avoid blocking this thread") ) ;
            etherC::etTextIF( tin0P ).traceF( tin0P , T("~socketC [this,flagsOpenSslFails]:    ")+TF2((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(flagsOpenSslFails,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            TN( tb4 , "    " ) ;
        {
        if( F(flagsOpenSslFails) )
    
        if( pMapPortBind ) pMapPortBind->idPortSpecified = pMapPortBind->idPortActual = 0 ;
    
        *pEther = ecSave ;
    
        pEther->delF( tin0P , psttPemPrivateKey   ) ;
        pEther->delF( tin0P , psttPemCertificates ) ;

        }
            }
                pEther->delF( tin0P , *pppczKTS[ off ] ) ;
                }
                    }
                        if( POOP ) POOPR
                        ((tin123S&)tin0P).pEtScratch->boxZapF( tin0P , tLong , 1 ) ;
                        SCOOPS
                    {
                    IFsCRATCH
            
                    TN( tLong , "" ) ; tLong = T("///desk/" POSTfOLDERsECURITYkEYdEPOSITORY)+(idHomeDisk==1?T(""):T(" (Home ")+TF1(idHomeDisk)+T(")"))+T("/")+tShort ;
                    textC tShort( tin0P , TAG( TAGiDnULL ) , flTEXTc_null , *pppczKTS[ off ] , flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE , 8 , 0 , tDot ) ;
                    TN( tDot , "." ) ;
                {                                      //U::ALT: SET A FLAG TO REMEMBER THAT PEER'S KEY ALREADY EXISTED, SO DON'T DELETE IT
                if( /*off == 0 &&*/ *pppczKTS[ off ] ) //U::DELETE MY COPY OF THE PEER'S KEY IFF IT DID NOT OVERWRITE EXISTING COPY
            {
            for( countT off = 0 ; off < 2 ; off ++ )
            countT idHomeDisk = etherC::ifc_idHomeIdisk_IF() ;
    
            countT** pppczKTS[] = { &pczKeyTopSecret , &pczKeyTopSecretPeer } ;
        {
    
        if( !( F(flags) & flSOCKETc_LEAVEsOCKEToPENwHENdIE ) && ~handle ) handle.closeIfF() ;
    
        bRead.ungrabF( tin0P ) ;
        }
            etherC::sockStkIdleTimeoutersF( tin0P ).ungrabF( tin0P ) ;
            else                                                     __1
            if( etherC::sockStkIdleTimeoutersF( tin0P )( (countT)this ) ) etherC::sockStkIdleTimeoutersF( tin0P ).extractF( tin0P ) ;
            etherC::sockStkIdleTimeoutersF( tin0P ).grabF( tin0P , TAG( TAGiDnULL ) ) ;
        {
        if( !( F(flags) & flSOCKETc_DOnOTrEGISTERtIMEoUT ) )
    
        }
            etherC::sockStkAcceptorsF( tin0P ).ungrabF( tin0P ) ;
            else                                                     __1
            if( etherC::sockStkAcceptorsF( tin0P )( (countT)this ) ) etherC::sockStkAcceptorsF( tin0P ).extractF( tin0P ) ;
            etherC::sockStkAcceptorsF( tin0P ).grabF( tin0P , TAG( TAGiDnULL ) ) ;
        {
        if( bAcceptor && !( F(flags) & flSOCKETc_DOnOTrEGISTERaCCEPTOR ) )
    
        }
            etherC::sockStkQuittersF( tin0P ).ungrabF( tin0P ) ;
            else if( !fListening )                                 __1
            if( etherC::sockStkQuittersF( tin0P )( (countT)this ) ) etherC::sockStkQuittersF( tin0P ).extractF( tin0P ) ;
            etherC::sockStkQuittersF( tin0P ).grabF( tin0P , TAG( TAGiDnULL ) ) ;
        {
        if( idType != ifcSOCKETtYPE_DATAgRAM && !( F(flags) & flSOCKETc_DOnOTrEGISTERqUITTER ) )
    
        }
            etherC::sockStkCatchersF( tin0P ).ungrabF( tin0P ) ;
            else                                                   __1
            if( etherC::sockStkCatchersF( tin0P )( (countT)this ) ) etherC::sockStkCatchersF( tin0P ).extractF( tin0P ) ;
            etherC::sockStkCatchersF( tin0P ).grabF( tin0P , TAG( TAGiDnULL ) ) ;
        {
        if( bCatcher && !( F(flags) & flSOCKETc_DOnOTrEGISTERcATCHER ) )
    
        *pEther = 0 ;
        const countT ecSave = *pEther ;
    
        pEther->delF( tin0P , psttName ) ;
    
        bRead.grabF( tin0P , TAG( TAGiDnULL ) ) ;

        ((tin1S&)tin0P).pag3->_socketC_.grab.ungrabF( tin0P ) ;
        }
            DEL( ((tin1S&)tin0P).pag3->_socketC_.pSwOdometer ) ;
    
            }
                //if( ((tin123S&)tin0P).pc Utility[ 0 ] ) { LOGrAW( TD("socketC::~socketC/odometer/")+TF3(pOdometer->cbRead,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+T(" ")+TF3(pOdometer->cbWrite,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES,8)+T(((tin1S&)tin0P).pag3->_socketC_.nnLever)+T("\r\n") ) ; }
                pOdometer = (sockOdometerS*)&(countT&)*((tin1S&)tin0P).pag3->_socketC_.pSwOdometer ;
                ((tin1S&)tin0P).pag3->_socketC_.nnLever = *(nicNameC*)((tin1S&)tin0P).pag3->_socketC_.pSwOdometer->leverF( tin0P , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = ((tin1S&)tin0P).pag3->_socketC_.pSwOdometer->cFlavorsF( tin0P ) ;
    
            if( !((tin1S&)tin0P).pag3->_socketC_.pSwOdometer ) { BLAMMO ; }
        {
        if( 1 == decv02AM( ((tin1S&)tin0P).pag3->_socketC_.cRef ) )
        ((tin1S&)tin0P).pag3->_socketC_.grab.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    
        }
            THREADmODE1rESTORE
            }
                ++ s ; thirdC::dosSleepWinkIF( tin0P ) ;
            {
            while( cFunctionsPending > 1 )
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        {
    
        SCOOPP

        //if( ((tin123S&)tin0P).pc Utility[ 0 ] == (countT)this ) ((tin123S&)tin0P).pEther->traceF( tin0P , T("~socketC: it's being deleted!") ) ; //U:: TO FIND A BUG
    
        _IO_
        TINSL
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/socketC::~socketC( voidT )/*1*/

/**/
*/
 this is to avoid having an invalid pointer exist
i will deregister myself from stAcceptors even if i am impotent
 i do not refer to bRead or bWrite before closing the socket
i can be called while another thread is blocked on a read or a write
  \<A HREF=\"5.5420104.1.1.0.html\"\>5420104:  WAKEsHOW( "example.simplest.func.1070003.socketC.dt_socketC" )\</A\>
 simplest
examples
\<A HREF=\"5.1070003.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

