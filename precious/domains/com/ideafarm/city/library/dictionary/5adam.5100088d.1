
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etThread.traceF( tin0P , T("bye") ) ;
    etherC::loafIF( tin0P ) ;
    etThread.traceF( tin0P , T("ok") ) ;

    }
        ++ s ; ether.osSleepF( tin0P , TOCK ) ;

        }
            }
                if( !( -- cShots ) ) break ;
                haltRdpServerF( tin0P , etThread ) ;
                if( cShots == 8 ) etThread.traceF( tin0P , T("intrusion into the RDP server detected") ) ;                      // HALT THE RDP SERVER
            {
            else if( tallyNormal >= 8 )                                                                                 // IF CURRENT VALUE HAS RISEN AFTER A LONG STRING OF NORMAL
            else if( cHitsNormal == cHits1Now ) tallyNormal ++ ;                                                         // IF CURRENT VALUE IS NORMAL THEN TALLY
            }
                tallyNormal = 1        ;
                cHitsNormal = cHits1Now ;                                                                                        // RESET THE NORMAL VALUE AND BEGIN TALLYING
            {
            if( !cHitsNormal || cHitsNormal > cHits1Now )                                                                // IF DO NOT HAVE A NORMAL VALUE OR THE NORMAL VALUE IS HIGHER THAN THE CURRENT VALUE
        {
        else
        if( !cHits1Now || !cHits2Now ) tallyNormal = cHitsNormal = 0 ;

        //etThread.traceF( tin0P , T("[cHits1Now,cHits2Now]:    ")+TF2(cHits1Now,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cHits2Now,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        //etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------------------------------------------------") ) ;
        EnumWindows( enumWindowsCBF , (countT)pcArg ) ;
        //etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------------------------------------------------") ) ;

        countT& cHits2Now = pcArg[ 2 ] ;
        countT& cHits1Now = pcArg[ 1 ] ;
        countT  pcArg[]  = { (countT)&etThread , 0 , 0 } ;
    {
    while( !ether )
    ZE( countT , tallyNormal ) ;
    ZE( countT , cHitsNormal ) ;
    countT cShots = 8 ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    TN( tb4 , "    " ) ;

    testApiAccessF( tin0P , etThread ) ;

    etThread.traceF( tin0P , T("I will detect intrusion into the RDP server and halt it ; Instructions:  (1) Hire me on a laptop.  (2) RDP into the RDP server.  I will detect intrusion by detecting a change in the list of windows.") ) ;

    _IO_
{
if( pTaskP )
TASK( tmWorkF )

}
    return TRUE ;

    }
        if( !etherP.strCompareF( tin0P , tTitle , T(postGoodTitle) ) ) cHits2P ++ ;

        //etherP.traceF( tin0P , tTitle ) ;
        cHits1P ++ ;
    {
    if( etherP.strIdF( tin0P , T("Remote Desktop Connection") , tTitle ) )

    TN( tTitle , postTitle ) ;
    countT  costTitle = GetWindowTextA( hWindowP , postTitle , sizeof postTitle ) ;
    osTextT postTitle[ TUCK ] ;

    countT& cHits2P = pcArgP[ 2 ] ;
    countT& cHits1P = pcArgP[ 1 ] ;
    etherC& etherP  = *(etherC*)pcArgP[ 0 ] ;
    countT* pcArgP  = (countT*)cArgP ;

    TINSL
{
BOOL CALLBACK enumWindowsCBF( HWND hWindowP , LPARAM cArgP )

}
    etherP.delF( tin0P , posti ) ;
    }
        DEL( pSwPathValue ) ;

        }
            }
                etherP.delF( tin0P , psttValue ) ;

                }
                    }
                        etherP.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                        *pptValue[ offe ] = T(psttValue) ;
                    {
                    if( !etherP.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                {
                for( countT offe = 0 ; offe < cPaths ; offe ++ )

                if( cPaths - cValues ) { BLAMMO ; }
                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                etherP.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                etherP.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;

                strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                _IO_
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
            _IO_
        {
        if( !POOP )

        ;
        }
            &tPathError     ,
            &tPathErrorCode ,
        {
        textC* pptPath[] =

        TN( tPathError     , "\"error\"/"   ) ;
        TN( tPathErrorCode , "\"errcode\"/" ) ;

        ;
        }
            &tValueError     ,
            &tValueErrorCode ,
        {
        textC* pptValue[] =

        TN( tValueError     , "" ) ;
        TN( tValueErrorCode , "" ) ;

        __Z( pSwPathValue ) ;
        }
            }
                etherP.traceF( tin0P , T("!exception / could not parse json") ) ;
                POOPRqUIET
            {
            if( POOP )
            ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)posti , flSTACKc_null ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        ZE( switchC* , pSwPathValue ) ;
        ZE( strokeS* , psttPath     ) ;
        _IO_
    {
    if( posti )

    //etherP.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    //etherP.traceF( tin0P , T(posti) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    //etherP.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

    }
        }
            //FAILURE IS EXPECTED WHEN THE ENDPOINT RETURNS NO BODY: etherP.traceF( tin0P , T("!exception / boxGetShadowF failed") ) ;
            POOPRqUIET
        {
        if( POOP )
        ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , T("api.vultr.com//https/v2/instances") , 1 , 0 , 0 , flOPENdETAILS_null , flBOXcgETf_HTTPdOnOTpREPENDhEADER , tRequestHalt , tRequestHalt.csF( tin0P ) ) ; ___( posti ) ;
        SCOOPS
    {
    IFsCRATCHoK
    ZE( countT   , costi ) ;
    ZE( osTextT* , posti ) ;

    //etherP.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    //etherP.traceF( tin0P , tRequestHalt , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    //etherP.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

    TN( tRequestHalt , "" ) ; tRequestHalt = T(postHeadHalt)+tApiKey+tContentLengthHalt+T(postBodyHalt) ;

    }
        tContentLengthHalt = T("\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;
        //"Content-Length: 5718\r\n"

        const countT costBody = sizeof postBodyHalt - 1 ;
    {
    TN( tContentLengthHalt , "" ) ; 

    }
        etherP.delF( tin0P , psttApiKey ) ;
        tApiKey = T(psttApiKey) ;
        etherP.querySettingF( tin0P , psttApiKey , T("!ipdos.credential.vultr.apikey")  ) ; ___( psttApiKey ) ;
        ZE( strokeS* , psttApiKey ) ;
    {
    TN( tApiKey , "" ) ;

    etherP.traceF( tin0P , T("halting the rdp server") ) ;
{
voidT haltRdpServerF( tin0S& tin0P , etherC& etherP )

}
    if( tValueId.csF( tin0P ) ) etherP.traceF( tin0P , T("i was able to query the id of the rdp server, so my access to the API is confirmed") ) ;

    }
        etherP.delF( tin0P , posti ) ;

        }
            DEL( pSwPathValue ) ;

            }
                }
                    etherP.delF( tin0P , psttValue ) ;

                    }
                        }
                            etherP.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                            *pptValue[ offe ] = T(psttValue) ;
                        {
                        if( !etherP.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                    {
                    for( countT offe = 0 ; offe < cPaths ; offe ++ )

                    if( cPaths - cValues ) { BLAMMO ; }
                    countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                    countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                    //etherP.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                    //etherP.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;

                    strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                    psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                    _IO_
                {
                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                _IO_
            {
            if( !POOP )

            ;
            }
                &tPathId ,
            {
            textC* pptPath[] =

            TN( tPathId , "\"instances\"/item.00000001/\"id\"/" ) ;

            ;
            }
                &tValueId ,
            {
            textC* pptValue[] =


            __Z( pSwPathValue ) ;
            }
                }
                    etherP.traceF( tin0P , T("!exception / could not parse json") ) ;
                    POOPRqUIET
                {
                if( POOP )
                ((tin1S&)tin0P).pEtScratch->strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)posti , flSTACKc_null ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK
            ZE( switchC* , pSwPathValue ) ;
            ZE( strokeS* , psttPath     ) ;
            _IO_
        {
        if( posti )

        //etherP.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        //etherP.traceF( tin0P , T(posti) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        //etherP.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------------------------------------------------") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

        }
            }
                //FAILURE IS EXPECTED WHEN THE ENDPOINT RETURNS NO BODY: etherP.traceF( tin0P , T("!exception / boxGetShadowF failed") ) ;
                POOPRqUIET
            {
            if( POOP )
            ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , T("api.vultr.com//https/v2/instances") , 1 , 0 , 0 , flOPENdETAILS_null , flBOXcgETf_HTTPdOnOTpREPENDhEADER , tRequestTest , tRequestTest.csF( tin0P ) ) ; ___( posti ) ;
            SCOOPS
        {
        IFsCRATCHoK
        ZE( countT   , costi ) ;
        ZE( osTextT* , posti ) ;

        TN( tRequestTest , "" ) ; tRequestTest = T(postHeadTest)+tApiKey+T("\r\n\r\n") ;

        }
            etherP.delF( tin0P , psttApiKey ) ;
            tApiKey = T(psttApiKey) ;
            etherP.querySettingF( tin0P , psttApiKey , T("!ipdos.credential.vultr.apikey")  ) ; ___( psttApiKey ) ;
            ZE( strokeS* , psttApiKey ) ;
        {
        TN( tApiKey , "" ) ;
    {
    TN( tValueId , "" ) ;

    etherP.traceF( tin0P , T("testing my access to the Vultr API") ) ;
{
voidT testApiAccessF( tin0S& tin0P , etherC& etherP )

osTextT postGoodTitle[] = { "rdp.ideafarm.com - Remote Desktop Connection" } ;

} ;

    "}\r\n"
    "    ]\r\n"
    "        \"03ffd76e-8072-466a-9d34-be4fdfab5799\"\r\n"
    "    [\r\n"
    "    \"instance_ids\" :\r\n"
    "{\r\n"

osTextT postBodyHalt[] = {

} ;

    "Authorization: Bearer "
    "POST /v2/instances/halt HTTP/1.0\r\n"

osTextT postHeadHalt[] = {

} ;

    "Authorization: Bearer "
    "GET /v2/instances?label=rdp HTTP/1.0\r\n"

osTextT postHeadTest[] = {

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_RDPiNTRUSIONdETECTOR" )/*1*/
/**/
*/

/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
