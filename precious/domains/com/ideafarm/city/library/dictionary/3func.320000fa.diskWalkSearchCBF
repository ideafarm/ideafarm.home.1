
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bDoIt ;
    }
        }
            }
                }
                    if( POOP ) POOPR

                    }
                        DEL( pInfo ) ;
                        }
                            ((tin1S&)tin0P).pEtScratch->delF( tin0P , posti ) ;
                            }
                                ((tin1S&)tin0P).pEther->traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

                                TN( tSay , "" ) ; tSay += T(postNameP)+T(" [idLine,idCol]: ")+TF4(idLine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T("(")+TF4(idCol,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,0,0xa)+T(")    ")+T(posti+offCurrentLine)+tCRLF ;

                                while( posti[ offCurrentLine ] == ' ' ) offCurrentLine ++ ;

                                //U:: LATER: OPTIONALLY ACCUMULATE THESE REPORT ENTRIES IN A stackC SO THAT CALLER CAN REPORT THEM
                            {
                            else
                            }
                                CONoUTrAW( "." ) ;  // VISUAL FEEDBACK IF RUNNING IN A CONSOLE WINDOW, BUT NO FEEDBACK INTO TRACE FILE
                            {
                            if( !idLine )

                            }
                                }
                                    }
                                        }
                                            posti[ offi ] = 0 ;
                                            )
                                                )
                                                    && posti[ offi + 1 ] != '\n'
                                                    && posti[ offi     ] == '\r'    //COUNTED: CARRIAGE RETURN NOT FOLLOWED BY NEW LINE (FILES PRODUCED BY COMMODORE AND EARLY MACINTOSH SYSTEMS)
                                                       offi < offFound - 1
                                                (
                                                ||
                                                posti[ offi ] == '\n'               //COUNTED: NEW LINE
                                            (
                                            if
                                        {
                                        for( countT offi = offFound + thirdC::c_strlenIF( tin0P , info.postFind ) ; offi < costi ; offi ++ )    //TRUNCATE THE CONTAINING LINE
                                        osTextT* poste = posti + costi ;

                                        idCol = offFound - offCurrentLine + 1 ;

                                        }
                                            }
                                                
                                                offCurrentLine = offi + 1 ;
                                                idLine ++ ;
                                            {
                                            )
                                                )
                                                    && posti[ offi + 1 ] != '\n'
                                                    && posti[ offi     ] == '\r'    //COUNTED: CARRIAGE RETURN NOT FOLLOWED BY NEW LINE (FILES PRODUCED BY COMMODORE AND EARLY MACINTOSH SYSTEMS)
                                                       offi < offFound - 1
                                                (
                                                ||
                                                posti[ offi ] == '\n'               //COUNTED: NEW LINE
                                            (
                                            if
                                        {
                                        for( countT offi = 0 ; offi < offFound ; offi ++ )
                                        idLine = 1 ;

                                        countT offFound = postHit - posti ;
                                    {
                                    if( postHit )
                                    const osTextT* const postHit = thirdC::c_strstrIF( tin0P , posti , info.postFind ) ;

                                    }
                                        }
                                            if( old >= 'A' && old <= 'Z' ) posti[ offi ] = (osTextT)( 'a' - 'A' + old ) ;
                                            countT old = posti[ offi ] ;
                                        {
                                        for( countT offi = 0 ; offi < costi ; offi ++ )
                                    {
                                    if( bIgnoreCase )
                                {
                                else
                                }
                                    ((tin1S&)tin0P).pEther->traceF( tin0P , T("file is null length [postNameP]:    ")+T(postNameP)+tCRLF , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                {
                                else if( !posti || !costi )

                                }
                                    ((tin1S&)tin0P).pEther->traceF( tin0P , T("!exception / could read file [postNameP]:    ")+T(postNameP)+tCRLF , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                    POOPRqUIET ;
                                {
                                if( POOP )

                                ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , T(ifFileNameC(tin0P,*((tin1S&)tin0P).pEtScratch,postNameP)) , 1 ) ; ___( posti ) ;
                            {
                            else
                            }
                                ((tin1S&)tin0P).pEther->traceF( tin0P , T("file is too large for me to scan [postNameP]:    ")+T(postNameP)+tCRLF , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                            {
                            if( pInfo->cbUsedHigh || !pInfo->cbUsed | pInfo->cbUsed > TICK )
                            ZE( countT , idCol ) ;
                            ZE( countT , idLine ) ;
                            ZE( countT , offCurrentLine ) ;
                            ZE( countT   , costi ) ;
                            ZE( osTextT* , posti ) ;
                        {
                        else if( pInfo && ( pInfo->cbUsedHigh || pInfo->cbUsed ) )
                        }
                            ((tin1S&)tin0P).pEther->traceF( tin0P , T("!exception / could not obtain file info [postNameP]:    ")+T(postNameP)+tCRLF , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                            POOPRqUIET ;
                        {
                        if( POOP )
                    
                        ((tin1S&)tin0P).pEtScratch->diskFileQueryF( tin0P , pInfo , fi ) ; ___( pInfo ) ;
                        ZE( infoFileS* , pInfo ) ;
                    {
                    else
                    }
                        ((tin1S&)tin0P).pEther->traceF( tin0P , T("!exception / could not open a read handle for file [postNameP]:    ")+T(postNameP)+tCRLF , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    TN( tCRLF , "\r\n" ) ;

                    fileC fi( tin0P , postNameP , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null , flFILEaTTR2_null , flFILEc_null , 1 ) ;

                    //}
                    //    countT foo = 2 ;
                    //{
                    //if( idIn == 0xf )
                    //CONoUTrAW3( "\r\n [idIn]:    " , idIn , "\r\n" ) ;
                    //countT idIn = 1 + incv02AM( idInLath ) ;
                    //static countT idInLath ;

                    SCOOPS
                {
                IFsCRATCHoK
            {
            else
            }
            {
            if( bDir )

            boolT  bDir = postNameP[ costLike - 1 ] == '\\' ;
            countT costLike = ((tin1S&)tin0P).brcRaw ;
            BOSdOnOTtEST( WHATgbo , strlen( postNameP ) )
        {
        if( bDoIt )

        ;
            : 1
            ? (*info.pCbf)( tin0P , cDirsP , cFilesP , bQuitP , postNameP , pcArgP )
        bDoIt = info.pCbf

        boolT bIgnoreCase = F(info.flagsSearch) & flSEARCH_IGNOREcASE ;

        diskWalkSearchInfoS& info = *(diskWalkSearchInfoS*)pcArgP ;
    {
    if( postNameP )
    ZE( boolT , bDoIt ) ;
    _IO_
{
/*1*/boolT diskWalkSearchCBF( tin0S& tin0P , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloFilesP , const countT* const pModuloDirsP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
