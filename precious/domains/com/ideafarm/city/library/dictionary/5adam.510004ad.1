
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//U::NEXT: REPRT THE DetailLevel TO SE WHETHER THE MISSING ITEMS ARE ALL "GURU" LEVEL

REST

etThread.boxPutF( tin0P , T("///d/ideafarm.rpt.fooey") , tr , tr.csF( tin0P ) ) ;

etThread.delF( tin0P , psttr ) ;
textC tr( tin0P , TAG( TAGiDnULL ) , psttr ) ;


}
    etThread.strokeF( tin0P , tSay ) ;
    etThread.strFuseF( tin0P , psttr , tSay ) ;
    TN( tSay , "" ) ; tSay = T("i have ")+TF1(cHave)+T(" of ")+TF1(osIdName)+tcb+T(psttName)+tc ;
    strokeS*& psttName = (strokeS*&)swOsIdName( osIdName ) ;
    
    countT cHave = swTally ;
    osIdName = swTally.leverF( tin0P , idf ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
countT cFlavors = swTally.cFlavorsF( tin0P ) ;

}
    }
        }
            etThread.strFuseF( tin0P , psttr , T("*********************************** found!\r\n") ) ;
        {
        if( def.CounterNameTitleIndex == 952 || def.CounterNameTitleIndex == 676 )
    
        count2S* pc2v = (count2S*)( (byteT*)pBlock + def.CounterOffset ) ;
    
        // WORK AT GETTING HANDLE AND OTHER TYPES
        // STUDY WHY I CANNOT GET HANDLE AND OTHER TYPES (SECURITY?)
        // LIST ALL TYPES THAT I CAN GET
        // THEN PLAY WITH GETTING OTHER TYPES OF COUNTERS
        // DEBUG TILL AM GETTING GOOD VALUES FOR THESE
        // REPORT THE SIZE, THE VALUE, AND THE TITLE FOR ALL OF THESE COUNTERS
        // GET THE TITLES
        //PLAN:
        //U::GET THE TITLE

        ++ swTally ;
        osIdName = def.CounterNameTitleIndex ;

        etThread.strokeF( tin0P , tSay ) ;
        etThread.strFuseF( tin0P , psttr , tSay ) ;
        TN( tSay , "" ) ; tSay = T("<")+TF1((countT)def.DetailLevel)+T(">    ")+TF3((countT)def.CounterNameTitleIndex,flFORMAT_null,9)+T("    ")+tb4+T(psttName)+tc ;
        strokeS*& psttNote = (strokeS*&)swOsIdNote( def.CounterHelpTitleIndex ) ;
        strokeS*& psttName = (strokeS*&)swOsIdName( def.CounterNameTitleIndex ) ;

        PERF_COUNTER_DEFINITION& def = pDefs[ offDef ] ;
    {
    for( countT offDef = 0 ; offDef < pType->NumCounters ; offDef ++ )

    PERF_COUNTER_BLOCK* pBlock = (PERF_COUNTER_BLOCK*)( (byteT*)pType + pType->DefinitionLength ) ;
    PERF_COUNTER_DEFINITION* pDefs = (PERF_COUNTER_DEFINITION*)pbc ; pbc = (byteT*)pType + pType->TotalByteLength ;

    ++ swTally ;
    osIdName = pType->ObjectNameTitleIndex ;

    etThread.strokeF( tin0P , tSay ) ;
    etThread.strFuseF( tin0P , psttr , tSay ) ;
    TN( tSay , "" ) ; tSay = TF3((countT)pType->ObjectNameTitleIndex,flFORMAT_null,9)+T("    ")+( pType->NumInstances ? T("(")+TF1((countT)pType->NumInstances)+T(") ") : T("") )+T(psttName)+tcb+T(psttNote)+tc ;
    strokeS*& psttNote = (strokeS*&)swOsIdNote( pType->ObjectHelpTitleIndex ) ;
    strokeS*& psttName = (strokeS*&)swOsIdName( pType->ObjectNameTitleIndex ) ;

    PERF_OBJECT_TYPE* pType = (PERF_OBJECT_TYPE*)pbc ; pbc += pType->HeaderLength ;
{
while( pbc < pbe )
byteT* pbe = pbBuffer + pHeader->TotalByteLength ;
__( cbBuffer - pHeader->TotalByteLength ) ;
PERF_DATA_BLOCK* pHeader = (PERF_DATA_BLOCK*)pbc ; pbc += pHeader->HeaderLength ;
byteT* pbc = pbBuffer ;
etThread.strMakeF( tin0P , LF , psttr , T("") , 0x100000 ) ; ___( psttr ) ;
ZE( strokeS* , psttr ) ;

//THIS CODE SETS A CURSOR TO THE WO'TH COUNTER VALUE

bFail = rc != ERROR_SUCCESS ;
rc = ((tin1S&)tin0P).brcRaw ;
BOSdOnOTtEST( WHATgbo , RegCloseKey( HKEY_PERFORMANCE_DATA ) )
boolT bFail = rc != ERROR_SUCCESS ;
//countT rc = ((tin1S&)tin0P).brcRaw ;
//BOSdOnOTtEST( WHATgbo , RegQueryValueEx( HKEY_PERFORMANCE_DATA , "260" , 0 , (ULONG*)&idType , (UCHAR*)pbBuffer , (ULONG*)&cbBuffer ) )
//B:countT rc = ((tin1S&)tin0P).brcRaw ;
//B:BOSdOnOTtEST( WHATgbo , RegQueryValueEx( HKEY_PERFORMANCE_DATA , "952" , 0 , (ULONG*)&idType , (UCHAR*)pbBuffer , (ULONG*)&cbBuffer ) )
//countT rc = ((tin1S&)tin0P).brcRaw ;
//BOSdOnOTtEST( WHATgbo , RegQueryValueEx( HKEY_PERFORMANCE_DATA , "Costly" , 0 , (ULONG*)&idType , (UCHAR*)pbBuffer , (ULONG*)&cbBuffer ) )
countT rc = ((tin1S&)tin0P).brcRaw ;
BOSdOnOTtEST( WHATgbo , RegQueryValueEx( HKEY_PERFORMANCE_DATA , "Global" , 0 , (ULONG*)&idType , (UCHAR*)pbBuffer , (ULONG*)&cbBuffer ) )
ZE( countT , idType ) ;

}
    etThread.delF( tin0P , pbNotes ) ;
    }
        }
            pbc += thirdC::c_strlenIF( tin0P , pbc ) + 1 ;
            bIndex = !bIndex ;
            }
                osIdNote = 0 ;
                swOsIdNote = osIdNote ;
                psttNote = tNote ;
                TN( tNote , "" ) ; tNote = T(pbc) ;
                __Z( osIdNote ) ;
            {
            else
            }
                osIdNote = etThread.strDigitsToSCountF( tin0P , tId , 0xa , 1 ) ;
                //etThread.strokeF( tin0P , tId+tc ) ;
                TN( tId , "" ) ; tId = T(pbc) ;
                __( osIdNote ) ;
            {
            if( bIndex )
        {
        while( pbc < pbe )
        ZE( countT , osIdNote ) ;
        boolT bIndex = 1 ;
        byteT* pbe = pbNotes + cbNotes ;
        byteT* pbc = pbNotes ;
    {
    
    etThread.delF( tin0P , pbNames ) ;
    }
        }
            pbc += thirdC::c_strlenIF( tin0P , pbc ) + 1 ;
            bIndex = !bIndex ;
            }
                osIdName = 0 ;
                swTally = 0 ;
                swOsIdName = osIdName ;
                psttName = tName ;
                TN( tName , "" ) ; tName = T(pbc) ;
                __Z( osIdName ) ;
            {
            else
            }
                osIdName = etThread.strDigitsToSCountF( tin0P , tId , 0xa , 1 ) ;
                //etThread.strokeF( tin0P , tId+tc ) ;
                TN( tId , "" ) ; tId = T(pbc) ;
                __( osIdName ) ;
            {
            if( bIndex )
        {
        while( pbc < pbe )
        boolT bIndex = 1 ;
        byteT* pbe = pbNames + cbNames ;
        byteT* pbc = pbNames ;
    {
    
    bFail |= rc != ERROR_SUCCESS ;
    rc = ((tin1S&)tin0P).brcRaw ;
    BOSdOnOTtEST( WHATgbo , RegQueryValueEx( HKEY_PERFORMANCE_DATA , "Explain 009" , 0 , (ULONG*)&idType , (UCHAR*)pbNotes , (ULONG*)&cbNotes ) )
    etThread.newF( tin0P , LF , pbNotes , cbNotes ) ; ___( pbNotes ) ;
    ZE( byteT* , pbNotes ) ;
    
    bFail = rc != ERROR_SUCCESS ;
    rc = ((tin1S&)tin0P).brcRaw ;
    BOSdOnOTtEST( WHATgbo , RegQueryValueEx( HKEY_PERFORMANCE_DATA , "Explain 009" , 0 , (ULONG*)&idType , 0 , (ULONG*)&cbNotes ) )
    ZE( countT , cbNotes ) ;
    idType = 0 ;
    
    bFail |= rc != ERROR_SUCCESS ;
    rc = ((tin1S&)tin0P).brcRaw ;
    BOSdOnOTtEST( WHATgbo , RegQueryValueEx( HKEY_PERFORMANCE_DATA , "Counter 009" , 0 , (ULONG*)&idType , (UCHAR*)pbNames , (ULONG*)&cbNames ) )
    etThread.newF( tin0P , LF , pbNames , cbNames ) ; ___( pbNames ) ;
    ZE( byteT* , pbNames ) ;
    
    boolT bFail = rc != ERROR_SUCCESS ;
    LONG rc = ((tin1S&)tin0P).brcRaw ;
    BOSdOnOTtEST( WHATgbo , RegQueryValueEx( HKEY_PERFORMANCE_DATA , "Counter 009" , 0 , (ULONG*)&idType , 0 , (ULONG*)&cbNames ) )
    ZE( countT , cbNames ) ;
    ZE( countT , idType ) ;
{
switchC swTally( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , osIdName ) ;
ZE( countT , osIdName ) ;
switchC swOsIdNote( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttNote ) ;
ZE( strokeS* , psttNote ) ;
switchC swOsIdName( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttName ) ;
ZE( strokeS* , psttName ) ;
TN( tb4 , "    " ) ;
TN( tcb , ": " ) ;
TN( tc , "\r\n" ) ;

TODO

countT cbBuffer = sizeof pbBuffer ;
byteT pbBuffer[ 0x1000000 ] ;

/*1*/WAKEhIDE( "doodle.os.measurements" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

