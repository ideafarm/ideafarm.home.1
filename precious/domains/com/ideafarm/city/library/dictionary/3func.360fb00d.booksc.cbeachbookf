
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    THREADmODE3rESTORE

    }
        }
            }
                while( stqIdBookCb ) { stqIdBookCb >> (byteT*)pcc ; pcc -= 2 ; }

                pcc += cBooks - 1 << 1 ;
                countT* pcc = pcpIdBookSizePairsP + 1 ;

                *pcpIdBookSizePairsP = cBooks ;
            {
            if( pcpIdBookSizePairsP )
            ((tin1S&)tin0P).pEther->newF( tin0P , LF , pcpIdBookSizePairsP , 1 + ( cBooks << 1 ) ) ; ___( pcpIdBookSizePairsP ) ;
        {
        if( cBooks )
        countT cBooks = stqIdBookCb ;

        while( ~hFind ) ;
        }
            DEL( pInfo ) ;
            }
                DEL( pLook ) ;
                ((tin1S&)tin0P).pEther->delF( tin0P , pcpIdLook ) ;
                }
                    //CONoUTrAW3( T("book: \"")+tName+T("\" [cbUsed]: ") , head.cbUsed , "\r\n" ) ;

                    stqIdBookCb << (byteT*)pc2 ;
                    countT pc2[] = { pcpIdLook[ 1 ] , head.cbUsed } ;

                    const bookHeadS& head = *pLook ;
                {
                if( pLook && pcpIdLook )

                THREADmODE3rESTORE
                THREADmODE1rESTORE ;
                bookC* pLook = new( 0 , tin0P , LF ) bookC( tin0P , TAG( TAGiDnULL ) , tName , idStateSpace , flagsCtBook & ~( F(flBOOKc_WRITER) ) , 0 , bFill , idMemorySpace ) ; ___( pLook ) ;
                THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING ) ;
                THREADmODE3oN( flTHREADmODE3_ALLOWeXPLICITmEMORYsPACE )

                ;
                    : T(postPath)+T(postShort)+T(".booksC.1.book.")+tIdLook
                    ? T(postShort)+T(".booksC.1.book.")+tIdLook
                TN( tName , "" ) ; tName = !*postPath
        
                }
                    for( countT offi = *pcpIdLook ; offi ; offi -- ) tIdLook += tDot+TF3(pcpIdLook[offi],flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ;
                    TN( tDot , "." ) ;
                    tIdLook = TF3(*pcpIdLook,flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE|flFORMAT_NObIGITvALUES,8) ;
                {
                TN( tIdLook , "" ) ;

                ((tin1S&)tin0P).pEther->delF( tin0P , pstt1w ) ;
                }
                    }
                        else                       pco -- ;
                        if( pco == pcpIdLook ) pco = pcpIdLook + cWords - 1 ;
                        *pco = ((tin1S&)tin0P).pEther->strDigitsToSCountF( tin0P , psttc1 , 0 , 1 ) ;
                    {
                    FORsTRINGSiN1( pstt1w )

                    countT* pco = pcpIdLook ;
                {
                if( pcpIdLook )
                PUSE.newF( tin0P , LF , *(byteT**)&pcpIdLook , sizeof( countT ) * cWords ) ; ___( pcpIdLook ) ;
                ZE( countT* , pcpIdLook ) ;

                ((tin1S&)tin0P).pEther->delF( tin0P , psttw ) ;
                countT cWords = ((tin1S&)tin0P).pEther->strWordsOldF( tin0P , pstt1w , psttw , sttq , tDot ) ; ___( pstt1w ) ;
                ZE( strokeS* , pstt1w ) ;

                ((tin1S&)tin0P).pEther->strSubstringF( tin0P , psttw , idf , sttq , tAfter , pInfo->psttIfoName ) ; ___( psttw ) ;
                ((tin1S&)tin0P).pEther->delF( tin0P , psttw ) ;
                ((tin1S&)tin0P).pEther->strSubstringF( tin0P , psttw , idf , sttq , tBefore , pInfo->psttIfoName ) ; ___( psttw ) ;
                countT idf = 1 ;
                ZE( strokeS* , psttw ) ;
            {
            if( pInfo && !( F(pInfo->flags) & flFILEaTTR1_DIRECTORY ) )
            ((tin1S&)tin0P).pEtScratch->diskFindFileOrDirF( tin0P , pInfo , hFind , fnLike.pathF() , &pat ) ; ___( pInfo ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

        patternC pat( tin0P , *((tin1S&)tin0P).pEther , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
        fileNameC fnLike( tin0P , *((tin1S&)tin0P).pEther , psttFindLike ) ;
        TN( tDot , "." ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        TN( tAfter  , ".bookC" ) ;
        TN( tBefore , ".booksC.1.book." ) ;
        staqC stqIdBookCb( tin0P , 2 * sizeof( countT ) , 0x20 ) ;
    {
    if( idStateSpace )

    THREADmODE3oN( flTHREADmODE3_POOLaLLOCATEfROMhEAP )

    _IO_

    }
        if( POOP ) return ;
        __NZ( pcpIdBookSizePairsP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT booksC::cbEachBookF( tin0S& tin0P , countT*& pcpIdBookSizePairsP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

