
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


#undef DELETEpbs

}
    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/0") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
    //etRock.traceF( tinBaseP , TP("",cNestP)+T("put""FileIF/- ")+TF2(cNestP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(jMeP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(jDadP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(jGrandDadP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
    cNestP -- ;
    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/1") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

    }
        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/2") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

        }
            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/3") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
            etherP.delF( tinBaseP , psttOutWhite ) ;
            etherP.delF( tinBaseP , psttOutBlack ) ;
            }
                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/4") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                }
                    //etRock.traceF( tinBaseP , T("    ")+TF2(jMeP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+tFileShortWhite ) ;
                    }
                        etherP.delF( tinBaseP , posto ) ;
                        etherP.fileWriteF( tinBaseP , hFile , posto , costo ) ;

                        etherP.delF( tinBaseP , psttp ) ;
                        countT costo = etherP.strMakeF( tinBaseP , LF , posto , psttp ) ; ___( posto ) ;
                        ZE( osTextT* , posto ) ;

                        sOutWhite >> psttp ; ___( psttp ) ;
                        ZE( strokeS* , psttp ) ;
                    {
                    else while( sOutWhite )
                    }
                        etherP.delF( tinBaseP , posto ) ;
                        etherP.fileWriteF( tinBaseP , hFile , posto , costo ) ;

                        etherP.delF( tinBaseP , psttOutBlack ) ;
                        countT costo = etherP.strMakeF( tinBaseP , LF , posto , psttOutBlack ) ; ___( posto ) ;
                        ZE( osTextT* , posto ) ;
                    {
                    if( !sOutWhite )

                    etherP.fileOpenF( tinBaseP , hFile , countTC() , tFilePath+tFileShortUse , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
                    handleC hFile( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                    _IO_

                    ;
                        : tFileShortWhite
                        ? tFileTiny+T(".white.html")
                    TN( tFileShortUse , "" ) ; tFileShortUse = !etherP.strCompareF( tinBaseP , tFileShortBlack , tFileTiny+T(".html") )

                {
                if( !bQuitP )
                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/5") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                }
                    //etRock.traceF( tinBaseP , T("    ")+TF2(jMeP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+tFileShortBlack ) ;
                    }
                        etherP.delF( tinBaseP , posto ) ;
                        etherP.fileWriteF( tinBaseP , hFile , posto , costo ) ;

                        etherP.delF( tinBaseP , psttp ) ;
                        countT costo = etherP.strMakeF( tinBaseP , LF , posto , psttp ) ; ___( posto ) ;
                        ZE( osTextT* , posto ) ;

                        sOutBlack >> psttp ; ___( psttp ) ;
                        ZE( strokeS* , psttp ) ;
                    {
                    else while( sOutBlack )
                    }
                        etherP.delF( tinBaseP , posto ) ;
                        etherP.fileWriteF( tinBaseP , hFile , posto , costo ) ;

                        etherP.delF( tinBaseP , psttOutBlack ) ;
                        countT costo = etherP.strMakeF( tinBaseP , LF , posto , psttOutBlack ) ; ___( posto ) ;
                        ZE( osTextT* , posto ) ;
                    {
                    if( !sOutBlack )

                    etherP.fileOpenF( tinBaseP , hFile , countTC() , tFilePath+tFileShortBlack , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR ) ;
                    handleC hFile( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                    _IO_
                {
                if( !bQuitP )
                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/6") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
            {
            if( !POOP && ( sOutBlack || psttOutBlack ) )

            }
                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/7") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                //etRock.traceF( tinBaseP , T("pass ended [cNest,idPass]:    ")+TF2(cNestP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(offPass+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                }
                    etherP.strFuseF( tinBaseP , psttOutWhite , pP.tEpilogWhite , &sOutWhite ) ;
                    etherP.strFuseF( tinBaseP , psttOutBlack , pP.tEpilogBlack , &sOutBlack ) ;
                {
                else if(  offPass == 1 )
                     if( !offPass      ) csttNeeded += pP.tEpilogBlack.csF( tinBaseP ) ;            // IF offPass == - 1 THEN I'VE CREATED A KID HTML FILE SO MUST START OVER FROM SCRATCH
                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/8") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                }
                    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/9") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                    //if( !( idBranch % ( TUCK << 4 ) ) ) etRock.traceF( tinBaseP , T("branch ended [cNest,idPass,idBranch,jc]:    ")+TF2(cNestP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(offPass+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(idBranch,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(jcTrace,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    DELETEpbs
                    tRefHtmlIdLag = tRefHtmlId ;
                    bJumpedLag = bJumped ;
                    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/A") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                    }
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/B") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                        }
                            }
                                st_putFileJob_P << (byteT*)&job ;
                                inc02AM( cPendingP ) ;

                                putFileJobS job( idEditionP , cNestP , offLevelKid , jcSaveMe , jcSaveDad , jcSaveGrandDad ) ;
                                //etRock.traceF( tinBaseP , TP("",cNestP)+T("job: ")+TF2(cNestP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(jcSaveMe,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(jcSaveDad,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(jcSaveGrandDad,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

                                // *******************************************************************************************************************************************************
                                // *******************************************************************************************************************************************************
                                // *******************************************************************************************************************************************************
                                // *******************************************************************************************************************************************************
                                // ****                                 ******************************************************************************************************************
                                // ****  ORDER PAGE FOR CURRENT BRANCH  ******************************************************************************************************************
                                // ****                                 ******************************************************************************************************************
                                // *******************************************************************************************************************************************************
                                // *******************************************************************************************************************************************************
                                // *******************************************************************************************************************************************************
                                // *******************************************************************************************************************************************************
                            {
                            //U::T: if( jcSaveNakedGrandDad != jcSaveNakedDad || jcSaveNakedDad == 2 ) //THIS SUPPRESSES REDUNDANT ORDER BY DAD WHEN GRANDDAD HAS ALREADY ORDERED IT
                            countT jcSaveNakedGrandDad = jcSaveGrandDad & ~NM_HIGH ;
                            countT jcSaveNakedDad      = jcSaveDad      & ~NM_HIGH ;
                        {
                        if( offPass && bKid && !bQuitP )
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/C") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                        if( bWoth ) bWoth = 0 ;

                        }
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/D") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            if( bWrapped ) etherP.strFuseF( tinBaseP , psttOutWhite , psttvSuffix , &sOutWhite ) ;
                            if( bWrapped ) etherP.strFuseF( tinBaseP , psttOutBlack , psttvSuffix , &sOutBlack ) ;

                            }
                                                  etherP.strFuseF( tinBaseP , psttOutWhite , tSuffix     , &sOutWhite ) ;
                                                  etherP.strFuseF( tinBaseP , psttOutBlack , tSuffix     , &sOutBlack ) ;

                                                  etherP.strFuseF( tinBaseP , psttOutWhite , tSpanEnd    , &sOutWhite ) ;
                                                  etherP.strFuseF( tinBaseP , psttOutBlack , tSpanEnd    , &sOutBlack ) ;

                                                  etherP.strFuseF( tinBaseP , psttOutWhite , thBranchTerminator  , &sOutWhite ) ;
                                                  etherP.strFuseF( tinBaseP , psttOutBlack , thBranchTerminator  , &sOutBlack ) ;

                                                  etherP.strFuseF( tinBaseP , psttOutWhite , psttvBody   , &sOutWhite ) ;
                                                  etherP.strFuseF( tinBaseP , psttOutBlack , psttvBody   , &sOutBlack ) ;

                                                  etherP.strFuseF( tinBaseP , psttOutWhite , tSpanBegin  , &sOutWhite ) ;
                                                  etherP.strFuseF( tinBaseP , psttOutBlack , tSpanBegin  , &sOutBlack ) ;

                                                  etherP.strFuseF( tinBaseP , psttOutWhite , tPrefix2White , &sOutWhite ) ;
                                                  etherP.strFuseF( tinBaseP , psttOutBlack , tPrefix2Black , &sOutBlack ) ;

                                                  //etRock.traceF( tinBaseP , TP("",cNestP)+T("NOT suppressing:    ")+T(psttvBody) ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            {
                            else
                            if( bSuppressWoth  ) ; //etRock.traceF( tinBaseP , TP("",cNestP)+T("suppressing:    ")+T(psttvBody) ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                            if( bWrapped        ) etherP.strFuseF( tinBaseP , psttOutWhite , psttvPrefix , &sOutWhite ) ;
                            if( bWrapped        ) etherP.strFuseF( tinBaseP , psttOutBlack , psttvPrefix , &sOutBlack ) ;

                                                  etherP.strFuseF( tinBaseP , psttOutWhite , tPrefix1    , &sOutWhite ) ;
                                                  etherP.strFuseF( tinBaseP , psttOutBlack , tPrefix1    , &sOutBlack ) ;
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/E") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("[bSuppressWoth,bWoth,cs]:    ")+TF2(bSuppressWoth,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(bWoth,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(pP.tHtml50TableBegin.csF(tinBaseP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            boolT bSuppressWoth = bWoth && !pP.tHtml50TableBegin.csF( tinBaseP ) ;       //U:: KLUDGE: TEST FOR MODE DIRECTLY HERE, NOT OPAQUELY BY TESTING LENGTH OF A PARTICULAR STRING
                        {                                                                            //U:: bSuppressWoth IS USED TO SUPPRESS THE TITLE HEADER FOR MODE ROOT.  BEST PRACTICE FOR MODE ROOT IS A SINGLE PAGE WITH NO CLICKABLE NAVIGATION (BECAUSE THERE IS NO HEADER INCLUDING NO DOWN NAVIGATION)
                        else
                        }
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/F") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            if( bWrapped ) csttNeeded += psttvPrefix->idAdam + psttvSuffix->idAdam ;
                                           csttNeeded += tPrefix1.csF( tinBaseP ) + tPrefix2White.csF( tinBaseP ) + tSpanBegin.csF( tinBaseP ) + psttvBody->idAdam + thBranchTerminator.csF( tinBaseP ) + tSpanEnd.csF( tinBaseP ) + tSuffix.csF( tinBaseP ) ;
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/G") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                        {
                        if( !offPass )

                        if( !bWrapped && bMaxGrand && bInvertBehaviorPrefixSuffix ) bWrapped = 1 ; //20230613@1318: INTENDED TO CAUSE INCLUSION OF HTML FOR DETAIL SENTENCES AND TO NOT HAVE ANY EFFECT FOR SUMMARY SENTENCES OR FOR PAGE TITLE
                        boolT bWrapped = bMaxAlmost || ( bMaxReduced && bMaxGrand ) ; //U::ENHANCE TO ENABLE SOIL INPUT TO CONTAIN OVERRIDES WHICH INVERT THE DEFAULT BEHAVIOR FOR EACH LEVEL WITHIN A PAGE; SYNTAX: \1\2\3

                        if( tPrefix2Black.csF( tinBaseP ) > tPrefix2White.csF( tinBaseP ) ) { BLAMMO ; }

                        }
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/H") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            etherP.delF( tinBaseP , psttUrlBodyTrunc ) ;
                            etherP.delF( tinBaseP , psttUrlFileShort ) ;
                            }
                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_003 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_003 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , thBranchTerminator  , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , thBranchTerminator  , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , tHtml20Title   , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , tHtml20Title   , &sOutBlack ) ;

                                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/I") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_002 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_002 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_f1 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_f1 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_e1 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_e1 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_d1 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_d1 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_c1 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_c1 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_b1 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_b1 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_a1 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_a1 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_91 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_91 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_81 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_81 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_71 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_71 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_61 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_61 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_51 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_51 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_41 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_41 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_31 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_31 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_21 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_21 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_11 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_11 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_01 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_01 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_f0White , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_f0Black , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_e0 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_e0 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_d0White , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_d0Black , &sOutBlack ) ;

                                }
                                    if( psttBanner2P ) etherP.strFuseF( tinBaseP , psttOutWhite , psttBanner2P , &sOutWhite ) ;
                                    if( psttBanner2P ) etherP.strFuseF( tinBaseP , psttOutBlack , psttBanner2P , &sOutBlack ) ;
                                {
                                if( pP.tBodyProlog_c0.csF( tinBaseP ) )

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_c0 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_c0 , &sOutBlack ) ;

                                //U::20230618@1043: }
                                //U::20230618@1043:     etherP.strFuseF( tinBaseP , psttOutWhite , tSoilLink , &sOutWhite ) ;
                                //U::20230618@1043:     etherP.strFuseF( tinBaseP , psttOutBlack , tSoilLink , &sOutBlack ) ;
                                //U::20230618@1043: {
                                //U::20230618@1043: if( pP.tBodyProlog_b0.csF( tinBaseP ) )

                                //U::20230618@1043: etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_b0 , &sOutWhite ) ;
                                //U::20230618@1043: etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_b0 , &sOutBlack ) ;

                                }
                                    }
                                        }
                                            etherP.strFuseF( tinBaseP , psttOutWhite , pP.tPrologf , &sOutWhite ) ;
                                            etherP.strFuseF( tinBaseP , psttOutBlack , pP.tPrologf , &sOutBlack ) ;

                                            etherP.strFuseF( tinBaseP , psttOutWhite , tDown1White , &sOutWhite ) ;
                                            etherP.strFuseF( tinBaseP , psttOutBlack , tDown1Black , &sOutBlack ) ;

                                            etherP.strFuseF( tinBaseP , psttOutWhite , pP.tProloge , &sOutWhite ) ;
                                            etherP.strFuseF( tinBaseP , psttOutBlack , pP.tProloge , &sOutBlack ) ;

                                            //etRock.traceF( tinBaseP , T("down1: included") ) ;
                                        {
                                        else
                                        if( bSuppressDown1 ) ;//etRock.traceF( tinBaseP , T("down1: SUPPRESSED") ) ;

                                        }
                                            }
                                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tPrologd , &sOutWhite ) ;
                                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tPrologd , &sOutBlack ) ;

                                                etherP.strFuseF( tinBaseP , psttOutWhite , tDown2White , &sOutWhite ) ;
                                                etherP.strFuseF( tinBaseP , psttOutBlack , tDown2Black , &sOutBlack ) ;

                                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tPrologc , &sOutWhite ) ;
                                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tPrologc , &sOutBlack ) ;

                                                //etRock.traceF( tinBaseP , T("down2: included") ) ;
                                            {
                                            else
                                            if( bSuppressDown2 ) ; //etRock.traceF( tinBaseP , T("down2: SUPPRESSED") ) ;


                                            if( bRoot ) etherP.strFuseF( tinBaseP , psttOutWhite , tPrologWas_aWhite , &sOutWhite ) ;
                                            if( bRoot ) etherP.strFuseF( tinBaseP , psttOutBlack , tPrologWas_aBlack , &sOutBlack ) ;
                                        {
                                        if( bDown2 )
                                    {
                                    if( bDown1 )
                                {
                                //if( pP.tBodyProlog_a0.csF( tinBaseP ) )       //20221107@1226: DISABLED THIS TEST W/O ANALYSIS ; I SUSPECT THAT THE IDEA WAS TO KEEP THE ROOT AND ABOUT PAGES VERY SIMPLE

//U::                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_a0 , &sOutWhite ) ;
//U::                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_a0 , &sOutBlack ) ;
//U::
//U::                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_90 , &sOutWhite ) ;
//U::                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_90 , &sOutBlack ) ;
//U::
//U::                                }
//U::                                    if( psttBanner1P ) etherP.strFuseF( tinBaseP , psttOutWhite , psttBanner1P , &sOutWhite ) ;
//U::                                    if( psttBanner1P ) etherP.strFuseF( tinBaseP , psttOutBlack , psttBanner1P , &sOutBlack ) ;
//U::                                {
//U::                                if( pP.tBodyProlog_80Black.csF( tinBaseP ) )
//U::
//U::                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_80White , &sOutWhite ) ;
//U::                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_80Black , &sOutBlack ) ;
//U::
//U::                                }
//U::                                    etherP.strFuseF( tinBaseP , psttOutWhite , tFileShortWhite , &sOutWhite ) ;
//U::                                    etherP.strFuseF( tinBaseP , psttOutBlack , tFileShortBlack , &sOutBlack ) ;
//U::                                {
//U::                                if( pP.tBodyProlog_70Black.csF( tinBaseP ) && pP.idMode != ifcIDmODEpUTfILE_ROOT && pP.idMode != ifcIDmODEpUTfILE_ABOUT )
//U::
//U::                                }
//U::                                    etherP.strFuseF( tinBaseP , psttOutWhite , T(psttNameSpaceP)+pP.thSlash , &sOutWhite ) ;
//U::                                    etherP.strFuseF( tinBaseP , psttOutBlack , T(psttNameSpaceP)+pP.thSlash , &sOutBlack ) ;
//U::                                {
//U::                                if( psttNameSpaceP && pP.tBodyProlog_70Black.csF( tinBaseP ) && pP.idMode != ifcIDmODEpUTfILE_ROOT && pP.idMode != ifcIDmODEpUTfILE_ABOUT )

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_70White , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_70Black , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_60 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_60 , &sOutBlack ) ;

                                }
                                    etherP.strFuseF( tinBaseP , psttOutWhite , tFileShortBlack , &sOutWhite ) ; //INTENTIONALLY THE OTHER COLOR
                                    etherP.strFuseF( tinBaseP , psttOutBlack , tFileShortWhite , &sOutBlack ) ; //INTENTIONALLY THE OTHER COLOR
                                {
                                if( pP.tBodyProlog_50.csF( tinBaseP ) )

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_50 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_50 , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_40White , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_40Black , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_30 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_30 , &sOutBlack ) ;

                                }
                                    etherP.strFuseF( tinBaseP , psttOutWhite , psttUrlBodyTrunc      , &sOutWhite ) ;
                                    etherP.strFuseF( tinBaseP , psttOutBlack , psttUrlBodyTrunc      , &sOutBlack ) ;
                                {
                                if( pP.tBodyProlog_20.csF( tinBaseP ) )

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tBodyProlog_20 , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tBodyProlog_20 , &sOutBlack ) ;

                                }
                                    etherP.strFuseF( tinBaseP , psttOutWhite , psttUrlFileShort      , &sOutWhite ) ;
                                    etherP.strFuseF( tinBaseP , psttOutBlack , psttUrlFileShort      , &sOutBlack ) ;
                                {
                                if( pP.tHtml50TableBegin.csF( tinBaseP ) )

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tHtml50TableBegin , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tHtml50TableBegin , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tHtml40BodyBeginWhite , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tHtml40BodyBeginBlack , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , pP.tHtml30TitleEnd    , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , pP.tHtml30TitleEnd    , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , thBranchTerminator  , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , thBranchTerminator  , &sOutBlack ) ;

                                etherP.strFuseF( tinBaseP , psttOutWhite , tHtml20Title   , &sOutWhite ) ;
                                etherP.strFuseF( tinBaseP , psttOutBlack , tHtml20Title   , &sOutBlack ) ;
                                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/J") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            {
                            else
                            }
                                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/K") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                                if( psttBanner2P ) csttNeeded += psttBanner2P->idAdam ;

                                //if( psttTimeStampP ) csttNeeded += psttTimeStampP->idAdam ;

                                }
                                    csttNeeded += pP.tProloge.csF( tinBaseP ) + tDown1White.csF( tinBaseP ) + pP.tPrologf.csF( tinBaseP ) ;
                                    }
                                        csttNeeded += pP.tPrologc.csF( tinBaseP ) + ( tDown2Black.csF( tinBaseP ) >= tDown2White.csF( tinBaseP ) ? tDown2Black.csF( tinBaseP ) : tDown2White.csF( tinBaseP ) ) + pP.tPrologd.csF( tinBaseP ) ;
                                        if( bRoot ) csttNeeded += tPrologWas_aWhite.csF( tinBaseP ) ;
                                    {
                                    if( bDown2 )
                                {
                                if( bDown1 )

                                }
                                    csttNeeded += pP.tProloge.csF( tinBaseP ) + tDown1White.csF( tinBaseP ) + pP.tPrologf.csF( tinBaseP ) ;
                                    }
                                        csttNeeded += pP.tPrologc.csF( tinBaseP ) + ( tDown2Black.csF( tinBaseP ) >= tDown2White.csF( tinBaseP ) ? tDown2Black.csF( tinBaseP ) : tDown2White.csF( tinBaseP ) ) + pP.tPrologd.csF( tinBaseP ) ;
                                        if( bRoot ) csttNeeded += tPrologWas_aWhite.csF( tinBaseP ) ;
                                    {
                                    if( bDown2 )
                                {
                                if( bDown1 )

                                ;
                                    //+ tMap.csF( tinBaseP )
                                    + ( !psttBanner1P ? 0 : psttBanner1P->idAdam )
                                    + ( tFileShortBlack.csF( tinBaseP ) >= tFileShortWhite.csF( tinBaseP ) ? tFileShortBlack.csF( tinBaseP ) : tFileShortWhite.csF( tinBaseP ) )
                                    + psttUrlBodyTrunc->idAdam
                                    + psttUrlFileShort->idAdam

                                    + pP.tBodyProlog_003.csF( tinBaseP )
                                    + pP.tBodyProlog_002.csF( tinBaseP )
                                    + pP.tBodyProlog_f1.csF( tinBaseP )
                                    + pP.tBodyProlog_e1.csF( tinBaseP )
                                    + pP.tBodyProlog_d1.csF( tinBaseP )
                                    + pP.tBodyProlog_c1.csF( tinBaseP )
                                    + pP.tBodyProlog_b1.csF( tinBaseP )
                                    + pP.tBodyProlog_a1.csF( tinBaseP )
                                    + pP.tBodyProlog_91.csF( tinBaseP )
                                    + pP.tBodyProlog_81.csF( tinBaseP )
                                    + pP.tBodyProlog_71.csF( tinBaseP )
                                    + pP.tBodyProlog_61.csF( tinBaseP )
                                    + pP.tBodyProlog_51.csF( tinBaseP )
                                    + pP.tBodyProlog_41.csF( tinBaseP )
                                    + pP.tBodyProlog_31.csF( tinBaseP )
                                    + pP.tBodyProlog_21.csF( tinBaseP )
                                    + pP.tBodyProlog_11.csF( tinBaseP )
                                    + pP.tBodyProlog_01.csF( tinBaseP )
                                    + ( pP.tBodyProlog_f0Black.csF( tinBaseP ) >= pP.tBodyProlog_f0White.csF( tinBaseP ) ? pP.tBodyProlog_f0Black.csF( tinBaseP ) : pP.tBodyProlog_f0White.csF( tinBaseP ) )
                                    + pP.tBodyProlog_e0.csF( tinBaseP )
                                    + ( pP.tBodyProlog_d0Black.csF( tinBaseP ) >= pP.tBodyProlog_d0White.csF( tinBaseP ) ? pP.tBodyProlog_d0Black.csF( tinBaseP ) : pP.tBodyProlog_d0White.csF( tinBaseP ) )
                                    + ( !psttBanner2P ? 0 : psttBanner2P->idAdam )
                                    + pP.tBodyProlog_c0.csF( tinBaseP )
                                    + tSoilLink.csF( tinBaseP )
                                    + pP.tBodyProlog_b0.csF( tinBaseP )
                                    + pP.tBodyProlog_a0.csF( tinBaseP )
                                    + pP.tBodyProlog_90.csF( tinBaseP )
                                    + ( !psttBanner1P ? 0 : psttBanner1P->idAdam )
                                    + ( pP.tBodyProlog_80Black.csF( tinBaseP ) >= pP.tBodyProlog_80White.csF( tinBaseP ) ? pP.tBodyProlog_80Black.csF( tinBaseP ) : pP.tBodyProlog_80White.csF( tinBaseP ) )
                                    + ( tFileShortBlack.csF( tinBaseP ) >= tFileShortWhite.csF( tinBaseP ) ? tFileShortBlack.csF( tinBaseP ) : tFileShortWhite.csF( tinBaseP ) )
                                    + ( !psttNameSpaceP ? 0 : 1 + psttNameSpaceP->idAdam )
                                    + ( pP.tBodyProlog_70Black.csF( tinBaseP ) >= pP.tBodyProlog_70White.csF( tinBaseP ) ? pP.tBodyProlog_70Black.csF( tinBaseP ) : pP.tBodyProlog_70White.csF( tinBaseP ) )
                                    + pP.tBodyProlog_60.csF( tinBaseP )
                                    + ( tFileShortBlack.csF( tinBaseP ) >= tFileShortWhite.csF( tinBaseP ) ? tFileShortBlack.csF( tinBaseP ) : tFileShortWhite.csF( tinBaseP ) )
                                    + pP.tBodyProlog_50.csF( tinBaseP )
                                    + ( pP.tBodyProlog_40Black.csF( tinBaseP ) >= pP.tBodyProlog_40White.csF( tinBaseP ) ? pP.tBodyProlog_40Black.csF( tinBaseP ) : pP.tBodyProlog_40White.csF( tinBaseP ) )
                                    + pP.tBodyProlog_30.csF( tinBaseP )
                                    + psttUrlBodyTrunc->idAdam
                                    + pP.tBodyProlog_20.csF( tinBaseP )
                                    + psttUrlFileShort->idAdam
                                    + pP.tHtml50TableBegin.csF( tinBaseP )

                                    + ( pP.tHtml40BodyBeginBlack.csF( tinBaseP ) >= pP.tHtml40BodyBeginWhite.csF( tinBaseP ) ? pP.tHtml40BodyBeginBlack.csF( tinBaseP ) : pP.tHtml40BodyBeginWhite.csF( tinBaseP ) )
                                    + pP.tHtml30TitleEnd.csF( tinBaseP )
                                    + thBranchTerminator.csF( tinBaseP )
                                      tHtml20Title.csF( tinBaseP )
                                csttNeeded +=
                                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/L") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            {
                            if( !offPass )
                            TN( tMap , "[treemap goes here]" ) ;
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/M") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                            ;

                                +T("soil/index.1.html\" onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'Click to view the source file for this IdeaFarm (tm) Knowledge Tree' , 0 )\">soil</a>\r\n") ;
                                +trpToRoot
                                T("                                        <a href=\"")

                            TN( tSoilLink , "" ) ; tSoilLink =

                            TN( tHtml20Title , psttvBody->idAdam && etherP.strIdF( tinBaseP , pP.sMark101 , psttvBody , 1 ) ? (strokeS*)pP.thPageTitleImage : psttvBody ) ;

                            }
                                default : { bRoot = 1 ; bDown2 = 1 ; bDown1 = 1 ; break ; }
                                case 2  : {             bDown2 = 1 ; bDown1 = 1 ; break ; }
                                case 1  : {                          bDown1 = 1 ; break ; }
                                case 0  : {                                       break ; }
                            {
                            switch( offLevelKid )
                            ZE( boolT , bDown2 ) ;
                            ZE( boolT , bDown1 ) ;
                            ZE( boolT , bRoot  ) ;

                            if( bDelBodyTrunc ) etherP.delF( tinBaseP , psttvBodyTrunc ) ;
                            etherP.strToUrlF( tinBaseP , psttUrlBodyTrunc , T(psttvBodyTrunc)+( tElMaybe.csF( tinBaseP ) ? tElMaybe : pP.thDot ) ) ; ___( psttUrlBodyTrunc ) ;
                            ZE( strokeS* , psttUrlBodyTrunc )  ;

                            }
                                else psttvBodyTrunc = psttvBody ;
                                }
                                    tElMaybe = T("...") ;
                                    bDelBodyTrunc = 1 ;
                                    etherP.strSubstringF( tinBaseP , psttvBodyTrunc , idf , idl , psttvBody ) ; ___( psttvBodyTrunc ) ;
                                {
                                if( psttvBody->idAdam > idl )
                                countT idl = 0x20 ;
                                countT idf = 1 ;
                            {
                            ZE( boolT    , bDelBodyTrunc ) ;
                            ZE( strokeS* , psttvBodyTrunc ) ;
                            TN( tElMaybe , "" ) ;

                            //TRACES THE HTML FILE NAME: etRock.traceF( tinBaseP , T("U:: [tFileShortBlack]: ")+tFileShortBlack ) ;

                            etherP.strToUrlF( tinBaseP , psttUrlFileShort , tFileShortBlack ) ; ___( psttUrlFileShort ) ;
                            ZE( strokeS* , psttUrlFileShort )  ;
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/N") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                        {
                        if( bWoth )
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("put""FileIF/ [offLevelKid,offLevelP,offLevel,thBranchTerminator,tBody]:    ")+TF2(offLevelKid,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(offLevelP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(offLevel,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    \"")+thBranchTerminator+T("\"")+T("    ")+T(psttvBody) ) ;
                        countT offLevelKid = offLevelP + offLevel ; //U:: SHOULD BE const
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/O") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                        }
                            }
                                }
                                    etherP.strConvertToUpperCaseF( tinBaseP , psttvBody[ offw ] , psttvBody[ offw ] ) ; //CAPITALIZE WOTH STROKE IN THE BODY
                                    countT offw = CSpREFIX - 1 + idSmudge ;
                                {
                                if( idSmudge <= psttvBody->idAdam )

                                while( idSmudge <= psttvBody->idAdam && psttvBody[ CSpREFIX - 1 + idSmudge ].idCaste == sc_MARK ) idSmudge ++ ;

                                countT idSmudge = 1 + etherP.strIdF( tinBaseP , pP.sMark01 , psttvBody , 1 ) ;
                            {

                            }
                                }
                                    default  : { thBranchTerminator = pP.thDot ; break ; }
                                    case '?' : { thBranchTerminator = pP.tn    ; break ; }
                                    case '!' :
                                    case ':' :
                                    case '>' :
                                {
                                else          switch( psttvBody[ CSpREFIX - 1 + idLath ] )
                                if( !idLath ) thBranchTerminator = pP.thDot ;

                                while( idLath && psttvBody[ CSpREFIX - 1 + idLath ].idCaste == sc_MARK ) idLath -- ;
                                countT idLath = psttvBody->idAdam ;
                            {
                        {
                        else
                        if( !psttvBody->idAdam || etherP.strIdF( tinBaseP , pP.sMarkc1 , psttvBody ) || etherP.strIdF( tinBaseP , pP.sMark02 , psttvBody ) ) thBranchTerminator = pP.tn ; // IF RAW BRANCH ("\r")

                        }
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/P") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            }
                                tSpanEnd = pP.tSpanEndOpenClose ;

                                }
                                    case 2 : { tSpanBegin = pP.tSpanBeginOpen+pP.tSpanBeginFlyClimbUp2+pP.tSpanBeginClose ; break ; }
                                    case 1 : { tSpanBegin = pP.tSpanBeginOpen+pP.tSpanBeginFlyClimbUp1+pP.tSpanBeginClose ; break ; }
                                {
                                switch( offLevel )
                            {
                            if( offLevel && !tSpanBegin.csF( tinBaseP ) )

                            tSuffix = bMaxAlmost ? (bNoBody?pP.tn:pP.titOff)+pP.tLinkEnd : pP.tLinkEnd ;

                            }
                                }
                                    }
                                        tPrefix2White = pP.tLinkBegin+tRelativePath+tFileShortWhite+tGo+pP.tLinkMiddle+(bNoBody?pP.tn:pP.titOn) ;
                                        tPrefix2Black = pP.tLinkBegin+tRelativePath+tFileShortBlack+tGo+pP.tLinkMiddle+(bNoBody?pP.tn:pP.titOn) ;
                                        tPrefix1 = pP.tNewPara ;
                                    {
                                    else
                                    }
                                        tPrefix2White = pP.tLinkBegin+tRelativePath+tFileShortWhite+tGo+pP.tLinkMiddle+(bNoBody?pP.tn:pP.titOn) ;
                                        tPrefix2Black = pP.tLinkBegin+tRelativePath+tFileShortBlack+tGo+pP.tLinkMiddle+(bNoBody?pP.tn:pP.titOn) ;
                                        tPrefix1 = pP.tNewDetail ;
                                    {
                                    else if( bNoNewPara )
                                    }
                                        tPrefix2White = pP.tLinkBegin+tRelativePath+tFileShortWhite+tGo+pP.tLinkMiddle ;
                                        tPrefix2Black = pP.tLinkBegin+tRelativePath+tFileShortBlack+tGo+pP.tLinkMiddle ;
                                        tPrefix1 = pP.tNewDetail ;
                                    {
                                    if( bMaxGrand )

                                    ;
                                            : trpToRoot+T("pages/")
                                            ? trpToRoot+pP.thpArchiveSlash
                                        : ((strokeS*)tFileShortBlack)[ CSpREFIX ].idAdam == '!'
                                        ? trpToRoot
                                    tRelativePath = !etherP.strCompareF( tinBaseP , tFileShortBlack , tFileTiny+T(".html") )
                                    TN( tRelativePath , "" ) ;
                                    //CS:CODEsYNCH: PSEUDODUPLICATE: 36128008 36128008
                                {
                                else
                                if( POOP ) break ;

                                __Z( B(bcSaveMe).hashId ) ;
                                __Z( B(bcSaveMe).hashv ) ;
                                //CONoUTrAW( "    NOT FOUND IN SWITCH\r\n" ) ;
                            {
                            else
                            }
                                bKid = 0 ;

                                }
                                    tPrefix2White = pP.tLinkBegin+tRelativePath+tFileShortWhite+tGo+pP.tLinkMiddle+(bNoBody?pP.tn:pP.titOn) ;
                                    tPrefix2Black = pP.tLinkBegin+tRelativePath+tFileShortBlack+tGo+pP.tLinkMiddle+(bNoBody?pP.tn:pP.titOn) ;
                                    tPrefix1 = pP.tNewPara ;
                                {
                                else
                                }
                                    tPrefix2White = pP.tLinkBegin+tRelativePath+tFileShortWhite+tGo+pP.tLinkMiddle+(bMaxAlmost?(bNoBody?pP.tn:pP.titOn):pP.tn) ;
                                    tPrefix2Black = pP.tLinkBegin+tRelativePath+tFileShortBlack+tGo+pP.tLinkMiddle+(bMaxAlmost?(bNoBody?pP.tn:pP.titOn):pP.tn) ;
                                    tPrefix1 = pP.tNewDetail ;
                                {
                                if( bMaxGrand || bNoNewPara )

                                ;
                                        : trpToRoot+T("pages/")
                                        ? trpToRoot+pP.thpArchiveSlash
                                    : ((strokeS*)tFileShortBlack)[ CSpREFIX ].idAdam == '!'
                                    ? trpToRoot
                                tRelativePath = !etherP.strCompareF( tinBaseP , tFileShortBlack , tFileTiny+T(".html") )
                                TN( tRelativePath , "" ) ;
                                //CS:CODEsYNCH: PSEUDODUPLICATE: 36128008 36128008

                                //CONoUTrAW( "        FOUND IN SWITCH\r\n" ) ;
                            {
                            if( bFound )

                            swFileP.ungrabF( tinBaseP ) ;
                            boolT bFound = !!swFileP.idSlotOfLeverF( tinBaseP , jcSaveMe ) ;
                            swFileP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                            if( tRefHtmlIdLag.csF( tinBaseP ) ) tGo = T("#")+tRefHtmlIdLag ;
                            TN( tGo , "" ) ;

                            tFileF( tinBaseP , etherP , tFilePath , tFileShortBlack , tFileShortWhite , tFileTiny , jcSaveMe , pP , cNestP , idEditionP ) ;
                            TN( tFileShortWhite , "" ) ;
                            TN( tFileShortBlack , "" ) ;
                            TN( tFileTiny  , "" ) ;
                            TN( tFilePath  , "" ) ;

                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/Q") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                        {
                        else
                        }
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/R") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            }
                                default: { BLAMMO ; }
                                case 2 : { tPrefix2White = tPrefix2Black = bIt ? pP.tNewDetail+(bNoBody?pP.tn:pP.titOn) : pP.tNewDetail ; if( bIt ) tSuffix = (bNoBody?pP.tn:pP.titOff) ; break ; }
                                case 1 : { tPrefix2White = tPrefix2Black =       pP.tNewPara  +(bNoBody?pP.tn:pP.titOn)                 ;           tSuffix = (bNoBody?pP.tn:pP.titOff) ; break ; }
                                case 0 : { tPrefix2White = tPrefix2Black =       pP.tTitleBegin                                         ;           tSuffix = pP.tTitleEnd              ; break ; }
                            {
                            switch( offUse )

                            boolT bIt = offUse == 2 && bMaxAlmost && !oBias ;

                            ;
                                : offLevel + oBias
                                ? 2
                            countT offUse = bNoBody || bNoNewPara
                            //CONoUTrAW( "\r\n" ) ;
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/S") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                        {
                        if( !bKid )
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/T") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                        branchS& bDebug = B(bcSaveMe) ; //U:: TO FIND A BUG
                        BSP( bcSaveMe , jcSaveMe ) ;

                        }
                            tSpanEnd   = pP.tSpanEndOpenClose ;
                            tSpanBegin = pP.tSpanBeginOpen+pP.tSpanBeginColorReferenceBlack+pP.tSpanBeginFlyJump+pP.tSpanBeginClose ;
                        {
                        if( bJumpedLag )
                        TN( tSuffix , "" ) ;
                        TN( tPrefix2White , "" ) ;
                        TN( tPrefix2Black , "" ) ;
                        TN( tPrefix1 , "" ) ;
                        TN( tSpanEnd , "" ) ;
                        TN( tSpanBegin , "" ) ;

                        //CONoUTrAW( T("[idIn,cNestP,offPass,pBranch,psttvBody]: ")+TF2(idIn,flFORMAT_NObIGITvALUES)+T(" ")+TF2(cNestP,flFORMAT_NObIGITvALUES)+T(" ")+TF2(offPass,flFORMAT_NObIGITvALUES)+T(" ")+TF2(jcSaveMe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" \"")+T(psttvBody)+T("\"\r\n") ) ;

                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("[bKid,oBiasDefault,bUp,bMaxGrand,bMaxAlmost]:    ")+TF2(bKid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(oBiasDefault,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(bUp,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(bMaxGrand,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(bMaxAlmost,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG
                        ;
                                : bUp &&   bMaxGrand
                                ? bUp && ( bMaxGrand || bMaxAlmost )
                            : !oBiasDefault
                            ? 0
                        boolT bKid = bNoKid || bNoBody || !cDepth
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("[bNoKid,bNoBody,cDepth]:    ")+TF2(bNoKid,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(bNoBody,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(cDepth,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; //U:: TO FIND A BUG
                        __( cDepth == - 1 ) ;
                        countT cDepth = cDepthIF( tinBaseP , etherP , jcSaveMe , 1 , idEditionP ) ;

                        }
                            etherP.delF( tinBaseP , postvBody ) ;
                            if( !*postvBody ) bNoBody = 1 ;
                            etherP.strMakeF( tinBaseP , LF , postvBody , psttvBody ) ; ___( postvBody ) ;
                            ZE( osTextT* , postvBody ) ;
                        {
                        else
                        if( !psttvBody->idAdam ) bNoBody = 1 ;
                        ZE( boolT , bNoBody ) ;
                        }
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("suppressing kid [pstetvBody]:  ")+T(psttvBody) ) ;
                        {
                        if( bNoKid )
                        boolT bNoKid      = psttvBody->idAdam               && !!etherP.strIdF( tinBaseP , pP.sMarke1 , psttvBody ) ;

                        boolT bNoNewPara  = psttvBody->idAdam && bMaxAlmost && !!etherP.strIdF( tinBaseP , pP.sMarkd1 , psttvBody ) ;

                        // *******************************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        // ****               ************************************************************************************************************************************
                        // ****  APPEND TEXT  ************************************************************************************************************************************
                        // ****               ************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/U") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                        _IO_    // WHERE RANK #1: 34% OF TOTAL putFileIF TIME IS SPENT IN HERE
                    {
                    if( bShow )

                    if( jc && jc != stCursor[ 1 ] ) { BLAMMO ; }
                    }
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/V") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                        }
                            }
                                }
                                    break ;
                                    jc = 0 ;
                                    //etRock.traceF( tinBaseP , T("...END") ) ;
                                {
                                if( jc == jMeP ) //20131207@1756: ADDED WITHOUT ANALYSIS

                                }
                                    break ;
                                    }
                                        else        break ;
                                        if( !POOP ) stCursor[ 1 ] = jc ;
                                        bJumped = !!jumpIfIF( tinBaseP , jc , stJump , tRefHtmlId ) ;
                                    {
                                    if( jc )
                                    jc = jbrRightNew ;
                                    //etRock.traceF( tinBaseP , T("...RIGHT") ) ;
                                    //CONoUTrAW( "RIGHT\r\n" ) ;
                                {
                                if( jbrRightNew && jc != jMeP )

                                }
                                    //CONoUTrAW3( "Unsuppressing " , cd , "\r\n" ) ;
                                    stNix >> cd ;
                                    ZE( countT , cd ) ;
                                {
                                if( stNix && stNix[ 1 ] == jc ) // I DON'T KNOW WHETHER BOTH OF THESE ARE NEEDED

                                }
                                    break ;
                                    stCursor[ 1 ] = jc ;
                                {
                                else if( idTypeNew != ifcIDtYPEbRANCHs_branchSptr && unJumpIfIF( tinBaseP , jc , stJump ) )
                                if( !jc ) break ;

                                }
                                    jbrRightNew = B(bc).jbrRight ;
                                    idTypeNew   = B(bc).idType   ;
                                    BSP( bc , jc ) ;                    //U:: 20190802@0915: BUG: ACCESS VIOLATION IFF THERE IS EXACTLY 1 BRANCH (JUST THE ROOT BRANCH)
                                {
                                ZE( countT , jbrRightNew ) ;
                                ZE( countT , jbrUpNew    ) ;
                                ZE( countT , valueNew    ) ;
                                ZE( countT , idTypeNew   ) ;

                                }
                                    ;
                                        : 0
                                        ? stCursor[ 1 ]
                                    jc = stCursor
                                    { ZE( countT , cnu ) ; stCursor >> cnu ; }
                                    //etRock.traceF( tinBaseP , T("...DOWN") ) ;
                                    //CONoUTrAW( "DOWN\r\n" ) ;

                                    }
                                        //CONoUTrAW3( "Unsuppressing " , cd , "\r\n" ) ;
                                        stNix >> cd ;
                                        ZE( countT , cd ) ;
                                    {
                                    if( stNix && stNix[ 1 ] == jc ) // I DON'T KNOW WHETHER BOTH OF THESE ARE NEEDED

                                    BSP( bcdOld , jc ) ;
                                {
                            {
                            while( jc )
                            ZE( boolT , bDone ) ;

                            //etRock.traceF( tinBaseP , T("DOWN THEN RIGHT...") ) ;
                            // GO DOWN UNTIL I CAN GO RIGHT ; THEN GO RIGHT
                        {
                        else
                        }
                            stCursor[ 1 ] = jc ; // IF UNJUMP THEN THE NEXT ITERATION WILL PROCESS THE REFERENCE BRANCH'S KIDS AND YOUNGER SIBLINGS
                        {
                        if( idTypeCursor != ifcIDtYPEbRANCHs_branchSptr && unJumpIfIF( tinBaseP , jc , stJump ) )
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/W") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                        _IO_
                    {
                    else
                    }
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/X") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                        }
                            break ;
                            etRock.traceF( tinBaseP , T("error: jumped (right) off of a cliff (possibly a missing label in the kt") ) ;
                            DELETEpbs
                        {
                        else
                        if( jc ) stCursor[ 1 ] = jc ;

                        //__Z( jc ) ;                                                               //20180420@1058:  !jc CAN HAPPEN WHEN PROCESSING A KT WITH INTENTIONALLY MISSING LABEL
                        bJumped = !!jumpIfIF( tinBaseP , jc , stJump , tRefHtmlId ) ;

                        jc = jbrRightCursor ;

                        }
                            //CONoUTrAW3( "Unsuppressing " , cd , "\r\n" ) ;
                            stNix >> cd ;
                            ZE( countT , cd ) ;
                        {
                        if( stNix && stNix[ 1 ] == jc ) // I DON'T KNOW WHETHER BOTH OF THESE ARE NEEDED

                        //etRock.traceF( tinBaseP , T("RIGHT") ) ;
                        //CONoUTrAW( "RIGHT\r\n" ) ;
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/Z") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                    {
                    else if( jbrRightCursor && jc != jMeP && !bJumpedLag )
                    }
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/a") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                        }
                            break ;
                            etRock.traceF( tinBaseP , T("error: jumped (up) off of a cliff (possibly a missing label in the kt") ) ;
                            DELETEpbs
                        {
                        else
                        if( jc ) stCursor << jc ;

                        //__Z( jc ) ;                                                               //20180420@1058:  !jc CAN HAPPEN WHEN PROCESSING A KT WITH INTENTIONALLY MISSING LABEL
                        bJumped = !!jumpIfIF( tinBaseP , jc , stJump , tRefHtmlId ) ;

                        jc = jbrUpCursor ;
                        bUp = 1 ;
                        //etRock.traceF( tinBaseP , T("UP") ) ;
                        //CONoUTrAW( "UP\r\n" ) ;
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/b") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                    {
                    if( jbrUpCursor )
                    TN( tRefHtmlId , "" ) ;
                    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/c") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                    countT jcSaveGrandDad = stCursor >= 3 ? stCursor[ 3 ] : stCursor >= 2 ? stCursor[ 2 ] : stCursor[ 1 ] ;
                    countT jcSaveDad      =                                 stCursor >= 2 ? stCursor[ 2 ] : stCursor[ 1 ] ;
                    countT jcSaveMe       =                                                                 stCursor[ 1 ] ;
                    if( jc != stCursor[ 1 ] ) { BLAMMO ; }

                    ZE( boolT , bJumped ) ;
                    ZE( boolT , bUp ) ;

                    // *******************************************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    // ****         ******************************************************************************************************************************************
                    // ****  CLIMB  ******************************************************************************************************************************************
                    // ****         ******************************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    // *******************************************************************************************************************************************************

                    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/d") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                    etherP.delF( tinBaseP , psttvDecoded ) ;
                    }
                        }
                            etherP.delF( tinBaseP , pstt1f ) ;
                            }
                                }
                                    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/e") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                                    }
                                        //U::TO FIND A BUG: pP.pswUrlReferenced->ungrabF( tinBaseP ) ;
                                        //U::TO FIND A BUG: ++ *pP.pswUrlReferenced ;
                                        //U::TO FIND A BUG: *pP.ppsttLever = psttc1 ;
                                        //U::TO FIND A BUG: pP.pswUrlReferenced->grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                                        //etRock.traceF( tinBaseP , T("registering: \"")+T(psttc1)+T("\"") ) ;
                                    {
                                    else if( bArm )
                                    }
                                        if( cDelimiters % 2 ) bArm = !bArm ;
                                        if( cDelimiters > 1 ) etRock.traceF( tinBaseP , T("exception: null length file name (multiple adjacent delimiters encountered) [cDelimiters]:    ")+TF2(cDelimiters,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                        countT cDelimiters = psttc1->idAdam ;
                                        if( idDelimiter != 1 ) { BLAMMO ; }
                                    {
                                    if( idDelimiter )

                                    countT idDelimiter = etherP.strIdF( tinBaseP , tm4 , psttc1 ) ;
                                    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/f") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                                {
                                FORsTRINGSiN1( pstt1f )
                                ZE( boolT , bArm ) ;
                            {
                            if( cWords > 1 )
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/g") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            countT cWords = etherP.strWordsF( tinBaseP , pstt1f , psttvDecoded ? psttvDecoded : psttvBody , sttq , tm4 , flSTRwORDS_DELIMITERS ) ; ___( pstt1f ) ;
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/h") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                            ZE( strokeS* , pstt1f ) ;
                            TN( tm4 , "" ) ; tm4 = pP.tn+pP.sMark11 ;
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/i") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                        {
                        else if( bRegisterUrl )
                        }
                            stNix << jNix ;
                            bShow = 0 ;
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/j") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                        {
                        if( jNix )
                        countT jNix = branchS::bEditionIF( tinBaseP , etherP , jc , idEditionP ) ;

                        // *******************************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        // ****                ***********************************************************************************************************************************
                        // ****  REGISTER URL  ***********************************************************************************************************************************
                        // ****                ***********************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        // *******************************************************************************************************************************************************
                        _IO_ //WHERE RANK #4: b% OF TOTAL putFileIF TIME IS SPENT IN HERE
                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/k") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                    {
                    if( bShow )

                    if( bShow && stNix ) bShow = 0 ;

                    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/l") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                    }
                        }
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/m") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            }
                                __Z( psttvSuffix ) ; // "
                                __Z( psttvBody   ) ; // "
                                __Z( psttvPrefix ) ; //SHOULD BE IMPOSSIBLE
                                }
                                    }
                                        }
                                            bDeleteSuffix = 1 ;
                                            etherP.strSubstringF( tinBaseP , psttvSuffix , idf , sttq , pP.sMark01 , psttvDecoded ) ; ___( psttvSuffix ) ;
                                        {
                                        else
                                        if( !idf ) psttvSuffix = pP.tn ;

                                        etherP.strSubstringF( tinBaseP , psttvBody , idf , sttq , pP.sMark01 , psttvDecoded ) ; ___( psttvBody ) ;

                                        bDeletePrefix = 1 ;
                                    {
                                    else
                                    }
                                        psttvBody = psttvPrefix ; psttvSuffix = psttvPrefix = pP.tn ;
                                    {
                                    if( !idf )

                                    etherP.strSubstringF( tinBaseP , psttvPrefix , idf , sttq , pP.sMark01 , psttvDecoded ) ; ___( psttvPrefix ) ;
                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                    countT idf = 1 ;
                                {
                                else
                                }
                                                                psttvDecoded = 0 ;
                                    psttvBody                 = psttvDecoded ;
                                    psttvSuffix = psttvPrefix = pP.tn ;
                                {
                                if( !idMark )

                                countT idMark = etherP.strIdF( tinBaseP , pP.sMark01 , psttvDecoded , 1 ) ;
                                bInvertBehaviorPrefixSuffix = etherP.strIdF( tinBaseP , pP.sMarkf2 , psttvDecoded , 1 ) ;

                                _IO_
                            {


                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/n") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                            }
                                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/o") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                                }
                                    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/p") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                                    }
                                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/q") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                                        }
                                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/r") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                                            etherP.delF( tinBaseP , pstti ) ;

                                            }
                                                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/s") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                                                bIn = !bIn ;
                                                if( idf || bIn ) etherP.strFuseF( tinBaseP , psttvDecoded , !bIn ? te1 : te2 ) ;
                                                etherP.delF( tinBaseP , psttw ) ;

                                                }
                                                    }
                                                        etherP.delF( tinBaseP , pstt1w ) ;

                                                        }
                                                            }
                                                                break ;
                                                                etherP.strFuseF( tinBaseP , psttvDecoded , psttc1 ) ;
                                                            {
                                                            FORsTRINGSiN1( pstt1w )
                                                        {
                                                        else
                                                        }
                                                            }
                                                                if( BlATHsTRING1 ) etherP.strFuseF( tinBaseP , psttvDecoded , psttc1 ) ;
                                                            {
                                                            FORsTRINGSiN1( pstt1w )
                                                        {
                                                        if( !offLevel )

                                                        etherP.strWordsF( tinBaseP , pstt1w , psttw , sttq , tComma ) ; ___( pstt1w ) ;
                                                        ZE( strokeS* , pstt1w ) ;
                                                    {
                                                    else
                                                    if( offe != 0x9 || !bIn ) etherP.strFuseF( tinBaseP , psttvDecoded , psttw ) ;
                                                {
                                                if( psttw && psttw->idAdam )
                                                etherP.strSubstringF( tinBaseP , psttw , idf , sttq , *pP.ppsMacroEscapes[ offe ] , pstti ) ; ___( psttw ) ;
                                                ZE( strokeS* , psttw ) ;
                                                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/t") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                                            {
                                            while( idf )
                                            countT idf = 1 ;
                                            ZE( boolT , bIn ) ;

                                            etherP.strMakeF( tinBaseP , LF , psttvDecoded , 0 , cstta ) ; ___( psttvDecoded ) ;
                                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/u") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                                            countT cstta = pstti->idAdam + cHits * ( te1.csF( tinBaseP ) + te2.csF( tinBaseP ) ) ;

                                            }
                                                }
                                                    }
                                                        break ;
                                                        //etRock.traceF( tinBaseP , T("html tag (putFileIF): \"")+T(pstti)+T("\"") ) ;
                                                        te2 = T("\"></span>")   ;
                                                        te1 = T("<span id=\"" ) ;
                                                    {
                                                    case 0xd :
                                                    case 0xc : { te1 = T(  "<a onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'IdeaFarm (tm) SOIL (Sentient Object Interface Language) file' , 0 )\" href=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+pP.sMark11 ; te2 = pP.tn+pP.sMark11+T("\">")+T("<img src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+tUrlSoilIcon       +tCloseAnchor ; break ; }
                                                    case 0xb : { te1 = T(  "<a onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'miscellaneous file'                                           , 0 )\" href=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+pP.sMark11 ; te2 = pP.tn+pP.sMark11+T("\">")+T("<img src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+tUrlMiscIcon       +tCloseAnchor ; break ; }
                                                    case 0xa : { te1 = T(  "<a onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'zip container'                                                , 0 )\" href=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+pP.sMark11 ; te2 = pP.tn+pP.sMark11+T("\">")+T("<img src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+tUrlZipIcon        +tCloseAnchor ; break ; }
                                                    }
                                                        break ;
                                                        te2  = pP.tn+pP.sMark11+T("\">") ;

                                                        ;
                                                            : T("")+pP.sMark101+T("<img style=\""            "\" onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( '' , 0 )\" src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/" )/*+trpToRoot+pP.thpArchiveSlash*/+pP.sMark11
                                                            ? T("<img style=\"max-width:100%\" onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( '' , 0 )\" src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/" )/*+trpToRoot+pP.thpArchiveSlash*/+pP.sMark11
                                                        te1 = offLevel

                                                        //;
                                                        //    : T("<img style=\""            "\" onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'Slow loading, full resolution image.  For more viewing options, download this image and open its file with your favorite image editor.' , 0 )\" src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/" )/*+trpToRoot+pP.thpArchiveSlash*/+pP.sMark11
                                                        //    ? T("<img style=\"max-width:100%\" onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'Fast loading, low resolution image.  To view full resolution, click the image.'  , 0 )\" src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/" )/*+trpToRoot+pP.thpArchiveSlash*/+pP.sMark11
                                                        //te1 = offLevel
                                                    {
                                                    case 0x9 :
                                                    case 0x8 : { te1 = T(  "<a onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'link to url other than law or treatise'                       , 0 )\" href=\""                            )            ; te2 = pP.tn           +T("\">")+T("<img src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+tUrlLinkOther      +tCloseAnchor ; break ; }
                                                    case 0x7 : { te1 = T(  "<a onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'link to scholarly treatise'                                   , 0 )\" href=\""                            )            ; te2 = pP.tn           +T("\">")+T("<img src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+tUrlLinkTreatise   +tCloseAnchor ; break ; }
                                                    case 0x6 : { te1 = T(  "<a onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'link to statutory or case law'                                , 0 )\" href=\""                            )            ; te2 = pP.tn           +T("\">")+T("<img src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+tUrlLinkLaw        +tCloseAnchor ; break ; }
                                                    case 0x5 : { te1 = T(  "<a onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'text pdf'                                                     , 0 )\" href=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+pP.sMark11 ; te2 = pP.tn+pP.sMark11+T("\">")+T("<img src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+tUrlTextPdf        +tCloseAnchor ; break ; }
                                                    case 0x4 : { te1 = T(  "<a onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'text email'                                                   , 0 )\" href=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+pP.sMark11 ; te2 = pP.tn+pP.sMark11+T("\">")+T("<img src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+tUrlTextEmail      +tCloseAnchor ; break ; }
                                                    case 0x3 : { te1 = T(  "<a onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'text ascii'                                                   , 0 )\" href=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+pP.sMark11 ; te2 = pP.tn+pP.sMark11+T("\">")+T("<img src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+tUrlTextAscii      +tCloseAnchor ; break ; }
                                                    case 0x2 : { te1 = T(  "<a onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'video movie'                                                  , 0 )\" href=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+pP.sMark11 ; te2 = pP.tn+pP.sMark11+T("\">")+T("<img src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+tUrlVideocam       +tCloseAnchor ; break ; }
                                                    case 0x1 : { te1 = T(  "<a onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'snapshot picture'                                             , 0 )\" href=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+pP.sMark11 ; te2 = pP.tn+pP.sMark11+T("\">")+T("<img src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+tUrlCamera         +tCloseAnchor ; break ; }
                                                    case 0x0 : { te1 = T(  "<a onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'voice recording'                                              , 0 )\" href=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+pP.sMark11 ; te2 = pP.tn+pP.sMark11+T("\">")+T("<img src=\"http://" postDOMAINnAMEaRCHIVEiDEAFARMcOM "/")+tUrlMicrophone     +tCloseAnchor ; break ; }
                                                {
                                                switch( offe )
                                            {
                                            TN( te1a , "" ) ;
                                            TN( te2  , "" ) ;
                                            TN( te1  , "" ) ;
                                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/v") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
        
                                                             psttvDecoded = 0 ;
                                            strokeS* pstti = psttvDecoded ;
                                        {
                                        if( cHits && !( cHits % 2 ) )
                                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/w") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                                        //etRock.traceF( tinBaseP , T("[offe,cHits]:    ")+TF2(offe,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(cHits,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

                                        }
                                            }
                                                if( etherP.strIdF( tinBaseP , idf , sttq , *pP.ppsMacroEscapes[ offe ] , psttvDecoded ) ) cHits ++ ;
                                            {
                                            while( idf )
                                            countT idf = 1 ;
                                        {
                                        ZE( countT , cHits ) ;
                                        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/x") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                                    {
                                    for( countT offe = 0 ; offe < sizeof pP.ppsMacroEscapes / sizeof pP.ppsMacroEscapes[ 0 ] ; offe ++ )
                                    TN( tComma , "," ) ;
                                {
                                if( etherP.strIdAnyF( tinBaseP , 0 , flSTRmATCH_null , idf , sttq , pP.tMacroEscapes , psttvDecoded ) )
                                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                countT idf = 1 ;
                                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/y") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                                _IO_
                            {
                            bRegisterUrl = 1 ;
                            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/z") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                            //etRock.traceF( tinBaseP , T("branch:\r\n")+T(psttvDecoded) ) ;
                            etherP.strDecodeF( tinBaseP , psttvDecoded , pbzEncoded ) ; ___( psttvDecoded ) ;
                            _IO_
                        {
                        if( pbzEncoded )

                        const byteT* pbzEncoded = idTypeCursor == ifcIDtYPEbRANCHs_strokeSstr ? (const byteT*)pageEncoded : 0 ;
                        PSP( pageEncoded , valueCursor ) ;
                    {
                    ZE( boolT , bInvertBehaviorPrefixSuffix ) ;
                    ZE( boolT , bRegisterUrl ) ;
                    ZE( strokeS* , psttvDecoded ) ;
                    ZE( strokeS* , psttvSuffix ) ;
                    ZE( strokeS* , psttvBody ) ;
                    ZE( strokeS* , psttvPrefix ) ;
                    ZE( boolT , bDeleteSuffix ) ;
                    ZE( boolT , bDeletePrefix ) ;

                    //CONoUTrAWb( "[jc,bShow,offLevel,idLevelMax,stCursor]: " , jc , " " , bShow , " " , offLevel , " " , idLevelMax , " " , stCursor , "\r\n" ) ;
                    boolT  bShow      = idTypeCursor != ifcIDtYPEbRANCHs_branchSptr && offLevel <= idLevelMax - 1 ;
                    boolT  bMaxAlmost = offLevel == idLevelMax - 2 ;
                    boolT  bMaxGrand  = offLevel == idLevelMax - 1 ;
                    countT offLevel   = stCursor - cLevelsNoted - 1 ;
                    //THIS STUFF IS EARLY SO THAT offLevel CAN BE USED TO CONDITIONALLY SELECT FROM A LIST OF DELIMITED COMMA SEPARATED FILE NAMES E.G. \ifile1.jpg,file2.jpg\i

                    }
                        jbrRightCursor = B(bc).jbrRight ;
                        jbrUpCursor    = B(bc).jbrUp    ;
                        valueCursor    = B(bc).value    ;
                        idTypeCursor   = B(bc).idType   ;
                        BSP( bc , jc ) ;
                    {
                    ZE( countT , jbrRightCursor ) ;
                    ZE( countT , jbrUpCursor    ) ;
                    ZE( countT , valueCursor    ) ;
                    ZE( countT , idTypeCursor   ) ;

                    }
                        __1
                        etRock.traceF( tinBaseP , T("error: infinite loop detected") ) ;
                    {
                    if( stJump > 0x10 )
                    //if( !( idBranch % ( TUCK << 4 ) ) ) etRock.traceF( tinBaseP , T("branch begun [cNest,idPass,idBranch,jc]:    ")+TF2(cNestP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(offPass+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(idBranch,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(jcTrace,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    ++ idBranch ;
                    const countT jcTrace = jc ;
                    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/11") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                    //etRock.traceF( tinBaseP , TP("",cNestP)+T("walk [jMeP,jc]:    ")+TF2(jMeP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(jc,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

                    // *******************************************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    // ****                ***********************************************************************************************************************************
                    // **** SET psttvBody  ***********************************************************************************************************************************
                    // ****                ***********************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    // *******************************************************************************************************************************************************
                    _IO_ //WHERE RANK #3: 11% OF TOTAL putFileIF TIME IS SPENT IN HERE

                    }
                        }
                            countT foo = 2 ;
                        {
                        if( bDebug.psttRefHtmlId || bDebug.idType == ifcIDtYPEbRANCHs_branchSptr )
                        branchS& bDebug = B(bcDebug) ; //U:: TO FIND A BUG
                        BSP( bcDebug , jc ) ;
                    {
                    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/22") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                {
                while( jc && !POOP )
                ZE( countT , idBranch ) ; //ONLY FOR TRACING
                ZE( countT , jbrEditionNix ) ;
                boolT bWoth = 1 ;
                TN( tCloseAnchor , "" ) ; tCloseAnchor = T("\"/></a>") ;

                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/33") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                //  2. GO RIGHT
                //  1. GO DOWN UNTIL CAN GO RIGHT
                // ELSE 
                // ELSE IF CAN GO RIGHT THEN GO RIGHT
                // IF CAN GO UP THEN GO UP
                // 
                // CLIMBING RECIPE:  ASSUMES NO REFERENCES.  GOING RIGHT IS ILLEGAL IF AT ROOT OR IF GOT HERE BY JUMPING
                // 
                // THUS THE ENTIRE CONTENT OF t, INCLUDING THE VALUE OF t, IS EMITTED, AND THEN THE ENTIRE CONTENT OF r'S KIDS AND YOUNGER SIBLINGS IS EMITTED
                // SINCE r IS A REFERENCE, ITS VALUE IS NOT EMITTED
                // AFTER BRANCH t IS WALKED, BRANCH r IS WALKED
                // IF BRANCH r REFERENCES BRANCH t, BRANCH t IS WALKED
                // THE ONLY EXCEPTION IS THE WALKING OF A BRANCH OF TYPE branchSptr
                // NORMALLY, B(bc) NEVER POINTS TO A BRANCH OF TYPE branchSptr
                // NORMALLY, WHEN A NEW VALUE IS PATCHED INTO B(bc), B(bc) IS IMMEDIATELY DEREFERENCED SO THAT IT DOES NOT POINT TO A BRANCH OF TYPE branchSptr
                // WHENEVER A VALUE IS ASSIGNED TO B(bc), THAT SAME VALUE IS IMMEDIATELY LOADED INTO stCursor[1], EITHER BY PUSHING OR BY PATCHING
                // ON ENTRY, B(bc) MUST POINT TO A BRANCH OF TYPE OTHER THAN branchSptr
                // THIS RECIPE WALKS THE TREE WITH THE ROOT B(bc)
                // 
                // RECIPE

                stCursor << jMeP ;
                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/44") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

                }
                    stCursor << jDadP ;
                    cLevelsNoted ++ ;
                {
                if( jDadP != jMeP )

                }
                    stCursor << jGrandDadP ;
                    cLevelsNoted ++ ;
                {
                if( jGrandDadP != jDadP )
                ZE( countT , cLevelsNoted ) ;

                boolT bJumpedLag = !!jumpIfIF( tinBaseP , jc , stJump , tRefHtmlIdLag ) ;
                TN( tRefHtmlIdLag , "" ) ;

                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/55") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                }
                    //CONoUTrAW3( "[cDepthGross]: " , cDepthGross , "\r\n" ) ;
                    //etRock.traceF( tinBaseP , T("[oBias]: ")+TF2(oBias,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
            
                    ;
                        : idLevelMax - cDepthGross
                        ? oBiasDefault
                    oBias = cDepthGross >= idLevelMax
                    __Z( cDepthGross ) ; //WILL OCCUR WHEN I AM NIXED FOR THIS EDITION
                    //etRock.traceF( tinBaseP , T("called  cDepthIF [cDepthGross]: ")+TF2(cDepthGross,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                    countT cDepthGross = 1 + cDepthIF( tinBaseP , etherP , jc , idLevelMax - 1 , idEditionP ) ; // "GROSS": "INCLUDING B(bc)"
                    //etRock.traceF( tinBaseP , T("calling cDepthIF") ) ;
                    _IO_ // WHERE RANK #2: 71% OF TOTAL putFileIF TIME IS SPENT IN HERE
                {
                ZE( countT , oBias ) ;

                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/66") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                //etRock.traceF( tinBaseP , TP("",cNestP)+T("walk begun [jMeP]:    ")+TF2(jMeP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

                }
                    countT foo = 2 ; //U:: TO FIND A BUG
                {
                if( jMeP == 0xb0000056 || jMeP == 0xb0000044 )

                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/77") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                countT jc = jMeP  ;

                // *******************************************************************************************************************************************************
                // *******************************************************************************************************************************************************
                // *******************************************************************************************************************************************************
                // *******************************************************************************************************************************************************
                // ****             **************************************************************************************************************************************
                // ****  WALK jMeP  **************************************************************************************************************************************
                // ****             **************************************************************************************************************************************
                // *******************************************************************************************************************************************************
                // *******************************************************************************************************************************************************
                // *******************************************************************************************************************************************************
                // *******************************************************************************************************************************************************

                }
                    etherP.strFuseF( tinBaseP , psttOutWhite , pP.tHtml10PageBeginWhite , &sOutWhite ) ; ___( psttOutWhite ) ;
                    etherP.strFuseF( tinBaseP , psttOutBlack , pP.tHtml10PageBeginBlack , &sOutBlack ) ; ___( psttOutBlack ) ;
                {
                if( offPass )

                __NZ( stNix ) ;
                stJump.purgeF( tinBaseP ) ;
                stCursor.purgeF( tinBaseP ) ; // NEEDED EVEN IF !offPass BECAUSE I MIGHT HAVE RESTARTED DUE TO CREATING A KID (U::THIS IS AN OBSOLETE COMMENT)
                //etRock.traceF( tinBaseP , T("pass begun [cNest,idPass]:    ")+TF2(cNestP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(offPass+1,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/88") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
                _IO_
            {
            for( countT offPass = 0 ; offPass <= 1 ; offPass ++ ) // 0: ACCUMULATE csttOut ; 1: WRITE psttOutBlack
            TN( tHash , "" ) ;
            ZE( countT , csttNeeded ) ;

            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/99") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
            etherP.delF( tinBaseP , psttu ) ;
            soulC sOutWhite( tinBaseP , TAG( TAGiDnULL ) , flSOUL_null , (osTextT*)tSoulNameWhite ) ;
            soulC sOutBlack( tinBaseP , TAG( TAGiDnULL ) , flSOUL_null , (osTextT*)tSoulNameBlack ) ;

            //etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("putFileIF [sOutJotName]: ")+tSoulNameBlack ) ;
            TN( tSoulNameWhite , "" ) ; tSoulNameWhite = T(psttu)+T(".putfileif.s.out.white.")+TF2(cNestP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
            TN( tSoulNameBlack , "" ) ; tSoulNameBlack = T(psttu)+T(".putfileif.s.out.black.")+TF2(cNestP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
            etherP.strUniqueF( tinBaseP , psttu ) ; ___( psttu ) ;
            ZE( strokeS* , psttu ) ;
            ZE( strokeS* , psttOutWhite ) ;
            ZE( strokeS* , psttOutBlack ) ;
            //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/aa") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
            _IO_
        {
        if( !POOP )

        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/bb") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
        stackC stNix(    tinBaseP , etherP , TAG( TAGiDnULL ), flSTACKc_DOnOTsERIALIZE|flSTACKc_XRAY               , ifcSTACKtYPE_countT   ) ;
        stackC stJump(   tinBaseP , etherP , TAG( TAGiDnULL ), flSTACKc_DOnOTsERIALIZE|flSTACKc_XRAY|flSTACKc_BLOB , 2 * sizeof( countT )  ) ;
        stackC stCursor( tinBaseP , etherP , TAG( TAGiDnULL ), flSTACKc_DOnOTsERIALIZE|flSTACKc_XRAY               , ifcSTACKtYPE_countT   ) ;

        }
            }
                etherP.delF( tinBaseP , psttvDecoded ) ;

                }
                    bMaxReduced = 1 ;
                    ++ oBiasDefault ;
                    -- *(countT*)&idLevelMax ;
                {
                if( etherP.strIdF( tinBaseP , pP.sMarkb1 , psttvDecoded , 1 ) )

                etherP.strDecodeF( tinBaseP , psttvDecoded , pbzEncoded ) ; ___( psttvDecoded ) ;
                ZE( strokeS* , psttvDecoded ) ;
            {
            if( pbzEncoded )
            const byteT* pbzEncoded = idTypeMe == ifcIDtYPEbRANCHs_strokeSstr ? (const byteT*)pageEncoded : 0 ;

            PSP( pageEncoded , valueMe ) ;
            }
                idTypeMe = B(br).idType ;
                valueMe  = B(br).value  ;
                BSP( br , jMeP ) ;
            {
            ZE( countT , valueMe ) ;
            ZE( countT , idTypeMe ) ;
            _IO_
        {
        /*const*/ countT idLevelMax = 3 ; // WATCOM COMPILER HAS BEEN OBSERVED TO EMIT INCORRECT OBJECT CODE FOR const LOCAL VARIABLES
        ZE( boolT  , bEmitSpan    ) ;
        ZE( boolT  , bMaxReduced  ) ;
        ZE( countT , oBiasDefault ) ;

        TN( thBranchTerminator , "" ) ;

        if( tPrologWas_aBlack.csF( tinBaseP ) > tPrologWas_aWhite.csF( tinBaseP ) ) { BLAMMO ; }
        
        ) ;

            "                                        <a href=\"../")+tFileTiny+T(".white.html\" onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'Click to climb down to the root branch (home page).' , 0 )\">root</a>\r\n"

        TN( tPrologWas_aWhite , "" ) ; tPrologWas_aWhite = T(

        ) ;

            "                                        <a href=\"../")+tFileTiny+T(".html\" onmouseout=\"sayMessageF( 0 , 16000 )\" onmouseover=\"sayMessageF( 'Click to climb down to the root branch (home page).' , 0 )\">root</a>\r\n"

        TN( tPrologWas_aBlack , "" ) ; tPrologWas_aBlack = T(

        textC** pptUrl = cNestP == 1 ? &pP.ppthpu[ 0 ] : &pP.ppthpu[ 0 ] ;

        textC& tUrlb            = cNestP == 1 ? pP.thpub             : pP.thpub             ;
        textC& tUrla            = cNestP == 1 ? pP.thpua             : pP.thpua             ;
        textC& tUrl9            = cNestP == 1 ? pP.thpu9             : pP.thpu9             ;
        textC& tUrl8            = cNestP == 1 ? pP.thpu8             : pP.thpu8             ;
        textC& tUrl7            = cNestP == 1 ? pP.thpu7             : pP.thpu7             ;
        textC& tUrl6            = cNestP == 1 ? pP.thpu6             : pP.thpu6             ;
        textC& tUrl5            = cNestP == 1 ? pP.thpu5             : pP.thpu5             ;
        textC& tUrl4            = cNestP == 1 ? pP.thpu4             : pP.thpu4             ;
        textC& tUrl3            = cNestP == 1 ? pP.thpu3             : pP.thpu3             ;
        textC& tUrl2            = cNestP == 1 ? pP.thpu2             : pP.thpu2             ;
        textC& tUrl1            = cNestP == 1 ? pP.thpu1             : pP.thpu1             ;

        textC& tUrlLinkOther    = cNestP == 1 ? pP.thpuLinkOther     : pP.thpuLinkOther     ;
        textC& tUrlLinkTreatise = cNestP == 1 ? pP.thpuLinkTreatise  : pP.thpuLinkTreatise  ;
        textC& tUrlLinkLaw      = cNestP == 1 ? pP.thpuLinkLaw       : pP.thpuLinkLaw       ;
        textC& tUrlTextPdf      = cNestP == 1 ? pP.thpuTextPdf       : pP.thpuTextPdf       ;
        textC& tUrlTextEmail    = cNestP == 1 ? pP.thpuTextEmail     : pP.thpuTextEmail     ;
        textC& tUrlTextAscii    = cNestP == 1 ? pP.thpuTextAscii     : pP.thpuTextAscii     ;
        textC& tUrlSoilIcon     = cNestP == 1 ? pP.thpuSoilIcon      : pP.thpuSoilIcon      ;
        textC& tUrlMiscIcon     = cNestP == 1 ? pP.thpuMiscIcon      : pP.thpuMiscIcon      ;
        textC& tUrlZipIcon      = cNestP == 1 ? pP.thpuZipIcon       : pP.thpuZipIcon       ;
        textC& tUrlVideocam     = cNestP == 1 ? pP.thpuVideocam      : pP.thpuVideocam      ;
        textC& tUrlCamera       = cNestP == 1 ? pP.thpuCamera        : pP.thpuCamera        ;
        textC& tUrlMicrophone   = cNestP == 1 ? pP.thpuMicrophone    : pP.thpuMicrophone    ;
        textC& tUrlIcon         = cNestP == 1 ? pP.thpuIcon          : pP.thpuIcon          ;

        if( tDown2Black.csF( tinBaseP ) > tDown2White.csF( tinBaseP ) ) { BLAMMO ; }
        if( tDown1Black.csF( tinBaseP ) > tDown1White.csF( tinBaseP ) ) { BLAMMO ; }

        //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/cc") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
        }
            }
                }
                    etherP.delF( tinBaseP , psttvDecoded ) ;

                    }
                        bSuppressDown2 = 1 ;
                    {
                    if( !psttvDecoded || !psttvDecoded->idAdam || etherP.strIdF( tinBaseP , pP.sMark02 , psttvDecoded ) )

                    etherP.strDecodeF( tinBaseP , psttvDecoded , pbzEncoded ) ; ___( psttvDecoded ) ;
                    ZE( strokeS* , psttvDecoded ) ;
                {
                if( pbzEncoded )
                const byteT* pbzEncoded = idTypeGrandDad == ifcIDtYPEbRANCHs_strokeSstr ? (const byteT*)pageEncoded : 0 ;

                PSP( pageEncoded , valueGrandDad ) ;
                }
                    idTypeGrandDad = B(br).idType ;
                    valueGrandDad  = B(br).value  ;
                    BSP( br , jGrandDadP ) ;
                {
                ZE( countT , valueGrandDad ) ;
                ZE( countT , idTypeGrandDad ) ;
                _IO_
            {

            }
                }
                    etherP.delF( tinBaseP , psttvDecoded ) ;

                    }
                        bSuppressDown1 = 1 ;
                    {
                    if( !psttvDecoded || !psttvDecoded->idAdam || etherP.strIdF( tinBaseP , pP.sMark02 , psttvDecoded ) )

                    etherP.strDecodeF( tinBaseP , psttvDecoded , pbzEncoded ) ; ___( psttvDecoded ) ;
                    ZE( strokeS* , psttvDecoded ) ;
                {
                if( pbzEncoded )
                const byteT* pbzEncoded = idTypeDad == ifcIDtYPEbRANCHs_strokeSstr ? (const byteT*)pageEncoded : 0 ;

                PSP( pageEncoded , valueDad ) ;
                }
                    idTypeDad = B(br).idType ;
                    valueDad  = B(br).value  ;
                    BSP( br , jDadP ) ;
                {
                ZE( countT , valueDad ) ;
                ZE( countT , idTypeDad ) ;
                _IO_
            {

            }
                ;
                    : tGrandDadFileShortWhite
                    ? trpToRoot+tGrandDadFileShortWhite
                tDown2White = bRootGrandDad

                ;
                    : tGrandDadFileShortBlack
                    ? trpToRoot+tGrandDadFileShortBlack
                tDown2Black = bRootGrandDad

                boolT bRootGrandDad = !etherP.strCompareF( tinBaseP , tGrandDadFileShortBlack , tFileTiny+T(".html") ) ;

                tFileF( tinBaseP , etherP , tGrandDadFilePath , tGrandDadFileShortBlack , tGrandDadFileShortWhite , tGrandDadFileTiny , jGrandDadP , pP , cNestP , idEditionP ) ;
                TN( tGrandDadFileShortWhite , "" ) ;
                TN( tGrandDadFileShortBlack , "" ) ;
                TN( tGrandDadFileTiny  , "" ) ;
                TN( tGrandDadFilePath  , "" ) ;
            {
            if( jDadP != jGrandDadP )

            ;
                : tDadFileShortWhite
                ? trpToRoot+tDadFileShortWhite
            tDown1White = bRootDad

            ;
                : tDadFileShortBlack
                ? trpToRoot+tDadFileShortBlack
            tDown1Black = bRootDad

            boolT bRootDad = !etherP.strCompareF( tinBaseP , tDadFileShortBlack , tFileTiny+T(".html") ) ;

            tFileF( tinBaseP , etherP , tDadFilePath , tDadFileShortBlack , tDadFileShortWhite , tDadFileTiny , jDadP , pP , cNestP , idEditionP ) ;
            TN( tDadFileShortWhite , "" ) ;
            TN( tDadFileShortBlack , "" ) ;
            TN( tDadFileTiny  , "" ) ;
            TN( tDadFilePath  , "" ) ;
            _IO_
        {
        if( jMeP != jDadP )
        ZE( boolT , bSuppressDown2 ) ;
        ZE( boolT , bSuppressDown1 ) ;
        TN( tDown2White , "" ) ;
        TN( tDown2Black , "" ) ;
        TN( tDown1White , "" ) ;
        TN( tDown1Black , "" ) ;

        textC& trpToRoot = cNestP == 1 ? pP.thNull : pP.thDotDotSlash ;

        //LOGrAW3( "put""FileF/+ [cNestP]: " , cNestP , "\r\n" ) ;

        if( POOP ) { BLAMMO ; } //U:: THIS IS POSSIBLE DUE TO A RACE CONDITION: IF OO JOBS FOR THE SAME PAGE ARE QUEUED, IT IS POSSIBLE FOR THE "WRONG" (OOTH) JOB TO GET TO THIS POINT

        //}
        //    __Z( jDadP - jGrandDadP ) ;
        //    __Z( jMeP  - jGrandDadP ) ;
        //    __Z( jMeP  - jDadP      ) ;
        //{
        //if( !bRootMe && !bRootDad )

        boolT bRootDad = ( jDadP & ~NM_HIGH ) == 2 ;
        boolT bRootMe  = ( jMeP  & ~NM_HIGH ) == 2 ;
        _IO_
    {
    if( !bDone )

    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/dd") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
    }
        swFileP.ungrabF( tinBaseP ) ;
        }
            swFileP = (countT)1 ; //U:: 20171227@1430: THIS VALUE IS ARBITRARY AND IS NEVER USED. MIGRATE TO USE stackC OR SOME CONTAINER OTHER THAN switchC BECAUSE NO LONGER STORING FILE NAME
            cLeverBranchP = jMeP ;
        {
        if( !bDone )
        bDone = swFileP.idSlotOfLeverF( tinBaseP , jMeP ) ; //A:ASSUME: WOTH CALL TO WRITE THIS FILE IS THE "BEST" CALL TO USE SINCE jDadP != jGrandDadP
        swFileP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

        }
            //++ s ; etherP.osSleepF( tinBaseP , TOCK ) ;
            //sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
        {
        if( jDadP == jGrandDadP ) //U:: KLUDGE TO MAKE PERVERSE RACE OUTCOME LESS LIKELY
        //U::T:

        _IO_
    {
    ZE( boolT , bDone ) ;

    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/ee") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)
    tFileF( tinBaseP , etherP , tFilePath , tFileShortBlack , tFileShortWhite , tFileTiny , jMeP , pP , cNestP , idEditionP ) ;
    TN( tFileShortWhite , "" ) ;
    TN( tFileShortBlack , "" ) ;
    TN( tFileTiny  , "" ) ;
    TN( tFilePath  , "" ) ;

    }
        __1
        LOGrAW( "error: infinite loop detected\r\n" ) ;
    {
    if( ++ cNestP > pP.cNestMax )

    }
        countT foo = 2 ;
    {
    if( idIn == idInTest )
    countT idIn = 1 + incv02AM( idInLath ) ;
    static countT idInTest = 3 ;
    static countT idInLath ;

    // *******************************************************************************************************************************************************
    // *******************************************************************************************************************************************************
    // *******************************************************************************************************************************************************
    // *******************************************************************************************************************************************************
    // ****           ****************************************************************************************************************************************
    // ****  PREPARE  ****************************************************************************************************************************************
    // ****           ****************************************************************************************************************************************
    // *******************************************************************************************************************************************************
    // *******************************************************************************************************************************************************
    // *******************************************************************************************************************************************************
    // *******************************************************************************************************************************************************

    //etRock.traceF( tinBaseP , TP("",cNestP)+T("U::/ff") ) ; //U::TO FIND A BUG (TRACE SQUEEZE)

    _IO_

    }
        if( POOP ) return ;
        __( idEditionP > 9 ) ;
        __Z( idEditionP ) ;
        __Z( B(br).hashId ) ;
        __Z( B(br).hashv ) ;

        BSP( br , jMeP ) ;

        if( POOP ) return ;

        }
            }
                __( jNakedMe ) ;
            {
            if( jNakedMe != 2 )                 // THE ROOT BRANCH MUST BE 2 BECAUSE I CONTAIN CODE THAT TESTS FOR THIS VALUE
            countT jNakedMe = jMeP & ~NM_HIGH ;
        {
        if( !cNestP )

        if( POOP ) return ;
    {
    IFbEcAREFUL
    //etRock.traceF( tinBaseP , TP("",cNestP)+T("put""FileIF/+ ")+TF2(cNestP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(jMeP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(jDadP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2(jGrandDadP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;

    etherC& etRock = etherC::etRockIF( tinBaseP ) ;
{
/*1*/voidT branchS::putFileIF( tin0S& tinBaseP , etherC& etherP , const boolT& bQuitP , countT& cPendingP , stackC& st_putFileJob_P , putFileS& pP , const countT offLevelP , const countT jMeP , const countT jDadP , const countT jGrandDadP , countT& cLeverBranchP , switchC& swFileP , countT cNestP , const countT idEditionP , const strokeS* const psttTimeStampP , const strokeS* const psttBanner1P , const strokeS* const psttBanner2P , const strokeS* const psttNameSpaceP )/*1*/

//PC|    
//PC|            write tFilePath+tFileShort
//PC|    
//PC|                        // ****  ORDER PAGE FOR CURRENT BRANCH  ****
//PC|    
//PC|                    if bKid && not redundant
//PC|    
//PC|                    // ****  APPEND TEXT  ****
//PC|    
//PC|                if bShow
//PC|    
//PC|                // ****  CLIMB  ****
//PC|    
//PC|                    // ****  REGISTER URL  ****
//PC|    
//PC|                if bShow
//PC|    
//PC|                // **** SET psttvBody  ****
//PC|    
//PC|            while jc
//PC|    
//PC|            // ****  WALK jMeP  ****
//PC|    
//PC|        for offPass 0 , 1 (accumulate csttOut , write psttOutBlack)
//PC|        
//PC|        calculate tDown1 tDown2 (queries registry)
//PC|        register tFileShort
//PC|        calculate tFile Path Short Tiny
//PC|    
//PC|        // ****  PREPARE  ****
//PC|    
//PC|    putFileIF
//PC|    
//PC|    PSEUDOcODE

}
    }
        etherP.delF( tinBaseP , psttPart2 ) ;
        etherP.delF( tinBaseP , psttPart1 ) ;
        tFileShortWhiteP = tFileTinyP+(bRoot?T(".white"):pP.thDotZDot+T("white.")+TF3(B(br).hashv,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+pP.thDot+TF3(B(br).hashId,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8))+T(".html") ;
        tFileShortBlackP = tFileTinyP+(bRoot?pP.tn      :pP.thDotZDot+T("black.")+TF3(B(br).hashv,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+pP.thDot+TF3(B(br).hashId,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8))+T(".html") ;
        tFileTinyP  = T(psttPart2) ;
        tFilePathP  = T(psttPart1)+TF2(idEditionP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+(cNestP==1?pP.tn:pP.thSlash+pP.thLeaf)+pP.thSlash ;
        etherP.strBisectF( tinBaseP , psttPart1 , psttPart2 , pP.psttFile , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPart1 ) ; ___( psttPart2 ) ;
        ZE( strokeS* , psttPart2 ) ;
        ZE( strokeS* , psttPart1 ) ;
    {
    if( B(br).idType != ifcIDtYPEbRANCHs_branchSptr )

    }
        if( jNakedMe == 2 ) bRoot = 1 ;
        countT jNakedMe = jP & ~NM_HIGH ;
    {
    ZE( boolT , bRoot ) ;

    BSP( br , jP ) ;
{
voidT tFileF( tin0S& tinBaseP , etherC& etherP , textC& tFilePathP , textC& tFileShortBlackP , textC& tFileShortWhiteP , textC& tFileTinyP , const countT jP , putFileS& pP , const countT cNestP , const countT idEditionP )

//U::ELIMINATE cNestP ; RESULT WILL BECOME INVARIANT WRT cNestP

    }
        if( bDeleteSuffix ) etherP.delF( tinBaseP , psttvSuffix ) ;                     \
                            etherP.delF( tinBaseP , psttvBody ) ;                       \
        if( bDeletePrefix ) etherP.delF( tinBaseP , psttvPrefix ) ;                     \
    {                                                                               \
                                                                                    \
#define DELETEpbs                                                                   \

/**/
*/
U::enhance to obey a flag saying "lint walk to detect nonunique hash values"
if this assumption is not satisfied by the input, i will fail when i attempt to open an output file that already exists
warning: i assume that the body portion of each branch value is unique
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

