
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        //U:: pbMeta IS BACKED BY A DATABASE LISTING THAT SHOULD BE DELETED IF I AM THE ONLY REFERENCE TO IT
    {
    else
    }
        DELzOMBIE( pnDoomed ) ;
        napkinC* pnDoomed = (napkinC*)pb_napMeta ;
    {
    if( F(flagsStatePrivate) & flSEXcsTATEpRIVATE_USINGnAPfORmETA )

    }
        DELzOMBIE( pnDoomed ) ;
        napkinC* pnDoomed = (napkinC*)pb_napData ;
    {
    if( F(flagsStatePrivate) & flSEXcsTATEpRIVATE_USINGnAPfORdATA )

    //------------------------------------------------------------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        }
            DELzOMBIE( pzMetaHead ) ;

            }
                }
                    //if( cLeaks ) BOSnOvALUE( WHATsn , OS sLEEPf( -1 ) )

                    }
                        }
                            //}
                            //    LOGrAW( "\"\r\n" ) ;
                            //    LOGrAW( postBuf ) ;
                            //    LOGrAW( "content: \"" ) ;
                            //
                            //    CONoUTrAW( "\"\r\n" ) ;
                            //    CONoUTrAW( postBuf ) ;
                            //    CONoUTrAW( "content: \"" ) ;
                            //
                            //    *posto = 0 ;
                            //    while( cDo -- ) *( posto ++ ) = ( pstti ++ )->idAdam ;
                            //    countT cDo = ((strokeS*)pbDrop)->idAdam ;
                            //    osTextT* posto = postBuf ;
                            //    strokeS* pstti = (strokeS*)pbDrop + CSpREFIX ;
                            //    osTextT postBuf[ TUCK << 2 ] ;
                            //{
                            //COMMENT OUT IN PRODUCTION.  CODE LIKE THIS CAN BE USED TO FIND LEAKS: strokeS STRING

                            //}
                            //    LOGrAW( "\r\n" ) ;
                            //    LOGrAW( pbDrop ) ;
                            //    //LOGrAW( "content: \"" ) ;
                            //
                            //    CONoUTrAW( "\r\n" ) ;
                            //    CONoUTrAW( pbDrop + offx ) ;
                            //    //CONoUTrAW( "content: \"" ) ;
                            //
                            //    countT offx = thirdC::c_strstrIF( pbDrop , postTest ) == pbDrop ? sizeof postTest - 1 : 0 ;
                            //    static osTextT postTest[] = POSThHOMEdRIVE ":\\ideafarm.home.1\\ephemeral\\backed.up.daily\\domains\\com\\ideafarm\\ipdos\\memorySpaces\\ifo20111122\\4\\stateSpaces\\" ;
                            //{
                            //if( pzMetaNote[ offs ].idLineTagged == 0x5f )
                            //COMMENT OUT IN PRODUCTION.  CODE LIKE THIS CAN BE USED TO FIND LEAKS: osTextT STRING

                            etherC::etRockIF( tinBaseP ).traceF( tinBaseP , (const strokeS* const)(const osTextT* const)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
                            }
                                OStEXTC(  ostoSay , idName , 0 ) ;
                                OStEXTAK( ostoSay , "    listC: " ) ;
                            {
                            if( idName )
                            OStEXTAK( ostoSay , "_9)" ) ;
                            OStEXTC9( ostoSay , pzMetaNote[ offs ].idLineTagged2 ) ;
                            OStEXTAK( ostoSay , "_(" ) ;
                            OStEXTCF( ostoSay , pzMetaNote[ offs ].idiFileTagged2 , 0 ) ;
                            OStEXTAK( ostoSay , "_9)    " ) ;
                            OStEXTC9( ostoSay , pzMetaNote[ offs ].idLineTagged ) ;
                            OStEXTAK( ostoSay , "_(" ) ;
                            OStEXTCF( ostoSay , pzMetaNote[ offs ].idiFileTagged , 0 ) ;
                            OStEXTAK( ostoSay , "_    " ) ;
                            OStEXTCF( ostoSay , pbDrop , '0' ) ;
                            OStEXTAK( ostoSay , "\"    " ) ;
                            OStEXTA(  ostoSay , pzMetaHead->postName ) ;
                            OStEXTAK( ostoSay , "~sexC leak found [postName,@address,LF,LF-TAGGED,listC::idName]:    \"" ) ;
                            OStEXT(   ostoSay , TUCK << 1 ) ;

                            ;
                                : 0
                                ? ((listC*)pbDrop)->nameF()
                            countT idName = listingC::bIsListingIF( tinBaseP , (listingC*)pbDrop , fliLISTINGc_MIXINlIST )
                            byteT* pbDrop = pbData + offs * cbSlot + ( pzMetaHead->cbDropSeparator + pzMetaHead->cbDropHeader ) ;

                            cLeaks ++ ;
                        {
                        if( bOwned )

                        continue ;
                        )
                            offs >= offSlotsUseableEnd 
                            ||
                            offs <  offSlotsUseableBegin
                        (
                        if
                    
                        }
                            mask = 1 ;
                            pbo ++ ;
                        {
                        if( !mask )
                        mask <<= 1 ;
                        boolT bOwned = *pbo & mask ;
                    {
                    for( countT offs = 0 ; offs < cSlots ; offs ++ )

                    ZE( countT , cLeaks ) ;
                    byteT mask = 1 ;
                    byteT* pbo = pbzMetaBitsOwned ;
                    const countT offSlotsUseableEnd   = cSlots - pzMetaHead->cSlotsAvoidHi ;
                    const countT offSlotsUseableBegin =          pzMetaHead->cSlotsAvoidLo ;
                    const countT cSlots = 1 << pzMetaHead->expSlots ;
                    const countT cbSlot = pzMetaHead->cbDropSeparator + pzMetaHead->cbDropHeader + pzMetaHead->cbDropAdjust + ( 1 << pzMetaHead->expCbDrop ) ;
                {
                if( pzMetaNote )

                ;
                    : 0
                    ? (dropNoteS*)( pbzMetaBitsOwned + cbaBitsOwned )
                dropNoteS* pzMetaNote = F(pzMetaHead->flagsCt) & fliSEXc_NOTES

                cbaBitsOwned += CBtOaLIGN02( pbzMetaBitsOwned + cbaBitsOwned ) ;
                countT cbaBitsOwned = 1 + ( 1 << pzMetaHead->expSlots ) / SB ;

                byteT* pbzMetaBitsOwned = (byteT*)( pzMetaHead + 1 ) ;
            {
            if( bFoo )
            boolT bFoo = 1 ;
            //U::IF A FLAG IS SET THEN LOG ALL SLOTS THAT ARE FLAGGED AS OWNED AND, IF NOTE EXISTS, REPORT THE CONTENT OF THE NOTE FOR EACH
        {
        if( 1 == decv02AM( pzMetaHead->cRef ) )

        }
            DELzOMBIE( pDoomed ) ;
            pDoomed = (fileC*)pbFileData ;
            DELzOMBIE( pDoomed ) ;
            fileC* pDoomed = (fileC*)pbFileMeta ;
            puseC puse( tinBaseP , ifcIDpOOL_ADAMtEMP ) ;
        {
        if( pzMetaHead && F(pzMetaHead->flagsCt) & fliSEXc_MAPPEDtOdISK ) //CLOSING THE BACKING FILES BEFORE DELETING THE SHARED MEMORY THAT IS MAPPED TO THEM IS OK ACCORDING TO WIN32 DOC

        //------------------------------------------------------------------------------------------------------------------------------------------------------------
        // 
        //------------------------------------------------------------------------------------------------------------------------------------------------------------

        }
            }
                }
                    LOGrAW( "sexC::~sexC/!exception: i could not find myself in the registry\r\n" ) ;
                {
                if( offe == CsEXeNTRIES )

                grabot.ungrabF( tinBaseP ) ;
                }
                    }
                        break ;
                        if( !( -- pe[ offe ].cRef ) ) thirdC::c_memsetIF( tinBaseP , pe[ offe ].postName , sizeof pe[ offe ].postName ) ;
                    {
                    if( !thirdC::c_strcmpIF( tinBaseP , pe[ offe ].postName , pzMetaHead->postName ) )
                {
                for( ; offe < CsEXeNTRIES ; offe ++ )
                ZE( countT , offe ) ;
                grabot.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
        
                sexGlobalEntryS* pe = (sexGlobalEntryS*)( pbNapkin + sizeof( grabotC ) ) ;
                grabotC& grabot = *(grabotC*)pbNapkin ;

                grabitC grabitx( tinBaseP , TAG( TAGiDnULL ) ) ;
            {
            if( pbNapkin )
            byteT* pbNapkin = processGlobal8I._sexC_napGlobalRegistry ;
        {
        if( F(flagsStatePrivate) & flSEXcsTATEpRIVATE_REGISTEREDwITHlEAKlOGGERaOK )

        //------------------------------------------------------------------------------------------------------------------------------------------------------------
        // IF I AM NOT PART OF THE poolC USED BY THE LEAKlOGGER ADAM THEN DEREGISTER MYSELF WITH LEAK LOGGER
        //------------------------------------------------------------------------------------------------------------------------------------------------------------

        //}
        //    etherC::etRockIF( tinBaseP ).traceF( tinBaseP , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT ) ;
        //    
        //    OStEXTAK( ostoSay , "\" " ) ;
        //    OStEXTA(  ostoSay , pzMetaHead->postName ) ;
        //    OStEXTAK( ostoSay , " \"" ) ;
        //    OStEXTCF( ostoSay , pbDataEnd , ' ' ) ;
        //    OStEXTAK( ostoSay , " " ) ;
        //    OStEXTCF( ostoSay , pbData , ' ' ) ;
        //    OStEXTA(  ostoSay , F(flagsStatePrivate) & flSEXcsTATEpRIVATE_USINGnAPfORmETA ? " NAPKIN " : " pool   " ) ;
        //    OStEXTA(  ostoSay , F(flagsStatePrivate) & flSEXcsTATEpRIVATE_USINGnAPfORdATA ? " NAPKIN " : " pool   " ) ;
        //    OStEXTC(  ostoSay , pzMetaHead->expSlots , ' ' ) ;
        //    OStEXTAK( ostoSay , " " ) ;
        //    OStEXTC(  ostoSay , pzMetaHead->expCbDrop , ' ' ) ;
        //    OStEXTAK( ostoSay , "          " ) ;
        //    OStEXTC(  ostoSay , ((tinFullS&)tinBaseP).pag1->idAdam , ' ' ) ;
        //    OStEXTAK( ostoSay , "---- ~sexC [idAdam                ,expCbDrop,expSlots,n/p,pbData,pbDataEnd,postName]: " ) ;
        //    OStEXT(   ostoSay , TUCK << 2 ) ;
        //{

        //------------------------------------------------------------------------------------------------------------------------------------------------------------
        // DEBUGGING CHATTER
        //------------------------------------------------------------------------------------------------------------------------------------------------------------

        }
            }
                btsAM( pReg->pbSexDeletedBits , offSexBit ) ;                                                   // INTENTIONALLY NOT CHECKED, BUT FAILURE MIGHT INDICATE A SOFTWARE ERROR SINCE SETTING THIS BIT SHOULD PREVENT CODE FROM REQUESTING A SUBSEQUENT DELETION ; NOT CHECKED BECAUSE THE BIT IS JUST A SUGGESTION AND CODE MIGHT DECIDE TO IGNORE IT
                const countT offSexBit = pzMetaHead->expCbDrop * CsLOTeXTENTS + pzMetaHead->expSlots ;
            {
            if( pReg )

            //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            // SET THE "DELETED" BIT FOR MY SPECIFICATIONS [expCbDropP,expSlotsP] TO SUPPRESS SUBSEQUENT DELETIONS UNTIL THE BIT IS CLEARED BY tmWatchF
            //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

            }
                __( !pReg ) ;
                }
                    }
                        break ;
                        inc02AM( pReg->cRefPoolReg ) ;
                        pReg = pRegs + offr ;
                    {
                    if( !thirdC::c_strcmpIF( tinBaseP , pRegs[ offr ].postPoolName , postPoolName ) && !pReg )
                    grabitC grabx( tinBaseP , TAG( TAGiDnULL ) , (byteT*)&pRegs[ offr ].flagsi , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_null , 0 , ifcIDgRABlAYER_9POOLlAYER2) ;
                {
                for( countT offr = 0 ; offr < CpOOLrEGISTRATIONSmAX ; offr ++ )

                grabitC grabx( tinBaseP , TAG( TAGiDnULL ) , (byteT*)&home.fliGrab , ifcIDgRABITbIT_00 , *(grabitC*)0 , 0 , 0 , 0 , flGRABITc_null , 0 , ifcIDgRABlAYER_9POOLlAYER1 ) ;

                const osTextT* postPoolName = pPoolContainsMe->postNameF( tinBaseP ) ;
                poolRegistrationS* pRegs = (poolRegistrationS*)home.pb_pPoolReg ;
                homeS& home = homeS::homeIF() ;
                POOPIE
            {
            if( pPoolContainsMe )
            ZE( poolRegistrationS* , pReg ) ;

            //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            // SET pReg TO THE REGISTRATION RECORD FOR *pPoolContainsMe
            //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        {
    {
    if( pzMetaHead )

    //}
    //    CONoUTrAW( "\"\r\n" ) ;
    //    CONoUTrAW( pzMetaHead->postName ) ;
    //    CONoUTrAW( "~sexC -  --  - [postName]: \"" ) ;
    //    if( !pzMetaHead ) { BLAMMOiD( 0x77700777 ) ; }
    //{
    //if( !idPoopWas )

    //------------------------------------------------------------------------------------------------------------------------------------------------------------
    // 
    //------------------------------------------------------------------------------------------------------------------------------------------------------------

    }
        TELLsYSc3( idTypeSay , (byteT*)&info , sizeof info )
        info.pSex       = this ;
        thirdC::c_strcpyIF( tinBaseP , info.postName , pzMetaHead->postName ) ;
        info.expSlots   = pzMetaHead->expSlots  ;
        info.expCbDrop  = pzMetaHead->expCbDrop ;
        info.osPid      = ((tinFullS&)tinBaseP).osPid ;
        tellInfoSysSexS info ;
        countT idTypeSay = ifcIDtYPEtELLsYS_SEXdT ;
    {
    if( F(flagsStatePrivate) & flSEXcsTATEpRIVATE_CONSTRUCTEDaOK )

    _IO_

    if( POOP ) POOPRqUIET ;
    countT idPoopWas = POOP ;
    SCOOP

    TINSL
{
/*1*/sexC::~sexC( voidT )/*1*/


/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

