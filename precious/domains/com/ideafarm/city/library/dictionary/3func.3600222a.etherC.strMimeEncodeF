
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    return offo - 1 ;   //DON'T INCLUDE THE TRAILING 0, WHICH I PUT THERE AS A COURTESY BUT WHICH IS NOT PART OF THE ENCODING

    traceF( tin0P , T("strMimeEncodeF / [costOut]:    ")+TF2(offo-1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    delF( tin0P , postoRaw ) ;

    }
        __( offo - costa ) ;
        postP[ offo ++ ] = 0 ;
        postP[ offo ++ ] = '\n' ;
        postP[ offo ++ ] = '\r' ;
        }
            postP[ offo ++ ] = postoRaw[ offi ] ;
            }
                postP[ offo ++ ] = '\n' ;
                postP[ offo ++ ] = '\r' ;
            {
            if( offi && !( offi % 76 ) )
        {
        for( countT offi = 0 ; offi < costoRaw ; offi ++ )
    {
    if( postP )
    ZE( countT , offo ) ;
    newF( tin0P , LF , postP , costa ) ; ___( postP ) ;
    countT costa = costoRaw + 1 + ( cCRLF << 1 ) ;

    countT cCRLF = 1 + costoRaw / 76 ;      // RFC 2045 LINE LENGTH LIMIT

    traceF( tin0P , T("strMimeEncodeF / got     [costoRaw,tLongMappedOut]:    ")+TF2(costoRaw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongMappedOut ) ;
    boxGetShadowF( tin0P , postoRaw , costoRaw , tLongMappedOut ) ; ___( postoRaw ) ;               //U:: IN PRODUCTION, USE boxGetF
    traceF( tin0P , T("strMimeEncodeF / getting [tLongMappedOut]:    ")+tLongMappedOut ) ;
    ZE( countT   , costoRaw ) ;
    ZE( osTextT* , postoRaw ) ;

    traceF( tin0P , T("strMimeEncodeF / 0") ) ;
    boxZapF( tin0P , tLongMappedIn ) ;
    traceF( tin0P , T("strMimeEncodeF / 1") ) ;

    }
        traceF( tin0P , T("strMimeEncodeF [c4Result]:    ")+TF2(c4Result.c1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(c4Result.c2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(c4Result.c3,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(c4Result.c4,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        }
            traceF( tin0P , T("strMimeEncodeF / 2") ) ;
            c4Result = ifcHireF( tin0P , T("ifcIDaDAM_HEALaRCHIVES") , ifcIDaDAM_HIREwITHOUTdEBUGGING , tArgsOuter , flHIRE_WAIT ) ;
            traceF( tin0P , T("strMimeEncodeF / 3") ) ;
            TN( tArgsOuter , "" ) ; tArgsOuter = T("!maxValue 0 !hireLater ")+tosExe+tArgsInner ;
            _IO_
        {
        countT& osPid = c4Result.c2 ;
        countT& osTid = c4Result.c1 ;
        count4S c4Result ;
    {

    TN( tArgsInner , " " ) ; tArgsInner += T(osfnOut)+tb+T(osfnIn) ;
    }
        tosExe = T(osfnExe) ;
        delF( tin0P , psttm ) ;
        osFileNameC osfnExe( tin0P , third , T(psttm) ) ;
        diskMapFileNameF( tin0P , psttm , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/base64encode/base64encode.exe") ) ; ___( psttm ) ;
        ZE( strokeS* , psttm ) ;
    {
    TN( tosExe  , "" ) ;
    TN( tb    , " " ) ;

    osFileNameC osfnOut( tin0P , third , tLongMappedOut ) ;
    diskMakeDirIfNeededF( tin0P , tLongMappedOut ) ;
    delF( tin0P , psttLongOut ) ;
    }
        delF( tin0P , psttm ) ;
        tLongMappedOut = T(psttm) ;
        diskMapFileNameF( tin0P , psttm , psttLongOut ) ; ___( psttm ) ;
        ZE( strokeS* , psttm ) ;
    {
    TN( tLongMappedOut , "" ) ;
    traceF( tin0P , T("strMimeEncodeF / 4") ) ;

    delF( tin0P , psttLongIn ) ;
    strReplaceF( tin0P , psttLongOut , psttLongIn , T(".in.") , T(".out.") ) ; ___( psttLongOut ) ;
    ZE( strokeS* , psttLongOut ) ;

    osFileNameC osfnIn( tin0P , third , tLongMappedIn ) ;
    diskMakeDirIfNeededF( tin0P , tLongMappedIn ) ;
    }
        delF( tin0P , psttm ) ;
        tLongMappedIn = T(psttm) ;
        diskMapFileNameF( tin0P , psttm , psttLongIn ) ; ___( psttm ) ;
        ZE( strokeS* , psttm ) ;
    {
    TN( tLongMappedIn , "" ) ;

    traceF( tin0P , T("strMimeEncodeF / 5") ) ;
    boxPutUniqueF( tin0P , psttLongIn , T("///ideafarm/tmp/strMimeEncodeF.in") , pbP , cbP ) ; ___( psttLongIn ) ;
    ZE( strokeS* , psttLongIn ) ;
    traceF( tin0P , T("strMimeEncodeF / 6") ) ;

    TN( tb4 , "    " ) ;

    }
        if( POOP ) return 0 ;
        __Z( cbP ) ;
        __Z( pbP ) ;
        __NZ( postP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/countT etherC::strMimeEncodeF( tin0S& tin0P , osTextT*& postP , const byteT* const pbP , const countT cbP )/*1*/

// 
//  RFC 4648
// 

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
