
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    return offo - 1 ;   //DON'T INCLUDE THE TRAILING 0, WHICH I PUT THERE AS A COURTESY BUT WHICH IS NOT PART OF THE ENCODING

    ZE( countT , costo ) ;

    delF( tin0P , postoRaw ) ;

    }
        __( offo - costa ) ;
        postP[ offo ++ ] = 0 ;
        }
            postP[ offo ++ ] = postoRaw[ offi ] ;
            }
                postP[ offo ++ ] = '\n' ;
                postP[ offo ++ ] = '\r' ;
            {
            if( !( offi % 76 ) )
        {
        for( countT offi = 0 ; offi < costoRaw ; offi ++ )
    {
    if( postP )
    ZE( countT , offo ) ;
    newF( tin0P , LF , postP , costa ) ; ___( postP ) ;
    countT costa = costoRaw + 1 + ( cCRLF << 1 ) ;

    countT cCRLF = 1 + costoRaw / 76 ;      // RFC 2045 LINE LENGTH LIMIT

    boxGetF( tin0P , postoRaw , costoRaw , tLongMappedOut ) ; ___( postoRaw ) ;
    ZE( countT   , costoRaw ) ;
    ZE( osTextT* , postoRaw ) ;

    boxZapF( tin0P , tLongMappedIn ) ;
    osProcessF( tin0P , countTC() , countTC() , value , countTC() , T("///ideafarm/precious/domains/com/ideafarm/city/workshop/base64encode/base64encode.exe") , tArgs ) ;
    ZE( countT , value ) ;

    TN( tArgs , "" ) ; tArgs = T(osfnOut)+tb+T(osfnIn) ;
    TN( tb    , " " ) ;

    osFileNameC osfnOut( tin0P , third , tLongMappedOut ) ;
    diskMakeDirIfNeededF( tin0P , tLongMappedOut ) ;
    delF( tin0P , psttLongOut ) ;
    }
        delF( tin0P , psttm ) ;
        tLongMappedOut = T(psttm) ;
        diskMapFileNameF( tin0P , psttm , psttLongOut ) ; ___( psttm ) ;
        ZE( strokeS* , psttm ) ;
    {
    TN( tLongMappedOut , "" ) ;

    strReplaceF( tin0P , psttLongOut , psttLongIn , T(".in.") , T(".out.") ) ; ___( psttLongOut ) ;
    ZE( strokeS* , psttLongOut ) ;

    osFileNameC osfnIn( tin0P , third , tLongMappedIn ) ;
    delF( tin0P , psttLongIn ) ;
    diskMakeDirIfNeededF( tin0P , tLongMappedIn ) ;
    }
        delF( tin0P , psttm ) ;
        tLongMappedIn = T(psttm) ;
        diskMapFileNameF( tin0P , psttm , psttLongIn ) ; ___( psttm ) ;
        ZE( strokeS* , psttm ) ;
    {
    TN( tLongMappedIn , "" ) ;

    boxPutUniqueF( tin0P , psttLongIn , T("///ideafarm/tmp/strMimeEncodeF.in") , pbP , cbP ) ; ___( psttLongIn ) ;
    ZE( strokeS* , psttLongIn ) ;

#endif

    return offo ;

    traceF( tin0P , T("strMimeEncodeF [cbIn,cbOut]:    ")+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    }
        }
            postP[ offo ++ ] = *(osTextT*)tPad ;
            postP[ offo ++ ] = *(osTextT*)tPad ;
            postP[ offo ++ ] = *(osTextT*)TF4(vv2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_BASE64RFC4648|flFORMAT_NObASE,0,64) ;
            postP[ offo ++ ] = *(osTextT*)TF4(vv1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_BASE64RFC4648|flFORMAT_NObASE,0,64) ;

            countT vv2 = vvIn >> 0x0c & 0x3f ;
            countT vv1 = vvIn >> 0x12        ;
        {
        else
        }
            postP[ offo ++ ] = *(osTextT*)tPad ;
            postP[ offo ++ ] = *(osTextT*)TF4(vv3,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_BASE64RFC4648|flFORMAT_NObASE,0,64) ;
            postP[ offo ++ ] = *(osTextT*)TF4(vv2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_BASE64RFC4648|flFORMAT_NObASE,0,64) ;
            postP[ offo ++ ] = *(osTextT*)TF4(vv1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_BASE64RFC4648|flFORMAT_NObASE,0,64) ;

            countT vv3 = vvIn >> 0x06 & 0x3f ;
            countT vv2 = vvIn >> 0x0c & 0x3f ;
            countT vv1 = vvIn >> 0x12        ;
        {
        else if( cBytes == 2 )
        }
            postP[ offo ++ ] = *(osTextT*)TF4(vv4,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_BASE64RFC4648|flFORMAT_NObASE,0,64) ;
            postP[ offo ++ ] = *(osTextT*)TF4(vv3,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_BASE64RFC4648|flFORMAT_NObASE,0,64) ;
            postP[ offo ++ ] = *(osTextT*)TF4(vv2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_BASE64RFC4648|flFORMAT_NObASE,0,64) ;
            postP[ offo ++ ] = *(osTextT*)TF4(vv1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_BASE64RFC4648|flFORMAT_NObASE,0,64) ;

            countT vv4 = vvIn         & 0x3f ;
            countT vv3 = vvIn >> 0x06 & 0x3f ;
            countT vv2 = vvIn >> 0x0c & 0x3f ;
            countT vv1 = vvIn >> 0x12        ;
        {
        if( cBytes >= 3 )

        }
            if( cBytes > 2 ) pbIn[ 0 ] = pbP[ offi + 2 ] ;
            if( cBytes > 1 ) pbIn[ 1 ] = pbP[ offi + 1 ] ;
                             pbIn[ 2 ] = pbP[ offi     ] ;
            byteT* pbIn = (byteT*)&vvIn ;
        {
        ZE( countT , vvIn ) ;

        countT cBytes = cbP - offi ;
    {
    for( countT offi = 0 ; offi < cbP ; offi += 3 )
    traceF( tin0P , T("strMimeEncodeF [cbIn]:    ")+TF2(cbP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    TN( tPad , "=" ) ;
    TN( tb4  , "    " ) ;
    ZE( countT , offo ) ;

    memSetF( tin0P , postP , cba ) ;
    newF( tin0P , LF , postP , cba ) ; ___( postP ) ;     // MORE THAN NEEDED ; THE "3 +" IS TO ENSURE SPACE FOR TRAILING NULL AND OO PAD CHARS WHEN INPUT IS A SINGLE BYTE
    countT cba =  3 + 2 * cbP ;

#if defined( NEVERdEFINED )
// KEEP THIS DOODLE CODE AS PSEUDOCODE FOR WHAT I DO; IT WORKS BUT IS EXTREMELY SLOW

    }
        if( POOP ) return 0 ;
        __Z( cbP ) ;
        __Z( pbP ) ;
        __NZ( postP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
{
/*1*/countT etherC::strMimeEncodeF( tin0S& tin0P , osTextT*& postP , const byteT* const pbP , const countT cbP )/*1*/

// 
//  RFC 4648
// 

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
