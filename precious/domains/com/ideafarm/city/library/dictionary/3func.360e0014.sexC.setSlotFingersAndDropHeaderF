
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

}
    return pbDropNew ;

    }
        else putNegAM( pcSlot[ bSeparator ] , FINGERnEG_dropHeaderInitialize ) ;
        }
            }
                BLAMMO ;
                //((tin9S&)tinBaseP).pc Utility[ 0 ] = was ;
            {
            if( was != pMyNote->dropHeaderCopy )
            countT was = setIfEqualsAM( pcSlot[ bSeparator ] , getNegAM( FINGERnEG_dropHeaderInitialize ) , pMyNote->dropHeaderCopy ) ;        // DROP HEADER VALUE.  IF I AM CALLED BY poolC THEN VALUE WILL CONTAIN idApt, WHICH WILL BE USED TO IDENTIFY *this SO THAT THE DROP CAN BE DELETED WITHOUT SEARCHING FOR THE CORRECT sexC INSTANCE

            dropNoteS* pMyNote = pzMetaNote + offSlotP ;

        {
        if( pzMetaHead->cbDropHeader && pzMetaNote )
        boolT bSeparator = pzMetaHead->cbDropSeparator == sizeof( countT ) ;

        //}
        //    BLAMMOiD( pcSlot[ 1 ] ) ;
        //{
        //else if( getNegAM( pcSlot[ 1 ] ) != FINGERnEG_dropHeaderInitialize )
        //     if( !bNewP                                                    ) putNegAM( pcSlot[ 1 ] , FINGERnEG_dropHeaderInitialize ) ;

        }
            BLAMMOiD( pcSlotEnd[ 0 ] ) ;                                // THE NEXT SEPARATOR IS INVALID AND MY CALLER IS THE PRIME SUSPECT
            //((tin9S&)tinBaseP).pc Utility[ 1 ] = pcSlotEnd[ 1 ] ;
            //((tin9S&)tinBaseP).pc Utility[ 0 ] = pcSlotEnd[ 0 ] ;
        {
        if( pzMetaHead->cbDropSeparator == sizeof( countT ) && offSlotP < offSlotPsUseableEnd - 1 && getNegAM( pcSlotEnd[ 0 ] ) != FINGERnEG_dropSeparator )       // NOT CHECKED IF I USE LATH SLOT

        const countT offSlotPsUseableEnd   = cSlots - pzMetaHead->cSlotsAvoidHi ;
        const countT offSlotPsUseableBegin =          pzMetaHead->cSlotsAvoidLo ;
        const countT cSlots                =     1 << pzMetaHead->expSlots      ;
    {
    else
    }
        }
            }
                BLAMMO ;
                //((tin9S&)tinBaseP).pc Utility[ 0 ] = was ;
            {
            if( getNegAM( was ) != FINGERnEG_dropHeaderInitialize )

            countT was = setIfEqualsAM( ((countT*)pbDropNew)[ - 1 ] , offSlotP , getNegAM( FINGERnEG_dropHeaderInitialize ) ) ;
        {
        if( pzMetaHead->cbDropHeader )

        // IOW, THE NEXT LINE CAN SET dropHeader TO ANY SUFFICIENTLY SMALL VALUE.  (A VALUE THAT IS TOO LARGE WILL CAUSE SHIFT LEFT TO FAIL IN slotsC::newF poolC:newF)
        // 20210130@1202: offSlot IS NOT USED TO DELETE THE DROP OR FOR ANY OTHER PURPOSE.  IT CAN BE ELIMINATED FROM dropHeader IN ORDER TO SIMPLIFY LAYOUT, ADD A CHECKSUM, OR ADD OTHER INFORMATION
        // DROP HEADER VALUE.  IF I AM CALLED BY poolC THEN VALUE WILL CONTAIN idApt, WHICH WILL BE USED TO IDENTIFY *this SO THAT THE DROP CAN BE DELETED WITHOUT SEARCHING FOR THE CORRECT sexC INSTANCE

        pbDropNew = pbData + cbGrossP * offSlotP + ( pzMetaHead->cbDropSeparator + pzMetaHead->cbDropHeader ) ;
    {
    if( bNewP )
    ZE( byteT* , pbDropNew ) ;

    }
        BLAMMOiD( pcSlot[ 0 ] ) ;
        //((tin9S&)tinBaseP).pc Utility[ 1 ] = pcSlot[ 1 ] ;
        //((tin9S&)tinBaseP).pc Utility[ 0 ] = pcSlot[ 0 ] ;
    {
    if( pzMetaHead->cbDropSeparator == sizeof( countT ) && getNegAM( pcSlot[ 0 ] ) != FINGERnEG_dropSeparator )

    countT* pcSlotEnd = (countT*)( pbData + ( offSlotP + 1 ) * cbGrossP ) ;
    countT* pcSlot    = (countT*)pbSlotP ;
{
/*1*/byteT* sexC::setSlotFingersAndDropHeaderF( tin0S& tinBaseP , byteT* pbSlotP , countT offSlotP , countT cbGrossP , boolT bNewP )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
