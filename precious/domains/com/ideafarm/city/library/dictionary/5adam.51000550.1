
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        ++ s ; ether.osSleepF( tin0P , bFail ? TOCK * 0x10 : TICK ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    {
    if( !ether )
    
    etThread.delF( tin0P , pstt1m ) ;
    }
        }
            }
                break ;
                bFail = 1 ;
                etThread.strokeF( tin0P , T(" failed\r\n") ) ;
            {
            else
            }
                ((tin9S&)tin0P).pEtScratch->boxZapF( tin0P , psttc1 , 1 ) ;
                etThread.strokeF( tin0P , T(" aok\r\n") ) ;
            {
            if( !POOP )

            etThread.delF( tin0P , postm ) ;
            if( postm && costm ) ((tin9S&)tin0P).pEtScratch->boxPutF( tin0P , tHead , postm , costm , 1 ) ;
            ((tin9S&)tin0P).pEtScratch->boxGetShadowF( tin0P , postm , costm , psttc1 , 1 ) ; ___( postm ) ;
            ZE( countT   , costm ) ;
            ZE( osTextT* , postm ) ;
        
            SCOOPS
        {
        IFsCRATCH

        etThread.strokeF( tin0P , psttc1 ) ;
    {
    FORsTRINGSiN1( pstt1m )
    ZE( boolT , bFail ) ;
    etThread.boxMenuF( tin0P , soul , tDepository+T("*") , 0 , 1 ) ; ___( pstt1m ) ;
    ZE( strokeS* , pstt1m ) ;
{
while( !ether && !etThread )
TN( tcr , "\r\n" ) ;
handleC hDirChange( tin0P , TAG( TAGiDnULL ) ) ;
TN( tHead , "" ) ; tHead = T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/" ifcEMAIL_OLDfROM "") ;
    
etThread.diskMakeDirIfNeededF( tin0P , tDepository ) ;
TN( tDepository , "///ideafarm/ephemeral/domains/com/ideafarm/data/" ) ;

etThread.osThreadF( TaRG1( tmWatchCeeF ) ) ;

TODO

DONE( tmWatchCeeF )

}
    }
        ++ s ; ether.osSleepF( tin0P , bFail ? TOCK * 0x10 : TICK ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    {
    if( !ether )
    
    etThread.delF( tin0P , pstt1m ) ;
    }
        }
            }
                break ;
                bFail = 1 ;
                etThread.strokeF( tin0P , T(" failed\r\n") ) ;
            {
            else
            }
                ((tin9S&)tin0P).pEtScratch->boxZapF( tin0P , psttc1 , 1 ) ;
                etThread.strokeF( tin0P , T(" aok\r\n") ) ;
            {
            if( !POOP )

            etThread.delF( tin0P , postm ) ;
            if( postm ) ((tin9S&)tin0P).pEtScratch->boxPutF( tin0P , tHead , postm , costm , 1 ) ;
            ((tin9S&)tin0P).pEtScratch->boxGetShadowF( tin0P , postm , costm , psttc1 , 1 ) ; ___( postm ) ;
            ZE( countT   , costm ) ;
            ZE( osTextT* , postm ) ;
        
            SCOOPS
        {
        IFsCRATCH

        etThread.strokeF( tin0P , psttc1 ) ;
    {
    FORsTRINGSiN1( pstt1m )
    ZE( boolT , bFail ) ;

    }
        ++ s ; ether.osSleepF( tin0P , TOCK ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    {
    if( cFiles ) //TO GIVE THE WRITER TIME TO CLOSE THE FILE (CURRENT TAGGING PROTOCOL IS FLAWED AND CAN CAUSE ME TO DELETE A FILE IF I SEE THE TAG JUST BEFORE IT IS REMOVED)

    countT cFiles = etThread.boxMenuF( tin0P , soul , tDepository+T("ideafarm.rpt.*") , 0 , 1 ) ; ___( pstt1m ) ;
    ZE( strokeS* , pstt1m ) ;
{
while( !ether && !etThread )
TN( tcr , "\r\n" ) ;
handleC hDirChange( tin0P , TAG( TAGiDnULL ) ) ;
TN( tHead , "" ) ; tHead = T("ideafarm.com//smtp/" ifcEMAIL_OLDfROM "/" ifcEMAIL_OLDfROM "") ;
    
TN( tDepository , "///d/" ) ;

TASK( tmWatchCeeF )

/*1*/WAKEhIDE( "ifcIDaDAM_DATA.data" )/*1*/
/**/
*/
/*
//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

