
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.loafIF( tinBaseP ) ;

while( cTries -- ) etThread.osThreadF( tinBaseP , countTC() , tmClientF , 0 , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&stIdPort ) ;
cTries = CcLIENTS ;

}
    }
        ++ s ; etThread.osSleepF( tinBaseP , TUCK * 0x40 ) ;
    {
    while( stIdPort < CsERVERS )
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
{

while( cTries -- ) etThread.osThreadF( tinBaseP , countTC() , tmAcceptorF , 0 , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&stIdPort ) ;
countT cTries = CsERVERS ;

stackC stIdPort( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmAcceptorF )
}
    DEL( pStBang2 ) ;
    DEL( pStBang1 ) ;
    DEL( pStBang0 ) ;
    }
        }
            ++ s ; etThread.osSleepF( tinBaseP , TUCK * 0x40 ) ;
        {
        while( ((tinFullS&)tinBaseP).cKidThreads )
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    {

    if( pStBang2 ) *pStBang2 << new( 0 , tinBaseP , LF ) soulC( tinBaseP , TAG( TAGiDnULL ) ) ;
    if( pStBang1 ) *pStBang1 << new( 0 , tinBaseP , LF ) soulC( tinBaseP , TAG( TAGiDnULL ) ) ;
    if( pStBang0 ) *pStBang0 << new( 0 , tinBaseP , LF ) soulC( tinBaseP , TAG( TAGiDnULL ) ) ;

    }
        else                { DEL( pso ) ; }
        if( !ether && pso ) etThread.osThreadF( tinBaseP , countTC() , tmServerF , 0 , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&stIdPort , (countT)pso , idPort , ideMe , (countT)pStBang0 , (countT)pStBang1 , (countT)pStBang2 ) ;
        sListen.acceptF( tinBaseP , pso , idPortPeer , nnPeer , countTC() ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        ZE( socketC* , pso ) ;
    {
    while( !etThread && !ether )

    if( idPortExplode2 && pStBang2 ) etThread.osThreadF( tinBaseP , countTC() , tmBangClientF , 0 , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , idPortExplode2 , (countT)pStBang2 ) ;
    if( idPortExplode1 && pStBang1 ) etThread.osThreadF( tinBaseP , countTC() , tmBangClientF , 0 , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , idPortExplode1 , (countT)pStBang1 ) ;
    if( idPortImplode  && pStBang0 ) etThread.osThreadF( tinBaseP , countTC() , tmBangClientF , 0 , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , idPortImplode  , (countT)pStBang0 ) ;
    stackC* pStBang2 = idPortExplode2 ? new( 0 , tinBaseP , LF ) stackC( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) : 0 ;
    stackC* pStBang1 = idPortExplode1 ? new( 0 , tinBaseP , LF ) stackC( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) : 0 ;
    stackC* pStBang0 = idPortImplode  ? new( 0 , tinBaseP , LF ) stackC( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO | flSTACKc_GIVEsIGNnEWpLATE , ifcSTACKtYPE_PTR_soulC ) : 0 ;

    stIdPort.ungrabF( tinBaseP ) ;
    countT idPortExplode2 = stIdPort >= ideMe * 2 + 1 ? stIdPort[ ideMe * 2 + 1 ] : 0 ;
    countT idPortExplode1 = stIdPort >= ideMe * 2     ? stIdPort[ ideMe * 2     ] : 0 ;
    countT idPortImplode  = ideMe != 1                ? stIdPort[ ideMe / 2     ] : 0 ;
    countT ideMe = stIdPort( idPort ) ;
    countT cRelays = stIdPort ;
    stIdPort.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

    }
        }
            ++ s ; etThread.osSleepF( tinBaseP , TUCK * 0x40 ) ;
        {
        while( stIdPort < CsERVERS )
        sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    {

    stIdPort.sinkF( tinBaseP , countTC() , idPort , flSTACKsINK_UNIQUE ) ;

    sListen.listenF( tinBaseP ) ;
    const countT idPort = sListen.bindF( tinBaseP ) ;
    socketC sListen( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;

    stackC& stIdPort = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmAcceptorF )

DONE( tmServerF )
}
    }
        }
            CONoUTrAW( TF1(ideMe)+T(": received ")+TF1(idSerial)+T(" from ")+T(nnHim)+tcr ) ;
            //LOCAL PROCESSING GOES HERE

            }
                }
                    }
                        *pStBang2 << psBang ;
                        *psBang = sIn ;
                    {
                    if( psBang )
                    soulC* psBang = new( 0 , tinBaseP , LF ) soulC( tinBaseP , TAG( TAGiDnULL ) ) ; ___( psBang ) ;
                {
                if( pStBang2 )
                
                }
                    }
                        *pStBang1 << psBang ;
                        *psBang = sIn ;
                    {
                    if( psBang )
                    soulC* psBang = new( 0 , tinBaseP , LF ) soulC( tinBaseP , TAG( TAGiDnULL ) ) ; ___( psBang ) ;
                {
                if( pStBang1 )
            {
            else
            }
                }
                    }
                        *pStBang0 << psBang ;
                        *psBang = sIn ;
                    {
                    if( psBang )
                    soulC* psBang = new( 0 , tinBaseP , LF ) soulC( tinBaseP , TAG( TAGiDnULL ) ) ; ___( psBang ) ;
                {
                if( pStBang0 )
            {
            if( bImplosion )
        {
        else
        }
            sock.writeF( tinBaseP , sIn ) ;
            sock.connectF( tinBaseP , stIdPort[ 1 ] ) ;
            socketC sock( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
            bIncoming = 0 ;
            CONoUTrAW( TF1(ideMe)+T(": forwarding incoming ")+TF1(idSerial)+T(" from ")+T(nnHim)+tcr ) ;
        {
        if( bIncoming && !bImplosion )
        TN( tcr , "\r\n" ) ;
    
        osTextT* postIn      = sIn.pbFieldF( tinBaseP , countTC() , countTC() , countTC() , 0xa ) ;
        countT   idCmd       = sIn.cFieldF( tinBaseP , 9 ) ;
        countT&  idBang      = sIn.cFieldF( tinBaseP , 8 ) ;
        countT   bImplosion  = sIn.cFieldF( tinBaseP , 7 ) ;
        countT&  bIncoming   = sIn.cFieldF( tinBaseP , 6 ) ;
        countT   idSerial    = sIn.cFieldF( tinBaseP , 5 ) ;
        countT   idPortReply = sIn.cFieldF( tinBaseP , 4 ) ;
        nicNameC nnHim       = sIn.nicNameFieldF( tinBaseP , 3 ) ;
        countT   idFormat    = sIn.cFieldF( tinBaseP , 2 ) ;
        countT   fingerprint = sIn.cFieldF( tinBaseP , 1 ) ;

        }
            break ;
            DEL( pso ) ;
            *((tinFullS&)tinBaseP).zEtScratch = 0 ;
        {
        if( *((tinFullS&)tinBaseP).zEtScratch )
        pso->readF( tinBaseP , sIn ) ;
        soulC sIn( tinBaseP , TAG( TAGiDnULL ) ) ;
    {
    while( !etThread && !ether )

    pso->etherF( tinBaseP , *((tinFullS&)tinBaseP).zEtScratch ) ;

    stackC*  pStBang2 =  (stackC*)pTaskP->c7 ;
    stackC*  pStBang1 =  (stackC*)pTaskP->c6 ;
    stackC*  pStBang0 =  (stackC*)pTaskP->c5 ;
    countT   ideMe    =           pTaskP->c4 ;
    countT   idPort   =           pTaskP->c3 ;
    socketC* pso      = (socketC*)pTaskP->c2 ;
    stackC&  stIdPort = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmServerF )

DONE( tmBangClientF )
}
    }
        }
            DEL( ps ) ;
            }
                sock.writeF( tinBaseP , *ps ) ;
                ps->cFieldF( tinBaseP , 8 ) ++ ; //idBang
            {
            if( !ether && *ps >= 8 )
            stBang >> ps ;
            ZE( soulC* , ps ) ;
        {
        while( stBang )
        stBang.waitF( tinBaseP ) ;
    {
    while( !ether )

    sock.connectF( tinBaseP , idPortExplode ) ;
    socketC sock( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;

    stackC& stBang        = *(stackC*)pTaskP->c2 ;
    countT  idPortExplode =           pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmBangClientF )

DONE( tmClientF )
}
    sock.writeF( tinBaseP , sOut ) ;
    
    sock.connectF( tinBaseP , stIdPort.randomF( tinBaseP ) ) ;
    socketC sock( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
    
    sOut << ostoOut ;
    sOut << (countT)IDcMDwRITE ;
    sOut << (countT)0 ; //idBang
    sOut << (countT)0 ; //bImplosion
    sOut << (countT)1 ; //bIncoming
    sOut << idSerial ;
    sOut << (countT)0 ; //idPortReply (OPTIONAL)
    sOut << nnMe ;
    sOut << (countT)1 ; //idFormat
    sOut << (countT)FINGERnEG ;
    soulC sOut( tinBaseP , TAG( TAGiDnULL ) ) ;

    OStEXTV( ostoOut , "This is the day that the Lord has made.  Let us rejoice!\r\n" )
    
    countT idSerial = 1 + incv02AM( host.idSerialLath ) ;
    homeS& host = homeS::homeIF() ;
    nicNameC nnMe = socketC::nicNameIF( tinBaseP , etThread ) ;

    stackC& stIdPort = *(stackC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmClientF )

#define IDcMDwRITE        0x2
#define IDcMDcONTROLHELLO 0x1
#define FINGERnEG 0x87654321
#define CcLIENTS 0x1
#define CsERVERS 0xf

/*1*/WAKEhIDE( "doodle.2.power.explosion.persistent.connections" )/*1*/
/**/
*/
objective: explore distributed blob storage
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

