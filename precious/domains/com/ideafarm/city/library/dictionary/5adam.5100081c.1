
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("ok") ) ;

}
    DEL( pJotUnsortedShort ) ;
    }
        }
            etThread.traceF( tinBaseP , T("!exception: walk failed") ) ;
            POOPRqUIET
        {
        if( POOP )

        ((tinFullS&)tinBaseP).pEtScratch->diskWalkF( tinBaseP , cDirs , cFiles , tPathToWalk  , bQuit , flDISKwALK_null , walkCBF , pcArg , 0 , 0 ) ;
        SCOOPS
        _IO_
    {
    IFsCRATCH

    countT pcArg[] = { (countT)&cSetsDone , (countT)(strokeS*)tArchives , (countT)(strokeS*)tYearTest , (countT)&bYear , (countT)&bYearDo , (countT)&tSlash , (countT)&tn , (countT)&tb4 , (countT)&tDot , (countT)&tData , (countT)&tMeta , (countT)&tPath , (countT)&tHeyIdeaFarm , (countT)&t9 , (countT)&ta , (countT)&t2 , (countT)&pJotUnsortedShort , (countT)&cYearKidDirectories , (countT)&bArmDoNames , (countT)&tDevice , (countT)&tYear , (countT)&tMigrateSortedPrefix , (countT)&tMigrateUnsortedPrefix , (countT)&tHeyIdeaFarmDot , (countT)&tDotHeyDotControlDot , (countT)&tHeyIdeaFarmDotADot , (countT)&tHeyIdeaFarmDot9Dot , (countT)&tDotMetaDotDatafiletimes , (countT)&tDotFsetDotZip , (countT)&tDot20 , (countT)&tUscore20 } ;

    TN( tUscore20 , "_20" ) ;
    TN( tDot20 , ".20" ) ;
    TN( tDotFsetDotZip , ".fset.zip" ) ;
    TN( tDotMetaDotDatafiletimes , ".meta.datafiletimes" ) ;
    TN( tHeyIdeaFarmDot9Dot , "!ideafarm.9." ) ;
    TN( tHeyIdeaFarmDotADot , "!ideafarm.a." ) ;
    TN( tDotHeyDotControlDot , ".!.control." ) ;
    TN( tHeyIdeaFarmDot , "!ideafarm." ) ;
    TN( tMigrateUnsortedPrefix , "migrate.unsorted.short.filenames." ) ;
    TN( tMigrateSortedPrefix   , "migrate.sorted.short.filenames."   ) ;
    TN( tYear , "" ) ;
    ZE( boolT , bArmDoNames ) ;
    ZE( countT , cYearKidDirectories ) ;
    ZE( jotC* , pJotUnsortedShort ) ;
    TN( t2 , "2" ) ;
    TN( ta , "a" ) ;
    TN( t9 , "9" ) ;
    TN( tHeyIdeaFarm , "!ideafarm" ) ;
    TN( tPath , "" ) ;
    TN( tMeta , "meta" ) ;
    TN( tData , "data" ) ;
    TN( tDot , "." ) ;
    TN( tb4 , "    " ) ;
    TN( tn , "" ) ;
    TN( tSlash , "/" ) ;
    ZE( boolT , bYearDo ) ;
    ZE( boolT , bYear ) ;
    TN( tYearTest , "" ) ;  // E.G. "2011" OR "2012,2013,2014"
    //TN( tYearTest , "2018,2019,2020,2021,2022,2023,2099" ) ;  // E.G. "2011" OR "2012,2013,2014"
    TN( tArchives , "ideafarm.archives" ) ;
    ZE( countT , cSetsDone ) ;
    ZE( boolT , bQuit ) ;

    etThread.traceF( tinBaseP , T("[device]:    ")+tDevice ) ;
    }
        etThread.delF( tinBaseP , psttw ) ;
        tDevice = T(psttw) ;
        etThread.strWordF( tinBaseP , psttw , tPathToWalk , sttq , S1C('/') , - 4 ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;
        ZE( strokeS* , psttw ) ;
        
        _IO_
    {
    TN( tDevice , "" ) ;

    etThread.traceF( tinBaseP , T("i will walk [path]:    ")+tPathToWalk ) ;
    TN( tPathToWalk , psttPathP ) ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs  ) ;
    _IO_
{
else
}
    }
        ++ s ; ether.osSleepF( tinBaseP , TOCK << 2 ) ;

        }
            etThread.delF( tinBaseP , pstt1d ) ;
            }
                }
                    break ;
                    }
                        etThread.delF( tinBaseP , pstta ) ;
                        etThread.ifcHireF( tinBaseP , T("ifcIDaDAM_SCRATCH0f") , 0 , tArgKeyName+T(" ")+T(pstta) , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                        etThread.traceF( tinBaseP , T("hiring [psttArchive]:    ")+T(pstta) ) ;
                        stArchiveDo >> pstta ;
                        ZE( strokeS* , pstta ) ;
                    {
                    while( stArchiveDo )
                {
                if( !bFail && !ether )

                }
                    }
                        }
                            stArchiveDo << pstta ;
                            etThread.strMakeF( tinBaseP , LF , pstta , tArchiveTry ) ; ___( pstta ) ;
                            ZE( strokeS* , pstta ) ;
                        {
                        else if( cFound )
                        }
                            break ;
                            tDeviceFailed = T(psttc1) ;
                            etThread.traceF( tinBaseP , T("!exception: device failed; please power cycle the device: ")+T(psttc1) ) ;
                        {
                        if( bFail )

                        etThread.delF( tinBaseP , pstt1f ) ;
                        }
                            etThread.traceF( tinBaseP , T("    [found]:    ")+T(psttc2) ) ;
                        {
                        FORsTRINGSiN2( pstt1f )
                        etThread.traceF( tinBaseP , T("[cFound,tArchiveTry]:    ")+TF2(cFound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tArchiveTry ) ;
                        }
                            }
                                bFail = 1 ;
                                POOPRqUIET
                            {
                            if( POOP )
                            cFound = ((tinFullS&)tinBaseP).pEtScratch->diskFindFileOrDirF( tinBaseP , pstt1f , tArchiveTry , 0 , flDISKfIND_null , 0 , 0 , 0 , 1 , 0 ) ;
                            SCOOPS
                        {
                        ZE( countT , cFound ) ;
                        ZE( strokeS* , pstt1f ) ;
                        TN( tArchiveTry , "" ) ; tArchiveTry = T(psttc1)+T("ideafarm.archives/wo.ideafarm/") ;
                    {
                    if( !bSkip )

                    if( !tDeviceFailed.csF( tinBaseP ) || !etThread.strCompareF( tinBaseP , psttc1 , tDeviceFailed ) ) bSkip = 0 ;

                    //if( etThread.strCompareF( tinBaseP , psttc1 , T("///d/ideafarm.home.101/devices/ssd4.arc.20240214/") ) ) continue ; //TO FIND A BUG
                    //etThread.traceF( tinBaseP , psttc1 ) ;
                {
                FORsTRINGSiN1( pstt1d )
                boolT bSkip = 1 ;
            {
            else
            }
                etThread.traceF( tinBaseP , T("!exception: could not obtain device list") ) ;
            {
            if( bFail )
            }
                }
                    bFail = 1 ;
                    POOPRqUIET
                {
                if( POOP )
                ((tinFullS&)tinBaseP).pEtScratch->diskFindFileOrDirF( tinBaseP , pstt1d , tLongDevices , 0 , flDISKfIND_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1d ) ;
                SCOOPS
            {
            ZE( boolT , bFail ) ;
            ZE( strokeS* , pstt1d ) ;
            TN( tLongDevices , "///d/ideafarm.home.101/devices/" ) ;
            stackC stArchiveDo( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
            _IO_
        {
        IFsCRATCH
        _IO_
    {
    while( !ether )
    TN( tDeviceFailed , "" ) ;
    sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
    _IO_
{
if( !psttPathP )

}
    }
        }
            break ;
            etThread.strMakeF( tinBaseP , LF , psttPathP , psttc1 ) ; ___( psttPathP ) ;
            bArmed = 0 ;
        {
        else if( bArmed )
        if( !etThread.strCompareF( tinBaseP , psttc1 , tArgKeyName ) ) bArmed = 1 ;
        etThread.traceF( tinBaseP , T("param: ")+T(psttc1) ) ;
        _IO_
    {
    FORsTRINGSiN1( pstt1Param )
    ZE( boolT , bArmed ) ;
    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tinBaseP ) ;
    _IO_
{
ZE( strokeS* , psttPathP ) ;
TN( tArgKeyName , "!path" ) ;

TODO

}
    return 0 ;

    }
        }
            }
                }
                    if( !( ( idJot & ~NM_HIGH ) % TUCK ) ) etherP.traceF( tinBaseP , T("jotted [idJot,tShort]:    ")+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4P+tShortNew ) ;
                    countT idJot = pJotUnsortedShortP->writeF( tinBaseP , tShortNew , tShortNew.csF( tinBaseP ) + 1 , 0 , 0 ) ;
                    _IO_
                {
                if( tShortNew.csF( tinBaseP ) )

                }
                    etherP.delF( tinBaseP , pstt1w ) ;
                    }
                        }
                            tShortNew = tnP ;
                            etherP.delF( tinBaseP , psttShortNew ) ;
                            if( cHits ) etherP.diskMoveFileOrDirF( tinBaseP , tPathP+T(psttShortNew) , tPathP+tShort , 0 ) ;
                            countT cHits = etherP.strReplaceF( tinBaseP , psttShortNew , tShort , tHeyIdeaFarmDot9DotP , tHeyIdeaFarmDotADotP , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                            ZE( strokeS* , psttShortNew ) ;
                            //CS:CODEsYNC: DUPLICATE CODE: 5101200f 5101200f
                        {
                        if( bFail )

                        }
                            if( bFail ) break ;

                            }
                                }
                                    break ;
                                    bFail = !bData && !bMeta ;
                                    boolT bMeta = !etherP.strCompareF( tinBaseP , psttc1 , tMetaP ) ;
                                    boolT bData = !etherP.strCompareF( tinBaseP , psttc1 , tDataP ) ;
                                {
                                case 0xa :
                                }
                                    break ;
                                    bFail = psttc1->idAdam != 3 ;
                                {
                                case 0x9 :
                                }
                                    break ;
                                    bFail = psttc1->idAdam != 0x20 ;
                                {
                                case 0x8 :
                                }
                                    break ;
                                    bFail = psttc1->idAdam != 0xd ;
                                {
                                case 0x7 :
                                case 0x6 :
                                }
                                    break ;
                                    bFail = psttc1->idAdam != 8 ;
                                {
                                case 0x5 :
                                case 0x4 :
                                }
                                    break ;
                                    bFail = !!etherP.strCompareF( tinBaseP , psttc1 , t2P ) ;
                                {
                                case 0x3 :
                                }
                                    break ;
                                    bFail = etherP.strCompareF( tinBaseP , psttc1 , t9P ) && etherP.strCompareF( tinBaseP , psttc1 , taP ) ;
                                {
                                case 0x2 :
                                }
                                    break ;
                                    bFail = !!etherP.strCompareF( tinBaseP , psttc1 , tHeyIdeaFarmP ) ;
                                {
                                case 0x1 :
                            {
                            switch( ++ idw )
                            //etherP.traceF( tinBaseP , tb4+T(psttc1) ) ;
                            _IO_
                        {
                        FORsTRINGSiN1( pstt1w )
                        ZE( countT , idw ) ;
                        ZE( boolT , bFail ) ;
                        _IO_
                    {
                    else
                    }
                        tShortNew = tnP ;
                        etherP.delF( tinBaseP , psttShortNew ) ;
                        if( cHits ) etherP.diskMoveFileOrDirF( tinBaseP , tPathP+T(psttShortNew) , tPathP+tShort , 0 ) ;
                        countT cHits = etherP.strReplaceF( tinBaseP , psttShortNew , tShort , tHeyIdeaFarmDot9DotP , tHeyIdeaFarmDotADotP , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                        ZE( strokeS* , psttShortNew ) ;
                        _IO_
                    {
                    if( cWords < 0xb )
                    //etherP.traceF( tinBaseP , T("cWords:    ")+TF2(cWords,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT cWords = etherP.strWordsF( tinBaseP , pstt1w , tShortNew , sttq , tDotP , flSTRwORDS_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1w ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , pstt1w ) ;

                    // b    jpg
                    // a    data
                    // 9    001
                    // 8    2a24e441984f7650ef8982bc85155e1c
                    // 7    20170131@0012
                    // 6    00000000@0000
                    // 5    00000001
                    // 4    00000000
                    // 3    2
                    // 2    9
                    // 1   !ideafarm
                    //
                    // !ideafarm.9.2.00000000.00000001.00000000@0000.20170131@0012.2a24e441984f7650ef8982bc85155e1c.001.data.jpg
                    // EXPECTED INPUT, PARSED TO WORDS

                    _IO_
                {
                if( tShortNew.csF( tinBaseP ) )

                }
                    }
                        }
                            }
                                tShortNew = tnP ;
                                etherP.traceF( tinBaseP , T("!exception: could not move to eliminate underscore ; file will be ignored") ) ;
                                POOPRqUIET
                            {
                            if( POOP )

                            THREADmODE2rESTORE
                            ((tinFullS&)tinBaseP).pEtScratch->diskMoveFileOrDirF( tinBaseP , tLongNew , tPathP+tShort , 1 ) ;
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                            SCOOPS
                            _IO_
                        {
                        IFsCRATCH

                        etherP.traceF( tinBaseP , T("to eliminate underscore, moving from:    ")+tPathP+tShort ) ;
                        etherP.traceF( tinBaseP , T("to eliminate underscore, moving to  :    ")+tLongNew ) ;
                    {
                    if( cHits )

                    TN( tLongNew , "" ) ; tLongNew = tPathP+tShortNew ;
                    etherP.delF( tinBaseP , psttShortNew ) ;
                    tShortNew = T(psttShortNew) ;
                    countT cHits = etherP.strReplaceF( tinBaseP , psttShortNew , tShort , tUscore20P , tDot20P , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                    ZE( strokeS* , psttShortNew ) ;
                    _IO_
                {
                TN( tShortNew , "" ) ;
            {
            else if( !etherP.strIdF( tinBaseP , tDotFsetDotZipP , tShort ) )
            }
                etherP.traceF( tinBaseP , T("!exception: zapped  unexpected file [tLong]:    ")+tPathP+tShort ) ;
                etherP.boxZapF( tinBaseP , tPathP+tShort ) ;
                etherP.traceF( tinBaseP , T("!exception: zapping unexpected file [tLong]:    ")+tPathP+tShort ) ;
                _IO_
            {
            else if( etherP.strIdF( tinBaseP , tDotMetaDotDatafiletimesP , tShort ) )
            }
                etherP.delF( tinBaseP , psttShortNew ) ;
                if( cHits ) etherP.diskMoveFileOrDirF( tinBaseP , tPath+T(psttShortNew) , tPath+tShort , 0 ) ;
                countT cHits = etherP.strReplaceF( tinBaseP , psttShortNew , tShort , tHeyIdeaFarmDot9DotP , tHeyIdeaFarmDotADotP , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                ZE( strokeS* , psttShortNew ) ;
                //CS:CODEsYNC: DUPLICATE CODE: 5101200f 5101200f
                _IO_
            {
            else if( etherP.strIdF( tinBaseP , tDotHeyDotControlDotP , tShort ) )
            }
                _IO_
                etherP.traceF( tinBaseP , T("!exception: file ignored (a particular file to ignore; it is a duplicate of another data file in the same set) [tLong]:    ")+tPathP+tShort ) ;
            {
            else if( etherP.strIdF( tinBaseP , T(".data.tripod.speech.") , tShort ) )
            }
                _IO_
                etherP.traceF( tinBaseP , T("!exception: file ignored (name does not begin with !ideafarm.) [tLong]:    ")+tPathP+tShort ) ;
            {
            if( 1 != etherP.strIdF( tinBaseP , tHeyIdeaFarmDotP , tShort ) )

            else { __NZ( etherP.strCompareF( tinBaseP , tPath , tPathP ) ) ; }
            }
                //etherP.traceF( tinBaseP , T("walkCBF set [tPathP]:    ")+tPathP ) ;
                tPathP = tPath ;
                _IO_
            {
            if( !tPathP.csF( tinBaseP ) )

            //etherP.traceF( tinBaseP , T("inspecting file [tShort]:    ")+tShort ) ;
            }
                etherP.delF( tinBaseP , psttShort ) ;
                etherP.delF( tinBaseP , psttPath ) ;
                tShort = T(psttShort) ;
                tPath  = T(psttPath) ;
                etherP.strBisectF( tinBaseP , psttPath , psttShort , tName , tSlashP , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttPath ) ;
                _IO_
            {
            TN( tShort , "" ) ;
            TN( tPath  , "" ) ;

            //etherP.traceF( tinBaseP , T("walkCBF [tFile]:    ")+tName ) ;
            TN( tName , ifName ) ;
            ifFileNameC ifName( tinBaseP , *((tinFullS&)tinBaseP).pEther , postNameP ) ;
            _IO_
        {
        else if( bYearP && bYearDoP /*&& !cSetsDoneP*/ )
        }
            }
                }
                    pJotUnsortedShortP = new( 0 , tinBaseP , LF ) jotC( tinBaseP , tPart2 , flJOTc_PRIVATE | flJOTc_DELETE | flJOTc_WRITE | flJOTc_PURGEoNcT | flJOTc_PATCHbOOKSfLAGStOpURGEoNdT , 1 , CBdATAbOOKsHORTfILEnAMES , CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ) ; ___( pJotUnsortedShortP ) ;
                    TN( tPart2  , "" ) ; tPart2  = tMigrateUnsortedPrefixP+tDeviceP+tDotP+tYearP ;

                    bYearDoP = 1 ;
                    etherP.traceF( tinBaseP , T("year to do:    ")+tYearP ) ;
                {
                if( !psttYearTestP->idAdam || etherP.strIdF( tinBaseP , tYearP , psttYearTestP , 1 ) )

                etherP.traceF( tinBaseP , T("year      :    ")+tYearP ) ;
                }
                    etherP.delF( tinBaseP , psttYear ) ;
                    tYearP  = T(psttYear) ;

                    etherP.delF( tinBaseP , psttnu ) ;
                    etherP.delF( tinBaseP , psttYearSlash ) ;
                    etherP.strBisectF( tinBaseP , psttYear , psttnu , psttYearSlash , tSlashP , - 1 , flSTRbISECT_null ) ; ___( psttYear ) ; ___( psttnu ) ;
                    ZE( strokeS* , psttYear ) ;

                    etherP.delF( tinBaseP , psttnu ) ;
                    etherP.strBisectF( tinBaseP , psttnu , psttYearSlash , tArchivesSlashArchiveSlashYearSlash , tSlashP , - 2 , flSTRbISECT_null ) ; ___( psttYearSlash ) ; ___( psttnu ) ;
                    ZE( strokeS* , psttYearSlash ) ;
                    ZE( strokeS* , psttnu ) ;
                {

                bYearP = 1 ;
                //etherP.traceF( tinBaseP , T("year:    ")+tArchivesSlashArchiveSlashYearSlash ) ;
                _IO_
            {
            else
            }
                bYearDoP = bYearP = 0 ;
                if( bYearDoP || cYearKidDirectoriesP ) cYearKidDirectoriesP ++ ;
                _IO_
            {
            if( 1 != etherP.strIdF( tinBaseP , psttzArchivesP , tArchivesSlashArchiveSlashYearSlash , 1 ) )

            //etherP.traceF( tinBaseP , T("directory [tArchivesSlashArchiveSlashYearSlash]:    ")+tArchivesSlashArchiveSlashYearSlash ) ;
            }
                etherP.delF( tinBaseP , psttnu ) ;
                etherP.delF( tinBaseP , psttArchivesSlashArchiveSlashYearSlash ) ;

                tArchivesSlashArchiveSlashYearSlash  = T(psttArchivesSlashArchiveSlashYearSlash) ;
                etherP.strBisectF( tinBaseP , psttnu , psttArchivesSlashArchiveSlashYearSlash , tName , tSlashP , - 4 , flSTRbISECT_null ) ; ___( psttArchivesSlashArchiveSlashYearSlash ) ; ___( psttnu ) ;
                ZE( strokeS* , psttArchivesSlashArchiveSlashYearSlash ) ;
                ZE( strokeS* , psttnu ) ;
                _IO_
            {
            TN( tArchivesSlashArchiveSlashYearSlash , "" ) ;

            //etherP.traceF( tinBaseP , T("walkCBF [tDirectory]:    ")+tName ) ;
            TN( tName , ifName ) ;
            ifFileNameC ifName( tinBaseP , etherP , postNameP ) ;
            _IO_
        {
        else if( postNameP[ thirdC::c_strlenIF( tinBaseP , postNameP ) - 1 ] == '\\' ) // IF DIRECTORY
        }
            }
                bYearDoP = bYearP = 0 ;
                tPathP = tnP ;

                DEL( pJotSortedShort ) ;
                }
                    //etherP.traceF( tinBaseP , T("processed  sorted short names") ) ;
                    consumeSortedShortF( tinBaseP , etherP , etPrime , *(boolT*)&bQuitP , *pJotSortedShort , tPathP , cSetsDoneP ) ;
                    //etherP.traceF( tinBaseP , T("processing sorted short names") ) ;
                {
                if( !bQuitP )

                }
                    etherP.delF( tinBaseP , psttName ) ;
                    DEL( pJotUnsortedShortP ) ;
                    if( pJotUnsortedShortP ) pJotUnsortedShortP->flagsCtRefF() |= flJOTc_PATCHbOOKSfLAGStOpURGEoNdT ;
                    if( !bQuitP && etPrime ) *(boolT*)&bQuitP = 1 ;
                    if( pJotSortedShort ) pJotSortedShort->flagsCtRefF() |= flJOTc_PATCHbOOKSfLAGStOpURGEoNdT ;
                    sortF( tinBaseP , etherP , etPrime , pJotSortedShort , *pJotUnsortedShortP , psttName , tMigrateSortedPrefixP+tDeviceP+tDotP+tYearP , CBdATAbOOKsHORTfILEnAMES , CiNDEXeNTRIESpERbOOKsHORTfILEnAMES , TUCK << 0 , flSORTERc_SILENTLYsUPPRESSdUPLICATES , flJOTc_null , cShortNames , 0 ) ; ___( pJotSortedShort ) ;
                    ZE( strokeS* , psttName ) ;
                    //etherP.traceF( tinBaseP , T("sorting short names [cShortNames]:    ")+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( !bQuitP )
                ZE( jotC* , pJotSortedShort ) ;

                pJotUnsortedShortP->resetLathReadF() ;
                }
                    //etherP.traceF( tinBaseP , T("unsorted [tShort]:    ")+tShort ) ;
        
                    }
                        }
                            *(boolT*)&bQuitP = 1 ;
                            etherP.traceF( tinBaseP , T("!exception: could not obtain blob so aborting") ) ;
                        {
                        else        
                        if( pbIn ) tShort = T(pbIn) ;
                        const byteT* pbIn = pageIn ;
                        pageC pageIn = *pJotUnsortedShortP ;
                    {
                    TN( tShort , "" ) ;
        
                    _IO_
                {
                while( cDo -- )
                countT cDo = cShortNames ;
                countT cShortNames = pJotUnsortedShortP->cElementsF() ;

                bArmDoNamesP = 0 ;
                _IO_
            {
            else if( ( bYearP && bYearDoP ) || bArmDoNamesP )
            }
                bYearDoP = bYearP = 1 ;
                bArmDoNamesP = 1 ;
                _IO_
            {
            if( cYearKidDirectoriesP && !( -- cYearKidDirectoriesP ) )
            _IO_
        {
        if( !postNameP )
        _IO_
    {
    if( !bQuitP && !POOP )

    //etherP.traceF( tinBaseP , T("walkCBF ++++ [tPathP]:    ")+tPathP ) ;

    //etherP.traceF( tinBaseP , T("walkCBF [tDeviceP,tYearP,postNameP]:    ")+tDeviceP+tb4P+tYearP+tb4P+T(postNameP) ) ;

    if( etPrime ) *(boolT*)&bQuitP = 1 ;

    textC&         tUscore20P                =        *(textC*)pcArgP[ 0x1e ] ;
    textC&         tDot20P                   =        *(textC*)pcArgP[ 0x1d ] ;
    textC&         tDotFsetDotZipP           =        *(textC*)pcArgP[ 0x1c ] ;
    textC&         tDotMetaDotDatafiletimesP =        *(textC*)pcArgP[ 0x1b ] ;
    textC&         tHeyIdeaFarmDot9DotP      =        *(textC*)pcArgP[ 0x1a ] ;
    textC&         tHeyIdeaFarmDotADotP      =        *(textC*)pcArgP[ 0x19 ] ;
    textC&         tDotHeyDotControlDotP     =        *(textC*)pcArgP[ 0x18 ] ;
    textC&         tHeyIdeaFarmDotP          =        *(textC*)pcArgP[ 0x17 ] ;
    textC&         tMigrateUnsortedPrefixP   =        *(textC*)pcArgP[ 0x16 ] ;
    textC&         tMigrateSortedPrefixP     =        *(textC*)pcArgP[ 0x15 ] ;
    textC&         tYearP                    =        *(textC*)pcArgP[ 0x14 ] ;
    textC&         tDeviceP                  =        *(textC*)pcArgP[ 0x13 ] ;
    boolT&         bArmDoNamesP              =        *(boolT*)pcArgP[ 0x12 ] ;
    countT&        cYearKidDirectoriesP      =       *(countT*)pcArgP[ 0x11 ] ;
    jotC*&         pJotUnsortedShortP        =        *(jotC**)pcArgP[ 0x10 ] ;
    textC&         t2P                       =        *(textC*)pcArgP[ 0x0f ] ;
    textC&         taP                       =        *(textC*)pcArgP[ 0x0e ] ;
    textC&         t9P                       =        *(textC*)pcArgP[ 0x0d ] ;
    textC&         tHeyIdeaFarmP             =        *(textC*)pcArgP[ 0x0c ] ;
    textC&         tPathP                    =        *(textC*)pcArgP[ 0x0b ] ;
    textC&         tMetaP                    =        *(textC*)pcArgP[ 0x0a ] ;
    textC&         tDataP                    =        *(textC*)pcArgP[ 0x09 ] ;
    textC&         tDotP                     =        *(textC*)pcArgP[ 0x08 ] ;
    textC&         tb4P                      =        *(textC*)pcArgP[ 0x07 ] ;
    textC&         tnP                       =        *(textC*)pcArgP[ 0x06 ] ;
    textC&         tSlashP                   =        *(textC*)pcArgP[ 0x05 ] ;
    boolT&         bYearDoP                  =        *(boolT*)pcArgP[ 0x04 ] ;
    boolT&         bYearP                    =        *(boolT*)pcArgP[ 0x03 ] ;
    const strokeS* psttYearTestP             = (const strokeS*)pcArgP[ 0x02 ] ;
    const strokeS* psttzArchivesP            = (const strokeS*)pcArgP[ 0x01 ] ;
    countT&        cSetsDoneP                =       *(countT*)pcArgP[ 0x00 ] ;

    etherC& etPrime = etherC::etPrimeIF() ;
    etherC& etherP = *((tinFullS&)tinBaseP).pEther ;
    _IO_
{
boolT walkCBF( tinBaseS& tinBaseP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

}
    if( stShort && !bQuitP && !etPrimeP ) bQuitP = flushFileSetF( tinBaseP , etherP , etPrimeP , cSetsDoneP , tShortPrefixLag , stShort , tPathP , tn , tb , tb4 , timeDataWritten ) ;

    jotSortedShortP.resetLathReadF() ;
    }
        }
            }
                }
                    bQuitP = 1 ;
                    etherP.delF( tinBaseP , psttShort ) ;
                    etherP.traceF( tinBaseP , T("!exception: could not sink ; aborting [psttShort]:    ")+T(psttShort) ) ;
                {
                else
                if( ids ) ; //etherP.traceF( tinBaseP , T("sinked (aok)  [psttShort]:    ")+T(psttShort) ) ;
                stShort.sinkF( tinBaseP , ids , psttShort , flSTACKsINK_UNIQUE , 0 , 0 ) ;
                ZE( countT , ids ) ;
                //etherP.traceF( tinBaseP , T("sinking       [psttShort]:    ")+T(psttShort) ) ;
                etherP.strMakeF( tinBaseP , LF , psttShort , tShort ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                //etherP.traceF( tinBaseP , T("about to push [tShort]:    ")+tShort ) ;
                // IF GET HERE THEN THIS FILE IS ACCEPTED AS A MEMBER OF A FORMAT 9 FILESET
            {
            if( !bQuitP )

            }
                }
                    }
                        }
                            etherP.traceF( tinBaseP , T("!exception: could not get file time [tShort]:    ")+tShort ) ;
                            bQuitP = 1 ;
                            POOPRqUIET
                        {
                        if( POOP )

                        //etherP.traceF( tinBaseP , T("      data file time written: ")+TT(timeDataWritten.time1,timeDataWritten.time2) ) ;
                        thirdC::getFileTimeIF( tinBaseP , fiWo , &timeDataWritten , 0 , 0 ) ;
                        timeDataWritten = timeS() ;
                    {
                    else
                    }
                        etherP.traceF( tinBaseP , T("!exception: could not open data file [tShort]:    ")+tShort ) ;
                        bQuitP = 1 ;
                        POOPRqUIET
                    {
                    if( POOP )

                    fileC fiWo( tinBaseP , (strokeS*)( tPathP+tShort ) , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                    SCOOPS
                    _IO_
                {
                IFsCRATCH
                _IO_
            {
            if( !bQuitP && bData )

            bQuitP = !bData && !bMeta ;
            boolT bMeta = 1 == etherP.strIdF( tinBaseP , tMeta , tShortAfterPrefix ) ;
            boolT bData = 1 == etherP.strIdF( tinBaseP , tData , tShortAfterPrefix ) ;

            //20240324@1122: FILE NAME VALIDATION MOVED FROM HERE TO walkCBF IN ORDER TO AVOID THE NEED TO QUIT IF A NONCONFORMING FILE NAME IS ENCOUNTERED ; NOW THOSE FILES ARE JUST IGNORED

            _IO_
        {
        if( !POOP )

        }
            break ;
            bQuitP = 1 ;
            _IO_
        {
        if( bTimeToQuit )
                                                                        
        }
            }
                tShortPrefixLag = tShortPrefix ;
                bTimeToQuit = flushFileSetF( tinBaseP , etherP , etPrimeP , cSetsDoneP , tShortPrefixLag , stShort , tPathP , tn , tb , tb4 , timeDataWritten ) ;
                _IO_
            {
            else if( stShort )
            if( !tShortPrefixLag.csF( tinBaseP ) ) tShortPrefixLag = tShortPrefix ;
            //etherP.traceF( tinBaseP , T("the prefix has changed") ) ;

            bTimeToQuit = !!etPrimeP ;     // THE INTENTION IS TO QUIT ONLY AT FILESET BOUNDARY, SO I INSPECT ether HERE
            _IO_
        {
        if( etherP.strCompareF( tinBaseP , tShortPrefix , tShortPrefixLag ) )     //A:ASSUME: THIS CODE ASSUMES THAT THE FILES ARE PRESENTED IN SORTED ORDER
        ZE( boolT , bTimeToQuit ) ;

        //etherP.traceF( tinBaseP , T("the prefix of this file is:                     ")+tShortPrefix ) ;
        }
            etherP.delF( tinBaseP , psttAfterPrefix ) ;
            etherP.delF( tinBaseP , psttPrefix ) ;
            tShortAfterPrefix  = T(psttAfterPrefix) ;
            tShortPrefix       = T(psttPrefix) ;
            etherP.strBisectF( tinBaseP , psttPrefix , psttAfterPrefix , tShort , tDot , 9 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPrefix ) ; ___( psttAfterPrefix ) ;                                      // tDot
            ZE( strokeS* , psttAfterPrefix ) ;
            ZE( strokeS* , psttPrefix ) ;
            _IO_
        {
        TN( tShortAfterPrefix , "" ) ;
        TN( tShortPrefix      , "" ) ;

        etherP.traceF( tinBaseP , T("consuming sorted [tShort]:    ")+tShort ) ;
        
        }
            }
                break ;
                bQuitP = 1 ;
                etherP.traceF( tinBaseP , T("!exception: could not obtain blob so aborting") ) ;
            {
            else        
            if( pbIn ) tShort = T(pbIn) ;
            const byteT* pbIn = pageIn ;
            pageC pageIn = jotSortedShortP ;
            _IO_
        {
        TN( tShort , "" ) ;

        // /*if( !( cDo % ( TUCK >> 5 ) ) )*/ etherP.traceF( tinBaseP , T("processing sorted short names [cShortNames,cRemaining]:    ")+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        
        _IO_
    {
    while( !etPrimeP && !bQuitP && cDo -- )
    etherP.traceF( tinBaseP , T("beginning to process sorted short names [cShortNames,tPathP]:    ")+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tPathP ) ;
    timeS timeDataWritten ;
    stackC stShort( tinBaseP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    TN( tShortPrefixLag  , "" ) ;
    TN( t2 , "2" ) ;
    TN( ta , "a" ) ;
    TN( t9 , "9" ) ;
    TN( tHeyIdeaFarm , "!ideafarm" ) ;
    TN( tDot , "." ) ;
    TN( tMeta , "meta" ) ;
    TN( tData , "data" ) ;
    TN( tb4 , "    " ) ;
    TN( tb , " " ) ;
    TN( tn           , "" ) ;
    countT cDo = cShortNames ;
    countT cShortNames = jotSortedShortP.cElementsF() ;
    _IO_
{
voidT consumeSortedShortF( tinBaseS& tinBaseP , etherC& etherP , etherC& etPrimeP , boolT& bQuitP , jotC& jotSortedShortP , textC& tPathP , countT& cSetsDoneP )

}
    return bFail ;
                                                 //NOW DOING HDD, SO COMMENT OUT SLEEP:             20240407@1024
                                                 //OFFLINE FAILURES OBSERVED, SO:                   20240323@1739: "<< 2"
                                                 //OFFLINE FAILURES OBSERVED, SO:                   20240304@0810: "<< 1"
                                                 //                                                 20240303@1028: "<< 0"
    //etPrimeP.osSleepF( tinBaseP , TOCK << 1 ) ;      //GIVE THE VOLUME TIME TO COMPLETE ITS I/O FLUSH ; 20240301@0917: "<< 1"
    //sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;        //NAPPING HERE IS NEEDED FOR SSD BUT NOT FOR HDD
    //etherP.traceF( tinBaseP , T("napping" ) ) ;

    tShortPrefixP    = tnP     ;
    //etherP.traceF( tinBaseP , T("flushed  [tShortPrefixP]:                       ")+tShortPrefixP ) ;

    timeDataWrittenP = timeS() ;
    //etherP.traceF( tinBaseP , T("purged  stShortP [cPlates]:    ")+TF2(stShortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    stShortP.purgeF( tinBaseP ) ;
    //etherP.traceF( tinBaseP , T("purging stShortP [cPlates]:    ")+TF2(stShortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    }
        THREADmODE2rESTORE
        }
            }
                //etherP.traceF( tinBaseP , T("flush [cDone]:    ")+TF2(cDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                countT cDone = 1 + incv02AM( cSetsDoneP ) ;

                }
                    //etherP.traceF( tinBaseP , T("setted  zip file time to:     ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
                    ((thirdC&)etherP).setFileTimeF( tinBaseP , fiZip , &timeDataWrittenP , &timeDataWrittenP , &timeDataWrittenP ) ;
                    //etherP.traceF( tinBaseP , T("setting zip file time to:     ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
                    fileC fiZip(   tinBaseP , (strokeS*)( tPathP+tShortZip ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 0 , 0 ) ;
                    _IO_
                {

                //etherP.traceF( tinBaseP , T("called  disZipF [tArgsPkZip]:    ")+tArgsPkZip ) ;
                }
                    etherP.diskZipOldF( tArgsInfoZip , tinBaseP , tArgsPkZip ) ;
                    _IO_
                {
            {
            if( !bFail && !bDoNothing )

            //etherP.traceF( tinBaseP , T("calling disZipF [tArgsPkZip]:    ")+tArgsPkZip ) ;
            }
                }
                    etherP.delF( tinBaseP , psttShortNew ) ;

                    tArgsPkZip   += tbP+T(psttShortNew) ;
                    tArgsInfoZip += tbP+T(psttShortNew) ;
                    //etherP.traceF( tinBaseP , T("moved [old]:    ")+tShort ) ;
                    //etherP.traceF( tinBaseP , T("moved [new]:    ")+T(psttShortNew) ) ;

                    }
                        etherP.diskMoveFileOrDirF( tinBaseP , tLongNew , tPathP+tShort , 0 ) ;
                    {

                    //etherP.traceF( tinBaseP , T("moving from:    ")+tPathP+tShort ) ;
                    //etherP.traceF( tinBaseP , T("moving to  :    ")+tLongNew ) ;

                    TN( tLongNew , "" ) ; tLongNew = tPathP+T(psttShortNew) ;
                    etherP.strReplaceF( tinBaseP , psttShortNew , tShort , T("!ideafarm.9.") , T("!ideafarm.a.") , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                    ZE( strokeS* , psttShortNew ) ;
                    _IO_
                {
                else
                }
                    break ;
                    bDoNothing = 1 ;
                    etherP.traceF( tinBaseP , T("    doing nothing with this prefix") ) ;
                    etherP.traceF( tinBaseP , T("    ")+tShort ) ;
                    etherP.traceF( tinBaseP , T("    ")+tShortPrefixP ) ;
                    etherP.traceF( tinBaseP , T("!exception: not expected for current fileset [tShortPrefix,tShort]:") ) ;
                {
                if( 1 != etherP.strIdF( tinBaseP , tShortPrefixP , tShort , 1 ) )

                }
                    }
                        }
                            }
                                etherP.traceF( tinBaseP , T("!exception: could set file time [tShort]:    ")+tShort ) ;
                                bFail = 1 ;
                                POOPRqUIET
                            {
                            if( POOP )

                            //etherP.traceF( tinBaseP , T("setted  file time to:     ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
                            ((thirdC&)*((tinFullS&)tinBaseP).pEtScratch).setFileTimeF( tinBaseP , fiWo , &timeDataWrittenP , &timeDataWrittenP , &timeDataWrittenP ) ;
                            //etherP.traceF( tinBaseP , T("setting file time to:     ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
                        {
                        else
                        }
                            etherP.traceF( tinBaseP , T("!exception: could not open [tShort]:    ")+tShort ) ;
                            bFail = 1 ;
                            POOPRqUIET
                        {
                        if( POOP )

                        fileC fiWo( tinBaseP , (strokeS*)( tPathP + tShort ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                        SCOOPS
                        _IO_
                    {
                    IFsCRATCH
                    _IO_
                {
                // IOW, ALL FILES IN EACH FILESET ARE DATED ONLY WITH THE TIME MODIFIED VALUE OF THE DATA FILE
                // THIS IS TO SUPPRESS DIFFERENCES IN META DATA ACROSS VOLUMES THAT ARE DUE TO ACCESSING OR DUE TO AD HOC DATA RECOVERY AND MIGRATION ACTIVITIES
                //PS:PERSONALITY: I CLOBBER FILE TIME METADATA SO THAT TIME WRITTEN, ACCESSED, AND CREATED FOR EVERY FILE IN THE FILESET ARE ALL SMUDGED TO THE TIME WRITTEN VALUE OF THE DATA FILE

                //etherP.traceF( tinBaseP , T("popped [tShort]:    ")+tShort ) ;
                }
                    etherP.delF( tinBaseP , psttShort ) ;
                    tShort = T(psttShort) ;
                    stShortP >> psttShort ;
                    ZE( strokeS* , psttShort ) ;
                {
                TN( tShort , "" ) ;
                _IO_
            {
            while( !bFail && stShortP )
            ZE( boolT , bDoNothing ) ;
            //etherP.traceF( tinBaseP , T("popping from stShortP [cPlates]:    ")+TF2(stShortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                }
                    etherP.delF( tinBaseP , psttShort ) ;
                    etherP.traceF( tinBaseP , T("!exception: sink unique failed [psttShort]:    ")+T(psttShort) ) ;
                {
                else
                if( ids ) ; //etherP.traceF( tinBaseP , T("sinked (aok)  [psttShort]:    ")+T(psttShort) ) ;
                stShortP.sinkF( tinBaseP , ids , psttShort , flSTACKsINK_UNIQUE , 0 , 0 ) ;
                ZE( countT , ids ) ;
                //etherP.traceF( tinBaseP , T("sinking       [psttShort]:    ")+T(psttShort) ) ;
                etherP.strMakeF( tinBaseP , LF , psttShort , tShortTimes ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                _IO_
            {
            if( !bFail )

            }
                }
                    }
                        etherP.traceF( tinBaseP , T("!exception: could not write the file times metafile") ) ;
                        bFail = 1 ;
                        POOPRqUIET
                    {
                    if( POOP )
                    ((tinFullS&)tinBaseP).pEtScratch->fileWriteF( tinBaseP , fiTimes , (byteT*)&timeDataWrittenP  , sizeof( timeS ) ) ;
                {
                else
                }
                    etherP.traceF( tinBaseP , T("!exception: could not create the file times metafile") ) ;
                    bFail = 1 ;
                    POOPRqUIET
                {
                if( POOP )

                fileC fiTimes( tinBaseP , (strokeS*)( tPathP + tShortTimes ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeF , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 0 , 0 ) ;

                SCOOPS
                _IO_
            {
            IFsCRATCH
            TN( tShortTimes , "" ) ; tShortTimes = tShortPrefixP + T("meta.datafiletimes") ;
            etherP.boxZapF( tinBaseP , tPathP+tShortZip ) ;
            TN( tArgsPkZip   , "" ) ; tArgsPkZip   = T("-max -add -move ") + tShortZip ;
            TN( tArgsInfoZip , "" ) ; tArgsInfoZip = T("-9m "            ) + tShortZip ;

            hoverC hover( tinBaseP , etherP , tPathP ) ;
        {
        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

        etherP.delF( tinBaseP , psttShortPrefixNew ) ;
        TN( tShortZip , "" ) ; tShortZip = T(psttShortPrefixNew) + T("fset.zip") ;

        etherP.strReplaceF( tinBaseP , psttShortPrefixNew , tShortPrefixP , T("!ideafarm.9.") , T("!ideafarm.a.") , 0 , flSTRrEPLACE_null ) ; ___( psttShortPrefixNew ) ;
        ZE( strokeS* , psttShortPrefixNew ) ;

        //etherP.traceF( tinBaseP , T("flushing with data file time: ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
        _IO_
    {
    else
    }
        etherP.traceF( tinBaseP , T("!exception: null file time for the fset to be flushed, so doing nothing with these files [cFiles,shortPrefix]:    ")+TF2(stShortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tShortPrefixP ) ;
        _IO_
    {
    else if( !timeDataWrittenP )
    if( !stShortP ) ;
    ZE( boolT , bFail ) ;

    //etherP.traceF( tinBaseP , T("flushing [tShortPrefixP]:                       ")+tShortPrefixP ) ;
    //etherP.traceF( tinBaseP , T("                [tPathP]:                       ")+tPathP ) ;

    _IO_
{
boolT flushFileSetF( tinBaseS& tinBaseP , etherC& etherP , etherC& etPrimeP , countT& cSetsDoneP , textC& tShortPrefixP , stackC& stShortP , textC& tPathP , textC& tnP , textC& tbP , textC& tb4P , timeS& timeDataWrittenP )

#define CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ( TOCK << 2 )
#define CBdATAbOOKsHORTfILEnAMES           ( TICK << 1 )

/*1*/WAKEhIDE( "ifcIDaDAM_TOOLmIGRATEaRCHIVEfORMAT9tOfORMATa" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
