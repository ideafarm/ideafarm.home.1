
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etherC::loafIF( tin0P ) ;
    etThread.traceF( tin0P , T("ok") ) ;

    }
        DEL( pJotUnsortedShort ) ;
        }
            }
                etThread.traceF( tin0P , T("!exception: walk failed") ) ;
                POOPRqUIET
            {
            if( POOP )

            ((tin1S&)tin0P).pEtScratch->diskWalkF( tin0P , cDirs , cFiles , tPathToWalk  , bQuit , flDISKwALK_null , walkCBF , pcArg , 0 , 0 ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK

        countT pcArg[] = { (countT)&cSetsDone , (countT)(strokeS*)tArchives , (countT)(strokeS*)tYearTest , (countT)&bYear , (countT)&bYearDo , (countT)&tSlash , (countT)&tn , (countT)&tb4 , (countT)&tDot , (countT)&tData , (countT)&tMeta , (countT)&tPath , (countT)&tHeyIdeaFarm , (countT)&t9 , (countT)&ta , (countT)&t2 , (countT)&pJotUnsortedShort , (countT)&cYearKidDirectories , (countT)&bArmDoNames , (countT)&tDevice , (countT)&tYear , (countT)&tMigrateSortedPrefix , (countT)&tMigrateUnsortedPrefix , (countT)&tHeyIdeaFarmDot , (countT)&tDotHeyDotControlDot , (countT)&tHeyIdeaFarmDotADot , (countT)&tHeyIdeaFarmDot9Dot , (countT)&tDotMetaDotDatafiletimes , (countT)&tDotFsetDotZip , (countT)&tDot20 , (countT)&tUscore20 } ;

        TN( tUscore20 , "_20" ) ;
        TN( tDot20 , ".20" ) ;
        TN( tDotFsetDotZip , ".fset.zip" ) ;
        TN( tDotMetaDotDatafiletimes , ".meta.datafiletimes" ) ;
        TN( tHeyIdeaFarmDot9Dot , "!ideafarm.9." ) ;
        TN( tHeyIdeaFarmDotADot , "!ideafarm.a." ) ;
        TN( tDotHeyDotControlDot , ".!.control." ) ;
        TN( tHeyIdeaFarmDot , "!ideafarm." ) ;
        TN( tMigrateUnsortedPrefix , "migrate.unsorted.short.filenames." ) ;
        TN( tMigrateSortedPrefix   , "migrate.sorted.short.filenames."   ) ;
        TN( tYear , "" ) ;
        ZE( boolT , bArmDoNames ) ;
        ZE( countT , cYearKidDirectories ) ;
        ZE( jotC* , pJotUnsortedShort ) ;
        TN( t2 , "2" ) ;
        TN( ta , "a" ) ;
        TN( t9 , "9" ) ;
        TN( tHeyIdeaFarm , "!ideafarm" ) ;
        TN( tPath , "" ) ;
        TN( tMeta , "meta" ) ;
        TN( tData , "data" ) ;
        TN( tDot , "." ) ;
        TN( tb4 , "    " ) ;
        TN( tn , "" ) ;
        TN( tSlash , "/" ) ;
        ZE( boolT , bYearDo ) ;
        ZE( boolT , bYear ) ;
        TN( tYearTest , "" ) ;  // E.G. "2011" OR "2012,2013,2014"
        //TN( tYearTest , "2018,2019,2020,2021,2022,2023,2099" ) ;  // E.G. "2011" OR "2012,2013,2014"
        TN( tArchives , "ideafarm.archives" ) ;
        ZE( countT , cSetsDone ) ;
        ZE( boolT , bQuit ) ;

        etThread.traceF( tin0P , T("[device]:    ")+tDevice ) ;
        }
            etThread.delF( tin0P , psttw ) ;
            tDevice = T(psttw) ;
            etThread.strWordF( tin0P , psttw , tPathToWalk , sttq , S1C('/') , - 4 ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttw ) ;

            _IO_
        {
        TN( tDevice , "" ) ;

        etThread.traceF( tin0P , T("i will walk [path]:    ")+tPathToWalk ) ;
        TN( tPathToWalk , psttPathP ) ;
        ZE( countT , cFiles ) ;
        ZE( countT , cDirs  ) ;
        _IO_
    {
    else
    }
        }
            ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;

            }
                etThread.delF( tin0P , pstt1d ) ;
                }
                    }
                        break ;
                        }
                            etThread.delF( tin0P , pstta ) ;
                            etThread.ifcHireF( tin0P , T("ifcIDaDAM_SCRATCH0f") , 0 , tArgKeyName+T(" ")+T(pstta) , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                            etThread.traceF( tin0P , T("hiring [psttArchive]:    ")+T(pstta) ) ;
                            stArchiveDo >> pstta ;
                            ZE( strokeS* , pstta ) ;
                        {
                        while( stArchiveDo )
                    {
                    if( !bFail && !ether )

                    }
                        }
                            }
                                stArchiveDo << pstta ;
                                etThread.strMakeF( tin0P , LF , pstta , tArchiveTry ) ; ___( pstta ) ;
                                ZE( strokeS* , pstta ) ;
                            {
                            else if( cFound )
                            }
                                break ;
                                tDeviceFailed = T(psttc1) ;
                                etThread.traceF( tin0P , T("!exception: device failed; please power cycle the device: ")+T(psttc1) ) ;
                            {
                            if( bFail )

                            etThread.delF( tin0P , pstt1f ) ;
                            }
                                etThread.traceF( tin0P , T("    [found]:    ")+T(psttc2) ) ;
                            {
                            FORsTRINGSiN2( pstt1f )
                            etThread.traceF( tin0P , T("[cFound,tArchiveTry]:    ")+TF2(cFound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tArchiveTry ) ;
                            }
                                }
                                    bFail = 1 ;
                                    POOPRqUIET
                                {
                                if( POOP )
                                cFound = ((tin1S&)tin0P).pEtScratch->diskFindFileOrDirF( tin0P , pstt1f , tArchiveTry , 0 , flDISKfIND_null , 0 , 0 , 0 , 1 , 0 ) ;
                                SCOOPS
                            {
                            ZE( countT , cFound ) ;
                            ZE( strokeS* , pstt1f ) ;
                            TN( tArchiveTry , "" ) ; tArchiveTry = T(psttc1)+T("ideafarm.archives/wo.ideafarm/") ;
                        {
                        if( !bSkip )

                        if( !tDeviceFailed.csF( tin0P ) || !etThread.strCompareF( tin0P , psttc1 , tDeviceFailed ) ) bSkip = 0 ;

                        //if( etThread.strCompareF( tin0P , psttc1 , T("///d/ideafarm.home.101/devices/ssd4.arc.20240214/") ) ) continue ; //TO FIND A BUG
                        //etThread.traceF( tin0P , psttc1 ) ;
                    {
                    FORsTRINGSiN1( pstt1d )
                    boolT bSkip = 1 ;
                {
                else
                }
                    etThread.traceF( tin0P , T("!exception: could not obtain device list") ) ;
                {
                if( bFail )
                }
                    }
                        bFail = 1 ;
                        POOPRqUIET
                    {
                    if( POOP )
                    ((tin1S&)tin0P).pEtScratch->diskFindFileOrDirF( tin0P , pstt1d , tLongDevices , 0 , flDISKfIND_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1d ) ;
                    SCOOPS
                {
                ZE( boolT , bFail ) ;
                ZE( strokeS* , pstt1d ) ;
                TN( tLongDevices , "///d/ideafarm.home.101/devices/" ) ;
                stackC stArchiveDo( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                _IO_
            {
            IFsCRATCHoK
            _IO_
        {
        while( !ether )
        TN( tDeviceFailed , "" ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        _IO_
    {
    if( !psttPathP )

    }
        }
            }
                break ;
                etThread.strMakeF( tin0P , LF , psttPathP , psttc1 ) ; ___( psttPathP ) ;
                bArmed = 0 ;
            {
            else if( bArmed )
            if( !etThread.strCompareF( tin0P , psttc1 , tArgKeyName ) ) bArmed = 1 ;
            //etThread.traceF( tin0P , T("param: ")+T(psttc1) ) ;
            _IO_
        {
        FORsTRINGSiN1( pstt1Param )
        ZE( boolT , bArmed ) ;
        strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tin0P ) ;
        _IO_
    {
    ZE( strokeS* , psttPathP ) ;
    TN( tArgKeyName , "!path" ) ;
{
if( pTaskP )
TASK( tmWorkF )

}
    return 1 ;

    }
        }
            }
                }
                    if( !( ( idJot & ~NM_HIGH ) % TUCK ) ) etherP.traceF( tin0P , T("jotted [idJot,tShort]:    ")+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4P+tShortNew ) ;
                    countT idJot = pJotUnsortedShortP->writeF( tin0P , tShortNew , tShortNew.csF( tin0P ) + 1 , 0 , 0 ) ;
                    _IO_
                {
                if( tShortNew.csF( tin0P ) )

                }
                    etherP.delF( tin0P , pstt1w ) ;
                    }
                        }
                            tShortNew = tnP ;
                            etherP.delF( tin0P , psttShortNew ) ;
                            if( cHits ) etherP.diskMoveFileOrDirF( tin0P , tPathP+T(psttShortNew) , tPathP+tShort , 0 ) ;
                            countT cHits = etherP.strReplaceF( tin0P , psttShortNew , tShort , tHeyIdeaFarmDot9DotP , tHeyIdeaFarmDotADotP , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                            ZE( strokeS* , psttShortNew ) ;
                            //CS:CODEsYNC: DUPLICATE CODE: 5101200f 5101200f
                        {
                        if( bFail )

                        }
                            if( bFail ) break ;

                            }
                                }
                                    break ;
                                    bFail = !bData && !bMeta ;
                                    boolT bMeta = !etherP.strCompareF( tin0P , psttc1 , tMetaP ) ;
                                    boolT bData = !etherP.strCompareF( tin0P , psttc1 , tDataP ) ;
                                {
                                case 0xa :
                                }
                                    break ;
                                    bFail = psttc1->idAdam != 3 ;
                                {
                                case 0x9 :
                                }
                                    break ;
                                    bFail = psttc1->idAdam != 0x20 ;
                                {
                                case 0x8 :
                                }
                                    break ;
                                    bFail = psttc1->idAdam != 0xd ;
                                {
                                case 0x7 :
                                case 0x6 :
                                }
                                    break ;
                                    bFail = psttc1->idAdam != 8 ;
                                {
                                case 0x5 :
                                case 0x4 :
                                }
                                    break ;
                                    bFail = !!etherP.strCompareF( tin0P , psttc1 , t2P ) ;
                                {
                                case 0x3 :
                                }
                                    break ;
                                    bFail = etherP.strCompareF( tin0P , psttc1 , t9P ) && etherP.strCompareF( tin0P , psttc1 , taP ) ;
                                {
                                case 0x2 :
                                }
                                    break ;
                                    bFail = !!etherP.strCompareF( tin0P , psttc1 , tHeyIdeaFarmP ) ;
                                {
                                case 0x1 :
                            {
                            switch( ++ idw )
                            //etherP.traceF( tin0P , tb4+T(psttc1) ) ;
                            _IO_
                        {
                        FORsTRINGSiN1( pstt1w )
                        ZE( countT , idw ) ;
                        ZE( boolT , bFail ) ;
                        _IO_
                    {
                    else
                    }
                        tShortNew = tnP ;
                        etherP.delF( tin0P , psttShortNew ) ;
                        if( cHits ) etherP.diskMoveFileOrDirF( tin0P , tPathP+T(psttShortNew) , tPathP+tShort , 0 ) ;
                        countT cHits = etherP.strReplaceF( tin0P , psttShortNew , tShort , tHeyIdeaFarmDot9DotP , tHeyIdeaFarmDotADotP , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                        ZE( strokeS* , psttShortNew ) ;
                        _IO_
                    {
                    if( cWords < 0xb )
                    //etherP.traceF( tin0P , T("cWords:    ")+TF2(cWords,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT cWords = etherP.strWordsF( tin0P , pstt1w , tShortNew , sttq , tDotP , flSTRwORDS_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1w ) ;
                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                    ZE( strokeS* , pstt1w ) ;

                    // b    jpg
                    // a    data
                    // 9    001
                    // 8    2a24e441984f7650ef8982bc85155e1c
                    // 7    20170131@0012
                    // 6    00000000@0000
                    // 5    00000001
                    // 4    00000000
                    // 3    2
                    // 2    9
                    // 1   !ideafarm
                    //
                    // !ideafarm.9.2.00000000.00000001.00000000@0000.20170131@0012.2a24e441984f7650ef8982bc85155e1c.001.data.jpg
                    // EXPECTED INPUT, PARSED TO WORDS

                    _IO_
                {
                if( tShortNew.csF( tin0P ) )

                }
                    }
                        }
                            }
                                tShortNew = tnP ;
                                etherP.traceF( tin0P , T("!exception: could not move to eliminate underscore ; file will be ignored") ) ;
                                POOPRqUIET
                            {
                            if( POOP )

                            THREADmODE1rESTORE
                            ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tLongNew , tPathP+tShort , 1 ) ;
                            THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

                            SCOOPS
                            _IO_
                        {
                        IFsCRATCHoK

                        etherP.traceF( tin0P , T("to eliminate underscore, moving from:    ")+tPathP+tShort ) ;
                        etherP.traceF( tin0P , T("to eliminate underscore, moving to  :    ")+tLongNew ) ;
                    {
                    if( cHits )

                    TN( tLongNew , "" ) ; tLongNew = tPathP+tShortNew ;
                    etherP.delF( tin0P , psttShortNew ) ;
                    tShortNew = T(psttShortNew) ;
                    countT cHits = etherP.strReplaceF( tin0P , psttShortNew , tShort , tUscore20P , tDot20P , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                    ZE( strokeS* , psttShortNew ) ;
                    _IO_
                {
                TN( tShortNew , "" ) ;
            {
            else if( !etherP.strIdF( tin0P , tDotFsetDotZipP , tShort ) )
            }
                etherP.traceF( tin0P , T("!exception: zapped  unexpected file [tLong]:    ")+tPathP+tShort ) ;
                etherP.boxZapF( tin0P , tPathP+tShort ) ;
                etherP.traceF( tin0P , T("!exception: zapping unexpected file [tLong]:    ")+tPathP+tShort ) ;
                _IO_
            {
            else if( etherP.strIdF( tin0P , tDotMetaDotDatafiletimesP , tShort ) )
            }
                etherP.delF( tin0P , psttShortNew ) ;
                if( cHits ) etherP.diskMoveFileOrDirF( tin0P , tPath+T(psttShortNew) , tPath+tShort , 0 ) ;
                countT cHits = etherP.strReplaceF( tin0P , psttShortNew , tShort , tHeyIdeaFarmDot9DotP , tHeyIdeaFarmDotADotP , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                ZE( strokeS* , psttShortNew ) ;
                //CS:CODEsYNC: DUPLICATE CODE: 5101200f 5101200f
                _IO_
            {
            else if( etherP.strIdF( tin0P , tDotHeyDotControlDotP , tShort ) )
            }
                _IO_
                etherP.traceF( tin0P , T("!exception: file ignored (a particular file to ignore; it is a duplicate of another data file in the same set) [tLong]:    ")+tPathP+tShort ) ;
            {
            else if( etherP.strIdF( tin0P , T(".data.tripod.speech.") , tShort ) )
            }
                _IO_
                etherP.traceF( tin0P , T("!exception: file ignored (name does not begin with !ideafarm.) [tLong]:    ")+tPathP+tShort ) ;
            {
            if( 1 != etherP.strIdF( tin0P , tHeyIdeaFarmDotP , tShort ) )

            else { __NZ( etherP.strCompareF( tin0P , tPath , tPathP ) ) ; }
            }
                //etherP.traceF( tin0P , T("walkCBF set [tPathP]:    ")+tPathP ) ;
                tPathP = tPath ;
                _IO_
            {
            if( !tPathP.csF( tin0P ) )

            //etherP.traceF( tin0P , T("inspecting file [tShort]:    ")+tShort ) ;
            }
                etherP.delF( tin0P , psttShort ) ;
                etherP.delF( tin0P , psttPath ) ;
                tShort = T(psttShort) ;
                tPath  = T(psttPath) ;
                etherP.strBisectF( tin0P , psttPath , psttShort , tName , tSlashP , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttPath ) ;
                _IO_
            {
            TN( tShort , "" ) ;
            TN( tPath  , "" ) ;

            //etherP.traceF( tin0P , T("walkCBF [tFile]:    ")+tName ) ;
            TN( tName , ifName ) ;
            ifFileNameC ifName( tin0P , *((tin1S&)tin0P).pEther , postNameP ) ;
            _IO_
        {
        else if( bYearP && bYearDoP /*&& !cSetsDoneP*/ )
        }
            }
                }
                    pJotUnsortedShortP = new( 0 , tin0P , LF ) jotC( tin0P , tPart2 , flJOTc_PRIVATE | flJOTc_DELETE | flJOTc_WRITE | flJOTc_PURGEoNcT | flJOTc_PATCHbOOKSfLAGStOpURGEoNdT, ifcIDsTATEsPACE_SINGLEaDAM( tin0P ) , 1 , CBdATAbOOKsHORTfILEnAMES , CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ) ; ___( pJotUnsortedShortP ) ;
                    TN( tPart2  , "" ) ; tPart2  = tMigrateUnsortedPrefixP+tDeviceP+tDotP+tYearP ;

                    bYearDoP = 1 ;
                    etherP.traceF( tin0P , T("year to do:    ")+tYearP ) ;
                {
                if( !psttYearTestP->idAdam || etherP.strIdF( tin0P , tYearP , psttYearTestP , 1 ) )

                etherP.traceF( tin0P , T("year      :    ")+tYearP ) ;
                }
                    etherP.delF( tin0P , psttYear ) ;
                    tYearP  = T(psttYear) ;

                    etherP.delF( tin0P , psttnu ) ;
                    etherP.delF( tin0P , psttYearSlash ) ;
                    etherP.strBisectF( tin0P , psttYear , psttnu , psttYearSlash , tSlashP , - 1 , flSTRbISECT_null ) ; ___( psttYear ) ; ___( psttnu ) ;
                    ZE( strokeS* , psttYear ) ;

                    etherP.delF( tin0P , psttnu ) ;
                    etherP.strBisectF( tin0P , psttnu , psttYearSlash , tArchivesSlashArchiveSlashYearSlash , tSlashP , - 2 , flSTRbISECT_null ) ; ___( psttYearSlash ) ; ___( psttnu ) ;
                    ZE( strokeS* , psttYearSlash ) ;
                    ZE( strokeS* , psttnu ) ;
                {

                bYearP = 1 ;
                //etherP.traceF( tin0P , T("year:    ")+tArchivesSlashArchiveSlashYearSlash ) ;
                _IO_
            {
            else
            }
                bYearDoP = bYearP = 0 ;
                if( bYearDoP || cYearKidDirectoriesP ) cYearKidDirectoriesP ++ ;
                _IO_
            {
            if( 1 != etherP.strIdF( tin0P , psttzArchivesP , tArchivesSlashArchiveSlashYearSlash , 1 ) )

            //etherP.traceF( tin0P , T("directory [tArchivesSlashArchiveSlashYearSlash]:    ")+tArchivesSlashArchiveSlashYearSlash ) ;
            }
                etherP.delF( tin0P , psttnu ) ;
                etherP.delF( tin0P , psttArchivesSlashArchiveSlashYearSlash ) ;

                tArchivesSlashArchiveSlashYearSlash  = T(psttArchivesSlashArchiveSlashYearSlash) ;
                etherP.strBisectF( tin0P , psttnu , psttArchivesSlashArchiveSlashYearSlash , tName , tSlashP , - 4 , flSTRbISECT_null ) ; ___( psttArchivesSlashArchiveSlashYearSlash ) ; ___( psttnu ) ;
                ZE( strokeS* , psttArchivesSlashArchiveSlashYearSlash ) ;
                ZE( strokeS* , psttnu ) ;
                _IO_
            {
            TN( tArchivesSlashArchiveSlashYearSlash , "" ) ;

            //etherP.traceF( tin0P , T("walkCBF [tDirectory]:    ")+tName ) ;
            TN( tName , ifName ) ;
            ifFileNameC ifName( tin0P , etherP , postNameP ) ;
            _IO_
        {
        else if( postNameP[ thirdC::c_strlenIF( tin0P , postNameP ) - 1 ] == '\\' ) // IF DIRECTORY
        }
            }
                bYearDoP = bYearP = 0 ;
                tPathP = tnP ;

                DEL( pJotSortedShort ) ;
                }
                    //etherP.traceF( tin0P , T("processed  sorted short names") ) ;
                    consumeSortedShortF( tin0P , etherP , etPrime , *(boolT*)&bQuitP , *pJotSortedShort , tPathP , cSetsDoneP ) ;
                    //etherP.traceF( tin0P , T("processing sorted short names") ) ;
                {
                if( !bQuitP )

                }
                    etherP.delF( tin0P , psttName ) ;
                    DEL( pJotUnsortedShortP ) ;
                    if( pJotUnsortedShortP ) pJotUnsortedShortP->flagsCtRefF() |= flJOTc_PATCHbOOKSfLAGStOpURGEoNdT ;
                    if( !bQuitP && etPrime ) *(boolT*)&bQuitP = 1 ;
                    if( pJotSortedShort ) pJotSortedShort->flagsCtRefF() |= flJOTc_PATCHbOOKSfLAGStOpURGEoNdT ;
                    sortF( tin0P , etherP , etPrime , pJotSortedShort , *pJotUnsortedShortP , psttName , tMigrateSortedPrefixP+tDeviceP+tDotP+tYearP , CBdATAbOOKsHORTfILEnAMES , CiNDEXeNTRIESpERbOOKsHORTfILEnAMES , TUCK << 0 , flSORTERc_SILENTLYsUPPRESSdUPLICATES , flJOTc_null , cShortNames , 0 ) ; ___( pJotSortedShort ) ;
                    ZE( strokeS* , psttName ) ;
                    //etherP.traceF( tin0P , T("sorting short names [cShortNames]:    ")+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( !bQuitP )
                ZE( jotC* , pJotSortedShort ) ;

                pJotUnsortedShortP->resetLathReadF() ;
                }
                    //etherP.traceF( tin0P , T("unsorted [tShort]:    ")+tShort ) ;
        
                    }
                        }
                            *(boolT*)&bQuitP = 1 ;
                            etherP.traceF( tin0P , T("!exception: could not obtain blob so aborting") ) ;
                        {
                        else        
                        if( pbIn ) tShort = T(pbIn) ;
                        const byteT* pbIn = pageIn ;
                        pageC pageIn = *pJotUnsortedShortP ;
                    {
                    TN( tShort , "" ) ;
        
                    _IO_
                {
                while( cDo -- )
                countT cDo = cShortNames ;
                countT cShortNames = pJotUnsortedShortP->cElementsF() ;

                bArmDoNamesP = 0 ;
                _IO_
            {
            else if( ( bYearP && bYearDoP ) || bArmDoNamesP )
            }
                bYearDoP = bYearP = 1 ;
                bArmDoNamesP = 1 ;
                _IO_
            {
            if( cYearKidDirectoriesP && !( -- cYearKidDirectoriesP ) )
            _IO_
        {
        if( !postNameP )
        _IO_
    {
    if( !bQuitP && !POOP )

    //etherP.traceF( tin0P , T("walkCBF ++++ [tPathP]:    ")+tPathP ) ;

    etherP.traceF( tin0P , T("walkCBF [tDeviceP,tYearP,postNameP]:    ")+tDeviceP+tb4P+tYearP+tb4P+T(postNameP) ) ;

    if( etPrime ) *(boolT*)&bQuitP = 1 ;

    textC&         tUscore20P                =        *(textC*)pcArgP[ 0x1e ] ;
    textC&         tDot20P                   =        *(textC*)pcArgP[ 0x1d ] ;
    textC&         tDotFsetDotZipP           =        *(textC*)pcArgP[ 0x1c ] ;
    textC&         tDotMetaDotDatafiletimesP =        *(textC*)pcArgP[ 0x1b ] ;
    textC&         tHeyIdeaFarmDot9DotP      =        *(textC*)pcArgP[ 0x1a ] ;
    textC&         tHeyIdeaFarmDotADotP      =        *(textC*)pcArgP[ 0x19 ] ;
    textC&         tDotHeyDotControlDotP     =        *(textC*)pcArgP[ 0x18 ] ;
    textC&         tHeyIdeaFarmDotP          =        *(textC*)pcArgP[ 0x17 ] ;
    textC&         tMigrateUnsortedPrefixP   =        *(textC*)pcArgP[ 0x16 ] ;
    textC&         tMigrateSortedPrefixP     =        *(textC*)pcArgP[ 0x15 ] ;
    textC&         tYearP                    =        *(textC*)pcArgP[ 0x14 ] ;
    textC&         tDeviceP                  =        *(textC*)pcArgP[ 0x13 ] ;
    boolT&         bArmDoNamesP              =        *(boolT*)pcArgP[ 0x12 ] ;
    countT&        cYearKidDirectoriesP      =       *(countT*)pcArgP[ 0x11 ] ;
    jotC*&         pJotUnsortedShortP        =        *(jotC**)pcArgP[ 0x10 ] ;
    textC&         t2P                       =        *(textC*)pcArgP[ 0x0f ] ;
    textC&         taP                       =        *(textC*)pcArgP[ 0x0e ] ;
    textC&         t9P                       =        *(textC*)pcArgP[ 0x0d ] ;
    textC&         tHeyIdeaFarmP             =        *(textC*)pcArgP[ 0x0c ] ;
    textC&         tPathP                    =        *(textC*)pcArgP[ 0x0b ] ;
    textC&         tMetaP                    =        *(textC*)pcArgP[ 0x0a ] ;
    textC&         tDataP                    =        *(textC*)pcArgP[ 0x09 ] ;
    textC&         tDotP                     =        *(textC*)pcArgP[ 0x08 ] ;
    textC&         tb4P                      =        *(textC*)pcArgP[ 0x07 ] ;
    textC&         tnP                       =        *(textC*)pcArgP[ 0x06 ] ;
    textC&         tSlashP                   =        *(textC*)pcArgP[ 0x05 ] ;
    boolT&         bYearDoP                  =        *(boolT*)pcArgP[ 0x04 ] ;
    boolT&         bYearP                    =        *(boolT*)pcArgP[ 0x03 ] ;
    const strokeS* psttYearTestP             = (const strokeS*)pcArgP[ 0x02 ] ;
    const strokeS* psttzArchivesP            = (const strokeS*)pcArgP[ 0x01 ] ;
    countT&        cSetsDoneP                =       *(countT*)pcArgP[ 0x00 ] ;

    etherC& etPrime = etherC::etPrimeIF() ;
    etherC& etherP = *((tin1S&)tin0P).pEther ;
    _IO_
{
boolT walkCBF( tin0S& tin0P , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

}
    if( stShort && !bQuitP && !etPrimeP ) bQuitP = flushFileSetF( tin0P , etherP , etPrimeP , cSetsDoneP , tShortPrefixLag , stShort , tPathP , tn , tb , tb4 , timeDataWritten ) ;

    jotSortedShortP.resetLathReadF() ;
    }
        }
            }
                }
                    bQuitP = 1 ;
                    etherP.delF( tin0P , psttShort ) ;
                    etherP.traceF( tin0P , T("!exception: could not sink ; aborting [psttShort]:    ")+T(psttShort) ) ;
                {
                else
                if( ids ) ; //etherP.traceF( tin0P , T("sinked (aok)  [psttShort]:    ")+T(psttShort) ) ;
                stShort.sinkF( tin0P , ids , psttShort , flSTACKsINK_UNIQUE , 0 , 0 ) ;
                ZE( countT , ids ) ;
                //etherP.traceF( tin0P , T("sinking       [psttShort]:    ")+T(psttShort) ) ;
                etherP.strMakeF( tin0P , LF , psttShort , tShort ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                //etherP.traceF( tin0P , T("about to push [tShort]:    ")+tShort ) ;
                // IF GET HERE THEN THIS FILE IS ACCEPTED AS A MEMBER OF A FORMAT 9 FILESET
            {
            if( !bQuitP )

            }
                }
                    }
                        }
                            etherP.traceF( tin0P , T("!exception: could not get file time [tShort]:    ")+tShort ) ;
                            bQuitP = 1 ;
                            POOPRqUIET
                        {
                        if( POOP )

                        //etherP.traceF( tin0P , T("      data file time written: ")+TT(timeDataWritten.time1,timeDataWritten.time2) ) ;
                        thirdC::getFileTimeIF( tin0P , fiWo , &timeDataWritten , 0 , 0 ) ;
                        timeDataWritten = timeS() ;
                    {
                    else
                    }
                        etherP.traceF( tin0P , T("!exception: could not open data file [tShort]:    ")+tShort ) ;
                        bQuitP = 1 ;
                        POOPRqUIET
                    {
                    if( POOP )

                    fileC fiWo( tin0P , (strokeS*)( tPathP+tShort ) , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                _IO_
            {
            if( !bQuitP && bData )

            bQuitP = !bData && !bMeta ;
            boolT bMeta = 1 == etherP.strIdF( tin0P , tMeta , tShortAfterPrefix ) ;
            boolT bData = 1 == etherP.strIdF( tin0P , tData , tShortAfterPrefix ) ;

            //20240324@1122: FILE NAME VALIDATION MOVED FROM HERE TO walkCBF IN ORDER TO AVOID THE NEED TO QUIT IF A NONCONFORMING FILE NAME IS ENCOUNTERED ; NOW THOSE FILES ARE JUST IGNORED

            _IO_
        {
        if( !POOP )

        }
            break ;
            bQuitP = 1 ;
            _IO_
        {
        if( bTimeToQuit )
                                                                        
        }
            }
                tShortPrefixLag = tShortPrefix ;
                bTimeToQuit = flushFileSetF( tin0P , etherP , etPrimeP , cSetsDoneP , tShortPrefixLag , stShort , tPathP , tn , tb , tb4 , timeDataWritten ) ;
                _IO_
            {
            else if( stShort )
            if( !tShortPrefixLag.csF( tin0P ) ) tShortPrefixLag = tShortPrefix ;
            //etherP.traceF( tin0P , T("the prefix has changed") ) ;

            bTimeToQuit = !!etPrimeP ;     // THE INTENTION IS TO QUIT ONLY AT FILESET BOUNDARY, SO I INSPECT ether HERE
            _IO_
        {
        if( etherP.strCompareF( tin0P , tShortPrefix , tShortPrefixLag ) )     //A:ASSUME: THIS CODE ASSUMES THAT THE FILES ARE PRESENTED IN SORTED ORDER
        ZE( boolT , bTimeToQuit ) ;

        //etherP.traceF( tin0P , T("the prefix of this file is:                     ")+tShortPrefix ) ;
        }
            etherP.delF( tin0P , psttAfterPrefix ) ;
            etherP.delF( tin0P , psttPrefix ) ;
            tShortAfterPrefix  = T(psttAfterPrefix) ;
            tShortPrefix       = T(psttPrefix) ;
            etherP.strBisectF( tin0P , psttPrefix , psttAfterPrefix , tShort , tDot , 9 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPrefix ) ; ___( psttAfterPrefix ) ;                                      // tDot
            ZE( strokeS* , psttAfterPrefix ) ;
            ZE( strokeS* , psttPrefix ) ;
            _IO_
        {
        TN( tShortAfterPrefix , "" ) ;
        TN( tShortPrefix      , "" ) ;

        etherP.traceF( tin0P , T("consuming sorted [tShort]:    ")+tShort ) ;
        
        }
            }
                break ;
                bQuitP = 1 ;
                etherP.traceF( tin0P , T("!exception: could not obtain blob so aborting") ) ;
            {
            else        
            if( pbIn ) tShort = T(pbIn) ;
            const byteT* pbIn = pageIn ;
            pageC pageIn = jotSortedShortP ;
            _IO_
        {
        TN( tShort , "" ) ;

        // /*if( !( cDo % ( TUCK >> 5 ) ) )*/ etherP.traceF( tin0P , T("processing sorted short names [cShortNames,cRemaining]:    ")+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        
        _IO_
    {
    while( !etPrimeP && !bQuitP && cDo -- )
    etherP.traceF( tin0P , T("beginning to process sorted short names [cShortNames,tPathP]:    ")+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tPathP ) ;
    timeS timeDataWritten ;
    stackC stShort( tin0P , etherP , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    TN( tShortPrefixLag  , "" ) ;
    TN( t2 , "2" ) ;
    TN( ta , "a" ) ;
    TN( t9 , "9" ) ;
    TN( tHeyIdeaFarm , "!ideafarm" ) ;
    TN( tDot , "." ) ;
    TN( tMeta , "meta" ) ;
    TN( tData , "data" ) ;
    TN( tb4 , "    " ) ;
    TN( tb , " " ) ;
    TN( tn           , "" ) ;
    countT cDo = cShortNames ;
    countT cShortNames = jotSortedShortP.cElementsF() ;
    _IO_
{
voidT consumeSortedShortF( tin0S& tin0P , etherC& etherP , etherC& etPrimeP , boolT& bQuitP , jotC& jotSortedShortP , textC& tPathP , countT& cSetsDoneP )

}
    return bFail ;
                                                 //NOW DOING HDD, SO COMMENT OUT SLEEP:             20240407@1024
                                                 //OFFLINE FAILURES OBSERVED, SO:                   20240323@1739: "<< 2"
                                                 //OFFLINE FAILURES OBSERVED, SO:                   20240304@0810: "<< 1"
                                                 //                                                 20240303@1028: "<< 0"
    //etPrimeP.osSleepF( tin0P , TOCK << 1 ) ;      //GIVE THE VOLUME TIME TO COMPLETE ITS I/O FLUSH ; 20240301@0917: "<< 1"
    //sleepC s( tin0P , TAG( TAGiDnULL ) ) ;        //NAPPING HERE IS NEEDED FOR SSD BUT NOT FOR HDD
    //etherP.traceF( tin0P , T("napping" ) ) ;

    tShortPrefixP    = tnP     ;
    //etherP.traceF( tin0P , T("flushed  [tShortPrefixP]:                       ")+tShortPrefixP ) ;

    timeDataWrittenP = timeS() ;
    //etherP.traceF( tin0P , T("purged  stShortP [cPlates]:    ")+TF2(stShortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    stShortP.purgeF( tin0P ) ;
    //etherP.traceF( tin0P , T("purging stShortP [cPlates]:    ")+TF2(stShortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    }
        THREADmODE1rESTORE
        }
            }
                //etherP.traceF( tin0P , T("flush [cDone]:    ")+TF2(cDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                countT cDone = 1 + incv02AM( cSetsDoneP ) ;

                }
                    //etherP.traceF( tin0P , T("setted  zip file time to:     ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
                    ((thirdC&)etherP).setFileTimeF( tin0P , fiZip , &timeDataWrittenP , &timeDataWrittenP , &timeDataWrittenP ) ;
                    //etherP.traceF( tin0P , T("setting zip file time to:     ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
                    fileC fiZip(   tin0P , (strokeS*)( tPathP+tShortZip ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 0 , 0 ) ;
                    _IO_
                {

                //etherP.traceF( tin0P , T("called  disZipF [tArgsPkZip]:    ")+tArgsPkZip ) ;
                }
                    etherP.diskZipOldF( tArgsInfoZip , tin0P , tArgsPkZip ) ;
                    _IO_
                {
            {
            if( !bFail && !bDoNothing )

            //etherP.traceF( tin0P , T("calling disZipF [tArgsPkZip]:    ")+tArgsPkZip ) ;
            }
                }
                    etherP.delF( tin0P , psttShortNew ) ;

                    tArgsPkZip   += tbP+T(psttShortNew) ;
                    tArgsInfoZip += tbP+T(psttShortNew) ;
                    //etherP.traceF( tin0P , T("moved [old]:    ")+tShort ) ;
                    //etherP.traceF( tin0P , T("moved [new]:    ")+T(psttShortNew) ) ;

                    }
                        etherP.diskMoveFileOrDirF( tin0P , tLongNew , tPathP+tShort , 0 ) ;
                    {

                    //etherP.traceF( tin0P , T("moving from:    ")+tPathP+tShort ) ;
                    //etherP.traceF( tin0P , T("moving to  :    ")+tLongNew ) ;

                    TN( tLongNew , "" ) ; tLongNew = tPathP+T(psttShortNew) ;
                    etherP.strReplaceF( tin0P , psttShortNew , tShort , T("!ideafarm.9.") , T("!ideafarm.a.") , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                    ZE( strokeS* , psttShortNew ) ;
                    _IO_
                {
                else
                }
                    break ;
                    bDoNothing = 1 ;
                    etherP.traceF( tin0P , T("    doing nothing with this prefix") ) ;
                    etherP.traceF( tin0P , T("    ")+tShort ) ;
                    etherP.traceF( tin0P , T("    ")+tShortPrefixP ) ;
                    etherP.traceF( tin0P , T("!exception: not expected for current fileset [tShortPrefix,tShort]:") ) ;
                {
                if( 1 != etherP.strIdF( tin0P , tShortPrefixP , tShort , 1 ) )

                }
                    }
                        }
                            }
                                etherP.traceF( tin0P , T("!exception: could set file time [tShort]:    ")+tShort ) ;
                                bFail = 1 ;
                                POOPRqUIET
                            {
                            if( POOP )

                            //etherP.traceF( tin0P , T("setted  file time to:     ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
                            ((thirdC&)*((tin1S&)tin0P).pEtScratch).setFileTimeF( tin0P , fiWo , &timeDataWrittenP , &timeDataWrittenP , &timeDataWrittenP ) ;
                            //etherP.traceF( tin0P , T("setting file time to:     ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
                        {
                        else
                        }
                            etherP.traceF( tin0P , T("!exception: could not open [tShort]:    ")+tShort ) ;
                            bFail = 1 ;
                            POOPRqUIET
                        {
                        if( POOP )

                        fileC fiWo( tin0P , (strokeS*)( tPathP + tShort ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                        SCOOPS
                        _IO_
                    {
                    IFsCRATCHoK
                    _IO_
                {
                // IOW, ALL FILES IN EACH FILESET ARE DATED ONLY WITH THE TIME MODIFIED VALUE OF THE DATA FILE
                // THIS IS TO SUPPRESS DIFFERENCES IN META DATA ACROSS VOLUMES THAT ARE DUE TO ACCESSING OR DUE TO AD HOC DATA RECOVERY AND MIGRATION ACTIVITIES
                //PS:PERSONALITY: I CLOBBER FILE TIME METADATA SO THAT TIME WRITTEN, ACCESSED, AND CREATED FOR EVERY FILE IN THE FILESET ARE ALL SMUDGED TO THE TIME WRITTEN VALUE OF THE DATA FILE

                //etherP.traceF( tin0P , T("popped [tShort]:    ")+tShort ) ;
                }
                    etherP.delF( tin0P , psttShort ) ;
                    tShort = T(psttShort) ;
                    stShortP >> psttShort ;
                    ZE( strokeS* , psttShort ) ;
                {
                TN( tShort , "" ) ;
                _IO_
            {
            while( !bFail && stShortP )
            ZE( boolT , bDoNothing ) ;
            //etherP.traceF( tin0P , T("popping from stShortP [cPlates]:    ")+TF2(stShortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

            }
                }
                    etherP.delF( tin0P , psttShort ) ;
                    etherP.traceF( tin0P , T("!exception: sink unique failed [psttShort]:    ")+T(psttShort) ) ;
                {
                else
                if( ids ) ; //etherP.traceF( tin0P , T("sinked (aok)  [psttShort]:    ")+T(psttShort) ) ;
                stShortP.sinkF( tin0P , ids , psttShort , flSTACKsINK_UNIQUE , 0 , 0 ) ;
                ZE( countT , ids ) ;
                //etherP.traceF( tin0P , T("sinking       [psttShort]:    ")+T(psttShort) ) ;
                etherP.strMakeF( tin0P , LF , psttShort , tShortTimes ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                _IO_
            {
            if( !bFail )

            }
                }
                    }
                        etherP.traceF( tin0P , T("!exception: could not write the file times metafile") ) ;
                        bFail = 1 ;
                        POOPRqUIET
                    {
                    if( POOP )
                    ((tin1S&)tin0P).pEtScratch->fileWriteF( tin0P , fiTimes , (byteT*)&timeDataWrittenP  , sizeof( timeS ) ) ;
                {
                else
                }
                    etherP.traceF( tin0P , T("!exception: could not create the file times metafile") ) ;
                    bFail = 1 ;
                    POOPRqUIET
                {
                if( POOP )

                fileC fiTimes( tin0P , (strokeS*)( tPathP + tShortTimes ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeF , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 0 , 0 ) ;

                SCOOPS
                _IO_
            {
            IFsCRATCHoK
            TN( tShortTimes , "" ) ; tShortTimes = tShortPrefixP + T("meta.datafiletimes") ;
            etherP.boxZapF( tin0P , tPathP+tShortZip ) ;
            TN( tArgsPkZip   , "" ) ; tArgsPkZip   = T("-max -add -move ") + tShortZip ;
            TN( tArgsInfoZip , "" ) ; tArgsInfoZip = T("-9m "            ) + tShortZip ;

            hoverC hover( tin0P , etherP , tPathP ) ;
        {
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )

        etherP.delF( tin0P , psttShortPrefixNew ) ;
        TN( tShortZip , "" ) ; tShortZip = T(psttShortPrefixNew) + T("fset.zip") ;

        etherP.strReplaceF( tin0P , psttShortPrefixNew , tShortPrefixP , T("!ideafarm.9.") , T("!ideafarm.a.") , 0 , flSTRrEPLACE_null ) ; ___( psttShortPrefixNew ) ;
        ZE( strokeS* , psttShortPrefixNew ) ;

        //etherP.traceF( tin0P , T("flushing with data file time: ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
        _IO_
    {
    else
    }
        etherP.traceF( tin0P , T("!exception: null file time for the fset to be flushed, so doing nothing with these files [cFiles,shortPrefix]:    ")+TF2(stShortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tShortPrefixP ) ;
        _IO_
    {
    else if( !timeDataWrittenP )
    if( !stShortP ) ;
    ZE( boolT , bFail ) ;

    //etherP.traceF( tin0P , T("flushing [tShortPrefixP]:                       ")+tShortPrefixP ) ;
    //etherP.traceF( tin0P , T("                [tPathP]:                       ")+tPathP ) ;

    _IO_
{
boolT flushFileSetF( tin0S& tin0P , etherC& etherP , etherC& etPrimeP , countT& cSetsDoneP , textC& tShortPrefixP , stackC& stShortP , textC& tPathP , textC& tnP , textC& tbP , textC& tb4P , timeS& timeDataWrittenP )

#define CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ( TOCK << 2 )
#define CBdATAbOOKsHORTfILEnAMES           ( TICK << 1 )

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_TOOLmIGRATEaRCHIVEfORMAT9tOfORMATa" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
