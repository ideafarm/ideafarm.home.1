
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    DEL( pJotUnsortedShort ) ;
    }
        }
            etThread.traceF( tinP , T("!exception: walk failed") ) ;
            POOPRqUIET
        {
        if( POOP )

        tinP.pEtScratch->diskWalkF( tinP , cDirs , cFiles , tPathToWalk  , bQuit , flDISKwALK_null , walkCBF , pcArg , 0 , 0 ) ;
        SCOOPS
        _IO_
    {
    IFsCRATCH

    countT pcArg[] = { (countT)&cSetsDone , (countT)(strokeS*)tArchives , (countT)(strokeS*)tYearTest , (countT)&bYear , (countT)&bYearDo , (countT)&tSlash , (countT)&tn , (countT)&tb4 , (countT)&tDot , (countT)&tPath , (countT)&pJotUnsortedShort , (countT)&cYearKidDirectories , (countT)&bArmDoNames , (countT)&tDevice , (countT)&tYear } ;

    TN( tYear , "" ) ;
    ZE( boolT , bArmDoNames ) ;
    ZE( countT , cYearKidDirectories ) ;
    ZE( jotC* , pJotUnsortedShort ) ;
    TN( tPath , "" ) ;
    TN( tDot , "." ) ;
    TN( tb4 , "    " ) ;
    TN( tn , "" ) ;
    TN( tSlash , "/" ) ;
    ZE( boolT , bYearDo ) ;
    ZE( boolT , bYear ) ;
    TN( tYearTest , "2018,2019,2020,2021,2022,2023,2099" ) ;  // E.G. "2011" OR "2012,2013,2014"
    TN( tArchives , "ideafarm.archives" ) ;
    ZE( countT , cSetsDone ) ;
    ZE( boolT , bQuit ) ;

    etThread.traceF( tinP , T("[device]:    ")+tDevice ) ;
    }
        etThread.delF( tinP , psttw ) ;
        tDevice = T(psttw) ;
        etThread.strWordF( tinP , psttw , tPathToWalk , sttq , S1C('/') , - 4 ) ;
        strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        countT idf = 1 ;
        ZE( strokeS* , psttw ) ;
        
        _IO_
    {
    TN( tDevice , "" ) ;

    etThread.traceF( tinP , T("i will walk [path]:    ")+tPathToWalk ) ;
    TN( tPathToWalk , psttPathP ) ;
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs  ) ;
    _IO_
{
else
}
    }
        ++ s ; ether.osSleepF( tinP , TOCK << 2 ) ;

        }
            etThread.delF( tinP , pstt1d ) ;
            }
                }
                    break ;
                    }
                        etThread.delF( tinP , pstta ) ;
                        etThread.ifcHireF( tinP , T("ifcIDaDAM_SCRATCH0f") , 0 , tArgKeyName+T(" ")+T(pstta) , flHIRE_DISPLAYaUTO , nicNameC() ) ;
                        etThread.traceF( tinP , T("hiring [psttArchive]:    ")+T(pstta) ) ;
                        stArchiveDo >> pstta ;
                        ZE( strokeS* , pstta ) ;
                    {
                    while( stArchiveDo )
                {
                if( !bFail && !ether )

                }
                    }
                        }
                            stArchiveDo << pstta ;
                            etThread.strMakeF( tinP , LF , pstta , tArchiveTry ) ; ___( pstta ) ;
                            ZE( strokeS* , pstta ) ;
                        {
                        else if( cFound )
                        }
                            break ;
                            tDeviceFailed = T(psttc1) ;
                            etThread.traceF( tinP , T("!exception: device failed; please power cycle the device: ")+T(psttc1) ) ;
                        {
                        if( bFail )

                        etThread.delF( tinP , pstt1f ) ;
                        }
                            etThread.traceF( tinP , T("    [found]:    ")+T(psttc2) ) ;
                        {
                        FORsTRINGSiN2( pstt1f )
                        etThread.traceF( tinP , T("[cFound,tArchiveTry]:    ")+TF2(cFound,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tArchiveTry ) ;
                        }
                            }
                                bFail = 1 ;
                                POOPRqUIET
                            {
                            if( POOP )
                            cFound = tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1f , tArchiveTry , 0 , flDISKfIND_null , 0 , 0 , 0 , 1 , 0 ) ;
                            SCOOPS
                        {
                        ZE( countT , cFound ) ;
                        ZE( strokeS* , pstt1f ) ;
                        TN( tArchiveTry , "" ) ; tArchiveTry = T(psttc1)+T("ideafarm.archives/wo.ideafarm/") ;
                    {
                    if( !bSkip )

                    if( !tDeviceFailed.csF( tinP ) || !etThread.strCompareF( tinP , psttc1 , tDeviceFailed ) ) bSkip = 0 ;

                    //if( etThread.strCompareF( tinP , psttc1 , T("///d/ideafarm.home.101/devices/ssd4.arc.20240214/") ) ) continue ; //U:: TO FIND A BUG
                    //etThread.traceF( tinP , psttc1 ) ;
                {
                FORsTRINGSiN1( pstt1d )
                boolT bSkip = 1 ;
            {
            else
            }
                etThread.traceF( tinP , T("!exception: could not obtain device list") ) ;
            {
            if( bFail )
            }
                }
                    bFail = 1 ;
                    POOPRqUIET
                {
                if( POOP )
                tinP.pEtScratch->diskFindFileOrDirF( tinP , pstt1d , tLongDevices , 0 , flDISKfIND_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1d ) ;
                SCOOPS
            {
            ZE( boolT , bFail ) ;
            ZE( strokeS* , pstt1d ) ;
            TN( tLongDevices , "///d/ideafarm.home.101/devices/" ) ;
            stackC stArchiveDo( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
            _IO_
        {
        IFsCRATCH
        _IO_
    {
    while( !ether )
    TN( tDeviceFailed , "" ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    _IO_
{
if( !psttPathP )

}
    }
        }
            break ;
            etThread.strMakeF( tinP , LF , psttPathP , psttc1 ) ; ___( psttPathP ) ;
            bArmed = 0 ;
        {
        else if( bArmed )
        if( !etThread.strCompareF( tinP , psttc1 , tArgKeyName ) ) bArmed = 1 ;
        etThread.traceF( tinP , T("param: ")+T(psttc1) ) ;
        _IO_
    {
    FORsTRINGSiN1( pstt1Param )
    ZE( boolT , bArmed ) ;
    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tinP ) ;
    _IO_
{
ZE( strokeS* , psttPathP ) ;
TN( tArgKeyName , "!path" ) ;

TODO

}
    return 0 ;

    }
        }
            }
                }
                    if( !( ( idJot & ~NM_HIGH ) % TUCK ) ) etherP.traceF( tinP , T("jotted [idJot,tShort]:    ")+TF2(idJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4P+tShortNew ) ;
                    countT idJot = pJotUnsortedShortP->writeF( tinP , tShortNew , tShortNew.csF( tinP ) + 1 , 0 , 0 ) ;
                    _IO_
                {
                if( tShortNew.csF( tinP ) )

                }
                    }
                        }
                            }
                                tShortNew = tnP ;
                                etherP.traceF( tinP , T("!exception: could not move to eliminate underscore ; file will be ignored") ) ;
                                POOPRqUIET
                            {
                            if( POOP )

                            THREADmODE2rESTORE
                            tinP.pEtScratch->diskMoveFileOrDirF( tinP , tLongNew , tPathP+tShort , 1 ) ;
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                            SCOOPS
                            _IO_
                        {
                        IFsCRATCH

                        etherP.traceF( tinP , T("to eliminate underscore, moving from:    ")+tPathP+tShort ) ;
                        etherP.traceF( tinP , T("to eliminate underscore, moving to  :    ")+tLongNew ) ;
                    {
                    if( cHits )

                    TN( tLongNew , "" ) ; tLongNew = tPathP+tShortNew ;
                    etherP.delF( tinP , psttShortNew ) ;
                    tShortNew = T(psttShortNew) ;
                    countT cHits = etherP.strReplaceF( tinP , psttShortNew , tShort , T("_20") , T(".20") , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                    ZE( strokeS* , psttShortNew ) ;
                    _IO_
                {
                TN( tShortNew , "" ) ;
            {
            else if( !etherP.strIdF( tinP , T(".fset.zip") , tShort ) )
            }
                etherP.traceF( tinP , T("!exception: zapped  unexpected file [tLong]:    ")+tPathP+tShort ) ;
                etherP.boxZapF( tinP , tPathP+tShort ) ;
                etherP.traceF( tinP , T("!exception: zapping unexpected file [tLong]:    ")+tPathP+tShort ) ;
                _IO_
            {
            else if( etherP.strIdF( tinP , T(".meta.datafiletimes") , tShort ) )
            }
                etherP.delF( tinP , psttShortNew ) ;
                if( cHits ) etherP.diskMoveFileOrDirF( tinP , tPath+T(psttShortNew) , tPath+tShort , 0 ) ;
                countT cHits = etherP.strReplaceF( tinP , psttShortNew , tShort , T("!ideafarm.9.") , T("!ideafarm.a.") , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                ZE( strokeS* , psttShortNew ) ;
                //CS:CODEsYNC: DUPLICATE CODE: 5101200f 5101200f
                _IO_
            {
            else if( etherP.strIdF( tinP , T(".!.control.") , tShort ) )
            }
                _IO_
                etherP.traceF( tinP , T("!exception: file ignored (name does not begin with !ideafarm.) [tLong]:    ")+tPathP+tShort ) ;
            {
            if( 1 != etherP.strIdF( tinP , T("!ideafarm.") , tShort ) )

            else { __NZ( etherP.strCompareF( tinP , tPath , tPathP ) ) ; }
            }
                //etherP.traceF( tinP , T("walkCBF set [tPathP]:    ")+tPathP ) ;
                tPathP = tPath ;
                _IO_
            {
            if( !tPathP.csF( tinP ) )

            //etherP.traceF( tinP , T("inspecting file [tShort]:    ")+tShort ) ;
            }
                etherP.delF( tinP , psttShort ) ;
                etherP.delF( tinP , psttPath ) ;
                tShort = T(psttShort) ;
                tPath  = T(psttPath) ;
                etherP.strBisectF( tinP , psttPath , psttShort , tName , tSlashP , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                ZE( strokeS* , psttShort ) ;
                ZE( strokeS* , psttPath ) ;
                _IO_
            {
            TN( tShort , "" ) ;
            TN( tPath  , "" ) ;

            //etherP.traceF( tinP , T("walkCBF [tFile]:    ")+tName ) ;
            TN( tName , ifName ) ;
            ifFileNameC ifName( tinP , *tinP.pEther , postNameP ) ;
            _IO_
        {
        else if( bYearP && bYearDoP /*&& !cSetsDoneP*/ )
        }
            }
                }
                    pJotUnsortedShortP = new( 0 , tinP , LF ) jotC( tinP , tPart2 , flJOTc_PRIVATE | flJOTc_DELETE | flJOTc_WRITE | flJOTc_PURGEoNcT | flJOTc_PATCHbOOKSfLAGStOpURGEoNdT , 1 , CBdATAbOOKsHORTfILEnAMES , CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ) ; ___( pJotUnsortedShortP ) ;
                    TN( tPart2  , "" ) ; tPart2  = T("migrate.unsorted.short.filenames.")+tDeviceP+tDotP+tYearP ;

                    bYearDoP = 1 ;
                    etherP.traceF( tinP , T("year to do:    ")+tYearP ) ;
                {
                if( !psttYearTestP->idAdam || etherP.strIdF( tinP , tYearP , psttYearTestP , 1 ) )

                etherP.traceF( tinP , T("year      :    ")+tYearP ) ;
                }
                    etherP.delF( tinP , psttYear ) ;
                    tYearP  = T(psttYear) ;

                    etherP.delF( tinP , psttnu ) ;
                    etherP.delF( tinP , psttYearSlash ) ;
                    etherP.strBisectF( tinP , psttYear , psttnu , psttYearSlash , tSlashP , - 1 , flSTRbISECT_null ) ; ___( psttYear ) ; ___( psttnu ) ;
                    ZE( strokeS* , psttYear ) ;

                    etherP.delF( tinP , psttnu ) ;
                    etherP.strBisectF( tinP , psttnu , psttYearSlash , tArchivesSlashArchiveSlashYearSlash , tSlashP , - 2 , flSTRbISECT_null ) ; ___( psttYearSlash ) ; ___( psttnu ) ;
                    ZE( strokeS* , psttYearSlash ) ;
                    ZE( strokeS* , psttnu ) ;
                {

                bYearP = 1 ;
                //etherP.traceF( tinP , T("year:    ")+tArchivesSlashArchiveSlashYearSlash ) ;
                _IO_
            {
            else
            }
                bYearDoP = bYearP = 0 ;
                if( bYearDoP || cYearKidDirectoriesP ) cYearKidDirectoriesP ++ ;
                _IO_
            {
            if( 1 != etherP.strIdF( tinP , psttzArchivesP , tArchivesSlashArchiveSlashYearSlash , 1 ) )

            //etherP.traceF( tinP , T("directory [tArchivesSlashArchiveSlashYearSlash]:    ")+tArchivesSlashArchiveSlashYearSlash ) ;
            }
                etherP.delF( tinP , psttnu ) ;
                etherP.delF( tinP , psttArchivesSlashArchiveSlashYearSlash ) ;

                tArchivesSlashArchiveSlashYearSlash  = T(psttArchivesSlashArchiveSlashYearSlash) ;
                etherP.strBisectF( tinP , psttnu , psttArchivesSlashArchiveSlashYearSlash , tName , tSlashP , - 4 , flSTRbISECT_null ) ; ___( psttArchivesSlashArchiveSlashYearSlash ) ; ___( psttnu ) ;
                ZE( strokeS* , psttArchivesSlashArchiveSlashYearSlash ) ;
                ZE( strokeS* , psttnu ) ;
                _IO_
            {
            TN( tArchivesSlashArchiveSlashYearSlash , "" ) ;

            //etherP.traceF( tinP , T("walkCBF [tDirectory]:    ")+tName ) ;
            TN( tName , ifName ) ;
            ifFileNameC ifName( tinP , etherP , postNameP ) ;
            _IO_
        {
        else if( postNameP[ thirdC::c_strlenIF( tinP , postNameP ) - 1 ] == '\\' ) // IF DIRECTORY
        }
            }
                bYearDoP = bYearP = 0 ;
                tPathP = tnP ;

                DEL( pJotSortedShort ) ;
                }
                    //etherP.traceF( tinP , T("processed  sorted short names") ) ;
                    consumeSortedShortF( tinP , etherP , etPrime , *(boolT*)&bQuitP , *pJotSortedShort , tPathP , cSetsDoneP ) ;
                    //etherP.traceF( tinP , T("processing sorted short names") ) ;
                {
                if( !bQuitP )

                }
                    etherP.delF( tinP , psttName ) ;
                    DEL( pJotUnsortedShortP ) ;
                    if( pJotUnsortedShortP ) pJotUnsortedShortP->flagsCtRefF() |= flJOTc_PATCHbOOKSfLAGStOpURGEoNdT ;
                    if( !bQuitP && etPrime ) *(boolT*)&bQuitP = 1 ;
                    if( pJotSortedShort ) pJotSortedShort->flagsCtRefF() |= flJOTc_PATCHbOOKSfLAGStOpURGEoNdT ;
                    sortF( tinP , etherP , etPrime , pJotSortedShort , *pJotUnsortedShortP , psttName , T("migrate.sorted.short.filenames.")+tDeviceP+tDotP+tYearP , CBdATAbOOKsHORTfILEnAMES , CiNDEXeNTRIESpERbOOKsHORTfILEnAMES , TUCK << 0 , flSORTERc_SILENTLYsUPPRESSdUPLICATES , flJOTc_null , cShortNames , 0 ) ; ___( pJotSortedShort ) ;
                    ZE( strokeS* , psttName ) ;
                    //etherP.traceF( tinP , T("sorting short names [cShortNames]:    ")+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( !bQuitP )
                ZE( jotC* , pJotSortedShort ) ;

                pJotUnsortedShortP->resetLathReadF() ;
                }
                    //etherP.traceF( tinP , T("unsorted [tShort]:    ")+tShort ) ;
        
                    }
                        }
                            *(boolT*)&bQuitP = 1 ;
                            etherP.traceF( tinP , T("!exception: could not obtain blob so aborting") ) ;
                        {
                        else        
                        if( pbIn ) tShort = T(pbIn) ;
                        const byteT* pbIn = pageIn ;
                        pageC pageIn = *pJotUnsortedShortP ;
                    {
                    TN( tShort , "" ) ;
        
                    _IO_
                {
                while( cDo -- )
                countT cDo = cShortNames ;
                countT cShortNames = pJotUnsortedShortP->cElementsF() ;

                bArmDoNamesP = 0 ;
                _IO_
            {
            else if( ( bYearP && bYearDoP ) || bArmDoNamesP )
            }
                bYearDoP = bYearP = 1 ;
                bArmDoNamesP = 1 ;
                _IO_
            {
            if( cYearKidDirectoriesP && !( -- cYearKidDirectoriesP ) )
            _IO_
        {
        if( !postNameP )
        _IO_
    {
    if( !bQuitP && !POOP )

    //etherP.traceF( tinP , T("walkCBF ++++ [tPathP]:    ")+tPathP ) ;

    //etherP.traceF( tinP , T("walkCBF [tDeviceP,tYearP,postNameP]:    ")+tDeviceP+tb4P+tYearP+tb4P+T(postNameP) ) ;

    if( etPrime ) *(boolT*)&bQuitP = 1 ;

    textC&         tYearP               =        *(textC*)pcArgP[ 0x0e ] ;
    textC&         tDeviceP             =        *(textC*)pcArgP[ 0x0d ] ;
    boolT&         bArmDoNamesP         =        *(boolT*)pcArgP[ 0x0c ] ;
    countT&        cYearKidDirectoriesP =       *(countT*)pcArgP[ 0x0b ] ;
    jotC*&         pJotUnsortedShortP   =        *(jotC**)pcArgP[ 0x0a ] ;
    textC&         tPathP               =        *(textC*)pcArgP[ 0x09 ] ;
    textC&         tDotP                =        *(textC*)pcArgP[ 0x08 ] ;
    textC&         tb4P                 =        *(textC*)pcArgP[ 0x07 ] ;
    textC&         tnP                  =        *(textC*)pcArgP[ 0x06 ] ;
    textC&         tSlashP              =        *(textC*)pcArgP[ 0x05 ] ;
    boolT&         bYearDoP             =        *(boolT*)pcArgP[ 0x04 ] ;
    boolT&         bYearP               =        *(boolT*)pcArgP[ 0x03 ] ;
    const strokeS* psttYearTestP        = (const strokeS*)pcArgP[ 0x02 ] ;
    const strokeS* psttzArchivesP       = (const strokeS*)pcArgP[ 0x01 ] ;
    countT&        cSetsDoneP           =       *(countT*)pcArgP[ 0x00 ] ;

    etherC& etPrime = etherC::etPrimeIF() ;
    etherC& etherP = *tinP.pEther ;
    _IO_
{
boolT walkCBF( tinS& tinP , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )

}
    if( stShort && !bQuitP && !etPrimeP ) bQuitP = flushFileSetF( tinP , etherP , etPrimeP , cSetsDoneP , tShortPrefixLag , stShort , tPathP , tn , tb , tb4 , timeDataWritten ) ;

    jotSortedShortP.resetLathReadF() ;
    }
        }
            }
                etherP.delF( tinP , pstt1w ) ;
                }
                    }
                        }
                            bQuitP = 1 ;
                            etherP.delF( tinP , psttShort ) ;
                            etherP.traceF( tinP , T("!exception: could not sink ; aborting [psttShort]:    ")+T(psttShort) ) ;
                        {
                        else
                        if( ids ) ; //etherP.traceF( tinP , T("sinked (aok)  [psttShort]:    ")+T(psttShort) ) ;
                        stShort.sinkF( tinP , ids , psttShort , flSTACKsINK_UNIQUE , 0 , 0 ) ;
                        ZE( countT , ids ) ;
                        //etherP.traceF( tinP , T("sinking       [psttShort]:    ")+T(psttShort) ) ;
                        etherP.strMakeF( tinP , LF , psttShort , tShort ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        //etherP.traceF( tinP , T("about to push [tShort]:    ")+tShort ) ;
                        // IF GET HERE THEN THIS FILE IS ACCEPTED AS A MEMBER OF A FORMAT 9 FILESET
                    {
                    else
                    }
                        bQuitP = 1 ;
                        etherP.delF( tinP , psttShortNew ) ;
                        if( cHits ) etherP.diskMoveFileOrDirF( tinP , tPathP+T(psttShortNew) , tPathP+tShort , 0 ) ;
                        countT cHits = etherP.strReplaceF( tinP , psttShortNew , tShort , T("!ideafarm.9.") , T("!ideafarm.a.") , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                        ZE( strokeS* , psttShortNew ) ;
                        //CS:CODEsYNC: DUPLICATE CODE: 5101200f 5101200f
                    {
                    if( bFail )

                    }
                        if( bFail ) break ;

                        }
                            }
                                break ;

                                }
                                    }
                                        }
                                            }
                                                etherP.traceF( tinP , T("!exception: could not get file time [tShort]:    ")+tShort ) ;
                                                bFail = 1 ;
                                                POOPRqUIET
                                            {
                                            if( POOP )

                                            //etherP.traceF( tinP , T("      data file time written: ")+TT(timeDataWritten.time1,timeDataWritten.time2) ) ;
                                            thirdC::getFileTimeIF( tinP , fiWo , &timeDataWritten , 0 , 0 ) ;
                                            timeDataWritten = timeS() ;
                                        {
                                        else
                                        }
                                            etherP.traceF( tinP , T("!exception: could not open data file [tShort]:    ")+tShort ) ;
                                            bFail = 1 ;
                                            POOPRqUIET
                                        {
                                        if( POOP )

                                        fileC fiWo( tinP , (strokeS*)( tPathP+tShort ) , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 , 0 ) ;

                                        SCOOPS
                                        _IO_
                                    {
                                    IFsCRATCH
                                    _IO_
                                {
                                if( bData )

                                bFail = !bData && !bMeta ;
                                boolT bMeta = !etherP.strCompareF( tinP , psttc1 , tMeta ) ;
                                boolT bData = !etherP.strCompareF( tinP , psttc1 , tData ) ;
                            {
                            case 0xa :
                            }
                                break ;
                                bFail = psttc1->idAdam != 3 ;
                            {
                            case 0x9 :
                            }
                                break ;
                                bFail = psttc1->idAdam != 0x20 ;
                            {
                            case 0x8 :
                            }
                                break ;
                                bFail = psttc1->idAdam != 0xd ;
                            {
                            case 0x7 :
                            case 0x6 :
                            }
                                break ;
                                bFail = psttc1->idAdam != 8 ;
                            {
                            case 0x5 :
                            case 0x4 :
                            }
                                break ;
                                bFail = !!etherP.strCompareF( tinP , psttc1 , t2 ) ;
                            {
                            case 0x3 :
                            }
                                break ;
                                bFail = etherP.strCompareF( tinP , psttc1 , t9 ) && etherP.strCompareF( tinP , psttc1 , ta ) ;
                            {
                            case 0x2 :
                            }
                                break ;
                                bFail = !!etherP.strCompareF( tinP , psttc1 , tHeyIdeaFarm ) ;
                            {
                            case 0x1 :
                        {
                        switch( ++ idw )
                        //etherP.traceF( tinP , tb4+T(psttc1) ) ;
                        _IO_
                    {
                    FORsTRINGSiN1( pstt1w )
                    ZE( countT , idw ) ;
                    ZE( boolT , bFail ) ;
                    _IO_
                {
                else
                }
                    etherP.delF( tinP , psttShortNew ) ;
                    if( cHits ) etherP.diskMoveFileOrDirF( tinP , tPathP+T(psttShortNew) , tPathP+tShort , 0 ) ;
                    countT cHits = etherP.strReplaceF( tinP , psttShortNew , tShort , T("!ideafarm.9.") , T("!ideafarm.a.") , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                    ZE( strokeS* , psttShortNew ) ;
                    _IO_
                {
                if( cWords < 0xb )
                //etherP.traceF( tinP , T("cWords:    ")+TF2(cWords,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                countT cWords = etherP.strWordsF( tinP , pstt1w , tShort , sttq , tDot , flSTRwORDS_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1w ) ;
                strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                ZE( strokeS* , pstt1w ) ;

                // b    jpg
                // a    data
                // 9    001
                // 8    2a24e441984f7650ef8982bc85155e1c
                // 7    20170131@0012
                // 6    00000000@0000
                // 5    00000001
                // 4    00000000
                // 3    2
                // 2    9
                // 1   !ideafarm
                //
                // !ideafarm.9.2.00000000.00000001.00000000@0000.20170131@0012.2a24e441984f7650ef8982bc85155e1c.001.data.jpg
                // EXPECTED INPUT, PARSED TO WORDS
                _IO_
            {
            if( !POOP )
            _IO_
        {

        }
            break ;
            bQuitP = 1 ;
            _IO_
        {
        if( bTimeToQuit )
                                                                        
        }
            }
                tShortPrefixLag = tShortPrefix ;
                bTimeToQuit = flushFileSetF( tinP , etherP , etPrimeP , cSetsDoneP , tShortPrefixLag , stShort , tPathP , tn , tb , tb4 , timeDataWritten ) ;
                _IO_
            {
            else if( stShort )
            if( !tShortPrefixLag.csF( tinP ) ) tShortPrefixLag = tShortPrefix ;
            //etherP.traceF( tinP , T("the prefix has changed") ) ;

            bTimeToQuit = !!etPrimeP ;     // THE INTENTION IS TO QUIT ONLY AT FILESET BOUNDARY, SO I INSPECT ether HERE
            _IO_
        {
        if( etherP.strCompareF( tinP , tShortPrefix , tShortPrefixLag ) )     //U:: THIS CODE ERRONEOUSLY ASSUMES THAT THE FILE SYSTEM (E.G. NTFS) WILL PRESENT THE FILES IN SORTED ORDER; THESE NAMES NEED TO BE SORTED BEFORE PROCESSING THEM INTO FILESETS (LIKE HEAL DOES)
        ZE( boolT , bTimeToQuit ) ;

        //etherP.traceF( tinP , T("the prefix of this file is:                     ")+tShortPrefix ) ;
        }
            etherP.delF( tinP , psttnu ) ;
            etherP.delF( tinP , psttShortPrefix ) ;
    
            tShortPrefix  = T(psttShortPrefix) ;
            etherP.strBisectF( tinP , psttShortPrefix , psttnu , tShort , tDot , 9 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttShortPrefix ) ; ___( psttnu ) ;                                      // tDot
            ZE( strokeS* , psttnu ) ;
            ZE( strokeS* , psttShortPrefix ) ;
            _IO_
        {
        TN( tShortPrefix  , "" ) ;

        etherP.traceF( tinP , T("consuming sorted [tShort]:    ")+tShort ) ;
        
        }
            }
                break ;
                bQuitP = 1 ;
                etherP.traceF( tinP , T("!exception: could not obtain blob so aborting") ) ;
            {
            else        
            if( pbIn ) tShort = T(pbIn) ;
            const byteT* pbIn = pageIn ;
            pageC pageIn = jotSortedShortP ;
            _IO_
        {
        TN( tShort , "" ) ;

        // /*if( !( cDo % ( TUCK >> 5 ) ) )*/ etherP.traceF( tinP , T("processing sorted short names [cShortNames,cRemaining]:    ")+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cDo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        
        _IO_
    {
    while( !etPrimeP && !bQuitP && cDo -- )
    etherP.traceF( tinP , T("beginning to process sorted short names [cShortNames,tPathP]:    ")+TF2(cShortNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tPathP ) ;
    timeS timeDataWritten ;
    stackC stShort( tinP , etherP , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
    TN( tShortPrefixLag  , "" ) ;
    TN( t2 , "2" ) ;
    TN( ta , "a" ) ;
    TN( t9 , "9" ) ;
    TN( tHeyIdeaFarm , "!ideafarm" ) ;
    TN( tDot , "." ) ;
    TN( tMeta , "meta" ) ;
    TN( tData , "data" ) ;
    TN( tb4 , "    " ) ;
    TN( tb , " " ) ;
    TN( tn           , "" ) ;
    countT cDo = cShortNames ;
    countT cShortNames = jotSortedShortP.cElementsF() ;
    _IO_
{
voidT consumeSortedShortF( tinS& tinP , etherC& etherP , etherC& etPrimeP , boolT& bQuitP , jotC& jotSortedShortP , textC& tPathP , countT& cSetsDoneP )

}
    return bFail ;
                                                 //OFFLINE FAILURES OBSERVED, SO:                   20240304@0810: "<< 1"
                                                 //                                                 20240303@1028: "<< 0"
    etPrimeP.osSleepF( tinP , TOCK << 1 ) ;      //GIVE THE VOLUME TIME TO COMPLETE ITS I/O FLUSH ; 20240301@0917: "<< 1"
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    etherP.traceF( tinP , T("napping" ) ) ;

    tShortPrefixP    = tnP     ;
    //etherP.traceF( tinP , T("flushed  [tShortPrefixP]:                       ")+tShortPrefixP ) ;

    timeDataWrittenP = timeS() ;
    //etherP.traceF( tinP , T("purged  stShortP [cPlates]:    ")+TF2(stShortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    stShortP.purgeF( tinP ) ;
    //etherP.traceF( tinP , T("purging stShortP [cPlates]:    ")+TF2(stShortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    }
        }
            //etherP.traceF( tinP , T("flush [cDone]:    ")+TF2(cDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            countT cDone = 1 + incv02AM( cSetsDoneP ) ;

            }
                THREADmODE2rESTORE
                //etherP.traceF( tinP , T("setted  zip file time to:     ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
                ((thirdC&)etherP).setFileTimeF( tinP , fiZip , &timeDataWrittenP , &timeDataWrittenP , &timeDataWrittenP ) ;
                //etherP.traceF( tinP , T("setting zip file time to:     ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
                fileC fiZip(   tinP , (strokeS*)( tPathP+tShortZip ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 0 , 0 ) ;
                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                _IO_
            {

            //etherP.traceF( tinP , T("called  disZipF [tArgsPkZip]:    ")+tArgsPkZip ) ;
            }
                THREADmODE2rESTORE
                etherP.diskZipF( tArgsInfoZip , tinP , tArgsPkZip ) ;
                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                _IO_
            {
        {
        if( !bFail && !bDoNothing )

        //etherP.traceF( tinP , T("calling disZipF [tArgsPkZip]:    ")+tArgsPkZip ) ;
        }
            }
                etherP.delF( tinP , psttShortNew ) ;

                tArgsPkZip   += tbP+T(psttShortNew) ;
                tArgsInfoZip += tbP+T(psttShortNew) ;
                //etherP.traceF( tinP , T("moved [old]:    ")+tShort ) ;
                //etherP.traceF( tinP , T("moved [new]:    ")+T(psttShortNew) ) ;

                }
                    THREADmODE2rESTORE
                    etherP.diskMoveFileOrDirF( tinP , tLongNew , tPathP+tShort , 0 ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                {

                //etherP.traceF( tinP , T("moving from:    ")+tPathP+tShort ) ;
                //etherP.traceF( tinP , T("moving to  :    ")+tLongNew ) ;

                TN( tLongNew , "" ) ; tLongNew = tPathP+T(psttShortNew) ;
                etherP.strReplaceF( tinP , psttShortNew , tShort , T("!ideafarm.9.") , T("!ideafarm.a.") , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                ZE( strokeS* , psttShortNew ) ;
                _IO_
            {
            else
            }
                break ;
                bDoNothing = 1 ;
                etherP.traceF( tinP , T("    doing nothing with this prefix") ) ;
                etherP.traceF( tinP , T("    ")+tShort ) ;
                etherP.traceF( tinP , T("    ")+tShortPrefixP ) ;
                etherP.traceF( tinP , T("!exception: not expected for current fileset [tShortPrefix,tShort]:") ) ;
            {
            if( 1 != etherP.strIdF( tinP , tShortPrefixP , tShort , 1 ) )

            }
                THREADmODE2rESTORE
                }
                    }
                        }
                            etherP.traceF( tinP , T("!exception: could set file time [tShort]:    ")+tShort ) ;
                            bFail = 1 ;
                            POOPRqUIET
                        {
                        if( POOP )

                        //etherP.traceF( tinP , T("setted  file time to:     ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
                        ((thirdC&)*tinP.pEtScratch).setFileTimeF( tinP , fiWo , &timeDataWrittenP , &timeDataWrittenP , &timeDataWrittenP ) ;
                        //etherP.traceF( tinP , T("setting file time to:     ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
                    {
                    else
                    }
                        etherP.traceF( tinP , T("!exception: could not open [tShort]:    ")+tShort ) ;
                        bFail = 1 ;
                        POOPRqUIET
                    {
                    if( POOP )

                    fileC fiWo( tinP , (strokeS*)( tPathP + tShort ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR_null , flFILEc_null , 1 , 0 ) ;

                    SCOOPS
                    _IO_
                {
                IFsCRATCH
                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                _IO_
            {
            // IOW, ALL FILES IN EACH FILESET ARE DATED ONLY WITH THE TIME MODIFIED VALUE OF THE DATA FILE
            // THIS IS TO SUPPRESS DIFFERENCES IN META DATA ACROSS VOLUMES THAT ARE DUE TO ACCESSING OR DUE TO AD HOC DATA RECOVERY AND MIGRATION ACTIVITIES
            //PS:PERSONALITY: I CLOBBER FILE TIME METADATA SO THAT TIME WRITTEN, ACCESSED, AND CREATED FOR EVERY FILE IN THE FILESET ARE ALL SMUDGED TO THE TIME WRITTEN VALUE OF THE DATA FILE

            //etherP.traceF( tinP , T("popped [tShort]:    ")+tShort ) ;
            }
                etherP.delF( tinP , psttShort ) ;
                tShort = T(psttShort) ;
                stShortP >> psttShort ;
                ZE( strokeS* , psttShort ) ;
            {
            TN( tShort , "" ) ;
            _IO_
        {
        while( !bFail && stShortP )
        ZE( boolT , bDoNothing ) ;
        //etherP.traceF( tinP , T("popping from stShortP [cPlates]:    ")+TF2(stShortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        }
            }
                etherP.delF( tinP , psttShort ) ;
                etherP.traceF( tinP , T("!exception: sink unique failed [psttShort]:    ")+T(psttShort) ) ;
            {
            else
            if( ids ) ; //etherP.traceF( tinP , T("sinked (aok)  [psttShort]:    ")+T(psttShort) ) ;
            stShortP.sinkF( tinP , ids , psttShort , flSTACKsINK_UNIQUE , 0 , 0 ) ;
            ZE( countT , ids ) ;
            //etherP.traceF( tinP , T("sinking       [psttShort]:    ")+T(psttShort) ) ;
            etherP.strMakeF( tinP , LF , psttShort , tShortTimes ) ; ___( psttShort ) ;
            ZE( strokeS* , psttShort ) ;
            _IO_
        {
        if( !bFail )

        THREADmODE2rESTORE
        }
            }
                }
                    etherP.traceF( tinP , T("!exception: could not write the file times metafile") ) ;
                    bFail = 1 ;
                    POOPRqUIET
                {
                if( POOP )
                tinP.pEtScratch->fileWriteF( tinP , fiTimes , (byteT*)&timeDataWrittenP  , sizeof( timeS ) ) ;
            {
            else
            }
                etherP.traceF( tinP , T("!exception: could not create the file times metafile") ) ;
                bFail = 1 ;
                POOPRqUIET
            {
            if( POOP )

            fileC fiTimes( tinP , (strokeS*)( tPathP + tShortTimes ) , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeF , flFILEaTTR_null , flFILEc_null , 0 , 0 ) ;

            SCOOPS
            _IO_
        {
        IFsCRATCH
        TN( tShortTimes , "" ) ; tShortTimes = tShortPrefixP + T("meta.datafiletimes") ;
        etherP.boxZapF( tinP , tPathP+tShortZip ) ;
        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        TN( tArgsPkZip   , "" ) ; tArgsPkZip   = T("-max -add -move ") + tShortZip ;
        TN( tArgsInfoZip , "" ) ; tArgsInfoZip = T("-9m "            ) + tShortZip ;


        hoverC hover( tinP , etherP , tPathP ) ;

        etherP.delF( tinP , psttShortPrefixNew ) ;
        TN( tShortZip , "" ) ; tShortZip = T(psttShortPrefixNew) + T("fset.zip") ;

        etherP.strReplaceF( tinP , psttShortPrefixNew , tShortPrefixP , T("!ideafarm.9.") , T("!ideafarm.a.") , 0 , flSTRrEPLACE_null ) ; ___( psttShortPrefixNew ) ;
        ZE( strokeS* , psttShortPrefixNew ) ;

        //etherP.traceF( tinP , T("flushing with data file time: ")+TT(timeDataWrittenP.time1,timeDataWrittenP.time2) ) ;
        _IO_
    {
    else
    }
        etherP.traceF( tinP , T("!exception: null file time for the fset to be flushed, so doing nothing with these files [cFiles,shortPrefix]:    ")+TF2(stShortP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+tShortPrefixP ) ;
        _IO_
    {
    else if( !timeDataWrittenP )
    if( !stShortP ) ;
    ZE( boolT , bFail ) ;

    //etherP.traceF( tinP , T("flushing [tShortPrefixP]:                       ")+tShortPrefixP ) ;
    //etherP.traceF( tinP , T("                [tPathP]:                       ")+tPathP ) ;

    _IO_
{
boolT flushFileSetF( tinS& tinP , etherC& etherP , etherC& etPrimeP , countT& cSetsDoneP , textC& tShortPrefixP , stackC& stShortP , textC& tPathP , textC& tnP , textC& tbP , textC& tb4P , timeS& timeDataWrittenP )

#define CiNDEXeNTRIESpERbOOKsHORTfILEnAMES ( TOCK << 2 )
#define CBdATAbOOKsHORTfILEnAMES           ( TICK << 1 )

/*1*/WAKEhIDE( "ifcIDaDAM_TOOLmIGRATEaRCHIVEfORMAT9tOfORMATa" )/*1*/
///*1*/WAKEdEBUGsHOWtEXT( "ifcIDaDAM_TOOLmIGRATEaRCHIVEfORMAT9tOfORMATa" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
