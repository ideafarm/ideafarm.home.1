
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK << 0 ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        etThread.diskFileOrDirDeleteF( tin0P , tFolderMyEvents ) ;
        }
            while( !ether && ~hFind && !POOP ) ;
            }
                DEL( pInfo ) ;
                }
                    }
                        etThread.traceF( tin0P , (!F(flagsFail)?T("aok"):T("flagsFail:")+TF2(flagsFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)) ) ;

                        }
                            }
                                ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;                    //THIS ENSURES THAT I DON'T PEG CPU BY RETRYING ; I AM SPRINKLED OVER CODE WITHOUT ANALYSIS
                                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                                flagsFail |= flFAIL_COULDnOTmOVEfILE ;
                                POOPR
                            {
                            if( POOP )
                            ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tWhere+tShort , tIfoName ) ;

                            SCOOPS
                        {
                        IFsCRATCHoK

                        ;
                            : tSharedFolderEventDone
                            ? tSharedFolderEventRetryLater
                        TN( tWhere , "" ) ; tWhere = F(flagsFail)

                        etThread.traceF( tin0P , T("moving the file") ) ;

                        etThread.traceF( tin0P , T("cleaning up 3") ) ;

                        }
                            ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;                    //THIS ENSURES THAT I DON'T PEG CPU BY RETRYING ; I AM SPRINKLED OVER CODE WITHOUT ANALYSIS
                            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                            etThread.traceF( tin0P , T("unknown error") ) ;
                            flagsFail |= flFAIL_UNKNOWNeRROR ;
                            POOPR
                        {
                        if( POOP )
                        etThread.traceF( tin0P , T("cleaning up 2") ) ;

                        }
                            etThread.delF( tin0P , psttValueLive           ) ;
                            etThread.delF( tin0P , psttValueIdSubscription ) ;
                            etThread.delF( tin0P , psttValueName           ) ;
                            etThread.delF( tin0P , psttValueEmail          ) ;
                            etThread.delF( tin0P , psttValuePostalCode     ) ;
                            etThread.delF( tin0P , psttValueCountry        ) ;
                            etThread.delF( tin0P , psttValueHawker         ) ;
                            etThread.delF( tin0P , psttValueAge            ) ;
                            etThread.delF( tin0P , psttVersion             ) ;
                            etThread.delF( tin0P , psttEvent               ) ;
                            }
                                }
                                    }
                                        etThread.traceF( tin0P , T("debug / 0") ) ;
                                        etThread.boxPutF( tin0P , T("mail.smtp2go.com/dd9/smtp/factories@ideafarm.com/factoryreports@ideafarm.com/")+T(psttValueEmail)+T("") , tThankYou ) ;
                                        etThread.traceF( tin0P , T("debug / 1") ) ;

                                        }
                                            ) ;

                                                "Be sure to use the same email address so that we can detect duplicate charges and reverse them.\r\n\r\n"
                                                "If you entered your [matrix] username incorrectly, you can submit a new, corrected order.\r\n"
                                                "\r\nWe have been notified and will contact you via email during business hours.\r\n"

                                            tThankYou += T(

                                            }
                                                ) ;

                                                    "    [students and faculty]:    ")+tValueError3+T("\r\n"

                                                tThankYou += T(
                                            {
                                            if( bFail3 )

                                            }
                                                ) ;

                                                    "    [courtship workshops]:     ")+tValueError2+T("\r\n"

                                                tThankYou += T(
                                            {
                                            if( bFail2 )

                                            }
                                                ) ;

                                                    "    [visitors]:                ")+tValueError1+T("\r\n"

                                                tThankYou += T(
                                            {
                                            if( bFail1 )

                                            ) ;

                                                "Your payment has been received but this automated system could not generate some of your invite(s):\r\n\r\n"

                                            tThankYou += T(
                                        {
                                        if( bFail1 || bFail2 || bFail3 )

                                        ) ;
                                            "go to http://admissions.ideafarm.com/ and click: \"[Click here to manage your subscription]\".\r\n"
                                            "unless you think that this email is spam.  To terminate or modify the subscription that you just paid for,\r\n"
                                            "The anti-spam link at the bottom appears at the end of all email sent from IDEAFARM.COM.  Please do NOT click it\r\n"
                                            +tInvitationsSubmitted +T("\r\n\r\n"
                                            "You have been invited to join the following spaces and rooms at The IdeaFarm (tm) College of Imagination Science:\r\n\r\n")
                                            "    [backup codes]:  ")+T("        (You will receive these during your first login, but hopefully will never need them.)\r\n\r\n"
                                            "    [secret phrase]: ")+T("        (You will make this up during your first login and enter it each time you log in.)\r\n"
                                            "Your account will also be secured by the following credentials:\r\n\r\n"
                                            "    [password]:      ")+tNewPassword+T("        (Be sure to change this right away!)\r\n\r\n"
                                            "    [username]:      ")+tNewUserNameShort+T("\r\n"
                                            "Here are your credentials.  You can use them immediately to log in:\r\n\r\n"
                                            "For instructions, see http://admissions.ideafarm.com .\r\n\r\n"
                                            "    [hawker]:        ")+T(psttValueHawker)+T("\r\n\r\n"
                                            "    [age (parsed)]:  ")+TF4(age,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n"
                                            "    [age (raw)]:     ")+T(psttValueAge)+T("\r\n"
                                            "    [email]:         ")+T(psttValueEmail)+T("\r\n"
                                            +T("Payment received for:\r\n\r\n"
                                            "Subject: Notification from IDEAFARM.COM\r\n\r\nThank you for ")+tForWhat

                                        TN( tThankYou , "" ) ; tThankYou = T(

                                        else           tForWhat = T("paying your entry fee for self-monitored chat.\r\n\r\n") ;
                                        if( bStudent ) tForWhat = T("registering as a student on IDEAFARM.COM.\r\n\r\n") ;
                                        TN( tForWhat , "" ) ;
                                        etThread.traceF( tin0P , T("debug / 2") ) ;

                                        }
                                            }
                                                }
                                                    }
                                                        etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                        POOPRqUIET
                                                    {
                                                    if( POOP )
                                                
                                                    etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
                                                
                                                    }
                                                        DEL( pSwPathValue ) ;
                                                
                                                        }
                                                            }
                                                                etThread.delF( tin0P , pstpsttValue ) ;
                                                
                                                                }
                                                                    }
                                                                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                        *pptValue[ offe ] = T(pstpsttValue) ;
                                                                    {
                                                                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                                {
                                                                for( countT offe = 0 ; offe < cPaths ; offe ++ )
                                                
                                                                if( cPaths - cValues ) { BLAMMO ; }
                                                                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
                                                
                                                                //etThread.trace F( tin0P , T("--------------------------        [value]:    ")+T(pstpsttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                //etThread.trace F( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                
                                                                strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                                                
                                                                _IO_
                                                            {
                                                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                        {
                                                        if( !POOP )
                                                
                                                        ;
                                                        }
                                                            &tPathDeviceId     ,
                                                            &tPathAccessToken  ,
                                                        {
                                                        textC* pptPath[] =
                                                
                                                        TN( tPathDeviceId    , "\"device_id\"/"    ) ;
                                                        TN( tPathAccessToken , "\"access_token\"/" ) ;
                                                
                                                        ;
                                                        }
                                                            &tValueDeviceId      ,
                                                            &tValueAccessToken ,
                                                        {
                                                        textC* pptValue[] =
                                                
                                                        __Z( pSwPathValue ) ;
                                                        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                        ZE( switchC* , pSwPathValue ) ;
                                                        ZE( strokeS* , psttPath     ) ;
                                                    {
                                                
                                                    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("json response:") ) ;
                                                
                                                    }
                                                        }
                                                            else if( costj ) break ;
                                                                 if( cNest ) costj ++ ;
                                                
                                                            else if( postj[ costj ] == '}' ) cNest -- ;
                                                                 if( postj[ costj ] == '{' ) cNest ++ ;

                                                            if( !cbIn ) break ;
                                                            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                        {
                                                        for(;;)
                                                        ZE( countT , cNest ) ;
                                                    {
                                                    ZE( countT , costj ) ;
                                                    thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                                                    osTextT postj[ TUCK << 1 ] ;
                                                
                                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("request:") ) ;
                                                
                                                    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/logout HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(0,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;
                                                
                                                    //sockc.connectF( tin0P , 80 , nnServer ) ;
                                                    //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                                
                                                    sockc.connectF( tin0P , 443 , nnServer ) ;
                                                    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                                
                                                    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT timeAllowedConnected = TICK >> 2 ;
                                                
                                                    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                    nicNameC nnServer ;
                                                
                                                    SCOOPS
                                                    _IO_
                                                {
                                                IFsCRATCHoK                                                           // LOGOUT

                                                if( !tInvitationsSubmitted.csF( tin0P ) ) tInvitationsSubmitted = T("    none\r\n") ;
                                                etThread.traceF( tin0P , T("debug / 3") ) ;

                                                }            
                                                    }
                                                        }
                                                            tInvitationsSubmitted += tb4+tNameSpaceAcademic+tcrlf ;
                                                            TN( tNameSpaceAcademic , "Students and Faculty Only (ICIS)" ) ;
                                                        {
                                                        if( !bFail3 )

                                                        }
                                                            bFail3 = 1 ;
                                                            etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                            POOPRqUIET
                                                        {
                                                        if( POOP )
                                                    
                                                        }
                                                            if( !tValueErrorCode3.csF( tin0P ) ) bFail3 = 0 ;
                                                            DEL( pSwPathValue ) ;
                                                            }
                                                                }
                                                                    etThread.delF( tin0P , pstpsttValue ) ;

                                                                    }
                                                                        }
                                                                            etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                            *pptValue[ offe ] = T(pstpsttValue) ;
                                                                        {
                                                                        if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                                    {
                                                                    for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                                    if( cPaths - cValues ) { BLAMMO ; }
                                                                    countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                                    countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                                    strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                                    psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                                    _IO_
                                                                {
                                                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                            {
                                                            if( !POOP )

                                                            //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                                            ;
                                                            }
                                                                &tPathError     ,
                                                                &tPathErrorCode ,
                                                            {
                                                            textC* pptPath[] =

                                                            TN( tPathError     , "\"error\"/"   ) ;
                                                            TN( tPathErrorCode , "\"errcode\"/" ) ;

                                                            ;
                                                            }
                                                                &tValueError3     ,
                                                                &tValueErrorCode3 ,
                                                            {
                                                            textC* pptValue[] =

                                                            __Z( pSwPathValue ) ;
                                                            etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                            ZE( switchC* , pSwPathValue ) ;
                                                            ZE( strokeS* , psttPath     ) ;
                                                        {

                                                        etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                        etThread.traceF( tin0P , T("json response:") ) ;

                                                        }
                                                            }
                                                                else if( costj ) break ;
                                                                     if( cNest ) costj ++ ;
                                                    
                                                                else if( postj[ costj ] == '}' ) cNest -- ;
                                                                     if( postj[ costj ] == '{' ) cNest ++ ;
                                                    
                                                                putchar( postj[ costj ] ) ;

                                                                if( !cbIn ) break ;
                                                                countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                            {
                                                            for(;;)
                                                            ZE( countT , cNest ) ;
                                                        {
                                                        ZE( countT , costj ) ;
                                                        thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                                                        osTextT postj[ TUCK << 1 ] ;
                                                    
                                                        sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                        etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                        etThread.traceF( tin0P , T("request:") ) ;

                                                        TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!CxQXuURdflEEIURQXO:ideafarm.com/invite HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(tBodyInvite.csF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBodyInvite ;
                                                    
                                                        sockc.connectF( tin0P , 443 , nnServer ) ;
                                                        socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                                    
                                                        countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                        countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                        countT timeAllowedConnected = TICK >> 2 ;
                                                    
                                                        nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                        nicNameC nnServer ;
                                                    
                                                        SCOOPS
                                                    {
                                                    IFsCRATCHoK
                                                    _IO_
                                                {
                                                else if( !bFail0 )
                                                if( age < 16 || !bStudent ) bFail3 = 0 ;
                                                TN( tNameSpaceAcademic , "Students and Faculty Only (ICIS)" ) ;    // INVITE TO SPACE
                                                etThread.traceF( tin0P , T("debug / 4") ) ;
                                                
                                                }            
                                                    }
                                                        }
                                                            tInvitationsSubmitted += tb4+tNameSpaceCourtship+tcrlf ;
                                                            TN( tNameSpaceCourtship , "Bait N' Switch Courtship Workshops (ICIS)" ) ;
                                                        {
                                                        if( !bFail2 )

                                                        }
                                                            bFail2 = 1 ;
                                                            etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                            POOPRqUIET
                                                        {
                                                        if( POOP )
                                                    
                                                        }
                                                            if( !tValueErrorCode2.csF( tin0P ) ) bFail2 = 0 ;
                                                            DEL( pSwPathValue ) ;
                                                            }
                                                                }
                                                                    etThread.delF( tin0P , pstpsttValue ) ;

                                                                    }
                                                                        }
                                                                            etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                            *pptValue[ offe ] = T(pstpsttValue) ;
                                                                        {
                                                                        if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                                    {
                                                                    for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                                    if( cPaths - cValues ) { BLAMMO ; }
                                                                    countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                                    countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                                    strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                                    psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                                    _IO_
                                                                {
                                                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                            {
                                                            if( !POOP )

                                                            //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                                            ;
                                                            }
                                                                &tPathError     ,
                                                                &tPathErrorCode ,
                                                            {
                                                            textC* pptPath[] =

                                                            TN( tPathError     , "\"error\"/"   ) ;
                                                            TN( tPathErrorCode , "\"errcode\"/" ) ;

                                                            ;
                                                            }
                                                                &tValueError2     ,
                                                                &tValueErrorCode2 ,
                                                            {
                                                            textC* pptValue[] =

                                                            __Z( pSwPathValue ) ;
                                                            etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                            ZE( switchC* , pSwPathValue ) ;
                                                            ZE( strokeS* , psttPath     ) ;
                                                        {

                                                        etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                        etThread.traceF( tin0P , T("json response:") ) ;

                                                        }
                                                            }
                                                                else if( costj ) break ;
                                                                     if( cNest ) costj ++ ;
                                                    
                                                                else if( postj[ costj ] == '}' ) cNest -- ;
                                                                     if( postj[ costj ] == '{' ) cNest ++ ;
                                                    
                                                                putchar( postj[ costj ] ) ;

                                                                if( !cbIn ) break ;
                                                                countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                            {
                                                            for(;;)
                                                            ZE( countT , cNest ) ;
                                                        {
                                                        ZE( countT , costj ) ;
                                                        thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                                                        osTextT postj[ TUCK << 1 ] ;
                                                    
                                                        sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                        etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                        etThread.traceF( tin0P , T("request:") ) ;
                                                    
                                                        TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!esnkyOGEyeJQlIZGPM:ideafarm.com/invite HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(tBodyInvite.csF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBodyInvite ;
                                                    
                                                        sockc.connectF( tin0P , 443 , nnServer ) ;
                                                        socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                                    
                                                        countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                        countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                        countT timeAllowedConnected = TICK >> 2 ;
                                                    
                                                        nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                        nicNameC nnServer ;
                                                    
                                                        SCOOPS
                                                    {
                                                    IFsCRATCHoK
                                                    _IO_
                                                {
                                                else if( !bFail0 )
                                                if( age < 13 || age > 29 ) bFail2 = 0 ;
                                                etThread.traceF( tin0P , T("debug / 5") ) ;
                                                
                                                }
                                                    }
                                                        }
                                                            tInvitationsSubmitted += tb4+tNameSpaceVisitors+tcrlf ;
                                                            TN( tNameSpaceVisitors , "Visitors (ICIS: The IdeaFarm (tm) College of Imagination Science)" ) ;
                                                        {
                                                        if( !bFail1 )

                                                        }
                                                            bFail1 = 1 ;
                                                            etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                            POOPRqUIET
                                                        {
                                                        if( POOP )
                                                    
                                                        }
                                                            if( !tValueErrorCode1.csF( tin0P ) ) bFail1 = 0 ;
                                                            DEL( pSwPathValue ) ;
                                                            }
                                                                }
                                                                    etThread.delF( tin0P , pstpsttValue ) ;

                                                                    }
                                                                        }
                                                                            etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                            *pptValue[ offe ] = T(pstpsttValue) ;
                                                                        {
                                                                        if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                                    {
                                                                    for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                                    if( cPaths - cValues ) { BLAMMO ; }
                                                                    countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                                    countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                                    strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                                    psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                                    _IO_
                                                                {
                                                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                            {
                                                            if( !POOP )

                                                            //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                                            ;
                                                            }
                                                                &tPathError     ,
                                                                &tPathErrorCode ,
                                                            {
                                                            textC* pptPath[] =

                                                            TN( tPathError     , "\"error\"/"   ) ;
                                                            TN( tPathErrorCode , "\"errcode\"/" ) ;

                                                            ;
                                                            }
                                                                &tValueError1     ,
                                                                &tValueErrorCode1 ,
                                                            {
                                                            textC* pptValue[] =

                                                            __Z( pSwPathValue ) ;
                                                            etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                            ZE( switchC* , pSwPathValue ) ;
                                                            ZE( strokeS* , psttPath     ) ;
                                                        {

                                                        etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                        etThread.traceF( tin0P , T("json response:") ) ;

                                                        }
                                                            }
                                                                else if( costj ) break ;
                                                                     if( cNest ) costj ++ ;
                                                    
                                                                else if( postj[ costj ] == '}' ) cNest -- ;
                                                                     if( postj[ costj ] == '{' ) cNest ++ ;
                                                    
                                                                putchar( postj[ costj ] ) ;

                                                                if( !cbIn ) break ;
                                                                countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                            {
                                                            for(;;)
                                                            ZE( countT , cNest ) ;
                                                        {
                                                        ZE( countT , costj ) ;
                                                        thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                                                        osTextT postj[ TUCK << 1 ] ;
                                                    
                                                        sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                        etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                        etThread.traceF( tin0P , T("request:") ) ;
                                                    
                                                        TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!tvsMKCZYUrmUfxhZIq:ideafarm.com/invite HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(tBodyInvite.csF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBodyInvite ;
                                                    
                                                        sockc.connectF( tin0P , 443 , nnServer ) ;
                                                        socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                                    
                                                        countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                        countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                        countT timeAllowedConnected = TICK >> 2 ;
                                                    
                                                        nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                        nicNameC nnServer ;
                                                    
                                                        SCOOPS
                                                    {
                                                    IFsCRATCHoK                                                       // INVITE TO SPACE
                                                    _IO_
                                                {
                                                else if( !bFail0 )
                                                if( age < 13 ) bFail1 = 0 ;
                                                etThread.traceF( tin0P , T("debug / 6") ) ;

                                                }
                                                    if( tValueAccessToken.csF( tin0P ) ) bFail0 = 0 ;

                                                    }
                                                        etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                        POOPRqUIET
                                                    {
                                                    if( POOP )
                                                
                                                    etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
                                                
                                                    }
                                                        DEL( pSwPathValue ) ;
                                                        
                                                        }
                                                            }
                                                                etThread.delF( tin0P , pstpsttValue ) ;
                                                        
                                                                }
                                                                    }
                                                                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                        *pptValue[ offe ] = T(pstpsttValue) ;
                                                                    {
                                                                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                                {
                                                                for( countT offe = 0 ; offe < cPaths ; offe ++ )
                                                        
                                                                if( cPaths - cValues ) { BLAMMO ; }
                                                                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
                                                        
                                                                //etThread.trace F( tin0P , T("--------------------------        [value]:    ")+T(pstpsttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                //etThread.trace F( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                        
                                                                strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                                                        
                                                                _IO_
                                                            {
                                                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                        {
                                                        if( !POOP )
                                                        
                                                        ;
                                                        }
                                                            &tPathDeviceId     ,
                                                            &tPathAccessToken  ,
                                                        {
                                                        textC* pptPath[] =
                                                        
                                                        TN( tPathDeviceId    , "\"device_id\"/"    ) ;
                                                        TN( tPathAccessToken , "\"access_token\"/" ) ;
                                                        
                                                        ;
                                                        }
                                                            &tValueDeviceId      ,
                                                            &tValueAccessToken ,
                                                        {
                                                        textC* pptValue[] =
                                                        
                                                        __Z( pSwPathValue ) ;
                                                        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                        ZE( switchC* , pSwPathValue ) ;
                                                        ZE( strokeS* , psttPath     ) ;
                                                        _IO_
                                                    {
                                                
                                                    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("json response:") ) ;
                                                
                                                    }
                                                        }
                                                            else if( costj ) break ;
                                                                 if( cNest ) costj ++ ;
                                                
                                                            else if( postj[ costj ] == '}' ) cNest -- ;
                                                                 if( postj[ costj ] == '{' ) cNest ++ ;
                                                
                                                            putchar( postj[ costj ] ) ;

                                                            if( !cbIn ) break ;
                                                            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                        {
                                                        for(;;)
                                                        ZE( countT , cNest ) ;
                                                    {
                                                    ZE( countT , costj ) ;
                                                    thirdC::c_memsetIF( tin0P , postj , sizeof postj ) ;
                                                    osTextT postj[ TUCK << 1 ] ;
                                                
                                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("request:") ) ;
                                                
                                                    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/login HTTP/1.1\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;
                                                
                                                    countT costBody = tBody.csF( tin0P ) ;
                                                
                                                    //sockc.connectF( tin0P , 80 , nnServer ) ;
                                                    //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                                
                                                    sockc.connectF( tin0P , 443 , nnServer ) ;
                                                    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                                
                                                    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT timeAllowedConnected = TICK >> 2 ;
                                                
                                                    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                    nicNameC nnServer ;
                                                
                                                    ) ;
                                                    
                                                        "}\r\n"
                                                        "    \"password\": \"")+tApiPassword+T("\"\r\n"
                                                        "    },\r\n"
                                                        "        \"user\": \"a.1\"\r\n"
                                                        "        \"type\": \"m.id.user\",\r\n"
                                                        "    {\r\n"
                                                        "    \"identifier\":\r\n"
                                                        "    \"type\": \"m.login.password\",\r\n"
                                                        "{\r\n"
                                                    
                                                    TN( tBody , "" ) ; tBody = T(
                                                    
                                                    }
                                                        etThread.delF( tin0P , psttApiPassword ) ;
                                                        tApiPassword = T(psttApiPassword) ;
                                                        etThread.traceF( tin0P , T("[password]:    ")+T(psttApiPassword) ) ;
                                                        if( psttApiPassword && psttApiPassword->idAdam ) tApiPassword = T(psttApiPassword) ;

                                                          ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.ideafarm.com.a.1"          ) ) ; ___( psttApiPassword ) ;
                                                        //ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.ideafarm.com.administrator") ) ; ___( psttApiPassword ) ;
                                                        //ZE( strokeS* , psttApiPassword ) ; etThread.querySettingF( tin0P , psttApiPassword , T("!ipdos.password.matrix.communick.com.ideafarm"    ) ) ; ___( psttApiPassword ) ;
                                                    {
                                                    TN( tApiPassword , "" ) ;

                                                    SCOOPS
                                                    _IO_
                                                {
                                                IFsCRATCHoK                                                           // LOGIN

                                                TN( tValueDeviceId    , ""                     ) ;
                                                TN( tValueAccessToken , ""                     ) ;
                                                TN( tServer              , "ideafarm.com"         ) ;
                                              //TN( tServer              , "matrix.communick.com" ) ;
                                                etThread.traceF( tin0P , T("debug / 7") ) ;

                                                }
                                                    etThread.traceF( tin0P , T("debug / 7.1") ) ;
                                                    }
                                                        etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                        POOPRqUIET
                                                    {
                                                    if( POOP )
                                                    etThread.traceF( tin0P , T("debug / 7.2") ) ;

                                                    etThread.traceF( tin0P , T("[nonce]:    ")+tValueNonce ) ;
                                                    TN( tb4 , "    " ) ;

                                                    }
                                                        }
                                                            etThread.boxPutF( tin0P , tLong , tRecord , tRecord.csF( tin0P ) ) ;

                                                            etThread.delF( tin0P , psttu ) ;
                                                            TN( tLong , "" ) ; tLong = T("///z/ideafarm.shared/precious/")+TfORsTRING(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T("/json/usernames/")+T("json.username.")+T(psttu)+T(".json") ;
                                                            etThread.strUniqueF( tin0P , psttu ) ; ___( psttu ) ;
                                                            ZE( strokeS* , psttu ) ;

                                                            ) ;

                                                                "}\r\n"
                                                                "    \"subscription.id\" : \"")+T(psttValueIdSubscription)+T("\"\r\n"
                                                                "    \"type\" : \"")+T(bStudent?"student":"visitor")+T("\"\r\n"
                                                                "    \"username\" : \"")+tNewUserNameLong+T("\"\r\n"
                                                                "    \"email\" : \"")+T(psttValueEmail)+T("\"\r\n"
                                                                "    \"live\" : \"")+T(psttValueLive)+T("\"\r\n"
                                                                "    \"time\" : \"")+TTF(timeN1,timeN2)+T("\"\r\n"
                                                                "{\r\n"

                                                            TN( tRecord , "" ) ; tRecord = T(

                                                            etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
                                                            ZE( sCountT , timeN2 ) ;
                                                            ZE( countT  , timeN1 ) ;

                                                            bRegistered = 1 ;
                                                        {
                                                        else
                                                        }
                                                            continue ;
                                                            bRetrySameUsername = 1 ;
                                                            etThread.traceF( tin0P , T("!exception / other error ; will retry the same value [errorCode,error]:    ")+tValueError+tb4+tValueError ) ;
                                                        {
                                                        else if( tValueErrorCode.csF( tin0P ) || tValueError.csF( tin0P ) )
                                                        }
                                                            continue ;
                                                            etThread.traceF( tin0P , T("!exception / this username is already registered ; will try the next value [errorCode,error]:    ")+tValueError+tb4+tValueError ) ;
                                                        {
                                                        if( !etThread.strCompareF( tin0P , tValueErrorCode , T("M_USER_IN_USE") ) )

                                                        DEL( pSwPathValue ) ;

                                                        }
                                                            }
                                                                etThread.delF( tin0P , psttValue ) ;

                                                                }
                                                                    }
                                                                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                        *pptValue[ offe ] = T(psttValue) ;
                                                                    {
                                                                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                                {
                                                                for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                                if( cPaths - cValues ) { BLAMMO ; }
                                                                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                                //etThread.trace F( tin0P , T("--------------------------        [value]:    ")+T(psttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                //etThread.trace F( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

                                                                strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                                _IO_
                                                            {
                                                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                            _IO_
                                                        {
                                                        if( !POOP )

                                                        //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                                        ;
                                                        }
                                                            &tPathNonce     ,
                                                            &tPathError     ,
                                                            &tPathErrorCode ,
                                                        {
                                                        textC* pptPath[] =

                                                        TN( tPathNonce     , "\"nonce\"/"   ) ;
                                                        TN( tPathError     , "\"error\"/"   ) ;
                                                        TN( tPathErrorCode , "\"errcode\"/" ) ;

                                                        ;
                                                        }
                                                            &tValueNonce     ,
                                                            &tValueError     ,
                                                            &tValueErrorCode ,
                                                        {
                                                        textC* pptValue[] =

                                                        TN( tValueError     , "" ) ;
                                                        TN( tValueErrorCode , "" ) ;

                                                        __Z( pSwPathValue ) ;
                                                        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                        ZE( switchC* , pSwPathValue ) ;
                                                        ZE( strokeS* , psttPath     ) ;
                                                        _IO_
                                                    {
                                                    TN( tValueNonce     , "" ) ;
                                                    etThread.traceF( tin0P , T("debug / 7.3") ) ;

                                                    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("json response:") ) ;

                                                    }
                                                        etThread.traceF( tin0P , T(posth) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                        etThread.traceF( tin0P , T("[headers]:") ) ;
                                                        posth[ costh ] = 0 ;
                                                        }
                                                            }
                                                                break ;

                                                                postj[ costj ] = save ;
                                                                               postj[ costj ] = 0 ;
                                                                osTextT save = postj[ costj ] ;
                                                            {
                                                            else if( costj )
                                                                 if( cNest ) costj ++ ;

                                                            else if( postj[ costj ] == '}' ) cNest -- ;
                                                                 if( postj[ costj ] == '{' ) cNest ++ ;

                                                            if( !costj && !cNest ) posth[ costh ++ ] = postj[ costj ] ;

                                                            //etThread.traceF( tin0P , TF3(++idReadLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN,8)+T("    ")+T(post2) ) ;
                                                            //osTextT post2[] = { postj[ costj ] , 0 } ;
                                                
                                                            if( !cbIn ) break ;
                                                            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                        {
                                                        for(;;)
                                                        ZE( countT , cNest ) ;
                                                        ZE( countT , idReadLath ) ;

                                                        ZE( countT , costh ) ;
                                                        osTextT posth[ TUCK << 1 ] ;
                                                        _IO_
                                                    {
                                                    ZE( countT , costj ) ;
                                                    thirdC::c_memsetIF( tin0P , postj , sizeof postj , 0 ) ;
                                                    osTextT postj[ TUCK << 1 ] ;
                                                    etThread.traceF( tin0P , T("debug / 7.4") ) ;

                                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("request:") ) ;
                                                    etThread.traceF( tin0P , T("debug / 7.5") ) ;

                                                    TN( tSay , "" ) ; tSay = T("POST /_synapse/admin/v1/register HTTP/1.1")/*+T("\r\nAuthorization: Bearer ")+tValueSharedSecret*/+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;

                                                    countT costBody = tBody.csF( tin0P ) ;

                                                    etThread.traceF( tin0P , T("debug / 7.6") ) ;
                                                    sockc.connectF( tin0P , 443 , nnServer ) ;
                                                    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                                    etThread.traceF( tin0P , T("debug / 7.7") ) ;

                                                    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT timeAllowedConnected = TICK >> 2 ;

                                                    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                    nicNameC nnServer ;

                                                    etThread.traceF( tin0P , T("debug / 7.8") ) ;
                                                    ) ;

                                                        "}\r\n"
                                                        "    \"mac\": \"")+tMac                 +T("\"\r\n"
                                                        "    \"password\": \"")+tNewPassword           +T("\",\r\n"
                                                        "    \"username\": \"")+tNewUserNameShort      +T("\",\r\n"
                                                        "    \"nonce\": \"")+tValueNonce        +T("\",\r\n"
                                                        "{\r\n"

                                                    TN( tBody , "" ) ; tBody = T(

                                                    etThread.traceF( tin0P , T("[mac]:    ")+tMac ) ;
                                                    }
                                                        etThread.delF( tin0P , psttMac ) ;
                                                        tMac = T(psttMac) ;
                                                        etThread.openSslHmacF( tin0P , psttMac , tValueSharedSecret , tValueSharedSecret.csF( tin0P ) , postRaw , costRaw ) ; ___( psttMac ) ;
                                                        ZE( strokeS* , psttMac ) ;

                                                        countT costRaw = postc - postRaw ;

                                                        thirdC::c_strcpyIF( tin0P , postc , posti ) ; postc += costi     ;
                                                        costi = tNote.csF( tin0P ) ;
                                                        posti = tNote ;

                                                        thirdC::c_strcpyIF( tin0P , postc , posti ) ; postc += costi + 1 ;
                                                        costi = tNewPassword.csF( tin0P ) ;
                                                        posti = tNewPassword ;

                                                        thirdC::c_strcpyIF( tin0P , postc , posti ) ; postc += costi + 1 ;
                                                        costi = tNewUserNameShort.csF( tin0P ) ;
                                                        posti = tNewUserNameShort ;

                                                        thirdC::c_strcpyIF( tin0P , postc , posti ) ; postc += costi + 1 ;
                                                        countT   costi = tValueNonce.csF( tin0P ) ;
                                                        osTextT* posti = tValueNonce ;

                                                        osTextT* postc = postRaw ;
                                                        thirdC::c_memsetIF( tin0P , postRaw , sizeof postRaw , 0 ) ;
                                                        osTextT postRaw[ TUCK ] ;
                                                        etThread.traceF( tin0P , T("debug / 7.g") ) ;
                                                        _IO_
                                                    {
                                                    TN( tMac , "" ) ;

                                                    TN( tNote , "notadmin"  ) ;
                                                    etThread.traceF( tin0P , T("debug / 7.h") ) ;

                                                    _IO_
                                                {
                                                etThread.traceF( tin0P , T("debug / 8") ) ;

                                                }
                                                    }
                                                        etThread.traceF( tin0P , T("socket is impotent") ) ;
                                                        POOPRqUIET
                                                    {
                                                    if( POOP )

                                                    etThread.traceF( tin0P , T("[nonce]:    ")+tValueNonce ) ;

                                                    }
                                                        DEL( pSwPathValue ) ;

                                                        }
                                                            }
                                                                etThread.delF( tin0P , psttValue ) ;

                                                                }
                                                                    }
                                                                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                        *pptValue[ offe ] = T(psttValue) ;
                                                                    {
                                                                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                                {
                                                                for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                                if( cPaths - cValues ) { BLAMMO ; }
                                                                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                                                                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                                //etThread.trace F( tin0P , T("--------------------------        [value]:    ")+T(psttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                                //etThread.trace F( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

                                                                strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                                _IO_
                                                            {
                                                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                            _IO_
                                                        {
                                                        if( !POOP )

                                                        //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                                        ;
                                                        }
                                                            &tPathNonce     ,
                                                            &tPathError     ,
                                                            &tPathErrorCode ,
                                                        {
                                                        textC* pptPath[] =

                                                        TN( tPathNonce     , "\"nonce\"/"   ) ;
                                                        TN( tPathError     , "\"error\"/"   ) ;
                                                        TN( tPathErrorCode , "\"errcode\"/" ) ;

                                                        ;
                                                        }
                                                            &tValueNonce     ,
                                                            &tValueError     ,
                                                            &tValueErrorCode ,
                                                        {
                                                        textC* pptValue[] =

                                                        TN( tValueError     , "" ) ;
                                                        TN( tValueErrorCode , "" ) ;

                                                        __Z( pSwPathValue ) ;
                                                        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                                        ZE( switchC* , pSwPathValue ) ;
                                                        ZE( strokeS* , psttPath     ) ;
                                                        _IO_
                                                    {

                                                    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("json response:") ) ;

                                                    }
                                                        }
                                                            else if( costj ) break ;
                                                                 if( cNest ) costj ++ ;

                                                            else if( postj[ costj ] == '}' ) cNest -- ;
                                                                 if( postj[ costj ] == '{' ) cNest ++ ;

                                                            putchar( postj[ costj ] ) ;

                                                            if( !cbIn ) break ;
                                                            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                                        {
                                                        for(;;)
                                                        ZE( countT , cNest ) ;
                                                        _IO_
                                                    {
                                                    ZE( countT , costj ) ;
                                                    thirdC::c_memsetIF( tin0P , postj , sizeof postj , 0 ) ;
                                                    osTextT postj[ TUCK << 1 ] ;

                                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                                    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    etThread.traceF( tin0P , T("request:") ) ;

                                                    TN( tSay , "" ) ; tSay = T("GET /_synapse/admin/v1/register HTTP/1.1")+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;

                                                    countT costBody = tBody.csF( tin0P ) ;

                                                    sockc.connectF( tin0P , 443 , nnServer ) ;
                                                    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

                                                    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                                    countT timeAllowedConnected = TICK >> 2 ;

                                                    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                                    nicNameC nnServer ;

                                                    TN( tBody , "" ) ;

                                                    SCOOPS
                                                    _IO_
                                                {
                                                IFsCRATCHoK
                                                TN( tValueNonce , "" ) ;
                                                _IO_
                                            {
                                            else
                                            }
                                                ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;                    //THIS ENSURES THAT I DON'T PEG CPU BY RETRYING ; I AM SPRINKLED OVER CODE WITHOUT ANALYSIS
                                                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                                                flagsFail |= flFAIL_COULDnOTgETsHAREDsECRET ;
                                                etThread.traceF( tin0P , T("could not retrieve shared secret") ) ;
                                            {
                                            if( !tValueSharedSecret.csF( tin0P ) )

                                            TN( tServer , "ideafarm.com" ) ;

                                            }
                                                etThread.traceF( tin0P , T("[sharedSecret]:    ")+tValueSharedSecret ) ;
                                                etThread.delF( tin0P , psttSharedSecret ) ;
                                                if( psttSharedSecret && psttSharedSecret->idAdam ) tValueSharedSecret = T(psttSharedSecret) ;

                                                ZE( strokeS* , psttSharedSecret ) ; etThread.querySettingF( tin0P , psttSharedSecret , T("!ipdos.password.matrix.ideafarm.com.shared.secret")  ) ; ___( psttSharedSecret ) ;
                                            {
                                            TN( tValueSharedSecret , "" ) ;

                                            tNewPassword = TF4((countT)ruPassword,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FILLzE,0,0x3e) ;
                                            countT idNewPassword = ruPassword ;
                                            _IO_
                                        {
                                        if( tNewUserNameLong.csF( tin0P ) )

                                        }
                                            }
                                                tBodyInvite = T("{\"user_id\": \"")+tNewUserNameLong+T("\"}\r\n") ;
                                                tNewUserNameLong  = T("@")+tNewUserNameShort+T(":ideafarm.com") ;       // GIVE ONLY THE SHORT USERNAME IN THE EMAILS BECAUSE NONFEDERATED SO (1) LONG NAME ISN'T NEEDED AND (2) LONG NAME WILL PRODUCE AN ERROR MESSAGE THAT WILL CONFUSE EVEN THOUGH IT WILL THEN WORK
                                                tNewUserNameShort =  T("test.")+TF4(idNewUser,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x3e) ;
                                                countT idNewUser = bRetrySameUsername ? idNewUserLath : 1 + incv02AM( idNewUserLath ) ;

                                                if( bZe ) idNewUserLath = 0 ;
                                                countT& idNewUserLath = *(countT*)pbi ;
                                            {
                                            if( pbi && cbi == sizeof( countT ) )
                                            fwsLath.getF( tin0P , pbi , cbi , sizeof( countT ) ) ;
                                            ZE( countT , cbi ) ;
                                            ZE( byteT* , pbi ) ;
                                            fileWindowsC fwsLath( tin0P , etThread , tName , flFILEwINDOW_WRITE ) ;

                                            boolT bZe = !etThread.diskFileExistsF( tin0P , tName ) ;
                                            TN( tName , "///z/ideafarm.shared/precious/idNewTestUserLath" ) ;
                                            _IO_
                                        {
                                        else                                                            // DISPENSE CREDENTIALS (TEST)
                                        }
                                            }
                                                tBodyInvite = T("{\"user_id\": \"")+tNewUserNameLong+T("\"}\r\n") ;
                                                tNewUserNameLong  = T("@")+tNewUserNameShort+T(":ideafarm.com") ;       // GIVE ONLY THE SHORT USERNAME IN THE EMAILS BECAUSE NONFEDERATED SO (1) LONG NAME ISN'T NEEDED AND (2) LONG NAME WILL PRODUCE AN ERROR MESSAGE THAT WILL CONFUSE EVEN THOUGH IT WILL THEN WORK
                                                tNewUserNameShort = T("a.")+TF4(idNewUser,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE,0,0x24) ;       // [0-9,a-z]
                                                countT idNewUser = 1 + incv02AM( idNewUserLath ) ;

                                                if( bZe ) idNewUserLath = 0 ;
                                                countT& idNewUserLath = *(countT*)pbi ;
                                            {
                                            if( pbi && cbi == sizeof( countT ) )
                                            fwsLath.getF( tin0P , pbi , cbi , sizeof( countT ) ) ;
                                            ZE( countT , cbi ) ;
                                            ZE( byteT* , pbi ) ;
                                            fileWindowsC fwsLath( tin0P , etThread , tName , flFILEwINDOW_WRITE ) ;

                                            boolT bZe = !etThread.diskFileExistsF( tin0P , tName ) ;
                                            TN( tName , "///z/ideafarm.shared/precious/idNewLiveUserLath" ) ;
                                            _IO_
                                        {
                                        if( !etThread.strCompareF( tin0P , psttValueLive , tTrue ) )   // DISPENSE CREDENTIALS (LIVE)
                                        TN( tBodyInvite , "" ) ;

                                        tNewPassword          = tn ;
                                        tNewUserNameLong      = tn ;
                                        tNewUserNameShort     = tn ;
                                        tValueError3          = tn ;
                                        tValueErrorCode3      = tn ;
                                        tValueError2          = tn ;
                                        tValueErrorCode2      = tn ;
                                        tValueError1          = tn ;
                                        tValueErrorCode1      = tn ;
                                        tInvitationsSubmitted = tn ;
                                        bFail3 = 1 ;
                                        bFail2 = 1 ;
                                        bFail1 = 1 ;
                                        bFail0 = 1 ;
                                        _IO_
                                    {
                                    while( !ether && !POOP && !bRegistered )     //WILL continue UNTIL SUCCESSFULLY REGISTER A NEW USERNAME ; THIS CAUSES idNewUser TO INCREMENT UNTIL IT IS A VALUE THAT HAS NOT BEEN REGISTERED
                                    ZE( boolT , bRetrySameUsername ) ;
                                    ZE( boolT , bRegistered ) ;
                                    TN( tNewPassword         , "" ) ;
                                    TN( tNewUserNameLong     , "" ) ;
                                    TN( tNewUserNameShort    , "" ) ;
                                    TN( tValueError3         , "" ) ;
                                    TN( tValueErrorCode3     , "" ) ;
                                    TN( tValueError2         , "" ) ;
                                    TN( tValueErrorCode2     , "" ) ;
                                    TN( tValueError1         , "" ) ;
                                    TN( tValueErrorCode1     , "" ) ;
                                    boolT bFail3 = 1 ;
                                    boolT bFail2 = 1 ;
                                    boolT bFail1 = 1 ;
                                    boolT bFail0 = 1 ;
                                    TN( tInvitationsSubmitted , "" ) ;
                                {
                                if( !flagsFail )

                                }
                                    ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;                    //THIS ENSURES THAT I DON'T PEG CPU BY RETRYING ; I AM SPRINKLED OVER CODE WITHOUT ANALYSIS
                                    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                                    flagsFail |= flFAIL_UNKNOWNpRODUCT ;
                                {
                                if( !bStudent && !bVisitor )

                                ;
                                    !etThread.strCompareF( tin0P , psttValueIdProduct , T("prod_RTnJkcMaLDwaqK") )      // TEST
                                    ||
                                    !etThread.strCompareF( tin0P , psttValueIdProduct , T("prod_RJ1RvgWrjbn5VU") )      // LIVE
                                const boolT bVisitor =

                                ;
                                    !etThread.strCompareF( tin0P , psttValueIdProduct , T("prod_RTh7nU4xMtwvzD") )      // TEST
                                    ||
                                    !etThread.strCompareF( tin0P , psttValueIdProduct , T("prod_RJ1XOIUO9htwyX") )      // LIVE
                                const boolT bStudent =

                                _IO_
                            {
                            else
                            }
                                ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;                    //THIS ENSURES THAT I DON'T PEG CPU BY RETRYING ; I AM SPRINKLED OVER CODE WITHOUT ANALYSIS
                                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                            {
                            if( flagsFail )

                            if( age < 13                                                      ) flagsFail |= flFAIL_UNEXPECTEDaGEtOOyOUNG ;
                            if( etThread.strCompareF( tin0P , psttVersion , tCorrectVersion ) ) flagsFail |= flFAIL_UNEXPECTEDvERSION     ;
                            if( etThread.strCompareF( tin0P , psttEvent   , tCorrectEvent   ) ) flagsFail |= flFAIL_UNEXPECTEDeVENT       ;

                            const sCountT age = etThread.strDigitsToSCountF( tin0P , psttValueAge , 0xa , 1 ) ;
                            TN( tCorrectVersion , "1" ) ;
                            TN( tCorrectEvent    , "ipdos.subscription.create" ) ;

                            ZE( strokeS* , psttValueHawker         ) ; sIn >> psttValueHawker         ; ___( psttValueHawker         ) ; etThread.traceF( tin0P , T("[ValueHawker         ]:    ")+T(psttValueHawker         ) ) ;
                            ZE( strokeS* , psttValueAge            ) ; sIn >> psttValueAge            ; ___( psttValueAge            ) ; etThread.traceF( tin0P , T("[ValueAge            ]:    ")+T(psttValueAge            ) ) ;
                            ZE( strokeS* , psttValueName           ) ; sIn >> psttValueName           ; ___( psttValueName           ) ; etThread.traceF( tin0P , T("[ValueName           ]:    ")+T(psttValueName           ) ) ;
                            ZE( strokeS* , psttValueEmail          ) ; sIn >> psttValueEmail          ; ___( psttValueEmail          ) ; etThread.traceF( tin0P , T("[ValueEmail          ]:    ")+T(psttValueEmail          ) ) ;
                            ZE( strokeS* , psttValuePostalCode     ) ; sIn >> psttValuePostalCode     ; ___( psttValuePostalCode     ) ; etThread.traceF( tin0P , T("[ValuePostalCode     ]:    ")+T(psttValuePostalCode     ) ) ;
                            ZE( strokeS* , psttValueCountry        ) ; sIn >> psttValueCountry        ; ___( psttValueCountry        ) ; etThread.traceF( tin0P , T("[ValueCountry        ]:    ")+T(psttValueCountry        ) ) ;
                            ZE( strokeS* , psttValueIdSubscription ) ; sIn >> psttValueIdSubscription ; ___( psttValueIdSubscription ) ; etThread.traceF( tin0P , T("[ValueIdSubscription ]:    ")+T(psttValueIdSubscription ) ) ;
                            ZE( strokeS* , psttValueIdProduct      ) ; sIn >> psttValueIdProduct      ; ___( psttValueIdProduct      ) ; etThread.traceF( tin0P , T("[ValueIdProduct      ]:    ")+T(psttValueIdProduct      ) ) ;
                            ZE( strokeS* , psttValueLive           ) ; sIn >> psttValueLive           ; ___( psttValueLive           ) ; etThread.traceF( tin0P , T("[ValueLive           ]:    ")+T(psttValueLive           ) ) ;
                            ZE( strokeS* , psttVersion             ) ; sIn >> psttVersion             ; ___( psttVersion             ) ; etThread.traceF( tin0P , T("[Version             ]:    ")+T(psttVersion             ) ) ;
                            ZE( strokeS* , psttEvent               ) ; sIn >> psttEvent               ; ___( psttEvent               ) ; etThread.traceF( tin0P , T("[Event               ]:    ")+T(psttEvent               ) ) ;

                            _IO_
                        {
                        if( !( F(flagsFail) & flFAIL_COULDnOTgETsHADOW ) )

                        }
                            }
                                ++ s ; ether.osSleepF( tin0P , TOCK << 2 ) ;                    //THIS ENSURES THAT I DON'T PEG CPU BY RETRYING ; I AM SPRINKLED OVER CODE WITHOUT ANALYSIS
                                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                                etThread.traceF( tin0P , T("could not get shadow of ")+T((strokeS*)tIfoName)+T(": ") ) ;
                                flagsFail |= flFAIL_COULDnOTgETsHADOW ;
                                POOPR ;
                            {
                            if( POOP )
                            ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , sIn , tIfoName , 1 ) ;
                            SCOOPS
                        {
                        IFsCRATCHoK
                        soulC sIn( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
                        IFsCRATCHoK{}

                        ZE( flagsT , flagsFail ) ;
                        etThread.traceF( tin0P , T("receiving ")+T((strokeS*)tIfoName)+T(": ") ) ;

                        etThread.traceF( tin0P , tShort ) ;

                        }
                            etThread.delF( tin0P , psttShort ) ;
                            tShort = T(psttShort) ;
                            etThread.delF( tin0P , psttnu ) ;
                            etThread.strBisectF( tin0P , psttnu , psttShort , tIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShort , "" ) ;

                        TN( tIfoName , pInfo->psttIfoName ) ;
                        _IO_
                    {
                    if( !bDir )

                    const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
                    _IO_
                {
                else
                }
                    break ;
                    DEL( pInfo ) ;
                {
                if( !pInfo || !pInfo->psttIfoName )

                etThread.diskFindFileOrDirF( tin0P , pInfo , hFind , tFolderMyEvents ) ;
                ZE( infoFileS* , pInfo ) ;
                _IO_
            {
            do
            handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        {

        }
            while( !ether && ~hFind && !POOP ) ;
            }
                DEL( pInfo ) ;
                }
                    }
                        }
                            }
                                etThread.traceF( tin0P , T("collision / could not move event to my events folder [short]:    ")+tShort ) ;
                                POOPRqUIET ;
                            {
                            if( POOP )
                            ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tLongTo , tLongFrom , 1 ) ;
                            SCOOPS
                        {
                        IFsCRATCHoK

                        etThread.traceF( tin0P , T("[tLongFrom]:    ")+tLongFrom ) ;
                        etThread.traceF( tin0P , T("[tLongTo]:      ")+tLongTo ) ;
                        TN( tLongFrom , "" ) ; tLongFrom = tSharedFolderEventIncoming+tShort ;
                        TN( tLongTo   , "" ) ; tLongTo   = tFolderMyEvents+tShort ;
     
                        }
                            etThread.delF( tin0P , psttShort ) ;
                            tShort = T(psttShort) ;
                            etThread.delF( tin0P , psttnu ) ;
                            etThread.strBisectF( tin0P , psttnu , psttShort , tIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShort , "" ) ;

                        TN( tIfoName , pInfo->psttIfoName ) ;
                        _IO_
                    {
                    if( !bDir )

                    const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
                    _IO_
                {
                else
                }
                    break ;
                    DEL( pInfo ) ;
                {
                if( !pInfo || !pInfo->psttIfoName )

                etThread.diskFindFileOrDirF( tin0P , pInfo , hFind , tSharedFolderEventIncoming ) ;
                ZE( infoFileS* , pInfo ) ;
                _IO_
            {
            do
            handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        {

        }
            while( !etThread.diskMakeDirIfNeededF( tin0P , tFolderMyEvents ) ) ;                   // RETRY IF EXISTS ; EXISTS SHOULD BE IMPOSSIBLE, BUT THIS LOOP ENSURES THAT tFolderMyEvents IS UNIQUE AND NEWLY MADE
            }
                etThread.delF( tin0P , psttu ) ;
                tFolderMyEvents = tSharedFolderPrefix+T("incoming.events.")+T(psttu)+T("/") ;
                etThread.strUniqueF( tin0P , psttu ) ; ___( psttu ) ;
                ZE( strokeS* , psttu ) ;
            {
            do
        {
        TN( tFolderMyEvents , "" ) ;

        }
            while( !ether && ~hFindOuter && !POOP && !cNewEvents ) ;
            }
                DEL( pInfoOuter ) ;
                }
                    }
                        }
                            while( !ether && ~hFindMiddle && !POOP && !cNewEvents ) ;
                            }
                                DEL( pInfoMiddle ) ;
                                }
                                    }
                                        }
                                            }                                                                                                                                                   //U:: USE THE IDEMPOTENT FIELD IN STRIPE NOTICES TO PREVENT DUPLICATION OF PROCESSING
                                                etThread.traceF( tin0P , T("[cMoved]:    ")+TF2(cMoved,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                }
                                                    }
                                                        ++ s ; ether.osSleepF( tin0P , TOCK * napTocks ) ;
                                                        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                                                        etThread.traceF( tin0P , T("napping for a few tocks / [napTocks]:    ")+TF2(napTocks,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                        countT napTocks = (countT)ruPassword >> SB * 3 + 5 ;                    // [0,8] ; NAP FOR A RANDOM TIME TO GIVE OTHER SERVERS AN OPPORTUNITY TO GET THESE RAW INCOMING FILES

                                                        etThread.diskFileOrDirDeleteF( tin0P , tFolderMaybe ) ;
                                                        }
                                                            }
                                                                }
                                                                    continue ;
                                                                    DEL( pInfoOuter ) ;
                                                                    etThread.traceF( tin0P , T("could not move back to incoming from unique maybe [short]")+*pptShort[ offi ] ) ;
                                                                    POOPR ;
                                                                {
                                                                else
                                                                if( !POOP ) cMoved -- ;
                                                                ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tSharedFolderRawIncoming+*pptShort[ offi ] , tFolderMaybe+*pptShort[ offi ] ) ;
                                                                SCOOPS
                                                            {
                                                            IFsCRATCHoK
                                                        {
                                                        for( countT offi = 0 ; offi < sizeof pptShort / sizeof pptShort[ 0 ] ; offi ++ )
                                                    {
                                                    else
                                                    }
                                                        cNewEvents ++ ;
                                                        etThread.diskFileOrDirDeleteF( tin0P , tFolderReady ) ;
                                                        etThread.diskMoveFileOrDirF( tin0P , tSharedFolderRawDone+tShortInner  , tFolderReady+tShortInner  ) ;
                                                        etThread.diskMoveFileOrDirF( tin0P , tSharedFolderRawDone+tShortMiddle , tFolderReady+tShortMiddle ) ;
                                                        etThread.diskMoveFileOrDirF( tin0P , tSharedFolderRawDone+tShortOuter  , tFolderReady+tShortOuter  ) ;

                                                        etThread.delF( tin0P , psttFile ) ;
                                                        etThread.boxPutUniqueF( tin0P , psttFile , tSharedFolderEventIncoming+tShortEvent , WS( sOut ) ) ;
                                                        ZE( strokeS* , psttFile ) ;

                                                        TN( tShortEvent , "soil." ) ; tShortEvent += T(bLive?"soul.event.live.":"soul.event.test.")+tEvent ;

                                                        boolT bLive = !etThread.strCompareF( tin0P , tValueOuterLive , T("true") ) ;

                                                        }
                                                            sOut << (strokeS*)tValueMiddleHawker         ;
                                                            sOut << (strokeS*)tValueMiddleAge            ;
                                                            sOut << (strokeS*)tValueMiddleName           ;
                                                            sOut << (strokeS*)tValueMiddleEmail          ;
                                                            sOut << (strokeS*)tValueMiddlePostalCode     ;
                                                            sOut << (strokeS*)tValueMiddleCountry        ;
                                                            sOut << (strokeS*)tValueMiddleIdSubscription ;
                                                            sOut << (strokeS*)tValueOuterIdProduct      ;
                                                            sOut << (strokeS*)tValueOuterLive           ;

                                                            sOut << (strokeS*)tVersion                  ;
                                                            sOut << (strokeS*)tEvent                    ;
                                                        {
                                                        soulC sOut( tin0P , TAG( TAGiDnULL ) ) ;

                                                        TN( tVersion   , "1" ) ;
                                                        TN( tEvent , "ipdos.subscription.create" ) ;

                                                        etThread.traceF( tin0P , T("    [tValueMiddleHawker        ]: ")+tValueMiddleHawker         ) ;
                                                        etThread.traceF( tin0P , T("    [tValueMiddleAge           ]: ")+tValueMiddleAge            ) ;
                                                        etThread.traceF( tin0P , T("    [tValueMiddleName          ]: ")+tValueMiddleName           ) ;
                                                        etThread.traceF( tin0P , T("    [tValueMiddleEmail         ]: ")+tValueMiddleEmail          ) ;
                                                        etThread.traceF( tin0P , T("    [tValueMiddlePostalCode    ]: ")+tValueMiddlePostalCode     ) ;
                                                        etThread.traceF( tin0P , T("    [tValueMiddleCountry       ]: ")+tValueMiddleCountry        ) ;
                                                        etThread.traceF( tin0P , T("    [tValueMiddleIdSubscription]: ")+tValueMiddleIdSubscription ) ;
                                                        etThread.traceF( tin0P , T("    [tValueOuterIdProduct     ]: ")+tValueOuterIdProduct      ) ;
                                                        etThread.traceF( tin0P , T("    [tValueOuterLive          ]: ")+tValueOuterLive           ) ;
                                                        etThread.traceF( tin0P , T("found a matching inner:") ) ;
                                                        // EAT THE READY SET

                                                        }
                                                            }
                                                                }
                                                                    continue ;
                                                                    DEL( pInfoOuter ) ;
                                                                    etThread.traceF( tin0P , T("could not rename the maybe folder to ready [tFolderReady,tFolderMaybe]:    ")+tFolderReady+tb4+tFolderMaybe ) ;
                                                                    POOPR ;
                                                                {
                                                                else
                                                                if( !POOP ) break ;
                                                                ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tFolderReady , tFolderMaybe , 1 ) ;
                                                                SCOOPS
                                                            {
                                                            IFsCRATCHoK
                                                        {
                                                        for(;;)
                                                    {
                                                    if( cMoved == 3 )

                                                    }
                                                        }
                                                            }
                                                                continue ;
                                                                DEL( pInfoOuter ) ;
                                                                etThread.traceF( tin0P , T("could not move to unique maybe from incoming [short]")+*pptShort[ offi ] ) ;
                                                                POOPR ;
                                                            {
                                                            else
                                                            if( !POOP ) cMoved ++ ;
                                                            ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tFolderMaybe+*pptShort[ offi ] , tSharedFolderRawIncoming+*pptShort[ offi ] , 1 ) ;
                                                            SCOOPS
                                                        {
                                                        IFsCRATCHoK
                                                    {
                                                    for( countT offi = 0 ; offi < sizeof pptShort / sizeof pptShort[ 0 ] ; offi ++ )
                                                    textC* pptShort[] = { &tShortOuter , &tShortMiddle , &tShortInner } ;
                                                {
                                                ZE( countT , cMoved ) ;

                                                }
                                                    etThread.delF( tin0P , psttu ) ;
                                                    tFolderReady = tSharedFolderPrefix+T("set.ready.")+T(psttu)+T("/") ;

                                                    while( !etThread.diskMakeDirIfNeededF( tin0P , tFolderMaybe ) ) ;                   // RETRY IF EXISTS ; EXISTS SHOULD BE IMPOSSIBLE, BUT THIS LOOP ENSURES THAT tFolderMaybe IS UNIQUE AND NEWLY MADE
                                                    }
                                                        tFolderMaybe = tSharedFolderPrefix+T("set.maybe.")+T(psttu)+T("/") ;
                                                        etThread.strUniqueF( tin0P , psttu ) ; ___( psttu ) ;
                                                        etThread.delF( tin0P , psttu ) ;
                                                    {
                                                    do
                                                    ZE( strokeS* , psttu ) ;
                                                {
                                                TN( tFolderReady , "" ) ;
                                                TN( tFolderMaybe , "" ) ;

                                                etThread.traceF( tin0P , T("attempting to move this set to a unique new folder for further processing") ) ;
                                            {
                                            if( bActive )

                                            }
                                                while( !ether && ~hFindInner && !POOP && !bUpdateFound ) ;
                                                }
                                                    DEL( pInfoInner ) ;
                                                    }
                                                        }
                                                            }
                                                                if( bActive ) tShortInner = tShortInnerMaybe ;
                                                                bActive = !etThread.strCompareF( tin0P , tValueInnerStatus , T("active") ) ;
                                                            {
                                                            )
                                                                !etThread.strCompareF( tin0P , tValueInnerLatestInvoice    , tValueMiddleInvoice               )
                                                                &&
                                                                !etThread.strCompareF( tin0P , tValueInnerStripeNoticeType , tValueWantedInnerStripeNoticeType )
                                                            (
                                                            if
                                                            if( !etThread.strCompareF( tin0P , tValueInnerStripeNoticeType , tValueWantedInnerStripeNoticeType ) ) etThread.traceF( tin0P , T("    [tValueInnerLatestInvoice]:    ")+tValueInnerLatestInvoice ) ;
                                                            etThread.traceF( tin0P , T("        inner [tValueInnerStripeNoticeType]:    ")+tValueInnerStripeNoticeType ) ;

                                                            }
                                                                DEL( pSwPathValue ) ;
                                                                
                                                                }
                                                                    }
                                                                        etThread.delF( tin0P , psttValueInner ) ;
                                                                
                                                                        }
                                                                            }
                                                                                //etThread.traceF( tin0P , T("********    ") + *pptKeyInner[ offe ] + T("   :    ") + *pptValueInner[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF , ifcIDtRACEdIVERT_f ) ;

                                                                                etThread.delF( tin0P , psttt ) ;
                                                                                *pptValueInner[ offe ] = T(psttt) ;
                                                                                etThread.strTrimF( tin0P , psttt , psttValueInner , 0 , 0 , strokeS() ) ; ___( psttt ) ;
                                                                                ZE( strokeS* , psttt ) ;
                                                                            {
                                                                            if( !etThread.strCompareF( tin0P , psttPath , *pptKeyInner[ offe ] ) )
                                                                        {
                                                                        for( countT offe = 0 ; offe < cKeys ; offe ++ )
                                                                
                                                                        if( cKeys - cValues ) { BLAMMO ; }
                                                                        countT cValues = sizeof pptValueInner / sizeof pptValueInner[ 0 ] ;
                                                                        countT cKeys  = sizeof pptKeyInner  / sizeof pptKeyInner[  0 ] ;
                                                                
                                                                        //etThread.trace F( tin0P , T("--------------------------        [value]:    ")+T(psttValueInner) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF /*, ifcIDtRACEdIVERT_d*/ ) ;
                                                                        //etThread.trace F( tin0P , T("-------------------------- [path]:            ")+T(psttPath)       , flTRACE_NOpREFIX | flTRACE_KEEPcRlF /*, ifcIDtRACEdIVERT_d*/ ) ;
                                                                
                                                                        strokeS*& psttValueInner = *(strokeS**)&(countT&)*pSwPathValue ;
                                                                        psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                                                                
                                                                        _IO_
                                                                    {
                                                                    for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                                    countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                                                {
                                                                if( !POOP )
                                                            
                                                                ;
                                                                }
                                                                    &tKeyInnerAmountDiscount   ,
                                                                    &tKeyInnerIdSubscription   ,
                                                                    &tKeyInnerMode             ,
                                                                    &tKeyInnerName             ,
                                                                    &tKeyInnerEmail            ,
                                                                    &tKeyInnerPostalCode       ,
                                                                    &tKeyInnerCountry          ,
                                                                    &tKeyInnerHawker           ,
                                                                    &tKeyInnerAge              ,
                                                                    &tKeyInnerAmountTotal      ,
                                                                    &tKeyInnerAmountSubtotal   ,
                                                                    &tKeyInnerApiVersion       ,
                                                                    &tKeyInnerIdProduct        ,
                                                                    &tKeyInnerStatus           ,
                                                                    &tKeyInnerLatestInvoice    ,
                                                                    &tKeyInnerStripeNoticeType ,
                                                                    &tKeyInnerLive             ,
                                                                {
                                                                textC* pptKeyInner[] =
                                                                
                                                                TN( tKeyInnerAmountDiscount   , "\"data\"/\"object\"/\"total_details\"/\"amount_discount\"/"                 ) ;
                                                                TN( tKeyInnerIdSubscription   , "\"data\"/\"object\"/\"subscription\"/"                                      ) ;
                                                                TN( tKeyInnerMode             , "\"data\"/\"object\"/\"mode\"/"                                              ) ;
                                                                TN( tKeyInnerName             , "\"data\"/\"object\"/\"customer_details\"/\"name\"/"                         ) ;
                                                                TN( tKeyInnerEmail            , "\"data\"/\"object\"/\"customer_details\"/\"email\"/"                        ) ;
                                                                TN( tKeyInnerPostalCode       , "\"data\"/\"object\"/\"customer_details\"/\"address\"/\"postal_code\"/"      ) ;
                                                                TN( tKeyInnerCountry          , "\"data\"/\"object\"/\"customer_details\"/\"address\"/\"country\"/"          ) ;
                                                                TN( tKeyInnerHawker           , "\"data\"/\"object\"/\"custom_fields\"/item.00000002/\"text\"/\"value\"/"    ) ;
                                                                TN( tKeyInnerAge              , "\"data\"/\"object\"/\"custom_fields\"/item.00000001/\"numeric\"/\"value\"/" ) ;
                                                                TN( tKeyInnerAmountTotal      , "\"data\"/\"object\"/\"amount_total\"/"                                      ) ;
                                                                TN( tKeyInnerAmountSubtotal   , "\"data\"/\"object\"/\"amount_subtotal\"/"                                   ) ;
                                                                TN( tKeyInnerApiVersion       , "\"api_version\"/"                                                           ) ;
                                                                TN( tKeyInnerIdProduct        , "\"data\"/\"object\"/\"plan\"/\"product\"/"                                  ) ;
                                                                TN( tKeyInnerStatus           , "\"data\"/\"object\"/\"status\"/"                                            ) ;
                                                                TN( tKeyInnerLatestInvoice    , "\"data\"/\"object\"/\"latest_invoice\"/"                                    ) ;
                                                                TN( tKeyInnerStripeNoticeType , "\"type\"/"                                                                  ) ;
                                                                TN( tKeyInnerLive             , "\"livemode\"/"                                                              ) ;

                                                                // 
                                                                // 
                                                                // 
                                                                // "data" / "object" / "plan" / "product" / : "prod_RJ1XOIUO9htwyX"
                                                                // "type" / : "customer.subscription.created"
                                                                //
                                                                // FOR THE STUDENT REGISTRATION SUBSCRIPTION

                                                                ;
                                                                }
                                                                    &tValueInnerAmountDiscount   ,
                                                                    &tValueInnerIdSubscription   ,
                                                                    &tValueInnerMode             ,
                                                                    &tValueInnerName             ,
                                                                    &tValueInnerEmail            ,
                                                                    &tValueInnerPostalCode       ,
                                                                    &tValueInnerCountry          ,
                                                                    &tValueInnerHawker           ,
                                                                    &tValueInnerAge              ,
                                                                    &tValueInnerAmountTotal      ,
                                                                    &tValueInnerAmountSubtotal   ,
                                                                    &tValueInnerApiVersion       ,
                                                                    &tValueInnerIdProduct        ,
                                                                    &tValueInnerStatus           ,
                                                                    &tValueInnerLatestInvoice    ,
                                                                    &tValueInnerStripeNoticeType ,
                                                                    &tValueInnerLive             ,
                                                                {
                                                                textC* pptValueInner[] =
                                                            
                                                                }
                                                                    etThread.delF( tin0P , postRaw ) ;
                                                                    __Z( pSwPathValue ) ;
                                                                    etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postRaw , flSTACKc_null ) ;
                                                                    }
                                                                        }
                                                                            continue ;
                                                                            DEL( pInfoInner ) ;
                                                                            etThread.traceF( tin0P , T(" skipping file name that no longer exists [long]")+T(pInfoInner->psttIfoName) ) ;
                                                                            POOPR ;
                                                                        {
                                                                        if( POOP )
                                                                        ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , postRaw , costRaw , pInfoInner->psttIfoName , 1 ) ; ___( postRaw ) ;
                                                                        SCOOPS
                                                                    {
                                                                    IFsCRATCHoK
                                                                    ZE( countT   , costRaw ) ;
                                                                    ZE( osTextT* , postRaw ) ;
                                                                {
                                                                ZE( switchC* , pSwPathValue ) ;
                                                                ZE( strokeS* , psttPath     ) ;
                                                            {
                                                            TN( tValueInnerAmountDiscount   , "" ) ;
                                                            TN( tValueInnerIdSubscription   , "" ) ;
                                                            TN( tValueInnerMode             , "" ) ;
                                                            TN( tValueInnerName             , "" ) ;
                                                            TN( tValueInnerEmail            , "" ) ;
                                                            TN( tValueInnerPostalCode       , "" ) ;
                                                            TN( tValueInnerCountry          , "" ) ;
                                                            TN( tValueInnerHawker           , "" ) ;
                                                            TN( tValueInnerAge              , "" ) ;
                                                            TN( tValueInnerAmountTotal      , "" ) ;
                                                            TN( tValueInnerAmountSubtotal   , "" ) ;
                                                            TN( tValueInnerApiVersion       , "" ) ;
                                                            TN( tValueInnerIdProduct        , "" ) ;
                                                            TN( tValueInnerStatus           , "" ) ;
                                                            TN( tValueInnerLatestInvoice    , "" ) ;
                                                            TN( tValueInnerStripeNoticeType , "" ) ;
                                                            TN( tValueInnerLive             , "" ) ;

                                                            etThread.traceF( tin0P , T("        ------------------------------------------------------------------------------------------------------------------------------------------------------- ")+tShortInnerMaybe ) ;

                                                            }
                                                                etThread.delF( tin0P , psttShortInnerMaybe ) ;
                                                                tShortInnerMaybe = T(psttShortInnerMaybe) ;
                                                                etThread.delF( tin0P , psttnu ) ;
                                                                etThread.strBisectF( tin0P , psttnu , psttShortInnerMaybe , pInfoInner->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShortInnerMaybe ) ;
                                                                ZE( strokeS* , psttShortInnerMaybe ) ;
                                                                ZE( strokeS* , psttnu ) ;
                                                            {
                                                            TN( tShortInnerMaybe , "" ) ;
                                                        {
                                                        if( !bDir )

                                                        const boolT bDir = pInfoInner->psttIfoName[ CSpREFIX - 1 + pInfoInner->psttIfoName->idAdam ].idAdam == '/' ;
                                                    {
                                                    else
                                                    }
                                                        break ;
                                                        DEL( pInfoInner ) ;
                                                    {
                                                    if( !pInfoInner || !pInfoInner->psttIfoName )

                                                    etThread.diskFindFileOrDirF( tin0P , pInfoInner , hFindInner , tSharedFolderRawIncoming ) ;
                                                    ZE( infoFileS* , pInfoInner ) ;
                                                {
                                                do
                                                handleC hFindInner( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                                                ZE( boolT , bUpdateFound )

                                                etThread.traceF( tin0P , T("not so fast!  verify that the newly created subscription has been updated to \"active\" status") ) ;

                                                _IO_
                                            {
                                            if( !bActive )
                                            TN( tShortInner , "" ) ;
                                            boolT bActive = !etThread.strCompareF( tin0P , tValueOuterStatus , T("active") ) ;
                                        {
                                        )
                                            !etThread.strCompareF( tin0P , tValueOuterLatestInvoice     , tValueMiddleInvoice                )
                                            &&
                                            !etThread.strCompareF( tin0P , tValueMiddleStripeNoticeType , tValueWantedMiddleStripeNoticeType )
                                        (
                                        if
                                        etThread.traceF( tin0P , T("    middle [tValueMiddleStripeNoticeType]:    ")+tValueMiddleStripeNoticeType ) ;
                                        if( !etThread.strCompareF( tin0P , tValueMiddleStripeNoticeType , tValueWantedMiddleStripeNoticeType ) ) etThread.traceF( tin0P , T("    [tValueMiddleInvoice]:    ")+tValueMiddleInvoice ) ;

                                        }
                                            DEL( pSwPathValue ) ;
                                            
                                            }
                                                }
                                                    etThread.delF( tin0P , psttValueMiddle ) ;
                                            
                                                    }
                                                        }
                                                            //etThread.traceF( tin0P , T("********    ") + *pptKeyMiddle[ offe ] + T("   :    ") + *pptValueMiddle[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF , ifcIDtRACEdIVERT_f ) ;

                                                            etThread.delF( tin0P , psttt ) ;
                                                            *pptValueMiddle[ offe ] = T(psttt) ;
                                                            etThread.strTrimF( tin0P , psttt , psttValueMiddle , 0 , 0 , strokeS() ) ; ___( psttt ) ;
                                                            ZE( strokeS* , psttt ) ;
                                                        {
                                                        if( !etThread.strCompareF( tin0P , psttPath , *pptKeyMiddle[ offe ] ) )
                                                    {
                                                    for( countT offe = 0 ; offe < cKeys ; offe ++ )
                                            
                                                    if( cKeys - cValues ) { BLAMMO ; }
                                                    countT cValues = sizeof pptValueMiddle / sizeof pptValueMiddle[ 0 ] ;
                                                    countT cKeys  = sizeof pptKeyMiddle  / sizeof pptKeyMiddle[  0 ] ;
                                            
                                                    //etThread.trace F( tin0P , T("--------------------------        [value]:    ")+T(psttValueMiddle) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF /*, ifcIDtRACEdIVERT_d*/ ) ;
                                                    //etThread.trace F( tin0P , T("-------------------------- [path]:            ")+T(psttPath)       , flTRACE_NOpREFIX | flTRACE_KEEPcRlF /*, ifcIDtRACEdIVERT_d*/ ) ;
                                            
                                                    strokeS*& psttValueMiddle = *(strokeS**)&(countT&)*pSwPathValue ;
                                                    psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                                            
                                                    _IO_
                                                {
                                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                            {
                                            if( !POOP )
                                        
                                            ;
                                            }
                                                &tKeyMiddleAmountDiscount   ,
                                                &tKeyMiddleIdSubscription   ,
                                                &tKeyMiddleMode             ,
                                                &tKeyMiddleName             ,
                                                &tKeyMiddleEmail            ,
                                                &tKeyMiddlePostalCode       ,
                                                &tKeyMiddleCountry          ,
                                                &tKeyMiddleHawker           ,
                                                &tKeyMiddleAge              ,
                                                &tKeyMiddleAmountTotal      ,
                                                &tKeyMiddleAmountSubtotal   ,
                                                &tKeyMiddleApiVersion       ,
                                                &tKeyMiddleIdProduct        ,
                                                &tKeyMiddleInvoice          ,
                                                &tKeyMiddleStripeNoticeType ,
                                                &tKeyMiddleLive             ,
                                            {
                                            textC* pptKeyMiddle[] =
                                            
                                            TN( tKeyMiddleAmountDiscount   , "\"data\"/\"object\"/\"total_details\"/\"amount_discount\"/"                 ) ;
                                            TN( tKeyMiddleIdSubscription   , "\"data\"/\"object\"/\"subscription\"/"                                      ) ;
                                            TN( tKeyMiddleMode             , "\"data\"/\"object\"/\"mode\"/"                                              ) ;
                                            TN( tKeyMiddleName             , "\"data\"/\"object\"/\"customer_details\"/\"name\"/"                         ) ;
                                            TN( tKeyMiddleEmail            , "\"data\"/\"object\"/\"customer_details\"/\"email\"/"                        ) ;
                                            TN( tKeyMiddlePostalCode       , "\"data\"/\"object\"/\"customer_details\"/\"address\"/\"postal_code\"/"      ) ;
                                            TN( tKeyMiddleCountry          , "\"data\"/\"object\"/\"customer_details\"/\"address\"/\"country\"/"          ) ;
                                            TN( tKeyMiddleHawker           , "\"data\"/\"object\"/\"custom_fields\"/item.00000002/\"text\"/\"value\"/"    ) ;
                                            TN( tKeyMiddleAge              , "\"data\"/\"object\"/\"custom_fields\"/item.00000001/\"numeric\"/\"value\"/" ) ;
                                            TN( tKeyMiddleAmountTotal      , "\"data\"/\"object\"/\"amount_total\"/"                                      ) ;
                                            TN( tKeyMiddleAmountSubtotal   , "\"data\"/\"object\"/\"amount_subtotal\"/"                                   ) ;
                                            TN( tKeyMiddleApiVersion       , "\"api_version\"/"                                                           ) ;
                                            TN( tKeyMiddleIdProduct        , "\"data\"/\"object\"/\"plan\"/\"product\"/"                                  ) ;
                                            TN( tKeyMiddleInvoice          , "\"data\"/\"object\"/\"invoice\"/"                                           ) ;
                                            TN( tKeyMiddleStripeNoticeType , "\"type\"/"                                                                  ) ;
                                            TN( tKeyMiddleLive             , "\"livemode\"/"                                                              ) ;

                                            // 
                                            // 
                                            // 
                                            // "data" / "object" / "plan" / "product" / : "prod_RJ1XOIUO9htwyX"
                                            // "type" / : "customer.subscription.created"
                                            //
                                            // FOR THE STUDENT REGISTRATION SUBSCRIPTION

                                            ;
                                            }
                                                &tValueMiddleAmountDiscount   ,
                                                &tValueMiddleIdSubscription   ,
                                                &tValueMiddleMode             ,
                                                &tValueMiddleName             ,
                                                &tValueMiddleEmail            ,
                                                &tValueMiddlePostalCode       ,
                                                &tValueMiddleCountry          ,
                                                &tValueMiddleHawker           ,
                                                &tValueMiddleAge              ,
                                                &tValueMiddleAmountTotal      ,
                                                &tValueMiddleAmountSubtotal   ,
                                                &tValueMiddleApiVersion       ,
                                                &tValueMiddleIdProduct        ,
                                                &tValueMiddleInvoice          ,
                                                &tValueMiddleStripeNoticeType ,
                                                &tValueMiddleLive             ,
                                            {
                                            textC* pptValueMiddle[] =
                                        
                                            }
                                                etThread.delF( tin0P , postRaw ) ;
                                                __Z( pSwPathValue ) ;
                                                etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postRaw , flSTACKc_null ) ;
                                                }
                                                    }
                                                        continue ;
                                                        DEL( pInfoMiddle ) ;
                                                        etThread.traceF( tin0P , T(" skipping file name that no longer exists [long]")+T(pInfoMiddle->psttIfoName) ) ;
                                                        POOPR ;
                                                    {
                                                    if( POOP )
                                                    ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , postRaw , costRaw , pInfoMiddle->psttIfoName , 1 ) ; ___( postRaw ) ;
                                                    SCOOPS
                                                {
                                                IFsCRATCHoK
                                                
                                                ZE( countT   , costRaw ) ;
                                                ZE( osTextT* , postRaw ) ;
                                            {
                                            ZE( switchC* , pSwPathValue ) ;
                                            ZE( strokeS* , psttPath     ) ;
                                        {
                                        TN( tValueMiddleAmountDiscount   , "" ) ;
                                        TN( tValueMiddleIdSubscription   , "" ) ;
                                        TN( tValueMiddleMode             , "" ) ;
                                        TN( tValueMiddleName             , "" ) ;
                                        TN( tValueMiddleEmail            , "" ) ;
                                        TN( tValueMiddlePostalCode       , "" ) ;
                                        TN( tValueMiddleCountry          , "" ) ;
                                        TN( tValueMiddleHawker           , "" ) ;
                                        TN( tValueMiddleAge              , "" ) ;
                                        TN( tValueMiddleAmountTotal      , "" ) ;
                                        TN( tValueMiddleAmountSubtotal   , "" ) ;
                                        TN( tValueMiddleApiVersion       , "" ) ;
                                        TN( tValueMiddleIdProduct        , "" ) ;
                                        TN( tValueMiddleInvoice          , "" ) ;
                                        TN( tValueMiddleStripeNoticeType , "" ) ;
                                        TN( tValueMiddleLive             , "" ) ;

                                        etThread.traceF( tin0P , T("    ------------------------------------------------------------------------------------------------------------------------------------------------------- ")+tShortMiddle ) ;

                                        }
                                            etThread.delF( tin0P , psttShortMiddle ) ;
                                            tShortMiddle = T(psttShortMiddle) ;
                                            etThread.delF( tin0P , psttnu ) ;
                                            etThread.strBisectF( tin0P , psttnu , psttShortMiddle , pInfoMiddle->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShortMiddle ) ;
                                            ZE( strokeS* , psttShortMiddle ) ;
                                            ZE( strokeS* , psttnu ) ;
                                        {
                                        TN( tShortMiddle , "" ) ;
                                    {
                                    if( !bDir )

                                    const boolT bDir = pInfoMiddle->psttIfoName[ CSpREFIX - 1 + pInfoMiddle->psttIfoName->idAdam ].idAdam == '/' ;
                                {
                                else
                                }
                                    break ;
                                    DEL( pInfoMiddle ) ;
                                {
                                if( !pInfoMiddle || !pInfoMiddle->psttIfoName )

                                etThread.diskFindFileOrDirF( tin0P , pInfoMiddle , hFindMiddle , tSharedFolderRawIncoming ) ;
                                ZE( infoFileS* , pInfoMiddle ) ;
                            {
                            do
                            handleC hFindMiddle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                            etThread.traceF( tin0P , T("looking for [tValueOuterLatestInvoice]:    ")+tValueOuterLatestInvoice ) ;

                            _IO_
                        {
                        if( !etThread.strCompareF( tin0P , tValueOuterStripeNoticeType , tValueWantedOuterStripeNoticeType ) )
                        etThread.traceF( tin0P , T("outer [tValueOuterStripeNoticeType]:    ")+tValueOuterStripeNoticeType ) ;

                        }
                            DEL( pSwPathValue ) ;
                            
                            }
                                }
                                    etThread.delF( tin0P , psttValueOuter ) ;
                            
                                    }
                                        }
                                            //etThread.traceF( tin0P , T("********    ") + *pptKeyOuter[ offe ] + T("   :    ") + *pptValueOuter[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF , ifcIDtRACEdIVERT_f ) ;

                                            etThread.delF( tin0P , psttt ) ;
                                            *pptValueOuter[ offe ] = T(psttt) ;
                                            etThread.strTrimF( tin0P , psttt , psttValueOuter , 0 , 0 , strokeS() ) ; ___( psttt ) ;
                                            ZE( strokeS* , psttt ) ;
                                        {
                                        if( !etThread.strCompareF( tin0P , psttPath , *pptKeyOuter[ offe ] ) )
                                    {
                                    for( countT offe = 0 ; offe < cKeys ; offe ++ )
                            
                                    if( cKeys - cValues ) { BLAMMO ; }
                                    countT cValues = sizeof pptValueOuter / sizeof pptValueOuter[ 0 ] ;
                                    countT cKeys  = sizeof pptKeyOuter  / sizeof pptKeyOuter[  0 ] ;
                            
                                    //etThread.trace F( tin0P , T("--------------------------        [value]:    ")+T(psttValueOuter) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF /*, ifcIDtRACEdIVERT_e*/ ) ;
                                    //etThread.trace F( tin0P , T("-------------------------- [path]:            ")+T(psttPath)       , flTRACE_NOpREFIX | flTRACE_KEEPcRlF /*, ifcIDtRACEdIVERT_e*/ ) ;
                            
                                    strokeS*& psttValueOuter = *(strokeS**)&(countT&)*pSwPathValue ;
                                    psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                            
                                    _IO_
                                {
                                for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                            {
                            if( !POOP )
                        
                            ;
                            }
                                &tKeyOuterAmountDiscount   ,
                                &tKeyOuterIdSubscription   ,
                                &tKeyOuterMode             ,
                                &tKeyOuterName             ,
                                &tKeyOuterEmail            ,
                                &tKeyOuterPostalCode       ,
                                &tKeyOuterCountry          ,
                                &tKeyOuterHawker           ,
                                &tKeyOuterAge              ,
                                &tKeyOuterAmountTotal      ,
                                &tKeyOuterAmountSubtotal   ,
                                &tKeyOuterApiVersion       ,
                                &tKeyOuterIdProduct        ,
                                &tKeyOuterStatus           ,
                                &tKeyOuterLatestInvoice    ,
                                &tKeyOuterStripeNoticeType ,
                                &tKeyOuterLive             ,
                            {
                            textC* pptKeyOuter[] =
                            
                            TN( tKeyOuterAmountDiscount   , "\"data\"/\"object\"/\"total_details\"/\"amount_discount\"/"                 ) ;
                            TN( tKeyOuterIdSubscription   , "\"data\"/\"object\"/\"subscription\"/"                                      ) ;
                            TN( tKeyOuterMode             , "\"data\"/\"object\"/\"mode\"/"                                              ) ;
                            TN( tKeyOuterName             , "\"data\"/\"object\"/\"customer_details\"/\"name\"/"                         ) ;
                            TN( tKeyOuterEmail            , "\"data\"/\"object\"/\"customer_details\"/\"email\"/"                        ) ;
                            TN( tKeyOuterPostalCode       , "\"data\"/\"object\"/\"customer_details\"/\"address\"/\"postal_code\"/"      ) ;
                            TN( tKeyOuterCountry          , "\"data\"/\"object\"/\"customer_details\"/\"address\"/\"country\"/"          ) ;
                            TN( tKeyOuterHawker           , "\"data\"/\"object\"/\"custom_fields\"/item.00000002/\"text\"/\"value\"/"    ) ;
                            TN( tKeyOuterAge              , "\"data\"/\"object\"/\"custom_fields\"/item.00000001/\"numeric\"/\"value\"/" ) ;
                            TN( tKeyOuterAmountTotal      , "\"data\"/\"object\"/\"amount_total\"/"                                      ) ;
                            TN( tKeyOuterAmountSubtotal   , "\"data\"/\"object\"/\"amount_subtotal\"/"                                   ) ;
                            TN( tKeyOuterApiVersion       , "\"api_version\"/"                                                           ) ;
                            TN( tKeyOuterIdProduct        , "\"data\"/\"object\"/\"plan\"/\"product\"/"                                  ) ;

                            TN( tKeyOuterStatus           , "\"data\"/\"object\"/\"status\"/"                                            ) ;
                            TN( tKeyOuterLatestInvoice    , "\"data\"/\"object\"/\"latest_invoice\"/"                                    ) ;
                            TN( tKeyOuterStripeNoticeType , "\"type\"/"                                                                  ) ;
                            TN( tKeyOuterLive             , "\"livemode\"/"                                                              ) ;

                            // 
                            // 
                            // 
                            // "data" / "object" / "plan" / "product" / : "prod_RJ1XOIUO9htwyX"
                            // "type" / : "customer.subscription.created"
                            //
                            // FOR THE STUDENT REGISTRATION SUBSCRIPTION

                            ;
                            }
                                &tValueOuterAmountDiscount   ,
                                &tValueOuterIdSubscription   ,
                                &tValueOuterMode             ,
                                &tValueOuterName             ,
                                &tValueOuterEmail            ,
                                &tValueOuterPostalCode       ,
                                &tValueOuterCountry          ,
                                &tValueOuterHawker           ,
                                &tValueOuterAge              ,
                                &tValueOuterAmountTotal      ,
                                &tValueOuterAmountSubtotal   ,
                                &tValueOuterApiVersion       ,
                                &tValueOuterIdProduct        ,
                                &tValueOuterStatus           ,
                                &tValueOuterLatestInvoice    ,
                                &tValueOuterStripeNoticeType ,
                                &tValueOuterLive             ,
                            {
                            textC* pptValueOuter[] =
                        
                            }
                                etThread.delF( tin0P , postRaw ) ;
                                __Z( pSwPathValue ) ;
                                etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postRaw , flSTACKc_null ) ;

                                }
                                    }
                                        continue ;
                                        DEL( pInfoOuter ) ;
                                        etThread.traceF( tin0P , T(" skipping file name that no longer exists [long]")+T(pInfoOuter->psttIfoName) ) ;
                                        POOPR ;
                                    {
                                    if( POOP )
                                    ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , postRaw , costRaw , pInfoOuter->psttIfoName , 1 ) ; ___( postRaw ) ;
                                    SCOOPS
                                {
                                IFsCRATCHoK
                                ZE( countT   , costRaw ) ;
                                ZE( osTextT* , postRaw ) ;
                            {
                            ZE( switchC* , pSwPathValue ) ;
                            ZE( strokeS* , psttPath     ) ;
                        {
                        TN( tValueOuterAmountDiscount   , "" ) ;
                        TN( tValueOuterIdSubscription   , "" ) ;
                        TN( tValueOuterMode             , "" ) ;
                        TN( tValueOuterName             , "" ) ;
                        TN( tValueOuterEmail            , "" ) ;
                        TN( tValueOuterPostalCode       , "" ) ;
                        TN( tValueOuterCountry          , "" ) ;
                        TN( tValueOuterHawker           , "" ) ;
                        TN( tValueOuterAge              , "" ) ;
                        TN( tValueOuterAmountTotal      , "" ) ;
                        TN( tValueOuterAmountSubtotal   , "" ) ;
                        TN( tValueOuterApiVersion       , "" ) ;
                        TN( tValueOuterIdProduct        , "" ) ;

                        TN( tValueOuterStatus           , "" ) ;
                        TN( tValueOuterLatestInvoice    , "" ) ;
                        TN( tValueOuterStripeNoticeType , "" ) ;
                        TN( tValueOuterLive             , "" ) ;

                        etThread.traceF( tin0P , T("------------------------------------------------------------------------------------------------------------------------------------------------------- ")+tShortOuter ) ;

                        }
                            etThread.delF( tin0P , psttShortOuter ) ;
                            tShortOuter = T(psttShortOuter) ;
                            etThread.delF( tin0P , psttnu ) ;
                            etThread.strBisectF( tin0P , psttnu , psttShortOuter , pInfoOuter->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShortOuter ) ;
                            ZE( strokeS* , psttShortOuter ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShortOuter , "" ) ;
                    {
                    if( !bDir )

                    const boolT bDir = pInfoOuter->psttIfoName[ CSpREFIX - 1 + pInfoOuter->psttIfoName->idAdam ].idAdam == '/' ;
                {
                else
                }
                    break ;
                    DEL( pInfoOuter ) ;
                {
                if( !pInfoOuter || !pInfoOuter->psttIfoName )

                etThread.diskFindFileOrDirF( tin0P , pInfoOuter , hFindOuter , tSharedFolderRawIncoming ) ;
                ZE( infoFileS* , pInfoOuter ) ;
            {
            do
            handleC hFindOuter( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            etThread.traceF( tin0P , T("raw notices / [cNewIncoming]:    ")+TF2(cNewIncoming,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            ZE( countT , cNewEvents ) ;

            _IO_
        {
        if( cNewIncoming )                                                                                                                                      // IF EXIST NEWLY INCOMING RAW NOTICES
        countT cNewIncoming = etThread.diskFileExistsF( tin0P , tSharedFolderRawIncoming+tStar ) ;                                                                    // IF EXIST NEWLY INCOMING RAW NOTICES

        _IO_
    {
    while( !ether && !etThread )
    TN( tStar  , "*" ) ;
    TN( tSlash , "/" ) ;

    ranUniC ruPassword( tin0P , (measure04T)MAXcOUNTT + 1 , processGlobal1S::_processGlobal1I_IF().trueRandom ) ;

    etThread.diskMakeDirIfNeededF( tin0P , tSharedFolderEventDone       ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tSharedFolderEventRetryLater ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tSharedFolderEventIncoming   ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tSharedFolderRawDone         ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tSharedFolderRawIncoming     ) ;

    TN( tValueWantedInnerStripeNoticeType  , "customer.subscription.updated" ) ;
    TN( tValueWantedMiddleStripeNoticeType , "checkout.session.completed"    ) ;
    TN( tValueWantedOuterStripeNoticeType  , "customer.subscription.created" ) ;

    TN( tn                       , ""                              ) ;
    TN( tb4                      , "    "                          ) ;
    TN( tcrlf                    , "\r\n"                          ) ;
    TN( tCorrectStripeNoticeType , "customer.subscription.created" ) ;
    TN( tCorrectApiVersion       , "2023-10-16"                    ) ;
    TN( tFalse                   , "false"                         ) ;
    TN( tTrue                    , "true"                          ) ;

    TN( tSharedFolderEventDone       , "" ) ; tSharedFolderEventDone       = tSharedFolderPrefix+T("events.3.done/"             ) ;
    TN( tSharedFolderEventRetryLater , "" ) ; tSharedFolderEventRetryLater = tSharedFolderPrefix+T("events.2.retry.later/"      ) ;
    TN( tSharedFolderEventIncoming   , "" ) ; tSharedFolderEventIncoming   = tSharedFolderPrefix+T("events.1.incoming/"         ) ;
    TN( tSharedFolderRawDone         , "" ) ; tSharedFolderRawDone         = tSharedFolderPrefix+T("raw.notices.2.done/"        ) ;
    TN( tSharedFolderRawIncoming     , "" ) ; tSharedFolderRawIncoming     = tSharedFolderPrefix+T("raw.notices.1.incoming/"    ) ;
    TN( tSharedFolderPrefix          , "" ) ; tSharedFolderPrefix          = T("///z/ideafarm.shared/precious/")+TfORsTRING(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T("/") ;

    //  
    //          move the input file to ether "done" or "retry later" folder
    //  
    //              send "thank you" email
    //  
    //                  logout
    //  
    //                  if age >= 16 and student then invite to space
    //  
    //                  if age >= 13 and age <= 29 then invite to space
    //  
    //                  if age >= 13 then invite to space
    //  
    //                  login
    //  
    //                  register new username
    //  
    //                  obtain nonce
    //  
    //              try until fired
    //  
    //          if "create subscription" and age >= 13 and is either for student or visitor
    //  
    //          load the field values
    //  
    //      for each file (not dir) in unique "my events" folder
    //  
    //          try to move the file to a unique "my events" folder
    //  
    //      for each file (not dir) in tSharedFolderEventIncoming 
    //  
    //                                  nap a random time ([0,8] tocks)
    //  
    //                                  delete the "maybe" folder
    //  
    //                                  move the 3 files back to "raw incoming" folder
    //  
    //                              else
    //  
    //                                  delete the "ready" folder
    //  
    //                                  move the 3 files to "raw done" folder
    //  
    //                                  emit an event file
    //  
    //                                  rename "maybe" folder to "ready"
    //  
    //                              if moved 3 aok
    //  
    //                          try to move the 3 files to a new unique folder
    //  
    //                      if active
    //  
    //                                  update active
    //  
    //                              if wanted for inner and matching invoice
    //  
    //                          for each file (not dir) in tSharedFolderRawIncoming
    //  
    //                      if not active
    //  
    //                  if wanted for middle with matching invoice
    //  
    //              for each file (not dir) in tSharedFolderRawIncoming
    //  
    //          if wanted for outer
    //  
    //      for each file (not dir) in tSharedFolderRawIncoming
    //  
    // PSEUDOCODE (AS OF 20250103@1619)

    // 20250103@1627: WOI: I SEE NO ERRORS IN THE ABOVE PSEUDOCODE THAT WOULD CONFLICT WITH ANY OF THESE OBJECTIVES ; (TIME AND TESTING WILL TELL)

    // * IF A SERVER DIES WHILE PROCESSING INPUT, NO DATA WILL BE LOST AND AND ADMINISTRATOR CAN EASILY RECOVER BY MANUALLY MOVING FILES BACK TO AN INPUT FOLDER
    // * INFINITELY SCALABLE
    // * INPUT IS PROCESSED CORRECTLY
    //
    // OBJECTIVES
    // THE DESIGN OBJECTIVE IS TO SUPPORT MULTIPLE SERVERS ALL RECEIVING WEBHOOK NOTICES SENT TO THE SAME DOMAIN NAME (CURRENTLY webhooks.ideafarm.com)
    // THIS CODE IS DESIGNED FOR INFINITE SCALABILITY

    _IO_
{
if( pTaskP )
TASK( tmWorkF )

#define flFAIL_UNKNOWNpRODUCT                   0xe01000ff
#define flFAIL_COULDnOTzAPrAW                   0xe00800ff
#define flFAIL_COULDnOTgEThMAC                  0xe00400ff
#define flFAIL_COULDnOTpUTrAW                   0xe00200ff
#define flFAIL_COULDnOTgETsHAREDsECRET          0xe00100ff
#define flFAIL_UNEXPECTEDaGEtOOyOUNG            0xe00080ff
#define flFAIL_UNEXPECTEDvERSION                0xe00010ff
#define flFAIL_UNEXPECTEDeVENT                  0xe00008ff
#define flFAIL_COULDnOTmOVEfILE                 0xe00004ff
#define flFAIL_COULDnOTgETsHADOW                0xe00002ff
#define flFAIL_UNKNOWNeRROR                     0xe00001ff

//OBSOLETES 87f_, WHICH DID NOT VERIFY "active" STATUS FOR THE SUBSCRIPTION

/*1*/WAKEhIDE( "ifcIDaDAM_EATiNCOMINGoRDERS" )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

