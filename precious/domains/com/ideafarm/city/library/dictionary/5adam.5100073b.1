
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

THREADmODE2rESTORE
THREADmODE3rESTORE
}
    etThread.traceF( tinBaseP , T("chattered  uri.access.events") ) ;
    }
        POPtINaRGS
        listC::walkIF( tinBaseP , pczEvents , flLISToPEN_IFeXISTS ) ;

        ((tinFullS&)tinBaseP).ta.retained.u.listWalk.util.pcP[ 3 ] = (countT)&hFileReport ;
        ((tinFullS&)tinBaseP).ta.retained.u.listWalk.util.pcP[ 2 ] = 0 ;                                         // WILL HOLD idJotUri       FOR THE URI CURRENTLY BEING PROCESSED
        ((tinFullS&)tinBaseP).ta.retained.u.listWalk.util.pcP[ 1 ] = 0 ;                                         // WILL HOLD idJotContainer FOR THE URI CURRENTLY BEING PROCESSED
        ((tinFullS&)tinBaseP).ta.retained.u.listWalk.util.pcP[ 0 ] = sizeof( countT ) ;

        ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.util.pcP[ 1 ] = flLISTwALKcHATTER_MAPiDjOTvALUES ;
        ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.util.pcP[ 0 ] = pczEvents[ 1 ] ;
        ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.flagsWalkP = flLISTwALK_IGNOREdELETErEQUESTEDbIT ;
        ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.pListWalkCBFP = listWalkReportAccessEventsCBF ;
        PUSHtINaRGS

        grabitC grabitx( tinBaseP , TAG( TAGiDnULL ) ) ;
    {
    etThread.traceF( tinBaseP , T("chattering uri.access.events") ) ;

    listC::dictionaryReplaceOsTextIF( tinBaseP , pczEvents ) ;
    countT pczEvents[] = { LISTnAMEsYS_ROOT , LISTnAMEsYS_ROOTaPPLICATION , (countT)"listAccessEeventsByContainerUri" , 0 } ;

    listC::chatterIF( tinBaseP ) ;

    puseC puseEvents( tinBaseP , "uri.access.events" , flPOOLc_DOnOTiNDEXdURINGcT , ifcIDsTATEsPACE_MULTIPLEaDAMS , 3 , 6 ) ;
    puseC puseAT( tinBaseP , ifcIDpOOL_ADAMtEMP ) ;

    handleC hFileReport( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
{
THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY )
THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

jotC jhsOther(   tinBaseP , "jotAccessEvents.hash.string.other"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 ) ;   // [STRING]; WO JOT PER UNIQUE STRING
jotC jhsBrowser( tinBaseP , "jotAccessEvents.hash.string.browser" , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 ) ;   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jotC jhsQuery(   tinBaseP , "jotAccessEvents.hash.string.query"   , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 ) ;   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
jotC jhsUri(     tinBaseP , "jotAccessEvents.hash.string.uri"     , flJOTc_WRITE , TICK << 2 , TOCK << 6 , 1 ) ;   // [HASH,STRING]; WO JOT PER UNIQUE STRING (A GIVEN HASH VALUE MIGHT APPEAR IN MULTIPLE JOTS)
//CS:CODEsYNC: 73a 740 (THESE MUST BE CT IN THE SAME ORDER SO THAT THE SAME TAG VALES ARE ASSIGNED

if( tinBaseP.idTypeTin - ifcIDtYPEtIN_FULL ) { BLAMMOiD( tinBaseP.idTypeTin - ifcIDtYPEtIN_FULL ) ; }

TODO

}
    return flrc ;

    THREADmODE3rESTORE
    THREADmODE4rESTORE

    }
        }
            }
                }
                    }
                        ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , pstto ) ;
                        POOPR
                    {
                    else
                    }
                        break ;
                        ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , pstto ) ;
                        ((tinFullS&)tinBaseP).pEtScratch->traceF( tinBaseP , pstto ) ;
                    {
                    if( !POOP )

                    if( flagsi & fliLISTINGc_DELETErEQUESTED ) ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("DELETErEQUESTED") ) ;

                    }
                        THREADmODE2rESTORE
                        }
                            ((tinFullS&)tinBaseP).tlsDelF( *(byteT**)&pczHe ) ;
                            //{ puseC puseat( tinBaseP , ifcIDpOOL_ADAMtEMP ) ; PUSE( tinBaseP , *(byteT**)&pczHe ) ; }

                            }
                                if( pczHe[ ++ offo ] ) { ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("/") ) ; }
            
                                }
                                    }
                                        ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("\"") ) ;
                                        ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T((const byteT*)vspo) ) ;
                                        ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("\"") ) ;
                                    {
                                    else            
                                    if( !(const byteT*)vspo ) { ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , TF2(pczHe[offo],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; }
                
                                    if( bUseDictionary ) vspo = listC::dictionaryQueryFromIdIF( tinBaseP , pczHe[ offo ] ) ;
                                    blobVSP vspo ;
                                {
                                else
                                if( postzMap ) { ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(postzMap) ) ; }
                                const osTextT* postzMap = pg3.mapListName( pczHe[ offo ] ) ;
                            {
                            while( pczHe[ offo ] )
                            countT offo = 0 ;
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(" Refers to: ") ) ;

                            ((const listingC*)vspValue)->nameF( tinBaseP , pczHe ) ; //___( pczHe ) ;
                            ZE( countT* , pczHe ) ;

                            if( flagsi & fliLISTINGc_DELETErEQUESTED ) ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(" DELETErEQUESTED") ) ;
                            }
                                ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("\"") ) ;
                                ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(postNamePool) ) ;
                                ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(" in pool: \"") ) ;
                            {
                            if( postNamePool )
                            const osTextT* postNamePool = ((tinFullS&)tinBaseP).pPoolUse ? ((tinFullS&)tinBaseP).pPoolUse->postNameF( tinBaseP ) : 0 ;
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , TF2(aptRef,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(" a: ") ) ;
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , TF2((countT)(const listingC*)vspValue,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("listingVSP: p: ") ) ;
            
                            aptC aptRef( tinBaseP , vspValue ) ;
            
                            puseC puseRecord( tinBaseP , *pPool ) ;

                            __Z( pPool ) ;
                            poolC* pPool = poolC::pPoolIF( tinBaseP , (byteT*)(const listingC*)vspValue ) ;
                        {
                        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING ) ;
                    {
                    else if( (const listingC*)vspValue )
                    }
                        }
                            if( pczValue[ ++ offo ] ) { ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("/") ) ; }

                            }
                                }
                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("\"") ) ;
                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T((const byteT*)vspo) ) ;
                                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("\"") ) ;
                                {
                                else            
                                if( !(const byteT*)vspo ) { ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , TF2(pczValue[offo],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ; }
            
                                if( bUseDictionary ) vspo = listC::dictionaryQueryFromIdIF( tinBaseP , pczValue[ offo ] ) ;
                                blobVSP vspo ;
                            {
                            else
                            if( postzMap ) { ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(postzMap) ) ; }
                            const osTextT* postzMap = pg3.mapListName( pczValue[ offo ] ) ;
                        {
                        while( pczValue[ offo ] )
                        countT offo = 0 ;

                        ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("countTstrz: ") ) ;
                    {
                    else if( pczValue )
                    }
                        }
                            ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , psttw ) ;
                            if( bPartial ) ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , (strokeS*)( T(" ... (there are ")+TF2(cbv,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" total bytes)") ) ) ;
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(psttw) ) ;
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("blob):\r\n") ) ;
                            ((tinFullS&)tinBaseP).pEtScratch->strDumpIF( tinBaseP , psttw , postValue , bPartial ? TUCK : cbv , flSTRdUMP_null , 0x20 , 4 , '~' ) ; ___( psttw ) ;
                            ZE( strokeS* , psttw ) ;

                            }
                                countT foo = 2 ;
                            {
                            if( idIn == 0x18 )

                            countT idIn = 1 + incv02AM( idInLath ) ;
                            static countT idInLath ;

                            boolT bPartial = cbv > TUCK ;
                        {
                        else
                        }
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("\"") ) ;
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(postValue) ) ;
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("blob: \"") ) ;
                        {
                        if( bText )

                        }
                            }
                                }
                                    break ;
                                    bText = 0 ;
                                {
                                if( !test || test < 0x20 || test > 0x7f )
                                byteT test = postValue[ offi ] ;
                            {
                            for( countT offi = 0 ; offi < offNull ; offi ++ )
                        {
                        if( bText )
                        byteT  bText = !postValue[ offNull ] ;
                        countT offNull = cbv - 1 ;
                        countT cbv = ((countT*)postValue)[ - 1 ] ;
                    {
                    else if( postValue )
                    }
                        }
                            }
                                ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , psttJot ) ;
                                ((tinFullS&)tinBaseP).pEther->fileWriteF( tinBaseP , hFileReportP , tSay , tSay.csF( tinBaseP ) ) ;
                                TN( tSay , "" ) ; tSay = T("\r\n")+T(psttJot) ;

                                ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , tb4+T(psttJot) ) ;
                            {
                            else
                            if( POOP ) POOPR
                            ((tinFullS&)tinBaseP).pEtScratch->strFromIdJotF( tinBaseP , psttJot , *pcValue , cbJotStringDecodePrefixP ) ; ___( psttJot ) ;
                            ZE( strokeS* , psttJot ) ;
                        {
                        if( F(flagsP) & flLISTwALKcHATTER_MAPiDjOTvALUES )

                        ((tinFullS&)tinBaseP).pEther->fileWriteF( tinBaseP , hFileReportP , tSay , tSay.csF( tinBaseP ) ) ;
                        TN( tSay , "" ) ; tSay = T("\r\n")+T("countT: ")+TF2(*pcValue,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ;

                        ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , TF2(*pcValue,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("countT: ") ) ;
                    {
                    if( pcValue )

                    }
                        ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(" ") ) ;
                        ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , TF2(cName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    else if( cName )
                    }
                        ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(" ") ) ;
                        ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(postzName) ) ;
                    {
                    if( postzName )
                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(postMark) ) ;
                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(" | ") ) ;
                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , TF2(aptListing,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(" | a: ") ) ;
                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , TF2((countT)pListing,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(" | p: ") ) ;
                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , TF2(((tinFullS&)tinBaseP).ta.pushed.u.listWalk.walk.cRecurseP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(" | ") ) ;
                    ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(((tinFullS&)tinBaseP).pPoolUse->postNameF(tinBaseP)) ) ;

                    ((tinFullS&)tinBaseP).pEtScratch->strMakeF( tinBaseP , LF , pstto , 0 , max ) ; ___( pstto ) ;
                    ZE( strokeS* , pstto ) ;
                {
                for( countT max = TOCK ;; max <<= 1 )
                SCOOPS
            {
            IFsCRATCH

            }
                }
                    if( (const byteT*)vspbName ) postzName = (const byteT*)vspbName ;
                    vspbName = listC::dictionaryQueryFromIdIF( tinBaseP , cName ) ;
                {
                else if( bUseDictionary && cName )
                if( postzMap ) postzName = postzMap ;

                }
                    countT foo = 2 ;
                {
                if( postzMap && !thirdC::c_strcmpIF( tinBaseP , postzMap , "ROOTaPPLICATION" ) )

                const osTextT* postzMap = pg3.mapListName( cName ) ;

                cName = pList->nameF() ;
                listC* pList = (listC*)pListing ;
            {
            if( flagsi & fliLISTINGc_MIXINlIST )
            ZE( const byteT* , postzName ) ;
            blobVSP vspbName ;
            ZE( countT   , cName ) ;
    
            ;
                : "listing "
                ? "LIST    "
            osTextT* postMark = flagsi & fliLISTINGc_MIXINlIST
    
            }
                }
                    }
                        default                             : { BLAMMO                                                ; break ; }
                        case ifcIDtYPEmIXINdATUM_listingVSP : { vspValue  =             *(list_listingVSP_C*)pListing ; break ; }
                        case ifcIDtYPEmIXINdATUM_countTstrz : { pczValue  =    (countT*)*(list_countTstrz_C*)pListing ; break ; }
                        case ifcIDtYPEmIXINdATUM_blob       : { postValue =         (osTextT*)*(list_blob_C*)pListing ; break ; }
                        case ifcIDtYPEmIXINdATUM_countT     : { pcValue   =        (countT*)*(list_countT_C*)pListing ; break ; }
                    {
                    switch( pListing->idTypeDatumF() ) //CS:CODEsYNC: 00104b0 21e0006 21e0002 21e0008 21e0009 220000e
                {
                else
                }
                    }
                        default                             : { BLAMMO                                                ; break ; }
                        case ifcIDtYPEmIXINdATUM_listingVSP : { vspValue  =          *(listing_listingVSP_C*)pListing ; break ; }
                        case ifcIDtYPEmIXINdATUM_countTstrz : { pczValue  = (countT*)*(listing_countTstrz_C*)pListing ; break ; }
                        case ifcIDtYPEmIXINdATUM_blob       : { postValue =      (osTextT*)*(listing_blob_C*)pListing ; break ; }
                        case ifcIDtYPEmIXINdATUM_countT     : { pcValue   =     (countT*)*(listing_countT_C*)pListing ; break ; }
                    {
                    switch( pListing->idTypeDatumF() ) //CS:CODEsYNC: 00104b0 21e0006 21e0002 21e0008 21e0009 220000e
                {
                if( !( flagsi & fliLISTINGc_MIXINlIST ) )
            {
            if( flagsi & fliLISTINGc_MIXINdATUM )
            flagsT flagsi = pListing->flagsF() ;
    
            listingVSP       vspValue ;
            ZE( countT*  , pczValue ) ;
            ZE( osTextT* , postValue ) ;
            ZE( countT*  , pcValue ) ;
        {
        else
        }
            flrc |= flLISTwALKcALLbACKrETURNcODE_QUIT ;
            CONoUTrAW( "EXCEPTION: An apartment was encountered that does not contain a valid listingC object.  quitting\r\n" ) ;
        {
        if( !listingC::bIsListingIF( tinBaseP , aptListing ) )

        aptC aptListing( tinBaseP , pListing ) ;
    {
    if( pListing )
    flagsT flrc = flLISTwALKcALLbACKrETURNcODE_null ;

    }
        }
            }
                }
                    ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , pstto ) ;
                    POOPR
                {
                else
                }
                    break ;
                    ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , pstto ) ;
                    ((tinFullS&)tinBaseP).pEtScratch->traceF( tinBaseP , pstto ) ;
                {
                if( !POOP )

                { puseC puseat( tinBaseP , ifcIDpOOL_ADAMtEMP ) ; PUSE( tinBaseP , *(byteT**)&pczSquished ) ; }
                ((tinFullS&)tinBaseP).tlsDelF( *(byteT**)&pczName ) ;
                //{ puseC puseat( tinBaseP , ifcIDpOOL_ADAMtEMP ) ; PUSE( tinBaseP , *(byteT**)&pczName ) ; }
                }
                    if( pczSquished[ ++ offi ] ) { ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("/") ) ; }

                    }
                        }
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("\"") ) ;
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T((const byteT*)vspo) ) ;
                            ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T("\"") ) ;
                        {
                        else            
                        if( !(const byteT*)vspo ) { ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , TF2(pczSquished[offi],flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ; }
            
                        if( bUseDictionary ) vspo = listC::dictionaryQueryFromIdIF( tinBaseP , pczSquished[ offi ] ) ;
                        blobVSP vspo ;
                    {
                    else
                    if( postzMap ) { ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(postzMap) ) ; }

                    const osTextT* postzMap = pg3.mapListName( pczSquished[ offi ] ) ;
                {
                while( pczSquished[ offi ] )
                ZE( countT , offi ) ;

                }
                    }
                        ((tinFullS&)tinBaseP).pEther->fileWriteF( tinBaseP , hFileReportP , tSay , tSay.csF( tinBaseP ) ) ;

                        ) ;

                            "\r\n"
                            "Uri" ":        ")+TF2(idJotUriP      ,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+tUri+T("\r\n"
                            "Container:  ")+TF2(idJotContainerP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+tb4+tContainer+T("\r\n"
                            "\r\n"
                            "Access History Report\r\n"
                            "\r\n"
                            "IDEAFARM.COM\r\n"

                        TN( tSay , "" ) ; tSay = T(

                        ((tinFullS&)tinBaseP).pEther->fileOpenF( tinBaseP , hFileReportP , countTC() , T("///d/web.reports/access/")+tContainer+tSlash+tUri+T(".txt") , ifcOPENaCCESS_W , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nCeR , flFILEaTTR1_null , flFILEaTTR2_null , 0 , 0 ) ;                    

                        etherC::etRockIF( tinBaseP ).traceF( tinBaseP , T("writing/replacing report file [container,uri]:    ")+tb4+tContainer+tb4+tUri ) ;

                        }
                            ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , psttWant ) ;
                            tUri = T(psttWant) ;
                            ((tinFullS&)tinBaseP).pEther->strSubstringF( tinBaseP , psttWant , idf , idl , tUri ) ; ___( psttWant ) ;
                            ZE( countT , idl ) ;
                            countT idf = idHit + tLook.csF( tinBaseP ) ;
                            ZE( strokeS* , psttWant ) ;
                        {
                        if( idHit )
                        countT idHit = ((tinFullS&)tinBaseP).pEther->strIdF( tinBaseP , tLook , tUri ) ;
                        TN( tLook , ".rackcdn.com/" ) ;

                        ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , psttJotUri       ) ;
                        ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , psttJotContainer ) ;
                        TN( tUri       , psttJotUri       ) ;
                        TN( tContainer , psttJotContainer ) ;
                    {
                    else
                    }
                        ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , psttJotUri       ) ;
                        ((tinFullS&)tinBaseP).pEtScratch->delF( tinBaseP , psttJotContainer ) ;
                        POOPR
                    {
                    if( POOP )
                    ((tinFullS&)tinBaseP).pEtScratch->strFromIdJotF( tinBaseP , psttJotUri       , idJotUriP       , cbJotStringDecodePrefixP ) ; ___( psttJotUri       ) ;
                    ((tinFullS&)tinBaseP).pEtScratch->strFromIdJotF( tinBaseP , psttJotContainer , idJotContainerP , cbJotStringDecodePrefixP ) ; ___( psttJotContainer ) ;
                    ZE( strokeS* , psttJotUri       ) ;
                    ZE( strokeS* , psttJotContainer ) ;

                    if( ~hFileReportP ) hFileReportP.closeIfF() ;
                    idJotUriP       = pczSquished[ 0xd ] ;
                    idJotContainerP = pczSquished[ 0x7 ] ;

                    puseC puseat( tinBaseP , ifcIDpOOL_ADAMtEMP ) ;
                {                                                                                                                                                     //          0    1               2                                 3                 4        5          6                 7        8          9                 a        b          c                 d        e
                if( pczSquished && 0xe <= thirdC::c_strlenIF( tinBaseP , pczSquished ) && ( idJotContainerP != pczSquished[ 0x7 ] || idJotUriP != pczSquished[ 0xd ] ) )  // EXAMPLE: ROOT/ROOTaPPLICATION/"listAccessEeventsByContainerUri"/STRETCHbEGINcOUNT/d99bfcf8/STRETCHeND/STRETCHbEGINcOUNT/3000000b/STRETCHeND/STRETCHbEGINcOUNT/c945d60d/STRETCHeND/STRETCHbEGINcOUNT/10000008/STRETCHeND/STRETCHbEGINcOUNTsTRZ/acd3b/76054e6d/44494263/STRETCHeND/RECORD/"browser"

                { puseC puseat( tinBaseP , ifcIDpOOL_ADAMtEMP ) ; etherC::strSquishIF( tinBaseP , pczSquished , pczName ) ; ___( pczSquished ) ; }     //U::20240828@1056: THIS OVERLOAD OF strSquishIF NOW RETURNS OUTPUT STRING LENGTH AND OUTPUT STRING CAN NOW CONTAIN NULL VALUES
                ZE( countT* , pczSquished ) ;

                ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pDadP->nameF( tinBaseP , pczName ) ; // ___( pczName ) ;
                ZE( countT* , pczName ) ;

                ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(bUseDictionary?" | ------------------------------------------------------------------------------- ":" | ------------------------------------------------------------------------------- (NO DICTIONARY LOOKUP) ") ) ;
                ((tinFullS&)tinBaseP).pEtScratch->strFuseF( tinBaseP , pstto , T(((tinFullS&)tinBaseP).pPoolUse->postNameF(tinBaseP)) ) ;

                ((tinFullS&)tinBaseP).pEtScratch->strMakeF( tinBaseP , LF , pstto , 0 , max ) ; ___( pstto ) ;
                ZE( strokeS* , pstto ) ;
            {
            for( countT max = TOCK ;; max <<= 1 )
            SCOOPS
        {
        IFsCRATCH
    {
    if( ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.idCallP == 1 )
    processGlobal4S& pg3 = processGlobal4S::_processGlobal4I_IF() ;

    TN( tSlash , "/" ) ;
    TN( tb4 , "    " ) ;

    THREADmODE4oN( flTHREADmODE4_POOLaLLOCATEfROMhEAP )                         // MY CALLER MIGHT HAVE GRABBED LISTnAMEsYS_ROOT, WHICH COULD DEADLOCK sexC::sexC
    THREADmODE3oN( flTHREADmODE3_ALLOWdICTIONARYwHILEgRABBING )

    ;
        && ( levelOoNameUse != LISTnAMEsYS_ROOTsYSTEM2 || levelReNameUse != LISTnAMEsYS_DICTIONARY )
             levelOoNameUse 
    const boolT bUseDictionary =                                             // 20180508@1624: AVOID DICTIONARY IF SYSTEM1 OR SYSTEM3 (ADDED WITHOUT ANALYSIS TO ELIMINATE DEADLOCK IN ADAM 206 (602_) WHICH USED TO WORK AOK)

    const countT levelReNameUse = levelReNameMe ? levelReNameMe : levelReNameDad ;
    const countT levelOoNameUse = levelOoNameMe ? levelOoNameMe : levelOoNameDad ;

    const countT levelReNameDad = !((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pDadP ? 0 : ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pDadP->nameF( 3 ) ;
    const countT levelReNameMe  = !pListing                          ? 0 : pListing->nameF( 3 )                          ;

    const countT levelOoNameDad = !((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pDadP ? 0 : ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pDadP->nameF( 2 ) ;
    const countT levelOoNameMe  = !pListing                          ? 0 : pListing->nameF( 2 )                          ;

    //U::FV( flLISTwALKcHATTER , flagsP ) ;

    handleC&  hFileReportP             = *(handleC*)((tinFullS&)tinBaseP).ta.retained.u.listWalk.util.pcP[ 3 ] ;
    countT&   idJotUriP                =            ((tinFullS&)tinBaseP).ta.retained.u.listWalk.util.pcP[ 2 ] ;
    countT&   idJotContainerP          =            ((tinFullS&)tinBaseP).ta.retained.u.listWalk.util.pcP[ 1 ] ;
    countT    cbJotStringDecodePrefixP =            ((tinFullS&)tinBaseP).ta.retained.u.listWalk.util.pcP[ 0 ] ;

    flagsT    flagsP                   =            ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.util.pcP[ 1 ] ;
    listingC* pListing                 =            ((tinFullS&)tinBaseP).ta.pushed.u.listWalk.cbf.pListingP ;

    if( tinBaseP.idTypeTin - ifcIDtYPEtIN_FULL ) { BLAMMOiD( tinBaseP.idTypeTin - ifcIDtYPEtIN_FULL ) ; }
{
flagsT listWalkReportAccessEventsCBF( tinBaseS& tinBaseP )


/*1*/WAKEsHOWtEXT( "ifcIDaDAM_ACCESSeVENTS4rEPORT" )/*1*/
/**/
*/
i will eventually report on the contents of the access list (database)
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
