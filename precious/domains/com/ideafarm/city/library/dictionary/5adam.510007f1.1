
REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

}
    }
        etThread.delF( tinP , pbi ) ;

        }
            }
                }
                    }
                        sock.writeF( tinP , idpi , nni , (byteT*)&epOut , sizeof epOut ) ;
                        etThread.traceF( tinP , T("throwing ")+TF2(epOut.idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" to port ")+TF2(idpi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" of ")+T(nni) ) ;

                        epOut.cbData = 0 ;
                        epOut.idType = ifcIDtYPEeCHOpACKET_ECHOrEPLY ;
                        echoPacketS epOut = epIn ;

                        }
                            }
                                if( ids ) etThread.traceF( tinP , T("remembering [nn]:    ")+T(nnHe) ) ;
                                stNicNameKnown.sinkF( tinP , ids , nnHe , flSTACKsINK_UNIQUE , 0 , 0 ) ;
                                ZE( countT , ids ) ;

                                nicNameC& nnHe = *( pnni ++ ) ;
                            {
                            while( cIn -- )
                            nicNameC* pnni = (nicNameC*)( pbi + sizeof( echoPacketS ) ) ;
                            countT cIn = epIn.cbData / sizeof( nicNameC ) ;
                        {
                        if( cbi == ifcCBdATAGRAMmAX && epIn.cbData >= sizeof( nicNameC ) && !( epIn.cbData % sizeof( nicNameC ) ) )
                    {
                    case ifcIDtYPEeCHOpACKET_ECHO :
                {
                switch( epIn.idType )

                if( ids ) etThread.traceF( tinP , T("remembering [nn]:    ")+T(nni) ) ;
                stNicNameKnown.sinkF( tinP , ids , nni , flSTACKsINK_UNIQUE , 0 , 0 ) ;
                ZE( countT , ids ) ;

                etThread.traceF( tinP , T("caught   ")+TF2(epIn.idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" from port ")+TF2(idpi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" of ")+T(nni) ) ;
            {
            if( getNegAM( epIn.finger ) == FINGERnEG_echoPacketS )
            echoPacketS& epIn = *(echoPacketS*)pbi ;
        {
        if( !ether && cbi >= sizeof( echoPacketS ) )

        }
            etThread.traceF( tinP , T("oops!") ) ;
            POOPR
        {
        if( POOP )
        sock.readF( tinP , pbi , cbi , idpi , nni ) ;
        nicNameC nni ;
        ZE( countT , idpi ) ;
        ZE( countT , cbi ) ;
        ZE( byteT* , pbi ) ;
    {
    while( !ether )

    etThread.osThreadF( TaRG1( tmOpenDoorToAllF ) , (countT)&sock , (countT)&stNicNameKnown ) ;
    idPortBind = sock.bindF( tinP , idPortBind ) ;
    socketC sock( tinP , *tinP.pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    SCOOPS
{
IFsCRATCH

}
    etThread.delF( tinP , pnnTo ) ;

    }
        if( ids ) etThread.traceF( tinP , T("remembering [nn]:    ")+T(pnnTo[offn]) ) ;
        stNicNameKnown.sinkF( tinP , ids , pnnTo[ offn ] , flSTACKsINK_UNIQUE , 0 , 0 ) ;
        ZE( countT , ids ) ;

        etThread.traceF( tinP , T("black  :    ")+T(pnnTo[offn]) ) ;
    {
    for( countT offn = 0 ; offn < cnnTo  ; offn ++ )
    socketC::nicNameIF( tinP , etThread , pnnTo  , cnnTo  , ppsttTo[ offt ] ) ;
    ZE( countT    , cnnTo  ) ;
    ZE( nicNameC* , pnnTo  ) ;
{
for( countT offt = 0 ; offt < sizeof ppsttTo / sizeof ppsttTo[ 0 ] ; offt ++ )

strokeS* ppsttTo[] = { tEcho /*, tBlack6 , tBlack4*/ } ;

TN( tBlack4  , "192.168.24.32" ) ;
TN( tBlack6  , "2600:380:442e:e76a:3309:635e:c64f:6d6f" ) ;
TN( tEcho    , "echo.ideafarm.com" ) ;

stackC stNicNameKnown( tinP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_nicNameC ) ;

TODO

DONE( tmOpenDoorToAllF )
}
    }
        ++ s ; ether.osSleepF( tinP , TOCK ) ;

        stNicNameKnownP.ungrabF( tinP ) ;
        }
            }
                while( ~hStk ) ;
                }
                    pSock->writeF( tinP , idPortTo , nnHe , pbGram , sizeof pbGram ) ;
                    etThread.traceF( tinP , T("throwing ")+TF2(pepOut->idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" to port ")+TF2(idPortTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(" of ")+T(nnHe) ) ;

                    nicNameC& nnHe = *(nicNameC*)&stNicNameKnownP.downF( tinP , hStk ) ;
                {
                do
                handleC hStk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {

            }
                while( ~hStk ) ;
                }
                    else break ;
                    }
                        cnnDone ++ ;
                        pepOut->cbData += sizeof nnHe ;
                        *( pnnOut ++ ) = nnHe ;
                    {
                    else if( cRemain -- )
                    if( cnnSkip ) cnnSkip -- ;

                    nicNameC& nnHe = *(nicNameC*)&stNicNameKnownP.downF( tinP , hStk ) ;
                {
                do
                handleC hStk( tinP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                countT cnnSkip = cnnDone ;
                if( stNicNameKnownP <= cnnDone ) cnnDone = 0 ;
            {

            pepOut->idType = ifcIDtYPEeCHOpACKET_ECHO ;
            putNegAM( pepOut->finger , FINGERnEG_echoPacketS ) ;

            ZE( countT , cnnThis ) ;
            countT       cRemain = CBpAYLOAD / sizeof( nicNameC ) ;
            nicNameC*    pnnOut = (nicNameC*)( pbGram + sizeof( echoPacketS ) ) ;
            echoPacketS* pepOut = (echoPacketS*)pbGram ;
            thirdC::c_memsetIF( tinP , pbGram , sizeof pbGram ) ;
            byteT pbGram[ sizeof( echoPacketS ) + CBpAYLOAD ] ;
        {
        if( stNicNameKnownP )
        stNicNameKnownP.grabF( tinP , TAG( TAGiDnULL ) ) ;

        idPass ++ ;
    {
    while( !ether )
    ZE( countT , cnnDone ) ;
    ZE( countT , idPass ) ;
    sleepC s( tinP , TAG( TAGiDnULL ) ) ;
    countT idSayLath  = 0x10000000 ;

    stackC&  stNicNameKnownP = *(stackC*)pTaskP->c2 ;
    socketC* pSock           = (socketC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmOpenDoorToAllF )

countT idPortTo   = 0xfade ;
countT idPortBind = 0xfade ;

#define CBpAYLOAD ( ifcCBdATAGRAMmAX - sizeof( echoPacketS ) )

//   WHEN RECEIVE ECHOrEPLYrEPLY, IF THE RECEIVED HASH IS CORRECT FOR THE CLAIMED nicNameC, ADD THAT nicNameC TO THE LIST
//   (PEER) IN RESPONSE TO ECHOrEPLY, SEND THE RECEIVED HASH VALUE IN ECHOrEPLYrEPLY
//   WHEN RECEIVE ECHO, HASH [cSecret||nicNameC] AND SEND THE HASH VALUE IN ECHOrEPLY TO THE CLAIMED nicNameC
//   UPDATE A countT cSecret EVERY TICK
// RECIPE:
//U:: ELIMINATE ATTACK SURFACE BY ADDING nicNameC VALUES ONLY AFTER THEY ARE CONFIRMED USING HASHED [nicNameC,secret]

//BASELINE: 7f0: "dut.duplex.udt.keepalive"

/*1*/WAKEhIDE( "ifcIDaDAM_UDPeCHO" )/*1*/

/**/
*/
 i ignore all other incoming packets
 i do this by catching ECHO udp packets and replying with ECHOrEPLY udp packets
i maintain a list of nicNameC values where IPDOS (tm) homes can be found
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ipdos for permitted uses.
//
