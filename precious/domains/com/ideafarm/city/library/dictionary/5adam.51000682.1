
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    etThread.delF( tin0P , psttName ) ;    
    strokeS*& psttName = *(strokeS**)&(countT&)swShortOnHey ;
    psttzHey = (strokeS*)swShortOnHey.leverF( tin0P , idf ) ;
    if( !( idf % TUCK ) ) { CONoUTrAW3( "\r        \r" , idf , "" ) }
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
countT cFlavors = swShortOnHey.cFlavorsF( tin0P ) ;

etThread.delF( tin0P , posto ) ;
etThread.boxPutF( tin0P , T("///d/ideafarm.work/txt/index.soil.after") , posto , costo ) ;

etThread.delF( tin0P , psttOut ) ;
countT costo = etThread.strMakeF( tin0P , LF , posto , psttOut ) ; ___( posto ) ;
ZE( osTextT* , posto ) ;

}
    }
        }
            etThread.delF( tin0P , psttHey ) ;
            }
                etThread.strFuseF( tin0P , psttOut , te    ) ;                                                           // OUT TO E
                etThread.strFuseF( tin0P , psttOut , psttName ) ;                                                        // OUT TO D (NEW NAME)
            {        
            if( psttName )
            strokeS*& psttName = *(strokeS**)&(countT&)swShortOnHey ;
            psttzHey = psttHey ;
        
            ((tin1S&)tin0P).pEther->strSubstringF( tin0P , psttHey , idf2 , countTC() , psttp ) ; ___( psttHey ) ;
            ZE( strokeS* , psttHey ) ;
        {
        else
        }
            etThread.delF( tin0P , psttp ) ;
            etThread.strFuseF( tin0P , psttOut , te    ) ;                                                               // OUT TO E
            etThread.strFuseF( tin0P , psttOut , psttp ) ;                                                               // OUT TO D
            etThread.strFuseF( tin0P , psttOut , tPrefix3 ) ;                                                            // OUT TO B
        {
        if( !etThread.strIdF( tin0P , countTC( 1 ) , idf2 , sttq , tHey , psttp ) || !idf2 )
        countT idf2 = 1 ;

        etThread.strSubstringF( tin0P , psttp , idf , sttq , te , tIn ) ; ___( psttp ) ;                                 // idf -> F
    {
    if( idf )

    etThread.delF( tin0P , psttp ) ;
    etThread.strFuseF( tin0P , psttOut , psttp ) ;                                                                       // OUT TO A
    etThread.strSubstringF( tin0P , psttp , idf , sttq , tPrefix3 , tIn ) ; ___( psttp ) ;                               // idf -> C
    ZE( strokeS* , psttp ) ;
{
while( idf )
TN( te       , "\\" ) ;
TN( tPrefix3 , "!ideafarm.3." ) ;
ZE( countT , idl ) ;
countT idf = 1 ;

//
//        A           BC                                                          DEF
//       \i!ideafarm.3.000b36b2.984b17e4.2f9afda7.editor.!.aladdin.logo.223x100.jpg\i
//
//
// REPLACE FORMAT 3 FILE NAMES WITH FORMAT 4 FILE NAMES

etThread.strMakeF( tin0P , LF , psttOut , 0 , tIn.csF( tin0P ) << 1 ) ; ___( psttOut ) ;
ZE( strokeS* , psttOut ) ;

}
    etThread.delF( tin0P , posti ) ;
    tIn = T(posti) ;
    etThread.boxGetShadowF( tin0P , posti , costi , T("///d/ideafarm.work/txt/index.soil") ) ; ___( posti ) ;
    ZE( countT   , costi ) ;
    ZE( osTextT* , posti ) ;
{
TN( tIn , "" ) ;

etThread.diskWalkF( tin0P , cDirs , cFiles , T("///d/ideafarm.home.101/IdeaFarm (tm)/2.1. Drop Files Here To Archive Them/") , (boolT&)(const boolT&)ether , diskWalkScanArchiveCBF , pcArg ) ;

countT pcArg[] = { (countT)&tcr ,  (countT)&tHey ,  (countT)&tArc , (countT)&sttq , (countT)&psttzHey , (countT)&swShortOnHey } ;
switchC swShortOnHey( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzHey ) ;
ZE( strokeS* , psttzHey ) ;
strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
TN( tArc , "\\2.1. Drop Files Here To Archive Them\\" ) ;
TN( tHey , ".!." ) ;
TN( tcr , "\r\n" ) ;
ZE( countT , cFiles ) ;
ZE( countT , cDirs ) ;

TODO

}
    return 1 ;

    }
        if( !( cFilesP % TUCK ) ) { CONoUTrAW3( "\r        \r" , cFilesP , "" ) }

        }
            ((tin1S&)tin0P).pEther->delF( tin0P , psttHey ) ;

            ((tin1S&)tin0P).pEther->strMakeF( tin0P , LF , psttShort , tShort ) ; ___( psttShort ) ;
            if( psttShort ) ((tin1S&)tin0P).pEther->delF( tin0P , psttShort ) ;
            strokeS*& psttShort = *(strokeS**)&(countT&)swShortOnHeyP ;
            psttzHeyP = psttHey ;

            ((tin1S&)tin0P).pEther->strSubstringF( tin0P , psttHey , idf , countTC() , tShort ) ; ___( psttHey ) ;
            ZE( strokeS* , psttHey ) ;
        {
        if( ((tin1S&)tin0P).pEther->strIdF( tin0P , countTC( 1 ) , idf , sttqP , tHeyP , tShort ) )
        countT idf = 1 ;

        }
            }
                ((tin1S&)tin0P).pEther->delF( tin0P , psttp ) ;
                tShort = T(psttp) ;                
                ((tin1S&)tin0P).pEther->strSubstringF( tin0P , psttp , idf , countTC() , tName ) ; ___( psttp ) ;
            {
            if( idf )
            ((tin1S&)tin0P).pEther->delF( tin0P , psttp ) ;
            ((tin1S&)tin0P).pEther->strSubstringF( tin0P , psttp , idf , sttqP , tArcP , tName ) ; ___( psttp ) ;
            countT idf = 1 ;
            ZE( strokeS* , psttp ) ;
            TN( tName , postNameP ) ;
        {
        TN( tShort , "" ) ;

        switchC&  swShortOnHeyP =  *(switchC*)pcArgP[ 5 ] ;
        strokeS*& psttzHeyP     = *(strokeS**)pcArgP[ 4 ] ;
        strokeS&  sttqP         =  *(strokeS*)pcArgP[ 3 ] ;
        textC&    tArcP         =    *(textC*)pcArgP[ 2 ] ;
        textC&    tHeyP         =    *(textC*)pcArgP[ 1 ] ;
        textC&    tcrP          =    *(textC*)pcArgP[ 0 ] ;
    {
    else
    }
    {
    if( bDir )

    boolT  bDir = postNameP[ costLike - 1 ] == '\\' ;
    countT costLike = ((tin1S&)tin0P).brcRaw ;

    BOSdOnOTtEST( WHATgbo , strlen( postNameP ) )
{
boolT diskWalkScanArchiveCBF( tin0S& tin0P , countT& cDirsP , countT& cFilesP , boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloFilesP , const countT* const pModuloDirsP )

/*1*/WAKEsHOWtEXT( "tool.migration.format.3.to.format.4.in.index.soil" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

