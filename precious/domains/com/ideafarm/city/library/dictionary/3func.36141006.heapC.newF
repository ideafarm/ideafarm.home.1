
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return pbNew ;

    THREADmODE5rESTORE
    }
        //if( ((tin9S&)tinBaseP).pc Utility[ 0 ] ) { LOGrAW3( "heapC::newF [pbNew]:    " , pbNew , "\r\n" ) ; } //U:: TO FIND A LEAK

        }
            grabMe.ungrabF( tinBaseP ) ;
            _IO_
        {

        }
            }
                BLAMMO ;
                _IO_
            {
            }
                dumpF( tinBaseP , "heapC::newF could not allocate pbNew" , "" ) ;
                _IO_
            {
            }
                LOGrAW9( "heapC::newF allocation failure [idAdamRoot,cbP,idLineP,idiFileP]:    " , processGlobal1I.idAdamRoot , "    " , cbP , "    " , idLineP , "    " , idiFileP , "\r\n" ) ;
                _IO_
            {
        {
        if( !pbNew )

        //testF( tinBaseP , "newF: after" ) ;

        }
            }
                }
                    break ;

                    cbWo |= BM_HIGH ;
                    cbNew += cbWo ;
                    cNew ++ ;

                    }
                        *(countT*)pbc = 0                           ; pbc += sizeof( countT ) ;
                        *(countT*)pbc = 0                           ; pbc += sizeof( countT ) ;
                        *(countT*)pbc = cbRemain - sizeof( countT ) ; pbc += sizeof( countT ) ;
                        pbc += cbWo ;
                        cbWo = cbAsk ;
                        countT cbRemain = cbWo - cbAsk ;
                    {
                    if( cbWo - cbAsk > 3 * sizeof( countT ) )      // THE PART THAT I DON'T NEED IS LARGE ENOUGH TO HOLD ANOTHER ALLOCATION

                    pbNew = pbc + 2 * sizeof( countT ) ;
                    ((countT*)pbc)[ 1 ] = idiFileP ;
                    ((countT*)pbc)[ 0 ] = idLineP ;
                {
                else
                if( cbWo & BM_HIGH || cbWo < cbAsk ) pbc += cbWo & ~BM_HIGH ;

                countT& cbWo = *(countT*)pbc ; pbc += sizeof( countT ) ;
            {
            while( pbc < pbe )
            byteT* const pbe = pbHeap + sizeof pbHeap ;
            byteT*       pbc = pbHeap ;
            countT cbAsk = cbP + 2 * sizeof( countT ) ; // idLine,idiFile,data
            _IO_
        {

        //testF( tinBaseP , "newF: before" ) ;

        grabMe.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

        grabitC grabx( tinBaseP , TAG( TAGiDnULL ) ) ;

        }
            BLAMMO ;
            dumpF( tinBaseP , "heapC::newF cbP is 0" , "" ) ;
            _IO_
        {
        if( !cbP )

        _IO_
    {
    THREADmODE5oN( flTHREADmODE5_INoUTfRAMEdEFERwRITINGaPPtELEMETRY )
    ((tin9S&)tinBaseP).flushPendingInOutFrameTelemetryIfF() ;
    ZE( byteT* , pbNew ) ;
{
/*1*/byteT* heapC::newF( tin0S& tinBaseP , const countT idLineP , const countT idiFileP , const countT cbP )/*1*/

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

