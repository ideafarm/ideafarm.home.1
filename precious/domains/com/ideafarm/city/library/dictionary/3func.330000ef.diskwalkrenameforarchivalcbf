
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bDoIt ;

    }
        }
            }
                }
                    }
                        }
                            }
                                }
                                    }
                                        etThread.traceF( tin0P , T("!exception: could not set file time [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc)+T("    ")+tLongZip ) ;
                                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                        POOPRqUIET
                                        countT rc = POOP ;
                                    {
                                    if( POOP )

                                    ((thirdC&)etThread).setFileTimeF( tin0P , fiw , &timeWritten , &timeWritten , &timeWritten ) ;

                                    }
                                        etThread.traceF( tin0P , T("!exception: could not open file to set its file time [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc)+T("    ")+tLongZip ) ;
                                        const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                        POOPRqUIET
                                        countT rc = POOP ;
                                    {
                                    if( POOP )

                                    fileC fiw( tin0P , (strokeS*)tLongZip , ifcOPENaCCESS_WR , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;

                                    //etThread.traceF( tin0P , tLongZip ) ;

                                    TN( tLongZip , "" ) ; tLongZip = tToPath+tNewFileZip ;
                                {
                                if( timeWritten )            

                                third.diskZipF( tin0P , tToShort , tFrom , 0 , 0 , "-max -move" , "-9m" , 0 ) ;

                                  etThread.traceF( tin0P , tFrom    ) ;
                                //etThread.traceF( tin0P , tFrom5   ) ;
                                //etThread.traceF( tin0P , tFrom4   ) ;
                                //etThread.traceF( tin0P , tFrom3   ) ;
                                //etThread.traceF( tin0P , tFrom2   ) ;
                                  etThread.traceF( tin0P , tToShort ) ;

                                TN( tFrom , "" ) ; tFrom = tq + tFrom1 + tqbq + tFrom2 + tqbq + tFrom3 + tqbq + tFrom4 + tqbq + tFrom5 + tq ;

                                TN( tFrom5   , osFileNameC( tin0P , third , tNewFileMetaPathLeaf    ) ) ;
                                TN( tFrom4   , osFileNameC( tin0P , third , tNewFileMetaPathRoot    ) ) ;
                                TN( tFrom3   , osFileNameC( tin0P , third , tNewFileMetaCurrentName ) ) ;
                                TN( tFrom2   , osFileNameC( tin0P , third , tNewFileMetaHashedName  ) ) ;
                                TN( tFrom1   , osFileNameC( tin0P , third , tNewFileData            ) ) ;
                                TN( tToShort , osFileNameC( tin0P , third , tNewFileZip             ) ) ;
                                TN( tq     , "\"" ) ;
                                TN( tqbq     , "\" \"" ) ;
                                thirdC& third = etThread ;

                                //countT rc = thirdC::c_systemIF( tin0P , "dir" ) ;
                                hoverC hover( tin0P , etThread , tToPath ) ;
                                //etThread.traceF( tin0P , tToPath ) ;

                                }
                                    }
                                        etThread.traceF( tin0P , T("             [timeAccessedLook]:    ")+TT(timeAccessedLook.time1,timeAccessedLook.time2) ) ;
                                        etThread.traceF( tin0P , T("              [timeCreatedLook]:    ")+TT(timeCreatedLook.time1,timeCreatedLook.time2) ) ;
                                        etThread.traceF( tin0P , T("              [timeWrittenLook]:    ")+TT(timeWrittenLook.time1,timeWrittenLook.time2) ) ;
                                        etThread.traceF( tin0P , T("original file     [timeWritten]:    ")+TT(timeWritten.time1,timeWritten.time2) ) ;
                                        }
                                            }
                                                }
                                                    etThread.traceF( tin0P , T("!exception: could not get file time [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc)+T("    ")+tOld ) ;
                                                    const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                    POOPRqUIET
                                                    countT rc = POOP ;
                                                {
                                                if( POOP )

                                                thirdC::getFileTimeIF( tin0P , fir , &timeWrittenLook , &timeCreatedLook , &timeAccessedLook ) ;

                                                SCOOPS
                                                _IO_
                                            {
                                            IFsCRATCH

                                            fileC fir( tin0P , (strokeS*)*pptLong[ offt ] , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;
                                        {
                                        timeS timeAccessedLook = timeS() ;
                                        timeS timeCreatedLook  = timeS() ;
                                        timeS timeWrittenLook  = timeS() ;

                                        }
                                            }
                                                etThread.traceF( tin0P , T("!exception: could not set file time [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc)+T("    ")+*pptLong[ offt ] ) ;
                                                const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                POOPRqUIET
                                                countT rc = POOP ;
                                            {
                                            if( POOP )

                                            ((thirdC&)etThread).setFileTimeF( tin0P , fiw , &timeWritten , &timeWritten , &timeWritten ) ;

                                            }
                                                etThread.traceF( tin0P , T("!exception: could not open file to set its file time [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc)+T("    ")+*pptLong[ offt ] ) ;
                                                const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                                POOPRqUIET
                                                countT rc = POOP ;
                                            {
                                            if( POOP )

                                            fileC fiw( tin0P , (strokeS*)*pptLong[ offt ] , ifcOPENaCCESS_WR , 0 , flOPENdETAILS_LOCsEQ , ifcOPENhOW_nFeO , flFILEaTTR1_null, flFILEaTTR2_null , flFILEc_null , 1 , 0 ) ;
                                        {
                                    {
                                    for( countT offt = 0 ; offt < sizeof pptLong / sizeof pptLong[ 0 ] ; offt ++ )

                                    textC* pptLong[] = { &tLong0 , &tLong1 , &tLong2 , &tLong3 , &tLong4 } ;
                                    TN( tLong4 , "" ) ; tLong4 = tToPath+tNewFileMetaPathLeaf    ;
                                    TN( tLong3 , "" ) ; tLong3 = tToPath+tNewFileMetaPathRoot    ;
                                    TN( tLong2 , "" ) ; tLong2 = tToPath+tNewFileMetaCurrentName ;
                                    TN( tLong1 , "" ) ; tLong1 = tToPath+tNewFileMetaHashedName  ;
                                    TN( tLong0 , "" ) ; tLong0 = tToPath+tNewFileData            ;
                                {
                                if( timeWritten )            

                                etThread.boxPutF(            tin0P , tToPath+tNewFileMetaPathLeaf    , tPathLeaf , tPathLeaf.csF( tin0P ) ) ;
                                etThread.boxPutF(            tin0P , tToPath+tNewFileMetaPathRoot    , tPathRoot , tPathRoot.csF( tin0P ) ) ;
                                etThread.boxPutF(            tin0P , tToPath+tNewFileMetaCurrentName , tShort    , tShort.csF(    tin0P ) ) ;
                                etThread.boxPutF(            tin0P , tToPath+tNewFileMetaHashedName  , tShort    , tShort.csF(    tin0P ) ) ;
                                etThread.diskMoveFileOrDirF( tin0P , tToPath+tNewFileData            , tOld ) ;

                                //etThread.traceF( tin0P , tNewFileMetaCurrentName ) ;
                                //etThread.traceF( tin0P , tNewFileMetaHashedName ) ;

                                //etThread.traceF( tin0P , tNewFileData+T("    ")+tOld , flTRACE_null , ifcIDtRACEdIVERT_8 ) ;

                                }
                                    ) ;
                                        || etThread.diskFileExistsF( tin0P , tToPath+tNewFileMetaPathLeaf    )
                                        || etThread.diskFileExistsF( tin0P , tToPath+tNewFileMetaPathRoot    )
                                        || etThread.diskFileExistsF( tin0P , tToPath+tNewFileMetaCurrentName )
                                        || etThread.diskFileExistsF( tin0P , tToPath+tNewFileMetaHashedName  )
                                        || etThread.diskFileExistsF( tin0P , tToPath+tNewFileData            )
                                           etThread.diskFileExistsF( tin0P , tToPath+tNewFileZip             )
                                    (
                                    while
                                    }
                                        tNewFileMetaPathLeaf    = tPart1+tDotTypeMetaDotPathLeaf    ;
                                        tNewFileMetaPathRoot    = tPart1+tDotTypeMetaDotPathRoot    ;
                                        tNewFileMetaCurrentName = tPart1+tDotTypeMetaDotCurrentName ;
                                        tNewFileMetaHashedName  = tPart1+tDotTypeMetaDotHashedName  ;
                                        tNewFileData            = tPart1+tDotTypeData+tDotExt       ;
                                        tNewFileZip             = tPart1+tDotFsetDotZip                    ;

                                        TN( tPart1 , "" ) ; tPart1 = tNewPrefix+tTimePair+tDot+tHash+tDot+TF3(++idSeq,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN,3) ;

                                        //20200410@1946: MIGRATE FROM FORMAT 8 TO FORMAT 9 BY EDITING THE FOLLOWING CODE

                                        //U:: DECISION: FOR THE NEXT FORMAT REVISION, ELIMINATE tSequenceNumber AND SHORTEN THE RENDERING OF idSeq TO 3 OR 4
                                        //U:: LOOK: WHAT IS THE ORIGIN OF THE tSequenceNumber VALUE?: IT IS FROM A FORMAT 6 NAME
                                        //U:: 20200405@1155: CONJ: CAN ELIMINATE THE tSequenceNumber SEQUENCE NUMBER AND ALSO SHORTEN THE idSeq RENDERING TO 3 BIGITS: CONJ: THERE IS NO NEED TO PRESERVE tSequenceNumber; ITS ONLY PURPOSE IS TO ENSURE THAT THERE ARE NO FILE COLLISIONS
                                    {
                                    do
                                    ZE( countT , idSeq ) ;

                                    }
                                        etThread.delF( tin0P , psttHash ) ;
                                        tHash = T(psttHash) ;
                                        hasher.queryStringF( tin0P , psttHash ) ; ___( psttHash ) ;
                                        ZE( strokeS* , psttHash ) ;

                                        hasher.eatF( tin0P , tShort , tShort.csF( tin0P ) ) ;
                                        hasherC hasher( tin0P , etThread ) ;
                                    {
                                    TN( tHash , "" ) ;
                                {
                                TN( tNewFileMetaPathLeaf , "" ) ;
                                TN( tNewFileMetaPathRoot , "" ) ;
                                TN( tNewFileMetaCurrentName , "" ) ;
                                TN( tNewFileMetaHashedName , "" ) ;
                                TN( tNewFileData , "" ) ;
                                TN( tNewFileZip  , "" ) ;
                                TN( tDotFsetDotZip , ".fset.zip" ) ;                                                                                            // 20240807@1800: NOW THE LEAF VALUE WILL SPECIFY THE NAME OF THE ARCHIVE TO PLACE THE FILESET INTO
                                                                                                                                                                // ORIGINALLY, THE LEAF VALUE DESCRIBED THE SOURCE OF THE FILE
                                TN( tToPath , ifFileNameC( tin0P , etThread , postzToP ) ) ; tToPath += tPathLeaf+T("/") ;                                       // DESTINATION FOLDER

                                }
                                    }
                                        etThread.delF( tin0P , psttSansDots ) ;
                                        tTimePair = T(psttSansDots) ;
                                        etThread.strSubstringF( tin0P , psttSansDots , idf , idl , tTimePair ) ; ___( psttSansDots ) ;
                                        countT idl = tTimePair.csF( tin0P) - 1 ;
                                        countT idf = 2 ;
                                        ZE( strokeS* , psttSansDots ) ;
                                    {
                                    if( tTimePair.csF( tin0P ) > 2 )

                                    }
                                        }
                                            }
                                                }
                                                    tTimePair = tDot+tTimeFromPrefix+tDot+tDateAtTimeFromFileMeta+tDot ;
                                                {
                                                else                    // THERE IS NO TIME AFTER HEY
                                                }
                                                    etThread.delF( tin0P , psttSingleTime ) ;
                                                    tTimePair = T(psttSingleTime)+tDateAtTimeFromFileMeta+tDot ;
                                                    etThread.strSubstringF( tin0P , psttSingleTime , idf , idl , tShort ) ; ___( psttSingleTime ) ;
                                                    countT idf = idHit2 ;
                                                    countT idl = idf - 1 ;
                                                    ZE( strokeS* , psttSingleTime ) ;
                                                {
                                                if( idHit2 )            // I HAVE A SINGLE TIME AFTER HEY                                                  
                                                idHit2 = etThread.strIdF( tin0P , 0 , flSTRmATCH_null , idf , sttq , tSssDotDateAtTimeDot , tShort ) ;
                                                idf = idfSave ;
                                            {
                                            else
                                            }
                                                etThread.delF( tin0P , psttDoubleTime ) ;
                                                tTimePair = T(psttDoubleTime) ;
                                                etThread.strSubstringF( tin0P , psttDoubleTime , idf , idl , tShort ) ; ___( psttDoubleTime ) ;
                                                countT idf = idHit2 ;
                                                countT idl = idf - 1 ;
                                                ZE( strokeS* , psttDoubleTime ) ;
                                            {
                                            if( idHit2 )            // I HAVE A DOUBLE TIME AFTER HEY                                                  
                                            countT idHit2 = etThread.strIdF( tin0P , 0 , flSTRmATCH_null , idf , sttq , tSssDotDateAtTimeDotDateAtTimeDot , tShort ) ;
                                            countT idfSave = -- idf ;                             
                                        {
                                        else                        // I HAVE A DOT HEY DOT
                                        }
                                            tTimePair = tDot+tTimeFromPrefix+tDot+tDateAtTimeFromFileMeta+tDot ;
                                        {
                                        if( !idHit )
                                        idHit = etThread.strIdF( tin0P , 0 , flSTRmATCH_null , idf , sttq , tDotHeyDot , tShort ) ;

                                        tSequenceNumber = tSequenceNumberFromPrefix ;
                                        }
                                            etThread.delF( tin0P , psttSequenceNumberFromPrefix ) ;
                                            tSequenceNumberFromPrefix = T(psttSequenceNumberFromPrefix) ;
                                            etThread.strSubstringF( tin0P , psttSequenceNumberFromPrefix , idf , idl , tShort ) ; ___( psttSequenceNumberFromPrefix ) ;
                                            countT idl = ++ idf + 2 ;
                                            ZE( strokeS* , psttSequenceNumberFromPrefix ) ;
                                        {
                                        TN( tSequenceNumberFromPrefix , "" ) ;

                                        }
                                            etThread.delF( tin0P , psttTimeFromPrefix ) ;
                                            tTimeFromPrefix = T(psttTimeFromPrefix) ;
                                            etThread.strSubstringF( tin0P , psttTimeFromPrefix , idf , idl , tShort ) ; ___( psttTimeFromPrefix ) ;
                                            countT idl = idf + 0xc ;
                                            ZE( strokeS* , psttTimeFromPrefix ) ;
                                        {
                                        TN( tTimeFromPrefix , "" ) ;
                                    {
                                    else                            // I HAVE A PREFIX
                                    }
                                        }
                                            }
                                                }
                                                    }
                                                        }
                                                            tTimePair = tDot+tDateAtTimeFromFileMeta+tDot+tDateAtTimeFromFileMeta+tDot ;
                                                        {
                                                        else
                                                        }
                                                            etThread.delF( tin0P , psttMMDDYYHHMM ) ;
                                                            tTimePair = tDot+T(psttSingle)+tDot+tDateAtTimeFromFileMeta+tDot ;

                                                            etThread.strFuseF( tin0P , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x09 ] ) ;
                                                            etThread.strFuseF( tin0P , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x08 ] ) ;
                                                            etThread.strFuseF( tin0P , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x07 ] ) ;
                                                            etThread.strFuseF( tin0P , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x06 ] ) ;
                                                            etThread.strFuseF( tin0P , psttSingle , tAt                               ) ;
                                                            etThread.strFuseF( tin0P , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x03 ] ) ;
                                                            etThread.strFuseF( tin0P , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x02 ] ) ;
                                                            etThread.strFuseF( tin0P , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x01 ] ) ;
                                                            etThread.strFuseF( tin0P , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x00 ] ) ;
                                                            etThread.strFuseF( tin0P , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x05 ] ) ;
                                                            etThread.strFuseF( tin0P , psttSingle , psttMMDDYYHHMM[ CSpREFIX + 0x04 ] ) ;
                                                            etThread.strMakeF( tin0P , LF , psttSingle , t20                               , TUCK ) ; ___( psttSingle ) ; // TUCK IS WAY MORE THAN NEEDED
                                                            ZE( strokeS* , psttSingle ) ;

                                                            etThread.strSubstringF( tin0P , psttMMDDYYHHMM , idf , idl , tShort ) ; ___( psttMMDDYYHHMM ) ;
                                                            countT idf = idHit ;
                                                            countT idl = idf - 1 ;
                                                            ZE( strokeS* , psttMMDDYYHHMM ) ;
                                                        {
                                                        if( idHit == 1 )
                                                        idHit = etThread.strIdF( tin0P , 0 , flSTRmATCH_null , idf , sttq , tSssMMDDYYHHMM , tShort ) ;
                                                        idf = 1 ;
                                                    {
                                                    else
                                                    }
                                                        etThread.delF( tin0P , psttSingleTime ) ;
                                                        tTimePair = tDot+T(psttSingleTime)+tDateAtTimeFromFileMeta+tDot ;
                                                        etThread.strSubstringF( tin0P , psttSingleTime , idf , idl , tShort ) ; ___( psttSingleTime ) ;
                                                        countT idf = idHit ;
                                                        countT idl = idf - 1 ;
                                                        ZE( strokeS* , psttSingleTime ) ;
                                                    {
                                                    if( idHit == 1 )
                                                    idHit = etThread.strIdF( tin0P , 0 , flSTRmATCH_null , idf , sttq , tSssDateAtTimeDot , tShort ) ;
                                                    idf = 1 ;
                                                {
                                                else
                                                }
                                                    etThread.delF( tin0P , psttSingleTime ) ;
                                                    tTimePair = T(psttSingleTime)+tDateAtTimeFromFileMeta+tDot ;
                                                    etThread.strSubstringF( tin0P , psttSingleTime , idf , idl , tShort ) ; ___( psttSingleTime ) ;
                                                    countT idf = idHit ;
                                                    countT idl = idf - 1 ;
                                                    ZE( strokeS* , psttSingleTime ) ;
                                                {
                                                if( idHit )
                                                idHit = etThread.strIdF( tin0P , 0 , flSTRmATCH_null , idf , sttq , tSssDotDateAtTimeDot , tShort ) ;
                                                idf = 1 ;
                                            {
                                            else
                                            }
                                                etThread.delF( tin0P , psttDoubleTime ) ;
                                                tTimePair = tDot+T(psttDoubleTime) ;
                                                etThread.strSubstringF( tin0P , psttDoubleTime , idf , idl , tShort ) ; ___( psttDoubleTime ) ;
                                                //etThread.traceF( tin0P , T("[idf,idl]:    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idl,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                countT idf = idHit ;
                                                countT idl = idf - 1 ;
                                                ZE( strokeS* , psttDoubleTime ) ;
                                            {
                                            if( idHit == 1 )
                                            idHit = etThread.strIdF( tin0P , 0 , flSTRmATCH_null , idf , sttq , tSssDateAtTimeDotDateAtTimeDot , tShort ) ;
                                            idf = 1 ;
                                        {
                                        else
                                        }
                                            etThread.delF( tin0P , psttDoubleTime ) ;
                                            tTimePair = T(psttDoubleTime) ;
                                            etThread.strSubstringF( tin0P , psttDoubleTime , idf , idl , tShort ) ; ___( psttDoubleTime ) ;
                                            countT idf = idHit ;
                                            countT idl = idf - 1 ;
                                            ZE( strokeS* , psttDoubleTime ) ;
                                        {
                                        if( idHit )
                                        idHit = etThread.strIdF( tin0P , 0 , flSTRmATCH_null , idf , sttq , tSssDotDateAtTimeDotDateAtTimeDot , tShort ) ;
                                        idf = 1 ;

                                        //etThread.traceF( tin0P , T("[tPatt2]: ")+tSssDotDateAtTimeDotDateAtTimeDot ) ;                             
                                        //etThread.traceF( tin0P , T("[tShort]: ")+tShort ) ;                             
                                    {
                                    if( idHit != 1 )

                                    countT idHit = etThread.strIdF( tin0P , 0 , flSTRmATCH_null , idf , sttq , tPrefix6 , tShort ) ;

                                    TN( tPrefix6   , "!ideafarm.6." ) ;
                                    TN( tDotHeyDot , ".!." ) ;
                                    TN( tDot , "." ) ;
                                    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
                                    countT idf = 1 ;
                                {
                                TN( tSequenceNumber , "001" ) ;
                                TN( tTimePair , "" ) ;
                            {
                            if( 1 != etThread.strIdF( tin0P , tNewPrefix , tShort ) )
                        {
                        if( tShort.csF( tin0P ) )

                        }
                            etThread.delF( tin0P , psttDotExt ) ;
                            etThread.delF( tin0P , psttnu ) ;
                            tDotExt = T(psttDotExt) ;
                            etThread.strBisectF( tin0P , psttnu , psttDotExt , tShort , tDot , - 1 , flSTRbISECT_PREPENDdELIMITER ) ; ___( psttnu ) ; ___( psttDotExt ) ;
                            ZE( strokeS* , psttDotExt ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tDotExt , "" ) ;

                        }
                            ;
    
                                +TF4(mm,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)
                                +TF4(hh,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)
                                +S1C('@')
                                +TF4(1+da,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)
                                +TF4(1+mo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,2,0xa)
                                 TF4(1+ye,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE|flFORMAT_FOREIGN|flFORMAT_NObASE,4,0xa)
    
                            tDateAtTimeFromFileMeta =
    
                            etThread.osTimeToOldTimeF( tin0P , ms , ss , mm , hh , da , mo , ye , dow , pInfo->timeWritten1 , pInfo->timeWritten2 ) ;
                            ZE( countT , dow ) ;
                            ZE( sCountT , ye ) ;
                            ZE( countT , mo ) ;
                            ZE( countT , da ) ;
                            ZE( countT , hh ) ;
                            ZE( countT , mm ) ;
                            ZE( countT , ss ) ;
                            ZE( countT , ms ) ;
                        {
                        TN( tDateAtTimeFromFileMeta , "" ) ;

                        }
                            etThread.delF( tin0P , psttPathRoot ) ;
                            etThread.delF( tin0P , psttPathLeaf ) ;
                            tPathLeaf  = T(psttPathLeaf) ;
                            tPathRoot  = T(psttPathRoot) ;
                            etThread.strBisectF( tin0P , psttPathRoot , psttPathLeaf , tPath , tSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathLeaf ) ; ___( psttPathRoot ) ;
                            ZE( strokeS* , psttPathLeaf ) ;
                            ZE( strokeS* , psttPathRoot ) ;
                        {
                        TN( tPathLeaf , "" ) ;
                        TN( tPathRoot , "" ) ;

                        }
                            etThread.delF( tin0P , psttShort ) ;
                            etThread.delF( tin0P , psttPath ) ;
                            tShort = T(psttShort) ;
                            tPath  = T(psttPath) ;
                            etThread.strBisectF( tin0P , psttPath , psttShort , tOld , tSlash , - 1 , flSTRbISECT_null ) ; ___( psttPath ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttPath ) ;
                        {
                        TN( tShort , "" ) ;
                        TN( tPath , "" ) ;
                    {

                    etThread.traceF( tin0P , T("original file     [timeWritten]:    ")+TT(timeWritten.time1,timeWritten.time2) ) ;
                    }
                        }
                            }
                                etThread.traceF( tin0P , T("!exception: could not get file time [rc,postRc,name]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc)+T("    ")+tOld ) ;
                                const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                                POOPRqUIET
                                countT rc = POOP ;
                            {
                            if( POOP )

                            thirdC::getFileTimeIF( tin0P , hFile , &timeWritten , 0 , 0 ) ;

                            SCOOPS
                            _IO_
                        {
                        IFsCRATCH

                        etThread.diskFileQueryF( tin0P , pInfo , hFile ) ; ___( pInfo ) ;
                        etThread.fileOpenF( tin0P , hFile , countTC() , tOld , ifcOPENaCCESS_R , ifcOPENsHARE_R , flOPENdETAILS_NOcACHE | flOPENdETAILS_DOnOTvALIDATE | flOPENdETAILS_DOnOTrEGISTER | flOPENdETAILS_LOCnONE , ifcOPENhOW_nFeO ) ;
                        handleC hFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
                    {
                    timeS timeWritten = timeS() ;
                    ZE( infoFileS* , pInfo ) ;
                {
                if( postzToP )

                textC& t20                               = *pptSpecP[ 0x12 ] ;
                textC& tAt                               = *pptSpecP[ 0x11 ] ;
                textC& tDotTypeMetaDotPathLeaf           = *pptSpecP[ 0x10 ] ;
                textC& tDotTypeMetaDotPathRoot           = *pptSpecP[ 0x0f ] ;
                textC& tDotTypeMetaDotCurrentName        = *pptSpecP[ 0x0e ] ;
                textC& tDotTypeMetaDotHashedName         = *pptSpecP[ 0x0d ] ;
                textC& tDotTypeData                      = *pptSpecP[ 0x0c ] ;
                textC& tNewPrefix                        = *pptSpecP[ 0x0b ] ;
                textC& tSDDS                             = *pptSpecP[ 0x0a ] ;
                textC& tSDS                              = *pptSpecP[ 0x09 ] ;
                textC& tDot                              = *pptSpecP[ 0x08 ] ;
                textC& tSssMMDDYYHHMM                    = *pptSpecP[ 0x07 ] ;
                textC& tSssDateAtTimeDot                 = *pptSpecP[ 0x06 ] ;
                textC& tSssDateAtTimeDotDateAtTimeDot    = *pptSpecP[ 0x05 ] ;
                textC& tSssDotDateAtTimeDot              = *pptSpecP[ 0x04 ] ;
                textC& tSssDotDateAtTimeDotDateAtTimeDot = *pptSpecP[ 0x03 ] ;
                if( cSpecP < 0xe ) { BLAMMO ; }

                countT&  idSequenceLathP  = *(countT*)infoP.pcArgApp[ 4 ] ;
                textC&   tDateAtTimeLathP =  *(textC*)infoP.pcArgApp[ 3 ] ;
                countT   cSpecP           =           infoP.pcArgApp[ 2 ] ;
                textC**  pptSpecP         =  (textC**)infoP.pcArgApp[ 1 ] ;
                osTextT* postzToP         = (osTextT*)infoP.pcArgApp[ 0 ] ;
            {
            )
                !etThread.strIdF( tin0P , tSlash+tIdeaFarmDot9Dot , tOld )
                &&
                !etThread.strIdF( tin0P , tSlash+tIdeaFarmDotADot , tOld )
            (
            if
            TN( tSlash , "/" ) ;
            TN( tOld , ifFileNameC( tin0P , etThread , postNameP ) ) ;                                       // OLD IFC FILE NAME
            TN( tIdeaFarmDotADot , "!ideafarm.a.2.00000000.00000001." ) ;                                   //20231122@1235: STORE THE FILESET AS A SINGLE ZIP FILE
            TN( tIdeaFarmDot9Dot , "!ideafarm.9.2.00000000.00000001." ) ;                                   //U:: idOwner IS HARDCODED HERE TO ".2.00000000.00000001." (FOREIGN ORDERING)
            etherC& etThread = *((tin123S&)tin0P).pEther ;
        {
        if( bDoIt )

        //U::EDIT TO MAP EACH OCCURANCE OF "!" TO "!!"

        ;
            : 1
            ? (*infoP.pCbf)( tin0P , cDirsP , cFilesP , bQuitP , postNameP , pcArgP )
        bDoIt = infoP.pCbf

        diskWalkCopyInfoS& infoP = *(diskWalkCopyInfoS*)pcArgP ;

        //((tin123S&)tin0P).pEther->traceF( tin0P , T("diskWalkRenameForArchivalCBF [postNameP]:    ")+T(postNameP) ) ;
    {
    else if( ((tin123S&)tin0P).pEther )
    else if( postNameP[ thirdC::c_strlenIF( tin0P , postNameP ) - 1 ] == '\\' ) bDoIt = 1 ; // IF A DIRECTORY
    if( !postNameP ) ;
    ZE( boolT , bDoIt ) ;
    _IO_
{
/*1*/boolT diskWalkRenameForArchivalCBF( tin0S& tin0P , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloFilesP , const countT* const pModuloDirsP )/*1*/

/**/
*/
    if no override filetime is found in the name then the file time, converted to foreign datetime format, is used
    it is removed from [shortfilename] and placed into early position so that it controls sorting
   [overridetime]: is a time specified in [shortfilename]
   !ideafarm.4.[overridetime].[filetime].[cid].[leafdir].!.[shortfilename]
  example of format 4: !ideafarm.4.20130423@1824.000b3577.bb88e99f.3c1f01ba.leafdir.!.blabla.test
   !ideafarm. 3.[time].[cid].[leafdir].!.[shortfilename]
  example of format 3: !ideafarm. 3.000b3577.bb88e99f.3c1f01ba.leafdir.!.blabla.test
    it has nothing to do with the 8.3 encoded name in some file systems
    this is the name of the file with the path removed
   "!s": "short file name"
   all occurances of "!" in the old name are changed to "!!"
  example of format 2: !ideafarm.2.000b3577.bb88e99f.leafdir.!s.blabla.test
  example of format 1: !ideafarm.1.000b3577.bb88e99f.blabla.test
 ideafarm file name format specification
i rename each file with a nonconforming name so that its name conforms to the ideafarm file name specification format 3
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

