
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;

etThread.traceF( tin0P , T("ok") ) ;

}
    break ; //U:: TO FIND A BUG

    cReceivedFileWindows = 0 ;
    etThread.traceF( tin0P , T("received [cReceivedFileWindows]:    ")+TF2(cReceivedFileWindows,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    //++ s ; ether.osSleepF( tin0P , TOCK << 5 ) ;

    etThread.traceF( tin0P , T("process [mTocks]:    ")+TT(timeE1,timeE2)+tb4+TF2(mTocksE,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tin0P , T("throw   [mTocks]:    ")+TT(timeT1,timeT2)+tb4+TF2(mTocksT,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tin0P , T("[mGBits]:            ")+TF2(mGBits,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    etThread.traceF( tin0P , T("[cGram]:            ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

    measureT mGBits = (measureT)( cb04Thrown << 3 ) / ( TICK << 2 ) ;

    measureT mTocksE = (measureT)timeE1 / TOCK ;
    measureT mTocksT = (measureT)timeT1 / TOCK ;

    etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO PROCESS
    etThread.osTimeNowF( tin0P , timeE1 , timeE2 ) ;
    ZE( sCountT , timeE2 ) ;
    ZE( countT  , timeE1 ) ;

    }
        ++ s ; ether.osSleepF( tin0P , TOCK >> 4 ) ;
    {
    while( cProcessed < cThrown )

    etThread.osTimeSubtractF( tin0P , timeT1 , timeT2 , timeA1 , timeA2 ) ;      // TIME TAKEN TO THROW
    etThread.osTimeNowF( tin0P , timeT1 , timeT2 ) ;
    ZE( sCountT , timeT2 ) ;
    ZE( countT  , timeT1 ) ;

    }
        }
            //break ; //U:: TO FIND A BUG

            }
                }
                    // if( cThrown == 4 ) break ; //U:: TO FIND A BUG


                    //Sleep( 50 ) ;            // TO SLOW ME DOWN

                    cbDone += cbNow ;
                    pbc    += cbNow ;

                    cb04Thrown += cbGram ;
                    cThrown ++ ;

                    sThrow.writeF( tin0P , idPortCatch , nicNameC() , pbGram , cbGram ) ;
                    countT cbGram = sizeof( gramHeadFileWindowS ) + cbNow ;
                    //etThread.traceF( tin0P , T("sent [idGram,cbNow]:    ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbNow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    //CONoUTrAW( "!" ) ;
                    etThread.memCopyF( tin0P , pbPayload , pbc , cbNow ) ;
                    //head.pad4   = 0x3d3d3d3d ;
                    //head.pad3   = 0x3d3d3d3d ;
                    //head.pad2   = 0x3d3d3d3d ;
                    //head.pad1   = 0x3d3d3d3d ;
                    head.secret = secretToUse ;
                    head.len    = cbNow  ;
                    head.off    = cbDone ;
                    head.idCmd  = ifcIDcMDgRAM_PUTfILEwINDOW ;
                    head.cbThisGram = sizeof head + cbNow ;
                    //etThread.traceF( tin0P , T("throwing window [secretToUse]:    ")+TF2(secretToUse,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    //CONoUTrAW( "+" ) ;

                    }
                       //etThread.traceF( tin0P , T("throwing [idGram]:    ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    //if( idGram == 0x10 )

                    idGram ++ ;

                    cbDo -= cbNow ;

                    ;
                        : CBpAYLOAD
                        ? cbDo
                    countT cbNow = cbDo < CBpAYLOAD

//#endif
                    //etThread.traceF( tin0P , T("waited  for a secret") ) ;
                    }
                        Sleep( 100 ) ;
                    {
                    while( !secretToUse )
                    //etThread.traceF( tin0P , T("waiting for a secret") ) ;
//#if defined( NEVERdEFINED )
//U::
                {
                while( cbDo )
                countT cbDo = cbw ;
                byteT* pbc = pbw ;

                //etThread.boxPutF( tin0P , tFileIn+T(".window.")+tIdWindow , pbw , cbw ) ;
                //etThread.traceF( tin0P , T("[tIdWindow,cb]:    ")+tIdWindow+tb4+TF2(cbw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                //TN( tIdWindow , "" ) ; tIdWindow = TF3(++idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;
            {
            else
            if( !pbw || !cbw ) break ;

            fwsIn.getF( tin0P , pbw , cbw ) ;
            ZE( countT , cbw ) ;
            ZE( byteT* , pbw ) ;
        {
        while( !ether )
        //etThread.traceF( tin0P , T("sending begun") ) ;
        ZE( count04T , cbDone ) ;
        byteT*     pbPayload = pbGram + sizeof( gramHeadFileWindowS ) ;
        gramHeadFileWindowS& head      = *(gramHeadFileWindowS*)pbGram ;
        byteT      pbGram[ sizeof( gramHeadFileWindowS ) + CBpAYLOAD ] ;
        ZE( countT , idWindow ) ;

        fileWindowsC fwsIn( tin0P , etThread , tFileIn ) ;

        sThrow.bindF( tin0P ) ;
        socketC sThrow( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
    {
    ZE( countT , idGram ) ;

    etThread.osTimeNowF( tin0P , timeA1 , timeA2 ) ;
    ZE( sCountT , timeA2 ) ;
    ZE( countT  , timeA1 ) ;
{
while( !ether )
TN( tFileIn     , "///d/tmp/foo.ttt" ) ;

etThread.osThreadF( TaRG1( tmGetSecretF  ) , (countT)&secretToUse ) ;
etThread.osThreadF( TaRG1( tmObey1F       ) , (countT)&secretToUse ) ;
etThread.osThreadF( TaRG1( tmEpochClockF )                        ) ;

}
    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
{
while( !idPortCatch )
sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
TN( tb4 , "    " ) ;

etThread.osThreadF( TaRG1( tmCatchF ) ) ;
ZE( countT , secretToUse ) ;

TODO

DONE( tmCatchF )
}
    sCatch.readF( tin0P , (const countT&)ether , pbFastBuffer , sizeof pbFastBuffer ) ;

    idPortCatch = sCatch.bindF( tin0P ) ;
    socketC sCatch( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
{
if( pTaskP )
TASK( tmCatchF )

DONE( tmObey1F )
}
    }
        Sleep( 0 ) ;

        }
            pbci += cbThis ;

            //CONoUTrAW( "-" ) ;

            }
                }
                    pbco += cbDo ;
                    memcpy( pbco , pbThis + cbDone , cbDo ) ;
                {
                else
                if( cbDo > pbwe - pbco ) { BLAMMO ; }           //A:ASSUME: FILE WINDOW IS LARGE ENOUGH TO CONTAIN THE LARGEST POSSIBLE INCOMING PACKET
                countT cbDo = cbThis - cbDone ;

                //}
                //    while( cDo -- ) *( pbco ++ ) = 0x2d ;
                //    countT cDo = 0x10 - cbDashesDone ;
                //{
                //if( cbDashesDone < 0x10 )

                pbco = pbw ;
                pbwe = pbw + cbw ;
                if( !pbw || !cbw ) { BLAMMO ; }
                fwsBuffer.getF( tin0P , pbw , cbw ) ;
                cbw = 0 ;
                pbw = 0 ;

                }
                    pbco += cbDone ;
                    memcpy( pbco , pbThis , cbDone ) ;
                {
                if( cbDone )

                //}
                //    while( cDo -- ) *( pbco ++ ) = 0x2d ;
                //    countT cDo = cbDashesDone ;
                //{
                //if( cbDashesDone )

                countT cbDone = pbwe - pbco /*- cbDashesDone*/ ;

                //;
                //    : pbwe - pbco
                //    ? 0x10
                //countT cbDashesDone = pbwe - pbco >= 0x10

                //etThread.traceF( tin0P , T("spanning windows while writing to buffer") ) ;
            {
            else
            }
                pbco += cbThis ;
                memcpy( pbco , pbThis , cbThis ) ;

                //while( cDo -- ) *( pbco ++ ) = 0x2d ;
                //countT cDo = 0x10 ;
            {
            if( cbThis /*+ 0x10*/ <= pbwe - pbco )

            //etThread.traceF( tin0P , T("item length [cbThis]:    ")+TF2(cbThis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            countT cbThis = 3 * sizeof( countT ) + cbData + sizeof( sockaddr_in6 ) ;
            byteT* pbThis = pbci ;

            countT& cbData = ((countT*)pbci)[ 2 ] ;

            //
            //  c+cbData sizeof( sockaddr_in6 )    from
            //  c        cbData                    data
            //  8        4                         cbData
            //  4        4                         rc
            //  0        4                         idGram (serial number)
            //
            //  offset   length                    description
            //
            // INPUT LAYOUT (FROM s_readF WRITING TO MY CIRCULAR BUFFER pbFastBuffer)

            idGramProcessedLath ++ ;

            if( pbci + cbMin > pbe ) pbci = pbCircle ;

            //CONoUTrAW( "+" ) ;
        {
        while( idGramProcessedLath != idGramLath )      // INTENDED TO HANDLE WRAP AOK
    {
    while( !ether )
    ZE( countT , idGramProcessedLath ) ;
    TN( tb4 , "    " ) ;
    byteT* pbci = pbCircle ;
    const byteT* const pbe = pbFastBuffer + sizeof pbFastBuffer ;
    byteT* const pbCircle = pbFastBuffer + sizeof( countT ) ;
    countT& idGramLath = *(countT*)pbFastBuffer ;
    const countT cbMin = 0xc + ifcCBdATAGRAMmAX + sizeof( sockaddr_in6 ) ;

    etThread.osThreadF( TaRG1( tmObey2F ) , (countT)&secretToUseP ) ;

    byteT* pbco = pbw ;
    byteT* pbwe = pbw + cbw ;
    if( !pbw || !cbw ) { BLAMMO ; }         //SHOULD BE IMPOSSIBLE SINCE OPENING FOR WRITING ; U:: fileWindowsC WILL FAIL IF NO MORE SPACE ON DISK OR DISK I/O FAILURE
    fwsBuffer.getF( tin0P , pbw , cbw ) ;    //U:: ACCESSES TO THIS MEMORY WILL EXCEPTION IF DISK I/O FAILURE ; NEED TO USE RESTART TO RECOVER FROM SUCH A FAILURE
    ZE( countT , cbw ) ;
    ZE( byteT* , pbw ) ;

    fileWindowsC fwsBuffer( tin0P , etThread , tFileBuffer , flFILEwINDOW_WRITE | flFILEwINDOW_DOnOTvALIDATE ) ;
    etThread.boxPutF( tin0P , tFileBuffer , "X" , 1 ) ;
    TN( tFileBuffer     , "///d/tmp/foo.buffer.ttt" ) ;

    etThread.osThreadF( TaRG1( tmComplainF ) ) ;

    countT& secretToUseP = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmObey1F )

DONE( tmObey2F )
}
    }
        Sleep( 0 ) ;
        }
            }
                //etThread.traceF( tin0P , T("moving file window") ) ;
                }
                    cb04BufferDone += pbci - pbciSave ;

                    }
                        }
                            break ;

                            }
                                //etThread.traceF( tin0P , T("backlog [thrown,processed,backlog]:    ")+TF2(cThrown,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBacklog,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                countT cBacklog = cThrown - cProcessed ;
                                cProcessed ++ ;

                                }
                                    if( pbw && cbw == head.len ) etThread.memCopyF( tin0P , pbw , pbPayload , head.len ) ;

                                    fwsOut.getF( tin0P , pbw , cbw , head.len , head.off ) ;
                                    ZE( countT , cbw ) ;
                                    ZE( byteT* , pbw ) ;
                                {

                                // etThread.traceF( tin0P , T("received [cmd,off,len]:    ")+TF2(head.idCmd,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)head.off,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(head.len,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                cReceivedFileWindows ++ ;

                                byteT* pbPayload = pbData + sizeof( gramHeadFileWindowS ) ;
                                //etThread.traceF( tin0P , T("file window accepted") ) ;
                            {
//#endif
                            else
                            }
                                etThread.traceF( tin0P , T("secret rejected") ) ;
                            {
                            if( !bOk )
//#if defined( NEVERdEFINED )
//U:: TO FIND A BUG

                            }
                                }
                                    break ;
                                    bOk = 1 ;
                                {
                                if( secretTry == secretOk )

                                //etThread.traceF( tin0P , T("PUTfILEwINDOW [offEpochHonor,offSlot,offSecret,secretOk[0],secretOk[1],secretOk,secretTry,bOk]:    ")+TF2(offEpochHonor,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSlot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSecret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(secretOk0,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(secretOk1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(secretOk,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(secretTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(secretTry==secretOk?".":"X") ) ;

                                //countT secretOk1 = ppcSecrets[ offSlot ][ 1 ] ;
                                //countT secretOk0 = ppcSecrets[ offSlot ][ 0 ] ;
                                countT secretOk  = ppcSecrets[ offSlot ][ offSecret ] ;
                                countT secretTry = head.secret ;
                                countT offSecret = offSecretF( tin0P , etThread , nnFrom , offSlot ) ;
                                countT offSlot   = offEpochHonor % CePOCHsLOTS ;
                            {
                            for( countT offEpochHonor = OFFePOCHhONORmIN ; offEpochHonor <= OFFePOCHhONORmAX ; offEpochHonor ++ )           //U:: NEED TO HANDLE WRAP OF offEpochHonor EVERY 136 YEARS
                            ZE( boolT , bOk ) ;
                            //etThread.traceF( tin0P , T("PUTfILEwINDOW ---------------------------------------------------------------------------------") ) ;

                            gramHeadFileWindowS& head = *(gramHeadFileWindowS*)pbData ;
                        {
                        case ifcIDcMDgRAM_PUTfILEwINDOW :
                        }
                            break ;
                            secretToUseP = head.secret ;        //A:ASSUME: ATOMIC (secretToUseP MUST ALWAYS CONTAIN A VALID SECRET)
                            //etThread.traceF( tin0P , T("received [secret]:    ")+TF2(head.secret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            gramHeadSecretS& head = *(gramHeadSecretS*)pbData ;
                        {
                        case ifcIDcMDgRAM_USEtHISsECRET :
                        }
                            break ;
                            sThrow.writeF( tin0P , idPortCatch /*idpFrom*/ , nnFrom , (byteT*)&gram , sizeof gram ) ;

                            //gram.pad3   = 0x3d3d3d3d ;
                            //gram.pad2   = 0x3d3d3d3d ;
                            //gram.pad1   = 0x3d3d3d3d ;
                            gram.secret = secret ;
                            gram.idCmd = ifcIDcMDgRAM_USEtHISsECRET ;
                            gram.cbThisGram = sizeof gram ;
                            gramHeadSecretS gram ;

                            //etThread.traceF( tin0P , T("dispensing [offSlotHonorNewest,offSecret,secret]:    ")+TF2(offSlotHonorNewest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSecret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(secret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            countT secret    = ppcSecrets[ offSlotHonorNewest ][ offSecret ] ;
                            countT offSecret = offSecretF( tin0P , etThread , nnFrom , offSlotHonorNewest ) ;

                            countT offSlotHonorNewest = OFFePOCHhONORmAX   % CePOCHsLOTS ;
                        {
                        case ifcIDcMDgRAM_DISPENSEsECRET :
                    {
                    switch( head.idCmd )
                    gramHeadS& head = *(gramHeadS*)pbData ;

                    }

                        }
                            }
                                break ;
                                BLAMMO ;
                                etThread.traceF( tin0P , T("received unexpected [from.sin6_family]:    ")+TF2(from.sin6_family,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            default :
                            }
                                break ;
                                BLAMMO ;
                                etThread.traceF( tin0P , T("received AF_INET [from.sin6_family]:    ")+TF2(from.sin6_family,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                            {
                            case AF_INET :
                            }
                                break ;

                                if( !nnFrom ) nnFrom = NICnAMElOCAL ;

                                }
                                    pcOut[ 3 - offi ] = ((tin1S&)tin0P).brcRaw ;
                                    BOSdOnOTtEST( WHATgbo , ntohl( pcIn[ offi ] ) )
                                {
                                for( countT offi = 0 ; offi < 4 ; offi ++ )
                                countT* pcOut = (countT*)(const countT*)nnFrom ;
                                countT* pcIn  = (countT*)from.sin6_addr.u.Byte ;

                                idpFrom = ((tin1S&)tin0P).brcRaw ;
                                BOSdOnOTtEST( WHATgbo , ntohs( from.sin6_port ) )
                            {
                            case AF_INET6 :
                        {
                        switch( from.sin6_family )
                    {
                    nicNameC nnFrom ;
                    ZE( countT , idpFrom ) ;

                    }
                        Sleep( 0 ) ;
                    {
                    while( from.sin6_family != AF_INET6 )

                    sockaddr_in6& from   = *(sockaddr_in6*)pbci ; pbci += sizeof( sockaddr_in6 ) ;
                    byteT*        pbData = pbci                 ; pbci += cbData                 ;

                    pbci += 3 * sizeof( countT ) ;

                    //etThread.traceF( tin0P , T("recd [idGram]:    ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    }
                        Sleep( 0 ) ;
                        //etThread.traceF( tin0P , T("recd waiting for !!idGram") ) ;
                    {
                    while( !idGram )

                    countT& cbData = ((countT*)pbci)[ 2 ] ;
                    countT& rc     = ((countT*)pbci)[ 1 ] ;
                    countT& idGram = ((countT*)pbci)[ 0 ] ;

                    //
                    //  c+cbData sizeof( sockaddr_in6 )    from
                    //  c        cbData                    data
                    //  8        4                         cbData
                    //  4        4                         rc
                    //  0        4                         idGram (serial number)
                    //
                    //  offset   length                    description
                    //

                    //CONoUTrAW( "+" ) ;

                    }
                        break ;     // THIS IS INTENDED TO HAVE THE EFFECT OF CLOSING THE CURRENT FILE WINDOW AND, IN THE NEXT ITERATION, OPENING A NEW FILE WINDOW POSITIONED AT THE BEGINNING OF THE CURRENT RECORD
                        bArmed = 1 ;
                        //etThread.traceF( tin0P , T("spanned record: breaking to reposition file window [pbciSave-pbBufw,cb04BufferDone]:    ")+TF2(pbciSave-pbBufw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)cb04BufferDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    {
                    if( bFail1 || bFail2 )

                    //if( bFail2 ) etThread.traceF( tin0P , T("fail 2 [cbData]:    ")+TF2(((countT*)pbci)[2],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    boolT bFail2 = bFail1 ? 0 : pbci + 3 * sizeof( countT ) + ((countT*)pbci)[ 2 ] + sizeof( sockaddr_in6 ) > pbcie ;
                    boolT bFail1 =              pbci + 3 * sizeof( countT )                                                 > pbcie ;
                    
                    //etThread.traceF( tin0P , T("item [pbcie,pbci]:    ")+TF2((countT)pbcie,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)pbci,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    }
                        //etThread.traceF( tin0P , T("item [idGram,rc,cbData]:    ")+TF2(idGram,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbData,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                        countT& cbData = ((countT*)pbci)[ 2 ] ;
                        countT& rc     = ((countT*)pbci)[ 1 ] ;
                        countT& idGram = ((countT*)pbci)[ 0 ] ;
                    {
                    if( bArmed )

                    //etThread.traceF( tin0P , T("item [pbci-pbBufw]:    ")+TF2((countT)(pbci-pbBufw),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    #endif

                        pbci += 4 * sizeof( countT ) ;

                        { BLAMMO ; }
                        )
                            )
                                || ((countT*)pbci)[ 3 ] != 0x2d2d2d2d
                                || ((countT*)pbci)[ 2 ] != 0x2d2d2d2d
                                || ((countT*)pbci)[ 1 ] != 0x2d2d2d2d
                                   ((countT*)pbci)[ 0 ] != 0x2d2d2d2d
                            (
                            && 
                            ((countT*)pbci)[ 0 ]
                        (
                        if

                    #if defined( NEVERdEFINED )

                    //etThread.traceF( tin0P , T("item at [pbciSave-pbBufw,cb04BufferDone]:    ")+TF2(pbciSave-pbBufw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)cb04BufferDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    byteT* pbciSave = pbci ; //U:: TO FIND A BUG
                {
                while( pbci < pbcie )

                byteT* pbcie = pbBufw + cbBufw ;
                byteT* pbci  = pbBufw ;

                }
                    break ;
                    etThread.traceF( tin0P , T("recd: no more input") ) ;
                {
                if( !pbBufw || !cbBufw )

                etThread.traceF( tin0P , T("window [cb04BufferDone,cbBufw]:    ")+TF2((countT)cb04BufferDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cbBufw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                fwsBuffer.getF( tin0P , pbBufw , cbBufw , 0 , cb04BufferDone ) ;
                ZE( countT , cbBufw ) ;
                ZE( byteT* , pbBufw ) ;

                fileWindowsC fwsBuffer( tin0P , etThread , tFileBuffer , flFILEwINDOW_DOnOTvALIDATE ) ;
            {
            while( !ether )
        {
        //etThread.traceF( tin0P , T("constructing fwsBuffer for reading") ) ;
    {
    while( !ether )
    ZE( boolT , bArmed ) ;  //U:: TO FIND A BUG
    TN( tFileBuffer , "///d/tmp/foo.buffer.ttt" ) ;
    ZE( count04T , cb04BufferDone ) ;

    TN( tb4 , "    " ) ;
    const countT cbMin = 0xc + ifcCBdATAGRAMmAX + sizeof( sockaddr_in6 ) ;
    sThrow.bindF( tin0P ) ;
    socketC sThrow( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    fileWindowsC fwsOut( tin0P , etThread , tFileOut , flFILEwINDOW_WRITE | flFILEwINDOW_DOnOTvALIDATE ) ;
    etThread.boxPutF( tin0P , tFileOut , "X" , 1 ) ;
    TN( tFileOut , "///d/tmp/foo.received.fws.ttt" ) ;

    countT& secretToUseP = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmObey2F )

DONE( tmComplainF )
}
    }
        Sleep( 100 ) ;

        }
            dec02AM( cComplaintPending ) ;
            etThread.traceF( tin0P , t1+TF2(cComplaintPending,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cProcessed,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        while( cComplaintPending )
    {
    while( !ether )
    TN( t1 , "buffer overrun (packets lost) [cComplaintsPending,cProcessed (approximate)]:    " ) ;
    TN( tb4 , "    " ) ;
{
if( pTaskP )
TASK( tmComplainF )

DONE( tmGetSecretF )
}
    }
        ++ s ; ether.osSleepF( tin0P , TIMEePOCH >> 1 ) ;

        }
            ++ s ; ether.osSleepF( tin0P , TOCK >> 4 ) ;
            sThrow.writeF( tin0P , idPortCatch , nicNameC() , (byteT*)&gram , sizeof gram ) ;
            //gram.pad3   = 0x3d3d3d3d ;
            //gram.pad2   = 0x3d3d3d3d ;
            //gram.pad1   = 0x3d3d3d3d ;
            gram.idCmd = ifcIDcMDgRAM_DISPENSEsECRET ;
            gram.cbThisGram = sizeof gram ;
            gramHeadSecretS gram ;
            //CONoUTrAW( "!" ) ;
        {
        while( old == secretToUseP )
        countT old =  secretToUseP ;
    {
    while( !ether )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    sThrow.bindF( tin0P ) ;
    socketC sThrow( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;

    countT& secretToUseP = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmGetSecretF )

DONE( tmEpochClockF )
}
    }
        }
            //break ; //U:: TO FIND A BUG
            //etThread.traceF( tin0P , T("ready to test incoming secrets") ) ;
            bSetup = 0 ;
        {
        if( bSetup && !OFFePOCHhONORmIN )          // OFFePOCHhONORmIN IS INITIALLY NEGATIVE ; WHEN IT BECOMES 0, WE ARE READY TO START TESTING INCOMING SECRETS

        offEpochFreshening ++ ;

        if( !bSetup ) { ++ s ; ether.osSleepF( tin0P , TIMEePOCH ) ; }

        }
            ppcHashSecrets[ offSlotFreshen ][ offSecret ] = ru2 ;
        {
        for( countT offSecret = 0 ; offSecret < ChASHsECRETS ; offSecret ++ )
        ranUniC ru2( tin0P , (measure04T)MAXcOUNTT + 1 , slab.trueRandom ) ;

        }
            ppcSecrets[ offSlotFreshen ][ offSecret ] = ru1 ;
        {
        for( countT offSecret = 0 ; offSecret < CsECRETS ; offSecret ++ )
        ranUniC ru1( tin0P , (measure04T)MAXcOUNTT + 1 , slab.trueRandom ) ;

        //etThread.traceF( tin0P , T("[offEpochFreshening,OFFePOCHhONORmIN,OFFePOCHhONORmAX]:    ")+TF2(offEpochFreshening,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(OFFePOCHhONORmIN,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(OFFePOCHhONORmAX,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        //etThread.traceF( tin0P , T("[offSlotFreshen,offSlotHonorOldest,offSlotHonorNewest]:    ")+TF2(offSlotFreshen,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSlotHonorOldest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offSlotHonorNewest,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        countT offSlotHonorNewest = OFFePOCHhONORmAX   % CePOCHsLOTS ;
        countT offSlotHonorOldest = OFFePOCHhONORmIN   % CePOCHsLOTS ;
        countT offSlotFreshen     = offEpochFreshening % CePOCHsLOTS ;
    {
    while( !ether )
    slabS& slab = slabS::slabIF() ;
    boolT bSetup = 1 ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    TN( tb4 , "    " ) ;
{
if( pTaskP )
TASK( tmEpochClockF )

}
    return offs % CsECRETS ;

    //etherP.traceF( tin0P , T("offSecretF [off,nn,offSlotP]:    ")+TF2(offs%CsECRETS,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(nnP)+tb4+TF2(offSlotP,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4 ) ;

    }
        offs ^= *( pcc ++ ) ^ hashSecret ;
        //etherP.traceF( tin0P , T("offSecretF [offhs,hashSecret]:    ")+TF2(offhs,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(hashSecret,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        countT hashSecret = ppcHashSecrets[ offSlotP ][ offhs ] ;
    {
    for( countT offhs = 0 ; pcc < pce && offhs < ChASHsECRETS ; offhs ++ )
    ZE( countT , offs ) ;
    TN( tb4 , "    " ) ;

    countT* pce = pcc + sizeof nnP / sizeof( countT ) ;         //A:ASSUME: nicNameC IS AN INTEGRAL NUMBER OF countT ; IF NOT TRUE THEN THE TRAILING PORTION WILL NOT BE HASHED
    countT* pcc = (countT*)&nnP ;
{
countT offSecretF( tin0S& tin0P , etherC& etherP , const nicNameC& nnP , const countT offSlotP )

;
}
    //countT   pad4 ;          //U:: TO FIND A BUG
    //countT   pad3 ;          //U:: TO FIND A BUG
    //countT   pad2 ;          //U:: TO FIND A BUG
    //countT   pad1 ;          //U:: TO FIND A BUG
    countT   secret ;
    countT   len ;
    count04T off ;
{
struct gramHeadFileWindowS : public gramHeadS

;
}
    //countT   pad3 ;          //U:: TO FIND A BUG
    //countT   pad2 ;          //U:: TO FIND A BUG
    //countT   pad1 ;          //U:: TO FIND A BUG
    countT   secret ;
{
struct gramHeadSecretS : public gramHeadS

;
}
    countT   idCmd ;
    countT   cbThisGram ;       // INCLUDES ENTIRE gramHeadS INCLUDING THIS MEMBER
{
struct gramHeadS


countT ppcHashSecrets[ CePOCHsLOTS ][ ChASHsECRETS ] ;

                                                // THE OLDEST ROW IS NOT REFERENCED, AND RECEIVES FRESH RANDOM countT VALUES IMMEDIATELY BEFORE offEpochFreshening IS INCREMENTED
                                                // HONORS    ppcSecrets[ offHonor                   % CePOCHsLOTS ][ ii ] WHERE offHonor IS IN [ offEpochFreshening - CePOCHhONORED , offEpochFreshening - 1 ]
countT ppcSecrets[ CePOCHsLOTS ][ CsECRETS ] ;  // DISPENSES ppcSecrets[ ( offEpochFreshening - 1 ) % CePOCHsLOTS ][ ii ] IF offSecretF RETURNS ii, CALCULATED BY HASHING THE IP ADDRESS
countT offEpochFreshening ;

byteT  pbFastBuffer[ TOCK ] ;

countT cComplaintPending ;
countT cProcessed ;
countT cThrown ;
count04T cb04Thrown ;
countT cReceivedFileWindows ;
countT idPortCatch ;

#define ChASHsECRETS ( sizeof( nicNameC ) / sizeof( countT ) )

#define CsECRETS    TOCK

#define TIMEePOCH ( TOCK << 4 )

#define OFFePOCHhONORmAX ( offEpochFreshening - 1             )
#define OFFePOCHhONORmIN ( offEpochFreshening - CePOCHhONORED )

#define CePOCHhONORED ( CePOCHsLOTS - 1 )

#define CePOCHsLOTS 5

#define ifcIDcMDgRAM_PUTfILEwINDOW       0x3
#define ifcIDcMDgRAM_USEtHISsECRET       0x2
#define ifcIDcMDgRAM_DISPENSEsECRET      0x1

#define CBpAYLOAD ( ifcCBdATAGRAMmAX - sizeof( gramHeadFileWindowS ) )

//#define CBpAYLOAD 0xb0
//U:: TO FIND A BUG, ADJUST THIS SO THAT BUFFER IS NICELY FORMATTED ON REPORT LINE BOUNDARIES

/*1*/WAKEsHOWtEXT( "udp.cdn.proof.of.concept.now.add.source.ip.validation.hash.map.ip.to.secret" )/*1*/
/**/
*/
 this code works and suggests that code like this can keep up with incoming datagrams on a 1 gbit per second wire
 instead, secrets are honored for unlimited requests within an epoch (e.g. a tock or tock << 2)
 i eliminate the concept of ttl for each secret per requester
 baseline: 5adam.510007c2.1
i use hash to map ip address to secret in order to bound the size of the state needed for deluge of spoofed requests for secret
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
