
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return cbFree ;

    }
        }
            thirdC::c_strncpyIF( tinBaseP , home.postHome , tHome , sizeof home.postHome ) ;

            delF( tinBaseP , psttNoSlash ) ;
            TN( tHome , psttNoSlash ) ;

            strSubstringF( tinBaseP , psttNoSlash , idf , idl , psttP ) ; ___( psttNoSlash ) ;
            countT idl = psttP->idAdam - 1 ;
            countT idf = 1 ;
            ZE( strokeS* , psttNoSlash ) ;
        {
        if( bIdeafarm && psttP )

        }
            DEL( pInfo ) ;
            if( pInfo ) cbFree = pInfo->cBytesPerSector * pInfo->cSectorsPerAllocationUnit * pInfo->cUnusedUnits ;
            diskInfoF( tinBaseP , pInfo , psttP ) ; ___( pInfo ) ;
            ZE( infoDiskS* , pInfo ) ;
        {

        delF( tinBaseP , psttEnv ) ;
        delF( tinBaseP , psttSetting ) ;
        }
            delF( tinBaseP , psttPath ) ;

            }
                strMakeF( tinBaseP , LF , psttP , psttPath ) ; ___( psttP ) ;
                diskMakeDirF( tinBaseP , psttPath ) ;
                delF( tinBaseP , psttDiskBest ) ;
                if( !POOP ) psttPath[ CSpREFIX + 3 ] = psttDiskBest[ CSpREFIX + 3 ] ;
                diskFindMostFreeSpaceF( tinBaseP , psttDiskBest ) ; ___( psttDiskBest ) ;
                ZE( strokeS* , psttDiskBest ) ;
            {
            if( !psttP )

            }
                delF( tinBaseP , pstt1List ) ;
                }
                    }
                        break ;
                        strMakeF( tinBaseP , LF , psttP , psttc1 ) ; ___( psttP ) ;
                    {
                    FORsTRINGSiN1( pstt1List )
                {
                if( pstt1List && pstt1List->idAdam )
                QUITOZ diskFindFileOrDirF( tinBaseP , pstt1List , fnLike.pathF() , &pat ) ; ___( pstt1List ) ; QUITR
                ZE( strokeS* , pstt1List ) ;
                
                patternC pat( tinBaseP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                fileNameC fnLike( tinBaseP , *this , psttPath ) ;
            {

            }
                strFuseF( tinBaseP , psttPath , tPath ) ; ___( psttPath ) ;
                }
                    __1 ;   //20231123@1755: ADDED BECAUSE AFAIK THE CODE NEVER USES A KEY OTHER THAN "ideafarm" ; IF THIS FUNCTIONALITY IS EVER NEEDED, DEFINE A THREADmODE FLAG TO ENABLE THIS (TO NOT WARN AND TO NOT BECOME IMPOTENT)
                    traceF( tinBaseP , T("diskChooseSiteF / warning: probable configuration error (missing drive letter?): unexpected key [pattern]: ")+tPath ) ;
                {
                if( strCompareF( tinBaseP , psttKeyP , T("ideafarm") ) )
                TN( tPath , "" ) ; tPath = T("///?/")+T(psttKeyP)+T(".home.")+TF2(idHomeDisk,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("/") ;
            {
            else
            if( psttPathP ) { strFuseF( tinBaseP , psttPath , psttPathP                                                 ) ; ___( psttPath ) ; }
            ZE( strokeS* , psttPath ) ;
            const countT idHomeDisk = ifc_idHomeIdisk_IF() ;
        {
        else
        //}
        //    strMakeF( tinBaseP , LF , psttP , psttEnv ) ; ___( psttP ) ;
        //    delF( tinBaseP , psttb ) ;
        //    if( psttb && !psttb->idAdam ) diskMakeDirF( tinBaseP , psttEnv ) ;
        //    diskFindFileOrDirF( tinBaseP , psttb , psttEnv ) ; ___( psttb ) ;
        //    ZE( strokeS* , psttb ) ;
        //    __( psttEnv[ CSpREFIX - 1 + psttEnv->idAdam ].idAdam - '/' ) ;
        //{
        //else if( psttEnv )
        //DEPRECATED FOR PORTABILITY: ALL "ENVIRONMENT" SETTINGS ARE PICKED UP FROM LITTLE FILES IN THE ROOT DIRECTORY "c"":\"
        }
            strMakeF( tinBaseP , LF , psttP , psttSetting ) ; ___( psttP ) ;
            delF( tinBaseP , psttb ) ;
            if( psttb && !psttb->idAdam ) diskMakeDirF( tinBaseP , psttSetting ) ;
            diskFindFileOrDirF( tinBaseP , psttb , fnLike.pathF() , &pat ) ; ___( psttb ) ;
            ZE( strokeS* , psttb ) ;

            patternC pat( tinBaseP , *this , fnLike , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
            fileNameC fnLike( tinBaseP , *this , psttSetting ) ;

            __( psttSetting[ CSpREFIX - 1 + psttSetting->idAdam ].idAdam - '/' ) ;
        {
        if( psttSetting )

        //A: }
        //A:     else        POOPR
        //A:     if( !POOP ) { strMakeF( tinBaseP , LF , psttSetting , T(postValue) ) ; ___( psttSetting ) ; }
        //A: 
        //A:     thirdC::dosReadIF( tinBaseP , postValue , costValue , tFile ) ;
        //A:     POOPIE
        //A: 
        //A:     countT  costValue = sizeof postValue ;
        //A:     osTextT postValue[ 0x100 ] ;
        //A: 
        //A:     TN( tFile , "c" ":\\ideafarm." ) ; tFile += TF1(etherC::ifc_idHomeIdisk_IF())+T(".setting.keyValue.")+T(psttKeyP) ;
        //A: {
        //A: 20141129@2025: DISABLED TO KEEP SYNCH WITH diskFindHomeIF ; THE USE OF LITTLE SETTINGS FILES IS OBSOLETE ; IF A SETTING IS TO BE USED, QUERY THE SETTINGS bitTreeC

        ZE( strokeS* , psttSetting ) ;

        //osEnvironmentVariableF( tinBaseP , psttEnv , psttKeyP ) ; ___( psttEnv ) ;
        ZE( strokeS* , psttEnv ) ;
    {
    else
    if( bIdeafarm && home.postHome[ 0 ] ) { strMakeFromOsTextF( tinBaseP , psttP , T(ifFileNameC(tinBaseP,third,home.postHome))+T("/") ) ; ___( psttP ) ; }
    ZE( countT , cbFree ) ;

    boolT bIdeafarm = !psttPathP && !strCompareF( tinBaseP , psttKeyP , T("ideafarm") ) ;
    homeS& home = homeS::homeIF() ;

    _IO_

    }
        if( POOP ) return 0 ;
        __( !!psttKeyP && !psttKeyP->idAdam ) ;
        if( POOP ) return 0 ;
        __( psttPathP && psttPathP[ CSpREFIX - 1 + psttPathP->idAdam ].idAdam - '/' ) ;
        __( !psttPathP && !psttKeyP ) ;
        if( POOP ) return 0 ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/countT etherC::diskChooseSiteF( tin0S& tinBaseP , strokeS*& psttP , const strokeS* const psttKeyP , const strokeS* const psttPathP )/*1*/

/**/
*/
 psttPathP
   must not contain '/' or '.'
  must be alphanumeric or '_'
  example: T("103001f")
  example: T("ideafarm")
 psttKeyP
 psttP
arguments
evaluates to the number of bytes of free space
  \<A HREF=\"5.d210104.1.1.0.html\"\>d210104:  WAKEsHOW( "example.simplest.func.103001f.etherC.diskChooseSiteF" )\</A\>
 simplest
examples
\<A HREF=\"5.103001f.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$diskChooseSiteF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

