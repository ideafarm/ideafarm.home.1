
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.traceF( tin0P , T("i've been fired") ) ;

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    }
        etThread.traceF( tin0P , T("socket is impotent") ) ;
        POOPRqUIET
    {
    if( POOP )

    etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
    TN( tb4 , "    " ) ;

    }
        DEL( pSwPathValue ) ;

        }
            }
                etThread.delF( tin0P , psttValue ) ;

                }
                    }
                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                        *pptValue[ offe ] = T(psttValue) ;
                    {
                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                {
                for( countT offe = 0 ; offe < cPaths ; offe ++ )

                if( cPaths - cValues ) { BLAMMO ; }
                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

                strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                _IO_
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
        {
        if( !POOP )

        ;
        }
            &tPathDeviceId     ,
            &tPathAccessToken  ,
        {
        textC* pptPath[] =

        TN( tPathDeviceId    , "\"device_id\"/"    ) ;
        TN( tPathAccessToken , "\"access_token\"/" ) ;

        ;
        }
            &tValueDeviceId      ,
            &tValueAccessToken ,
        {
        textC* pptValue[] =

        __Z( pSwPathValue ) ;
        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
        ZE( switchC* , pSwPathValue ) ;
        ZE( strokeS* , psttPath     ) ;
    {

    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    etThread.traceF( tin0P , T("json response:") ) ;

    }
        }
            else if( costj ) break ;
                 if( cNest ) costj ++ ;

            else if( postj[ costj ] == '}' ) cNest -- ;
                 if( postj[ costj ] == '{' ) cNest ++ ;

            if( !cbIn ) break ;
            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
        {
        for(;;)
        ZE( countT , cNest ) ;
    {
    ZE( countT , costj ) ;
    osTextT postj[ TUCK << 1 ] ;

    sockc.writeF( tin0P , (osTextT*)tSay ) ;
    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    etThread.traceF( tin0P , T("request:") ) ;

    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/logout/all HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(0,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;

    //sockc.connectF( tin0P , 80 , nnServer ) ;
    //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

    sockc.connectF( tin0P , 443 , nnServer ) ;
    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
    countT timeAllowedConnected = TICK >> 2 ;

    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
    nicNameC nnServer ;

    SCOOPS
{
IFsCRATCH

}
    }
        etThread.traceF( tin0P , T("socket is impotent") ) ;
        POOPRqUIET
    {
    if( POOP )

    etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
    TN( tb4 , "    " ) ;

    }
        DEL( pSwPathValue ) ;
        
        }
            }
                etThread.delF( tin0P , psttValue ) ;
        
                }
                    }
                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pptValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                        *pptValue[ offe ] = T(psttValue) ;
                    {
                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                {
                for( countT offe = 0 ; offe < cPaths ; offe ++ )
        
                if( cPaths - cValues ) { BLAMMO ; }
                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
        
                etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
        
                strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
        
                _IO_
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
        {
        if( !POOP )
        
        ;
        }
            &tPathDeviceId     ,
            &tPathAccessToken  ,
        {
        textC* pptPath[] =
        
        TN( tPathDeviceId    , "\"device_id\"/"    ) ;
        TN( tPathAccessToken , "\"access_token\"/" ) ;
        
        ;
        }
            &tValueDeviceId      ,
            &tValueAccessToken ,
        {
        textC* pptValue[] =
        
        __Z( pSwPathValue ) ;
        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
        ZE( switchC* , pSwPathValue ) ;
        ZE( strokeS* , psttPath     ) ;
    {

    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    etThread.traceF( tin0P , T("json response:") ) ;

    }
        }
            else if( costj ) break ;
                 if( cNest ) costj ++ ;

            else if( postj[ costj ] == '}' ) cNest -- ;
                 if( postj[ costj ] == '{' ) cNest ++ ;

            if( !cbIn ) break ;
            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
        {
        for(;;)
        ZE( countT , cNest ) ;
    {
    ZE( countT , costj ) ;
    osTextT postj[ TUCK << 1 ] ;

    sockc.writeF( tin0P , (osTextT*)tSay ) ;
    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    etThread.traceF( tin0P , T("request:") ) ;

    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/login HTTP/1.1\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+T(postBody) ;

    countT costBody = tBody.csF( tin0P ) ;
    TN( tBody , postBody ) ;

    //sockc.connectF( tin0P , 80 , nnServer ) ;
    //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

    sockc.connectF( tin0P , 443 , nnServer ) ;
    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
    countT timeAllowedConnected = TICK >> 2 ;

    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
    nicNameC nnServer ;

    SCOOPS
{
IFsCRATCH
TN( tValueDeviceId       , "" ) ;
TN( tValueAccessToken , "" ) ;

  TN( tServer , "matrix.communick.com" ) ;

TODO

;

    "}\r\n"
    "    \"password\": \"\"\r\n"
    "    },\r\n"
    "        \"user\": \"ideafarm\"\r\n"
    "        \"type\": \"m.id.user\",\r\n"
    "    {\r\n"
    "    \"identifier\":\r\n"
    "    \"type\": \"m.login.password\",\r\n"
    "{\r\n"

osTextT* postBody =

/*1*/WAKEsHOWtEXT( "copy.of.doodle.matrix.kill.all.access.tokens" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
