
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK >> 2 ) ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

#endif
}
//    bFail = WSACleanup() ;

    if( bFail ) ;

    bFail = bind( osh , (sockaddr*)&info2 , sizeof info2 ) ;

    info2.sin6_port   = (short)htons( 0x00000035 ) ;
    info2.sin6_family = AF_INET6 ;
    static sockaddr_in6 info2 ;

    unsigned osh = socket( PF_INET6 , SOCK_DGRAM , 0 ) ;

    }
//        bFail = WSAStartup( 0x0202 , &info1 ) ;
//        WSADATA info1 ;
    {

    int bFail = 0 ;
{
#if defined( NEVERdEFINED )

TODO

DONE( tmWorkF )
}
    etThread.traceF( tin0P , T("Normal access restored.") , flTRACE_NOpREFIX | flTRACE_KEEPcRlF | flTRACE_NOcRlFaTbEGINNING ) ;

    sgnDone_tmWorkDnsF.waitF( tin0P ) ;
    }
        bQuitDns = 1 ;



        }
            ++ s ; etThread.osSleepF( tin0P , TUCK >> 6 ) ;
        {
        while( !bHeardEnterKey )
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkDnsF , sgnDone_tmWorkDnsF , TICK >> 2 ) , (countT)&bHeardEnterKey ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
        ZE( boolT , bHeardEnterKey ) ;
    {

    etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkDnsF , sgnDone_tmWorkDnsF , TICK >> 2 ) , (countT)&bQuitDns ) ;     //U::O: REPLACE "TICK >> 2" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
    signC sgnDone_tmWorkDnsF( tin0P , TAG( TAGiDnULL ) ) ;
    ZE( boolT , bQuitDns ) ;

    TN( tY , "y" ) ;

        etThread.delF( tin0P , psttBrowser ) ;
        //etThread.traceF( tin0P , psttBrowser ) ;
        etThread.osHttpViewerF( tin0P , psttBrowser ) ; ___( psttBrowser ) ;
        ZE( strokeS* , psttBrowser ) ;
{
if( pTaskP )
TASK( tmWorkF )

DONE( tmWorkDnsF )
}
    }
        }
            DELzOMBIE( psoDoomed ) ;
            socketC* psoDoomed = (socketC*)pbSocket ;
        {

        }
            gv.bQuit ++ ;

            }
                ++ s ; etThread.osSleepF( tin0P , TOCK >> 2 ) ;
            {
            while( !POOP && !bQuitDnsP )
        {

        }
            }
                continue ;
                ++ s ; etThread.osSleepF( tin0P , TOCK >> 2 ) ;
                POOPR
            {
            if( POOP )
            sockd.bindF( tin0P , ifcPORToLD2_DNS ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK

        }
            }
                continue ;
                ++ s ; etThread.osSleepF( tin0P , TOCK >> 2 ) ;
                POOPR
            {
            if( POOP )
            new( 0 , tin0P , pbSocket , sizeof pbSocket ) socketC( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        socketC& sockd = *(socketC*)pbSocket ;
        byteT pbSocket[ sizeof( socketC ) ] ;

        _IO_
    {
    while( !POOP && !bQuitDnsP )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    gVarDnsS gv( tin0P , etThread ) ;

    boolT& bQuitDnsP = *(boolT*)pTaskP->c1 ;

    _IO_
{
if( pTaskP && pTaskP->c1 )
TASK( tmWorkDnsF )

;
}
    }
    {
    bQuit( 0 )
    inline gVarDnsS( tin0S& tin0P , etherC& etherP ) :

    boolT   bQuit                 ;
{
struct gVarDnsS

/*1*/WAKEhIDE( "doodle squeeze" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
