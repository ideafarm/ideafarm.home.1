
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

etThread.delF( tinP , pstt01WildList ) ;

diskZipEtherF( tinP , etThread , T("///d/tmp/zoo.zip") , pstt01WildList , 0 , 0 , T("-max") , T("-9") , ifcIDzIPPER_PKZIPC ) ;
//diskZipEtherF( tinP , etThread , T("///d/tmp/zoo.zip") , pstt01WildList , 0 , 0 , 0 , 0 ) ;
//diskZipEtherF( tinP , etThread , T("///d/tmp/zoo.zip") , pstt01WildList , 0 , 0 , T("[pkzipc specs]") , T("[infozip specs]") ) ;

etThread.strFuseSeparateF( tinP ,      pstt01WildList , T("///d/tmp/hoo.ttt") ) ;
etThread.strFuseSeparateF( tinP ,      pstt01WildList , T("///d/tmp/goo.ttt") ) ;
etThread.strFuseSeparateF( tinP ,      pstt01WildList , T("///d/tmp/foo.ttt") ) ;
etThread.strMakeF(         tinP , LF , pstt01WildList , 0 , TUCK ) ; ___( pstt01WildList ) ;
//etThread.strMakeF(         tinP , LF , pstt01WildList , T("///d/tmp/joo.ttt") , TUCK ) ; ___( pstt01WildList ) ;
ZE( strokeS* , pstt01WildList ) ;

TODO

}
    etThreadP.delF( tinP , postWildListExclude ) ;
    etThreadP.delF( tinP , postWildListInclude ) ;
    etThreadP.delF( tinP , postWildList        ) ;
    diskZipThirdF( tinP , etThreadP , T(osfnTo) , postWildList , postWildListInclude , postWildListExclude , T(psttSpecsPKZipP) , T(psttSpecsInfoZipP) , idZipperP ) ;

    }
        }
            }
                            thirdC::c_strcatIF( tinP , postWildListExclude , osfnWild ) ;
                else        thirdC::c_strcatIF( tinP , postWildListExclude , " "      ) ;
                if( bWoth ) bWoth = 0 ;
                etThreadP.traceF( tinP , T(osfnWild) ) ;
                osFileNameC osfnWild( tinP , etThreadP , T(psttc1) ) ;
            {
            FORsTRINGSiN1( pstt01WildListExcludeP )
            boolT bWoth = 1 ;
        {
        else
        }
            thirdC::c_strcpyIF( tinP , postWildListExclude , osfnWild ) ;
            etThreadP.traceF( tinP , T(osfnWild) ) ;
            osFileNameC osfnWild( tinP , etThreadP , T(pstt01WildListExcludeP) ) ;
        {
        if( !bIsListWildExclude )

        *postWildListExclude = 0 ;
        etThreadP.newF( tinP , LF , postWildListExclude , pstt01WildListExcludeP->idAdam + cWildExclude ) ; ___( postWildListExclude ) ;
    {
    if( pstt01WildListExcludeP )
    ZE( osTextT* , postWildListExclude ) ;

    }
        }
            }
                            thirdC::c_strcatIF( tinP , postWildListInclude , osfnWild ) ;
                else        thirdC::c_strcatIF( tinP , postWildListInclude , " "      ) ;
                if( bWoth ) bWoth = 0 ;
                etThreadP.traceF( tinP , T(osfnWild) ) ;
                osFileNameC osfnWild( tinP , etThreadP , T(psttc1) ) ;
            {
            FORsTRINGSiN1( pstt01WildListIncludeP )
            boolT bWoth = 1 ;
        {
        else
        }
            thirdC::c_strcpyIF( tinP , postWildListInclude , osfnWild ) ;
            etThreadP.traceF( tinP , T(osfnWild) ) ;
            osFileNameC osfnWild( tinP , etThreadP , T(pstt01WildListIncludeP) ) ;
        {
        if( !bIsListWildInclude )

        *postWildListInclude = 0 ;
        etThreadP.newF( tinP , LF , postWildListInclude , pstt01WildListIncludeP->idAdam + cWildInclude ) ; ___( postWildListInclude ) ;
    {
    if( pstt01WildListIncludeP )
    ZE( osTextT* , postWildListInclude ) ;

    }
        }
            }
                            thirdC::c_strcatIF( tinP , postWildList , osfnWild ) ;
                else        thirdC::c_strcatIF( tinP , postWildList , " "      ) ;
                if( bWoth ) bWoth = 0 ;
                etThreadP.traceF( tinP , T(osfnWild) ) ;
                osFileNameC osfnWild( tinP , etThreadP , T(psttc1) ) ;
            {
            FORsTRINGSiN1( pstt01WildListP )
            boolT bWoth = 1 ;
        {
        else
        }
            thirdC::c_strcpyIF( tinP , postWildList , osfnWild ) ;
            etThreadP.traceF( tinP , T(osfnWild) ) ;
            osFileNameC osfnWild( tinP , etThreadP , T(pstt01WildListP) ) ;
        {
        if( !bIsListWild )

        *postWildList = 0 ;
        etThreadP.newF( tinP , LF , postWildList , pstt01WildListP->idAdam + cWild ) ; ___( postWildList ) ;
    {
    ZE( osTextT* , postWildList ) ;

    }
        else                     cWildExclude = 1 ;
        if( bIsListWildExclude ) { FORsTRINGSiN1( pstt01WildListExcludeP ) { cWildExclude ++ ; } }
    {
    if( pstt01WildListExcludeP )

    }
        else                     cWildInclude = 1 ;
        if( bIsListWildInclude ) { FORsTRINGSiN1( pstt01WildListIncludeP ) { cWildInclude ++ ; } }
    {
    if( pstt01WildListIncludeP )

    }
        else                     cWild = 1 ;
        if( bIsListWild        ) { FORsTRINGSiN1( pstt01WildListP        ) { cWild ++        ; } }
    {
    ZE( countT , cWildExclude ) ;
    ZE( countT , cWildInclude ) ;
    ZE( countT , cWild        ) ;

    boolT bIsListWildExclude = pstt01WildListExcludeP && ISsTRINGoFsTRINGS( pstt01WildListExcludeP ) ;
    boolT bIsListWildInclude = pstt01WildListIncludeP && ISsTRINGoFsTRINGS( pstt01WildListIncludeP ) ;
    boolT bIsListWild        =                           ISsTRINGoFsTRINGS( pstt01WildListP        ) ;

    etThreadP.traceF( tinP , T(osfnTo) ) ;
    osFileNameC osfnTo( tinP , etThreadP , T(psttToP) ) ;

    }
        if( POOP ) return ;
        }
            __( etThreadP.strIdF( tinP , S1C(' ' ) , pstt01WildListExcludeP ) ) ;
            __( etThreadP.strIdF( tinP , S1C('\\') , pstt01WildListExcludeP ) ) ;
        {
        if( pstt01WildListExcludeP )
        }
            __( etThreadP.strIdF( tinP , S1C(' ' ) , pstt01WildListIncludeP ) ) ;
            __( etThreadP.strIdF( tinP , S1C('\\') , pstt01WildListIncludeP ) ) ;
        {
        if( pstt01WildListIncludeP )
        }
            __( etThreadP.strIdF( tinP , S1C(' ' ) , pstt01WildListP ) ) ;
            __( etThreadP.strIdF( tinP , S1C('\\') , pstt01WildListP ) ) ;
        {
        if( POOP ) return ;
        __Z( pstt01WildListP ) ;
        __Z( psttToP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
voidT diskZipEtherF( tinS& tinP , etherC& etThreadP , const strokeS* const psttToP , const strokeS* const pstt01WildListP , const strokeS* const pstt01WildListIncludeP , const strokeS* const pstt01WildListExcludeP , const strokeS* const psttSpecsPKZipP , const strokeS* const psttSpecsInfoZipP , const countT idZipperP = 0 )

}
    thirdP.delF( tinP , postArgs2 ) ;
    thirdP.delF( tinP , postArgs1 ) ;

    __Z( bDone ) ;

    }
        }
            }
                tinP.pEtScratch->traceF( tinP , T("could not zip using bundled infozip zip.exe ; i give up" ) ) ;

                thirdP.delF( tinP , postDir ) ;
                tinP.pEtScratch->traceF( tinP , T("called pkzipc.exe [postArgs]:    ")+T(postArgs1) ) ;
                tinP.pEtScratch->traceF( tinP , T("[postDir]:    ")+T(postDir) ) ;
                thirdP.dosGetCurrentDirF( tinP , postDir ) ; ___( postDir ) ;
                ZE( osTextT* , postDir ) ;
            {
            if( !bDone )

            else bDone = 1 ;
            }
                __( idDeathType ) ;
                __( value ) ;
                tinP.pEtScratch->traceF( tinP , T("bundled infozip zipc.exe failed [value,idDeathType]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            else if( value || idDeathType )
            }
                tinP.pEtScratch->traceF( tinP , T("could not hire bundled infozip zip.exe [POOP]:    ")+TF2(idPoop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT idPoop = POOP ;
            {
            if( POOP )

            tinP.pEther->strokeF( tinP , T("\r\n") ) ;
            ((thirdC&)*tinP.pEtScratch).dosExecPgmF( tinP , countTC() , countTC() , value , idDeathType , "\\ideafarm.home.1\\precious\\domains\\com\\ideafarm\\city\\workshop\\infozip\\zip.exe\\zip.exe"  , postArgs2 ) ;
            tinP.pEther->strokeF( tinP , T("\r\n") ) ;
            SCOOPS
        {
        IFsCRATCH

        idDeathType = value = 0 ;
    {
    if( !bDone && ( !idZipperP || idZipperP == ifcIDzIPPER_INFOZIP ) )

    }
        }
            }
                }
                    tinP.pEther->traceF( tinP , T("!exception: kid process failed [value,rc,name]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postRc) ) ;
                    TN( tb4 , "    " ) ;
                    const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                {
                else
                if( !POOP ) bDone = 1 ;

                }
                    __1
                    __( value ) ;
                {
                if( value != ifcEXITcODE_EXITpROCESSaOK )

                tinP.pEtScratch->osProcessWaitF( tinP , value , countTC() , osTid , osPid ) ;
                ZE( countT , value ) ;

                SCOOPS
                _IO_
            {
            IFsCRATCH
        {
        else
        if( !osPid ) tinP.pEther->traceF( tinP , T("!exception: could not launch ifcIDaDAM_HIREwITHOUTdEBUGGING") ) ;

        }
            c4Result = tinP.pEther->ifcHireF( tinP , T("ifcIDaDAM_HEALaRCHIVES") , ifcIDaDAM_HIREwITHOUTdEBUGGING , tArgs , flHIRE_DISPLAYaUTO , 0 , 0 , 1 , nicNameC() ) ;
            TN( tArgs , "" ) ; tArgs = T("!ignore [comment can go here] !maxValue 0 !hireLater pkzipc.exe ")+T(postArgs1) ;
            _IO_
        {
        countT& osPid = c4Result.c2 ;
        countT& osTid = c4Result.c1 ;
        count4S c4Result ;
    {
    if( bHireNoMonitor )

    }
        }
            }
                tinP.pEtScratch->traceF( tinP , T(bHireNoMonitor?"could not hire pkzipc.exe directly ; will try hiring pkzipc.exe indirectly":"could not zip using pkzipc.exe ; will try the bundled infozip zip.exe" ) ) ;

                thirdP.delF( tinP , postDir ) ;
                tinP.pEtScratch->traceF( tinP , T("called pkzipc.exe [postArgs]:    ")+T(postArgs1) ) ;
                tinP.pEtScratch->traceF( tinP , T("[postDir]:    ")+T(postDir) ) ;
                thirdP.dosGetCurrentDirF( tinP , postDir ) ; ___( postDir ) ;
                ZE( osTextT* , postDir ) ;
            {
            if( !bDone )

            else bDone = 1 ;
            }
                __( idDeathType ) ;
                __( value ) ;
                tinP.pEtScratch->traceF( tinP , T("pczipc.exe failed [value,idDeathType]:    ")+TF2(value,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idDeathType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            {
            else if( value || idDeathType )
            }
                tinP.pEtScratch->traceF( tinP , T("could not hire pczipc.exe [POOP]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(postRc) ) ;
                POOPRqUIET
                const osTextT* postRc = (const osTextT*)processGlobal4S::_processGlobal4I_IF().mapIfcCode( rc ) ;
                bHireNoMonitor = rc == ifcIDiMPOTENCEbASEeRRORcODE_NOTsUPPORTED ;
                countT rc = POOP ;
            {
            if( POOP )

__( ifcIDiMPOTENCEbASEeRRORcODE_NOTsUPPORTED ) ;

            tinP.pEther->strokeF( tinP , T("\r\n") ) ;
//            ((thirdC&)*tinP.pEtScratch).dosExecPgmF( tinP , countTC() , countTC() , value , idDeathType , "pkzipc.exe" , postArgs1 ) ;
            tinP.pEther->strokeF( tinP , T("\r\n") ) ;
            SCOOPS
        {
        IFsCRATCH
    {
    if( !idZipperP || idZipperP == ifcIDzIPPER_PKZIPC )
    ZE( boolT , bHireNoMonitor ) ;
    ZE( countT , idDeathType ) ;
    ZE( countT , value ) ;
    ZE( boolT , bDone ) ;

    tinP.pEther->traceF( tinP , T("[postArgs2]:    ")+T(postArgs2) ) ;
    tinP.pEther->traceF( tinP , T("[postArgs1]:    ")+T(postArgs1) ) ;
    //thirdP.pEtherContainsMe

    }
        tinP.pEther->strMakeF( tinP , LF , postArgs2 , tArgs2 ) ; ___( postArgs2 ) ;
        tinP.pEther->strMakeF( tinP , LF , postArgs1 , tArgs1 ) ; ___( postArgs1 ) ;

        tArgs2 += T(postSpecsInfoZipP)+tb+T(postToP)+tb+T(postWildListP) ;
        tArgs1 += T(postSpecsPKZipP  )+tb+T(postToP)+tb+T(postWildListP) ;
        if( tArgs2.csF( tinP ) ) tArgs2 += tb ;
        if( tArgs1.csF( tinP ) ) tArgs1 += tb ;

        }
            tArgs2 += T(" -x "      )   +T(postWildListExcludeP)+tba ;
            tArgs1 += T(" -exclude ")+tq+T(postWildListExcludeP)+tq  ;
        {
        if( postWildListExcludeP )

        }
            tArgs2 += T(" -i "      )   +T(postWildListIncludeP)+tba ;
            tArgs1 += T(" -include ")+tq+T(postWildListIncludeP)+tq  ;
        {
        if( postWildListIncludeP )

        TN( tArgs2 , "" ) ;
        TN( tArgs1 , "-add" ) ;
        TN( tq , "\""  ) ;
        TN( tb , " "   ) ;
        TN( tba , " @" ) ;
    {
    ZE( osTextT* , postArgs2 ) ;
    ZE( osTextT* , postArgs1 ) ;

    if( postSpecsInfoZipP    ) costAll += thirdC::c_strlenIF( tinP , postSpecsInfoZipP    ) ;
    if( postSpecsPKZipP      ) costAll += thirdC::c_strlenIF( tinP , postSpecsPKZipP      ) ;   // REALLY ONLY NEED THE MAXIMUM LENGTH SINCE ONLY WO SPEC IS USED AT A TIME; DONE THIS WAY FOR SIMPLICITY (SPECS ARE SHORT)
    if( postWildListExcludeP ) costAll += thirdC::c_strlenIF( tinP , postWildListExcludeP ) ;
    if( postWildListIncludeP ) costAll += thirdC::c_strlenIF( tinP , postWildListIncludeP ) ;
    countT                     costAll  = thirdC::c_strlenIF( tinP , postToP ) + thirdC::c_strlenIF( tinP , postWildListP ) + TUCK ;

    tinP.pEther->traceF( tinP , T("[postSpecsInfoZipP   ]:    ")+T(postSpecsInfoZipP)    ) ;
    tinP.pEther->traceF( tinP , T("[postSpecsPKZipP     ]:    ")+T(postSpecsPKZipP)      ) ;
    tinP.pEther->traceF( tinP , T("[postWildListExcludeP]:    ")+T(postWildListExcludeP) ) ;
    tinP.pEther->traceF( tinP , T("[postWildListIncludeP]:    ")+T(postWildListIncludeP) ) ;
    tinP.pEther->traceF( tinP , T("[postWildListP       ]:    ")+T(postWildListP)        ) ;
    tinP.pEther->traceF( tinP , T("[postToP             ]:    ")+T(postToP)              ) ;

    _IO_

    }
        if( POOP ) return ;
//        __Z( pEtherContainsMe )
        __Z( postWildListP ) ;
        __Z( postToP       ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
voidT diskZipThirdF( tinS& tinP , thirdC& thirdP , const osTextT* const postToP , const osTextT* const postWildListP , const osTextT* const postWildListIncludeP , const osTextT* const postWildListExcludeP , const osTextT* const postSpecsPKZipP , const osTextT* const postSpecsInfoZipP , const countT idZipperP = 0 )

#define ifcIDzIPPER_INFOZIP  2
#define ifcIDzIPPER_PKZIPC   1



#endif

  set up dut
    commandsAndOptionsInfoZip  (omitting implied commands and options)
    commandsAndOptionsPKZip    (omitting implied commands and options)
    listOfFilesWildExclude
    listOfFilesWildInclude
    listOfFilesWild
    zipfile
   parameters needed
  think
   pkzipc : PKZIPC [command] [options]                               zipfile [@list] [files...]
   infozip: zip    [-options] [-b path] [-t mmddyyyy] [-n suffixes] [zipfile list]              [-xi list]
   set up dut: scr f
  play

#if defined( NEVERdEFINED )




/*1*/WAKEsHOWtEXT( "doodle.diskZipF" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
