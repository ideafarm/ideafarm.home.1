
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

THREADmODE2rESTORE
THREADmODE3rESTORE
THREADmODE4rESTORE

}
    }
        etThread.traceF( tinP , T("[idPass,*pc1,*pc2,flagsRC1,flagsRC2]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(*pc1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(*pc2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(flagsRC1,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(flagsRC2,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

        *pc1 += 0x11110000 ;
        countT*  pc2 = vsp2Lath ;
        flagsT flagsRC2 = tinP.brcRaw ;
        countVSP vsp2Lath = listC::countIF( tinP , myRecord , count2S( LISTnAME_RETURNiNFO2 ) ) ;

        *pc1 += 0x00001111 ;
        countT*  pc1 = vsp1Lath ;
        flagsT flagsRC1 = tinP.brcRaw ;
        countVSP vsp1Lath = listC::countIF( tinP , myRecord , count2S( LISTnAME_RETURNiNFO1 ) ) ;
    {

    recordC myRecord( tinP , pcNameRecord ) ;
    countT  pcNameRecord[] = { LISTnAME_ROOT , LISTnAME_ROOTaPPLICATION , LISTnAME_GLOBALrECORD , LISTnAME_PROCESSoUTCOME , 0 } ;

    tinP.pcUtility[ 0 ] -- ;
    puseC   puseHT( tinP , ifcIDpOOL_HOMEtEMP ) ;
    tinP.pcUtility[ 0 ] ++ ;

    _IO_
{
for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )

THREADmODE4oN( flTHREADmODE4_ALLOWwRITEABLEpOINTERgET )
THREADmODE3oN( flTHREADmODE3_UNLOCKpOOLiDENTITY       )
THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING   )

etThread.traceF( tinP , T("[idCellLath]:  ")+TF2(home.idCellLath,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
homeS& home = homeS::homeIF() ;
TN( tb4 , "    " ) ;

TODO

/*1*/WAKEsHOWtEXT( "doodle.listC.field.creation.return.codes" )/*1*/
/**/
*/
 communication is duplex and coherent and can involve complexity ranging from communicating a single volatile countT value to communicating and cooperatively modifying an entire database
 i demonstrate how a built in poolC instance that is visible to all adams of a home can be used to communicate a countT value between processes
 the listC class provides database functionality that uses a poolC instance
 heaps provided by poolC use shared memory that can optionally be backed by memory mapped disk files
 there is also a heapC class that provides a simpler, less powerful heap functionality
 in IPDOS (tm), heap functionality is provided mainly by poolC
i demonstrate a simple and powerful mechanism for ipc (interprocess communication)
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

