
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

countT cBacklog = myCircle ;

myCircle >> &foo1 ; etThread.traceF( tin0P , T("pulled wo") ) ;
myCircle >> &foo2 ; etThread.traceF( tin0P , T("pulled wo") ) ;
myCircle >> &foo3 ; etThread.traceF( tin0P , T("pulled wo") ) ;
myCircle >> &foo4 ; etThread.traceF( tin0P , T("pulled wo") ) ;
myCircle >> &foo5 ; etThread.traceF( tin0P , T("pulled wo") ) ;
myCircle >> &foo6 ; etThread.traceF( tin0P , T("pulled wo") ) ;
myCircle >> &foo7 ; etThread.traceF( tin0P , T("pulled wo") ) ;
myCircle >> &foo8 ; etThread.traceF( tin0P , T("pulled wo") ) ;

etThread.osThreadF( TaRG1( tmPushF ) , (countT)&myCircle ) ;

circleC myCircle( tin0P , etThread , (const boolT&)(const countT&)ether , sizeof foo1 , 8 ) ;

TODO

DONE( tmPushF )
}

    ++ s ; etThread.osSleepF( tin0P , TOCK ) ; myCircleP << &foo8 ;
    ++ s ; etThread.osSleepF( tin0P , TOCK ) ; myCircleP << &foo7 ;
    ++ s ; etThread.osSleepF( tin0P , TOCK ) ; myCircleP << &foo6 ;
    ++ s ; etThread.osSleepF( tin0P , TOCK ) ; myCircleP << &foo5 ;
    ++ s ; etThread.osSleepF( tin0P , TOCK ) ; myCircleP << &foo4 ;
    ++ s ; etThread.osSleepF( tin0P , TOCK ) ; myCircleP << &foo3 ;
    ++ s ; etThread.osSleepF( tin0P , TOCK ) ; myCircleP << &foo2 ;
    ++ s ; etThread.osSleepF( tin0P , TOCK ) ; myCircleP << &foo1 ;

    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    circleC& myCircleP = *(circleC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 )
TASK( tmPushF )

fooC foo8 ;
fooC foo7 ;
fooC foo6 ;
fooC foo5 ;
fooC foo4 ;
fooC foo3 ;
fooC foo2 ;
fooC foo1 ;

countT fooC::idMeLath ;

;
}
    }
            pcFoo[ offo ] = idMe ;
        for( countT offo = 0 ; offo < sizeof pcFoo / sizeof pcFoo[ 0 ] ; offo ++ )
        countT idMe = 1 + incv02AM( idMeLath ) ;
    {
    inline fooC( voidT )

    public :

    countT pcFoo[ 4 ] ;

    static countT idMeLath ;
{
class fooC

;
}
    }
        bGrabToPull -- ;

        }
            thirdC::c_memcpyIF( (byteT*)pP , pbCircle + offbi , cbElement ) ;
            countT offbi      = ( cOutBefore % cElements ) * cbElement ;
            countT cOutBefore = incv02AM( cOut ) ;
        {
        if( !bQuit )

        }
            ++ s ; thirdC::dosSleepWinkIF( tin0P , 0 ) ;

            if( cBacklog ) break ;
            countT cBacklog = *this ;
        {
        while( !bQuit )

        while( setIfZeAM( bGrabToPull , 1 ) ) { ++ s ; thirdC::dosSleepWinkIF( tin0P , 0 ) ; }
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        TINSL
    {
    inline voidT operator >>( voidT* pP )

    }
        bGrabToPush -- ;

        }
            thirdC::c_memcpyIF( pbCircle + offbo , (const byteT*)pP , cbElement ) ;
            countT offbo     = ( cInBefore % cElements ) * cbElement ;
            countT cInBefore = incv02AM( cIn ) ;
        {
        if( !bQuit )

        }
            ++ s ; thirdC::dosSleepWinkIF( tin0P , 0 ) ;

            if( cBacklog < cElements ) break ;
            countT cBacklog = *this ;
        {
        while( !bQuit )

        while( setIfZeAM( bGrabToPush , 1 ) ) { ++ s ; thirdC::dosSleepWinkIF( tin0P , 0 ) ; }
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        TINSL
    {
    inline voidT operator <<( voidT* pP )

    inline operator countT( voidT ) const { return cIn - cOut ; }

    }
        ether.newF( tin0P , LF , pbCircle , cbCircle ) ; ___( pbCircle ) ;
    {
    bGrabToPull( 0 )
    bGrabToPush( 0 ) ,
    cOut( 0 ) ,
    cIn( 0 ) ,
    pbCircle( 0 ) ,
    cbCircle( cbElementP * cElementsP ) ,
    cElements( cElementsP ) ,
    cbElement( cbElementP ) ,
    bQuit( bQuitP ) ,
    ether( etherP ) ,
    inline circleC( tin0S& tin0P , etherC& etherP , const boolT& bQuitP , const countT cbElementP , const countT cElementsP ) :

    }
        ether.delF( tin0P , pbCircle ) ;
        TINSL
    {
    inline ~circleC( voidT )

    public :

    countT       bGrabToPull ;
    countT       bGrabToPush ;
    countT       cOut        ;
    countT       cIn         ;

    byteT*       pbCircle    ;
    const countT cbCircle    ;
    const countT cElements   ;
    const countT cbElement   ;
    const boolT& bQuit       ;
    etherC&      ether       ;
{
class circleC

/*1*/WAKEhIDE( "doodle.circleC" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
