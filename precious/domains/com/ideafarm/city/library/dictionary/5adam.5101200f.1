
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    ++ s ; ether.osSleepF( tin0P , TOCK ) ;

    pcap_freealldevs( pInfo ) ; pInfo = 0 ;

    }
        pcDevice = pcDevice->next ;

        }
            }
                pcap_free_datalinks( pInfo2 ) ;

                }
                    }
                        }
                            }
                                }
                                    if( tData.csF( tin0P ) ) etThread.traceF( tin0P , T("[idPacket,source,dest,protocol,data]:    ")+TF3(++idPacket,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tIndent1+tb4+tSource+tb4+tDestination+tIndent2+tb4+tProtocol+tb4+tData , flTRACE_NOpREFIX ) ;

                                    ;
                                            : tn
                                            ? tb42
                                        : bToMe
                                        ? tb84
                                    TN( tIndent2 , "" ) ; tIndent2 = bFromMe

                                    ;
                                            : tb84
                                            ? tb42
                                        : bToMe
                                        ? tn
                                    TN( tIndent1 , "" ) ; tIndent1 = idLinkType == osIDlINKtYPE_NULL || bFromMe

                                    boolT bToMe   = nnMeOnWanted == nnDest   ;
                                    boolT bFromMe = nnMeOnWanted == nnSource ;

                                    TN( tProtocol    , ppostProtocol[ protocol ] ) ;
                                    TN( tDestination , ""                        ) ; tDestination = T(nnDest  ) ; while( tDestination.csF( tin0P ) < 0x18 ) tDestination += tb ;
                                    TN( tSource      , ""                        ) ; tSource      = T(nnSource) ; while( tSource     .csF( tin0P ) < 0x18 ) tSource      += tb ;

                                    }
                                        }
                                            etThread.delF( tin0P , psttData ) ;
                                            tData = T(psttData) ;

                                            }
                                                pbd ++ ;
                                                }
                                                    etThread.strFuseF( tin0P , psttData , T(post2) ) ;
                                                    osTextT post2[] = { *pbd , 0 } ;
                                                {
                                                if( *pbd >= 0x20 && *pbd < 0x7e )
                                            {
                                            while( psttData[ 2 ].idAdam && pbd < pbDataEnd )
                                            const byteT* pbd = pbData ;

                                            etThread.strMakeF( tin0P , LF , psttData , 0 , cbData > TUCK ? TUCK : cbData ) ; ___( psttData ) ;
                                            ZE( strokeS* , psttData ) ;

                                            countT cbData = pbDataEnd - pbData ;
                                            const byteT* pbData    = (byteT*)( (countT*)pTcp + tcp.u.swabbed.hCounts ) ;

                                            tcp.swabF() ;
                                            tcpHeadRawS tcp = *pTcp ;
                                            tcpHeadRawS* pTcp = (tcpHeadRawS*)( (byteT*)pIpv6HeadRaw + sizeof head ) ;
                                        {
                                        if( protocol == 6 /*TCP*/ )

                                        const byteT* pbDataEnd = (byteT*)pIpv6HeadRaw + sizeof head + head.u.swabbed.cbGramNet ;

                                        protocol = head.u.swabbed.idNextHeader ;
                                        nnDest   = nicNameC( head.u.swabbed.pcDestination[ 0 ] , head.u.swabbed.pcDestination[ 1 ] , head.u.swabbed.pcDestination[ 2 ] , head.u.swabbed.pcDestination[ 3 ] ) ;
                                        nnSource = nicNameC( head.u.swabbed.pcSource[      0 ] , head.u.swabbed.pcSource[      1 ] , head.u.swabbed.pcSource[      2 ] , head.u.swabbed.pcSource[      3 ] ) ;

                                        head.swabF() ;
                                        ipv6HeadRawS head = *pIpv6HeadRaw ;
                                    {
                                    else if( pIpv6HeadRaw )
                                    }
                                        }
                                            etThread.delF( tin0P , psttData ) ;
                                            tData = T(psttData) ;

                                            }
                                                pbd ++ ;
                                                }
                                                    etThread.strFuseF( tin0P , psttData , T(post2) ) ;
                                                    osTextT post2[] = { *pbd , 0 } ;
                                                {
                                                if( *pbd >= 0x20 && *pbd < 0x7e )
                                            {
                                            while( psttData[ 2 ].idAdam && pbd < pbDataEnd )
                                            const byteT* pbd = pbData ;

                                            etThread.strMakeF( tin0P , LF , psttData , 0 , TUCK ) ; ___( psttData ) ;
                                            ZE( strokeS* , psttData ) ;

                                            const byteT* const pbDataEnd =            (byteT*)pIpv4HeadRaw + head.u.swabbed.cbGramNet    ;

                                            countT cbData = pbDataEnd - pbData ;
                                            const byteT* pbData    = (byteT*)( (countT*)pTcp + tcp.u.swabbed.hCounts ) ;

                                            tcp.swabF() ;
                                            tcpHeadRawS tcp = *pTcp ;
                                            tcpHeadRawS* pTcp = (tcpHeadRawS*)( (countT*)pIpv4HeadRaw + head.u.swabbed.hCounts ) ;
                                        {
                                        if( protocol == 6 /*TCP*/ )

                                        const byteT* pbDataEnd = (byteT*)pIpv4HeadRaw + head.u.swabbed.hCounts * sizeof( countT ) + head.u.swabbed.cbGramNet ;

                                        protocol = head.u.swabbed.protocol ;
                                        nnDest   = nicNameC( head.u.swabbed.ipv4Destination ) ;
                                        nnSource = nicNameC( head.u.swabbed.ipv4Source      ) ;

                                        head.swabF() ;
                                        ipv4HeadRawS head = *pIpv4HeadRaw ;
                                    {
                                    if( pIpv4HeadRaw )
                                    ZE( countT , protocol ) ;
                                    nicNameC nnDest   ;
                                    nicNameC nnSource ;
                                    TN( tData , "" ) ;

                                    }
                                        if( idType == 0x800 ) pIpv4HeadRaw   = (const ipv4HeadRawS*)pbc ;

                                        count01T     idType           = *(count01T*)pbc ; pbc += 2 ; idType = SWAB2( idType ) ;
                                        const byteT* pbMACSource      =             pbc ; pbc += 6 ;
                                        const byteT* pbMACDestination =             pbc ; pbc += 6 ;
                                    {
                                    else if( idLinkType == osIDlINKtYPE_ETHERNET )
                                    }
                                        }
                                            case 0x1e : { pIpv6HeadRaw = (ipv6HeadRawS*)( pbc + sizeof( loopHeadS ) /*- 2*/ ) ; break ; }         //U::"- 2" TO MAKE IT WORK (MYSTERY)
                                            case 0x1c :
                                            case 0x18 :

                                            case 0x2 : { pIpv4HeadRaw = (ipv4HeadRawS*)( pbc + sizeof( loopHeadS ) ) ; break ; }
                                        {
                                        switch( pLoopHead->protocol )

                                        const loopHeadS* pLoopHead = (const loopHeadS*)pbc ;
                                    {
                                    if( idLinkType == osIDlINKtYPE_NULL )
                                    ZE( const ipv6HeadRawS* , pIpv6HeadRaw ) ;
                                    ZE( const ipv4HeadRawS* , pIpv4HeadRaw ) ;

                                    pbc = (byteT*)pInfo3Data ;
                                    byteT* pbc ;
                                {
                                if( rc == 1 )

                                rc = pcap_next_ex( pHandle , &pInfo3Header , &pInfo3Data ) ;
                                pInfo3Data = 0 ;
                                ZE( const u_char* , pInfo3Data   ) ;
                                pInfo3Header = 0 ;
                                ZE( pcap_pkthdr*  , pInfo3Header ) ;
                            {
                            while( !ether )
                            etThread.traceF( tin0P , T("receiving header/data images") ) ;
                        {
                        if( !rc )

                        rc = pcap_set_datalink( pHandle , idLinkType ) ;
                    {
                    if( idLinkType != - 1 )

                    }
                        }
                            break ;
                            idLinkType = idMaybe ;
                        {
                        if( idMaybe == osIDlINKtYPE_NULL /*LOOPBACK*/ || idMaybe == osIDlINKtYPE_ETHERNET )
                        etThread.traceF( tin0P , T("link layer header type:    ")+TF2(idMaybe,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        countT idMaybe = pInfo2[ offa ] ;
                    {
                    for( countT offa = 0 ; offa < rc ; offa ++ )
                    countT idLinkType = - 1 ;
                {
                if( rc )

                rc = pcap_list_datalinks( pHandle , &pInfo2 ) ;
                ZE( int* , pInfo2 ) ;
            {
            if( !rc )
            rc = pcap_activate( pHandle ) ;

            etThread.traceF( tin0P , T(pHandle?"aok":"nope") ) ;
            pcap_t* pHandle = pcap_create( pcDevice->name , postError ) ;
            etThread.traceF( tin0P , T("-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------") ) ;
        {
        if( etThread.strIdF( tin0P , tWantCurly , tName ) || !etThread.strCompareF( tin0P , tName , tWantExactName ) )
        etThread.traceF( tin0P , T("description    :    ")+T(pcDevice->description) ) ;
        etThread.traceF( tin0P , T("wantName       :    ")+tWantExactName ) ;
        etThread.traceF( tin0P , T("name           :    ")+tName ) ;
        etThread.traceF( tin0P , T("idDevice       :    ")+TF2(++idDevice,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        TN( tName , pcDevice->name ) ;
    {
    while( pcDevice )
    ZE( countT , idDevice ) ;
    pcDevice = pInfo ;
    pcap_if_t* pcDevice ;

    int rc = pcap_findalldevs( &pInfo , postError ) ;
    pcap_if_t* pInfo ;

    //thirdC::c_systemIF( tin0P , "cls" ) ;
{
while( !ether )
sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
ZE( countT , idPacket ) ;

char postError[ PCAP_ERRBUF_SIZE ] ;

#define osIDlINKtYPE_ETHERNET 1
#define osIDlINKtYPE_NULL     0

}
    pc1 = pc1->Next ;

    }
        pc2 = pc2->Next ;

        }
            etThread.traceF( tin0P , T("    [nnMe]        :    ")+T(nnMe)+(bWanted?tb4+T("wanted"):tn) ) ;

            if( bWanted && !nnMeOnWanted )  nnMeOnWanted = nnMe ;       //ONLY SUPPORTS A SINGLE ADDRESS ON THE WANTED ADAPTER

            nicNameC nnMe( nnv ) ;
            countT nnv = SWAB4( *(countT*)pbv ) ;
            byteT* pbv = (byteT*)pc2->Address.lpSockaddr->sa_data + 2 ;        //U:: THE "+ 2" IS NEEDED TO GET TO THE IPV4 VALUE, BUT I DO NOT KNOW WHY (CONJ: THE DEF OF THE STRUCTURE HAS CHANGED AND I AM USING AN OBSOLETE VERSION)
        {
        if( pc2->Address.lpSockaddr->sa_family == AF_INET )
    {
    while( pc2 )
    IP_ADAPTER_UNICAST_ADDRESS_LH* pc2 = pc1->FirstUnicastAddress ;

    if( cunt <= TUCK && !unicodeToAnsiF( postt , sizeof postt , (byteT*)punt , cunt ) ) etThread.traceF( tin0P , tSayDescription+T(postt) ) ;
    cunt = unicodeLengthF( punt ) ;
    punt = (unTextT*)pc1->Description ;

    etThread.traceF( tin0P , tSayName+T(pc1->AdapterName) ) ;

    }
        }
            tWantCurly = tCurly ;
            bWanted = 1 ;
        {
        if( !etThread.strCompareF( tin0P , tWantFriendly , T(postt) ) )
        etThread.traceF( tin0P , tSayFriendlyName+tFriendly ) ;
        TN( tFriendly , postt ) ;
    {
    if( cunt < sizeof postt && !unicodeToAnsiF( postt , sizeof postt , (byteT*)punt , cunt ) )
    ZE( boolT , bWanted ) ;
    countT   cunt = unicodeLengthF( punt ) ;
    unTextT* punt = (unTextT*)pc1->FriendlyName ;

    osTextT postt[ TUCK << 1 + 1 ] ;

    TN( tCurly , pc1->AdapterName ) ;
{
while( pc1 )
IP_ADAPTER_ADDRESSES* pc1 = pInfo ;
nicNameC nnMeOnWanted ;

ULONG cAddresses = GetAdaptersAddresses( AF_INET , 0 , 0 ,  pInfo , &cba ) ;
unsigned long cba = sizeof pInfo ; 
IP_ADAPTER_ADDRESSES pInfo[ 0x10 ] ;

etThread.traceF( tin0P , T(postv) ) ;
const osTextT* postv = pcap_lib_version() ;

  TN( tSayDescription  , "    [description] :    "     ) ;
  TN( tSayName         , "    [name]        :    "     ) ;
  TN( tSayFriendlyName , "[friendlyName]:    "         ) ;
  TN( tWantCurly       , ""                            ) ;

//TN( tWantFriendly    , "outer"                       ) ;
  TN( tWantFriendly    , "Loopback Pseudo-Interface 1" ) ;

//TN( tWantExactName   , ""                            ) ;
  TN( tWantExactName   , "\\Device\\NPF_Loopback"      ) ;

TN( tb84 , "                                                                        " ) ;
TN( tb42 , "                                    " ) ;
TN( tb4 , "    " ) ;
TN( tb  , " "    ) ;
TN( tn  , ""    ) ;

//if( cProtocol != TUCK ) { BLAMMOiD( 0xff00ff00 ) ; }
etThread.traceF( tin0P , T("[cProtocol]:    ")+TF2(cProtocol,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
const countT cProtocol = sizeof ppostProtocol / sizeof ppostProtocol[ 0 ] ;

etThread.osThreadF( TaRG2cBsTACK( tmAcceptF , CBsTACKmIN << 1 ) ) ;

TODO

DONE( tmAcceptF )
}
    }
        //++ s ; ether.osSleepF( tin0P , TOCK ) ;
        thThread.s_writeF( tin0P , handleJob , tSay , tSay.csF( tin0P ) ) ;
    {
    while( !ether )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    TN( tSay , "\r\nhow now brown cow!" ) ;

    etThread.traceF( tin0P , T("[nnPeerClient,protocol]:    ")+T(nnPeer)+tb4+T(nnPeer.isIPv4F()?"4   ":"   6") ) ;
    thThread.s_acceptF( tin0P , handleJob , idPortPeer , nnPeer , handleServer , countTC() ) ;
    ZE( countT , idPortPeer ) ;
    nicNameC nnPeer ;
    handleC handleJob( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_SOCKET ) ;

    etThread.osThreadF( TaRG2cBsTACK( tmClientF , CBsTACKmIN << 1 ) ) ;

    thThread.s_listenF( tin0P , handleServer ) ;
    idPort = thThread.s_bindF( tin0P , handleServer ) ;
    thThread.s_socketIF( tin0P , handleServer ) ;
    handleC handleServer( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_SOCKET ) ;

    TN( tb4 , "    " ) ;

    thirdC& thThread = etThread ;
{
if( pTaskP )
TASK( tmAcceptF )

DONE( tmClientF )
}
    }
        //etThread.traceF( tin0P , T("received: ")+T(postIn) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

        countT cbIn = thThread.s_readF( tin0P , postIn , sizeof postIn , handleClient , flSOCKETcrEAD_JUSToNEmOUTHFUL | flSOCKETcrEAD_STILLhUNGRYiSoK , 0 , 0 , ifcIDmODEsOCKETS_NOTeNCRYPTED ) ;
    {
    while( !ether )

    osTextT postIn[ TUCK ] ;

    thThread.s_connectF( tin0P , handleClient , idPort , nnServer ) ;
    thThread.s_socketIF( tin0P , handleClient ) ;
    handleC handleClient( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_SOCKET ) ;

    nicNameC nnServer = socketC::nicNameIF( tin0P , etThread , T("::1") ) ;

    Sleep( 4000 ) ;

    thirdC& thThread = etThread ;
{
if( pTaskP )
TASK( tmClientF )

countT idPort ;


;
}
    "Reserved"                              ,       //    255
    "Use for experimentation and testing"   ,       //    254
    "Use for experimentation and testing"   ,       //    253
    "Unassigned"                            ,       //    252
    "Unassigned"                            ,       //    251
    "Unassigned"                            ,       //    250
    "Unassigned"                            ,       //    249
    "Unassigned"                            ,       //    248
    "Unassigned"                            ,       //    247
    "Unassigned"                            ,       //    246
    "Unassigned"                            ,       //    245
    "Unassigned"                            ,       //    244
    "Unassigned"                            ,       //    243
    "Unassigned"                            ,       //    242
    "Unassigned"                            ,       //    241
    "Unassigned"                            ,       //    240
    "Unassigned"                            ,       //    239
    "Unassigned"                            ,       //    238
    "Unassigned"                            ,       //    237
    "Unassigned"                            ,       //    236
    "Unassigned"                            ,       //    235
    "Unassigned"                            ,       //    234
    "Unassigned"                            ,       //    233
    "Unassigned"                            ,       //    232
    "Unassigned"                            ,       //    231
    "Unassigned"                            ,       //    230
    "Unassigned"                            ,       //    229
    "Unassigned"                            ,       //    228
    "Unassigned"                            ,       //    227
    "Unassigned"                            ,       //    226
    "Unassigned"                            ,       //    225
    "Unassigned"                            ,       //    224
    "Unassigned"                            ,       //    223
    "Unassigned"                            ,       //    222
    "Unassigned"                            ,       //    221
    "Unassigned"                            ,       //    220
    "Unassigned"                            ,       //    219
    "Unassigned"                            ,       //    218
    "Unassigned"                            ,       //    217
    "Unassigned"                            ,       //    216
    "Unassigned"                            ,       //    215
    "Unassigned"                            ,       //    214
    "Unassigned"                            ,       //    213
    "Unassigned"                            ,       //    212
    "Unassigned"                            ,       //    211
    "Unassigned"                            ,       //    210
    "Unassigned"                            ,       //    209
    "Unassigned"                            ,       //    208
    "Unassigned"                            ,       //    207
    "Unassigned"                            ,       //    206
    "Unassigned"                            ,       //    205
    "Unassigned"                            ,       //    204
    "Unassigned"                            ,       //    203
    "Unassigned"                            ,       //    202
    "Unassigned"                            ,       //    201
    "Unassigned"                            ,       //    200
    "Unassigned"                            ,       //    199
    "Unassigned"                            ,       //    198
    "Unassigned"                            ,       //    197
    "Unassigned"                            ,       //    196
    "Unassigned"                            ,       //    195
    "Unassigned"                            ,       //    194
    "Unassigned"                            ,       //    193
    "Unassigned"                            ,       //    192
    "Unassigned"                            ,       //    191
    "Unassigned"                            ,       //    190
    "Unassigned"                            ,       //    189
    "Unassigned"                            ,       //    188
    "Unassigned"                            ,       //    187
    "Unassigned"                            ,       //    186
    "Unassigned"                            ,       //    185
    "Unassigned"                            ,       //    184
    "Unassigned"                            ,       //    183
    "Unassigned"                            ,       //    182
    "Unassigned"                            ,       //    181
    "Unassigned"                            ,       //    180
    "Unassigned"                            ,       //    179
    "Unassigned"                            ,       //    178
    "Unassigned"                            ,       //    177
    "Unassigned"                            ,       //    176
    "Unassigned"                            ,       //    175
    "Unassigned"                            ,       //    174
    "Unassigned"                            ,       //    173
    "Unassigned"                            ,       //    172
    "Unassigned"                            ,       //    171
    "Unassigned"                            ,       //    170
    "Unassigned"                            ,       //    169
    "Unassigned"                            ,       //    168
    "Unassigned"                            ,       //    167
    "Unassigned"                            ,       //    166
    "Unassigned"                            ,       //    165
    "Unassigned"                            ,       //    164
    "Unassigned"                            ,       //    163
    "Unassigned"                            ,       //    162
    "Unassigned"                            ,       //    161
    "Unassigned"                            ,       //    160
    "Unassigned"                            ,       //    159
    "Unassigned"                            ,       //    158
    "Unassigned"                            ,       //    157
    "Unassigned"                            ,       //    156
    "Unassigned"                            ,       //    155
    "Unassigned"                            ,       //    154
    "Unassigned"                            ,       //    153
    "Unassigned"                            ,       //    152
    "Unassigned"                            ,       //    151
    "Unassigned"                            ,       //    150
    "Unassigned"                            ,       //    149
    "Unassigned"                            ,       //    148
    "BIT-EMU"                               ,       //    147
    "Homa"                                  ,       //    146
    "NSH"                                   ,       //    145
    "AGGFRAG"                               ,       //    144
    "Ethernet"                              ,       //    143
    "ROHC"                                  ,       //    142
    "WESP"                                  ,       //    141
    "Shim6"                                 ,       //    140
    "HIP"                                   ,       //    139
    "manet"                                 ,       //    138
    "MPLS-in-IP"                            ,       //    137
    "UDPLite"                               ,       //    136
    "Mobility Header"                       ,       //    135
    "RSVP-E2E-IGNORE"                       ,       //    134
    "FC"                                    ,       //    133
    "SCTP"                                  ,       //    132
    "PIPE"                                  ,       //    131
    "SPS"                                   ,       //    130
    "IPLT"                                  ,       //    129
    "SSCOPMCE"                              ,       //    128
    "CRUDP"                                 ,       //    127
    "CRTP"                                  ,       //    126
    "FIRE"                                  ,       //    125
    "ISIS over IPv4"                        ,       //    124
    "PTP"                                   ,       //    123
    "SM (deprecated)"                       ,       //    122
    "SMP"                                   ,       //    121
    "UTI"                                   ,       //    120
    "SRP"                                   ,       //    119
    "STP"                                   ,       //    118
    "IATP"                                  ,       //    117
    "DDX"                                   ,       //    116
    "L2TP"                                  ,       //    115
    "any 0-hop protocol"                    ,       //    114
    "PGM"                                   ,       //    113
    "VRRP"                                  ,       //    112
    "IPX-in-IP"                             ,       //    111
    "Compaq-Peer"                           ,       //    110
    "SNP"                                   ,       //    109
    "IPComp"                                ,       //    108
    "A/N"                                   ,       //    107
    "QNX"                                   ,       //    106
    "SCPS"                                  ,       //    105
    "ARIS"                                  ,       //    104
    "PIM"                                   ,       //    103
    "PNNI"                                  ,       //    102
    "IFMP"                                  ,       //    101
    "GMTP"                                  ,       //    100
    "any private encryption scheme"         ,       //     99
    "ENCAP"                                 ,       //     98
    "ETHERIP"                               ,       //     97
    "SCC-SP"                                ,       //     96
    "MICP (deprecated)"                     ,       //     95
    "IPIP"                                  ,       //     94
    "AX.25"                                 ,       //     93
    "MTP"                                   ,       //     92
    "LARP"                                  ,       //     91
    "Sprite-RPC"                            ,       //     90
    "OSPFIGP"                               ,       //     89
    "EIGRP"                                 ,       //     88
    "TCF"                                   ,       //     87
    "DGP"                                   ,       //     86
    "NSFNET-IGP"                            ,       //     85
    "IPTM"                                  ,       //     84
    "VINES"                                 ,       //     83
    "SECURE-VMTP"                           ,       //     82
    "VMTP"                                  ,       //     81
    "ISO-IP"                                ,       //     80
    "WB-EXPAK"                              ,       //     79
    "WB-MON"                                ,       //     78
    "SUN-ND"                                ,       //     77
    "BR-SAT-MON"                            ,       //     76
    "PVP"                                   ,       //     75
    "WSN"                                   ,       //     74
    "CPHB"                                  ,       //     73
    "CPNX"                                  ,       //     72
    "IPCV"                                  ,       //     71
    "VISA"                                  ,       //     70
    "SAT-MON"                               ,       //     69
    "any distributed file system"           ,       //     68
    "IPPC"                                  ,       //     67
    "RVD"                                   ,       //     66
    "KRYPTOLAN"                             ,       //     65
    "SAT-EXPAK"                             ,       //     64
    "any local network"                     ,       //     63
    "CFTP"                                  ,       //     62
    "any host internal protocol"            ,       //     61
    "IPv6-Opts"                             ,       //     60
    "IPv6-NoNxt"                            ,       //     59
    "IPv6-ICMP"                             ,       //     58
    "SKIP"                                  ,       //     57
    "TLSP"                                  ,       //     56
    "Min-IPv4"                              ,       //     55
    "NARP"                                  ,       //     54
    "SWIPE (deprecated)"                    ,       //     53
    "I-NLSP"                                ,       //     52
    "AH"                                    ,       //     51
    "ESP"                                   ,       //     50
    "BNA"                                   ,       //     49
    "DSR"                                   ,       //     48
    "GRE"                                   ,       //     47
    "RSVP"                                  ,       //     46
    "IDRP"                                  ,       //     45
    "IPv6-Frag"                             ,       //     44
    "IPv6-Route"                            ,       //     43
    "SDRP"                                  ,       //     42
    "IPv6"                                  ,       //     41
    "IL"                                    ,       //     40
    "TP++"                                  ,       //     39
    "IDPR-CMTP"                             ,       //     38
    "DDP"                                   ,       //     37
    "XTP"                                   ,       //     36
    "IDPR"                                  ,       //     35
    "3PC"                                   ,       //     34
    "DCCP"                                  ,       //     33
    "MERIT-INP"                             ,       //     32
    "MFE-NSP"                               ,       //     31
    "NETBLT"                                ,       //     30
    "ISO-TP4"                               ,       //     29
    "IRTP"                                  ,       //     28
    "RDP"                                   ,       //     27
    "LEAF-2"                                ,       //     26
    "LEAF-1"                                ,       //     25
    "TRUNK-2"                               ,       //     24
    "TRUNK-1"                               ,       //     23
    "XNS-IDP"                               ,       //     22
    "PRM"                                   ,       //     21
    "HMP"                                   ,       //     20
    "DCN-MEAS"                              ,       //     19
    "MUX"                                   ,       //     18
    "UDP"                                   ,       //     17
    "CHAOS"                                 ,       //     16
    "XNET"                                  ,       //     15
    "EMCON"                                 ,       //     14
    "ARGUS (deprecated)"                    ,       //     13
    "PUP"                                   ,       //     12
    "NVP-II"                                ,       //     11
    "BBN-RCC-MON"                           ,       //     10
    "IGP"                                   ,       //      9
    "EGP"                                   ,       //      8
    "CBT"                                   ,       //      7
    "TCP"                                   ,       //      6
    "ST"                                    ,       //      5
    "IPv4"                                  ,       //      4
    "GGP"                                   ,       //      3
    "IGMP"                                  ,       //      2
    "ICMP"                                  ,       //      1
    "HOPOPT"                                ,       //      0
{
osTextT* ppostProtocol[] =

//    
//    255,Reserved,,,[Internet_Assigned_Numbers_Authority]
//    254,,Use for experimentation and testing,Y,[RFC3692]
//    253,,Use for experimentation and testing,Y,[RFC3692]
//    148-252,,Unassigned,,[Internet_Assigned_Numbers_Authority]
//    147,BIT-EMU,Bit-stream Emulation,Y,[RFC9801]
//    146,Homa,Homa,N,[HomaModule][John_Ousterhout]
//    145,NSH,Network Service Header,N,[RFC9491]
//    144,AGGFRAG,AGGFRAG encapsulation payload for ESP,,[RFC9347]
//    143,Ethernet,Ethernet,,[RFC8986]
//    142,ROHC,Robust Header Compression,,[RFC5858]
//    141,WESP,Wrapped Encapsulating Security Payload,,[RFC5840]
//    140,Shim6,Shim6 Protocol,Y,[RFC5533]
//    139,HIP,Host Identity Protocol,Y,[RFC7401]
//    138,manet,MANET Protocols,,[RFC5498]
//    137,MPLS-in-IP,,,[RFC4023]
//    136,UDPLite,,,[RFC3828]
//    135,Mobility Header,,Y,[RFC6275]
//    134,RSVP-E2E-IGNORE,,,[RFC3175]
//    133,FC,Fibre Channel,,[Murali_Rajagopal][RFC6172]
//    132,SCTP,Stream Control Transmission Protocol,,[Randall_R_Stewart]
//    131,PIPE,Private IP Encapsulation within IP,,[Bernhard_Petri]
//    130,SPS,Secure Packet Shield,,[Bill_McIntosh]
//    129,IPLT,,,[[Hollbach]]
//    128,SSCOPMCE,,,[Kurt_Waber]
//    127,CRUDP,Combat Radio User Datagram,,[Robert_Sautter]
//    126,CRTP,Combat Radio Transport Protocol,,[Robert_Sautter]
//    125,FIRE,,,[Criag_Partridge]
//    124,ISIS over IPv4,,,[Tony_Przygienda]
//    123,PTP,Performance Transparency Protocol,,[Michael_Welzl]
//    122,SM (deprecated),Simple Multicast Protocol,,[Jon_Crowcroft][draft-perlman-simple-multicast-03]
//    121,SMP,Simple Message Protocol,,[Leif_Ekblad]
//    120,UTI,UTI,,[Peter_Lothberg]
//    119,SRP,SpectraLink Radio Protocol,,[Mark_Hamilton]
//    118,STP,Schedule Transfer Protocol,,[Jean_Michel_Pittet]
//    117,IATP,Interactive Agent Transfer Protocol,,[John_Murphy]
//    116,DDX,D-II Data Exchange (DDX),,[John_Worley]
//    115,L2TP,Layer Two Tunneling Protocol,,[RFC3931][Bernard_Aboba]
//    114,,any 0-hop protocol,,[Internet_Assigned_Numbers_Authority]
//    113,PGM,PGM Reliable Transport Protocol,,[Tony_Speakman]
//    112,VRRP,Virtual Router Redundancy Protocol,,[RFC9568]
//    111,IPX-in-IP,IPX in IP,,[CJ_Lee]
//    110,Compaq-Peer,Compaq Peer Protocol,,[Victor_Volpe]
//    109,SNP,Sitara Networks Protocol,,[Manickam_R_Sridhar]
//    108,IPComp,IP Payload Compression Protocol,,[RFC2393]
//    107,A/N,Active Networks,,[Bob_Braden]
//    106,QNX,QNX,,[Michael_Hunter]
//    105,SCPS,SCPS,,[Robert_Durst]
//    104,ARIS,ARIS,,[Nancy_Feldman]
//    103,PIM,Protocol Independent Multicast,,[RFC7761][Dino_Farinacci]
//    102,PNNI,PNNI over IP,,[Ross_Callon]
//    101,IFMP,Ipsilon Flow Management Protocol,,"[Bob_Hinden][November 1995, 1997.]"
//    100,GMTP,GMTP,,[[RXB5]]
//    99,,any private encryption scheme,,[Internet_Assigned_Numbers_Authority]
//    98,ENCAP,Encapsulation Header,,[RFC1241][Robert_Woodburn]
//    97,ETHERIP,Ethernet-within-IP Encapsulation,,[RFC3378]
//    96,SCC-SP,Semaphore Communications Sec. Pro.,,[Howard_Hart]
//    95,MICP (deprecated),Mobile Internetworking Control Pro.,,[John_Ioannidis]
//    94,IPIP,IP-within-IP Encapsulation Protocol,,[John_Ioannidis]
//    93,AX.25,AX.25 Frames,,[Brian_Kantor]
//    92,MTP,Multicast Transport Protocol,,[Susie_Armstrong]
//    91,LARP,Locus Address Resolution Protocol,,[Brian Horn]
//    University of California at Berkeley, June 1986.][Bruce Willins]"
//    Technical Report, UCB/Computer Science Dept., 86/302,
//    90,Sprite-RPC,Sprite RPC Protocol,,"[Welch, B., ""The Sprite Remote Procedure Call System"",
//    89,OSPFIGP,OSPFIGP,,[RFC1583][RFC2328][RFC5340][John_Moy]
//    88,EIGRP,EIGRP,,[RFC7868]
//    87,TCF,TCF,,[Guillermo_A_Loyola]
//    November 16, 1987.][Mike_Little]"
//    Specification, Draft Version"", Contract no. CS901145,
//    86,DGP,Dissimilar Gateway Protocol,,"[M/A-COM Government Systems, ""Dissimilar Gateway Protocol
//    85,NSFNET-IGP,NSFNET-IGP,,[Hans_Werner_Braun]
//    84,IPTM,Internet Protocol Traffic Manager,,[Jim_Stevens][1]
//    83,VINES,VINES,,[Brian Horn]
//    82,SECURE-VMTP,SECURE-VMTP,,[Dave_Cheriton]
//    81,VMTP,VMTP,,[Dave_Cheriton]
//    80,ISO-IP,ISO Internet Protocol,,[Marshall_T_Rose]
//    79,WB-EXPAK,WIDEBAND EXPAK,,[Steven_Blumenthal]
//    78,WB-MON,WIDEBAND Monitoring,,[Steven_Blumenthal]
//    77,SUN-ND,SUN ND PROTOCOL-Temporary,,[William_Melohn]
//    76,BR-SAT-MON,Backroom SATNET Monitoring,,[Steven_Blumenthal]
//    75,PVP,Packet Video Protocol,,[Steve_Casner]
//    74,WSN,Wang Span Network,,[Victor Dafoulas]
//    73,CPHB,Computer Protocol Heart Beat,,[David Mittnacht]
//    72,CPNX,Computer Protocol Network Executive,,[David Mittnacht]
//    71,IPCV,Internet Packet Core Utility,,[Steven_Blumenthal]
//    70,VISA,VISA Protocol,,[Gene_Tsudik]
//    69,SAT-MON,SATNET Monitoring,,[Steven_Blumenthal]
//    68,,any distributed file system,,[Internet_Assigned_Numbers_Authority]
//    67,IPPC,Internet Pluribus Packet Core,,[Steven_Blumenthal]
//    66,RVD,MIT Remote Virtual Disk Protocol,,[Michael_Greenwald]
//    65,KRYPTOLAN,Kryptolan,,[Paul Liu]
//    64,SAT-EXPAK,SATNET and Backroom EXPAK,,[Steven_Blumenthal]
//    63,,any local network,,[Internet_Assigned_Numbers_Authority]
//    Newman, January 1982.][Harry_Forsdick]"
//    62,CFTP,CFTP,,"[Forsdick, H., ""CFTP"", Network Message, Bolt Beranek and
//    61,,any host internal protocol,,[Internet_Assigned_Numbers_Authority]
//    60,IPv6-Opts,Destination Options for IPv6,Y,[RFC8200]
//    59,IPv6-NoNxt,No Next Header for IPv6,,[RFC8200]
//    58,IPv6-ICMP,ICMP for IPv6,,[RFC8200]
//    57,SKIP,SKIP,,[Tom_Markson]
//    using Kryptonet key management",,[Christer_Oberg]
//    56,TLSP,"Transport Layer Security Protocol        
//    55,Min-IPv4,Minimal IPv4 Encapsulation,,[RFC2004][Charlie_Perkins]
//    54,NARP,NBMA Address Resolution Protocol,,[RFC1735]
//    53,SWIPE (deprecated),IP with Encryption,,[John_Ioannidis]
//    52,I-NLSP,Integrated Net Layer Security  TUBA,,[K_Robert_Glenn]
//    51,AH,Authentication Header,Y,[RFC4302]
//    50,ESP,Encap Security Payload,Y,[RFC4303]
//    49,BNA,BNA,,[Gary Salamon]
//    48,DSR,Dynamic Source Routing Protocol,,[RFC4728]
//    47,GRE,Generic Routing Encapsulation,,[RFC2784][Tony_Li]
//    46,RSVP,Reservation Protocol,,[RFC2205][RFC3209][Bob_Braden]
//    45,IDRP,Inter-Domain Routing Protocol,,[Sue_Hares]
//    44,IPv6-Frag,Fragment Header for IPv6,Y,[Steve_Deering]
//    43,IPv6-Route,Routing Header for IPv6,Y,[Steve_Deering]
//    42,SDRP,Source Demand Routing Protocol,,[Deborah_Estrin]
//    41,IPv6,IPv6 encapsulation,,[RFC2473]
//    40,IL,IL Transport Protocol,,[Dave_Presotto]
//    39,TP++,TP++ Transport Protocol,,[Dirk_Fromhein]
//    38,IDPR-CMTP,IDPR Control Message Transport Proto,,[Martha_Steenstrup]
//    37,DDP,Datagram Delivery Protocol,,[Wesley_Craig]
//    36,XTP,XTP,,[Greg_Chesson]
//    35,IDPR,Inter-Domain Policy Routing Protocol,,[Martha_Steenstrup]
//    34,3PC,Third Party Connect Protocol,,[Stuart_A_Friedberg]
//    33,DCCP,Datagram Congestion Control Protocol,,[RFC4340]
//    32,MERIT-INP,MERIT Internodal Protocol,,[Hans_Werner_Braun]
//    Livermore, California, June 1977.][Barry_Howard]"
//    Computer Network"", UCRL-52317, Lawrence Livermore Labs,
//    31,MFE-NSP,MFE Network Services Protocol,,"[Shuttleworth, B., ""A Documentary of MFENet, a National
//    30,NETBLT,Bulk Data Transfer Protocol,,[RFC969][David_Clark]
//    29,ISO-TP4,ISO Transport Protocol Class 4,,[RFC905][Robert_Cole]
//    28,IRTP,Internet Reliable Transaction,,[RFC938][Trudy_Miller]
//    27,RDP,Reliable Data Protocol,,[RFC908][Bob_Hinden]
//    26,LEAF-2,Leaf-2,,[Barry_Boehm]
//    25,LEAF-1,Leaf-1,,[Barry_Boehm]
//    24,TRUNK-2,Trunk-2,,[Barry_Boehm]
//    23,TRUNK-1,Trunk-1,,[Barry_Boehm]
//    Xerox Corporation, Stamford, CT., October 1980.][[XEROX]]"
//    Layer and Physical Layer Specification"", X3T51/80-50,
//    And: XEROX, ""The Ethernet, A Local Area Network: Data Link
//    Specifications"", Digital, Intel and Xerox, November 1982.
//    Area Network: Data Link Layer and Physical Layer
//    Corporation, September 1980.  And: ""The Ethernet, A Local
//    Equipment Corporation, Intel Corporation, Xerox
//    Ethernet - A Local Area Network"", Version 1.0, Digital
//    Equipment Corporation, Maynard, MA.  Also as: ""The
//    Physical Layer Specification"", AA-K759B-TK, Digital
//    22,XNS-IDP,XEROX NS IDP,,"[""The Ethernet, A Local Area Network: Data Link Layer and
//    21,PRM,Packet Radio Measurement,,[Zaw_Sing_Su]
//    20,HMP,Host Monitoring,,[RFC869][Bob_Hinden]
//    19,DCN-MEAS,DCN Measurement Subsystems,,[David_Mills]
//    USC/Information Sciences Institute, May 1979.][Jon_Postel]"
//    18,MUX,Multiplexing,,"[Cohen, D. and J. Postel, ""Multiplexing Protocol"", IEN 90,
//    17,UDP,User Datagram,,[RFC768][Jon_Postel]
//    16,CHAOS,Chaos,,[J_Noel_Chiappa]
//    IEN 158, October 1980.][Jack_Haverty]"
//    15,XNET,Cross Net Debugger,,"[Haverty, J., ""XNET Formats for Internet Protocol Version 4"",
//    14,EMCON,EMCON,,[Bich_Nguyen]
//    13,ARGUS (deprecated),ARGUS,,[Robert_W_Scheifler]
//    Communication, Volume COM-28, Number 4, April 1980.][[XEROX]]"
//    CSL-79-10, July 1979; also in IEEE Transactions on
//    Internetwork Architecture"", XEROX Palo Alto Research Center,
//    12,PUP,PUP,,"[Boggs, D., J. Shoch, E. Taft, and R. Metcalfe, ""PUP: An
//    11,NVP-II,Network Voice Protocol,,[RFC741][Steve_Casner]
//    10,BBN-RCC-MON,BBN RCC Monitoring,,[Steve_Chipman]
//    (used by Cisco for their IGRP)",,[Internet_Assigned_Numbers_Authority]
//    9,IGP,"any private interior gateway             
//    8,EGP,Exterior Gateway Protocol,,[RFC888][David_Mills]
//    7,CBT,CBT,,[Tony_Ballardie]
//    6,TCP,Transmission Control,,[RFC9293]
//    5,ST,Stream,,[RFC1190][RFC1819]
//    4,IPv4,IPv4 encapsulation,,[RFC2003]
//    3,GGP,Gateway-to-Gateway,,[RFC823]
//    2,IGMP,Internet Group Management,,[RFC1112]
//    1,ICMP,Internet Control Message,,[RFC792]
//    0,HOPOPT,IPv6 Hop-by-Hop Option,Y,[RFC8200]
//    
//    Decimal,Keyword,Protocol,IPv6 Extension Header,Reference
//    
//    https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
//    ASSIGNED INTERNET PROTOCOL NUMBERS
//    

;
}
    }
        }
                                                 u.bytes.pbRaw[ offMax - offs ] = save ;
                         u.bytes.pbRaw[ offs ] = u.bytes.pbRaw[ offMax - offs ]        ;
            byteT save = u.bytes.pbRaw[ offs ]                                         ;
        {
        for( countT offs = 0 ; offs < offStop ; offs ++ )
        countT offStop = 1 + offMax >> 1 ;                  //        1   1   2   2   3   3   4   4
        countT offMax  = sizeof u.bytes.pbRaw - 1 ;         //        0   1   2   3   4   5   6   7
    {                                                       // CASES
    inline voidT swabF( voidT )                             // FOR EVEN NUMBER OF BYTES, EFFICIENT ; FOR ODD NUMBER OF BYTES, SWITCHES THE MIDDLE BYTE WITH ITSELF

    } u ;

        swabbed ;
        }

            count01T    idpSource            ;
            count01T    idpDestination       ;

            countT      idSerial             ;

            countT      idAcknowlegement     ;

            byteT       hCounts          : 4 ;
            byteT       reserved         : 4 ;
            byteT       bFIN             : 1 ;
            byteT       bSYN             : 1 ;
            byteT       bRST             : 1 ;
            byteT       bPSH             : 1 ;
            byteT       bACK             : 1 ;
            byteT       bURG             : 1 ;
            byteT       bECE             : 1 ;
            byteT       bCWR             : 1 ;
            count01T    cbWindow             ;

            count01T    checksum             ;
            count01T    offUrgent            ;

        {
        struct

        raw ;
        }

            count01T    offUrgent            ;
            count01T    checksum             ;

            count01T    cbWindow             ;
            byteT       bFIN             : 1 ;
            byteT       bSYN             : 1 ;
            byteT       bRST             : 1 ;
            byteT       bPSH             : 1 ;
            byteT       bACK             : 1 ;
            byteT       bURG             : 1 ;
            byteT       bECE             : 1 ;
            byteT       bCWR             : 1 ;
            byteT       hCounts          : 4 ;
            byteT       reserved         : 4 ;

            countT      idAcknowlegement     ;

            countT      idSerial             ;

            count01T    idpDestination       ;
            count01T    idpSource            ;

        {
        struct

        bytes ;
        }
            byteT pbRaw[ 0x5 * sizeof( countT ) ] ;
        {
        struct
    {
    union
{
struct tcpHeadRawS

//  
//  
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     :                                                               |
//     :                             Data                              :
//     |                                                               :
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |                           [Options]                           |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |           Checksum            |         Urgent Pointer        |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |       |       |R|E|G|K|H|T|N|N|                               |
//     | Offset| Rsrvd |W|C|R|C|S|S|Y|I|            Window             |
//     |  Data |       |C|E|U|A|P|R|S|F|                               |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |                    Acknowledgment Number                      |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |                        Sequence Number                        |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//     |          Source Port          |       Destination Port        |
//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
//      0                   1                   2                   3
//  
//  Figure 1: TCP Header Format
//  
//  RFC 9293
//  

;
}
    }
        }
                                                 u.bytes.pbRaw[ offMax - offs ] = save ;
                         u.bytes.pbRaw[ offs ] = u.bytes.pbRaw[ offMax - offs ]        ;
            byteT save = u.bytes.pbRaw[ offs ]                                         ;
        {
        for( countT offs = 0 ; offs < offStop ; offs ++ )
        countT offStop = 1 + offMax >> 1 ;                  //        1   1   2   2   3   3   4   4
        countT offMax  = sizeof u.bytes.pbRaw - 1 ;         //        0   1   2   3   4   5   6   7
    {                                                       // CASES
    inline voidT swabF( voidT )                             // FOR EVEN NUMBER OF BYTES, EFFICIENT ; FOR ODD NUMBER OF BYTES, SWITCHES THE MIDDLE BYTE WITH ITSELF

    } u ;

        swabbed ;
        }

            countT      version      : 0x04 ;
            countT      pad1         : 0x04 ;
            countT      pad2         : 0x18 ;

            count01T    cbGramNet                ;
            byteT       idNextHeader          ;
            byteT       hopLimit              ;

            countT      pcSource[ 4 ]         ;

            countT      pcDestination[ 4 ]    ;

        {
        struct

        raw ;
        }

            countT      pcDestination[ 4 ]    ;

            countT      pcSource[ 4 ]         ;

            byteT       hopLimit              ;
            byteT       idNextHeader          ;
            count01T    cbGramNet                ;

            countT      pad2         : 0x18 ;
            countT      version      : 0x04 ;
            countT      pad1         : 0x04 ;

        {
        struct

        //counts ;
        //}
        //    countT pcRaw[ 0xa ] ;
        //{
        //struct
        
        bytes ;
        }
            byteT pbRaw[ 0xa * sizeof( countT ) ] ;
        {
        struct
        
        //nibs ;
        //}
        //    byteT  nibf : 4 ;
        //    byteT  nibe : 4 ;
        //    byteT  nibd : 4 ;
        //    byteT  nibc : 4 ;
        //    byteT  nibb : 4 ;
        //    byteT  niba : 4 ;
        //    byteT  nib9 : 4 ;
        //    byteT  nib8 : 4 ;
        //    byteT  nib7 : 4 ;
        //    byteT  nib6 : 4 ;
        //    byteT  nib5 : 4 ;
        //    byteT  nib4 : 4 ;
        //    byteT  nib3 : 4 ;
        //    byteT  nib2 : 4 ;
        //    byteT  nib1 : 4 ;
        //    byteT  nib0 : 4 ;
        //{
        //struct
    {
    union
{
struct ipv6HeadRawS

//    
//       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//       |                                                               |
//       +                                                               +
//       |                                                               |
//       +                      Destination Address                      +
//       |                                                               |
//       +                                                               +
//       |                                                               |
//       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//       |                                                               |
//       +                                                               +
//       |                                                               |
//       +                         Source Address                        +
//       |                                                               |
//       +                                                               +
//       |                                                               |
//       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//       |         Payload Length        |  Next Header  |   Hop Limit   |
//       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//       |Version| Traffic Class |           Flow Label                  |
//       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//    
//        RFC 8200
//    

;
}
    }
        }
                                                 u.bytes.pbRaw[ offMax - offs ] = save ;
                         u.bytes.pbRaw[ offs ] = u.bytes.pbRaw[ offMax - offs ]        ;
            byteT save = u.bytes.pbRaw[ offs ]                                         ;
        {
        for( countT offs = 0 ; offs < offStop ; offs ++ )
        countT offStop = 1 + offMax >> 1 ;                  //        1   1   2   2   3   3   4   4
        countT offMax  = sizeof u.bytes.pbRaw - 1 ;         //        0   1   2   3   4   5   6   7
    {                                                       // CASES
    inline voidT swabF( voidT )                             // FOR EVEN NUMBER OF BYTES, EFFICIENT ; FOR ODD NUMBER OF BYTES, SWITCHES THE MIDDLE BYTE WITH ITSELF

    } u ;

        swabbed ;
        }

            byteT       version : 4       ;
            byteT       hCounts : 4       ;
            byteT       service           ;
            count01T    cbGramNet            ;

            count01T    identification    ;
            count01T    pad1              ;

            byteT       ttl               ;
            byteT       protocol          ;
            count01T    hChecksum         ;

            countT      ipv4Source        ;

            countT      ipv4Destination   ;

        {
        struct

        raw ;
        }

            countT      ipv4Destination   ;

            countT      ipv4Source        ;

            count01T    hChecksum         ;
            byteT       protocol          ;
            byteT       ttl               ;

            count01T    pad1              ;
            count01T    identification    ;

            count01T    cbGramNet            ;
            byteT       service           ;
            byteT       version : 4       ;
            byteT       hCounts : 4       ;

        {
        struct

        bytes ;
        }
            byteT pbRaw[ 5 * sizeof( countT ) ] ;
        {
        struct
    {
    union
{
struct ipv4HeadRawS

//
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   |                    Options                    |    Padding    |
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   |                    Destination Address                        |
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   |                       Source Address                          |
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   |  Time to Live |    Protocol   |         Header Checksum       |
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   |         Identification        |Flags|      Fragment Offset    |
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//   |Version|  IHL  |Type of Service|          Total Length         |
//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
//    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
//    0                   1                   2                   3
//
//                    Example Internet Datagram Header
//
//    RFC 6274
//

;
}
    countT      protocol ;
{
struct loopHeadS

//      
//          23 - payload is an IPX packet.
//          7 - payload is an OSI packet;
//          30 - payload is an IPv6 packet;         0x1e
//          28 - payload is an IPv6 packet;         0x1c
//          24 - payload is an IPv6 packet;         0x18
//          2 - payload is an IPv4 packet;
//      
//      The protocol type field is in the host byte order of the machine on which the capture was done. The values for that field are:
//      
//      Description
//      
//      .                           .
//      .                           .
//      .                           .
//      |           Payload         |
//      +---------------------------+
//      |         (4 Octets)        |
//      |       Protocol type       |
//      +---------------------------+
//      
//      https://www.tcpdump.org/linktypes/LINKTYPE_NULL.html
//      

}
    return 0 ;

    *pbOutP = 0 ;
    }
        pbInP ++ ;
        *( pbOutP ++ ) = *( pbInP ++ ) ;
    {
    while( cInP -- )

    if( cbOutP <= cInP ) return 1 ;
{
boolT unicodeToAnsiF( byteT* pbOutP , const countT cbOutP , const byteT* pbInP , countT cInP )
//U::MOVE TO BASE (COPIED FROM 767)

}
    return cunt ;
    for( countT offi = 0 ; puntP[ offi ] ; offi ++ ) cunt ++ ;
    ZE( countT , cunt ) ;
{
countT unicodeLengthF( const unTextT* puntP )
//U::MOVE TO BASE (COPIED FROM 767)


#include <iphlpapi.h>

/*1*/WAKEhIDE( "was.copy.of.doodle.simple.npcap.packet.sniffer" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
