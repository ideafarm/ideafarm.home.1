
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK << 4 ) ;
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        while( !ether && ~hFind && !POOP ) ;
        }
            DEL( pInfo ) ;
            }
                }
                    etThread.traceF( tin0P , (!F(flagsFail)?T("aok"):T("flagsFail:")+TF2(flagsFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)) ) ;

                    }
                        }
                            flagsFail |= flFAIL_COULDnOTmOVEfILE ;
                            POOPR
                        {
                        if( POOP )
                        ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tWhere+tShort , tIfoName ) ;

                        SCOOPS
                    {
                    IFsCRATCH

                    ;
                            : tFolderDone
                            ? tFolderToRetry
                        : F(flagsFail)
                        ? tFolderAbandoned
                    TN( tWhere , "" ) ; tWhere = bFailPermanent

                    etThread.traceF( tin0P , T("moving the file") ) ;

                    etThread.traceF( tin0P , T("cleaning up 3") ) ;

                    }
                        etThread.traceF( tin0P , T("unknown error") ) ;
                        flagsFail |= flFAIL_UNKNOWNeRROR ;
                        POOPR
                    {
                    if( POOP )
                    etThread.traceF( tin0P , T("cleaning up 2") ) ;

                    }
                        etThread.delF( tin0P , psttValueLive            ) ;
                        etThread.delF( tin0P , psttValueAmountDiscount  ) ;
                        etThread.delF( tin0P , psttValueIdSubscription  ) ;
                        etThread.delF( tin0P , psttValueMode            ) ;
                        etThread.delF( tin0P , psttValueName            ) ;
                        etThread.delF( tin0P , psttValueEmail           ) ;
                        etThread.delF( tin0P , psttValuePostalCode      ) ;
                        etThread.delF( tin0P , psttValueCountry         ) ;
                        etThread.delF( tin0P , psttValueAge             ) ;
                        etThread.delF( tin0P , psttValueAmountTotal     ) ;
                        etThread.delF( tin0P , psttValueAmountSubtotal  ) ;
                        etThread.delF( tin0P , psttValueApiVersion      ) ;
                        etThread.delF( tin0P , psttValueNoticeType      ) ;
                        etThread.delF( tin0P , psttVersion              ) ;
                        etThread.delF( tin0P , psttType                 ) ;
                        }
                            etThread.boxPutF( tin0P , T("mail.smtp2go.com/dd9/smtp/factories@ideafarm.com/factoryreports@ideafarm.com/")+T(psttValueEmail)+T("") , tThankYou ) ;

                            }
                                ) ;

                                    "Be sure to use the same email address so that we can detect duplicate charges and reverse them.\r\n\r\n"
                                    "corrected, order.\r\n\r\n"
                                    "displays exactly ")/*+tValueMatrixUsername*/+T(" for your userid.  If not, you can submit a new,\r\n"
                                    "If you do not receive invite(s) within 15 minutes, verify that your [matrix] client\r\n"
                                    "the [matrix] system does not verify that the [matrix] username that you entered exists.\r\n"
                                    "This automated system did not detect any failure to create your invite(s).  However,\r\n"

                                tThankYou += T(
                            {
                            else
#endif
                            }
                                ) ;

                                    "Please verify that we have your correct email address, and contact us at admin@ideafarm.com if we do not.\r\n\r\n"
                                    "We will help you obtain a username and get you set up to use the [matrix] system.\r\n"
                                    "This automated system could not submit invitations because you did not provide a [matrix] username.\r\n"

                                tThankYou += T(
                            {
                            else if( !tValueMatrixUsername.csF( tin0P ) )
#if defined( NEVERdEFINED )
                            }
                                ) ;

                                    "Be sure to use the same email address so that we can detect duplicate charges and reverse them.\r\n\r\n"
                                    "If you entered your [matrix] username incorrectly, you can submit a new, corrected order.\r\n"
                                    "\r\nWe have been notified and will contact you via email during business hours.\r\n"

                                tThankYou += T(

                                }
                                    ) ;

                                        "    [classroom]:               ")+tValueError3+T("\r\n"

                                    tThankYou += T(
                                {
                                if( bFail3 )

                                }
                                    ) ;

                                        "    [courtship workshops]:     ")+tValueError2+T("\r\n"

                                    tThankYou += T(
                                {
                                if( bFail2 )

                                }
                                    ) ;

                                        "    [parlor]:                  ")+tValueError1+T("\r\n"

                                    tThankYou += T(
                                {
                                if( bFail1 )

                                ) ;

                                    "Your payment has been received but this automated system could not generate invite(s):\r\n\r\n"

                                tThankYou += T(
                            {
                            if( bFail1 || bFail2 || bFail3 )

                            ) ;
                                +tInvitationsSubmitted +T("\r\n"
                                "Invitations submitted to the [matrix] system:\r\n\r\n")
                                "    [age (parsed)]: ")+TF4(age,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n"
                                "    [age (raw)]:    ")+T(psttValueAge)+T("\r\n"
                                "    [email]:        ")+T(psttValueEmail)+T("\r\n"
                                +T("Payment received for:\r\n\r\n"
                                "Subject: Notification from IDEAFARM.COM\r\n\r\nThank you for ")+tForWhat

                            TN( tThankYou , "" ) ; tThankYou = T(

                            else           tForWhat = T("paying your entry fee for self-monitored chat.\r\n\r\n") ;
                            if( bStudent ) tForWhat = T("registering as a student on IDEAFARM.COM.\r\n\r\n") ;
                            TN( tForWhat , "" ) ;

                            }
                                }
                                    etThread.traceF( tin0P , T("socket is impotent") ) ;
                                    POOPRqUIET
                                {
                                if( POOP )
                            
                                etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+psttValueAccessToken+tb4+psttValueDeviceId ) ;
                                TN( tb4 , "    " ) ;
                            
                                }
                                    DEL( pSwPathValue ) ;
                            
                                    }
                                        }
                                            etThread.delF( tin0P , pstpsttValue ) ;
                            
                                            }
                                                }
                                                    etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pppsttValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    *pppsttValue[ offe ] = T(pstpsttValue) ;
                                                {
                                                if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                            {
                                            for( countT offe = 0 ; offe < cPaths ; offe ++ )
                            
                                            if( cPaths - cValues ) { BLAMMO ; }
                                            countT cValues = sizeof pppsttValue / sizeof pppsttValue[ 0 ] ;
                                            countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
                            
                                            etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(pstpsttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                            etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                            
                                            strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                            psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                            
                                            _IO_
                                        {
                                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                        countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                    {
                                    if( !POOP )
                            
                                    ;
                                    }
                                        &tPathDeviceId     ,
                                        &tPathAccessToken  ,
                                    {
                                    textC* pptPath[] =
                            
                                    TN( tPathDeviceId    , "\"device_id\"/"    ) ;
                                    TN( tPathAccessToken , "\"access_token\"/" ) ;
                            
                                    ;
                                    }
                                        &psttValueDeviceId      ,
                                        &psttValueAccessToken ,
                                    {
                                    textC* pppsttValue[] =
                            
                                    __Z( pSwPathValue ) ;
                                    etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                    ZE( switchC* , pSwPathValue ) ;
                                    ZE( strokeS* , psttPath     ) ;
                                {
                            
                                etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                etThread.traceF( tin0P , T("json response:") ) ;
                            
                                }
                                    }
                                        else if( costj ) break ;
                                             if( cNest ) costj ++ ;
                            
                                        else if( postj[ costj ] == '}' ) cNest -- ;
                                             if( postj[ costj ] == '{' ) cNest ++ ;
                            
                                        if( !cbIn ) break ;
                                        countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                    {
                                    for(;;)
                                    ZE( countT , cNest ) ;
                                {
                                ZE( countT , costj ) ;
                                osTextT postj[ TUCK << 1 ] ;
                            
                                sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                etThread.traceF( tin0P , T("request:") ) ;
                            
                                TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/logout HTTP/1.1")+T("\r\nAuthorization: Bearer ")+psttValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(0,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;
                            
                                //sockc.connectF( tin0P , 80 , nnServer ) ;
                                //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                            
                                sockc.connectF( tin0P , 443 , nnServer ) ;
                                socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                            
                                countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                countT timeAllowedConnected = TICK >> 2 ;
                            
                                nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                nicNameC nnServer ;
                            
                                SCOOPS
                            {
                            IFsCRATCH                                                           // LOGOUT

#endif
                            if( !tInvitationsSubmitted.csF( tin0P ) ) tInvitationsSubmitted = T("    none\r\n") ;

                            }            
                                }
                                    if( !bFail3 ) tInvitationsSubmitted += T("    Wo'O's Table (Classroom)\r\n") ;

                                    }
                                        bFail3 = 1 ;
                                        etThread.traceF( tin0P , T("socket is impotent") ) ;
                                        POOPRqUIET
                                    {
                                    if( POOP )
                                
                                    }
                                        if( !tValueErrorCode3.csF( tin0P ) ) bFail3 = 0 ;
                                        DEL( pSwPathValue ) ;
                                        }
                                            }
                                                etThread.delF( tin0P , pstpsttValue ) ;

                                                }
                                                    }
                                                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pppsttValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                        *pppsttValue[ offe ] = T(pstpsttValue) ;
                                                    {
                                                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                {
                                                for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                if( cPaths - cValues ) { BLAMMO ; }
                                                countT cValues = sizeof pppsttValue / sizeof pppsttValue[ 0 ] ;
                                                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                _IO_
                                            {
                                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                        {
                                        if( !POOP )

                                        //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                        ;
                                        }
                                            &tPathError     ,
                                            &tPathErrorCode ,
                                        {
                                        textC* pptPath[] =

                                        TN( tPathError     , "\"error\"/"   ) ;
                                        TN( tPathErrorCode , "\"errcode\"/" ) ;

                                        ;
                                        }
                                            &tValueError3     ,
                                            &tValueErrorCode3 ,
                                        {
                                        textC* pppsttValue[] =

                                        __Z( pSwPathValue ) ;
                                        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                        ZE( switchC* , pSwPathValue ) ;
                                        ZE( strokeS* , psttPath     ) ;
                                    {

                                    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                    etThread.traceF( tin0P , T("json response:") ) ;

                                    }
                                        }
                                            else if( costj ) break ;
                                                 if( cNest ) costj ++ ;
                                
                                            else if( postj[ costj ] == '}' ) cNest -- ;
                                                 if( postj[ costj ] == '{' ) cNest ++ ;
                                
                                            if( !cbIn ) break ;
                                            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                        {
                                        for(;;)
                                        ZE( countT , cNest ) ;
                                    {
                                    ZE( countT , costj ) ;
                                    osTextT postj[ TUCK << 1 ] ;
                                
                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                    etThread.traceF( tin0P , T("request:") ) ;

                                    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!asfLvjanrxfXkEVNHg:communick.com/invite HTTP/1.1")+T("\r\nAuthorization: Bearer ")+psttValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBodyInvite,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBodyInvite ;
                                
                                    sockc.connectF( tin0P , 443 , nnServer ) ;
                                    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                
                                    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                    countT timeAllowedConnected = TICK >> 2 ;
                                
                                    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                    nicNameC nnServer ;
                                
                                    SCOOPS
                                {
                                IFsCRATCH                                                           // INVITE TO ROOM: CLASSROOM
                            {
                            else if( !bFail0 )
                            if( age < 16 || !bStudent ) bFail3 = 0 ;
                            bStudent = !!etThread.strCompareF( tin0P , psttValueIdSubscription , T("null") ) ;
                            
                            }            
                                }
                                    if( !bFail2 ) tInvitationsSubmitted += T("    Bait N' Switch Courtship Workshops\r\n") ;

                                    }
                                        bFail2 = 1 ;
                                        etThread.traceF( tin0P , T("socket is impotent") ) ;
                                        POOPRqUIET
                                    {
                                    if( POOP )
                                
                                    }
                                        if( !tValueErrorCode2.csF( tin0P ) ) bFail2 = 0 ;
                                        DEL( pSwPathValue ) ;
                                        }
                                            }
                                                etThread.delF( tin0P , pstpsttValue ) ;

                                                }
                                                    }
                                                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pppsttValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                        *pppsttValue[ offe ] = T(pstpsttValue) ;
                                                    {
                                                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                {
                                                for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                if( cPaths - cValues ) { BLAMMO ; }
                                                countT cValues = sizeof pppsttValue / sizeof pppsttValue[ 0 ] ;
                                                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                _IO_
                                            {
                                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                        {
                                        if( !POOP )

                                        //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                        ;
                                        }
                                            &tPathError     ,
                                            &tPathErrorCode ,
                                        {
                                        textC* pptPath[] =

                                        TN( tPathError     , "\"error\"/"   ) ;
                                        TN( tPathErrorCode , "\"errcode\"/" ) ;

                                        ;
                                        }
                                            &tValueError2     ,
                                            &tValueErrorCode2 ,
                                        {
                                        textC* pppsttValue[] =

                                        __Z( pSwPathValue ) ;
                                        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                        ZE( switchC* , pSwPathValue ) ;
                                        ZE( strokeS* , psttPath     ) ;
                                    {

                                    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                    etThread.traceF( tin0P , T("json response:") ) ;

                                    }
                                        }
                                            else if( costj ) break ;
                                                 if( cNest ) costj ++ ;
                                
                                            else if( postj[ costj ] == '}' ) cNest -- ;
                                                 if( postj[ costj ] == '{' ) cNest ++ ;
                                
                                            if( !cbIn ) break ;
                                            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                        {
                                        for(;;)
                                        ZE( countT , cNest ) ;
                                    {
                                    ZE( countT , costj ) ;
                                    osTextT postj[ TUCK << 1 ] ;
                                
                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                    etThread.traceF( tin0P , T("request:") ) ;
                                
                                    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!vToQLBLEntzHVKLSgG:communick.com/invite HTTP/1.1")+T("\r\nAuthorization: Bearer ")+psttValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBodyInvite,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBodyInvite ;
                                
                                    sockc.connectF( tin0P , 443 , nnServer ) ;
                                    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                
                                    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                    countT timeAllowedConnected = TICK >> 2 ;
                                
                                    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                    nicNameC nnServer ;
                                
                                    SCOOPS
                                {
                                IFsCRATCH                                                           // INVITE TO SPACE: COURTSHIP WORKSHOPS
                            {
                            else if( !bFail0 )
                            if( age < 13 || age > 29 ) bFail2 = 0 ;
                            
                            }
                                }
                                    if( !bFail1 ) tInvitationsSubmitted += T("    Wo'O's Table (Parlor)\r\n") ;

                                    }
                                        bFail1 = 1 ;
                                        etThread.traceF( tin0P , T("socket is impotent") ) ;
                                        POOPRqUIET
                                    {
                                    if( POOP )
                                
                                    }
                                        if( !tValueErrorCode1.csF( tin0P ) ) bFail1 = 0 ;
                                        DEL( pSwPathValue ) ;
                                        }
                                            }
                                                etThread.delF( tin0P , pstpsttValue ) ;

                                                }
                                                    }
                                                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pppsttValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                        *pppsttValue[ offe ] = T(pstpsttValue) ;
                                                    {
                                                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                                {
                                                for( countT offe = 0 ; offe < cPaths ; offe ++ )

                                                if( cPaths - cValues ) { BLAMMO ; }
                                                countT cValues = sizeof pppsttValue / sizeof pppsttValue[ 0 ] ;
                                                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                                                strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                                                _IO_
                                            {
                                            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                        {
                                        if( !POOP )

                                        //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

                                        ;
                                        }
                                            &tPathError     ,
                                            &tPathErrorCode ,
                                        {
                                        textC* pptPath[] =

                                        TN( tPathError     , "\"error\"/"   ) ;
                                        TN( tPathErrorCode , "\"errcode\"/" ) ;

                                        ;
                                        }
                                            &tValueError1     ,
                                            &tValueErrorCode1 ,
                                        {
                                        textC* pppsttValue[] =

                                        __Z( pSwPathValue ) ;
                                        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                        ZE( switchC* , pSwPathValue ) ;
                                        ZE( strokeS* , psttPath     ) ;
                                    {

                                    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                    etThread.traceF( tin0P , T("json response:") ) ;

                                    }
                                        }
                                            else if( costj ) break ;
                                                 if( cNest ) costj ++ ;
                                
                                            else if( postj[ costj ] == '}' ) cNest -- ;
                                                 if( postj[ costj ] == '{' ) cNest ++ ;
                                
                                            if( !cbIn ) break ;
                                            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                        {
                                        for(;;)
                                        ZE( countT , cNest ) ;
                                    {
                                    ZE( countT , costj ) ;
                                    osTextT postj[ TUCK << 1 ] ;
                                
                                    sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                    etThread.traceF( tin0P , T("request:") ) ;
                                
                                    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!hYyziZVwPkfPSsKSsW:communick.com/invite HTTP/1.1")+T("\r\nAuthorization: Bearer ")+psttValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBodyInvite,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBodyInvite ;
                                
                                    sockc.connectF( tin0P , 443 , nnServer ) ;
                                    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                                
                                    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                    countT timeAllowedConnected = TICK >> 2 ;
                                
                                    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                    nicNameC nnServer ;
                                
                                    SCOOPS
                                {
                                IFsCRATCH                                                           // INVITE TO ROOM: PARLOR
                            {
                            else if( !bFail0 )
                            if( age < 13 ) bFail1 = 0 ;
                            
                            countT costBodyInvite = tBodyInvite.csF( tin0P ) ;
                            TN( tBodyInvite , "" ) ; tBodyInvite = T("{\"user_id\": \"")+psttValueMatrixUsername+T("\"}\r\n") ;
#if defined( NEVERdEFINED )
                            
                            }
                                if( psttValueAccessToken.csF( tin0P ) ) bFail0 = 0 ;

                                }
                                    etThread.traceF( tin0P , T("socket is impotent") ) ;
                                    POOPRqUIET
                                {
                                if( POOP )
                            
                                etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+psttValueAccessToken+tb4+psttValueDeviceId ) ;
                                TN( tb4 , "    " ) ;
                            
                                }
                                    DEL( pSwPathValue ) ;
                                    
                                    }
                                        }
                                            etThread.delF( tin0P , pstpsttValue ) ;
                                    
                                            }
                                                }
                                                    etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + *pppsttValue[ offe ] , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                                    *pppsttValue[ offe ] = T(pstpsttValue) ;
                                                {
                                                if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                                            {
                                            for( countT offe = 0 ; offe < cPaths ; offe ++ )
                                    
                                            if( cPaths - cValues ) { BLAMMO ; }
                                            countT cValues = sizeof pppsttValue / sizeof pppsttValue[ 0 ] ;
                                            countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
                                    
                                            etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(pstpsttValue) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                            etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath)  , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                    
                                            strokeS*& pstpsttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                                            psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
                                    
                                            _IO_
                                        {
                                        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
                                        countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
                                    {
                                    if( !POOP )
                                    
                                    ;
                                    }
                                        &tPathDeviceId     ,
                                        &tPathAccessToken  ,
                                    {
                                    textC* pptPath[] =
                                    
                                    TN( tPathDeviceId    , "\"device_id\"/"    ) ;
                                    TN( tPathAccessToken , "\"access_token\"/" ) ;
                                    
                                    ;
                                    }
                                        &psttValueDeviceId      ,
                                        &psttValueAccessToken ,
                                    {
                                    textC* pppsttValue[] =
                                    
                                    __Z( pSwPathValue ) ;
                                    etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
                                    ZE( switchC* , pSwPathValue ) ;
                                    ZE( strokeS* , psttPath     ) ;
                                {
                            
                                etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                etThread.traceF( tin0P , T("json response:") ) ;
                            
                                }
                                    }
                                        else if( costj ) break ;
                                             if( cNest ) costj ++ ;
                            
                                        else if( postj[ costj ] == '}' ) cNest -- ;
                                             if( postj[ costj ] == '{' ) cNest ++ ;
                            
                                        if( !cbIn ) break ;
                                        countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
                                    {
                                    for(;;)
                                    ZE( countT , cNest ) ;
                                {
                                ZE( countT , costj ) ;
                                osTextT postj[ TUCK << 1 ] ;
                            
                                sockc.writeF( tin0P , (osTextT*)tSay ) ;
                                etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
                                etThread.traceF( tin0P , T("request:") ) ;
                            
                                TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/login HTTP/1.1\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;
                            
                                countT costBody = tBody.csF( tin0P ) ;
                            
                                //sockc.connectF( tin0P , 80 , nnServer ) ;
                                //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                            
                                sockc.connectF( tin0P , 443 , nnServer ) ;
                                socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;
                            
                                countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
                                countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
                                countT timeAllowedConnected = TICK >> 2 ;
                            
                                nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
                                nicNameC nnServer ;
                            
                                ) ;
                                
                                    "}\r\n"
                                    "    \"password\": \"")+tPassword+T("\"\r\n"
                                    "    },\r\n"
                                    "        \"user\": \"ideafarm\"\r\n"
                                    "        \"type\": \"m.id.user\",\r\n"
                                    "    {\r\n"
                                    "    \"identifier\":\r\n"
                                    "    \"type\": \"m.login.password\",\r\n"
                                    "{\r\n"
                                
                                TN( tBody , "" ) ; tBody = T(
                                
                                }
                                    etThread.delF( tin0P , psttPassword ) ;
                                    tPassword = T(psttPassword) ;
                                    etThread.traceF( tin0P , T("[password]:    ")+T(psttPassword) ) ;
                                    if( psttPassword && psttPassword->idAdam ) tPassword = T(psttPassword) ;
                                    ZE( strokeS* , psttPassword ) ; etThread.querySettingF( tin0P , psttPassword , T("!ipdos.password.matrix.communick.com.ideafarm")  ) ; ___( psttPassword ) ;
                                {
                                TN( tPassword , "" ) ;

                                SCOOPS
                            {
                            IFsCRATCH                                                           // LOGIN

                            TN( psttValueDeviceId    , "" ) ;
                            TN( psttValueAccessToken , "" ) ;
                            TN( tServer              , "matrix.communick.com" ) ;
                            TN( tValueError3      , "" ) ;
                            TN( tValueErrorCode3  , "" ) ;
                            TN( tValueError2      , "" ) ;
                            TN( tValueErrorCode2  , "" ) ;
                            TN( tValueError1      , "" ) ;
                            TN( tValueErrorCode1  , "" ) ;
                            boolT bFail3 = 1 ;
                            boolT bFail2 = 1 ;
                            boolT bFail1 = 1 ;
                            boolT bFail0 = 1 ;
                            TN( tInvitationsSubmitted , "" ) ;
                            ZE( boolT , bStudent ) ;

                            etThread.traceF( tin0P , T("got wo!") ) ;
                        {
                        else
                        }
                            flagsFail |= flFAIL_DOlATER ;
                        {
                        )
                            || age < 13
                            || etThread.strCompareF( tin0P , psttValueLive       , tFalse                          )      //U:: THIS LINE CAUSES LIVE TRANSACTIONS TO BE POSTPONED
                            || etThread.strCompareF( tin0P , psttValueNoticeType , tCorrectNoticeType              )
                            || etThread.strCompareF( tin0P , psttValueApiVersion , tCorrectApiVersion              )
                            || etThread.strCompareF( tin0P , psttVersion         , tCorrectVersion                 )
                               etThread.strCompareF( tin0P , psttType            , tCorrectType                    )
                        (
                        if
                        const sCountT age = etThread.strDigitsToSCountF( tin0P , psttValueAge , 0xa , 1 ) ;
                        TN( tCorrectVersion , "1" ) ;
                        TN( tCorrectType    , "order" ) ;

                        ZE( strokeS* , psttValueLive            ) ; sIn >> psttValueLive            ; ___( psttValueLive            ) ;
                        ZE( strokeS* , psttValueAmountDiscount  ) ; sIn >> psttValueAmountDiscount  ; ___( psttValueAmountDiscount  ) ;
                        ZE( strokeS* , psttValueIdSubscription  ) ; sIn >> psttValueIdSubscription  ; ___( psttValueIdSubscription  ) ;
                        ZE( strokeS* , psttValueMode            ) ; sIn >> psttValueMode            ; ___( psttValueMode            ) ;
                        ZE( strokeS* , psttValueName            ) ; sIn >> psttValueName            ; ___( psttValueName            ) ;
                        ZE( strokeS* , psttValueEmail           ) ; sIn >> psttValueEmail           ; ___( psttValueEmail           ) ;
                        ZE( strokeS* , psttValuePostalCode      ) ; sIn >> psttValuePostalCode      ; ___( psttValuePostalCode      ) ;
                        ZE( strokeS* , psttValueCountry         ) ; sIn >> psttValueCountry         ; ___( psttValueCountry         ) ;
                        ZE( strokeS* , psttValueAge             ) ; sIn >> psttValueAge             ; ___( psttValueAge             ) ;
                        ZE( strokeS* , psttValueAmountTotal     ) ; sIn >> psttValueAmountTotal     ; ___( psttValueAmountTotal     ) ;
                        ZE( strokeS* , psttValueAmountSubtotal  ) ; sIn >> psttValueAmountSubtotal  ; ___( psttValueAmountSubtotal  ) ;
                        ZE( strokeS* , psttValueApiVersion      ) ; sIn >> psttValueApiVersion      ; ___( psttValueApiVersion      ) ;
                        ZE( strokeS* , psttValueNoticeType      ) ; sIn >> psttValueNoticeType      ; ___( psttValueNoticeType      ) ;
                        ZE( strokeS* , psttVersion              ) ; sIn >> psttVersion              ; ___( psttVersion              ) ;
                        ZE( strokeS* , psttType                 ) ; sIn >> psttType                 ; ___( psttType                 ) ;
                    {
                    if( !( F(flagsFail) & flFAIL_COULDnOTgETsHADOW ) )
                    ZE( boolT , bFailPermanent ) ;

                    }
                        }
                            etThread.traceF( tin0P , TT(timeN1,timeN2)+T(" | could not get shadow of ")+T((strokeS*)tIfoName)+T(": ") ) ;
                            flagsFail |= flFAIL_COULDnOTgETsHADOW ;
                            POOPR ;
                        {
                        if( POOP )
                        ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , sIn , tIfoName ) ;
                        SCOOPS
                    {
                    IFsCRATCH
                    soulC sIn( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
                    IFsCRATCH{}

                    ZE( flagsT , flagsFail ) ;
                    etThread.traceF( tin0P , TT(timeN1,timeN2)+T(" | receiving ")+T((strokeS*)tIfoName)+T(": ") ) ;

                    etThread.traceF( tin0P , tShort ) ;

                    }
                        etThread.delF( tin0P , psttShort ) ;
                        tShort = T(psttShort) ;
                        etThread.delF( tin0P , psttnu ) ;
                        etThread.strBisectF( tin0P , psttnu , psttShort , tIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShort , "" ) ;

                    TN( tIfoName , pInfo->psttIfoName ) ;
                {
                if( !bDir )

                const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
            {
            else
            }
                break ;
                DEL( pInfo ) ;
            {
            if( !pInfo || !pInfo->psttIfoName )

            etThread.diskFindFileOrDirF( tin0P , pInfo , hFind , tFolderIncoming ) ;
            ZE( infoFileS* , pInfo ) ;
        {
        do
        handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

        }
            while( !ether && ~hFind && !POOP ) ;
            }
                DEL( pInfo ) ;
                }
                    }
                        etThread.traceF( tin0P , tShort ) ;
                        etThread.diskMoveFileOrDirF( tin0P , tFolderIncoming+tShort , pInfo->psttIfoName ) ;

                        }
                            etThread.delF( tin0P , psttShort ) ;
                            tShort = T(psttShort) ;
                            etThread.delF( tin0P , psttnu ) ;
                            etThread.strBisectF( tin0P , psttnu , psttShort , pInfo->psttIfoName , tSlash , - 1 - bDir , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttnu ) ;
                        {
                        TN( tShort , "" ) ;
                    {
                    if( !bDir )

                    const boolT bDir = pInfo->psttIfoName[ CSpREFIX - 1 + pInfo->psttIfoName->idAdam ].idAdam == '/' ;
                {
                else
                }
                    break ;
                    DEL( pInfo ) ;
                {
                if( !pInfo || !pInfo->psttIfoName )

                etThread.diskFindFileOrDirF( tin0P , pInfo , hFind , tFolderToRetry ) ;
                ZE( infoFileS* , pInfo ) ;
            {
            do
            handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

            timeL2 = timeN2 ;
            timeL1 = timeN1 ;
        {
        if( timeE2 || timeE1 > TICK )

        etThread.osTimeSubtractF( tin0P , timeE1 , timeE2 , timeL1 , timeL2 ) ;
        sCountT timeE2 = timeN2 ;
        countT  timeE1 = timeN1 ;

        etThread.osTimeNowF( tin0P , timeN1 , timeN2 ) ;
        ZE( sCountT , timeN2 ) ;
        ZE( countT  , timeN1 ) ;
    {
    while( !ether && !etThread )
    ZE( sCountT , timeL2 ) ;
    ZE( countT  , timeL1 ) ;
    TN( tSlash , "/" ) ;

    etThread.diskMakeDirIfNeededF( tin0P , tFolderAbandoned ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFolderToRetry   ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFolderDone      ) ;
    etThread.diskMakeDirIfNeededF( tin0P , tFolderIncoming  ) ;

    TN( tCorrectNoticeType , "checkout.session.completed" ) ;
    TN( tCorrectApiVersion , "2023-10-16"                 ) ;
    TN( tFalse             , "false"                      ) ;
    TN( tFolderAbandoned   , ""                           ) ; tFolderAbandoned = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/orders.3.abandoned/") ;
    TN( tFolderToRetry     , ""                           ) ; tFolderToRetry   = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/orders.2.to.retry/" ) ;
    TN( tFolderDone        , ""                           ) ; tFolderDone      = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/orders.4.done/"     ) ;
    TN( tFolderIncoming    , ""                           ) ; tFolderIncoming  = T("///ideafarm/ephemeral/backed.up.daily/domains/com/ideafarm/ipdos/orders.1.incoming/" ) ;
{
if( pTaskP )
TASK( tmWorkF )

#define flFAIL_DOlATER                          0xe00004ff
#define flFAIL_COULDnOTmOVEfILE                 0xe00004ff
#define flFAIL_COULDnOTgETsHADOW                0xe00002ff
#define flFAIL_UNKNOWNeRROR                     0xe00001ff

/*1*/WAKEhIDE( "revision.of.ifcIDaDAM_EATiNCOMINGoRDERS" )/*1*/

/**/
*/
/*

// NEW APPLICATION (NO PRIOR REVISIONS)

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

