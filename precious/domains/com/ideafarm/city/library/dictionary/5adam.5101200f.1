
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.traceF( tin0P , T("ok") ) ;

}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK << 0 ) ;

        grab_tWoTimePasswordGotten.ungrabF( tin0P ) ;
        //etRock.traceF( tin0P , tWoTimePasswordGotten ) ;
        grab_tWoTimePasswordGotten.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {
    while( !ether && !POOP )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    etThread.osThreadF( TaRG2cBsTACK( tmGetWebHookRandomSuffixF , CBsTACKmIN << 1 ) , (countT)&tWoTimePasswordGotten , (countT)&grab_tWoTimePasswordGotten ) ;
    TN( tWoTimePasswordGotten , "" ) ;
    grabC grab_tWoTimePasswordGotten( tin0P , TAG( TAGiDnULL ) ) ;

    etRock.traceF( tin0P , T("client") ) ;
{
else
}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK << 4 ) ;

        grab_tWoTimePassword.ungrabF( tin0P ) ;

        //etRock.traceF( tin0P , T("new:         [tWoTimePassword]:    ")+tWoTimePassword ) ;
        tWoTimePassword = tPasswordPrefix+TF4((countT)ruPassword,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FILLzE,0,0x24) ;
        //etRock.traceF( tin0P , T("old:         [tWoTimePassword]:    ")+tWoTimePassword ) ;

        grab_tWoTimePassword.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    {
    while( !ether && !POOP )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    etThread.osThreadF( TaRG2cBsTACK( tmDispenseWoTimeWebHookSuffixF , CBsTACKmIN << 1 ) , (countT)&tWoTimePassword , (countT)&grab_tWoTimePassword ) ;

    grab_tWoTimePassword.ungrabF( tin0P ) ;
    TN( tWoTimePassword             , ""                     ) ; tWoTimePassword = tPasswordPrefix+TF4((countT)ruPassword,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_NObASE|flFORMAT_FILLzE,0,0x24) ;  //0x24: [0-9,a-z]
    TN( tPasswordPrefix             , "password"             ) ;            // THIS PREFIX IS FOR CONVENIENCE WHEN SEARCHING TRACE LOGS 
    grab_tWoTimePassword.grabF( tin0P , TAG( TAGiDnULL )     ) ;

    grabC grab_tWoTimePassword( tin0P , TAG( TAGiDnULL )     ) ;
    ranUniC ruPassword( tin0P , (measure04T)MAXcOUNTT + 1 , processGlobal1S::_processGlobal1I_IF().trueRandom ) ;

    etRock.traceF( tin0P , T("server") ) ;
{
if( bServer )

}
    }
        if( !etThread.strCompareF( tin0P , psttc1 , tArgKeyKid ) ) bServer = 1 ;
        etThread.traceF( tin0P , T("param: ")+T(psttc1) ) ;
        _IO_
    {
    FORsTRINGSiN1( pstt1Param )
    TN( tArgKeyKid , "!server" ) ;
    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tin0P ) ;
{
ZE( boolT , bServer ) ;

etherC& etRock = etherC::etRockIF( tin0P ) ;

TODO

DONE( tmGetWebHookRandomSuffixF )
}
    }
        }
            }
                etThread.traceF( tin0P , T("!exception / could not destroy sConnect") ) ;
                POOPRqUIET
            {
            if( POOP )
            DELzOMBIE( psDoomed ) ;
            socketC* psDoomed = (socketC*)pb_sConnect ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK

        }
            break ;
            }
                }
                    //etThread.traceF( tin0P , T("-------------------------------------------------------------------------------------------------------------------------------------------------------------------------[woTimePassword]:    ")+tWoTimePasswordGottenP ) ;
                    tWoTimePasswordGottenLag = tWoTimePasswordGottenP ;         //A:ASSUME: EVEN WITH THIS DELAY, THERE IS STILL PLENTY OF TIME BEFORE THE NEXT OUTER QUERY OCCURS
                    //++ s ; ether.osSleepF( tin0P , TOCK << 1 ) ;    // MORE DELAY SO THAT THE TRACE APPEARS AFTER THE STOMP THAT ELICITED IT
                {
                if( etThread.strCompareF( tin0P , tWoTimePasswordGottenLag , tWoTimePasswordGottenP ) )

                //++ s ; ether.osSleepF( tin0P , TOCK >> 0 ) ;        // DELAY THE "---" TRACE SO THAT IT APPEARS AFTER THE STOMP THAT ELICITED IT (THAT'S WHY I SLEEP HERE RATHER THAN AT THE END OF MY LOOP, WHICH IS AFTER THE TRACE)

                etThread.delF( tin0P , psttw ) ;
                grab_tWoTimePasswordGottenP.ungrabF( tin0P ) ;
                tWoTimePasswordGottenP = T(psttw) ;                                   // I UPDATE IMMEDIATELY ; THE DELAY IN MY TRACING OF THE NEW VALUE IS JUST COSMETIC, TO MAKE THE TRACE EASIER TO READ BY ENSURING THAT THE UPDATE IS TRACED AFTER THE STOMP THAT ELICITED IT
                grab_tWoTimePasswordGottenP.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                }
                    }
                        break ;
                        ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                        etThread.traceF( tin0P , T("!exception / pulled null length psttw from sIn") ) ;
                    {
                    else if( !psttw->idAdam )
                    }
                        break ;
                        ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                        etThread.traceF( tin0P , T("!exception / pulled null psttw from sIn") ) ;
                    {
                    else if( !psttw )
                    }
                        break ;
                        ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                        etThread.traceF( tin0P , T("!exception / could not pull psttw from sIn") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    sIn >> psttw ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                ZE( strokeS* , psttw ) ;

                }
                    break ;
                    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                    etThread.traceF( tin0P , T("!exception / sIn is empty") ) ;
                {
                if( !sIn.cFieldsF() )

                }
                    }
                        break ;
                        ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                        etThread.traceF( tin0P , T("!exception / could not read into sIn") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    sConnect.readF( tin0P , sIn ) ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK

                }
                    }
                        break ;
                        ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                        etThread.traceF( tin0P , T("!exception / could not ct soulC sIn") ) ;
                        POOPRqUIET
                    {
                    if( POOP )
                    new( 0 , tin0P , pb_sIn , sizeof pb_sIn ) soulC( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) ) ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                soulC& sIn = *(soulC*)pb_sIn ;
                byteT pb_sIn[ sizeof( soulC ) ] ;
                _IO_
            {
            while( !ether )

            }
                }
                    break ;
                    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                    etThread.traceF( tin0P , T("!exception / could not connect ; will replace sConnect and retry [idpDnsSuffix]:    ")+TF2(idpDnsSuffix,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                {
                if( POOP )
                sConnect.connectF( tin0P , idpDnsSuffix , nnHe ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK

            }
                if( !idpDnsSuffix ) { ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ; }

                etThread.delF( tin0P , pbi ) ;
                if( pbi && cbi == sizeof idpDnsSuffix ) idpDnsSuffix = *(countT*)pbi ;

                }
                    }
                        etThread.traceF( tin0P , T("!exception / could not read file idpListenDut [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        POOPRqUIET
                        countT rc = POOP ;
                    {
                    if( POOP )
                    ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , pbi , cbi , T("////dns1/d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(ifcIDaDAM_SCRATCH0f)+T("/idpListenDut") , 1 ) ; ___( pbi ) ;
                    SCOOPS
                    _IO_
                {
                IFsCRATCHoK
                ZE( countT , cbi ) ;
                ZE( byteT* , pbi ) ;
                _IO_
            {
            while( !ether && !idpDnsSuffix )
            ZE( countT , idpDnsSuffix ) ;
            _IO_
        {
        while( !ether )

        }
            continue ;

            }
                }
                    etThread.traceF( tin0P , T("!exception / could not destroy sConnect") ) ;
                    POOPRqUIET
                {
                if( POOP )
                DELzOMBIE( psDoomed ) ;
                socketC* psDoomed = (socketC*)pb_sConnect ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK

            ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
            _IO_
        {
        if( bFail )

        }
            }
                bFail = 1 ;
                etThread.traceF( tin0P , T("!exception / could not bind to port ifcIDpORT_DNSwEBhOOKsUFFIX ; will retry") ) ;
                POOPRqUIET
            {
            if( POOP )
            sConnect.bindF( tin0P ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK

        }
            continue ;

            }
                }
                    etThread.traceF( tin0P , T("!exception / could not destroy sConnect") ) ;
                    POOPRqUIET
                {
                if( POOP )
                DELzOMBIE( psDoomed ) ;
                socketC* psDoomed = (socketC*)pb_sConnect ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK

            ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
            _IO_
        {
        if( bFail )
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        }
            }
                bFail = 1 ;
                etThread.traceF( tin0P , T("!exception / could not construct sConnect ; will retry") ) ;
                POOPRqUIET
            {
            if( POOP )
            new( 0 , tin0P , pb_sConnect , sizeof pb_sConnect ) socketC( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_DOnOTrEGISTERtIMEoUT ) ;
            SCOOPS
            _IO_
        {
        IFsCRATCHoK
        ZE( boolT , bFail ) ;
        socketC& sConnect = *(socketC*)pb_sConnect ;
        byteT pb_sConnect[ sizeof( socketC ) ] ;
        _IO_
    {
    while( !ether )
    TN( tWoTimePasswordGottenLag , "" ) ;

    nicNameC nnHe = etThread.sockNicNameF( tin0P , T("10.0.2.1") ) ;
    nicNameC nnMe = etThread.sockNicNameF( tin0P , T("10.0.3.1") ) ;

    grabC& grab_tWoTimePasswordGottenP = *(grabC*)pTaskP->c2 ;
    textC& tWoTimePasswordGottenP      = *(textC*)pTaskP->c1 ;

    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE ) ;

    _IO_
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmGetWebHookRandomSuffixF )

DONE( tmDispenseWoTimeWebHookSuffixF )
}
    }
        etThread.boxPutF( tin0P , T("///d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(ifcIDaDAM_SCRATCH0f)+T("/idpListenDut") , (byteT*)&nu , sizeof nu ) ;
        ZE( countT , nu ) ;

        }
            }
                etThread.traceF( tin0P , T("!exception / could not destroy sListen [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )
            DELzOMBIE( psDoomed ) ;
            socketC* psDoomed = (socketC*)pb_sListen ;
            SCOOPS
        {
        IFsCRATCHoK

        }
            DEL( pso ) ;
            }
                break ;
                }
                    //++ s ; ether.osSleepF( tin0P , TOCK >> 0 ) ;
                    //etThread.traceF( tin0P , T("wrote      [tWoTimePassword]:    ")+tSnap ) ;

                    }
                        }
                            break ;
                            etThread.traceF( tin0P , T("!exception / could not write to client so closing the connection [tWoTimePassword]:    ")+tWoTimePasswordP ) ;
                            POOPRqUIET
                        {
                        if( POOP )
                        pso->writeF( tin0P , sOut ) ;
                        SCOOPS
                    {
                    IFsCRATCHoK

                    //etThread.traceF( tin0P , T("will write [tWoTimePassword]:    ")+tSnap ) ;
                    sOut << (strokeS*)tSnap ;
                    soulC sOut( tin0P , etThread , TAG( TAGiDnULL ) ) ;

                    grab_tWoTimePasswordP.ungrabF( tin0P ) ;
                    tSnap = tWoTimePasswordP ;
                    grab_tWoTimePasswordP.grabF( tin0P , TAG( TAGiDnULL ) ) ;

                    TN( tSnap , "" ) ;
                {
                while( !ether )
            {
            if( pso && nnPeer == nnHe )
            etThread.traceF( tin0P , T("client accepted") ) ;

            }
                }
                    break ;
                    ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
                    etThread.traceF( tin0P , T("!exception / could not accept a client connection ; will replace sListen and retry [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                {
                if( POOP )
                sListen.acceptF( tin0P , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
                SCOOPS
            {
            IFsCRATCHoK
            etThread.traceF( tin0P , T("calling acceptF") ) ;
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            ZE( socketC* , pso ) ;
        {
        while( !ether )

        }
            continue ;
            DELzOMBIE( psDoomed ) ;
            socketC* psDoomed = (socketC*)pb_sListen ;
            ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
        {
        if( bFail )

        }
            }
                bFail = 1 ;
                etThread.traceF( tin0P , T("!exception / could not listen ; will retry [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )
            sListen.listenF( tin0P ) ;
            SCOOPS
        {
        IFsCRATCHoK

        }
            continue ;

            }
                }
                    etThread.traceF( tin0P , T("!exception / could not destroy sListen [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                {
                if( POOP )
                DELzOMBIE( psDoomed ) ;
                socketC* psDoomed = (socketC*)pb_sListen ;
                SCOOPS
            {
            IFsCRATCHoK

            ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
        {
        if( bFail )

        }
            etThread.traceF( tin0P , T("wrote   file [tLong]:    ")+tLong ) ;
            etThread.boxPutF( tin0P , tLong , (byteT*)&idpListenDut , sizeof idpListenDut ) ;
            etThread.traceF( tin0P , T("writing file [tLong]:    ")+tLong ) ;
            TN( tLong , "" ) ; tLong = T("///d/ideafarm.home.101/ephemeral/shared/")+TfORsTRING(processGlobal1S::_processGlobal1I_IF().idAdamRoot)+T("/idpListenDut") ;

            }
                }
                    bFail = 1 ;
                    etThread.traceF( tin0P , T("!exception / could not bind to port ifcIDpORT_DNSwEBhOOKsUFFIX ; will retry [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                {
                else
                if( !POOP ) /*;*/etThread.traceF( tin0P , T("[idpListenDut]:    ")+TF2(idpListenDut,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                idpListenDut = sListen.bindF( tin0P ) ;
                SCOOPS
            {
            IFsCRATCHoK
            ZE( countT , idpListenDut ) ;
        {

        }
            continue ;

            }
                }
                    etThread.traceF( tin0P , T("!exception / could not destroy sListen [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    POOPRqUIET
                    countT rc = POOP ;
                {
                if( POOP )
                DELzOMBIE( psDoomed ) ;
                socketC* psDoomed = (socketC*)pb_sListen ;
                SCOOPS
            {
            IFsCRATCHoK

            ++ s ; ether.osSleepF( tin0P , TOCK >> 2 ) ;
        {
        if( bFail )
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

        }
            }
                bFail = 1 ;
                etThread.traceF( tin0P , T("!exception / could not construct sListen ; will retry [rc]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                POOPRqUIET
                countT rc = POOP ;
            {
            if( POOP )
            new( 0 , tin0P , pb_sListen , sizeof pb_sListen ) socketC( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_DOnOTrEGISTERtIMEoUT ) ;
            SCOOPS
        {
        IFsCRATCHoK
        ZE( boolT , bFail ) ;
        socketC& sListen = *(socketC*)pb_sListen ;
        byteT pb_sListen[ sizeof( socketC ) ] ;
    {
    while( !ether )

    nicNameC nnHe = etThread.sockNicNameF( tin0P , T("10.0.3.1") ) ;
    nicNameC nnMe = etThread.sockNicNameF( tin0P , T("10.0.2.1") ) ;

    etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_RUDE ) ;

    grabC& grab_tWoTimePasswordP = *(grabC*)pTaskP->c2 ;
    textC& tWoTimePasswordP      = *(textC*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmDispenseWoTimeWebHookSuffixF )

/*1*/WAKEsHOWtEXT( "scr" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
