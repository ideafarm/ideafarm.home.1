
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

REST

sgnDone_tmWorkF.waitF( tin0P ) ;
ether.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    bQuit = 1 ;
    etherC::loafIF( tin0P ) ;
    queueC qBook1Sub( tin0P , etThread , bQuit , tLongQ ) ;
    ZE( boolT , bQuit ) ;

    TN( tLongQ , "///d/tmp/queue/" ) ;
{
if( pTaskP )
TASK( tmWorkF )

}
    return *this ;
    }
        ether.delF( tin0P , psttLongTo ) ;

        __( rcFail ) ;
        }
            }
                }
                    POOPRqUIET
                    }
                        etRock.traceF( tin0P , T("!exception / i could not move this new file to the archive") ) ;
                        rcFail = POOP ;
                    {
                    if( offPass > 1 )
                {
                else
                if( !POOP ) break ;

                              ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF(   tin0P , psttLongTo , psttLongFileP          , 1 ) ;
                if( offPass ) ((tin1S&)tin0P).pEtScratch->diskFileOrDirDeleteF( tin0P , psttLongTo , flFILEoRdIRdELETE_null , 1 ) ;
                SCOOPS
                _IO_
            {
            IFsCRATCHoK
            ZE( countT , rc ) ;
        {
        for( countT offPass = !ids ; !rcFail ; offPass ++ )
        ZE( countT , rcFail ) ;
        ether.strMakeF( tin0P , LF , psttLongTo , T(psttLongArchive)+tShort ) ; ___( psttLongTo ) ;
        ZE( strokeS* , psttLongTo ) ;

        ether.traceF( tin0P , T(ids?"new     [tShort]:    ":"existed [tShort]:    ")+tShort ) ;

        if( !ids ) ether.delF( tin0P , posts ) ;

        stShort.sinkF( tin0P , ids , posts , flSTACKsINK_UNIQUE ) ;
        ZE( countT , ids ) ;
        ether.strMakeF( tin0P , LF , posts , tShort ) ; ___( posts ) ;
        ZE( osTextT* , posts ) ;
    
        //ether.traceF( tin0P , T("[short]:    ")+tShort ) ;
    {
    if( tShort.csF( tin0P ) )

    TN( tShort , pstts ) ;
    ether.delF( tin0P , psttnu ) ;
    ether.strBisectF( tin0P , psttnu , pstts , psttLongFileP , psttSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( pstts ) ;  ___( psttnu ) ;
    ZE( strokeS* , pstts  ) ;
    ZE( strokeS* , psttnu ) ;

    etherC& etRock = etherC::etRockIF( tin0P ) ;

    }
        if( POOP ) return *this ;
        __Z( psttLongFileP ) ;
        if( POOP ) return *this ;
    {
    IFbEcAREFUL

    TINSL
{
queueC& queueC::operator <<( const strokeS* const psttLongFileP )

}
    ether.osThreadF( TaRG3sGNdONEcBsTACK( tmWatchQueueF , sgnDone_tmWatchQueueF , CBsTACKmIN << 1 ) , (countT)this ) ;

    ether.strMakeF( tin0P , LF , psttSlash , T("/") ) ; ___( psttSlash ) ;
    ether.diskMakeDirIfNeededF( tin0P , psttLongArchive ) ;
    ether.diskMakeDirIfNeededF( tin0P , psttLongIn ) ;
    ether.strMakeF(         tin0P , LF , psttLongArchive , T(psttLongIn)+T("archive/") ) ; ___( psttLongArchive ) ;
    ether.diskMapFileNameF( tin0P , psttLongIn , psttLongInP ) ; ___( psttLongIn ) ;
{
sgnDone_tmWatchQueueF( tin0P , TAG( TAGiDnULL ) )
psttSlash( 0 ) ,
stShort( tin0P , ether , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_byteT ) ,
psttLongArchive( 0 ) ,
psttLongIn( 0 ) ,
bQuit( bQuitP ) ,
ether( etherP ) ,
queueC::queueC( tin0S& tin0P , etherC& etherP , boolT& bQuitP , const strokeS* const psttLongInP ) :

}
    ether.delF( tin0P , psttLongArchive ) ;
    ether.delF( tin0P , psttLongIn      ) ;
    ether.delF( tin0P , psttSlash       ) ;
    sgnDone_tmWatchQueueF.waitF( tin0P ) ;
    TINSL
{
queueC::~queueC( voidT )

NEWdELcLASS( 1 , queueC ) ;

DONE( tmWatchQueueF )
}
    }
        }
            if( bWoth ) bWoth = 0 ;

            }
                while( !ether && ~hFindFile && !POOP ) ;
                }
                    DEL( pInfoFile ) ;
                    }
                        if( !bDir ) queueP << pInfoFile->psttIfoName ;
                        const boolT bDir = pInfoFile->psttIfoName[ CSpREFIX - 1 + pInfoFile->psttIfoName->idAdam ].idAdam == '/' ;
                    {
                    else
                    }
                        break ;
                        DEL( pInfoFile ) ;
                    {
                    if( !pInfoFile || !pInfoFile->psttIfoName )

                    etThread.diskFindFileOrDirF( tin0P , pInfoFile , hFindFile , queueP.psttLongIn , &pat ) ; ___( pInfoFile ) ;
                    ZE( infoFileS* , pInfoFile ) ;
                {
                do
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                handleC hFindFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
            {

            //ether.traceF( tin0P , T(bWoth?"starting to watch":"file name change detected") ) ;
            _IO_
        {
        if( bWoth || etThread.etherC::diskWaitDirF( tin0P , hWait , queueP.bQuit , queueP.psttLongIn , TOCK << 0 , flWAITdIR_FILEnAME ) )
        _IO_
    {
    while( !queueP.bQuit )
    handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    boolT bWoth = 1 ;

    }
        while( !ether && ~hFindFile && !POOP ) ;
        }
            DEL( pInfoFile ) ;
            }
                }
                    ether.delF( tin0P , pstts ) ;
                    }
                        if( POOP ) { POOPRqUIET }
                        ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , T(queueP.psttLongIn)+T(pstts) , pInfoFile->psttIfoName , 1 ) ;
                        SCOOPS
                        _IO_
                    {
                    IFsCRATCHoK

                    ether.delF( tin0P , psttnu ) ;
                    ether.strBisectF( tin0P , psttnu , pstts , pInfoFile->psttIfoName , queueP.psttSlash , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( pstts ) ;  ___( psttnu ) ;
                    ZE( strokeS* , pstts  ) ;
                    ZE( strokeS* , psttnu ) ;
                {
                if( !bDir )
                const boolT bDir = pInfoFile->psttIfoName[ CSpREFIX - 1 + pInfoFile->psttIfoName->idAdam ].idAdam == '/' ;
            {
            else
            }
                break ;
                DEL( pInfoFile ) ;
            {
            if( !pInfoFile || !pInfoFile->psttIfoName )

            etThread.diskFindFileOrDirF( tin0P , pInfoFile , hFindFile , queueP.psttLongArchive , &pat ) ; ___( pInfoFile ) ;
            ZE( infoFileS* , pInfoFile ) ;
        {
        do
        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        handleC hFindFile( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
    {
    patternC pat( tin0P , etThread , tPatPrefix , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
    TN( tPatPrefix , "*" ) ;
    // POUR THE ARCHIVE INTO THE INPUT FOLDER, SKIPPING FILES THAT CANNOT BE MOVED

    queueC& queueP = *(queueC*)pTaskP->c1 ;

    _IO_
{
if( pTaskP && pTaskP->c1 )
TASK( tmWatchQueueF )

;
}
    friend TASKpROTO( tmWatchQueueF ) ;                                                                                                                                                                                                                             \

    queueC& operator <<( const strokeS* const psttLongFileP ) ;
    queueC( tin0S& tin0P , etherC& etherP , boolT& bQuitP , const strokeS* const psttLongInP ) ;
    ~queueC( voidT ) ;
    NEWdELcLASSpROTOS

    public :

    signC    sgnDone_tmWatchQueueF ;
    strokeS* psttSlash             ;
    stackC   stShort               ;
    strokeS* psttLongArchive       ;
    strokeS* psttLongIn            ;
    boolT&   bQuit                 ;
    etherC&  ether                 ;
{
class queueC

TASKpART0PROTO( tmWatchQueueF ) ;

/*1*/WAKEsHOWtEXT( "doodle.queueC" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
