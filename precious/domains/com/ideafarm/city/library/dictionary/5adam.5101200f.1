
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.traceF( tin0P , T("bye") ) ;
etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    }
        if( bDelete ) etThread.delF( tin0P , *(byteT**)&pbi ) ;
        }
            bHead = 1 ;
            cbi = sizeof( count3S ) ;
            pbi = 0 ;

            etThread.delF( tin0P , psttnu ) ;
            etThread.traceF( tin0P , TF3(cDone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,0xc)+T(psttnu) ) ;
            etThread.boxPutUniqueF( tin0P , psttnu , tLike , pbi , cbi - 1 ) ; ___( psttnu ) ;
            ZE( strokeS* , psttnu ) ;
            ++ cDone ;
        {
        else
        }
            }
                cbi = 1 ;
                bSearchForHead = 1 ;
                etThread.traceF( tin0P , T("bad header, so will search for the next header [flagsFail]:    ")+TF3(flagsFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
            {
            else
            }
                bHead = 0 ;
                cbi = c3h.c3 ;
            {
            if( !flagsFail )
            pbi = 0 ;

            }
                if( !c3h.c3                                       ) { flagsFail |= 0x00000108 ; }
                if( c3h.c2 - 1                                    ) { flagsFail |= 0x00000104 ; }
                if( getNegAM( c3h.c1 ) - FINGERnEG_WEBhOOKnOTICES ) { flagsFail |= 0x00000102 ; }

                // putNegAM( c3s.c1 , FINGERnEG_WEBhOOKnOTICES ) ;
                // count3S c3s( 0 , 1 , costaBody ) ;
            {
            if( !flagsFail )
            count3S& c3h = *(count3S*)pbi ;

            if( cbi - sizeof( count3S )                           ) { flagsFail |= 0x00000101 ; }
            ZE( flagsT , flagsFail ) ;
        {
        else if( bHead )
        }
            }
                cbi = 1 ;
                bSearchForHead = 1 ;
                etThread.traceF( tin0P , T("not a header, so will continue searching [flagsFail]:    ")+TF3(flagsFail,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8) ) ;
            {
            else
            }
                bHead = 0 ;
                cbi = c3h.c3 ;
                etThread.traceF( tin0P , T("header found!") ) ;
            {
            if( !flagsFail )
            pbi = 0 ;

            }
                if( !c3h.c3                                       ) { flagsFail |= 0x00000010 ; }
                if( c3h.c2 - 1                                    ) { flagsFail |= 0x00000008 ; }
                if( getNegAM( c3h.c1 ) - FINGERnEG_WEBhOOKnOTICES ) { flagsFail |= 0x00000004 ; }

                // putNegAM( c3s.c1 , FINGERnEG_WEBhOOKnOTICES ) ;
                // count3S c3s( 0 , 1 , costaBody ) ;
            {
            if( !flagsFail )

                            pc3HeadMaybe = 0 ;
            count3S& c3h = *pc3HeadMaybe ;

            if( pbi - (byteT*)pc3HeadMaybe - 1                    ) { flagsFail |= 0x00000002 ; }       //IF WHAT I GOT IS NOT IMMEDIATELY AFTER THE FINGERPRINT (SHOULD BE IMPOSSIBLE)
            if( cbi - sizeof( count3S )    + 1                    ) { flagsFail |= 0x00000001 ; }       //IF DIDN'T GET THE REST OF THE HEAD
            ZE( flagsT , flagsFail ) ;
        {
        else if( pc3HeadMaybe )
        }
            pbi = 0 ;
            }
                cbi = sizeof( count3S ) - 1 ;
                pc3HeadMaybe = (count3S*)pbi ;
                bSearchForHead = 0 ;
            {
            if( getNegAM( c3h.c1 ) == FINGERnEG_WEBhOOKnOTICES )                                        //A:ASSUME: booksC PROVIDES HEADROOM SO THAT A countT OBJECT CAN ALWAYS BE READ, EVEN AT THE END OF A bookC INSTANCE
            count3S& c3h = *(count3S*)pbi ;
        {
        if( bSearchForHead )

        }
            continue ;
            ++ s ; ether.osSleepF( tin0P , TOCK ) ;
            etThread.traceF( tin0P , T("napping") ) ;
        {
        if( !pbi || !cbi )
        boolT bDelete = bksWebHookNotices.readF( tin0P , pbi , cbi , hRead , flBOOKScrEAD_null ) ;
    {
    while( !ether && cDone < 8 )
    ZE( countT , cDone ) ;

    etThread.traceF( tin0P , T("reading begun") ) ;
    TN( tLike , "///ideafarm/tmp/notice.@1@.txt" ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    ZE( count3S* , pc3HeadMaybe   ) ;
    ZE( boolT    , bSearchForHead ) ;
    boolT bHead = 1 ;
    handleC hRead( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_BOOKS ) ;
    booksC bksWebHookNotices( tin0P , TAG( TAGiDnULL ) , "webhook.notices" , ifcIDsTATEsPACE_MULTIPLEaDAMS ) ;

    countT             cbi = sizeof( count3S ) ;
    ZE( const byteT* , pbi ) ;
{


TODO

/*1*/WAKEsHOWtEXT( "doodle.read.notices" )/*1*/
/**/
*/

/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
