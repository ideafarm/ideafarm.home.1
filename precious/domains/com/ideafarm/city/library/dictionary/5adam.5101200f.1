
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tinP ) ;
etThread.traceF( tinP , T("ok") ) ;

etThread.delF( tinP , pstt1WildList ) ;

diskZipEtherF( tinP , etThread , T("///d/tmp/zoo.zip") , pstt1WildList , 0 , 0 , T("[pkzipc specs]") , T("[infozip specs]") ) ;

etThread.strFuseSeparateF( tinP ,      pstt1WildList , T("///d/tmp/hoo.ttt") ) ;
etThread.strFuseSeparateF( tinP ,      pstt1WildList , T("///d/tmp/goo.ttt") ) ;
etThread.strFuseSeparateF( tinP ,      pstt1WildList , T("///d/tmp/foo.ttt") ) ;
etThread.strMakeF(         tinP , LF , pstt1WildList , 0 , TUCK ) ; ___( pstt1WildList ) ;
ZE( strokeS* , pstt1WildList ) ;

TODO

}
    etThreadP.delF( tinP , postWildListExclude ) ;
    etThreadP.delF( tinP , postWildListInclude ) ;
    etThreadP.delF( tinP , postWildList        ) ;
    diskZipThirdF( tinP , etThreadP , T(osfnTo) , postWildList , postWildListInclude , postWildListExclude , T(psttSpecsPKZipP) , T(psttSpecsInfoZipP) ) ;

    }
        }
                        thirdC::c_strcatIF( tinP , postWildListExclude , osfnWild ) ;
            else        thirdC::c_strcatIF( tinP , postWildListExclude , " "      ) ;
            if( bWoth ) bWoth = 0 ;
            etThreadP.traceF( tinP , T(osfnWild) ) ;
            osFileNameC osfnWild( tinP , etThreadP , T(psttc1) ) ;
        {
        FORsTRINGSiN1( pstt1WildListExcludeP )
        boolT bWoth = 1 ;
        *postWildListExclude = 0 ;
        etThreadP.newF( tinP , LF , postWildListExclude , pstt1WildListExcludeP->idAdam + cWildExclude ) ; ___( postWildListExclude ) ;
    {
    if( pstt1WildListExcludeP )
    ZE( osTextT* , postWildListExclude ) ;

    }
        }
                        thirdC::c_strcatIF( tinP , postWildListInclude , osfnWild ) ;
            else        thirdC::c_strcatIF( tinP , postWildListInclude , " "      ) ;
            if( bWoth ) bWoth = 0 ;
            etThreadP.traceF( tinP , T(osfnWild) ) ;
            osFileNameC osfnWild( tinP , etThreadP , T(psttc1) ) ;
        {
        FORsTRINGSiN1( pstt1WildListIncludeP )
        boolT bWoth = 1 ;
        *postWildListInclude = 0 ;
        etThreadP.newF( tinP , LF , postWildListInclude , pstt1WildListIncludeP->idAdam + cWildInclude ) ; ___( postWildListInclude ) ;
    {
    if( pstt1WildListIncludeP )
    ZE( osTextT* , postWildListInclude ) ;

    }
        }
                        thirdC::c_strcatIF( tinP , postWildList , osfnWild ) ;
            else        thirdC::c_strcatIF( tinP , postWildList , " "      ) ;
            if( bWoth ) bWoth = 0 ;
            etThreadP.traceF( tinP , T(osfnWild) ) ;
            osFileNameC osfnWild( tinP , etThreadP , T(psttc1) ) ;
        {
        FORsTRINGSiN1( pstt1WildListP )
        boolT bWoth = 1 ;
        *postWildList = 0 ;
        etThreadP.newF( tinP , LF , postWildList , pstt1WildListP->idAdam + cWild ) ; ___( postWildList ) ;
    {
    ZE( osTextT* , postWildList ) ;

    if( pstt1WildListExcludeP ) { FORsTRINGSiN1( pstt1WildListExcludeP ) { cWildExclude ++ ; } }
    if( pstt1WildListIncludeP ) { FORsTRINGSiN1( pstt1WildListIncludeP ) { cWildInclude ++ ; } }
    { FORsTRINGSiN1( pstt1WildListP ) { cWild ++ ; } }
    ZE( countT , cWildExclude ) ;
    ZE( countT , cWildInclude ) ;
    ZE( countT , cWild        ) ;

    etThreadP.traceF( tinP , T(osfnTo) ) ;
    osFileNameC osfnTo( tinP , etThreadP , T(psttToP) ) ;

    }
        if( POOP ) return ;
        __Z( pstt1WildListP ) ;
        __Z( psttToP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
{
voidT diskZipEtherF( tinS& tinP , etherC& etThreadP , const strokeS* const psttToP , const strokeS* const pstt1WildListP , const strokeS* const pstt1WildListIncludeP , const strokeS* const pstt1WildListExcludeP , const strokeS* const psttSpecsPKZipP , const strokeS* const psttSpecsInfoZipP )

}
    tinP.pEther->traceF( tinP , T(postSpecsInfoZipP)    ) ;
    tinP.pEther->traceF( tinP , T(postSpecsPKZipP)      ) ;
    tinP.pEther->traceF( tinP , T(postWildListExcludeP) ) ;
    tinP.pEther->traceF( tinP , T(postWildListIncludeP) ) ;
    tinP.pEther->traceF( tinP , T(postWildListP)        ) ;
    tinP.pEther->traceF( tinP , T(postToP)              ) ;
{
voidT diskZipThirdF( tinS& tinP , thirdC& thirdP , const osTextT* const postToP , const osTextT* const postWildListP , const osTextT* const postWildListIncludeP , const osTextT* const postWildListExcludeP , const osTextT* const postSpecsPKZipP , const osTextT* const postSpecsInfoZipP )



#endif

  set up dut
    commandsAndOptionsInfoZip  (omitting implied commands and options)
    commandsAndOptionsPKZip    (omitting implied commands and options)
    listOfFilesWildExclude
    listOfFilesWildInclude
    listOfFilesWild
    zipfile
   parameters needed
  think
   pkzipc : PKZIPC [command] [options]                               zipfile [@list] [files...]
   infozip: zip    [-options] [-b path] [-t mmddyyyy] [-n suffixes] [zipfile list]              [-xi list]
   set up dut: scr f
  play

#if defined( NEVERdEFINED )




/*1*/WAKEsHOWtEXT( "doodle.diskZipF" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
