
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

sgnDone_tmWorkF.waitF( tin0P ) ;
etThread.osThreadF( TaRG3sGNdONEcBsTACK( tmWorkF , sgnDone_tmWorkF , TICK ) ) ;     //U::O: REPLACE "TICK" WITH MINIMUM cbStackP VALUE THAT WORKS RELIABLY
signC sgnDone_tmWorkF( tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmWorkF )
}
    etherC::loafIF( tin0P ) ;
    etThread.traceF( tin0P , T("ok") ) ;

    }
        }
            }
                while( ~hWalk ) ;
                }
                    etThread.traceF( tin0P , tb8+T(pstta) ) ;
                    strokeS* pstta = (strokeS*)swsAddressesUse.downF( tin0P , hWalk ) ;
                {
                do
                handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            {
            if( swsAddressesUse )

            etThread.traceF( tin0P , TF2(idType,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzlName) ) ;
            countT idType = swTypeUse ;
            psttzlName = (strokeS*)swTypeUse.leverF( tin0P , idf ) ;
    
            _IO_
        {
        for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
        countT cFlavors = swTypeUse.cFlavorsF( tin0P ) ;

        switchStackC& swsAddressesUse = !idPass ? swsAddresses4 : swsAddresses6 ;
        switchC&      swSuffixUse     = !idPass ? swSuffix4     : swSuffix6     ;
        switchC&      swTypeUse       = !idPass ? swType4       : swType6       ;
    {
    for( countT idPass = 0 ; idPass <= 1 ; idPass ++ )

    }
        }
            }
                }
                    etThread.delF( tin0P , pstt1Addresses ) ;
                    }
                        swsAddressesUse << psttLower ;
                        etThread.strConvertToLowerCaseF( tin0P , psttLower , psttc1 ) ; ___( psttLower ) ;
                        ZE( strokeS* , psttLower ) ;
                    {
                    FORsTRINGSiN1( pstt1Addresses )
                    etThread.strWordsF( tin0P , pstt1Addresses , tAddresses , sttq , T(" \r\n") ) ; ___( pstt1Addresses ) ;
                    ZE( strokeS* , pstt1Addresses ) ;

                    etThread.delF( tin0P , pstts ) ;
                    TN( tAddresses , pstts ) ;
                    etThread.strTrimF( tin0P , pstts ) ; ___( pstts ) ;
                    etThread.strSubstringF( tin0P , pstts , idf , sttq , t4 , psttBig ) ; ___( pstts ) ;
                    ZE( strokeS* , pstts ) ;
                    swTypeUse = idType1Dhcp2Static ;
                {
                if( idType1Dhcp2Static )

                else if( !etThread.strCompareF( tin0P , tMatch , t3 ) ) idType1Dhcp2Static = 2 ;
                else if( !etThread.strCompareF( tin0P , tMatch , t2 ) ) idType1Dhcp2Static = 1 ;
                }
                    psttzlName = tName ;
                    //etThread.traceF( tin0P , tName ) ;
                    etThread.delF( tin0P , pstts ) ;
                    tName = T(pstts) ;
                    etThread.strTrimF( tin0P , pstts ) ; ___( pstts ) ;
                    etThread.strSubstringF( tin0P , pstts , idf , sttq , tq , psttBig ) ; ___( pstts ) ;
                    ZE( strokeS* , pstts ) ;
                {
                if( !etThread.strCompareF( tin0P , tMatch , t1 ) )
                ZE( countT , idType1Dhcp2Static ) ;

                }
                    break ;
                    etThread.delF( tin0P , psttm ) ;
                    //etThread.traceF( tin0P , tMatch ) ;
                    tMatch = T(psttm) ;
                    stMatch >> psttm ;
                    ZE( strokeS* , psttm ) ;
                {
                while( stMatch )
                TN( tMatch , "" ) ;

                //etThread.traceF( tin0P , T("[idf]  :    ")+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                //etThread.traceF( tin0P , T("[idHit]:    ")+TF2(idHit,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                countT idHit = etThread.strIdF( tin0P , &stMatch , flSTRmATCH_REPORTmATCH , idf , sttq , psttre , psttBig , 0 , 1 ) ;
                stackC stMatch( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
            {
            while( idf )
            TN( tName , "" ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;

            etThread.traceF( tin0P , tListRaw , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;

            strokeS* psttBig = tListRaw ;
            strokeS* psttre = tre ;

            etThread.delF( tin0P , posti ) ;
            TN( tListRaw , posti ) ;
            etThread.boxGetF( tin0P , posti , costi , T("///c/doodle.ttt") ) ; ___( posti ) ;
            ZE( countT   , costi ) ;
            ZE( osTextT* , posti ) ;

            thirdC::c_systemIF( tin0P , !idPass ? "netsh interface ipv4 show dnsservers > c:\\doodle.ttt" :  "netsh interface ipv6 show dnsservers > c:\\doodle.ttt" ) ;

            switchStackC& swsAddressesUse = !idPass ? swsAddresses4 : swsAddresses6 ;
            switchC&      swSuffixUse     = !idPass ? swSuffix4     : swSuffix6     ;
            switchC&      swTypeUse       = !idPass ? swType4       : swType6       ;
        {
        for( countT idPass = 0 ; idPass <= 1 ; idPass ++ )

        ;

            +S2(sa_SSSaNDeND,sc_ccSSS)
                +S2(sa_SSSrEPORTmATCHeND,sc_ccSSS)
                   +S2(sa_SSSoReND,sc_ccSSS)
                       +S2(sa_SSSaNDeND,sc_ccSSS)
                           +t4
                       +S2(sa_SSSaND,sc_ccSSS)
                       +S2(sa_SSSaNDeND,sc_ccSSS)
                           +t3
                       +S2(sa_SSSaND,sc_ccSSS)
                       +S2(sa_SSSaNDeND,sc_ccSSS)
                           +t2
                       +S2(sa_SSSaND,sc_ccSSS)
                       +S2(sa_SSSaNDeND,sc_ccSSS)
                           +t1
                       +S2(sa_SSSaND,sc_ccSSS)
                   +S2(sa_SSSoR,sc_ccSSS)
                +S2(sa_SSSrEPORTmATCH,sc_ccSSS)                  // 123456789abcde
            +S2(sa_SSSaND,sc_ccSSS)

        TN( tre , "" ) ; tre += tn

        TN( t4 , "Register with which suffix:" ) ;
        TN( t3 , "Statically Configured DNS Servers:" ) ;
        TN( t2 , "DNS servers configured through DHCP:" ) ;
        TN( t1 , "Configuration for interface \"" ) ;
        TN( tCRLF , "\r\n" ) ;
        TN( tq , "\"" ) ;
        TN( tn , "" ) ;
    {
    switchStackC   swsAddresses6( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    switchStackC   swsAddresses4( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName , flSTACKc_DOnOTsERIALIZE | flSTACKc_FIFO , ifcSTACKtYPE_PTR_strokeS ) ;
    switchC        swSuffix6(     tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName ) ;
    switchC        swSuffix4(     tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName ) ;
    switchC        swType6(       tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName ) ;
    switchC        swType4(       tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzlName ) ;
    ZE( strokeS* , psttzlName ) ;

    TN( tb8  , "        " ) ;
    TN( tb4  , "    " ) ;
{
if( pTaskP )
TASK( tmWorkF )

//  
//      Register with which suffix:           None
//                                            fec0:0:0:ffff::3%1
//                                            fec0:0:0:ffff::2%1
//      Statically Configured DNS Servers:    fec0:0:0:ffff::1%1
//  Configuration for interface "Loopback Pseudo-Interface 1"
//  
//      Register with which suffix:           Primary only
//                                            fec0:0:0:ffff::3%1
//                                            fec0:0:0:ffff::2%1
//      DNS servers configured through DHCP:  fec0:0:0:ffff::1%1
//  Configuration for interface "Bluetooth Network Connection"
//  
//      Register with which suffix:           None
//      DNS servers configured through DHCP:  2600:380:452e:b7e7::bc
//  Configuration for interface "Wi-Fi"
//  
//      Register with which suffix:           Primary only
//                                            fec0:0:0:ffff::3%1
//                                            fec0:0:0:ffff::2%1
//      DNS servers configured through DHCP:  fec0:0:0:ffff::1%1
//  Configuration for interface "Local Area Connection* 11"
//  
//      Register with which suffix:           Primary only
//                                            fec0:0:0:ffff::3%1
//                                            fec0:0:0:ffff::2%1
//      DNS servers configured through DHCP:  fec0:0:0:ffff::1%1
//  Configuration for interface "Local Area Connection* 8"
//  
//      Register with which suffix:           Primary only
//                                            fec0:0:0:ffff::3%1
//                                            fec0:0:0:ffff::2%1
//      Statically Configured DNS Servers:    fec0:0:0:ffff::1%1
//  Configuration for interface "virtualbox"
//  
//  OUTPUT OF "netsh interface ipv6 show dnsservers"

//  
//      Register with which suffix:           None
//      Statically Configured DNS Servers:    None
//  Configuration for interface "Loopback Pseudo-Interface 1"
//  
//      Register with which suffix:           Primary only
//      DNS servers configured through DHCP:  None
//  Configuration for interface "Bluetooth Network Connection"
//  
//      Register with which suffix:           Primary only
//                                            50.216.215.53
//      DNS servers configured through DHCP:  50.216.215.54
//  Configuration for interface "Wi-Fi"
//  
//      Register with which suffix:           Primary only
//      DNS servers configured through DHCP:  None
//  Configuration for interface "Local Area Connection* 11"
//  
//      Register with which suffix:           Primary only
//      DNS servers configured through DHCP:  None
//  Configuration for interface "Local Area Connection* 8"
//  
//      Register with which suffix:           Primary only
//      Statically Configured DNS Servers:    None
//  Configuration for interface "virtualbox"
//  
//  OUTPUT OF "netsh interface ipv4 show dnsservers"

/*1*/WAKEhIDE( "doodle" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
