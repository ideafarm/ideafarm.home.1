
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.delF( tin0P , psttDeviceP ) ;
}
    inc02AM( cKidStop ) ;
    }
        }
            etThread.traceF( tin0P , T("walk failed") ) ;
            POOPRqUIET
        {
        if( POOP )

        }
            ((tin1S&)tin0P).pEtScratch->diskWalkF( tin0P , cDirs , cFiles , psttDeviceP , bFired , flDISKwALK_null , workCBF , pcArg , 0 , 0 ) ;

            //}
            //    ++ s ; ether.osSleepF( tin0P , TOCK ) ;
            //{
            //while( !bFired )
            //sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

            _IO_
        {
        SCOOPS
    {
    IFsCRATCH
    ZE( countT , cFiles ) ;
    ZE( countT , cDirs  ) ;

    countT pcArg[] = { (countT)&pata , (countT)&patf , (countT)&tb4 , (countT)&tSlash , (countT)&tIdeafarmArchives , (countT)&tRepNewFset , (countT)&tRepNewOther , (countT)&tRepOld , (countT)&tRecover , (countT)&tRecoverSlash , (countT)&tUnzipped , (countT)&tUnzippedSlash , (countT)&idFileLath } ;

    ZE( countT            , idFileLath          ) ;
    TN( tUnzippedSlash    , "unzipped/"         ) ;
    TN( tUnzipped         , "unzipped"          ) ;
    TN( tRecoverSlash     , "recover/"          ) ;
    TN( tRecover          , "recover"           ) ;
    TN( tRepOld           , "!ideafarm.a."      ) ;
    TN( tRepNewOther      , "!ideafarm.9."      ) ;
    TN( tRepNewFset       , "!ideafarm.f."      ) ;
    TN( tIdeafarmArchives , "ideafarm.archives" ) ;
    TN( tSlash            , "/"                 ) ;
    TN( tb4               , "    "              ) ;
    patternC patf( tin0P , etThread , T("!ideafarm.f.*.fset.zip") , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
    patternC pata( tin0P , etThread , T("!ideafarm.a.*"         ) , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
    inc02AM( cKidStart ) ;
{
else
}
    ether.osSuspendF( tin0P , 0 , 0 , nicNameC() ) ;
    else         etThread.traceF( tin0P , T("not suspending base os (hibernating) because i have been fired") ) ;
    if( !ether ) etThread.traceF( tin0P , T("suspending base os (hibernating)") ) ;

    }
        ++ s ; etThread.osSleepF( tin0P , TOCK ) ;
        etThread.traceF( tin0P , T("fired!  waiting for all kids to die [cKidHired,cKidDied]:    ")+TF2(cKidHired,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cKidStop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( cKidStop < cKidHired )

    bFired = 1 ;

    }
        ++ s ; etThread.osSleepF( tin0P , TOCK ) ;
        etThread.traceF( tin0P , T("ho hum... waiting for all kids to die [cKidHired,cKidDied]:    ")+TF2(cKidHired,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cKidStop,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( !ether && cKidStop < cKidHired )

    }
        ++ s ; etThread.osSleepF( tin0P , TOCK ) ;
        etThread.traceF( tin0P , T("waiting for all kids to be born [cKidHired,cKidBorn]:    ")+TF2(cKidHired,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cKidStart,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    {
    while( cKidStart < cKidHired )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

    }
        etThread.delF( tin0P , pstt1f ) ;
        }
            etThread.ifcHireF( tin0P , T("self") , 0 , T("!device ")+T(psttc1) , flHIRE_DISPLAYaUTO | flHIRE_DEBUG , 0 , 0 , 1 , nicNameC() ) ;
            cKidHired ++ ;
            etThread.traceF( tin0P , psttc1 ) ;
        {
        FORsTRINGSiN1( pstt1f )
        etThread.diskFindFileOrDirF( tin0P , pstt1f , T("///d/ideafarm.home.101/devices/") , 0 , flDISKfIND_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1f ) ;
        ZE( strokeS* , pstt1f ) ;
    {
    if( !POOP )
    ZE( countT , cKidHired ) ;

    }
        if( pHomeDebug ) ;
        pHomeDebug = (homeS*)(byteT*)napHomeDebug ;
        static homeS* pHomeDebug ;
        napkinC napHomeDebug( tin0P , TAGnOtIN( TAGiDnULL ) , "napHome" , 0 , sizeof( homeS ) , ifcOPENsHAREDmEMORYhOW_nCeO , flNAPKINc_DOnOTsERIALIZEcT | flNAPKINc_ALLmEMORYsPACES ) ;
    {

    __( cKidStop ) ; // CkIDsTOP
    __( cKidStart ) ; // CkIDsTART
    __( bFired ) ; // BfIRED
{
if( !psttDeviceP )

pnu = &home ;
static homeS* pnu ;

countT& cKidStop  = home.pc Utility[ 2 ] ;
countT& cKidStart = home.pc Utility[ 1 ] ;
boolT&  bFired    = home.pc Utility[ 0 ] ;
homeS& home = homeS::homeIF() ;
TN( tb4 , "    " ) ;

}
    }
        }
            break ;
            etThread.strMakeF( tin0P , LF , psttDeviceP , psttc1 ) ; ___( psttDeviceP ) ;
            bArmed = 0 ;
        {
        else if( bArmed )
        if( !etThread.strCompareF( tin0P , psttc1 , tArgKeyName ) ) bArmed = 1 ;
        etThread.traceF( tin0P , T("param: ")+T(psttc1) ) ;
    {
    FORsTRINGSiN1( pstt1Param )
    ZE( boolT , bArmed ) ;
    strokeS*& pstt1Param = etThread.ether_pstt1_processParametersI_F( tin0P ) ;
{
ZE( strokeS* , psttDeviceP ) ;
TN( tArgKeyName , "!device" ) ;

TODO

}
    return 0 ;
    //etherP.traceF( tin0P , T("workCBF / 0") ) ; //U::

    }
        }
            }
                #endif

                    }
                        while( !bQuitP && ~hFind && !POOP ) ;
                        }
                            DEL( pInfo ) ;
                            }
                                etherP.delF( tin0P , psttShortNew ) ;
                                }
                                    }
                                        etherP.traceF( tin0P , tb4P+tLongTo ) ;
                                        etherP.traceF( tin0P , T("!exception: could not move [rc,tShortOld]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4P+tShort ) ;
                                        POOPRqUIET
                                        countT rc = POOP ;
                                        _IO_
                                    {
                                    else
                                    if( !POOP ) etherP.traceF( tin0P , T("moved aok [tShortOld]:    ")+tShort ) ;
                                    //etherP.traceF( tin0P , T("workCBF / 1") ) ; //U::
                                    ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tLongTo , tLongFrom , 1 , flFILEoRdIRmOVE_DOnOTmAKEdIRiFnEEDED ) ;
                                    //etherP.traceF( tin0P , T("workCBF / 2") ) ; //U::
                                    _IO_
                                    SCOOPS
                                {
                                IFsCRATCH

                                //etherP.traceF( tin0P , tPath   ) ;
                                //etherP.traceF( tin0P , tLongTo ) ;

                                TN( tLongFrom , "" ) ; tLongFrom = tPath+tShort          ;
                                TN( tLongTo   , "" ) ; tLongTo   = tPath+T(psttShortNew) ;

                                //etherP.traceF( tin0P , T("workCBF / 3") ) ; //U::
                                etherP.strReplaceF( tin0P , psttShortNew , tShort , tRepOldP , bFset ? tRepNewFsetP : tRepNewOtherP , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                                ZE( strokeS* , psttShortNew ) ;
                                //etherP.traceF( tin0P , T("workCBF / 4") ) ; //U::

                                //etherP.traceF( tin0P , tShort ) ;

                                boolT bFset = !!etherP.strIdF( tin0P , T(".fset.zip") , tShort , 1 ) ;

                                }
                                    etherP.delF( tin0P , psttShort ) ;
                                    etherP.delF( tin0P , psttnu ) ;
                                    tShort  = T(psttShort) ;
                                    etherP.strBisectF( tin0P , psttnu , psttShort , pInfo->psttIfoName , tSlashP , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                                    ZE( strokeS* , psttShort ) ;
                                    ZE( strokeS* , psttnu ) ;
                                    _IO_
                                {
                                TN( tShort , "" ) ;
                                //etherP.traceF( tin0P , T("workCBF / 5") ) ; //U::
                                _IO_
                            {
                            else
                            }
                                break ;
                                DEL( pInfo ) ;
                                _IO_
                            {
                            if( !pInfo || !pInfo->psttIfoName )

                            //etherP.traceF( tin0P , T("workCBF / 6") ) ; //U::
                            etherP.diskFindFileOrDirF( tin0P , pInfo , hFind , psttzPath , &pataP ) ; ___( pInfo ) ;
                            //etherP.traceF( tin0P , T("workCBF / 7") ) ; //U::
                            ZE( infoFileS* , pInfo ) ;
                            _IO_
                        {
                        do
                        handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                        etherP.traceF( tin0P , tPath ) ;                  //   ///d/ideafarm.home.101/devices/hdd3.arc.2021010601/ideafarm.archives/
                        _IO_
                    {
                    if( bArchives && bUnzipped )

                #elif defined( DOtASK03 )

                    }
                        while( !bQuitP && ~hFind && !POOP ) ;
                        }
                            DEL( pInfo ) ;
                            }
                                }
                                    //etherP.traceF( tin0P , T("workCBF / 0") ) ; //U::
                                    etherP.diskFileOrDirDeleteF( tin0P , pInfo->psttIfoName , flFILEoRdIRdELETE_null , 0 ) ;
                                    //etherP.traceF( tin0P , T("workCBF / 1") ) ; //U::
                                {
                                if( bOk )

                                }
                                    //etherP.traceF( tin0P , T("workCBF / 2") ) ; //U::
                                    }
                                        }
                                            etherP.traceF( tin0P , T("workCBF / 3") ) ; //U::
                                            else bOk = 1 ;
                                            }
                                                etherP.traceF( tin0P , tb4P+tb4P+T("!exception: could not unzip [idFile,tLong]:    ")+TF3(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4P+T(pInfo->psttIfoName) ) ;
                                                POOPR
                                            {
                                            if( POOP )
                                            ((thirdC&)*((tin1S&)tin0P).pEtScratch).diskUnzipOldF( tin0P , 0 , tRelFrom ) ;
                                            etherP.traceF( tin0P , T("workCBF / 4") ) ; //U::

                                            SCOOPS
                                        {
                                        IFsCRATCH
                                    {
                                    //etherP.traceF( tin0P , T("workCBF / 5") ) ; //U::
                                    TN( tCmd       , "" ) ; tCmd       = T("unzip ..\\")+tShort ;
                                    TN( tRelFrom   , "" ) ; tRelFrom   = T("..\\")+tShort ;
                                {
                                ZE( boolT , bOk ) ;

                                if( !( idFile % TUCK ) ) etherP.traceF( tin0P , tb4P+TF3(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED,8)+tb4P+tShort ) ;

                                }
                                    etherP.delF( tin0P , psttShort ) ;
                                    etherP.delF( tin0P , psttnu ) ;
                                    tShort  = T(psttShort) ;
                                    etherP.strBisectF( tin0P , psttnu , psttShort , pInfo->psttIfoName , tSlashP , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                                    ZE( strokeS* , psttShort ) ;
                                    ZE( strokeS* , psttnu ) ;
                                    _IO_
                                {
                                TN( tShort , "" ) ;

                                countT idFile = 1 + incv02AM( idFileLathP ) ;

                                _IO_
                            {
                            else
                            }
                                break ;
                                DEL( pInfo ) ;
                                _IO_
                            {
                            if( bQuitP || !pInfo || !pInfo->psttIfoName )

                            //etherP.traceF( tin0P , T("workCBF / 6") ) ; //U::
                            etherP.diskFindFileOrDirF( tin0P , pInfo , hFind , psttzPath , &patfP ) ; ___( pInfo ) ;
                            //etherP.traceF( tin0P , T("workCBF / 7") ) ; //U::
                            ZE( infoFileS* , pInfo ) ;
                            _IO_
                        {
                        do
                        handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
                        hoverC hover( tin0P , etherP , tPathHover ) ;
                        TN( tPathHover , "" ) ; tPathHover = tPath + T("unzipped.2/") ;
                        etherP.traceF( tin0P , tPath ) ;                  //   ///d/ideafarm.home.101/devices/hdd3.arc.2021010601/ideafarm.archives/recover/

                        _IO_
                    {
                    if( bArchives && bRecover )

                #elif defined( DOtASK02 )

                    }
                        while( !bQuitP && ~hFind && !POOP ) ;
                        }
                            DEL( pInfo ) ;
                            }
                                etherP.delF( tin0P , psttShortNew ) ;
                                }
                                    }
                                        etherP.traceF( tin0P , tb4P+tLongTo ) ;
                                        etherP.traceF( tin0P , T("!exception: could not move [rc,tShortOld]:    ")+TF2(rc,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4P+tShort ) ;
                                        POOPRqUIET
                                        countT rc = POOP ;
                                        _IO_
                                    {
                                    else
                                    if( !POOP ) etherP.traceF( tin0P , T("moved aok [tShortOld]:    ")+tShort ) ;
                                    //etherP.traceF( tin0P , T("workCBF / 1") ) ; //U::
                                    ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tLongTo , tLongFrom , 1 , flFILEoRdIRmOVE_DOnOTmAKEdIRiFnEEDED ) ;
                                    //etherP.traceF( tin0P , T("workCBF / 2") ) ; //U::
                                    _IO_
                                    SCOOPS
                                {
                                IFsCRATCH

                                //etherP.traceF( tin0P , tPath   ) ;
                                //etherP.traceF( tin0P , tLongTo ) ;

                                TN( tLongFrom , "" ) ; tLongFrom = tPath+tShort                         ;
                                TN( tLongTo   , "" ) ; tLongTo   = tPath+tRecoverSlashP+T(psttShortNew) ;

                                //etherP.traceF( tin0P , T("workCBF / 3") ) ; //U::
                                etherP.strReplaceF( tin0P , psttShortNew , tShort , tRepOldP , bFset ? tRepNewFsetP : tRepNewOtherP , 0 , flSTRrEPLACE_null ) ; ___( psttShortNew ) ;
                                ZE( strokeS* , psttShortNew ) ;
                                //etherP.traceF( tin0P , T("workCBF / 4") ) ; //U::

                                //etherP.traceF( tin0P , tShort ) ;

                                boolT bFset = !!etherP.strIdF( tin0P , T(".fset.zip") , tShort , 1 ) ;

                                }
                                    etherP.delF( tin0P , psttShort ) ;
                                    etherP.delF( tin0P , psttnu ) ;
                                    tShort  = T(psttShort) ;
                                    etherP.strBisectF( tin0P , psttnu , psttShort , pInfo->psttIfoName , tSlashP , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttnu ) ; ___( psttShort ) ;
                                    ZE( strokeS* , psttShort ) ;
                                    ZE( strokeS* , psttnu ) ;
                                    _IO_
                                {
                                TN( tShort , "" ) ;
                                //etherP.traceF( tin0P , T("workCBF / 5") ) ; //U::
                                _IO_
                            {
                            else
                            }
                                break ;
                                DEL( pInfo ) ;
                                _IO_
                            {
                            if( !pInfo || !pInfo->psttIfoName )

                            //etherP.traceF( tin0P , T("workCBF / 6") ) ; //U::
                            etherP.diskFindFileOrDirF( tin0P , pInfo , hFind , psttzPath , &pataP ) ; ___( pInfo ) ;
                            //etherP.traceF( tin0P , T("workCBF / 7") ) ; //U::
                            ZE( infoFileS* , pInfo ) ;
                            _IO_
                        {
                        do
                        handleC hFind( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;

                        etherP.diskMakeDirIfNeededF( tin0P , tPath+T("recover/") ) ;     // NEEDED BECAUSE flFILEoRdIRmOVE_DOnOTmAKEdIRiFnEEDED IS SPECIFIED FOR CALL TO diskMoveFileOrDirF
                        etherP.traceF( tin0P , tPath ) ;                  //   ///d/ideafarm.home.101/devices/hdd3.arc.2021010601/ideafarm.archives/
                        _IO_
                    {
                    if( bArchives && bYear )

                #if defined( DOtASK01 )

                }
                    etherP.delF( tin0P , pstt1w ) ;
                    }
                        }
                            }
                                }
                                    break ;
                                    bUnzipped = 0 ;
                                {
                                case 0xa :
                                }
                                    break ;
                                    if( !etherP.strCompareF( tin0P , psttc1 , tUnzippedP ) ) bUnzipped = 1 ;
                                    bRecover = 0 ;
                                {
                                case 9 :
                                }
                                    break ;
                                    if( !etherP.strCompareF( tin0P , psttc1 , tRecoverP ) ) bRecover = 1 ;
                                    bYear = 0 ;
                                {
                                case 8 :
                                }
                                    break ;
                                    bYear = 1 ;
                                {
                                case 7 :
                                }
                                    break ;
                                    if( !etherP.strCompareF( tin0P , psttc1 , tIdeafarmArchivesP ) ) bArchives = 1 ;
                                {
                                case 5 :
                            {
                            switch( idw )

                              //etherP.traceF( tin0P , tb4P+TF2(idw,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4P+T(psttc1) ) ;
                            ++ idw ;
                        {
                        FORsTRINGSiN1( pstt1w )
                        ZE( countT , idw ) ;
                    {
                    #endif
                        if( cWords == 0xa )
                    #elif defined( TASKpART03 )
                        if( cWords == 9 )
                    #elif defined( TASKpART02 )
                        if( cWords == 7 )
                    #if defined( TASKpART01 )
                    countT cWords = etherP.strWordsF( tin0P , pstt1w , psttzPath , sttq , tSlashP , flSTRwORDS_null , 0 , 0 , 0 , 0 , 0 ) ; ___( pstt1w ) ;
                    ZE( strokeS* , pstt1w ) ;
                    _IO_
                {
                ZE( boolT , bUnzipped ) ;
                ZE( boolT , bRecover  ) ;
                ZE( boolT , bYear     ) ;
                ZE( boolT , bArchives ) ;
                _IO_
            {
            if( psttzPath[ CSpREFIX - 1 + psttzPath->idAdam ].idAdam == '/' )           // IF A FOLDER NAME

            strokeS* psttzPath = tPath ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            TN( tPath , iffn ) ;
            ifFileNameC iffn( tin0P , etherP , postNameP ) ;
        {
        if( !bQuitP )

        countT&   idFileLathP        =   *(countT*)pcArgP[ 0xc ] ;
        textC&    tUnzippedSlashP    =    *(textC*)pcArgP[ 0xb ] ;
        textC&    tUnzippedP         =    *(textC*)pcArgP[ 0xa ] ;
        textC&    tRecoverSlashP     =    *(textC*)pcArgP[ 0x9 ] ;
        textC&    tRecoverP          =    *(textC*)pcArgP[ 0x8 ] ;
        textC&    tRepOldP           =    *(textC*)pcArgP[ 0x7 ] ;
        textC&    tRepNewOtherP      =    *(textC*)pcArgP[ 0x6 ] ;
        textC&    tRepNewFsetP       =    *(textC*)pcArgP[ 0x5 ] ;
        textC&    tIdeafarmArchivesP =    *(textC*)pcArgP[ 0x4 ] ;
        textC&    tSlashP            =    *(textC*)pcArgP[ 0x3 ] ;
        textC&    tb4P               =    *(textC*)pcArgP[ 0x2 ] ;
        patternC& patfP              = *(patternC*)pcArgP[ 0x1 ] ;
        patternC& pataP              = *(patternC*)pcArgP[ 0x0 ] ;
        _IO_
    {
    if( postNameP && *postNameP )

    // d:\ideafarm.home.101\devices\hdd3.arc.2021010601\archive.save.1999\1999\!ideafarm.9.2.00000000.00000001.00000000@0000.!.control.page.keywords

    etherC& etPrime = etherC::etPrimeIF() ;

    //etherP.traceF( tin0P , T("workCBF / 8") ) ; //U::
    etherC& etherP = *((tin1S&)tin0P).pEther ;
    _IO_
{
boolT workCBF( tin0S& tin0P , countT& cDirsP , countT& cFilesP , const boolT& bQuitP , const osTextT* const postNameP , countT* const pcArgP , const countT* const pModuloDirsP , const countT* const pModuloFilesP )


#define DOtASK03
//TASKpART02: UNZIP ALL OF THE FSET ZIP FILES IN recover/
//TASKpART01: MOVE ALL OF THE FMT a FILES TO recover/

/*1*/WAKEsHOWtEXT( "tool.archive.recovery" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
