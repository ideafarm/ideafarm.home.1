
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST
etThread.osProcessIdPhaseAdamF( tinBaseP , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

}
    }
        etThread = 0 ;

        }
            else        { ZE( countT , tnu ) ; etThread.osThreadF( tinBaseP , tnu , tmServePriceF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)pso , (countT)&pPricer , (countT)&b_pPricer ) ; }
            if( ether ) { DEL( pso ) ; }
            socket.acceptF( tinBaseP , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            ZE( socketC* , pso ) ;
        {
        while( !ether && !etThread )

        socket.listenF( tinBaseP ) ;    
        countT idPort = socket.bindF( tinBaseP , ifcPORToLD1pRICEaUTHORITY ) ;
        socketC socket( tinBaseP , etThread , TAG( TAGiDnULL ) ) ;
    {
    while( !ether )

    { ZE( countT , tnu ) ; etThread.osThreadF( tinBaseP , tnu , tmRefreshPricerF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)&pPricer , (countT)&b_pPricer ) ; }
    batonC b_pPricer( tinBaseP , TAG( TAGiDnULL ) ) ;
    ZE( pricerC* , pPricer ) ;

    etThread.strokeF( tinBaseP , T("IdeaFarm " "(tm) City Price Authority\r\ni state the price of resource usage on request\r\n\r\n")+TPS("price",0xd,S1C('-'))+T("  ")+TPS("qty",8,S1C('-'))+T("  ")+TPS("idResource",0x20,S1C('-'))+T("\r\n") ) ;
{
else
}
    etThread.strokeF( tinBaseP , T("Another ")+textIdFileC( tinBaseP , DDNAME )+T(" appears to be alive on this computer.  Only one is allowed.") ) ;
    etThread = 0  ;
{
if( etThread )
U:: USE napkinC OBJECT TO TEST FOR ALONENESS
batonC baton( tinBaseP , TAG( TAGiDnULL ) , T("6f30104") ) ;

TODO

DONE( tmRefreshPricerF )
}
    }
        }
            }
                DEL( pDoomed ) ;

                b_pPricer.ungrabF( tinBaseP ) ;
                pPricer = pPricerNew ;
                pricerC* pDoomed = pPricer ;
                b_pPricer.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
            {
            if( pPricerNew )

            pricerC* pPricerNew = new( 0 , tinBaseP , LF ) pricerC( tinBaseP , etThread ) ;
        {
        if( !( ( ++ idTry ) % 0x1000 ) ) //U: USE bNewHour
        etThread.osSleepF( tinBaseP , TOCK ) ;
    {
    while( !ether && !etThread )
    ZE( countT , idTry ) ;

    b_pPricer.ungrabF( tinBaseP ) ;
    pPricer = new( 0 , tinBaseP , LF ) pricerC( tinBaseP , etThread ) ;
    b_pPricer.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

    batonC&   b_pPricer = *(batonC*)  pTaskP->c2 ;
    pricerC*& pPricer   = *(pricerC**)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmRefreshPricerF )

DONE( tmServePriceF )

}
    DEL( pso ) ;

    }
        }
            break ;
            __1
            __( idCmd ) ;
        {
        default :
        }
            break ;
            }
                pso->readF( tinBaseP , &bnu , 1 , flSOCKETcrEAD_STILLhUNGRYiSoK ) ;
                ZE( byteT , bnu ) ;
                }
                    pso->writeF( tinBaseP , (byteT*)&idCitizen , sizeof idCitizen ) ;
                    stShare >> idCitizen ;
                    ZE( countT , idCitizen ) ;
                {
                while( stShare )        
                pso->writeF( tinBaseP , (byteT*)&cShare , sizeof cShare ) ;
                countT cShare = stShare ;
                b_pPricer.ungrabF( tinBaseP ) ;
                etThread.delF( tinBaseP , pcPart ) ;
                pPricer->shareF( tinBaseP , stShare , pcPart ) ;
                b_pPricer.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
                stackC stShare( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO ) ;

                if( pcPart ) pcPart[ ccPart ] = 0 ;
                pso->readF( tinBaseP , (byteT*)pcPart , sizeof( countT ) * ccPart ) ;
                etThread.newF( tinBaseP , LF , pcPart , ccPart + 1 ) ; ___( pcPart ) ;
                ZE( countT* , pcPart ) ;
            {
            if( !ether && !etThread && ccPart )
            pso->readF( tinBaseP , (byteT*)&ccPart , sizeof ccPart ) ;
            ZE( countT , ccPart ) ;
        {
        case idCMDpRICER_SHARE :
        }
            break ;
            }
                pso->readF( tinBaseP , &bnu , 1 , flSOCKETcrEAD_STILLhUNGRYiSoK ) ;
                ZE( byteT , bnu ) ;

                etThread.delF( tinBaseP , pcPart ) ;
                etThread.strokeF( tinBaseP , TF4(mPrice,flFORMAT_EXPONENT,2,6)+T("  ")+TF3(qty,flFORMAT_UNSIGNED,8)+T("  ")+TF1(pcPart)+T("\r\n") ) ;
                pso->writeF( tinBaseP , (byteT*)&mPrice , sizeof mPrice ) ;
                b_pPricer.ungrabF( tinBaseP ) ;
                measureT mPrice = pPricer->priceF( tinBaseP , pcPart , qty ) ;
                b_pPricer.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                pso->readF( tinBaseP , (byteT*)&qty , sizeof qty ) ;
                ZE( countT , qty ) ;

                if( pcPart ) pcPart[ ccPart ] = 0 ;
                pso->readF( tinBaseP , (byteT*)pcPart , sizeof( countT ) * ccPart ) ;
                etThread.newF( tinBaseP , LF , pcPart , ccPart + 1 ) ; ___( pcPart ) ;
                ZE( countT* , pcPart ) ;
            {
            if( !ether && !etThread && ccPart )
            pso->readF( tinBaseP , (byteT*)&ccPart , sizeof ccPart ) ;
            ZE( countT , ccPart ) ;
        {
        case idCMDpRICER_PRICE :
    {
    switch( idCmd )
    pso->readF( tinBaseP , (byteT*)&idCmd , sizeof idCmd ) ;
    ZE( countT , idCmd ) ;

    }
        etThread.osSleepF( tinBaseP , TOCK * 4 ) ;
        etThread.strokeF( tinBaseP , T("waiting for a pricerC object to be constructed\r\n") ) ;
    {
    while( !ether && !etThread && !pPricer )

    pso->etherF( tinBaseP , etThread ) ;
    batonC&   b_pPricer = *(batonC*)  pTaskP->c3 ;
    pricerC*& pPricer   = *(pricerC**)pTaskP->c2 ;
    socketC*  pso       = (socketC*)  pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmServePriceF )

/*1*/WAKEhIDE( "city.price.authority" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

