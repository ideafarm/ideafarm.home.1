
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    }
        etThread.delF( tin0P , pc2pbcb ) ;
        etThread.delF( tin0P , *(byteT**)&pc2pbcb->c1 ) ;
    {
    if( pc2pbcb )
    count2S*& pc2pbcb = *(count2S**)&(countT&)swImage ;
    psttLever = (strokeS*)swImage.leverF( tin0P , idf ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
countT cFlavors = swImage.cFlavorsF( tin0P ) ;

}
    while( cDone < idClient ) { ++ s ; thirdC::dosSleepIF( tin0P , TUCK * 0x40 ) ; }
    ZE( countT , ecz ) ;
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
{

}
    *((tin123S&)tin0P).zEtScratch = 0 ;
    }
        }
            else           { ZE( countT , tnu ) ; ((tin123S&)tin0P).zEtScratch->osThreadF( tin0P , tnu , tmFtpServeF , 0 , 0  , flTHREADlAUNCH_null , 0 , 0 , (countT)pso , ++ idClient , (countT)&cDone , (countT)&psttLever , (countT)&swImage ) ; }
            if( *((tin123S&)tin0P).zEtScratch ) { DEL( pso ) ; }
            socket.acceptF( tin0P , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
            ZE( countT , idPortPeer ) ;
            nicNameC nnPeer ;
            ZE( socketC* , pso ) ;
        {
        while( !cQuit && !*((tin123S&)tin0P).zEtScratch )

        socket.listenF( tin0P ) ;
        __( socket.bindF( tin0P , ifcPORToLD2_IFCfTP ) - ifcPORToLD2_IFCfTP ) ;
        socketC socket( tin0P , *((tin123S&)tin0P).zEtScratch , TAG( TAGiDnULL ) ) ;
    {
    while( !cQuit && !*((tin123S&)tin0P).zEtScratch )
{
while( !cQuit )
ZE( countT , cDone ) ;
ZE( countT , idClient ) ;
const countT& cQuit = ether ;
ZE( const countT , cQuitNU ) ;
switchC swImage( tin0P , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttLever ) ;
ZE( strokeS* , psttLever ) ;

TODO

DONE( tmFtpServeF )

}
    cDone ++ ;

    DEL( pso ) ;
    }
        etThread = 0 ;
        TELL( "cleaning up" )
        }
            ++ s ; etThread.osSleepF( tin0P , TUCK * 0x80 ) ; //AS COURTESY
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
        {
        //pso->readF( tin0P , &bIn , 1 ) ;
        TELL( "cleaning up: waiting for client to write a byteT so that it can disconnect" )
        ZE( byteT , bIn ) ;
    {
    if( !etThread )

    pso->writeF( tin0P , sOut ) ;
    sOut.shiftLeftF( tin0P , ifcIDtYPEsOULiTEM_byteTptr , pbi , cbi ) ;
    sOut << cbRemaining ;
    soulC sOut( tin0P , TAG( TAGiDnULL ) ) ;

    }
        if( !cbi ) pbi = 0 ;
        }
            cbi = cbw ;
            cbRemaining = cbi - cbw ;
        {
        if( cbi > cbw )
        cbi = offw < cbi ? cbi - offw : 0 ;
        pbi = offw < cbi ? pbi + offw : 0 ;
        pbcbF( tin0P , etThread , pbi , cbi , tName , psttLever , swImage ) ;
    {
    ZE( countT , cbRemaining ) ;
    ZE( countT , cbi ) ;
    ZE( byteT* , pbi ) ;

    }
        ((tin123S&)tin0P).zEtScratch->delF( tin0P , psttw ) ;
        tName = T(psttw) ;
        sIn >> cbw ; // CAN BE 0 (CLIENT WOULD DO THIS TO QUERY FOR FILE SIZE)
        sIn >> offw ;
        sIn >> psttw ;
        ZE( strokeS* , psttw ) ;
        pso->readF( tin0P , sIn ) ;
        soulC sIn( tin0P , TAG( TAGiDnULL ) ) ;
    {
    TN( tName , "" ) ;
    ZE( countT , cbw ) ;
    ZE( countT , offw ) ; // "w": "wanted"

    pso->etherF( tin0P , *((tin123S&)tin0P).zEtScratch ) ;

    switchC&  swImage   =  *(switchC*)pTaskP->c5 ;
    strokeS*& psttLever = *(strokeS**)pTaskP->c4 ;
    countT&   cDone     =   *(countT*)pTaskP->c3 ;
    countT    idClient  =             pTaskP->c2 ;
    socketC*  pso       =   (socketC*)pTaskP->c1 ;
    TELL( "setting up" )
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmFtpServeF )

}
    __Z( pbP ) ;
    swImageP.ungrabF( tin0P ) ;
    }
        cbP =         pc2pbcb->c2 ;
        pbP = (byteT*)pc2pbcb->c1 ;
    {
    if( pc2pbcb )
    __Z( pc2pbcb ) ;

    }
        }
            *((tin123S&)tin0P).zEtScratch = 0 ;
            DEL( pInfo ) ;
            }
                ((byteT*)pc2pbcb->c1)[ cba ] = 0 ;
                ((tin123S&)tin0P).zEtScratch->fileReadF( tin0P , (byteT*)pc2pbcb->c1 , cba , handle ) ;
                countT cba = pc2pbcb->c2 ;
                etThread.newF( tin0P , LF , *(byteT**)&pc2pbcb->c1 , pc2pbcb->c2 + 1 ) ; ___( pbP ) ;
                pc2pbcb->c2 = pInfo->cbUsed ;
            {
            if( pInfo )
            ((tin123S&)tin0P).zEtScratch->diskFileQueryF( tin0P , pInfo , handle ) ; ___( pInfo ) ;
            ((tin123S&)tin0P).zEtScratch->fileOpenF( tin0P , handle , idr , T(psttNameP) , ifcOPENaCCESS_R , ifcOPENsHARE_WR , flOPENdETAILS_FAIL , ifcOPENhOW_nFeO , flFILEaTTR1_null , flFILEaTTR2_null , 0 , 1 ) ;
            ZE( infoFileS* , pInfo ) ;
            ZE( countT , idr ) ;
            handleC handle( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILE ) ;
            *((tin123S&)tin0P).zEtScratch = 0 ;
        {
        if( pc2pbcb )
        etThread.newF( tin0P , LF , pc2pbcb ) ; ___( pc2pbcb ) ;
    {
    if( !pc2pbcb )
    count2S*& pc2pbcb = *(count2S**)&(countT&)swImageP ;
    psttLeverP = psttNameP ;
    swImageP.grabF( tin0P , TAG( TAGiDnULL ) ) ;
{
voidT pbcbF( tin0S& tin0P , etherC& etThread , byteT*& pbP , countT& cbP , strokeS* psttNameP , strokeS*& psttLeverP , switchC& swImageP )

/*1*/WAKEhIDE( "tool.server.blob" )/*1*/
/**/
*/
 keep a file cache permanently in memory, using a switch
int specs
  pb
  cb
 outgoing soul
  cbWanted
  offset to begin
  blob name
 incoming soul
protocol
i serve blobs
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

