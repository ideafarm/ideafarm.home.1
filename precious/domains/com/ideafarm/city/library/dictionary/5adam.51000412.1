
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.strokeF( tin0P , T("ok\r\n") ) ;
etThread.delF( tin0P , postx ) ;
etThread.boxPutF( tin0P , T("///ideafarm/precious/domains/com/ideafarm/city/library/snip/")+T(psttFileFrom)+T(".h") , postx , costx ) ;
etThread.delF( tin0P , pstto ) ;
//etThread.strokeF( tin0P , pstto ) ;
countT costx = etThread.strMakeF( tin0P , LF , postx , pstto ) ; ___( postx ) ;
ZE( osTextT* , postx ) ;

etThread.delF( tin0P , pstti ) ;
}
    }
        etThread.delF( tin0P , psttl ) ;
        }
            etThread.delF( tin0P , pstt1w ) ;
            }
                etThread.delF( tin0P , psttOldCode ) ;
                etThread.delF( tin0P , psttTitle ) ;
                etThread.strFuseF( tin0P , pstto , T(psttOldCode)+T(" , \"")+T(psttTitle)+(idf?T("\" ,\r\n"):T("\"\r\n")) ) ; ___( pstto ) ;

                }
                    }
                        }
                            else           { etThread.strMakeF( tin0P , LF , psttOldCode  , psttc1 ) ; ___( psttOldCode ) ; }
                            }
                                etThread.strWordF( tin0P , psttTitle , psttc1 , sttq2 , sttu , 2 ) ; ___( psttTitle ) ;
                            {
                            if( idw == 2 )
                            //sttq2 = ze ;
                            countT idf2 = 1 ;
                        {
                        if( ++ idw > 1 )
                    {
                    FORsTRINGSiN1( pstt1w )
                    ZE( countT , idw ) ;
                {
                ZE( strokeS* , psttOldCode  ) ;
                ZE( strokeS* , psttTitle ) ;
            {
            if( cWords == 3 )
            countT cWords = etThread.strWordsOldF( tin0P , pstt1w , psttl , sttq ) ; ___( pstt1w ) ;
            strokeS sttq ;
            ZE( strokeS* , pstt1w ) ;
        {
        if( psttl )
        etThread.strSubstringLineF( tin0P , psttl , idf , sttq , pstti ) ; ___( psttl ) ;
        ZE( strokeS* , psttl ) ;
    {
    while( idf && !etThread )
    strokeS sttu('_') ;
    strokeS sttq2( (countT)0 , sc_IGNOREqUOTES ) ;
    countT idf2 = 1 ;
    //sttq = ze ;
    idf = 1 ;

    etThread.strMakeF( tin0P , LF , pstto , T("") , csttSnip ) ; ___( pstto ) ;
{
ZE( strokeS* , pstto ) ;

__( pstti && !pstti->idAdam ) ;
__Z( pstti ) ;
__( idClass - 3 ) ;
etThread.delF( tin0P , psttSnip ) ;
countT csttSnip = psttSnip ? psttSnip->idAdam : 0 ;

while( !etThread && idClass && idClass != 3 ) ;
}
    etThread.strSubstringDelimitedF( tin0P , pstti , idClass , idf , sttq , psttSnip ) ; ___( pstti ) ;
    idClass = 0 ;
    etThread.delF( tin0P , pstti ) ;
{
do
strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
countT idf = 1 ;
ZE( countT , idClass ) ;
ZE( strokeS* , pstti ) ;

}
    //etThread.traceF( tin0P , psttSnip , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    //etThread.traceF( tin0P , T("snip:") ) ;
    //etThread.boxPutF( tin0P , T("///d/tmp/foo.ttt") , tSnip2 , tSnip2.csF( tin0P ) ) ;
    //TN( tSnip2 , psttSnip ) ;
    etThread.strSubstringF( tin0P , psttSnip , idf , sttq , psttFileFrom , tIn ) ; ___( psttSnip ) ;
    etThread.delF( tin0P , psttSnip ) ;
    //etThread.boxPutF( tin0P , T("///d/tmp/foo.ttt") , tSnip1 , tSnip1.csF( tin0P ) ) ;
    //TN( tSnip1 , psttSnip ) ;
    //etThread.traceF( tin0P , psttSnip , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    //etThread.traceF( tin0P , T("snip:") ) ;
    etThread.strSubstringF( tin0P , psttSnip , idf , sttq , psttFileFrom , tIn ) ; ___( psttSnip ) ;
    strokeS sttq( (countT)0 , sc_IGNOREqUOTES ) ;
    countT idf = 1 ;

    etThread.delF( tin0P , posti ) ;
    TN( tIn , posti ) ;    
    etThread.boxGetShadowF( tin0P , posti , costi , T("///ideafarm/precious/domains/com/ideafarm/city/library/snip/ipdos.h") ) ; ___( posti ) ;
    ZE( countT   , costi ) ;
    ZE( osTextT* , posti ) ;
{
ZE( strokeS* , psttSnip ) ;

etThread.traceF( tin0P , T("[psttFileFrom]:    ")+T(psttFileFrom) ) ;

__Z( psttFileFrom ) ;
}
    }
        else if( !psttFileFrom ) psttFileFrom = psttc1 ;
        if( cSkip && cSkip -- ) ;
        etThread.traceF( tin0P , T("param: \"")+T(psttc1)+T("\"\r\n") ) ;
    {
    FORsTRINGSiN1( pstt1p )
    countT cSkip = 4 ;
    ZE( countT , ids ) ;
    strokeS* const pstt1p = etThread.ether_pstt1_processParametersI_F( tin0P ) ;
{
ZE( const strokeS* , psttFileFrom ) ;

CONoUTrAW( "SYMBOL LOOKUP TABLE\r\n" ) ;

TODO

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_SYMBOLtABLE" )/*1*/
/**/
*/
writes a lookup array file from a snip file
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

