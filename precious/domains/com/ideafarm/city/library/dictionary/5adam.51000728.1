
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.osThreadSwitchingDesireF( tin0P , idDesireSave ) ;

}
    }
        }
            while( cFail ) ;
            }
                if( cFail ) { ++ s ; ether.osSleepF( tin0P , TOCK ) ; }

                FORsTRINGSiNsPANNEDcOMBINEDtAIL1
                }
                    }
                        }
                            etThread.osThreadF( TaRG1( tmObeySoilF ) , (countT)&cFail , (countT)(strokeS*)tPickSoil , (countT)(strokeS*)tBounce , (countT)psttFileName , (countT)posti , costi ) ; psttFileName = 0 ; posti = 0 ;
                            etThread.strMakeF( tin0P , LF , psttFileName , tFileBeingEaten ) ; ___( psttFileName ) ;
                            ZE( strokeS* , psttFileName ) ;
                        {
                        else
                        else if( !costi ) etThread.delF( tin0P , posti ) ;
                        }
                            CONoUTrAW( T("could not input ")+tFileBeingEaten+T(" ; will nap, then retry\r\n") ) ;
                            cFail ++ ;                                                                                  // INCREMENT cFail
                            POOPR
                        {
                        if( POOP )                                                                                  // IF COULD NOT GET THE FILE

                        ((tin1S&)tin0P).pEtScratch->boxGetShadowF( tin0P , posti , costi , tFileBeingEaten , 1 ) ; ___( posti ) ;        // GET THE FILE
                        ZE( countT   , costi ) ;
                        ZE( osTextT* , posti ) ;
                        SCOOPS

                        }
                            if( POOP ) POOPR
                            ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tFileBeingEaten , psttc1 , 1 ) ;

                            etThread.delF( tin0P , psttShort ) ;
                            etThread.delF( tin0P , psttPath ) ;
                            tFileBeingEaten = tEatingSoil+T(psttShort) ;
                            ___( psttShort ) ;
                            ___( psttPath ) ;
                            countT ids = etThread.etherC::strBisectF( tin0P , psttPath , psttShort , psttc1 , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttPath ) ;
                        {
                        TN( tFileBeingEaten , "" ) ;
                    {
                    if( psttc1[ CSpREFIX - 1 + psttc1->idAdam ].idAdam != '/' )                                 // IF NOT DIRECTORY

                    //CONoUTrAW( T("inspecting: ")+T(psttc1)+T("\r\n") ) ;
                {
                FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
                etThread.boxMenuF( tin0P , soul1m , tDropSoil+T("*.soil") , 0 , TUCK ) ; // FOR ALL FILES OR DIRS "*.soil"
                soulC soul1m( tin0P , TAG( TAGiDnULL ) , flSOUL_null , "soul.eat.menu" ) ;

                cFail = 0 ;
            {
            do
            ZE( countT , cFail ) ;
            sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

            if( bWoth ) bWoth = 0 ;
        {
        if( etThread.etherC::diskWaitDirF( tin0P , hWait , ether , tDropSoil , flWAITdIR_FILEnAME ) || bWoth )
    {
    while( !ether && !POOP )
    handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    boolT bWoth = 1 ;
{
IFsCRATCH

const countT idDesireSave = etThread.osThreadSwitchingDesireF( tin0P , ifcTHREADpRIORITY_LAZIER ) ;

}
    //ether.osThread AdamF( tin0P , ifcIDaDAM_ROOThTTPsERVER ) ;
    //THIS IS THE WO TO USE, BUT ONLY IF MASTER: ether.ifcHireF( tin0P , T("U::TO FIND A WINDOWS RESOURCE LEAK") , ifcIDaDAM_ROOThTTPsERVER , T("!ignoreFireByOperator") , flHIRE_DISPLAYaUTO , nicNameC() ) ; //U:: TO FIND A WINDOWS RESOURCE LEAK
{
if( !etThread.strCompareF( tin0P , tComputerName , T("ifo.master") ) )

ether.osThreadF( TaRG1( tmHireF ) ) ;

etThread.osThreadF( TaRG1( tmCleanF ) , (countT)(strokeS*)tBounce , (countT)(strokeS*)tDropSoil ) ;
//etThread.osThreadF( TaRG1( tmPingF ) ) ; //U::COMMENTED OUT BECAUSE SAW A FAILURE IN s_writeF 20121219@2102

etThread.osThreadF( TaRG1( tmFixArcNamesF ) ) ; // REDUNDANT, JUST IN CASE A FILE WITH A BAD NAME HAS GOTTEN INTO THE ARCHIVE ; U::ADD bQuitP PARAMETER

}
    etThread.osThreadF( TaRG1( tmRenameF ) , (countT)psttDropIn , (countT)psttNeverDropHere ) ;

    etThread.strMakeF( tin0P , LF , psttNeverDropHere , tNeverDropHere ) ; ___( psttNeverDropHere ) ;
    etThread.strMakeF( tin0P , LF , psttDropIn , tDropIn ) ; ___( psttDropIn ) ;
    ZE( strokeS* , psttNeverDropHere ) ;
    ZE( strokeS* , psttDropIn ) ;
{

//) ;
//
//    "If you generate too much of data within a single quarter, divide the quarter into 2 or 4 or 8 reporting periods.\r\n"
//    "When each quarter ends, use a final version of the file for that quarter to obtain IdeaFarm " "(tm) Hoe reports for that quarter.\r\n"
//    "Workaround: Limit your input file to data for the current IdeaFarm " "(tm) City calendar quarter.\r\n"
//    "\r\n"
//    "IPDOS (tm) will not realize this architectural potential until it is ported to the 04 bit cpu architecture.\r\n"
//    "IPDOS (tm) is designed to run quickly and efficiently on 04 bit (64_9 bit) computers with lots of memory available.\r\n"
//    "The file that you have dropped is larger than ")+TF2(costiMax,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T(" bytes (")+TF4(costiMax,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,0,0xa)+T(" bytes).\r\n"
//    "\r\n"
//    "Error: The input file is too large.\r\n"
//
//TN( tErrorFileTooBig , "" ) ; tErrorFileTooBig = T(
//const countT costiMax = CSTTmAXsOIL ;

}
    }
        }
            etThread.diskMakeDirF( tin0P , *pptDir[ offi ] ) ;
            cMade ++ ;
        {
        )
            )
                )
                    offi != 4
                    &&
                    offi != 3
                (
                ||
                !cMade
            (
            &&
            !etThread.diskFileExistsF( tin0P , *pptDir[ offi ] )
        (
        if
    {
    for( countT offi = 0 ; offi < sizeof pptDir / sizeof pptDir[ 0 ] ; offi ++ )
    ZE( countT , cMade ) ;

    //20140415@1204: DISABLED THIS SO WILL CREATE ANY MISSING FOLDERS: if( !etThread.diskFileExistsF( tin0P , tBounce ) )

    } ;
        &tPickSoil        // 9
        &tPickToProcess , // 8
        &tEatingSoil    , // 7
        &tDropSoil      , // 6
        &tDropIn2       , // 5
        &tDropIn1       , // 4 OPTIONAL: NOT CREATED UNLESS NONE EXIST
        &tDropIn        , // 3 OPTIONAL: NOT CREATED UNLESS NONE EXIST
        &tNeverDropHere , // 2
        &tDropArchive   , // 1
        &tBounce        , // 0
    {
    textC* pptDir[] =
{
TN( tPickSoil      , "///ideafarm/IdeaFarm " "(tm)/" ) ; tPickSoil      += tUser+T("/1.4. Pick Up Completed SOIL (tm) Text Files Here/"             ) ;
TN( tPickToProcess , "///ideafarm/IdeaFarm " "(tm)/" ) ; tPickToProcess += tUser+T("/2.2. Filesets Awaiting Flushing To An Archive/"     ) ;
TN( tEatingSoil    , "///ideafarm/IdeaFarm " "(tm)/" ) ; tEatingSoil    += tUser+T("/1.2. SOIL (tm) Text Files Being Eaten/"                    ) ;
TN( tDropSoil      , "///ideafarm/IdeaFarm " "(tm)/" ) ; tDropSoil      += tUser+T("/1.1. Drop a Copy of SOIL (tm) Text Files Here/"            ) ;
TN( tDropIn2       , "///ideafarm/IdeaFarm " "(tm)/" ) ; tDropIn2       += tUser+T("/2.1. Drop Files Here To Archive Them/voice.recorder/") ;
TN( tDropIn1       , "///ideafarm/IdeaFarm " "(tm)/" ) ; tDropIn1       += tUser+T("/2.1. Drop Files Here To Archive Them/camera/"        ) ;
TN( tDropIn        , "///ideafarm/IdeaFarm " "(tm)/" ) ; tDropIn        += tUser+T("/2.1. Drop Files Here To Archive Them/"               ) ;
TN( tNeverDropHere , "///ideafarm/IdeaFarm " "(tm)/" ) ; tNeverDropHere += tUser+T("/never.drop.here/"                               ) ;
TN( tDropArchive   , "///ideafarm/IdeaFarm " "(tm)/" ) ; tDropArchive   += tUser+T("/2.1. Drop Files Here To Archive Them/"                    ) ;
TN( tBounce        , "///ideafarm/IdeaFarm " "(tm)/" ) ; tBounce        += tUser+T("/1.3. Pick Up Rejected SOIL (tm) Text Files Here/"                   ) ;

TN( tDesk         , "///ideafarm/IdeaFarm " "(tm)/"  ) ;
TN( tUser         , thirdC::postUserNameIF() ) ;

}
    etThread.delF( tin0P , psttName ) ;
    if( psttName && psttName->idAdam ) tComputerName = T(psttName) ;

    //U::CALL THIS ONLY IF SETTINGS FILES EXIST: etThread.querySettingF( tin0P , psttName , T("computer.name") ) ;
    ZE( strokeS* , psttName ) ;

    TN( tHome , "" ) ; tHome = T("///d/ideafarm.home.")+TF2(etherC::ifc_idHomeIdisk_IF(),flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ;
{
TN( tComputerName , "" ) ;

TODO

DONE( tmFixArcNamesF )
etThread.traceF( tin0P , T("archive: fixed  bad file names, if any") ) ;
etThread.disk FixBadFileNamesF( tin0P , T("///ideafarm/IdeaFarm " "(tm)/")+T(thirdC::postUserNameIF())+T("/2.1. Drop Files Here To Archive Them/") ) ;
etThread.traceF( tin0P , T("archive: fixing bad file names, if any") ) ;
TASK( tmFixArcNamesF )

DONE( tmHireF )

//ether.ifcHireF( tin0P , T("PISS") , ifcIDaDAM_CLOUD , T("!ignoreFireByOperator") ) ;

++ s ; ether.osSleepF( tin0P , TOCK << 4 ) ;  // ENOUGH TIME SO THAT I WILL BE ABLE TO PROCESS A SETTINGS UPDATE
sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

TASK( tmHireF )

DONE( tmObeySoilF )
etThread.traceF( tin0P , T("thread exit") ) ;
}
    etThread.delF( tin0P , postiP ) ;
    etThread.delF( tin0P , psttFileNameP ) ;
    etThread.delF( tin0P , psttShort ) ;
    etThread.delF( tin0P , psttPath ) ;
    }
        }
            }
                inc02AM( cFailP ) ;                                                                     // INCREMENT cFail
                POOPR
            {
            if( POOP )                                                                                  // IF COULD NOT MOVE UNIQUE
            etThread.delF( tin0P , psttn ) ;
            ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirUniqueF( tin0P , psttn , psttFileNameP , 0 , 1 ) ;                    // MOVE UNIQUE TO ANUS
        
            etThread.strMakeF( tin0P , LF , psttn , tTo , TUCK+tShort.csF( tin0P ) ) ; ___( psttn ) ;
            ZE( strokeS* , psttn ) ;
        
            POOPR
        {
        if( POOP )                                                                                  // IF COULD NOT MOVE TO ANUS
        ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tTo+tShort , psttFileNameP , 1 ) ;                     // MOVE TO ANUS
        etThread.traceF( tin0P , T("cleaning up") ) ;

        }
            }
                }
                    }
                        }
                            etThread.delF( tin0P , postr ) ;
                            etThread.fileWriteF( tin0P , hFile1 , postr , costr ) ;
                        
                            etThread.delF( tin0P , psttr ) ;
                            countT costr = etThread.strMakeF( tin0P , LF , postr , psttr ) ; ___( postr ) ;
                            ZE( osTextT* , postr ) ;
                    
                            soulAsciiOut >> psttr ; ___( psttr ) ;
                            ZE( strokeS* , psttr ) ;
                        {
                        while( soulAsciiOut )
                        OPENfILEwRITE1( tTo+T("poop.")+tShort )
                    {
                    tTo = tPickSoil ;                                                                              // POINT TO BLOOD
                    etThread.traceF( tin0P , T("writing pseudoduplicate file of input file from soulAsciiOut") ) ;
                    
                    etThread.etherSoilF( tin0P , ether , soulAsciiOut , soulNativeLint , ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE , 0 , flETHERsOILf_CONSUMEiNPUT ) ;
                    soulC soulAsciiOut( tin0P , TAG( TAGiDnULL ) , flSOUL_null , "soul.ascii.out" ) ; //THIS IMAGE SHOULD BE IDENTICAL TO THE LINT IMAGE IF NO MARKS, SO THIS STEP COULD BE ELIMINATED; WE DO IT THIS WAY BECAUSE, OTHER THAN SOME MORE CODE, IT IS COSTLESS AND CONFIDENCE OF CORRECTNESS IS HIGHER (LINT MARKUP CODE IS COMPLEX SO MIGHT CONTAIN BUGS)
                    etThread.traceF( tin0P , T("loading soulAsciiOut") ) ;
                {
                if( soulNativeLint )
                // TAKES A LOT OF TIME AND I DO NOT NEED IT, EXCEPT WHEN DEBUGGING SOIL REPLACEMENTS

                }
                    }
                        etThread.delF( tin0P , postr ) ;
                        etThread.fileWriteF( tin0P , hFile1 , postr , costr ) ;
                    
                        etThread.delF( tin0P , psttr ) ;
                        countT costr = etThread.strMakeF( tin0P , LF , postr , psttr ) ; ___( postr ) ;
                        ZE( osTextT* , postr ) ;
            
                        soulr >> psttr ; ___( psttr ) ;
                        ZE( strokeS* , psttr ) ;
                    {
                    while( soulr )
                    OPENfILEwRITE1( tPickSoil+tPrefix+tFile+tSuffix )
            
                    etThread.traceF( tin0P , T("loading soulReports / [cFields,tFile]: ")+TF2((countT)soulr,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    \"")+tFile+T("\"") ) ;
                    soulReports >> soulr ;
                    soulC soulr( tin0P , TAG( TAGiDnULL ) , flSOUL_null , "soul.report" ) ;
            
                    etThread.delF( tin0P , psttf ) ;
                    tFile = T(psttf) ;
                    soulReports >> psttf ; ___( psttf ) ;
                    ZE( strokeS* , psttf ) ;
                    etThread.traceF( tin0P , T("writing report file") ) ;
                {
                while( soulReports )
                TN( tFile , "" ) ;
                TN( tSuffix , ".soil" ) ;
                TN( tPrefix , "report." ) ;
                TN( tn , "" ) ;
            
                DEL( ((tin1S&)tin0P).pBarryUtility ) ;
                while( !ether && !POOP && etThread.etherSoilF( tin0P , ether , soulReports , soulNativeLint , ifcIDmODEeTHERsOIL_REPORT /*, 0 , flETHERsOILf_CONSUMEiNPUT*/ ) ) ; // WHILE IS TO OBEY bRepeat ; WILL REPEAT FOREVER UNTIL I AM FIRED
                do     soulReports.removeAllF( tin0P ) ;

                etThread.traceF( tin0P , T("loading soulReports / calling etherSoilF") ) ;
                //TO GET REPORTS, COMMENT OUT THE CONSUMEiNPUT FLAG

                soulC soulReports( tin0P , TAG( TAGiDnULL ) , flSOUL_null , "soul.reports" , CBjOTbOOKwRAPPER( CBjOTbOOKdEFAULT , 1 ) ) ;
                etThread.traceF( tin0P , T("loading soulReports") ) ;
            {
            else
            }
                }
                    }
                        etThread.delF( tin0P , postr ) ;
                        etThread.fileWriteF( tin0P , hFile1 , postr , costr ) ;
                    
                        etThread.delF( tin0P , psttr ) ;
                        countT costr = etThread.strMakeF( tin0P , LF , postr , psttr ) ; ___( postr ) ;
                        ZE( osTextT* , postr ) ;

                        soulAsciiLint >> psttr ; ___( psttr ) ;
                        ZE( strokeS* , psttr ) ;
                    {
                    while( soulAsciiLint )
                    OPENfILEwRITE1( tTo+T("poop.")+tShort )
                {
                tTo = T(psttzBounceP) ;                                                                               // POINT TO ANUS
                etThread.traceF( tin0P , T("abort: writing poop file") ) ;

                //}
                //    etThread.delF( tin0P , psttp ) ;
                //    etThread.strokeF( tin0P , T("[part]: \"")+T(psttp)+T("\"\r\n") ) ;
                //    soulAsciiLint >> psttp ; ___( psttp ) ;
                //    ZE( strokeS* , psttp ) ;
                //{
                //while( soulAsciiLint )
                //U:: TO FIND A BUG

                etThread.etherSoilF( tin0P , ether , soulAsciiLint , soulNativeLint , ifcIDmODEeTHERsOIL_ASCIIfROMnATIVE , 0 , flETHERsOILf_CONSUMEiNPUT ) ;
                soulC soulAsciiLint( tin0P , TAG( TAGiDnULL ) , flSOUL_null , "soul.ascii.lint" ) ;
                etThread.traceF( tin0P , T("abort: loading soulAsciiLint") ) ;
                DEL( ((tin1S&)tin0P).pBarryUtility ) ;
            {
            if( bAbort )

            }
                bAbort = !!etThread.etherSoilF( tin0P , ether , soulNativeLint , soulNativeIn , ifcIDmODEeTHERsOIL_LINT , 0 , flETHERsOILf_CONSUMEiNPUT ) ;
                etThread.traceF( tin0P , T("loading soulNativeLint and calculating bAbort") ) ;

                }
                    etThread.etherSoilF( tin0P , ether , soulNativeIn , soulPrepared , ifcIDmODEeTHERsOIL_NATIVEfROMaSCII , 0 , flETHERsOILf_CONSUMEiNPUT ) ;
                    etThread.traceF( tin0P , T("loading soulNativeIn") ) ;

                    //}
                    //    //LOGrAW( "\r\n---- PREPARED: (END) ----\r\n" ) ;
                    //    }
                    //        etThread.delF( tin0P , psttp ) ;
                    //        LOGrAW( T(psttp) ) ;
                    //        soulPrepared << psttp ;
                    //        soulTmpDebug >> psttp ; ___( psttp ) ;
                    //        ZE( strokeS* , psttp ) ;
                    //    {
                    //    while( soulTmpDebug )
                    //    //LOGrAW( "\r\n---- PREPARED: (BEGIN) ----\r\n" ) ;
                    //
                    //    }
                    //        etThread.delF( tin0P , psttp ) ;
                    //        soulTmpDebug << psttp ;
                    //        soulPrepared >> psttp ; ___( psttp ) ;
                    //        ZE( strokeS* , psttp ) ;
                    //    {
                    //    while( soulPrepared )
                    //    soulC soulTmpDebug( tin0P , TAG( TAGiDnULL ) , flSOUL_null , "soul.tmp.debug" ) ;
                    //{
                    //U::COMMENT OUT IN PRODUCTION

                    }
                        }
                            }
                                }
                                    }
                                        etThread.delF( tin0P , psttp ) ;
                                        soulAsciiIn << psttp ;
                                        soulPrepared >> psttp ; ___( psttp ) ;
                                        ZE( strokeS* , psttp ) ;
                                    {
                                    while( soulPrepared )
                                    etThread.traceF( tin0P , T("pouring for another pass [idPass,soulPrepared]: ")+TF2(idPass,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("    ")+TF2((countT)soulPrepared,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                                {
                                else
                                if( !etThread.etherSoilF( tin0P , ether , soulPrepared , soulAsciiIn , ifcIDmODEeTHERsOIL_PREPAREsOURCE , 0 , flETHERsOILf_CONSUMEiNPUT ) ) break ;
                                etThread.traceF( tin0P , T("loading soulPrepared [idPass]: ")+TF2(idPass,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                            {
                            for( countT idPass = 1 ; ; idPass ++ )
                        {
                        etThread.traceF( tin0P , T("loading soulPrepared") ) ;

                        }
                            etThread.delF( tin0P , postiP ) ; costiP = 0 ;                                                 // REPLACE INPUT FILE
                            }
                                etThread.delF( tin0P , pstti ) ;
                                etThread.strFuseF( tin0P , soulAsciiIn , pstti , 0 , S1C( '\\' ) , T("[]") ) ;

                                postzBite += costBite ;
                                etThread.strMakeFromOsTextF( tin0P , pstti , postzBite , costBite ) ; ___( pstti ) ;
                                ZE( strokeS* , pstti ) ;                                                                  // INSPECT AND PERHAPS ANNOTATE

                                cDo -= costBite ;
                                while( postzBite[ costBite - 1 ] == '\\' ) costBite -- ; // LATH MUST NOT BE ESCAPE CHAR
                                countT costBite = cDo <= TOCK ? cDo : TOCK ;

                                etThread.traceF( tin0P , T("loading soulAsciiIn [cDo]: ")+TF2(cDo,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES) ) ;
                            {
                            while( cDo )
                            osTextT* postzBite = postiP ;
                            countT cDo = costiP ;
                        {
                        else
                        }
                            etThread.delF( tin0P , pstti ) ;
                            etThread.strFuseF( tin0P , soulAsciiIn , pstti , 0 , S1C( '\\' ) , T("[]") ) ;

                            etThread.delF( tin0P , postiP ) ; costiP = 0 ;                                                 // REPLACE INPUT FILE
                            etThread.strMakeFromOsTextF( tin0P , pstti , postiP , costiP ) ; ___( pstti ) ;
                            ZE( strokeS* , pstti ) ;                                                                  // INSPECT AND PERHAPS ANNOTATE
                        {
                        if( costiP <= TOCK )

                        soulC soulAsciiIn( tin0P , TAG( TAGiDnULL ) , flSOUL_null , "soul.ascii.in" ) ;
                        etThread.traceF( tin0P , T("loading soulAsciiIn") ) ;
                    {
                    soulC soulPrepared( tin0P , TAG( TAGiDnULL ) , flSOUL_null , "soul.prepared" ) ;
                {
                soulC soulNativeIn( tin0P , TAG( TAGiDnULL ) , flSOUL_null , "soul.native.in" ) ;
            {
            soulC soulNativeLint( tin0P , TAG( TAGiDnULL ) , flSOUL_null , "soul.native.lint" ) ;
            ZE( boolT , bAbort ) ;
        {
        //else
        //}
        //    etThread.boxPutF( tin0P , tTo+T("read.this.error.message.txt") , tErrorFileTooBig , tErrorFileTooBig.csF( tin0P ) ) ;
        //    tTo = T(psttzBounceP) ;
        //{
        //if( costiP > costiMax ) // NOTE 1: AVOIDING POOL OVERFLOW
        TN( tTo , "" ) ;
        TN( tShort , psttShort ) ;
        TN( tPickSoil , psttzPickSoilP ) ;
    {
    if( ids )
    countT ids = etThread.etherC::strBisectF( tin0P , psttPath , psttShort , psttFileNameP , T("/") , - 1 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
    ZE( strokeS* , psttShort ) ;
    ZE( strokeS* , psttPath ) ;

    ((tin1S&)tin0P).pBarryUtility = new( 0 , tin0P , LF ) barryC( tin0P ) ; ___( ((tin1S&)tin0P).pBarryUtility ) ;

    etThread.traceF( tin0P , T("setting up") ) ;

    countT   costiP                     =           pTaskP->c6 ;
    osTextT* postiP                     = (osTextT*)pTaskP->c5 ;
    strokeS* psttFileNameP              = (strokeS*)pTaskP->c4 ;
    const strokeS* const psttzBounceP   = (strokeS*)pTaskP->c3 ;
    const strokeS* const psttzPickSoilP = (strokeS*)pTaskP->c2 ;
    countT&  cFailP                     = *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmObeySoilF )

DONE( tmPingF )
}
    }
        ++ s ; ether.osSleepF( tin0P , TOCK ) ;
    
        sockPing.writeF( tin0P , ifcIDpORT_DOOR , nnCast , sOut ) ;
    {
    while( !ether && !POOP )
    sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
    
    sOut << (countT)1 ; //PING
    soulC sOut( tin0P , TAG( TAGiDnULL ) , flSOUL_null , "soul.ping.out" ) ;
    
    countT idPortMe = sockPing.bindF( tin0P ) ;
    socketC sockPing( tin0P , etThread , TAG( TAGiDnULL ) , ifcSOCKETtYPE_DATAgRAM , flSOCKETc_CANbROADCASToLDdOnOTuSE ) ;
    
    nicNameC nnCast = socketC::nicNameIF( tin0P , etThread , T("!broadcast") ) ;
{
if( pTaskP )
TASK( tmPingF ) // MAKE MYSELF VISIBLE TO OTHER PISS CELLS ON THE LAN

DONE( tmCleanF )
}
    }
        }
            }
                while( cFail ) ;
                }
                    if( cFail ) { ++ s ; ether.osSleepF( tin0P , TOCK ) ; }

                    FORsTRINGSiNsPANNEDcOMBINEDtAIL1
                    }
                        }
                            etThread.delF( tin0P , psttShort ) ;
                            etThread.delF( tin0P , psttPath ) ;
                            }
                                }
                                    }
                                        cFail ++ ;                                                                                  // INCREMENT cFail
                                        POOPR
                                    {
                                    if( POOP )                                                                                  // IF COULD NOT MOVE UNIQUE
                                    etThread.delF( tin0P , psttn ) ;
                                    ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirUniqueF( tin0P , psttn , psttc1 , 0 , 1 ) ;                    // MOVE UNIQUE TO ANUS
        
                                    etThread.strMakeF( tin0P , LF , psttn , tBounce , TUCK+tShort.csF( tin0P ) ) ; ___( psttn ) ;
                                    ZE( strokeS* , psttn ) ;
        
                                    POOPR
                                {
                                if( POOP )                                                                                  // IF COULD NOT MOVE TO ANUS
                                ((tin1S&)tin0P).pEtScratch->diskMoveFileOrDirF( tin0P , tBounce+tShort , psttc1 , 1 ) ;                   // MOVE TO ANUS
                                SCOOPS

                                TN( tShort , psttShort ) ;
                            {
                            if( ids )                                                                                   // IF HAVE PATH (ALWAYS TRUE)
                            countT ids = etThread.etherC::strBisectF( tin0P , psttPath , psttShort , psttc1 , tSlash , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttShort ) ;
                            ZE( strokeS* , psttShort ) ;
                            ZE( strokeS* , psttPath ) ;
                        {
                        if( psttc1[ CSpREFIX - 1 + psttc1->idAdam ].idAdam == '/' )                                 // IF DIRECTORY
                    {
                    FORsTRINGSiNsPANNEDcOMBINEDhEAD1( soul1m )
                    etThread.boxMenuF( tin0P , soul1m , tDrop+T("*") , 0 , TUCK ) ;
                    soulC soul1m( tin0P , TAG( TAGiDnULL ) , flSOUL_null , "soul.clean.menu" ) ;
                {
                do
                ZE( countT , cFail ) ;
                sleepC s( tin0P , TAG( TAGiDnULL ) ) ;

                if( bWoth ) bWoth = 0 ;
            {
            if( etThread.etherC::diskWaitDirF( tin0P , hWait , ether , tDrop , flWAITdIR_DIRnAME ) || bWoth )
        {
        while( !ether && !POOP )
        handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
        boolT bWoth = 1 ;
    {
    IFsCRATCH

    TN( tSlash , "/" ) ;    
    TN( tDrop , psttDropSoilP ) ;
    TN( tBounce  , psttBounceP  ) ;

    const strokeS* const psttDropSoilP = (strokeS*)pTaskP->c2 ;
    const strokeS* const psttBounceP   = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmCleanF )

DONE( tmRenameF )
}
    etThread.delF( tin0P , psttmDropIn ) ;
    }
        }
            CONoUTrAW5( "" , cDirs , " " , cFiles , "\r\n" ) ;
            etThread.diskWalkRenameForArchivalF( tin0P , cDirs , cFiles , ether , psttzTo , psttmDropIn , myCBF ) ;
            ZE( countT , cFiles ) ;
            ZE( countT , cDirs ) ;
    
            strokeS* psttzTo = tTo ;
            TN( tTo , "///ideafarm/IdeaFarm " "(tm)/" ) ; tTo += tUser+T("/2.2. Filesets Awaiting Flushing To An Archive/") ;

            if( bWoth ) bWoth = 0 ;
        {
        if( etThread.etherC::diskWaitDirF( tin0P , hWait , ether , psttmDropIn , flWAITdIR_RECURSE | flWAITdIR_FILEnAME | flWAITdIR_DIRnAME ) || bWoth )
    {
    while( !ether && !POOP )
    handleC hWait( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEwAIT ) ;
    boolT bWoth = 1 ;
    
    etThread.delF( tin0P , psttDropInP ) ;
    etThread.diskMapFileNameF( tin0P , psttmDropIn , psttDropInP ) ; ___( psttmDropIn ) ;
    ZE( strokeS* , psttmDropIn ) ;

    TN( tUser , thirdC::postUserNameIF() ) ;

    TN( tNeverDropHere , psttNeverDropHereP ) ;
    TN( tDropIn        , psttDropInP        ) ;

    strokeS* psttNeverDropHereP = (strokeS*)pTaskP->c2 ;
    strokeS* psttDropInP        = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmRenameF )

}
    return bDoIt ;
    boolT bDoIt = 1 ;
{
boolT myCBF( tin0S& tin0P , countT& cDirsP , countT& cFilesP , const osTextT* const postNameP , countT* const pcArgP )

// WHEN IPDOS (tm) IS PORTED TO 04 BIT HARDWARE, THE NEED FOR THIS LIMIT WILL VANISH
// THE HARDCODED LIMIT IS INTENDED TO SUFFICE FOR WO IFC QUARTER'S WORTH OF DATA
// THIS IS TO AVOID POOL OVERFLOW, WHICH OCCURS BECAUSE INPUT TEXT IS CONVERTED TO STRINGS OF strokeS
// IF AN EXCESSIVELY LARGE FILE IS DROPPED, IT WILL BOUNCE IMMEDIATELY TO THE ERROR FOLDER
//
// NOTE 1: AVOIDING POOL OVERFLOW

/*1*/WAKEsHOWtEXT( "was.scratch.3.archived.20180508@1202.ifcIDaDAM_PISS" )/*1*/

//WHEN DIFFERENT TYPES OF HARDWARE EXIST IN THE IPDOS CLOUD, THE FEATURE LIST WILL EXPAND TO INDICATE THE PRESENCE OR ABSENCE OF PARTICULAR CAPABILITIES SUCH AS TELEPHONY AND A FULL KEYBOARD AND LARGE DISPLAY
//IN THE FUTURE, THE TYPE OF THE HARDWARE WILL BE A FEATURE, TOO, DISTINGUISHING LAPTOP HARDWARE FROM SMARTPHONE HARDWARE
//ACCESS TO A HUMAN OPERATOR IS AN OPTIONAL "FEATURE", USING MICROSOFT'S TERMINOLOGY
//ALL LOGIN HOMES HAVE FULL ACCESS TO THE HARDWARE, BUT HARDWARE HOMES DO NOT HAVE ANY ACCESS TO A HUMAN OPERATOR
//BUT THE DISTINCTION IS TRANSPARENT TO ALL IPDOS FUNCTIONALITY INCLUDING INTERHOME COMMUNICATION
//HOMES IN THE IPDOS CLOUD ARE THUS OF OO TYPES
//EACH HARDWARE HOST HAS A HARDWARE HOME AND OPTIONALLY WO OR MORE LOGIN HOMES
//THIS IS SO THAT THE USER INTERFACE IS CLEAN
//U::WAKEhIDE FOR PRODUCTION

/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

