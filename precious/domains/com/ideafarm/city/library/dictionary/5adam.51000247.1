
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


//VISIBLE

REST
etThread.osProcessIdPhaseAdamF( tin0P , ifcIDpHASEhANDOFFoLD_SHUTTINGdOWN ) ;

HEAReNTER( ether )
etThread.strokeF( tin0P , T("press the enter key now\r\n") ) ;

sDone.waitF( tin0P ) ;
}
    sock.writeF( tin0P , &bCmd , 1 ) ;
    sock.connectF( tin0P , idPort , etThread.sockNicNameF( tin0P ) ) ;
    socketC sock( tin0P , ether , TAG( TAGiDnULL ) ) ;
{
bCmd = 'q' ;
}
    etThread.strokeF( tin0P , TF1(cValue)+T("\r\n") ) ;

    sock.readF( tin0P , (byteT*)&cValue , sizeof cValue ) ;
    sock.writeF( tin0P , &bCmd , 1 ) ;
    sock.connectF( tin0P , idPort , etThread.sockNicNameF( tin0P ) ) ;
    socketC sock( tin0P , ether , TAG( TAGiDnULL ) ) ;
{
while( cTries -- )
countT cTries = 0x8 ;
ZE( countT , cValue ) ;
byteT bCmd = 'n' ;

sReady.waitF( tin0P ) ;
{ ZE( countT , tnu ) ; etThread.osThreadF( tin0P , tnu , tmPushNumbersF , &sDone , flTHREADlAUNCH_null , 0 , 0 , (countT)&idPort , (countT)&sReady ) ; }
ZE( countT , idPort ) ;
signC sDone(  tin0P , TAG( TAGiDnULL ) ) ;
signC sReady(  tin0P , TAG( TAGiDnULL ) ) ;

TODO

DONE( tmPushNumbersF )

}
    }
        }
            if( bCmd == 'q' ) break ;
            DEL( pso ) ;
            if( bCmd == 'n' ) pso->writeF( tin0P , (byteT*)&cPrevious , sizeof cPrevious ) ;
            pso->readF( tin0P , &bCmd , 1 ) ;
            ZE( byteT , bCmd ) ;
            cPrevious ++ ;
        {
        if( pso )
        sock.acceptF( tin0P , pso , idPortPeer , nnPeer , countTC() ) ; ___( pso ) ;
        ZE( countT , idPortPeer ) ;
        nicNameC nnPeer ;
        ZE( socketC* , pso ) ;
    {
    while( !ether )
    ZE( countT , cPrevious ) ;

    ++ sReady ;
    sock.listenF( tin0P ) ;
    idPort = sock.bindF( tin0P ) ;
    socketC sock( tin0P , ether , TAG( TAGiDnULL ) ) ;

    signC&  sReady = *psReady ;
    countT& idPort = *pcIdPort ;
{
if( pcIdPort && psReady )

__Z( psReady ) ;
__Z( pcIdPort ) ;
DEL( pTaskP ) ;
psReady  = pTaskP ?  (signC*)pTaskP->c2 : 0 ;
pcIdPort = pTaskP ? (countT*)pTaskP->c1 : 0 ;
ZE( signC* , psReady ) ;
ZE( countT* , pcIdPort ) ;

TASK( tmPushNumbersF )

/*1*/WAKEhIDE( "example.simplest.func.107000b.socketC.readF" )/*1*/
/**/
*/
\<A HREF=\"5.9420104.1.0.html\"\>definition\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

