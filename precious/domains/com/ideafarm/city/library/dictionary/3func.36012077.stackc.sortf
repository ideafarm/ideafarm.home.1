
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    _OUTbATONsTACKc_

    }    
        if( pSgnEvent && F(flags) & flSTACKc_GIVEsIGNdELpLATE|flSTACKc_GIVEsIGNnEWpLATE ) pSgnEvent->giveF( tinBaseP ) ;

        third.delF( tinBaseP , *(countT**)&ppDoomed ) ;

        }
            __( !!ppDoomed[ off ] ) ; //U::O: COMMENT THIS OUT
            sinkPrivateF( tinBaseP , countTC() , PLATE_countT_REF( ppDoomed[ off ] ) , ppDoomed[ off ] , flSTACKsINK_null , pSubtractFP , subtractionParmP ) ;
        {
        for( countT off = 0 ; off < cpDoomed ; off ++ )
    
        third.delF( tinBaseP , pcTabIdSlot ) ;
        third.delF( tinBaseP , *(countT**)&ppTab ) ;
        newTabsIfF( tinBaseP , 0 , 0 ) ;
    
        }
            flagsState = flSTACKsTATE_null ; //115005c 0050011 0010121: VERIFY THAT THIS MAKES SENSE FOR NEWLY DEFINED STATE FLAGS
            cPlates = 0 ;
            }
                else        ppBottom   = 0 ;
                if( ppTop ) ppTop->ppU = 0 ;
                ppTop = ppTop->ppD ;
                ppDoomed[ off ] = ppTop ; //U::OBEY flagsP
                adjustRefsF( tinBaseP , 1 , ifcIDaCTIONsTACKaDJUSTrEFS_DELETED ) ;
            {
            for( countT off = 0 ; off < cpDoomed ; off ++ ) //U::O: CALL adjustRefsF OUTSIDE OF THIS LOOP, WO TIME
        {
        if( ppDoomed )
        third.newF( tinBaseP , LF , *(countT**)&ppDoomed , cpDoomed ) ; ___CT( ppDoomed ) ;
        const countT cpDoomed = cPlates ;
        ZE( plateS** , ppDoomed ) ;

        }
            }
                __1 ;
                __( idType ) ;
            {
            default :
            case ifcSTACKtYPE_PTR_strokeS   : { pSubtractFP = subtractStringsF          ; break ; }
            case ifcSTACKtYPE_PTR_count8S   : { pSubtractFP = subtractCount8F           ; break ; }
            case ifcSTACKtYPE_PTR_count7S   : { pSubtractFP = subtractCount7F           ; break ; }
            case ifcSTACKtYPE_PTR_count6S   : { pSubtractFP = subtractCount6F           ; break ; }
            case ifcSTACKtYPE_PTR_count5S   : { pSubtractFP = subtractCount5F           ; break ; }
            case ifcSTACKtYPE_PTR_count4S   : { pSubtractFP = subtractCount4F           ; break ; }
            case ifcSTACKtYPE_PTR_count3S   : { pSubtractFP = subtractCount3F           ; break ; }
            case ifcSTACKtYPE_PTR_count2S   : { pSubtractFP = subtractCount2F           ; break ; }
            case ifcSTACKtYPE_PTR_nicNameC  : { pSubtractFP = subtract_nicNameC_F       ; break ; }
            case ifcSTACKtYPE_PTR_soulC     : { pSubtractFP = subtract_soulC_F          ; break ; }
            case ifcSTACKtYPE_BLOB          : { pSubtractFP = subtractBlobsF            ; break ; }
            case ifcSTACKtYPE_PTR_byteT     : { pSubtractFP = subtractByteStringsF      ; break ; }
            case ifcSTACKtYPE_nicNameC      : { pSubtractFP = subtract_nicNameC_F       ; break ; }
            case ifcSTACKtYPE_timeS         : { pSubtractFP = subtract_timeS_F          ; break ; }
            case ifcSTACKtYPE_measureT      : { pSubtractFP = subtractMeasuresF         ; break ; }
            case ifcSTACKtYPE_PTR_countT    : { pSubtractFP = subtractCountStringsF     ; break ; }
            case ifcSTACKtYPE_PTR_plateC    : { pSubtractFP = subtract_plateC_F         ; break ; }
        {
        if( !pSubtractFP ) switch( idType )
    {
    if( cPlates )
    // SO purgeF WILL NOT FAIL DUE TO POOL EXHAUSTION, BUT I STILL CAN
    //20221221@0950: THE USE OF ppDoomed, WHICH CAN FAIL TO ALLOCATE DUE TO POOL EXHAUSTION, WAS ELIMINATED IN purgeF BUT NOT HERE
    //CS:CODEsYNC: 115005c 115007d


    _INbATONsTACKc_

    }
        if( third ) return ;
        __( F(flagsState) & flSTACKsTATE_LOCKED ) ;
        __( F(flags) & flSTACKc_XRAY ) ;
        FV( flSTACKsORT , flagsP ) ;
        if( third ) return ;
    {
    IFbEcAREFUL
    SCOOP   
{
/*1*/voidT stackC::sortF( tinBaseS& tinBaseP , const flagsT flagsP , ifc4FT pSubtractFP , const countT subtractionParmP )/*1*/

/**/
*/
  it is only passed into pSubtractF
  value is not used
  if 0 then cbd is used
  can be 0
  deprecated
 subtractionParmP
  can be 0
  deprecated
 pSubtractFP
 flagsP
arguments
   use randomF instead
   this application is illegal because it can easily violate the assumed invariance of the difference between oo plates
   the derived class can define its operator - in a way that causes plates to be sorted "randomly"
   this is a subapplication of dynamic sort criteria
  randomization
   this is more efficient than using separate stackC loads, because new plateS objects are not constructed and destructed
   several reports which sort the data in different ways can be generated by calling sortF for each mode value
   derived class can define its operator - dynamically, i.e. the definition can depend on the current value of a mode data member
  stackC of type ifcSTACKtYPE_PTR_plateC support dynamic sort ordering
 dynamic sort criteria
  pay the cost of sorting when generating a report rather than when collecting data
 defer sorting cost
  accumulate data in real time, and then sort it as a background activity when the incoming data stream is slow
 real time data accumulation
applications
i sort the plates on me
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

