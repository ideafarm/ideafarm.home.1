
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etThread.traceF( tin0P , T("i've been fired") ) ;

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

}
    }
        etThread.traceF( tin0P , T("socket is impotent") ) ;
        POOPRqUIET
    {
    if( POOP )

    etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
    TN( tb4 , "    " ) ;

    }
        DEL( pSwPathValue ) ;

        }
            }
                etThread.delF( tin0P , psttValue ) ;

                }
                    }
                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + ) ;
                        *pptValue[ offe ] = T(psttValue) ;
                    {
                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                {
                for( countT offe = 0 ; offe < cPaths ; offe ++ )

                if( cPaths - cValues ) { BLAMMO ; }
                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;

                strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                _IO_
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
        {
        if( !POOP )

        ;
        }
            &tPathDeviceId     ,
            &tPathAccessToken  ,
        {
        textC* pptPath[] =

        TN( tPathDeviceId    , "\"device_id\"/"    ) ;
        TN( tPathAccessToken , "\"access_token\"/" ) ;

        ;
        }
            &tValueDeviceId      ,
            &tValueAccessToken ,
        {
        textC* pptValue[] =

        __Z( pSwPathValue ) ;
        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
        ZE( switchC* , pSwPathValue ) ;
        ZE( strokeS* , psttPath     ) ;
    {

    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    etThread.traceF( tin0P , T("json response:") ) ;

    }
        }
            else if( costj ) break ;
                 if( cNest ) costj ++ ;

            else if( postj[ costj ] == '}' ) cNest -- ;
                 if( postj[ costj ] == '{' ) cNest ++ ;

            if( !cbIn ) break ;
            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
        {
        for(;;)
        ZE( countT , cNest ) ;
    {
    ZE( countT , costj ) ;
    osTextT postj[ TUCK << 1 ] ;

    sockc.writeF( tin0P , (osTextT*)tSay ) ;
    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    etThread.traceF( tin0P , T("request:") ) ;

    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/logout HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(0,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n") ;

    //sockc.connectF( tin0P , 80 , nnServer ) ;
    //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

    sockc.connectF( tin0P , 443 , nnServer ) ;
    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
    countT timeAllowedConnected = TICK >> 2 ;

    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
    nicNameC nnServer ;

    SCOOPS
{
IFsCRATCHoK

}
    }
        etThread.traceF( tin0P , T("socket is impotent") ) ;
        POOPRqUIET
    {
    if( POOP )

    etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
    TN( tb4 , "    " ) ;

    }
        DEL( pSwPathValue ) ;

        }
            }
                etThread.delF( tin0P , psttValue ) ;

                }
                    }
                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + ) ;
                        *pptValue[ offe ] = T(psttValue) ;
                    {
                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                {
                for( countT offe = 0 ; offe < cPaths ; offe ++ )

                if( cPaths - cValues ) { BLAMMO ; }
                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;

                etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;

                strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;

                _IO_
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
        {
        if( !POOP )

        //EXAMPLE: {"errcode":"M_UNKNOWN","error":"Can't connect to server ideafarm.com"}

        ;
        }
            &tPathError     ,
            &tPathErrorCode ,
        {
        textC* pptPath[] =

        TN( tPathError     , "\"error\"/"   ) ;
        TN( tPathErrorCode , "\"errcode\"/" ) ;

        ;
        }
            &tValueError     ,
            &tValueErrorCode ,
        {
        textC* pptValue[] =

        TN( tValueError     , "\"error\"/"   ) ;
        TN( tValueErrorCode , "\"errcode\"/" ) ;

        __Z( pSwPathValue ) ;
        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
        ZE( switchC* , pSwPathValue ) ;
        ZE( strokeS* , psttPath     ) ;
    {

    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    etThread.traceF( tin0P , T("json response:") ) ;

    }
        }
            else if( costj ) break ;
                 if( cNest ) costj ++ ;

            else if( postj[ costj ] == '}' ) cNest -- ;
                 if( postj[ costj ] == '{' ) cNest ++ ;

            if( !cbIn ) break ;
            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
        {
        for(;;)
        ZE( countT , cNest ) ;
    {
    ZE( countT , costj ) ;
    osTextT postj[ TUCK << 1 ] ;

    sockc.writeF( tin0P , (osTextT*)tSay ) ;
    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    etThread.traceF( tin0P , T("request:") ) ;

    ///*COURTSHIP SPACE*/   TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!vToQLBLEntzHVKLSgG:communick.com/invite HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBodyInvite,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBodyInvite ;

    /*PARLOR*/   TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!hYyziZVwPkfPSsKSsW:communick.com/invite HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBodyInvite,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBodyInvite ;

    //TEST ROOM: TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/rooms/!HnpEnmhcgIKCfCxeKH%3Acommunick.com/invite HTTP/1.1")+T("\r\nAuthorization: Bearer ")+tValueAccessToken+T("\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBodyInvite,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBodyInvite ;

    countT costBodyInvite = tBodyInvite.csF( tin0P ) ;

    //sockc.connectF( tin0P , 80 , nnServer ) ;
    //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

    sockc.connectF( tin0P , 443 , nnServer ) ;
    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
    countT timeAllowedConnected = TICK >> 2 ;

    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
    nicNameC nnServer ;

    ) ;

    //    "}\r\n"
    //    "    \"address\": \"test.2037@ideafarm.com\"\r\n"
    //    "    \"medium\": \"email\",\r\n"
    //    "    \"id_server\": \"")/*+tServer*/+T("matrix.org")+T("\",\r\n"
    //    "    \"id_access_token\": \"")+tValueAccessToken+T("\",\r\n"
    //    "    \"user_id\": \"@ideafarm:communick.com\",\r\n"
    //    "    \"user_id\": \"@ideafarm:matrix.org\"\r\n"
    //    "{\r\n"

          "{\"user_id\": \"@ideafarm38567392534901543notauser:matrix.org\"}\r\n" //INTENTIONAL USER NOT EXIST
        //"{\"user_id\": \"@ideafarmnotauser:matrix.org\"}\r\n" //INTENTIONAL USER NOT EXIST
        //"{\"user_id\": \"@ideafarm:ideafarm.com\"}\r\n"       //INTENTIONAL SERVER NOT EXIST
        //"{\"user_id\": \"@ideafarm:matrix.org\"}\r\n"

    TN( tBodyInvite , "" ) ; tBodyInvite = T(

    SCOOPS
{
IFsCRATCHoK

}
    }
        etThread.traceF( tin0P , T("socket is impotent") ) ;
        POOPRqUIET
    {
    if( POOP )

    etThread.traceF( tin0P , T("[accessToken,deviceId]:    ")+tValueAccessToken+tb4+tValueDeviceId ) ;
    TN( tb4 , "    " ) ;

    }
        DEL( pSwPathValue ) ;
        
        }
            }
                etThread.delF( tin0P , psttValue ) ;
        
                }
                    }
                        etThread.traceF( tin0P , T("********    ") + *pptPath[ offe ] + T("   :    ") + ) ;
                        *pptValue[ offe ] = T(psttValue) ;
                    {
                    if( !etThread.strCompareF( tin0P , psttPath , *pptPath[ offe ] ) )
                {
                for( countT offe = 0 ; offe < cPaths ; offe ++ )
        
                if( cPaths - cValues ) { BLAMMO ; }
                countT cValues = sizeof pptValue / sizeof pptValue[ 0 ] ;
                countT cPaths  = sizeof pptPath  / sizeof pptPath[  0 ] ;
        
                etThread.traceF( tin0P , T("--------------------------        [value]:    ")+T(psttValue) ) ;
                etThread.traceF( tin0P , T("-------------------------- [path]:            ")+T(psttPath) ) ;
        
                strokeS*& psttValue = *(strokeS**)&(countT&)*pSwPathValue ;
                psttPath = (strokeS*)pSwPathValue->leverF( tin0P , idf ) ;
        
                _IO_
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = pSwPathValue->cFlavorsF( tin0P ) ;
        {
        if( !POOP )
        
        ;
        }
            &tPathDeviceId     ,
            &tPathAccessToken  ,
        {
        textC* pptPath[] =
        
        TN( tPathDeviceId    , "\"device_id\"/"    ) ;
        TN( tPathAccessToken , "\"access_token\"/" ) ;
        
        ;
        }
            &tValueDeviceId      ,
            &tValueAccessToken ,
        {
        textC* pptValue[] =
        
        __Z( pSwPathValue ) ;
        etThread.strParseJsonF( tin0P , pSwPathValue , psttPath , (osTextT*)postj , flSTACKc_null ) ;
        ZE( switchC* , pSwPathValue ) ;
        ZE( strokeS* , psttPath     ) ;
    {

    etThread.traceF( tin0P , T(postj) , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    etThread.traceF( tin0P , T("json response:") ) ;

    }
        }
            else if( costj ) break ;
                 if( cNest ) costj ++ ;

            else if( postj[ costj ] == '}' ) cNest -- ;
                 if( postj[ costj ] == '{' ) cNest ++ ;

            if( !cbIn ) break ;
            countT cbIn = sockc.readF( tin0P , postj + costj , 1 ) ;
        {
        for(;;)
        ZE( countT , cNest ) ;
    {
    ZE( countT , costj ) ;
    osTextT postj[ TUCK << 1 ] ;

    sockc.writeF( tin0P , (osTextT*)tSay ) ;
    etThread.traceF( tin0P , tSay , flTRACE_NOpREFIX | flTRACE_KEEPcRlF ) ;
    etThread.traceF( tin0P , T("request:") ) ;

    TN( tSay , "" ) ; tSay = T("POST /_matrix/client/v3/login HTTP/1.1\r\nHost: ")+tServer+T("\r\nContent-Type: application/json\r\nContent-Length: ")+TF4(costBody,flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tBody ;

    countT costBody = tBody.csF( tin0P ) ;

    //sockc.connectF( tin0P , 80 , nnServer ) ;
    //socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_null , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

    sockc.connectF( tin0P , 443 , nnServer ) ;
    socketC sockc( tin0P , *((tin1S&)tin0P).pEtScratch , TAG( TAGiDnULL ) , 0 , flSOCKETc_CRYPTfOREIGNsSL , 0 , &idleTimeAllowedRead , &idleTimeAllowedWrite , &timeAllowedConnected ) ;

    countT idleTimeAllowedWrite = SOCKETtIMEOUTdEFAULTwAN ;
    countT idleTimeAllowedRead  = SOCKETtIMEOUTdEFAULTwAN ;
    countT timeAllowedConnected = TICK >> 2 ;

    nnServer = socketC::nicNameIF( tin0P , *((tin1S&)tin0P).pEtScratch , tServer ) ;
    nicNameC nnServer ;

    SCOOPS
{
IFsCRATCHoK
TN( tValueDeviceId       , "" ) ;
TN( tValueAccessToken , "" ) ;

TN( tServer , "matrix.communick.com" ) ;

) ;

    "}\r\n"
    "    \"password\": \"")+tPassword+T("\"\r\n"
    "    },\r\n"
    "        \"user\": \"ideafarm\"\r\n"
    "        \"type\": \"m.id.user\",\r\n"
    "    {\r\n"
    "    \"identifier\":\r\n"
    "    \"type\": \"m.login.password\",\r\n"
    "{\r\n"

TN( tBody , "" ) ; tBody = T(

}
    etThread.delF( tin0P , psttPassword ) ;
    tPassword = T(psttPassword) ;
    etThread.traceF( tin0P , T("[password]:    ")+T(psttPassword) ) ;
    if( psttPassword && psttPassword->idAdam ) tPassword = T(psttPassword) ;
    ZE( strokeS* , psttPassword ) ; etThread.querySettingF( tin0P , psttPassword , T("!ipdos.matrix.password.ideafarm")  ) ; ___( psttPassword ) ;
{
TN( tPassword , "" ) ;

TODO

/*1*/WAKEsHOWtEXT( "doodle.matrix.internal.server.error.invite.email" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
