
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        if( bDeleteOld ) delF( tinBaseP , *(strokeS**)&psttOldP ) ;

        }
            }
                if( bFound ) strFuseF( tinBaseP , *pSoulP , psttDelimiterP ) ;
    
                delF( tinBaseP , psttw ) ;
                }
                    }
                        strPourF( tinBaseP , *pSoulP , soulPour ) ;
                        strFuseF( tinBaseP , soulPour , psttw ) ;
                        soulC soulPour( tinBaseP , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;
                    {
                    else
                    if( psttw->idAdam <= CSTTsOULfUSEdEFAULT ) strFuseF( tinBaseP , *pSoulP , psttw ) ;
                {
                if( psttw && psttw->idAdam )
                boolT bFound = strSubstringF( tinBaseP , psttw , idf , sttq , psttDelimiterP , psttOldP ) ; ___( psttw ) ;
                idfLath = idf ;
                ZE( strokeS* , psttw ) ;
            {
            while( idf && !POOP )
            ZE( countT , idfLath ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
        {
        else
        }
            }
                delF( tinBaseP , psttp ) ;
                strFuseF( tinBaseP , psttP , psttp ) ;
                souli >> psttp ; ___( psttp ) ;
                ZE( strokeS* , psttp ) ;
            {
            while( souli )

            }
                if( bFound ) strFuseF( tinBaseP , souli , psttDelimiterP ) ;
    
                delF( tinBaseP , psttw ) ;
                }
                    }
                        strPourF( tinBaseP , souli , soulPour ) ;
                        strFuseF( tinBaseP , soulPour , psttw ) ;
                        soulC soulPour( tinBaseP , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;
                    {
                    else
                    if( psttw->idAdam <= CSTTsOULfUSEdEFAULT ) strFuseF( tinBaseP , souli , psttw ) ;
                {
                if( psttw && psttw->idAdam )
                boolT bFound = strSubstringF( tinBaseP , psttw , idf , sttq , psttDelimiterP , psttOldP ) ; ___( psttw ) ;
                idfLath = idf ;
                ZE( strokeS* , psttw ) ;
            {
            while( idf && !POOP )
            ZE( countT , idfLath ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
            countT idf = 1 ;
            soulC souli( tinBaseP , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;

            strMakeF( tinBaseP , LF , psttP , 0 , psttOldP->idAdam ) ; ___( psttP ) ;
        {
        if( !pSoulP )
    {
    else
    }
        }
            }
                delF( tinBaseP , psttp ) ;
                *pSoulP << psttp ;
                strReverseF( tinBaseP , psttp , 0 ) ; ___( psttp ) ;
                souli >> psttp ; ___( psttp ) ;
                ZE( strokeS* , psttp ) ;
            {
            while( souli )

            if( bDeleteOld ) delF( tinBaseP , *(strokeS**)&psttOldP ) ;
            strFuseF( tinBaseP , souli , psttOldP ) ;
            soulC souli( tinBaseP , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;
            countT cExtra = psttOldP[ 2 ].idAdam + csttExtraP ;
            countT cDo = psttOldP->idAdam ;
        {
        else
        }
            }
                delF( tinBaseP , psttp ) ;
                while( cDoPiece -- ) *( pstto -- ) = *( pstti ++ ) ;
                countT cDoPiece = psttp->idAdam ;
                strokeS* pstti = psttp + CSpREFIX ;
                souli >> psttp ; ___( psttp ) ;
                ZE( strokeS* , psttp ) ;
            {
            while( souli )
            strokeS* pstto = psttP + CSpREFIX - 1 + cDo ;

            SETpREFIX( psttP , cDo , cExtra ) ;
            strMakeF( tinBaseP , LF , psttP , 0 , cDo + cExtra ) ; // CALLER MUST TAG ___( psttP ) ;

            if( bDeleteOld ) delF( tinBaseP , *(strokeS**)&psttOldP ) ;
            strFuseF( tinBaseP , souli , psttOldP ) ;
            soulC souli( tinBaseP , TAG( TAGiDnULL ) , flSOUL_LIFO ) ;
            countT cExtra = psttOldP[ 2 ].idAdam + csttExtraP ;
            countT cDo = psttOldP->idAdam ;
        {
        if( !pSoulP )
    {
    if( !psttDelimiterP )

    if( !psttOldP ) { psttOldP = psttP ; psttP = 0 ; }
    const boolT bDeleteOld = !psttOldP ;

    _IO_

    }
        if( POOP ) return ;
        __( psttDelimiterP && psttDelimiterP->idAdam > CSTTsOULfUSEdEFAULT ) ;
        __( !psttP == !psttOldP ) ;
        if( POOP ) return ;
    {
    IFbEcAREFUL
    SCOOP
{
/*1*/voidT etherC::strReverseF( tinBaseS& tinBaseP , strokeS*& psttP , const strokeS* psttOldP , const strokeS* const psttDelimiterP , soulC* pSoulP , grabC* pGrabP , const countT csttExtraP )/*1*/

/**/
*/
  use csttExtraP to specify additional extra strokes
  i always preserve the extra strokes that are present in the source string
  can be 0
 csttExtraP
 pGrabP
  else                    must be lifo
  if !psttDelimiterP then must be fifo
  can be 0
 pSoulP
     for example, T("aaaa1::2bbbb1::2cccc") will become T("cccc1::2bbbb1::2aaaa")
    this will reverse the order of the substrings delimited by T("1::2")
   example: T("1::2")
  case: T("delimiter"): reverses the order of the delimited substrings
  case: 0: same as T("")
  case: T("\r\n"): reverses the order of the lines in the string
  case: T(""): reverses the order of the strokes in the string
  must be not longer than CSTTsOULfUSEdEFAULT
 psttDelimiterP
  if psttDelimiterP then no delimited string can be longer than CSTTsOULfUSEdEFAULT
  can be 0, unless psttP is 0
 psttOldP
   the drop at this address will be d eleted and the value of psttP will be replaced with the address of a new drop
  if not 0 then must be an address in the poolOld
  can be 0
 psttP
arguments
can be used reverse the order of the strokes or the lines or the delimited substrings of a string
  \<A HREF=\"5.8b10104.1.1.0.html\"\>8b10104:  WAKEsHOW( "example.simplest.func.1030086.etherC.strReverseF" )\</A\>
  \<A HREF=\"5.8a10104.1.1.0.html\"\>8a10104:  WAKEsHOW( "example.simplest.func.1030086.etherC.strReverseF" )\</A\>
  \<A HREF=\"5.7b10104.1.1.0.html\"\>7b10104:  WAKEsHOW( "example.simplest.func.1030086.etherC.strReverseF" )\</A\>
 simplest
examples
\<A HREF=\"5.1030086.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$strReverseF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

