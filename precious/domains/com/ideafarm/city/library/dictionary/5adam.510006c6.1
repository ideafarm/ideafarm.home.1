
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

etherC::loafIF( tin0P ) ;
etThread.traceF( tin0P , T("ok") ) ;

etThread.delF( tin0P , psttEncoded ) ;
raxDeleteWoFileF( tin0P , etThread , psttEncoded , resultAuth ) ;
etThread.strToUrlF( tin0P , psttEncoded , tRaw ) ; ___( psttEncoded ) ;
ZE( strokeS* , psttEncoded ) ;
TN( tRaw , "/archive/!ideafarm.6.19981210@0259.002.000b2284.75555555.ab10f1c3.archiveold.gather.to.!.000b2284.75555555.pc100.msv" ) ;

//raxDeleteWoFileF( tin0P , etThread , T("/archive/%21ideafarm%2e6%2e19981226%401232%2e001%2e000b2294%2edb0734b7%2eab10f1c3%2earchiveold%2egather%2eto%2e%21%2e000b2294%2edb0734b7%2edadflag%2ejpeg") , resultAuth ) ;

}
    raxGetAuthF( tin0P , etThread , resultAuth , tUser , tKey ) ;
    TN( tKey  , "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" ) ;
    TN( tUser , "ideafarm" ) ;
{
resultAuthS resultAuth( tin0P ) ;

TODO

}
    //etherP.traceF( tin0P , tIn ) ;

    //etherP.boxPutF( tin0P , T("///d/tmp/x/goo.ttt") , tIn , tIn.csF( tin0P ) ) ;
    //}
    //    }
    //        }
    //            tIn = T(postJson) ;
    //
    //            }
    //                }
    //                    case '}' : { if( !( -- idLevel ) ) bNix = 1 ; break ; }
    //                    case ']' :
    //
    //                    case '{' : {        ++ idLevel              ; break ; }
    //                    case '[' :
    //                {
    //                switch( *postc )
    //
    //                }
    //                    break ;
    //                    *postc = 0 ;
    //                {
    //                if( bNix )
    //            {
    //            for( osTextT* postc = postJson ; *postc ; postc ++ )
    //            ZE( boolT  , bNix ) ;
    //            ZE( countT , idLevel ) ;
    //        {
    //        if( postJson )
    //
    //        if( postJsonSq && postJsonSq < postJson ) postJson = postJsonSq ;
    //        osTextT* postJson   = thirdC::c_strstrIF( tin0P , postBody , "{" ) ;
    //        osTextT* postJsonSq = thirdC::c_strstrIF( tin0P , postBody , "[" ) ;
    //    {
    //    if( postBody )
    //    osTextT* postBody = thirdC::c_strstrIF( tin0P , postHear , "\r\n\r\n" ) ;
    //{
    //TN( tIn , "" ) ; // WILL CONTAIN A SINGLE, TRIMMED JSON WORD

    etherP.boxPutF( tin0P , T("///d/tmp/x/foo.")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T(".ttt") , postHear , costHear ) ;
    countT idIn = ++ idInLath ;
    static countT idInLath ;

    etherP.traceF( tin0P , T(postHear) ) ;
    countT costHear = ss.readF( tin0P , postHear , sizeof postHear ) ;
    memset( postHear , 0 , sizeof postHear ) ;
    char postHear[ TOCK ] ; 

    ss.writeF( tin0P , (osTextT*)tSay , (countT)tSay.csF( tin0P ) ) ;
    etherP.delF( tin0P , psttHost ) ;
    ss.connectF( tin0P , 443 , socketC::nicNameIF( tin0P , etherP , T(psttHost) ) ) ;
    socketC ss( tin0P , etherP , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL ) ;

    etherP.traceF( tin0P , tSay ) ;

    etherP.delF( tin0P , psttShort ) ;
    TN( tSay , "" ) ; tSay = T("DELETE ")+T(psttShort)+T(psttShortEncodedP)+T(" HTTP/1.1\r\nHost: ")+T(psttHost)+T("\r\nX-Auth-Token: ")+rAuthP.tAccessToken+T("\r\n\r\n") ;

    // Content-Length: 1234
    // Content-Type: text/plain
    // X-Auth-Token: f064c46a782c444cb4ba4b6434288f7c
    // Host: storage.clouddrive.com
    // DELETE /v1/MossoCloudFS_0672d7fa-9f85-4a81-a3ab-adb66a880123/shortEncodedName HTTP/1.1
    // EXAMPLE

    }
        }
            etherP.strSubstringF( tin0P , psttShort , idfShort , idlShort , rAuthP.tPublicUrl ) ; ___( psttShort ) ;
            etherP.strSubstringF( tin0P , psttHost  , idfHost  , idlHost  , rAuthP.tPublicUrl ) ; ___( psttHost  ) ;
            ZE( countT , idlShort ) ;
            countT idlHost = idfShort - 1 ;
            idfHost ++ ;
        {
        if( idfHost && idfShort )
        countT idfShort = etherP.strIdF( tin0P , strokeS( '/' ) , rAuthP.tPublicUrl , 3 ) ;
        countT idfHost  = etherP.strIdF( tin0P , strokeS( '/' ) , rAuthP.tPublicUrl , 2 ) ;
    {
    ZE( strokeS* , psttShort ) ;
    ZE( strokeS* , psttHost  ) ;
{
voidT raxDeleteWoFileF( tin0S& tin0P , etherC& etherP , const strokeS* const psttShortEncodedP , resultAuthS& rAuthP )

}
    wordF( tin0P , etherP , rP , scratchAuth , stPath , tIn ) ;
    stackC stPath( tin0P , etherP , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;
    scratchAuthS scratchAuth( tin0P ) ;

    }
        }
            }
                tIn = T(postJson) ;

                }
                    }
                        case '}' : { if( !( -- idLevel ) ) bNix = 1 ; break ; }
                        case ']' :

                        case '{' : {        ++ idLevel              ; break ; }
                        case '[' :
                    {
                    switch( *postc )

                    }
                        break ;
                        *postc = 0 ;
                    {
                    if( bNix )
                {
                for( osTextT* postc = postJson ; *postc ; postc ++ )
                ZE( boolT  , bNix ) ;
                ZE( countT , idLevel ) ;
            {
            if( postJson )

            if( postJsonSq && postJsonSq < postJson ) postJson = postJsonSq ;
            osTextT* postJson   = thirdC::c_strstrIF( tin0P , postBody , "{" ) ;
            osTextT* postJsonSq = thirdC::c_strstrIF( tin0P , postBody , "[" ) ;
        {
        if( postBody )
        osTextT* postBody = thirdC::c_strstrIF( tin0P , postHear , "\r\n\r\n" ) ;
    {
    TN( tIn , "" ) ; // WILL CONTAIN A SINGLE, TRIMMED JSON WORD

    countT cbIn = ss.readF( tin0P , postHear , sizeof postHear ) ;
    memset( postHear , 0 , sizeof postHear ) ;
    char postHear[ TOCK ] ; 

    ss.writeF( tin0P , (osTextT*)tSay , (countT)tSay.csF( tin0P ) ) ;
    ss.connectF( tin0P , 443 , socketC::nicNameIF( tin0P , etherP , T("identity.api.rackspacecloud.com") ) ) ;
    socketC ss( tin0P , etherP , TAG( TAGiDnULL ) , ifcSOCKETtYPE_STREAM , flSOCKETc_CRYPTfOREIGNsSL ) ;

    tSay += TF4(tSayBody.csF(tin0P),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_NObASE,0,0xa)+T("\r\n\r\n")+tSayBody ;
    ) ;

        "Content-Length: "
        "Content-Type: application/json\r\n"
        "Accept: application/json\r\n"
        "Host: identity.api.rackspacecloud.com\r\n"
        "User-Agent: IPDOS (tm)\r\n"
        "POST /v2.0/tokens HTTP/1.1\r\n"

    TN( tSay , 

    ) ;

        "}\r\n"
        "   }\r\n"
        "      }\r\n"
        "\"\r\n"

    tSayBody += T(

    tSayBody += T(psttKeyP) ;

    ) ;

        "         \"apiKey\": \""
        "\",\r\n"

    tSayBody += T(

    tSayBody += T(psttUserP) ;

    ) ;

        "         \"username\": \""
        "      {\r\n"
        "      \"RAX-KSKEY:apiKeyCredentials\":\r\n"
        "   {\r\n"
        "   \"auth\":\r\n"
        "{\r\n"

    TN( tSayBody ,
{
voidT raxGetAuthF( tin0S& tin0P , etherC& etherP , resultAuthS& rP , const strokeS* const psttUserP , const strokeS* const psttKeyP )

}
    }
        }
            //}
            //    etherP.traceF( tin0P , T("[ids,idLevel]: ")+TF2(ids,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idLevel,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            //{
            //if( idLevelLag != idLevel )

            }
                }
                    }
                        ;
                            : 0
                            ? ids + 1
                        idPairWoth = ids + 1 < idWordLath

                        etherP.delF( tin0P , psttPair ) ;
                        pairF( tin0P , etherP , rP , sP , stPathP , psttPair ) ;
                        etherP.strTrimF( tin0P , psttPair ) ; ___( psttPair ) ;
                        etherP.strSubstringF( tin0P , psttPair , idPairWoth , idPairLath , psttP ) ; ___( psttPair ) ;
                        ZE( strokeS* , psttPair ) ;

                        countT idPairLath = ids - 1 ;
                    {
                    if( !idLevel || ( idLevel == 1 && ostc == ',' ) )
                {
                case ',' :

                case '}' : { -- idLevel ; } // INTENTIONAL FALLTHROUGH

                case '{' : { ++ idLevel ; break ; }

                case ']' : { -- idLevel ; break ; }

                case '[' : { ++ idLevel ; break ; }
            {
            switch( ostc )

            if( bIgnore ) continue ;

            }
                //}
                //    etherP.delF( tin0P , psttIgnored ) ;
                //    etherP.traceF( tin0P , T("ignored: ")+T(psttIgnored) ) ;
                //    etherP.strSubstringF( tin0P , psttIgnored , idf , idl , psttP ) ; ___( psttIgnored ) ;
                //    ZE( strokeS* , psttIgnored ) ;
                //
                //    countT idl = ids ;
                //    countT idf = idsIgnoreWoth ;
                //{
                //else
                //if( bIgnore ) idsIgnoreWoth = ids ;

                bIgnore = !bIgnore ;
            {
            if( ostc == '"' )

            countT ostc = psttP[ CSpREFIX - 1 + ids ].idAdam ;
            idLevelLag = idLevel ;
        {
        for( countT ids = idWordWoth ; ids <= idWordLath ; ids ++ )
        ZE( countT , idsIgnoreWoth ) ;
        ZE( boolT , bIgnore ) ;
        countT idPairWoth = idWordWoth + 1 ;
        ZE( countT , idLevelLag ) ;
        ZE( countT , idLevel ) ;

        const countT idWordLath = psttP->idAdam ;
        const countT idWordWoth = 1 ;
    {
    if( psttP->idAdam > 2 )

    if( psttP[ CSpREFIX ].idAdam != '{' || psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != '}' ) { BLAMMO ; }
    //VERIFY THAT psttP BEGINS WITH '{' AND ENDS WITH '}'

    //
    // value := [ word , word , ... ]
    //
    // value := word
    // 
    // pair := key : value
    //
    // word := { pair , pair , ... }
    //
    // INPUT IS EXACTLY WO word
    // INPUT FORMAT SPECIFICATION
    // 
    // RECIPE
{
voidT wordF( tin0S& tin0P , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    }
        }
            idValueWoth = 0 ;
            etherP.delF( tin0P , psttValue ) ;
            valueF( tin0P , etherP , rP , sP , stPathP , psttValue ) ;
            etherP.strTrimF( tin0P , psttValue ) ; ___( psttValue ) ;
            etherP.strSubstringF( tin0P , psttValue , idValueWoth , idValueLath , psttP ) ; ___( psttValue ) ;
            ZE( countT , idValueLath ) ;
            ZE( strokeS* , psttValue ) ;
        {
        if( !idLevel && idValueWoth )

        }
            }
                }
                    break ;

                    }
                        ;
                            : 0
                            ? ids + 1
                        idValueWoth = ids + 1 <= idPairLath

                        idKeyWoth = 0 ;
                        etherP.delF( tin0P , psttKey ) ;
                        keyF( tin0P , etherP , rP , sP , stPathP , psttKey ) ;
                        etherP.strTrimF( tin0P , psttKey ) ; ___( psttKey ) ;
                        etherP.strSubstringF( tin0P , psttKey , idKeyWoth , idKeyLath , psttP ) ; ___( psttKey ) ;
                        ZE( strokeS* , psttKey ) ;

                        countT idKeyLath = ids - 1 ;
                    {
                    if( !idLevel && idKeyWoth )
                {
                case ':' :

                case '}' : { -- idLevel ; break ; }
                case ']' :

                case '{' : { ++ idLevel ; break ; }
                case '[' :
            {
            switch( ostc )

            if( bIgnore ) continue ;
            if( ostc == '"' ) bIgnore = !bIgnore ;

            countT ostc = psttP[ CSpREFIX - 1 + ids ].idAdam ;
        {
        for( countT ids = idPairWoth ; ids <= idPairLath ; ids ++ )
        ZE( countT , idsIgnoreWoth ) ;
        ZE( boolT  , bIgnore ) ;
        ZE( countT , idValueWoth ) ;
        countT idKeyWoth = idPairWoth ;
        ZE( countT , idLevel ) ;

        const countT idPairLath = psttP->idAdam ;
        const countT idPairWoth = 1 ;
    {
    if( psttP->idAdam > 2 )

    //
    // value := [ word , word , ... ]
    //
    // value := word
    // 
    // pair := key : value
    //
    // INPUT IS EXACTLY WO word
    // INPUT FORMAT SPECIFICATION
    // 
    // RECIPE

    //etherP.traceF( tin0P , T("[pair]: ")+T(psttP) ) ;
{
voidT pairF( tin0S& tin0P , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    }
        etherP.delF( tin0P , psttKey ) ;
        stPathP >> psttKey ;
        ZE( strokeS* , psttKey ) ;
    {
    if( stPathP )

    }
        }
            break ;
            wordF( tin0P , etherP , rP , sP , stPathP , psttP ) ;
            if( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != '}' ) { BLAMMO ; }
        {
        case '{' :
        }
            break ;
            etherP.delF( tin0P , psttList ) ;
            listF( tin0P , etherP , rP , sP , stPathP , psttList ) ;
            etherP.strSubstringF( tin0P , psttList , idf , idl , psttP ) ; ___( psttList ) ;
            countT idl = psttP->idAdam - 1 ;
            countT idf = 2 ;
            ZE( strokeS* , psttList ) ;

            if( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != ']' ) { BLAMMO ; }
        {
        case '[' :
    {
    if( psttP->idAdam ) switch( psttP[ CSpREFIX ].idAdam )

    }
        }
            }
                etherP.delF( tin0P , psttw ) ;
                rP.tTenantId = T(psttw) ;
                strFromJsonF( tin0P , etherP , psttw , sP.tMaybeTenantId ) ; ___( psttw ) ;

                etherP.delF( tin0P , psttw ) ;
                rP.tPublicUrl = T(psttw) ;
                strFromJsonF( tin0P , etherP , psttw , sP.tMaybePublicUrl ) ; ___( psttw ) ;
                ZE( strokeS* , psttw ) ;
            {
            if( !etherP.strCompareF( tin0P , psttP , T("\"object-store\"") ) )
        {
        else if( !etherP.strCompareF( tin0P , tPath , tWantObjectStore ) )
        }
            }
                sP.tMaybeTenantId = T(psttP) ;
            {
            if( F(sP.flags) & flME_MYrEGION )
        {
        else if( !etherP.strCompareF( tin0P , tPath , tWantTenantId ) )
        }
            }
                sP.tMaybePublicUrl = T(psttP) ;
            {
            if( F(sP.flags) & flME_MYrEGION )
        {
        else if( !etherP.strCompareF( tin0P , tPath , tWantPublicURL ) )
        }
            else                                                        sP.flags &= ~( flME_MYrEGION ) ;
            if( !etherP.strCompareF( tin0P , T(psttP) , T("\"IAD\"") ) ) sP.flags |=    flME_MYrEGION   ;
        {
        else if( !etherP.strCompareF( tin0P , tPath , tWantRegion ) )
        }
            etherP.delF( tin0P , psttw ) ;
            rP.tAccessToken = T(psttw) ;
            strFromJsonF( tin0P , etherP , psttw , psttP ) ; ___( psttw ) ;
            ZE( strokeS* , psttw ) ;
        {
        if( !etherP.strCompareF( tin0P , tPath , tWantToken ) )

        //etherP.traceF( tin0P , tPath ) ;

        TN( tWantObjectStore , "\"access\"/\"serviceCatalog\"/\"type\"/" ) ;
        TN( tWantPublicURL   , "\"access\"/\"serviceCatalog\"/\"endpoints\"/\"publicURL\"/" ) ;
        TN( tWantTenantId    , "\"access\"/\"serviceCatalog\"/\"endpoints\"/\"tenantId\"/"  ) ;
        TN( tWantRegion      , "\"access\"/\"serviceCatalog\"/\"endpoints\"/\"region\"/"    ) ;
        TN( tWantToken       , "\"access\"/\"token\"/\"id\"/"                               ) ;
    {

    // "access"/"token"/"id"/    --------    "995e991606cc43dbaddfaaed82b8aa4f"
    //
    //
    // THESE ARE THE VALUES THAT I WANT (PATH    --------    SAMPLEVALUE

    }
        while( ~hWalk ) ;
        do tPath += T((strokeS*)stPathP.upF(tin0P,hWalk))+T("/") ;
    {
    if( stPathP )
    TN( tPath , "" ) ;
    handleC hWalk( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
{
voidT valueF( tin0S& tin0P , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    stPathP << psttw ;
    etherP.strMakeF( tin0P , LF , psttw , psttP ) ; ___( psttw ) ;
    ZE( strokeS* , psttw ) ;

    //etherP.traceF( tin0P , T("[key]: ")+T(psttP) ) ;
{
voidT keyF( tin0S& tin0P , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    }
        }
            etherP.delF( tin0P , psttItem ) ;
            itemF( tin0P , etherP , rP , sP , stPathP , psttItem ) ;
            etherP.strTrimF( tin0P , psttItem ) ; ___( psttItem ) ;
            etherP.strSubstringF( tin0P , psttItem , idItemWoth , idItemLath , psttP ) ; ___( psttItem ) ;
            ZE( countT , idItemLath ) ;
            ZE( strokeS* , psttItem ) ;
        {
        if( idItemWoth )

        }
            }
                }
                    break ;

                    }
                        ;
                            : 0
                            ? ids + 1
                        idItemWoth = ids + 1 <= idListLath

                        etherP.delF( tin0P , psttItem ) ;
                        itemF( tin0P , etherP , rP , sP , stPathP , psttItem ) ;
                        etherP.strTrimF( tin0P , psttItem ) ; ___( psttItem ) ;
                        etherP.strSubstringF( tin0P , psttItem , idItemWoth , idItemLath , psttP ) ; ___( psttItem ) ;
                        ZE( strokeS* , psttItem ) ;

                        countT idItemLath = ids - 1 ;
                    {
                    if( !idLevel )
                {
                case ',' :

                case '}' : { -- idLevel ; break ; }
                case ']' :

                case '{' : { ++ idLevel ; break ; }
                case '[' :
            {
            switch( ostc )

            if( bIgnore ) continue ;
            if( ostc == '"' ) bIgnore = !bIgnore ;

            countT ostc = psttP[ CSpREFIX - 1 + ids ].idAdam ;
        {
        for( countT ids = idListWoth ; ids <= idListLath ; ids ++ )
        ZE( countT , idsIgnoreWoth ) ;
        ZE( boolT  , bIgnore ) ;
        countT idItemWoth = idListWoth ;
        ZE( countT , idLevel ) ;

        const countT idListLath = psttP->idAdam ;
        const countT idListWoth = 1 ;
    {
    if( psttP->idAdam > 2 )

    //etherP.traceF( tin0P , T("[list]: ")+T(psttP) ) ;
{
voidT listF( tin0S& tin0P , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    }
        }
            }
                break ;
                wordF( tin0P , etherP , rP , sP , stPathP , psttP ) ;
                if( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != '}' ) { BLAMMO ; }
            {
            case '{' :
            }
                break ;
                etherP.delF( tin0P , psttList ) ;
                listF( tin0P , etherP , rP , sP , stPathP , psttList ) ;
                etherP.strSubstringF( tin0P , psttList , idf , idl , psttP ) ; ___( psttList ) ;
                countT idl = psttP->idAdam - 1 ;
                countT idf = 2 ;
                ZE( strokeS* , psttList ) ;

                if( psttP[ CSpREFIX - 1 + psttP->idAdam ].idAdam != ']' ) { BLAMMO ; }
            {
            case '[' :
        {
        switch( psttP[ CSpREFIX ].idAdam )
    {
    if( psttP->idAdam )

    //etherP.traceF( tin0P , T("[item]: ")+T(psttP) ) ;
{
voidT itemF( tin0S& tin0P , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP )

}
    etherP.strReplaceF( tin0P , psttP , 0 , T("\\/") , T("/") ) ; ___( psttP ) ;
    etherP.strTrimF(    tin0P , psttP , psttFromP , 0 , T("\"") ) ; ___( psttP ) ;
{
voidT strFromJsonF( tin0S& tin0P , etherC& etherP , strokeS*& psttP , const strokeS* const psttFromP )

voidT wordF( tin0S& tin0P , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP ) ;
voidT listF( tin0S& tin0P , etherC& etherP , resultAuthS& rP , scratchAuthS& sP , stackC& stPathP , const strokeS* const psttP ) ;

}
{
tTenantId( tin0P , TAG( TAGiDnULL ) )
tPublicUrl( tin0P , TAG( TAGiDnULL ) ) ,
tAccessToken( tin0P , TAG( TAGiDnULL ) ) ,
resultAuthS::resultAuthS( tin0S& tin0P ) :

}
{
tMaybeTenantId( tin0P , TAG( TAGiDnULL ) )
tMaybePublicUrl( tin0P , TAG( TAGiDnULL ) ) ,
flags( flME_null ) ,
scratchAuthS::scratchAuthS( tin0S& tin0P ) :

;
}
    resultAuthS( tin0S& tin0P ) ;

    textC   tTenantId ;
    textC   tPublicUrl ;
    textC   tAccessToken ;
{
struct resultAuthS

;
}
    scratchAuthS( tin0S& tin0P ) ;

    textC   tMaybeTenantId ;
    textC   tMaybePublicUrl ;
    flagsT  flags ;
{
struct scratchAuthS

#define flME_MYrEGION    0xe00001ff
#define flME_null        0xe00000ff

/*1*/WAKEsHOWtEXT( "tool.cloud.delete.files.individually" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

