
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//

                            
REST

etThread.osSuspendF( tinBaseP ) ;
etThread.traceF( tinBaseP , T("ok.  hibernating") ) ;

//etherC::loafIF( tinBaseP ) ;
//etThread.traceF( tinBaseP , T("ok.  loafing") ) ;

}
    }
        }
            THREADmODE2rESTORE
            while( cExecutiveHealYear ) thirdC::dosSleepWinkIF( tinBaseP ) ;
            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
        {

        }
            while( ~hStYearToHeal ) ;
            }
                etThread.osThreadF( TaRG3fLAGScBtLS( tmExecutiveHealYearF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cExecutiveHealYear , (countT)psttYear , (countT)&psttzArchive , (countT)&swsPathToArchivesByArchiveName ) ;
                inc02AM( cExecutiveHealYear ) ;

                etThread.strMakeF( tinBaseP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                ZE( strokeS* , psttYear ) ;

                etThread.traceF( tinBaseP , T("year to heal:    ")+T(psttzYear) ) ;
                strokeS* psttzYear = (strokeS*)stYearToHeal.upF( tinBaseP , hStYearToHeal ) ;       //PROCESSES YEARS BEGINNING WITH MOST RECENT  (A:ASSUME: CURRENT YEARS ARE IN MOST NEED OF HEALING SINCE FILES ARE ADDED AND MODIFIED)

                }
                    THREADmODE2rESTORE
                    while( CyEARSiNpARALLEL == cExecutiveHealYear ) thirdC::dosSleepWinkIF( tinBaseP ) ;
                    THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                {
            {
            do
            handleC hStYearToHeal( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        {
        ZE( countT , cExecutiveHealYear ) ;

        }
            }
                }
                    }
                        BLAMMO ;                                //SHOULD BE IMPOSSIBLE
                        etThread.delF( tinBaseP , psttYear ) ;
                    {
                    if( !idSlot )
                    stYearToHeal.sinkF( tinBaseP , idSlot , psttYear , flSTACKsINK_UNIQUE ) ;
                    ZE( countT , idSlot ) ;
                    etThread.strMakeF( tinBaseP , LF , psttYear , psttzYear ) ; ___( psttYear ) ;
                    ZE( strokeS* , psttYear ) ;
                {
                if( tally > 1 )
                countT tally = swTallyByYear ;
                psttzYear = (strokeS*)swTallyByYear.leverF( tinBaseP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cFlavors ; idf ++ )
            countT cFlavors = swTallyByYear.cFlavorsF( tinBaseP ) ;

            while( ~hSwsPathToArchives ) ;
            }
                etThread.delF( tinBaseP , pstt1PathToYear ) ;
                }
                    //etThread.traceF( tinBaseP , T("[tYear,tally]:    ")+tYear+tb4+TF2((countT)swTallyByYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    swTallyByYear ++ ;
                    psttzYear = tYear ;

                    }
                        etThread.delF( tinBaseP , psttYear ) ;
                        tYear = T(psttYear) ;
                        etThread.strWordF( tinBaseP , psttYear , psttc1 , sttq , sttSlash , - 2 ) ; ___( psttYear ) ;
                        ZE( strokeS* , psttYear ) ;
                    {
                    TN( tYear , "" ) ;
                {
                FORsTRINGSiN1( pstt1PathToYear )
                etThread.strConvertToLowerCaseF( tinBaseP , pstt1PathToYear ) ;
                etThread.diskFindFileOrDirF( tinBaseP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                patternC pat( tinBaseP , etThread , tYearPattern , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                ZE( strokeS* , pstt1PathToYear ) ;

                //etThread.traceF( tinBaseP , T("new code [tPathToArchive]:    ")+tPathToArchive ) ;
                TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchive)+tSlash ;
                strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveName.downF( tinBaseP , hSwsPathToArchives ) ;
            {
            do
            handleC hSwsPathToArchives( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            strokeS sttSlash( '/' ) ;
            strokeS sttq( 0 , sc_IGNOREqUOTES ) ;

            switchC swTallyByYear( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , psttzYear ) ;
            ZE( strokeS* , psttzYear ) ;
        {
        stackC stYearToHeal( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE , ifcSTACKtYPE_PTR_strokeS ) ;

        // FOR EACH YEAR FOLDER (ALL YEARS FOR THIS ARCHIVE NAME (EXAMPLE: ALL YEAR PATHS FOR EVERY YEAR FOR "wo.ideafarm"), LAUNCH A FILE RECORD COLLECTION THREAD
    {
    if( cArchivesWithThisName > 1 )
    etThread.traceF( tinBaseP , T("[cArchivesWithThisName,archive]:    ")+TF2(cArchivesWithThisName,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttzArchive) ) ;
    swsPathToArchivesByArchiveName.ungrabF( tinBaseP ) ;
    countT cArchivesWithThisName = swsPathToArchivesByArchiveName ;
    psttzArchive = (strokeS*)swsPathToArchivesByArchiveName.leverF( tinBaseP , idf ) ;
    swsPathToArchivesByArchiveName.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
{
for( countT idf = 1 ; idf <= cFlavors ; idf ++ )    // FOR EACH ARCHIVE NAME (EXAMPLE: "wo.ideafarm")
swsPathToArchivesByArchiveName.ungrabF( tinBaseP ) ;
countT cFlavors = swsPathToArchivesByArchiveName.cFlavorsF( tinBaseP ) ;
swsPathToArchivesByArchiveName.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;
TN( tYearPattern , "?" "?" "?" "?" "/" ) ;                                                              //20221118@1747: "????/" PROUCES A SPURIOUS COMPILER ERROR INVOLVING TRIGRAPH
//TN( tYearPattern , "1999/" ) ;  //U:: TO FIND A BUG

swsPathToArchivesByArchiveName.lockIfF( tinBaseP ) ;
}
    }
        etThread.delF( tinBaseP , pstt1Archives ) ;
        }
            }
                swsPathToArchivesByArchiveName.sinkF( tinBaseP , countTC() , psttPathArchives ) ;                           // EXAMPLE: "///c/ipdos.arhives/"

                psttzArchive = tArchive ;

                etThread.traceF( tinBaseP , T("    [tPathArchives,tArchive]:    ")+T(psttPathArchives)+tb4+tArchive ) ;

                }
                    etThread.delF( tinBaseP , psttShorter ) ;
                    tArchive = T(psttShorter) ;
                    etThread.strSubstringF( tinBaseP , psttShorter , idf , idl , tArchiveSlash ) ; ___( psttShorter ) ;
                    ZE( strokeS* , psttShorter ) ;
                {
                if( idl )
                countT idl = tArchiveSlash.csF( tinBaseP ) ? tArchiveSlash.csF( tinBaseP ) - 1 : 0 ;
                countT idf = 1 ;
                TN( tArchive , "" ) ;                                                                                   // EXAMPLE: "wo.ideafarm"

                }
                    etThread.delF( tinBaseP , psttArchiveSlash ) ;
                    tArchiveSlash = T(psttArchiveSlash) ;
                    etThread.strBisectF( tinBaseP , psttPathArchives , psttArchiveSlash , psttc1 , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPathArchives ) ; ___( psttArchiveSlash ) ;
                    ZE( strokeS* , psttArchiveSlash ) ;
                {
                TN( tArchiveSlash , "" ) ;                                                                              // EXAMPLE: "wo.ideafarm/"
                ZE( strokeS* , psttPathArchives ) ;                                                                     // EXAMPLE: "///c/ipdos.arhives/"

                etThread.traceF( tinBaseP , T("processing archive ")+T(psttc1) ) ;                                          // EXAMPLE: "///c/ipdos.arhives/wo.ideafarm/"
            {
            FORsTRINGSiN1( pstt1Archives )
            etThread.diskFindFileOrDirF( tinBaseP , pstt1Archives , tLikeArchives ) ; ___( pstt1Archives ) ;
        {
        ZE( strokeS* , pstt1Archives ) ;
    {
    TN( tLikeArchives , "///?/ipdos.archives/" ) ;
{
switchStackC swsPathToArchivesByArchiveName( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , psttzArchive , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
ZE( strokeS* , psttzArchive ) ;
// LOAD swsPathToArchivesByArchiveName WITH VALUES LIKE "///c/ipdos.arhives/" SWITCHED ON VALUES LIKE "wo.ideafarm"

TN( tSlash , "/" ) ;
TN( tb4    , "    " ) ;

TODO

countT cDebug = sizeof( grabAnnotatedS ) ;

DONE( tmExecutiveHealYearF )
}
    dec02AM( cExecutiveHealYearP ) ;
    }
        etThread.traceF( tinBaseP , T("done for archive ")+T(psttzArchiveP) ) ;

        DEL( pSwsMetaByShort ) ;

        }
            //U::while( cWaiting ) sgnGo.giveF( tinBaseP ) ;       //cWaiting IS USED TO AVOID A RACE CONDITION: A THREAD THAT HAS INCREMENTED cCutoffUpdates BUT HAS NOT YET CALLED waitF WILL NOT SEE THIS SIGN
            sgnGo.giveF( tinBaseP ) ;
            thirdC::dosSleepWinkIF( tinBaseP ) ; // TO AVOID RACE
            //etThread.traceF( tinBaseP , T("giving sign to unpause workers") ) ;

            pSwsMetaByShort->ungrabF( tinBaseP ) ;

            //etThread.traceF( tinBaseP , T("after calling freeAllF [cFlavors]:    ")+TF2(pSwsMetaByShort->cFlavorsF(tinBaseP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
            pSwsMetaByShort->freeAllF( tinBaseP ) ;

            }
                }
                    while( ~hSwsOuter ) ;
                    }
                        DELzOMBIE( pfmOuter ) ;

                        }
                            DELzOMBIE( pd ) ;
                            imageCompareS* pd = picOuter + offd ;
                        {
                        for( countT offd = 0 ; offd < cResultStructsNeeded ; offd ++ )

                        fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + cResultStructsNeeded ) ;
                        imageCompareS* picOuter  = (imageCompareS*)&pSwsMetaByShort->downF( tinBaseP , hSwsOuter ) ;
                    {
                    do
                    handleC hSwsOuter( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                {
                if( cFiles )
                countT cFiles = *pSwsMetaByShort ;
                postzShort = (osTextT*)pSwsMetaByShort->leverF( tinBaseP , idf ) ;
            {
            for( countT idf = 1 ; idf <= cShortFileNames ; idf ++ )
            
            //etThread.traceF( tinBaseP , T("deleting metadata") ) ;

            }
                }
                    }
                        }
                            }
                                }
                                    etThread.osThreadF( TaRG3fLAGScBtLS( tmCopyFileF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)psttTo , (countT)psttFrom ) ; psttTo = psttFrom = 0 ;
                                    //etThread.traceF( tinBaseP , T("new      [psttTo,psttFrom]:    ")+TF2((countT)psttTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2((countT)psttFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                    //etThread.traceF( tinBaseP , T("copying [idFrom,new,old,idFrom]:    ")+TF2(idFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttTo)+tb4+T(psttFrom) ) ;

                                    etThread.strMakeF( tinBaseP , LF , psttFrom , (strokeS*)stFrom[ idFrom ] ) ; ___( psttFrom ) ;
                                    ZE( strokeS* , psttFrom ) ;

                                    countT idFrom = 1 + ( cDone ++ % cFrom ) ;

                                    stTo >> psttTo ;
                                    ZE( strokeS* , psttTo ) ;
                                {
                                while( stTo )
                                ZE( countT , cDone ) ;
                                countT cFrom = stFrom ;

                                while( ~hStPathToYear ) ;
                                }
                                    }
                                        if( !idSlot ) etThread.delF( tinBaseP , psttLong ) ;
                                        stTo.sinkF( tinBaseP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ;
                                        ZE( countT , idSlot ) ;
                                        //etThread.traceF( tinBaseP , T("sinking to stTo 2 [long]:    ")+T(psttLong) ) ;
                                    {
                                    else
                                    if( stFrom( psttLong ) ) etThread.delF( tinBaseP , psttLong ) ;

                                    etThread.strMakeF( tinBaseP , LF , psttLong , T(psttPathToYear)+tShort ) ; ___( psttLong ) ;
                                    ZE( strokeS* , psttLong ) ;

                                    strokeS* psttPathToYear = (strokeS*)stPathToYear.downF( tinBaseP , hStPathToYear ) ;
                                {
                                do
                                handleC hStPathToYear( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                while( ~hStUnique ) ;
                                }
                                    }
                                        while( ~hSwsInner ) ;
                                        }
                                            }
                                                if( !idSlot ) etThread.delF( tinBaseP , psttLong ) ;
                                                }
                                                    stTo.sinkF( tinBaseP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                    //etThread.traceF( tinBaseP , T("sunk into stTo [cPlatesBefore,long]:    ")+TF2(stTo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                {
                                                else
                                                }
                                                    stFrom.sinkF( tinBaseP , idSlot , psttLong , flSTACKsINK_UNIQUE ) ; psttLong = 0 ;
                                                    //etThread.traceF( tinBaseP , T("sunk into stFrom [cPlatesBefore,long]:    ")+TF2(stFrom,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(psttLong) ) ;
                                                {
                                                if( bYoungestNotAlone && bWinner )
                                                ZE( countT , idSlot ) ;

                                                etThread.strMakeF( tinBaseP , LF , psttLong , T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ) ; ___( psttLong ) ;
                                                ZE( strokeS* , psttLong ) ;
                                            {
                                            if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) )

                                            }
                                                }
                                                    break ;
                                                    bMatchImage = 0 ;
                                                {
                                                if( picUnique[ offc ] - picInner[ offc ] )
                                            {
                                            for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ )
                                            boolT bMatchImage = 1 ;

                                            //picInner->traceF( tinBaseP , T("inner :    ") ) ;
                                            fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                            imageCompareS* picInner  = (imageCompareS*)&pSwsMetaByShort->downF( tinBaseP , hSwsInner ) ;
                                        {
                                        do
                                        handleC hSwsInner( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                    {

                                    //pfmUnique->traceF( tinBaseP , stPathToYear , T(bYoungestNotAlone?"reporting tallies (youngestNotAlone):    ":"reporting tallies            (other):    ") ) ;

                                    //etThread.traceF( tinBaseP , T("[bYoungestNotAlone,bWinner,cVotes,cVotesMax]:    ")+TF2(bYoungestNotAlone,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bWinner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(pfmUnique->cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cVotesMax,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    boolT bWinner           = pfmUnique->cVotes         == cVotesMaxYoungestNotAlone      ;
                                    boolT bYoungestNotAlone = pfmUnique->timeModRounded == timeModRoundedYoungestNotAlone ;

                                    //for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ ) picUnique[ offc ].traceF( tinBaseP , T("reporting tallies:    ") ) ;

                                    //picUnique->traceF( tinBaseP , T("unique:    ") ) ;
                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hStUnique ) ;
                                {
                                do
                                handleC hStUnique( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                stackC stTo(     tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                                stackC stFrom(   tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
                            {
                            else
                            }
                                while( ~hSwsInner ) ;
                                }
                                    etThread.osThreadF( TaRG3fLAGScBtLS( tmMoveFileToUniqueF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)psttLongInRejects , (countT)psttLong ) ; psttLongInRejects = psttLong = 0 ;

                                    etThread.strReplaceF( tinBaseP , psttLongInRejects , psttLong , tPatArchives , tPatRejects ) ; ___( psttLongInRejects ) ;
                                    ZE( strokeS* , psttLongInRejects ) ;

                                    etThread.strMakeF( tinBaseP , LF , psttLong , T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ) ; ___( psttLong ) ;
                                    ZE( strokeS* , psttLong ) ;

                                    fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                    imageCompareS* picInner  = (imageCompareS*)&pSwsMetaByShort->downF( tinBaseP , hSwsInner ) ;
                                {
                                do
                                handleC hSwsInner( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                                etThread.traceF( tinBaseP , T("no, or too many (more than 1), winners (authoritative copies) so i will reject all copies [file]")+tShort ) ;
                            {
                            if( !cWinners || cWinners > 1 )

                            }
                                while( ~hSt ) ;
                                }
                                    cWinners ++ ;
                                    )
                                        pfmUnique->cVotes == cVotesMaxYoungestNotAlone
                                        &&
                                        timeModRoundedYoungestNotAlone == pfmUnique->timeModRounded
                                    (
                                    if

                                    //picUnique->traceF( tinBaseP , T("unique:    ") ) ;
                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                                {
                                do
                                handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( cVotesMaxYoungestNotAlone )        // IF ALL ARE ALONE THEN THERE WILL BE NO WINNER
                            ZE( countT , cWinners ) ;

                            // RULE; TO WIN, A SLOT MUST HAVE A "YOUNGEST NOT ALONE" AGE AND BE "NOT ALONE" AND HAVE THE MAXIMUM VOTES FOR SLOTS YOUNGEST AND NOT ALONE
                            //P:PERSONALITY: RULES FOR "WINNING": A stRecUnique SLOT "WINNING" MEANS THAT THE SLOT IS DEEMED TO BE AN AUTHORITATIVE IMAGE FOR THE FILE

                            }
                                while( ~hSt ) ;
                                }
                                    }
                                        if( pfmUnique->cVotes > 1 && cVotesMaxYoungestNotAlone < pfmUnique->cVotes ) cVotesMaxYoungestNotAlone = pfmUnique->cVotes ;
                                    {
                                    if( timeModRoundedYoungestNotAlone == pfmUnique->timeModRounded )

                                    }
                                        if(                          cVotesMaxYoungest         < pfmUnique->cVotes ) cVotesMaxYoungest         = pfmUnique->cVotes ;
                                    {
                                    if( timeModRoundedYoungest == pfmUnique->timeModRounded )

                                    //picUnique->traceF( tinBaseP , T("unique:    ") ) ;
                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                                {
                                do
                                handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( timeModRoundedYoungestNotAlone )        // IF ALL ARE ALONE THEN THERE WILL BE NO WINNER
                            ZE( countT , cVotesMaxYoungestNotAlone ) ;
                            ZE( countT , cVotesMaxYoungest ) ;

                            }
                                while( ~hSt ) ;
                                }
                                    if( pfmUnique->cVotes > 1 && timeModRoundedYoungestNotAlone < pfmUnique->timeModRounded ) timeModRoundedYoungestNotAlone = pfmUnique->timeModRounded ;

                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                                {
                                do
                                handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            ZE( countT , timeModRoundedYoungestNotAlone ) ;
                            // SET timeModRoundedYoungestNotAlone

                            }
                                while( ~hSt ) ;
                                }
                                    while( ~hSwsOuter ) ;
                                    }
                                        if( bMatchImage && !( *pfmUnique - *(fileMetaS*)pfmInner ) ) pfmUnique->cVotes ++ ;

                                        }
                                            }
                                                break ;
                                                bMatchImage = 0 ;
                                            {
                                            if( picUnique[ offc ] - picInner[ offc ] )
                                        {
                                        for( countT offc = 0 ; offc < cResultStructsNeeded ; offc ++ )
                                        boolT bMatchImage = 1 ;

                                        //}
                                        //    pfmInner->traceF( tinBaseP , stPathToYear , T("inner : ") ) ;
                                        //    picInner->traceF( tinBaseP , T("inner :    ") ) ;
                                        //{
                                        //if( bChatter )
                                        fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;
                                        imageCompareS* picInner  = (imageCompareS*)&pSwsMetaByShort->downF( tinBaseP , hSwsOuter ) ;
                                    {
                                    do
                                    handleC hSwsOuter( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

                                    if( timeModRoundedYoungest < pfmUnique->timeModRounded ) timeModRoundedYoungest = pfmUnique->timeModRounded ;

                                    //}
                                    //    pfmUnique->traceF( tinBaseP , stPathToYear , T("unique: ") ) ;
                                    //    picUnique->traceF( tinBaseP , T("unique:    ") ) ;
                                    //{
                                    //if( bChatter )
                                    fileMetaS*     pfmUnique = (fileMetaS*)( picUnique + cResultStructsNeeded ) ;
                                    imageCompareS* picUnique  = (imageCompareS*)&stRecUnique.downF( tinBaseP , hSt ) ;
                                {
                                do
                                handleC hSt( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            ZE( countT , timeModRoundedYoungest ) ;
                            // TALLY cVotes AND SET timeModRoundedYoungest

                            }
                                bChatter = 1 ;
                                etThread.traceF( tinBaseP , T("lengths or times or images differ [tShort]:    ")+tShort ) ;
                            {
                            if( stRecUnique > 1 )
                            ZE( boolT , bChatter ) ;
                        {
                        else                            // EVEN IF THERE IS ONLY WO PLATE, THERE IS STILL WORK TO DO BECAUSE THE FILE MIGHT NEED TO BE COPIED TO DESTINATIONS THAT DON'T HAVE IT
                        if( !stRecUnique ) { BLAMMO ; } //SHOULD  BE IMPOSSIBLE

                        while( ~hSwsOuter ) ;
                        do stRecUnique.sinkF( tinBaseP , countTC() , (byteT*)&pSwsMetaByShort->downF( tinBaseP , hSwsOuter ) , flSTACKsINK_UNIQUE , subtractFileMetaF ) ;
                        stackC stRecUnique( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_BLOB , stPathToYear * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ;
                        handleC hSwsOuter( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    {
                    if( !ether && cCopies > 1 )
                    //etThread.traceF( tinBaseP , T("[cFound,file]:    ")+TF2(cCopies,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+T(postzShort) ) ;

                    // PHASE 4: COPY TO ALL ARCHIVE CONTAINERS THAT DO NOT HAVE A COPY OF THIS FILE NAME
                    // PHASE 3: OVERWRITE ALL COPIES THAT DO NOT MATCH THIS UNIQUE META
                    // PHASE 2: IS THIS UNIQUE META VERIFIED (cVotes > 1)?
                    // PHASE 1: IDENTIFY THE UNIQUE META WITH THE LATEST FILE DATE
                    // HEALING ACTION HAS PHASES
                    // COMPARE AND FILE META FOR THIS FILE ARE SET AND READY FOR ANALYSIS AND HEALING ACTION
                    // THESE COMMENTS ARE OBSOLETED BY ACTUAL CODE WHICH CONTRADICTS THEM

                    while( !ether && ~hSwsOuter ) ;
                    }
                        etThread.delF( tinBaseP ,            pcBitsShiftLeftHeInMine ) ;
                        etThread.delF( tinBaseP ,            pcBitsShiftLeftMeInHis  ) ;
                        etThread.delF( tinBaseP , *(byteT**)&ppIdResultHeInMine      ) ;
                        etThread.delF( tinBaseP , *(byteT**)&ppIdResultMeInHis       ) ;
                        etThread.delF( tinBaseP ,            pcbwInner               ) ;
                        etThread.delF( tinBaseP , *(byteT**)&ppbwInner               ) ;

                        }
                            etThread.delF( tinBaseP , pEqual ) ;
                            }
                                //etThread.traceF( tinBaseP , T(pEqual[offo]?"        set other and myself to BITSrESULT_EQUAL because images match [offo]:    ":"        set other and myself to BITSrESULT_NOTeQUAL because images differ [offo]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                                }
                                    //etThread.traceF( tinBaseP , T("after  [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                    *ppIdResultMeInHis[  offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftMeInHis[  offo ] ;
                                    *ppIdResultHeInMine[ offo ] |= BITSrESULT_NOTeQUAL << pcBitsShiftLeftHeInMine[ offo ] ;
                                    //etThread.traceF( tinBaseP , T("before [offo,*ppIdResultHeInMine[offo],*ppIdResultMeInHis[offo]]:    ")+TF2(offo,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF4(*ppIdResultHeInMine[ offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2)+tb4+TF4(*ppIdResultMeInHis[  offo ],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
                                {
                                else
                                }
                                    *ppIdResultMeInHis[  offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftMeInHis[  offo ] ;
                                    *ppIdResultHeInMine[ offo ] |= BITSrESULT_EQUAL    << pcBitsShiftLeftHeInMine[ offo ] ;
                                {
                                if( pEqual[ offo ] )
                            {
                            for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ )

                            THREADmODE2rESTORE
                            }
                                if( !ether && cbDone != pfmOuter->cbUsed ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE

                                }
                                    cbDone += cbwOuter ;

                                    }
                                        }
                                            pcbwInner[ offi ] = 0 ;  // TELLS  TO GET ANOTHER WINDOW
                                            ppbwInner[ offi ] = 0 ;

                                            }
                                                }
                                                    thirdC::dosSleepWinkIF( tinBaseP ) ;
                                                    etThread.traceF( tinBaseP , T("exception while trying to access memory for a mapped file.  will retry [idWindow,idTry]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                else
                                                }
                                                    break;
                                                    }
                                                        //etThread.traceF( tinBaseP , T("images match between unique and inner [idWindow,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    {
                                                    else
                                                    }
                                                        //etThread.delF( tinBaseP , psttGen ) ;
                                                        //etThread.traceF( tinBaseP , T("wrote inner [gen]:    ")+T(psttGen) ) ;
                                                        //etThread.boxPutGenerationF( tinBaseP , psttGen , tLikeInner+TF3(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) , TUCK , ppbwInner[ offi ] , cbwOuter ) ; ___( psttGen ) ;

                                                        //etThread.delF( tinBaseP , psttGen ) ;
                                                        //etThread.traceF( tinBaseP , T("wrote outer [gen]:    ")+T(psttGen) ) ;
                                                        //etThread.boxPutGenerationF( tinBaseP , psttGen , tLikeOuter , TUCK , pbwOuter , cbwOuter ) ; ___( psttGen ) ;
                                                        //ZE( strokeS* , psttGen ) ;

                                                        pEqual[ offi ] = 0 ;
                                                        etThread.traceF( tinBaseP , T("difference detected between unique and inner [idWindow,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                    {
                                                    if( etThread.memCompareF( tinBaseP , pbwOuter , ppbwInner[ offi ] , cbwOuter ) )
                                                    //etThread.traceF( tinBaseP , T("attempting to compare images [idWindow,idTry,offi]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(idTry,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(offi,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                {
                                                if( !_restart )

                                                idTry ++ ;
                                                _restart.flags |= flRESTARTc_QUIET ;
                                                RESTART
                                            {
                                            while( !ether )
                                            ZE( countT , idTry ) ;
                                        {
                                        else
                                        }
                                            break ;
                                            bDone = 1 ;
                                            //etThread.traceF( tinBaseP , T("done inspecting images [idWindow]:    ")+TF2(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                        {
                                        if( !pbwOuter || !cbwOuter )

                                        if(   cbwOuter !=   pcbwInner[ offi ] ) { BLAMMO ; }     //SHOULD BE IMPOSSIBLE
                                        if( !!cbwOuter != !!pcbwInner[ offi ] ) { BLAMMO ; }     //SHOULD BE IMPOSSIBLE
                                        if( !!pbwOuter != !!ppbwInner[ offi ] ) { BLAMMO ; }     //SHOULD BE IMPOSSIBLE

                                        if( pcbwInner[ offi ] == - 1 ) pcbwInner[ offi ] = 0 ;            // tmFeedFileWindowsF IS DONE AND TERMINATING

                                        else           { if( pcbwInner[ offi ] != - 1           ) { BLAMMO ; } }     //SHOULD BE IMPOSSIBLE
                                        if( cbwOuter ) { if( pcbwInner[ offi ] == - 1 && !ether ) { BLAMMO ; } }     //SHOULD BE IMPOSSIBLE

                                        //etThread.traceF( tinBaseP , T("fed this [(countT)ppbwInner[offi],ppbwInner[offi]]:    ")+TF3((countT)ppbwInner[offi],flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+T(ppbwInner[offi]) ) ;
                                    {
                                    for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )

                                    }
                                        if( !bAgain ) break ;

                                        }
                                            }
                                                break ;
                                                bAgain = 1 ;
                                                thirdC::dosSleepWinkIF( tinBaseP ) ;
                                            {
                                            if( !pcbwInner[ offi ] )
                                        {
                                        for( countT offi = 0 ; offi < cInnerImagesToInspect ; offi ++ )
                                        ZE( boolT , bAgain ) ;
                                    {
                                    for(;;)     //WAIT FOR EVERY FEEDER TO SET ITS ppcwInner[] ELEMENT

                                    RETRY( fwsOuter.getF( tinBaseP , pbwOuter , cbwOuter ) )
                                    ZE( countT , cbwOuter ) ;
                                    ZE( byteT* , pbwOuter ) ;

                                    TN( tLikeInner , "///ideafarm/tmp/debug.inner." ) ; tLikeInner += TF3(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tDot ;
                                    TN( tLikeOuter , "///ideafarm/tmp/debug.outer." ) ; tLikeOuter += TF3(idWindow,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8) ;

                                    idWindow ++ ;
                                {
                                while( !ether && !bDone )
                                ZE( countT , idWindow ) ;
                                ZE( boolT , bDone ) ;
                                ZE( count04T , cbDone ) ;

                                //etThread.traceF( tinBaseP , T("inspecting images [cInnerImagesToInspect,tLongOuter]:    ")+TF2(cInnerImagesToInspect,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongOuter ) ;
                                fileWindowsC fwsOuter( tinBaseP , etThread , tLongOuter ) ;
                            {
                            THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )

                            for( countT offo = 0 ; offo < cInnerImagesToInspect ; offo ++ ) pEqual[ offo ] = 1 ;
                            etThread.newF( tinBaseP , LF , pEqual , cInnerImagesToInspect ) ; ___( pEqual ) ;
                            ZE( boolT* , pEqual ) ;
                            TN( tDot , "." ) ;

                            if( cFeedThreadsLaunched != cInnerImagesToInspect ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE
                        {
                        if( !ether && cInnerImagesToInspect )

                        }
                            }
                                while( !ether && ~hSwsInner ) ;
                                }
                                    }
                                        }
                                            break ;

                                            }
                                                cFeedThreadsLaunched ++ ;

                                                pcBitsShiftLeftHeInMine[ cFeedThreadsLaunched ] = cBitsShiftLeftHeInMine ;
                                                pcBitsShiftLeftMeInHis[  cFeedThreadsLaunched ] = cBitsShiftLeftMeInHis  ;
                                                ppIdResultHeInMine[      cFeedThreadsLaunched ] = &bitsResultHeInMine    ;
                                                ppIdResultMeInHis[       cFeedThreadsLaunched ] = &bitsResultMeInHis     ;

                                                etThread.osThreadF( TaRG3fLAGScBtLS( tmFeedFileWindowsF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&ppbwInner[ cFeedThreadsLaunched ] , (countT)&pcbwInner[ cFeedThreadsLaunched ] , (countT)psttLongInner ) ; psttLongInner = 0 ;

                                                etThread.strMakeF( tinBaseP , LF , psttLongInner , tLongInner ) ; ___( psttLongInner ) ;
                                                ZE( strokeS* , psttLongInner ) ;
                                            {
                                            if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                        {
                                        case 3 :
                                        }
                                            break ;

                                            }
                                                cInnerImagesToInspect ++ ;
                                                //etThread.traceF( tinBaseP , T("incrementing") ) ;
                                            {
                                            if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )

                                            //etThread.traceF( tinBaseP , T("        maybe incrementing cInnerImagesToInspect [bitsResultHeInMine,maskHeInMine,masked,cBitsShiftLeftHeInMine,inner]:    ")+TF2(bitsResultHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(maskHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((bitsResultHeInMine&maskHeInMine),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftHeInMine,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                        {
                                        case 2 :    // COUNT THE NUMBER OF INNER FILES FOR WHICH I MUST INSPECT THE IMAGE (I SET cInnerImagesToInspect HERE)
                                        }
                                            break ;

                                            }
                                                }
                                                    bitsResultHeInMine |= BITSrESULT_NOTeQUAL << cBitsShiftLeftHeInMine ;
                                                    bitsResultMeInHis  |= BITSrESULT_NOTeQUAL << cBitsShiftLeftMeInHis  ;
                                                    etThread.traceF( tinBaseP , T("        set other and myself to BITSrESULT_NOTeQUAL because cbUsed differs") ) ;
                                                {
                                                if( pfmOuter->cbUsed != pfmInner->cbUsed )
                                            {
                                            else if( ( bitsResultHeInMine & maskHeInMine ) == BITSrESULT_UNKNOWN << cBitsShiftLeftHeInMine )
                                            }
                                                //etThread.traceF( tinBaseP , T("        setted  myself to BITSrESULT_EQUAL [bitsResultMeInHis]:    ")+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                                bitsResultMeInHis |= BITSrESULT_EQUAL << cBitsShiftLeftMeInHis ;
                                                //etThread.traceF( tinBaseP , T("        setting myself to BITSrESULT_EQUAL [&bitsResultMeInHis,bitsResultMeInHis,&cBitsShiftLeftMeInHis,cBitsShiftLeftMeInHis]:    ")+TF2(&bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(bitsResultMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(&cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2(cBitsShiftLeftMeInHis,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                            {
                                            if( pfmInner == pfmOuter )
                                        {
                                        case 1 :    // SET bitsResult WITHOUT COMPARING FILE IMAGES
                                    {
                                    switch( idPass )

                                    //etThread.traceF( tinBaseP , T("    [idPass,tLongInner]:    ")+TF2(idPass,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
                                    TN( tLongInner , "" ) ; tLongInner = T((strokeS*)stPathToYear[pfmInner->idSlotPathToYear])+tShort ;

                                    countT maskHeInMine = BITSrESULT_ALLbITS << cBitsShiftLeftHeInMine ;
                                    countT maskMeInHis  = BITSrESULT_ALLbITS << cBitsShiftLeftMeInHis  ;

                                    countT cBitsShiftLeftHeInMine =           ( ( pfmInner->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;
                                    countT cBitsShiftLeftMeInHis  =           ( ( pfmOuter->idSlotPathToYear - 1 ) % cResultsPerStruct ) << 1 ;

                                    countT& bitsResultHeInMine    = picOuter[ ( pfmInner->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;
                                    countT& bitsResultMeInHis     = picInner[ ( pfmOuter->idSlotPathToYear - 1 ) / cResultsPerStruct ].bitsResult ;

                                    //picInner->traceF( tinBaseP , T("inner :    ") ) ;
                                    //pfmInner->traceF( tinBaseP , stPathToYear , T("inner: ") ) ;
                                    fileMetaS*     pfmInner = (fileMetaS*)( picInner + cResultStructsNeeded ) ;

                                    //etThread.traceF( tinBaseP , T("    [picInner]:    ")+TF2((countT)picInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                                    imageCompareS* picInner = (imageCompareS*)&pSwsMetaByShort->downF( tinBaseP , hSwsInner ) ;
                                {
                                do
                                handleC hSwsInner( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                            {
                            if( idPass != 3 || cInnerImagesToInspect )

                            }
                                etThread.memSetF( tinBaseP , (byteT*)pcBitsShiftLeftHeInMine , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tinBaseP , (byteT*)pcBitsShiftLeftMeInHis  , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tinBaseP , (byteT*)ppIdResultHeInMine      , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tinBaseP , (byteT*)ppIdResultMeInHis       , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tinBaseP , (byteT*)pcbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;
                                etThread.memSetF( tinBaseP , (byteT*)ppbwInner               , cInnerImagesToInspect * sizeof( countT* ) ) ;

                                etThread.newF( tinBaseP , LF ,             pcBitsShiftLeftHeInMine , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftHeInMine ) ;
                                etThread.newF( tinBaseP , LF ,             pcBitsShiftLeftMeInHis  , cInnerImagesToInspect ) ; ___( pcBitsShiftLeftMeInHis  ) ;
                                etThread.newF( tinBaseP , LF , *(countT**)&ppIdResultHeInMine      , cInnerImagesToInspect ) ; ___( ppIdResultHeInMine      ) ;
                                etThread.newF( tinBaseP , LF , *(countT**)&ppIdResultMeInHis       , cInnerImagesToInspect ) ; ___( ppIdResultMeInHis       ) ;
                                etThread.newF( tinBaseP , LF ,             pcbwInner               , cInnerImagesToInspect ) ; ___( pcbwInner               ) ;
                                etThread.newF( tinBaseP , LF , *(countT**)&ppbwInner               , cInnerImagesToInspect ) ; ___( ppbwInner               ) ;
                            {
                            if( idPass == 3 && cInnerImagesToInspect )
                        {
                        for( countT idPass = 1 ; !ether && idPass <= 3 ; idPass ++ )
                        ZE( countT   , cFeedThreadsLaunched  ) ;
                        ZE( countT*  , pcBitsShiftLeftHeInMine ) ;
                        ZE( countT*  , pcBitsShiftLeftMeInHis  ) ;
                        ZE( countT** , ppIdResultHeInMine      ) ;
                        ZE( countT** , ppIdResultMeInHis       ) ;
                        ZE( countT*  , pcbwInner               ) ;
                        ZE( byteT**  , ppbwInner               ) ;
                        ZE( countT   , cInnerImagesToInspect   ) ;

                        //pfmOuter->traceF( tinBaseP , stPathToYear , T("outer: ") ) ;
                        //etThread.traceF( tinBaseP , T("[tLongOuter]:    ")+tLongOuter ) ;
                        TN( tLongOuter , "" ) ; tLongOuter = T((strokeS*)stPathToYear[pfmOuter->idSlotPathToYear])+tShort ;

                        //picOuter->traceF( tinBaseP , T("outer :    ") ) ;
                        fileMetaS*     pfmOuter = (fileMetaS*)( picOuter + cResultStructsNeeded ) ;
                        imageCompareS* picOuter  = (imageCompareS*)&pSwsMetaByShort->downF( tinBaseP , hSwsOuter ) ;
                    {
                    do
                    handleC hSwsOuter( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
                    // SET ALL COMPARE META ELEMENTS FOR EACH FILE'S IMAGE COMPARE META ARRAY
                {
                //if( idf <= 4 ) // FOR TESTING.  IN PRODUCTION, COMMENT OUT THIS LINE

                }
                    etThread.traceF( tinBaseP , T("!tShort.csF() [cShortFileNames,idf]:    ")+TF2(cShortFileNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( !tShort.csF( tinBaseP ) )

                TN( tShort , postzShort ) ;

                countT cCopies = *pSwsMetaByShort ;
                postzShort = (osTextT*)pSwsMetaByShort->leverF( tinBaseP , idf ) ;

                }
                    etThread.traceF( tinBaseP , T("[cFiles,perTuck,idf]:    ")+TF2(cShortFileNames,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF3(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2)+tb+tPerTuck+tb4+TF2(idf,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                    countT perTuck = ( idf << 8 ) / cShortFileNames ;
                {
                //if( !( idf % ( TUCK >> 7 ) ) )
            {
            for( countT idf = 1 ; idf <= cShortFileNames ; idf ++ )
            etThread.traceF( tinBaseP , T("inspecting metadata and comparing images for each copy of each file") ) ;

            const countT cShortFileNames = pSwsMetaByShort->cFlavorsF( tinBaseP ) ;

            pSwsMetaByShort->grabF( tinBaseP , TAG( TAGiDnULL ) ) ;      //SHOULD NOT BE NEEDED SINCE ALL KIDS ARE GONE OR PAUSED

            // *pSwsMetaByShort NOW CONTAINS META (FILE META AND INITIALIZED ACCUMULATORS FOR COMPARE META)

            //etThread.tracePoolTalliesF( tinBaseP ) ;
            //etThread.traceF( tinBaseP , T("calling tracePoolTalliesF / file meta is loaded") ) ;

            etThread.delF( tinBaseP , postShortCutoff ) ;
            }
                THREADmODE2rESTORE
                }
                    if( cPausedAtCutoff == cWorkers ) break ;
                    thirdC::dosSleepWinkIF( tinBaseP ) ;
                {
                for(;;)
                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
            {
            etThread.traceF( tinBaseP , T("waiting for all workers to pause or die") ) ;

            //U::while( cWaiting ) sgnGo.giveF( tinBaseP ) ;       //cWaiting IS USED TO AVOID A RACE CONDITION: A THREAD THAT HAS INCREMENTED cCutoffUpdates BUT HAS NOT YET CALLED waitF WILL NOT SEE THIS SIGN
            sgnGo.giveF( tinBaseP ) ;
            thirdC::dosSleepWinkIF( tinBaseP ) ; // TO AVOID RACE
            cCutoffUpdates = 0 ;
            etThread.traceF( tinBaseP , T("final cutoff [postShortCutoff]:    ")+T(postShortCutoff) ) ;
            }
                THREADmODE2rESTORE
                while( cCutoffUpdates < cWorkers ) thirdC::dosSleepWinkIF( tinBaseP ) ;
                THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
            {
            //etThread.traceF( tinBaseP , T("waiting for all workers to update postShortCutoff") ) ;
        {
        while( cWorkers )

        }
            if( idPass == 1 ) stPathToYear.lockIfF( tinBaseP ) ;

            while( ~hSwsPathToArchives ) ;
            }
                etThread.delF( tinBaseP , pstt1PathToYear ) ;
                }
                    }
                        etThread.osThreadF( TaRG3fLAGScBtLS( tmCollectFileMetaF , flTHREADlAUNCH_NOiNoUTfRAMEsUPPORT , CBtLSmINIMUM ) , (countT)&cWorkers , (countT)&stPathToYear , idSlotPathToYear , (countT)&postzShort , (countT)pSwsMetaByShort , (countT)&grabCutoff , (countT)&postShortCutoff , (countT)&cCutoffUpdates , (countT)&sgnGo , (countT)&cPausedAtCutoff , (countT)&cWaiting ) ;
                        inc02AM( cWorkers ) ;
                        countT idSlotPathToYear = stPathToYear( psttc1 ) ;
                    {
                    else
                    }
                       }
                           BLAMMO ; //SHOULD BE IMPOSSIBLE
                           etThread.delF( tinBaseP , psttPathToYear ) ;
                       {
                       if( !idSlotPathToYear )
                       stPathToYear.sinkF( tinBaseP , idSlotPathToYear , psttPathToYear , flSTACKsINK_UNIQUE ) ;
                       ZE( countT , idSlotPathToYear ) ;

                       etThread.strMakeF( tinBaseP , LF , psttPathToYear , psttc1 ) ; ___( psttPathToYear ) ;
                       ZE( strokeS* , psttPathToYear ) ;
                    {
                    if( idPass == 1 )
                {
                FORsTRINGSiN1( pstt1PathToYear )

                //etThread.traceF( tinBaseP , T("[pstt1PathToYear]:    ")+T(pstt1PathToYear) ) ;
                etThread.strConvertToLowerCaseF( tinBaseP , pstt1PathToYear ) ;
                etThread.diskFindFileOrDirF( tinBaseP , pstt1PathToYear , tPathToArchive , &pat ) ; ___( pstt1PathToYear ) ;
                patternC pat( tinBaseP , etThread , tYearSlash , ifcIDtYPEpATTERN_FOREIGNwILDCARDsTRICT ) ;
                ZE( strokeS* , pstt1PathToYear ) ;

                //etThread.traceF( tinBaseP , T("[tPathToArchive]:    ")+tPathToArchive ) ;
                TN( tPathToArchive , "" ) ; tPathToArchive = T(psttzPathToArchives)+T(psttzArchiveP)+tSlash ;
                strokeS* psttzPathToArchives = *(strokeS**)&swsPathToArchivesByArchiveNameP.downF( tinBaseP , hSwsPathToArchives ) ;
            {
            do
            handleC hSwsPathToArchives( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;

            }
                pSwsMetaByShort = new( 0 , tinBaseP , LF ) switchStackC( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_SINKrEVERSE | flSTACKc_SINKiGNOREtABS , &postzShort , flSTACKc_BLOB | flSTACKc_ALLOWzE , cResultStructsNeeded * sizeof( imageCompareS ) + sizeof( fileMetaS ) ) ; ___( pSwsMetaByShort ) ;
                cResultStructsNeeded = 1 + cSlotsPathToYear / cResultsPerStruct ;
                cSlotsPathToYear = stPathToYear ;
            {
            if( idPass == 2 )
        {
        for( countT idPass = 1 ; idPass <= 2 ; idPass ++ )
        ZE( countT , cWaiting ) ;
        ZE( countT , cPausedAtCutoff ) ;
        signC sgnGo( tinBaseP , TAG( TAGiDnULL ) ) ;
        ZE( countT   , cCutoffUpdates ) ;
        ZE( osTextT* , postShortCutoff ) ;
        grabC grabCutoff( tinBaseP , TAG( TAGiDnULL ) ) ;
        ZE( countT , cWorkers ) ;
        stackC stPathToYear( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_null , ifcSTACKtYPE_PTR_strokeS ) ;
        ZE( switchStackC* , pSwsMetaByShort ) ;       // cbData IS NOT KNOWN UNTIL PASS 1 COMPLETES ; WILL BE CT'D IN PASS 2 USING THE THEN KNOWN NUMBER OF PATHS FOR THIS ARCHIVE NAME
        ZE( osTextT* , postzShort  ) ;
        ZE( countT   , cResultStructsNeeded ) ;
        ZE( countT   , cSlotsPathToYear     ) ;     //U:: THIS IS CALCULATED INCORRECTLY EXCEPT WHEN THERE IS ONLY WO YEAR.  RATHER THAN FIX IT, REDESIGN CODE TO PROCESS WO YEAR AT A TIME (OR USE A SEPARATE SWS FOR EACH YEAR AND DO IT IN PARALLEL).  SUCH A REDESIGN WILL ALSO MAKE IT EASIER TO THROTTLE PUSHING TO LIMIT THE NUMBER OF FLAVORS IN THE SWS, WHICH IS NECEWSSARY TO AVOID EXHAUSTING MEMORY SPACE

        etThread.traceF( tinBaseP , T("executive [pattern]:    ")+tYearSlash ) ;
        etThread.delF( tinBaseP , psttYearP ) ;
        TN( tYearSlash , "" ) ; tYearSlash = T(psttYearP)+T("/") ;

        TN( tPatRejects  , "/ipdos.archives.rejects/" ) ;
        TN( tPatArchives , "/ipdos.archives/" ) ;
        //CS:CODEsYNC: 2 2

        TN( tPerTuck , "%" ) ;
        TN( tSlash , "/" ) ;
        TN( tb4    , "    " ) ;
        TN( tb , " " ) ;
    {

    switchStackC& swsPathToArchivesByArchiveNameP = *(switchStackC*)pTaskP->c4 ;
    strokeS*&     psttzArchiveP                   =     *(strokeS**)pTaskP->c3 ;
    strokeS*      psttYearP                       =       (strokeS*)pTaskP->c2 ;
    countT&       cExecutiveHealYearP             =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmExecutiveHealYearF )

DONE( tmCopyFileF )
}
    etThread.delF( tinBaseP , psttFromP ) ;
    etThread.delF( tinBaseP , psttToP   ) ;

    }
        }
            }
                if( !bOk ) etThread.traceF( tinBaseP , T("diskCopyFileF failed too many times.  will not retry [to,from]:    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
                }
                    }
                        thirdC::dosSleepWinkIF( tinBaseP , 2 ) ;
                        etThread.traceF( tinBaseP , T("diskCopyFileF failed.  will retry [cRetries,to,from]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
                        POOPR
                    {
                    else
                    }
                        break ;
                        bOk = 1 ;
                    {
                    if( !POOP )
                    ((tinNormalS&)tinBaseP).pEtScratch->diskCopyFileF( tinBaseP , psttToP , psttFromP , 1 ) ;
                {
                while( cTries && cTries -- )
                ZE( boolT , bOk ) ;

                cTries = 8 ;

                etThread.traceF( tinBaseP , T("copying [to,from]:    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
            {
            else
            else if( bExists ) etThread.traceF( tinBaseP , T("bizarre!  there is still a file in the way, so not copying [to,from]:    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
                 if( !bOk    ) etThread.traceF( tinBaseP , T("after rejecting a file out of the way, not copying because could not obtain bExists (probable drive failure) [to,from]:    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;

            }
                }
                    thirdC::dosSleepWinkIF( tinBaseP , 2 ) ;
                    etThread.traceF( tinBaseP , T("diskFileExistsF failed.  will retry [cRetries,to,from]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
                    POOPR
                {
                else
                }
                    break ;
                    bOk = 1 ;
                {
                if( !POOP )
                bExists = ((tinNormalS&)tinBaseP).pEtScratch->diskFileExistsF( tinBaseP , psttToP ) ;
            {
            while( cTries && cTries -- )
            cTries = 8 ;
            bOk = bExists = 0 ;

            countT cTries = 8 ;

            }
                etThread.delF( tinBaseP , psttLongInRejects ) ;
                etThread.delF( tinBaseP , psttRejected ) ;

                etThread.traceF( tinBaseP , T("rejected  file from archive because would have been overwritten [reject,from]:    ")+T(psttRejected)+T("    ")+T(psttToP) ) ;
                etThread.diskMoveFileOrDirUniqueF( tinBaseP , psttRejected , psttToP , psttLongInRejects ) ;
                ZE( strokeS* , psttRejected ) ;

                etThread.strReplaceF( tinBaseP , psttLongInRejects , psttToP , tPatArchives , tPatRejects ) ; ___( psttLongInRejects ) ;
                ZE( strokeS* , psttLongInRejects ) ;
            {
            if( bExists )
        {
        else
        if( !bOk ) etThread.traceF( tinBaseP , T("not copying because could not obtain bExists (probable drive failure) [to,from]:    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;

        }
            }
                thirdC::dosSleepWinkIF( tinBaseP , 2 ) ;
                etThread.traceF( tinBaseP , T("diskFileExistsF failed.  will retry [cRetries,to,from]:    ")+TF2(cTries,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T(psttToP)+T("    ")+T(psttFromP) ) ;
                POOPR
            {
            else
            }
                break ;
                bOk = 1 ;
            {
            if( !POOP )
            bExists = ((tinNormalS&)tinBaseP).pEtScratch->diskFileExistsF( tinBaseP , psttToP ) ;
        {
        while( cTries && cTries -- )
        ZE( boolT , bOk ) ;
        ZE( boolT , bExists ) ;

        countT cTries = 8 ;

        SCOOPS
    {
    IFsCRATCH

    TN( tPatRejects  , "/ipdos.archives.rejects/" ) ;
    TN( tPatArchives , "/ipdos.archives/" ) ;
    //CS:CODEsYNC: 2 2

    strokeS* psttFromP = (strokeS*)pTaskP->c2 ;
    strokeS* psttToP   = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmCopyFileF )

DONE( tmMoveFileToUniqueF )
}
    etThread.delF( tinBaseP , psttFromP ) ;
    etThread.delF( tinBaseP , psttToP   ) ;
    etThread.delF( tinBaseP , psttUnique ) ;

    etThread.traceF( tinBaseP , T("moved [to,from]:    ")+T(psttUnique)+T("    ")+T(psttFromP) ) ;
    etThread.diskMoveFileOrDirUniqueF( tinBaseP , psttUnique , psttFromP , psttToP ) ;
    ZE( strokeS* , psttUnique ) ;

    strokeS* psttFromP = (strokeS*)pTaskP->c2 ;
    strokeS* psttToP   = (strokeS*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 )
TASK( tmMoveFileToUniqueF )

DONE( tmFeedFileWindowsF )
}
    }
        }
            }
                cbwInnerP = cbwInner ;
                pbwInnerP = pbwInner ;
            {
            else
            }
                break ;
                cbwInnerP = - 1 ;
            {
            if( ether || !pbwInner || !cbwInner )

            //etThread.traceF( tinBaseP , T("get returned [(countT)pbwInner,pbwInner]:    ")+TF3((countT)pbwInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+T(pbwInner) ) ;
            //etThread.traceF( tinBaseP , T("tmFeedFileWindowsF / called getF [idIn,pbwInner,cbwInner,tLongInner]                 :         ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF3((countT)pbwInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+TF3(cbwInner,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FOREIGN|flFORMAT_FILLzE,8)+tb4+tb4+tLongInner ) ;
            RETRY( fwsInner.getF( tinBaseP , pbwInner , cbwInner ) )
            //etThread.traceF( tinBaseP , T("tmFeedFileWindowsF / calling getF [idIn,tLongInner]                 :         ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
            ZE( countT , cbwInner ) ;
            ZE( byteT* , pbwInner ) ;

            else        while( !ether && cbwInnerP ) thirdC::dosSleepWinkIF( tinBaseP ) ;
            if( bWoth ) bWoth = 0 ;
        {
        while( !ether )
        boolT bWoth = 1 ;

        fileWindowsC fwsInner( tinBaseP , etThread , tLongInner ) ;
    {
    if( !POOP )

    //etThread.traceF( tinBaseP , T("tmFeedFileWindowsF / + [idIn,tLongInner]                 :         ")+TF2(idIn,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+tLongInner ) ;
    TN( tLongInner , psttLongInnerP ) ; etThread.delF( tinBaseP , psttLongInnerP ) ;
    TN( tb4 , "    " ) ;

    countT idIn = 1 + incv02AM( idInLath ) ;
    static countT idInLath ;

    __Z( psttLongInnerP ) ;
    __NZ( cbwInnerP ) ;
    __NZ( pbwInnerP ) ;

    strokeS* psttLongInnerP          = (strokeS*)pTaskP->c3 ;
    countT&  cbwInnerP               = *(countT*)pTaskP->c2 ;
    byteT*&  pbwInnerP               = *(byteT**)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 )
TASK( tmFeedFileWindowsF )

DONE( tmCollectFileMetaF )
}
    dec02AM( cWorkersP ) ;

    }
        etThread.traceF( tinBaseP , T("ended archive pathToYear:    ")+tPathToYearP ) ;
        }
            while( ~hWalk ) ;
            }
                DEL( pInfoFile ) ;
                }
                    swsMetaByShortP.ungrabF( tinBaseP ) ;
                    //etThread.traceF( tinBaseP , T("after pushing meta for a file [cFlavors]:    ")+TF2(swsMetaByShortP.cFlavorsF(tinBaseP),flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;

                    new( 0 , tinBaseP , (byteT*)pCursor , sizeof( fileMetaS ) ) fileMetaS( tinBaseP , idSlotPathToYearP , time1Mod , time2Mod , cbUsed ) ;

                    pCursor += cResultStructsNeeded ;
                    for( countT offs = 0 ; offs < cResultStructsNeeded ; offs ++ ) new( 0 , tinBaseP , (byteT*)( pCursor + offs ) , sizeof( imageCompareS ) ) imageCompareS ;
                    countT cResultStructsNeeded = 1 + cSlotsPathToYear / cResultsPerStruct ;
                    imageCompareS* pCursor = (imageCompareS*)&swsMetaByShortP[ 1 ] ;

                    swsMetaByShortP << (byteT*)0 ;

                    //etThread.traceF( tinBaseP , T("[idFile,postzShortP]:    ")+TF2(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE)+tb4+T(postzShortP) ) ;
                    postzShortP = tShort ;
                    swsMetaByShortP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                    count04T cbUsed = pInfoFile->cbUsedHigh << sizeof( count02T ) * SB | pInfoFile->cbUsed ;

                    sCountT time2Mod = pInfoFile->timeWritten2 ;
                    countT  time1Mod = pInfoFile->timeWritten1 ;

                    }
                        etThread.traceF( tinBaseP , T("[perTuck,idFile]:    ")+TF3(perTuck,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,2)+tb+tPerTuck+tb4+TF2(idFile,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                        countT perTuck = ( idFile << 8 ) / cFiles ;
                    {
                    if( !( idFile % ( TUCK << 2 ) ) )

                    ++ idFile ;
                                                               
                    }
                        etThread.delF( tinBaseP , psttYearSlashShort ) ;
                        etThread.delF( tinBaseP , psttPath ) ;
                        tYearSlashShort = T(psttYearSlashShort) ;
                        tPath  = T(psttPath) ;
                        etThread.strBisectF( tinBaseP , psttPath , psttYearSlashShort , tFileName , T("/") , - 2 , flSTRbISECT_APPENDdELIMITER ) ; ___( psttPath ) ; ___( psttYearSlashShort ) ;
                        ZE( strokeS* , psttYearSlashShort ) ;
                        ZE( strokeS* , psttPath ) ;
                    {
                    TN( tYearSlashShort , "" ) ;
                    TN( tPath  , "" ) ;

                    TN( tFileName , pInfoFile->psttIfoName ) ;
                {
                if( pInfoFile )
                RETRYsCR( diskFileQueryF( tinBaseP , pInfoFile , fi ) ) ___( pInfoFile ) ;
                fileC fi( tinBaseP , (strokeS*)tLong , ifcOPENaCCESS_R ) ;
                ZE( infoFileS* , pInfoFile ) ;

                TN( tLong , "" ) ; tLong = tPathToYearP+tShort ;

                }
                    //etThread.traceF( tinBaseP , T("resumed collecting file meta into sws, using stIdJot") ) ;

                    //etThread.traceF( tinBaseP , T("waited  for sgnGo") ) ;
                    dec02AM( cWaitingP ) ;
                    sgnGoP.waitF( tinBaseP ) ;
                    inc02AM( cCutoffUpdatesP ) ;
                    inc02AM( cWaitingP ) ;
                    //etThread.traceF( tinBaseP , T("waiting for sgnGo") ) ;

                    }
                        }
                            }
                                grabCutoffP.ungrabF( tinBaseP ) ;

                                }
                                    etThread.strMakeF( tinBaseP , LF , postShortCutoffP , tShortCutoff ) ; ___( postShortCutoffP ) ;
                                    etThread.delF( tinBaseP , postShortCutoffP ) ;
                                {
                                if( !postShortCutoffP || 0 < thirdC::c_strcmpIF( tinBaseP , postShortCutoffP , tShortCutoff ) )

                                grabCutoffP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                                if( !tShortCutoff.csF( tinBaseP ) ) { BLAMMO ; }      //SHOULD BE IMPOSSIBLE
                                //etThread.traceF( tinBaseP , T("proposed [tShortCutoff]:    ")+tShortCutoff ) ;
                                TN( tShortCutoff , (const byteT*)page ) ;
                            {
                            else
                            if( !page ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE

                            pageC page = jotShortFileNames[ idjCutoff ] ;
                        {
                        if( idjCutoff )
                        countT idjCutoff = stIdJot[ (sCountT)( 0 - idPlateCutoffWanted ) ] ;
                    {
                    if( stIdJot > idPlateCutoffWanted )
                    countT idPlateCutoffWanted = idPlate - 1 + BATCHsIZE ;
                    //CS:CODEsYNCH: PSEUDODUPLICATE 1
                    //etThread.traceF( tinBaseP , T("calculating the next proposed cutoff value") ) ;

                    //etThread.traceF( tinBaseP , T("waited  for sgnGo") ) ;
                    dec02AM( cPausedAtCutoffP ) ;
                    dec02AM( cWaitingP ) ;
                    sgnGoP.waitF( tinBaseP ) ;
                    inc02AM( cPausedAtCutoffP ) ;
                    inc02AM( cWaitingP ) ;
                    //etThread.traceF( tinBaseP , T("waiting for sgnGo (the short name that i would now process is beyond the cutoff)") ) ;
                {
                if( postShortCutoffP && 0 < thirdC::c_strcmpIF( tinBaseP , tShort , postShortCutoffP ) )

                if( !tShort.csF( tinBaseP ) ) { BLAMMO ; }      //SHOULD BE IMPOSSIBLE

                //etThread.traceF( tinBaseP , tShort ) ;
                }
                    else        tShort = T((const byteT*)page) ;
                    if( !page ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE
                    pageC page = jotShortFileNames[ idj ] ;
                {
                TN( tShort , "" ) ;

                countT idj = stIdJot.upF( tinBaseP , hWalk ) ;

                idPlate ++ ; //SINCE I AM GOING UP, THIS IS NOT THE idPlate ASSOCIATED WITH stackC MEMBER FUNCTIONS, FOR WHICH THE TOP PLATE IS idPlate 1
            {
            do
            handleC hWalk( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
            ZE( countT , idFile ) ;
            ZE( countT , idPlate ) ;
        {
        if( stIdJot )
        etThread.traceF( tinBaseP , T("collecting file meta into sws, using stIdJot") ) ;

        //etThread.traceF( tinBaseP , T("waited  for sgnGo") ) ;
        dec02AM( cWaitingP ) ;
        sgnGoP.waitF( tinBaseP ) ;
        inc02AM( cCutoffUpdatesP ) ;
        inc02AM( cWaitingP ) ;
        //etThread.traceF( tinBaseP , T("waiting for sgnGo") ) ;

        }
            }
                }
                    grabCutoffP.ungrabF( tinBaseP ) ;

                    }
                        etThread.strMakeF( tinBaseP , LF , postShortCutoffP , tShortCutoff ) ; ___( postShortCutoffP ) ;
                        etThread.delF( tinBaseP , postShortCutoffP ) ;
                    {
                    if( !postShortCutoffP || 0 < thirdC::c_strcmpIF( tinBaseP , postShortCutoffP , tShortCutoff ) )

                    grabCutoffP.grabF( tinBaseP , TAG( TAGiDnULL ) ) ;

                    if( !tShortCutoff.csF( tinBaseP ) ) { BLAMMO ; }      //SHOULD BE IMPOSSIBLE
                    //etThread.traceF( tinBaseP , T("proposed [tShortCutoff]:             ")+tShortCutoff ) ;
                    TN( tShortCutoff , (const byteT*)page ) ;
                {
                else
                if( !page ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE

                pageC page = jotShortFileNames[ idjCutoff ] ;
            {
            if( idjCutoff )
            countT idjCutoff = stIdJot[ (sCountT)( 0 - BATCHsIZE ) ] ;
        {
        if( stIdJot > BATCHsIZE )
        //CS:CODEsYNCH: PSEUDODUPLICATE 1
        //etThread.traceF( tinBaseP , T("calculating a proposed cutoff value") ) ;

        //}
        //    while( ~hWalk ) ;
        //    }
        //        }
        //            //etThread.traceF( tinBaseP , T((const byteT*)page) ) ;
        //        {
        //        else
        //        if( !page ) { BLAMMO ; } //SHOULD BE IMPOSSIBLE
        //
        //        pageC page = jotShortFileNames[ idj ] ;
        //
        //        countT idj = stIdJot.upF( tinBaseP , hWalk ) ;
        //    {
        //    do
        //    handleC hWalk( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_STACKwALK ) ;
        //{
        //if( stIdJot )
        //etThread.traceF( tinBaseP , T("reading in sorted order, using stIdJot") ) ;

        etThread.traceF( tinBaseP , T("counted files [cFiles,stIdJot]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+tb4+TF2((countT)stIdJot,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        }
            while( !ether && ~hFindFile && !POOP ) ;
            }
                DEL( pInfoFile ) ;
                }
                    }
                        stIdJot.sinkF( tinBaseP , countTC() , idJot , flSTACKsINK_null , subtractJottedOsTextF ) ;
                        countT idJot = jotShortFileNames.writeF( tinBaseP , tShort , tShort.csF( tinBaseP ) + 1 ) ;
                    {
                    if( tShort.csF( tinBaseP ) )        // IF NOT A DIRECTORY
                                                               
                    }
                        etThread.delF( tinBaseP , psttShort ) ;
                        etThread.delF( tinBaseP , psttnu ) ;
                        tShort  = T(psttShort) ;
                        etThread.strBisectF( tinBaseP , psttnu , psttShort , pInfoFile->psttIfoName , T("/") , - 1 , flSTRbISECT_null ) ; ___( psttnu ) ; ___( psttShort ) ;
                        ZE( strokeS* , psttShort ) ;
                        ZE( strokeS* , psttnu ) ;
                    {
                    TN( tShort , "" ) ;
                    cFiles ++ ;
                {
                else
                }
                    break ;
                    DEL( pInfoFile ) ;
                {
                if( !pInfoFile || !pInfoFile->psttIfoName )

                RETRYsCR( diskFindFileOrDirF( tinBaseP , pInfoFile , hFindFile , tPathToYearP ) )
                ZE( infoFileS* , pInfoFile ) ;

                }
                    etThread.traceF( tinBaseP , T("[cFiles]:    ")+TF2(cFiles,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
                {
                if( cFiles && !( cFiles % ( TUCK << 4 ) ) )
            {
            do
            sleepC s( tinBaseP , TAG( TAGiDnULL ) ) ;
            handleC hFindFile( tinBaseP , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_FILEfIND ) ;
        {
        ZE( countT , cFiles ) ;
        stackC stIdJot( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_DOnOTsERIALIZE | flSTACKc_SINKiGNOREtABS | flSTACKc_SINKrEVERSE ) ;
        jotC jotShortFileNames( tinBaseP , "short.file.names" , flJOTc_WRITE | flJOTc_PRIVATE | flJOTc_DELETE | flJOTc_PURGEoNcT , 1 ) ;            //U:: 1 IS ARBITRARY AND WILL BE INSUFFICIENT WHEN SORTING MUST REACH BEYOND THE PRIOR BOOK.  ENHANCE jotC TO SUPPORT A REASONABLE DEFAULT NUMBER OF INACTIVE
        etThread.traceF( tinBaseP , T("counting files") ) ;

        etThread.traceF( tinBaseP , T("this thread's job: [volume,pathToYear]:    ")+tVolumeName+tb4+tPathToYearP ) ;

        //}
        //    etThread.delF( tinBaseP , pstt1Words ) ;
        //    }
        //        else if( bArm                                               ) bArm -- ;
        //        else if( !etThread.strCompareF( tinBaseP , psttc1 , tArchives ) ) bArm = 2 ;
        //             if( bArm == 1                                          ) tYear = T(psttc1) ;
        //    {
        //    FORsTRINGSiN1( pstt1Words )
        //    TN( tArchives , "ipdos.archives" ) ;
        //    ZE( boolT , bArm ) ;
        //    etThread.strWordsF( tinBaseP , pstt1Words , tPathToYearP , sttq , T("/") ) ; ___( pstt1Words ) ;
        //    strokeS sttq( 0 , sc_IGNOREqUOTES ) ;
        //    ZE( strokeS* , pstt1Words ) ;
        //{
        //TN( tYear , "" ) ;

        }
            DEL( pInfoDisk ) ;
            tVolumeName = T(pInfoDisk->psttVolumeName) ;
            etThread.strConvertToLowerCaseF( tinBaseP , pInfoDisk->psttVolumeName ) ;
            etThread.delF( tinBaseP , psttDisk ) ;
            RETRYsCR( diskInfoF( tinBaseP , pInfoDisk , psttDisk ) ) ; ___( pInfoDisk ) ;
            ZE( infoDiskS* , pInfoDisk ) ;

            etThread.strSubstringF( tinBaseP , psttDisk , idf , idl , tPathToYearP ) ; ___( psttDisk ) ;
            countT idl = 5 ;
            countT idf = 1 ;
            ZE( strokeS* , psttDisk ) ;
        {
        TN( tVolumeName , "" ) ;

        TN( tPathToYearP , (strokeS*)stPathToYearP[ idSlotPathToYearP ] ) ;
        TN( tPerTuck , "%" ) ;
        TN( tDot , "." ) ;
        TN( tb4 , "    " ) ;
        TN( tb , " " ) ;
        const countT  cSlotsPathToYear = stPathToYearP ;
    {

    countT&       cWaitingP                =       *(countT*)pTaskP->cb ;
    countT&       cPausedAtCutoffP         =       *(countT*)pTaskP->ca ;
    signC&        sgnGoP                   =        *(signC*)pTaskP->c9 ;
    countT&       cCutoffUpdatesP          =       *(countT*)pTaskP->c8 ;
    osTextT*&     postShortCutoffP         =     *(osTextT**)pTaskP->c7 ;
    grabC&        grabCutoffP              =        *(grabC*)pTaskP->c6 ;
    switchStackC& swsMetaByShortP          = *(switchStackC*)pTaskP->c5 ;
    osTextT*&     postzShortP              =     *(osTextT**)pTaskP->c4 ;
    countT        idSlotPathToYearP        =                 pTaskP->c3 ;
    stackC&       stPathToYearP            =       *(stackC*)pTaskP->c2 ;
    countT&       cWorkersP                =       *(countT*)pTaskP->c1 ;
{
if( pTaskP && pTaskP->c1 && pTaskP->c2 && pTaskP->c3 && pTaskP->c4 && pTaskP->c5 && pTaskP->c6 && pTaskP->c7 && pTaskP->c8 && pTaskP->c9 && pTaskP->ca && pTaskP->cb )
TASK( tmCollectFileMetaF )

#endif
}

{
//CODEmINE:
#if defined( NEVERdEFINED )

}
    return sgn ;

    }
        ether.delF( tinBaseP , post1Copy ) ;

        sgn = thirdC::c_strcmpIF( tinBaseP , post1Copy , post2 ) ; ;
        //ether.traceF( tinBaseP , T("subtract [post1,post2]:    ")+T(post1Copy)+T("    ")+T(post2) ) ;

        }
            BLAMMO ;
            ether.traceF( tinBaseP , T("subtractJottedOsTextF / could not obtain text [idJot]:    ")+TF2(c2P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        if( !post2 )

        }
            BLAMMO ;
            ether.traceF( tinBaseP , T("subtractJottedOsTextF / could not obtain text [idJot]:    ")+TF2(c1P,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
        {
        if( !post1Copy )

        const osTextT* post2 = page2 ;
        pageC page2 = jotC::readIF( tinBaseP , c2P ) ;

        }
            thirdC::c_memcpyIF( tinBaseP , post1Copy , post1 , cost1 ) ;    
            ether.newF( tinBaseP , LF , post1Copy , cost1 ) ; ___( post1Copy ) ;
            countT         cost1 = page1 ;
            const osTextT* post1 = page1 ;
            pageC page1 = jotC::readIF( tinBaseP , c1P ) ;
        {
        ZE( osTextT* , post1Copy ) ;

        etherC& ether = *(etherC*)pEther ;
    {
    if( pEther )
    ZE( sCountT , sgn ) ;

    }
    {
    IFbEcAREFUL
{
/*1*/countT subtractJottedOsTextF( tinBaseS& tinBaseP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    return *pfr1 - *pfr2 ;

    fileMetaS* pfr2 = (fileMetaS*)c2P ;
    fileMetaS* pfr1 = (fileMetaS*)c1P ;
{
/*1*/countT subtractFileMetaF( tinBaseS& tinBaseP , countT& pEther , countT& c1P , countT& c2P , countT& c3P )/*1*/

}
    ((tinNormalS&)tinBaseP).pEther->traceF( tinBaseP , T(psttP)+T(" [bitsResult]:    ")+TF4(bitsResult,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,0x20,2) ) ;
{
voidT imageCompareS::traceF( tinBaseS& tinBaseP , const strokeS* const psttP )

}
    //traceF( tinBaseP , T("ct      :    ") ) ;
    TINSL
{
bitsResult( BITSrESULT_UNKNOWN )
imageCompareS::imageCompareS( voidT ) :

NEWdELcLASS( 2 , imageCompareS ) ;

}
    return ((tinNormalS&)tinBaseP).pEther->memCompareF( tinBaseP , (byteT*)this , (byteT*)&frP , sizeof( countT ) + sizeof( count04T ) ) ;    //CS:CODEsYNC 1 1
    TINSL
{
sCountT fileMetaS::operator -( const fileMetaS& frP ) const

}
    ((tinNormalS&)tinBaseP).pEther->traceF( tinBaseP , T(psttP)+T(" [timeModRounded,timeMod,cbUsed,cVotes,idSlotPathToYear,path]:    ")+TF3(timeModRounded,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED|flFORMAT_FILLzE,8)+T("    ")+TT(time1Mod,time2Mod)+T("    ")+TT(((countT*)&cbUsed)[0],((countT*)&cbUsed)[1])+T("    ")+TF2(cVotes,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+TF2(idSlotPathToYear,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED)+T("    ")+T((strokeS*)stPathToYearP[idSlotPathToYear]) ) ;
{
voidT fileMetaS::traceF( tinBaseS& tinBaseP , stackC& stPathToYearP , const strokeS* const psttP )

}
    timeModRounded = *(countT*)( (byteT*)pc2 + 3 ) + bRoundUp ;
    countT pc2[ 2 ] = { time1Mod , time2Mod } ;

    boolT bRoundUp = !!( ( time1Mod & 0xffffff ) > 0x800000 ) ;

        { BLAMMO ; }
    if( !idSlotPathToYear )
{
idSlotPathToYear( idSlotPathToYearP )
cVotes( 0 ) ,
time2Mod( time2ModP ) ,
time1Mod( time1ModP ) ,
cbUsed( cbUsedP ) ,
timeModRounded( 0 ) ,
fileMetaS::fileMetaS( tinBaseS& tinBaseP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) :

NEWdELcLASS( 1 , fileMetaS ) ;

osTextT* postDebugLever ;

const countT cResultsPerStruct = sizeof( countT ) * SB / 2 ;     // 2 BITS ARE USED TO STORE A RESULT, SO 4 RESULTS FIT INTO A BYTE AND 01 RESULTS FIT INTO A count02T ; MY CODE SHOULD BE WRITTEN WITHOUT ASSUMING countT IS count02T

;
}
    voidT traceF( tinBaseS& tinBaseP , const strokeS* const psttP = 0 ) ;
    inline sCountT operator -( imageCompareS& picP ) { return bitsResult - picP.bitsResult ; }
    imageCompareS( voidT ) ;
    NEWdELcLASSpROTOS

    countT bitsResult ;
{
struct imageCompareS

;
}
    sCountT operator -( const fileMetaS& frP ) const ;
    voidT traceF( tinBaseS& tinBaseP , stackC& stPathToYearP , const strokeS* const psttP = 0 ) ;
    fileMetaS( tinBaseS& tinBaseP , const countT idSlotPathToYearP , countT time1ModP , sCountT time2ModP , count04T cbUsedP ) ;
    NEWdELcLASSpROTOS

    countT   idSlotPathToYear ;
    countT   cVotes ;
    sCountT  time2Mod ;
    countT   time1Mod ;
    count04T cbUsed ;
    countT   timeModRounded ;   //CS:CODEsYNC 1 1
{
struct fileMetaS

#define CyEARSiNpARALLEL  2
//U:: 1 FOR TESTING; PERHAPS 4 FOR PROD

#define BATCHsIZE  ( TUCK >> 0 )

#define BITSrESULT_ALLbITS        3
#define BITSrESULT_EQUAL          2
#define BITSrESULT_NOTeQUAL       1
#define BITSrESULT_UNKNOWN        0

//OBSOLETES 7e0
//OBSOLETED BY NEW ADAM THAT WILL ELIMINATE tmFeedFileWindowsF

/*1*/WAKEsHOWtEXT( "ifcIDaDAM_HEALaRCHIVES" )/*1*/
/**/
*/
 sws consumes memory (e.g. a stackC instance for each short file name)
batch the file processing to eliminate capacity constraint
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
