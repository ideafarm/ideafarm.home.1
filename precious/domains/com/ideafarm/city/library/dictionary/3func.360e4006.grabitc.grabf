
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    //ctCheckF() ;

    //((tinNormalS&)tinBaseP).cGrabitC_registered ++ ; //TO FIND A BUG
    registerDoneF( tinBaseP , idLineP , idiFileP ) ;

    }
        if( pcGOT ) *pcGOT = ((tinNormalS&)tinBaseP).osTid ;

        //}
        //    emitWordsIF( tinBaseP , ifcLINE , IDFILE , pcSuffix , 4 ) ;
        //    countT pcSuffix[] = { 3 , (countT)pbo , offo , 0x1111 } ; //0x1111: "just set bit to 1"  ;  "3" IS LENGTH PREFIX
        //{                                                                                           //U::TO FIND A BUG
        //if( ((tinNormalS&)tinBaseP).pag1->idAdam == ifcIDaDAM_PISS )

        //}
        //    }
        //        countT foo = 2 ;
        //    {
        //    if( !processGlobal2I.pcTrace2[ offTraceMe ] )
        //
        //    //processGlobal2I.pcTrace7[ offTraceMe ] = idiFileP ;
        //    //processGlobal2I.pcTrace6[ offTraceMe ] = idLineP ;
        //    processGlobal2I.pcTrace7[ offTraceMe ] = savebyte2 ;
        //    processGlobal2I.pcTrace6[ offTraceMe ] = savebyte1 ;
        //    processGlobal2I.pcTrace5[ offTraceMe ] = ((tinNormalS&)tinBaseP).monitor.idThread ;
        //    processGlobal2I.pcTrace4[ offTraceMe ] = offo ;
        //    processGlobal2I.pcTrace3[ offTraceMe ] = (countT)pbo ;
        //    processGlobal2I.pcTrace2[ offTraceMe ] = *pbo ;
        //    processGlobal2I.pcTrace1[ offTraceMe ] = 1 ;            // 1:GRAB 2:UNGRAB
        //{
        //if( offTraceMe < sizeof processGlobal2I.pcTrace1 / sizeof processGlobal2I.pcTrace1[ 0 ] )
        //countT offTraceMe = incv02AM( processGlobal2I.cTrace ) ;
        //TO FIND A BUG

        ((tinNormalS&)tinBaseP).cGrabitC_set ++ ; //U:: TO FIND A BUG
        ((tinNormalS&)tinBaseP).cYield = 0 ;
        countT cYield = ((tinNormalS&)tinBaseP).cYield ;
        //savebyte2 = *pbo ;

        //}
        //    *pcBlammo = 7 ;
        //    ZE( countT* , pcBlammo ) ;
        //
        //    LOGrAW3(    "grabitC::grabF [*pcKey]: " , *pcKey , "\r\n" ) ;
        //    CONoUTrAW3( "grabitC::grabF [*pcKey]: " , *pcKey , "\r\n" ) ;
        //{
        //if( !*pbo ) //TO FIND A BUG

        }
            }
                }
                    thirdC::osThreadYieldIF( tinBaseP , idLineP , idiFileP , pbBitsP , msNap ) ;
                {
                while( btsAM( pbo , offo ) )
            {
            else
            }
                }
                    thirdC::osThreadYieldIF( tinBaseP , idLineP , idiFileP , pbBitsP , msNap ) ;
                {
                while( btsKeyedAM( pbo , *pcKey , offo , ((tinNormalS&)tinBaseP).monitor.idThread ) )
            {
            if( pcKey )
        {

        // savebyte1 = *pbo ;
        ((tinNormalS&)tinBaseP).cYield = 0 ;
        idiFileGrabber = idiFileP ; //SINCE THESE VALUES ARE RETAINED WHEN NOT GRABBED, THE MONITOR CAN SEE WHICH GRAB LINES ARE CURRENTLY ACTIVE
        idLineGrabber  = idLineP ; //THESE ARE INFORMATORY ONLY; THEY ARE NOT RESET; THEY ARE OVERWRITTEN HERE
    
        //byteT savebyte2 ;
        //byteT savebyte1 ;

        }
            thirdC::dosPriorityIF( tinBaseP , ifcTHREADpRIORITY_SPINLOCK ) ;
            idDesire = thirdC::dosPriorityIF( tinBaseP ) ;
        {
        if( !( F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERtHREADS ) && F(flagsCt2) & flGRABITc_DESIREcHANGEoNdEMAND )

        registerBegunF( tinBaseP , idLineP , idiFileP ) ;
    {
    else
    }
        ++ *pcGR ;
        registerBegunF( tinBaseP , idLineP , idiFileP , flBASEgRABcrEGISTERbEGUN_RECURSING ) ;

        }
            if( !( *pbo & mask ) ) { BLAMMO ; }     // AND THIS OBJECT'S GRABBED BIT SHOULD BE SET
            byteT mask = (byteT)( 1 << offo ) ;
        {

        if( !pcGR ) { BLAMMO ; }                    // THEN I SHOULD HAVE SET pcGR TO HOLD A RECURSION COUNT
    {
    if( pcGOT && *pcGOT == ((tinNormalS&)tinBaseP).osTid )             // IF I HAVE ALREADY GRABBED AND AM RECURSING

    ;
        : poff_cGrabberRecurse                                    
        ? (countT*)( (byteT*)this + (countT)poff_cGrabberRecurse )
    countT* pcGR = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES                                       // countT CONTAINING THE RECURSION COUNTER

    ;
        :                                   poff_cGrabberOsTid
        ? (countT*)( (byteT*)this + (countT)poff_cGrabberOsTid )
    countT* pcGOT = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES                                      // countT CONTAINING THE osTid THAT HAS THE BIT

    ;
        : poff_key
        ? (countT*)( (byteT*)this + (countT)poff_key )
    countT* pcKey = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES

    ;
        : poff_bo
        ? (byteT*)this + (countT)poff_bo
    byteT* pbo = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES                                         // byteT CONTAINING THE BIT TO BE GRABBED

    }
        }
            poff_cGrabberRecurse          = ( F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES ? (countT*)( (byteT*)&((tinNormalS&)tinBaseP).pcGrabitRecurse[ offr ]   - (byteT*)this ) : &((tinNormalS&)tinBaseP).pcGrabitRecurse[ offr ] ) ;
            poff_cGrabberOsTid            = ( F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES ? (countT*)( (byteT*)&((tinNormalS&)tinBaseP).pcGrabitOsTid[   offr ]   - (byteT*)this ) : &((tinNormalS&)tinBaseP).pcGrabitOsTid[   offr ] ) ;
        {
        else
        if( offr == CmAXgRABITrECURSEiNtINs ) { BLAMMO ; }

        }
            }
                break ;
                ((tinNormalS&)tinBaseP).ppbGrabitRecurse[ offr ] = pbo ;
            {
            if( !((tinNormalS&)tinBaseP).ppbGrabitRecurse[ offr ] )
        {
        if( offr == CmAXgRABITrECURSEiNtINs ) for( offr = 0 ; offr < CmAXgRABITrECURSEiNtINs ; offr ++ )

        }
            if( ((tinNormalS&)tinBaseP).ppbGrabitRecurse[ offr ] == pbo ) break ;
        {
        for( offr = 0 ; offr < CmAXgRABITrECURSEiNtINs ; offr ++ )
        ZE( countT , offr ) ;

        ;
            : poff_bo
            ? (byteT*)this + (countT)poff_bo
        byteT* pbo = F(flagsCt2) & flGRABITc_IMAGEiSvISIBLEtOoTHERpROCESSES                                         // byteT CONTAINING THE BIT TO BE GRABBED
    {
    if( F(flagsCt2) & flGRABITc_RECURSEuSINGtINs )

    if( ((tinNormalS&)tinBaseP).idDesireSetBySelf != ifcTHREADpRIORITY_SPINLOCK ) { BLAMMO ; }

    _IO_

    SCOOP
{
/*1*/voidT grabitC::grabF( tinBaseS& tinBaseP , const countT idLineP , const countT idiFileP , const byteT* const pbBitsP )/*1*/

/**/

*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

