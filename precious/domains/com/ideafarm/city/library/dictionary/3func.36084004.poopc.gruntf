
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    }
        ((tin1S&)tin0P).flagsThreadMode1 = tmSave ;

        }
            thirdC::dosRaiseExceptionIF( tin0P , ifcIDeVENTeXCEPTIONmONITORED_GRUNT , pcArgs , sizeof pcArgs / sizeof pcArgs[ 0 ] ) ;
            countT pcArgs[] = { idLineP , idiFileP , idSubTypeP , idTypeP } ;

                etherC::etRockIF( tin0P ).traceF( tin0P , (strokeS*)(const osTextT*)"gruntF: raising exception"                                      , flTRACE_PARAMETERiSoStEXT | flTRACE_NOcONSOLE | flTRACE_NOtELL ) ;
            else
                etherC::etRockIF( tin0P ).traceF( tin0P , (strokeS*)(const osTextT*)"gruntF: raising exception with no exception handler registered" , flTRACE_PARAMETERiSoStEXT | flTRACE_NOcONSOLE | flTRACE_NOtELL ) ;
            if( !( F(processGlobal2I.flCt) & flCTdTg_EXCEPTIONhANDLERrEGISTERED ) || F(processGlobal2I.flDt) & flCTdTg_EXCEPTIONhANDLERrEGISTERED )
        {
        if( bRaiseException )

        //}
        //    BLAMMOiD( 0x99119911 ) ;    //U:: TO FIND A BUG
        //
        //    etRock.traceF( tin0P , T("gruntF / NOTeNOUGHmEMORY ; traced  pool tallies and memory grain report") ) ;
        //    etRock.traceMemoryGrainRptF( tin0P ) ;
        //    etRock.tracePoolTalliesF( tin0P ) ;
        //    etRock.traceF( tin0P , T("gruntF / NOTeNOUGHmEMORY ; tracing pool tallies and memory grain report") ) ;
        //    etherC& etRock = etherC::etRockIF( tin0P ) ;
        //{
        //if( idSubTypeP == ifcIDiMPOTENCEbASEeRRORcODE_NOTeNOUGHmEMORY )
        //THIS IS COMMENTED OUT SO THAT socketC::readF WILL FAIL GRACEFULLY IF IT TRIES TO OBTAIN A poolC DROP OF SIZE length WHERE length IS GARBAGE

        }
            etherC::etRockIF( tin0P ).traceF( tin0P , (strokeS*)(const osTextT*)ostoSay , flTRACE_PARAMETERiSoStEXT | flTRACE_NOcONSOLE | flTRACE_NOtELL ) ;
                    
            OStEXTC(  ostoSay , idSubTypeP , 0 ) ;
            OStEXTAK( ostoSay , " idSubTypeP:" ) ;
            OStEXTC(  ostoSay , idTypeP , 0 ) ;
            OStEXTAK( ostoSay , ") idTypeP:" ) ;
            OStEXTC(  ostoSay , idiFileP , 0 ) ;
            OStEXTAK( ostoSay , "(" ) ;
            OStEXTC(  ostoSay , idLineP , 0 ) ;
            OStEXTAK( ostoSay , " ) at " ) ;
            //OStEXTA(  ostoSay , slabS::slabIF().flagsi & fliSLABs_SHUTDOWN             ? " shutdown"    : "" ) ;
            OStEXTA(  ostoSay , F(((tin1S&)tin0P).flagsThreadMode2) & flTHREADmODE2_SMELLY         ? " forceSmelly" : "" ) ;
            OStEXTA(  ostoSay , F(flags) & flPOOP_SMELLY                                ? " smelly"      : "" ) ;
            OStEXTA(  ostoSay , F(((tin1S&)tin0P).flagsThreadMode1) & flTHREADmODE1_QUIETiMPOTENCE ? " quiet"       : "" ) ;
            OStEXTA(  ostoSay , idTypeP == ifcIDtYPEpOOP_FIRED                          ? " fired"       : "" ) ;
            OStEXTAK( ostoSay , "gruntF (" ) ;
            OStEXT(   ostoSay , TUCK << 2 ) ;

            //}
            //    countT foo = 2 ;
            //{
            //if( ((tin1S&)tin0P).glass.idThread == ifcIDtHREADlOW_tmWatchF )
        {
        if( bTrace )

        ;

            //ze
            //&&
            //TO FIND A BUG

            !( slabS::slabIF().flagsi & fliSLABs_SHUTDOWN )
            &&
            ( F(flags) & flPOOP_SMELLY || F(((tin1S&)tin0P).flagsThreadMode2) & flTHREADmODE2_SMELLY )
            &&
            !( F(((tin1S&)tin0P).flagsThreadMode1) & flTHREADmODE1_QUIETiMPOTENCE )

        const boolT bRaiseException =
        //ZE( countT , ze ) ;

        const boolT bTrace = F(flags) & flPOOP_SMELLY && !( F(((tin1S&)tin0P).flagsThreadMode1) & flTHREADmODE1_QUIETiMPOTENCE ) && F(processGlobal2I.flCt) & flCTdTg_WITHINlIFETIMEoFmAIN && !( F(processGlobal2I.flDt) & flCTdTg_WITHINlIFETIMEoFmAIN ) ; //SILENCES EARLY/LATE TRACING

        idiFileGrunt = idiFileP ;
        idLineGrunt = idLineP ;
        if( idTypeP == ifcIDtYPEpOOP_FIRED ) flags &= ~( F(flPOOP_SMELLY) ) ;
        idType = idTypeP ;

        ((tin1S&)tin0P).flagsThreadMode1 &= ~( F(flTHREADmODE1_UPDATEtIN) ) ; //CONJ: NO LONGER NEEDED (IF IN OUT IS REMOVED)
        flagsT tmSave = ((tin1S&)tin0P).flagsThreadMode1 ;

        }
            if( ((tin1S&)tin0P).pag1->_etherC_.pEtLongLasting && this == &((tin1S&)tin0P).pag1->_etherC_.pEtLongLasting->poop ) { BLAMMOiD( 0x44444444 ) ; }
            if( ((tin1S&)tin0P).pag1->_etherC_.pEtPaint       && this == &((tin1S&)tin0P).pag1->_etherC_.pEtPaint->poop       ) { BLAMMOiD( 0x33333333 ) ; }
            if( ((tin1S&)tin0P).pag1->_etherC_.pEtText        && this == &((tin1S&)tin0P).pag1->_etherC_.pEtText->poop        ) { BLAMMOiD( 0x22222222 ) ; }
            if( ((tin1S&)tin0P).pag1->_etherC_.pEtRock        && this == &((tin1S&)tin0P).pag1->_etherC_.pEtRock->poop        ) { BLAMMOiD( 0x11111111 ) ; }
        {
        if( ((tin1S&)tin0P).pag1 )          //CS:CODEsTYLE: IT IS BAD CODING STYLE TO USE *pEtRock *pEtText ETC. IN A WAY THAT RISKS IMPOTENCE ; THIS BLOCK IS INTENDED TO PRODUCE AN EXCEPTION REPORT (WITH CALL NEST) IF ANY OF THESE FO etherC INSTANCES ARE ABOUT TO BECOME IMPOTENT

        }
            *pcBlammo = 0x12345678 ;
            countT* pcBlammo = (countT*)( - 1 ) ;

c_pPoopLong  = (countT)&((tin1S&)tin0P).pag1->_etherC_.pEtLongLasting->poop ;
c_pPoopPaint = (countT)&((tin1S&)tin0P).pag1->_etherC_.pEtPaint->poop ;
c_pPoopText  = (countT)&((tin1S&)tin0P).pag1->_etherC_.pEtText->poop ;
c_pPoopRock  = (countT)&((tin1S&)tin0P).pag1->_etherC_.pEtRock->poop ;
c_this       = (countT)this ;
static countT c_pPoopLong ;
static countT c_pPoopPaint ;
static countT c_pPoopText ;
static countT c_pPoopRock ;
static countT c_this ;
        {
        if( F(flags) & flPOOP_BLAMMO )
    {
    if( idSubTypeP && !setIfZeAM( idSubType , idSubTypeP ) )

    if( getNegAM( fingerprint ) != FINGERnEG_POOPc ) { BLAMMOiD( fingerprint | BM_HIGH ) ; }

    //}
    //    etherC::etRockIF( tin0P ).traceF( tin0P , T("gruntF FIREDbYsELF [this]:    ")+TF2((countT)this,flFORMAT_NObIGITvALUES|flFORMAT_UNSIGNED) ) ;
    //{
    //if( idTypeP == ifcIDtYPEpOOP_FIRED && idSubTypeP == ifcIDsUBtYPEpOOP_FIREDbYsELF )

    countT brcLathSave = ((tin1S&)tin0P).brcLath ;
{
/*1*/voidT poopC::gruntF( tin0S& tin0P , const countT idLineP , const countT idiFileP , const byteT* const pbBitsP , const countT idSubTypeP , const countT idTypeP )/*1*/

/**/
*/
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.00101dd.flGRUNT!||
 flagsP
 //||!kt|///ideafarm/precious/domains/com/ideafarm/city/library/dictionary/1snip.001034f.ifcIDtYPEpOOP!||
 idTypeP
 idSubTypeP
 pbBitsP
 idiFileP
 idLineP
 tin0P
arguments
it is illegal to refer to this symbol in the definition of an adam
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2026 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

