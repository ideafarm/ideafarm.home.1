
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return bGrabbed ;

    }
        //((tin9S&)tin0P).pc Utility[ 0 ] = bDebugTrace ;  //U:: TO FIND A BUG
        ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / 0") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
    {
    if( bDebugTrace )
    //U:: TO FIND A BUG

    //}
    //    CONoUTrAW( os ) ;
    //
    //    OStEXTAK(  os , "\r\n" ) ;
    //    }
    //        if( offi % 5 == 3 ) { OStEXTAK(  os , "]" ) ; }
    //        OStEXTC(   os , ((tin9S&)tin0P).pPanLifiRecurseGrabbedLevel[ offi ] , 0 ) ;
    //        else { OStEXTAK(  os , "," ) ; }
    //        }
    //            else { OStEXTAK(  os , " [" ) ; }
    //            }
    //                continue ;
    //                offi += 4 ;
    //            {
    //            if( !((tin9S&)tin0P).pPanLifiRecurseGrabbedLevel[ offi ] )
    //        {
    //        if( !( offi % 5 ) )
    //    {
    //    for( countT offi = 0 ; offi < sizeof ((tin9S&)tin0P).pPanLifiRecurseGrabbedLevel / sizeof ((tin9S&)tin0P).pPanLifiRecurseGrabbedLevel[ 0 ] ; offi ++ )
    //
    //    OStEXTAK( os , "} @@@@" ) ;
    //    OStEXTC(  os , idiFileCt , 0 ) ;
    //    OStEXTAK( os , "," ) ;
    //    OStEXTC(  os , idLineCt , 0 ) ;
    //    OStEXTAK( os , "," ) ;
    //    OStEXTC(  os , this , 0 ) ;
    //    OStEXTAK( os , " | {" ) ;
    //    OStEXTA(  os , ((tin9S&)tin0P).postThreadName ) ;
    //    OStEXTAK( os , " " ) ;
    //    OStEXTC(  os , ((tin9S&)tin0P).monitor.idThread , 0 ) ;
    //    OStEXTAK( os , " | " ) ;
    //    OStEXTC9( os , ((tin9S&)tin0P).osTid ) ;
    //    OStEXTAK( os , " | " ) ;
    //    OStEXTC(  os , idInDebug , '0' ) ;
    //    OStEXT(   os , TUCK << 2 ) ;
    //{
    //if( ((tin9S&)tin0P).pag1->idAdam == 0x4010501 )

    //if( F(((tin9S&)tin0P).flagsThreadMode3) & flTHREADmODE3_ADAMmAINtHREAD ) { CONoUTrAW3( "" , ((tin9S&)tin0P).pag1->idAdam , " G-\r\n" ) ; }
    //if( ((tin9S&)tin0P).monitor.idThread == 1 ) { CONoUTrAW3( "" , ((tin9S&)tin0P).pag1->idAdam , " G-\r\n" ) ; }
    //CONoUTrAW( "-" ) ;
    //if( (countT)this == etherC::ether_cUtility_IF( tin0P , 0 ) ) { LOGrAWtID( "G-" ) ; }
    if( pbBitsP ) ; //U::

    }
        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / 1") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
        registerDoneF( tin0P , idLineP , idiFileP ) ;
        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / 2") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG

        }
            if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / 3") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
            }
                if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / 4") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
                }
                    inc02AM( stat.cAcquisitions ) ;
                    }
                        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / 5") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
                        else                             osTid = osTidMe ;
                        if( osTid )                      { BLAMMO ; }
                        else                             idDesireGrabber  = ((tin9S&)tin0P).idDesireSetBySelf ;
                        if( idDesireGrabber )            { /*((tin9S&)tin0P).pc Utility[ 0xf ] = idDesireGrabber ;*/ BLAMMO ; }
                        if( cGrabbed == - 1 )            { BLAMMO ; }
                        inc02AM( cGrabbed ) ;
                        if( cGrabbed )                   { /*((tin9S&)tin0P).pc Utility[ 0xf ] = cGrabbed ;*/ BLAMMO ; }
                        if( idGrabberOk != idGrabberMe ) { /*((tin9S&)tin0P).pc Utility[ 0xf ] = idGrabberOk ; ((tin9S&)tin0P).pc Utility[ 0xe ] = idGrabberMe ;*/ BLAMMO ; }
                        stat.cCollisionsNew = 0 ; //U:MIGHT OVERWRITE A FEW COLLISIONS THAT SHOULD BE COUNTED AS NEW (I.E. SINCE INCREMENTING idGrabberOk)
            
                        processGlobal2I._grabC_pgw[ ogw ].osTid = 0 ; //MUST BE ZEED LATH; NOTE THAT bDirty IS NOT RESET
                        processGlobal2I._grabC_pgw[ ogw ].osPid = 0 ;
                        processGlobal2I._grabC_pgw[ ogw ].idGrabber = 0 ;
                        processGlobal2I._grabC_pgw[ ogw ].idGrab = 0 ;
                        }
                            processGlobal2I._grabC_pgw[ ogw ].hThread.closeIfF() ;
                            _IO_
                        {
                        processGlobal2I._grabC_pgw[ ogw ].idThread = 0 ;
                        processGlobal2I._grabC_pgw[ ogw ].flags = 0 ;
                        processGlobal2I._grabC_pgw[ ogw ].bDirty = 1 ;
        
                        }
                            thirdC::dosWriteStdOutIF( ostoBuf ) ;
                            OStEXTA( ostoBuf , "\r\n" ) ;
                            if( tin0P.idTypeTin == ifcIDtYPEtIN_FULL ) OStEXTA( ostoBuf , ((tin9S&)tin0P).postThreadName ) ;
                            OStEXTA( ostoBuf , " " ) ;
                            OStEXTC( ostoBuf , ((tin9S&)tin0P).monitor.idThread , 0 ) ;
                            OStEXTA( ostoBuf , "THAWED " ) ;
                            OStEXT( ostoBuf , 0x140 )
                        {
                        if( F(processGlobal2I._grabC_pgw[ogw].flags) & flGRABwANT_CHATTERrESUME )

                        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / 6") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
                        thirdC::dosSuspendThreadIF( tin0P ) ;
                        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / 7") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG

                        }
                            thirdC::dosWriteStdOutIF( ostoBuf ) ;
                            OStEXTA( ostoBuf , "\r\n" ) ;
                            if( tin0P.idTypeTin == ifcIDtYPEtIN_FULL ) OStEXTA( ostoBuf , ((tin9S&)tin0P).postThreadName ) ;
                            OStEXTA( ostoBuf , " " ) ;
                            OStEXTC( ostoBuf , ((tin9S&)tin0P).monitor.idThread , 0 ) ;
                            OStEXTA( ostoBuf , "FROZEN " ) ;
                            OStEXT( ostoBuf , 0x140 )
                        {
                        if( F(processGlobal2I._grabC_pgw[ogw].flags) & flGRABwANT_CHATTERrESUME )
                        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / 8") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
                        _IO_
                    {
                    else
                    }
                        THREADmODE2rESTORE
                        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / 9") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
                        }
                            }
                                break ;
        
                                else                             osTid = osTidMe ;
                                if( osTid )                      { BLAMMO ; }
                                else                             idDesireGrabber  = ((tin9S&)tin0P).idDesireSetBySelf ;
                                if( idDesireGrabber )            { BLAMMO ; }
                                if( cGrabbed == - 1 )            { BLAMMO ; }
                                inc02AM( cGrabbed ) ;
                                if( cGrabbed )                   { BLAMMO ; }
                                stat.cCollisionsNew = 0 ; //U:MIGHT OVERWRITE A FEW COLLISIONS THAT SHOULD BE COUNTED AS NEW (I.E. SINCE INCREMENTING idGrabberOk)
                            {
                            if( idGrabberOk == idGrabberMe )
                            ++ s ; thirdC::dosSleepRawIF( tin0P , 1 ) ;      //20201206@1637: 0x20 -> 1
                        {
                        for(;;)
                        sleepC s( tin0P , TAG( TAGiDnULL ) ) ;
                        THREADmODE2oN( flTHREADmODE2_ALLOWsTOPwHILEgRABBING )
                        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / a") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
                        }
    /*S*/                   thirdC::dosPriorityIF( tin0P , idDesireSave ) ;
                            _IO_
                        {
    /*S*/               _IO_
    /*S*/           {
    /*S*/           if( !bRegistered )
    /*S*/
    /*S*/           inc02AM( stat.cCollisionsNew ) ;
    /*S*/           inc02AM( stat.cCollisions ) ;
        
                    }
                        }
                            break ;
                            }
                                bRegistered = 1 ;
                                if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / b") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
                                }
    /*S*/                           thirdC::dosPriorityIF( tin0P , idDesireSave ) ;
                                    _IO_
                                {
    /*S*/    
    /*S*/                       processGlobal2I._grabC_pgw[ ogw ].bDirty = 0 ;
    /*S*/                       processGlobal2I._grabC_pgw[ ogw ].idThread = ((tin9S&)tin0P).monitor.idThread ;
    /*S*/                       processGlobal2I._grabC_pgw[ ogw ].osPid = ((tin9S&)tin0P).osPid ;
    /*S*/                       processGlobal2I._grabC_pgw[ ogw ].idGrabber = idGrabberMe ; // SCANNER LOOKS FOR THESE OO VALUES
    /*S*/                       processGlobal2I._grabC_pgw[ ogw ].idGrab = idMe ;           // SCANNER LOOKS FOR THESE OO VALUES
    /*S*/                       processGlobal2I._grabC_pgw[ ogw ].flags = F(((tin9S&)tin0P).flagsThreadMode3) & flTHREADmODE3_CHATTERgRABwANTfREEZES ? flGRABwANT_CHATTERrESUME : flGRABwANT_null ;
                                _IO_
    /*S*/                   {
    /*S*/                   else
    /*S*/                   }
    /*S*/                       processGlobal2I._grabC_pgw[ ogw ].osTid = 0 ;
    /*S*/                       //LOGrAWtID( "i could not clone a thread handle to myself" ) ; //U:: USED TO BLAMMO HERE; TO MAKE SERVER RELIABLE, I NOW JUST ABANDON SLOTTING
    /*S*/                       //CONoUTrAW( "i could not clone a thread handle to myself\r\n" ) ; //U:: USED TO BLAMMO HERE; TO MAKE SERVER RELIABLE, I NOW JUST ABANDON REGISTERING
    /*S*/                   {
    /*S*/                   if( !processGlobal2I._grabC_pgw[ ogw ].hThread )
    /*S*/                   processGlobal2I._grabC_pgw[ ogw ].hThread.osF( ifcIDtYPEhANDLE_THREAD , (countT)osh ) ;
    /*S*/
    /*S*/                   countT osh = thirdC::osHandleCloneIF( tin0P , note , oshtMe , ifcIDtYPEhANDLE_THREAD , oshpMe , oshpMe ) ;
    /*S*/
    /*S*/                   countT oshtMe = thirdC::osOpenThreadIF() ;
    /*S*/                   ZE( countT , note ) ;
    /*S*/                   countT oshpMe = hProcessMe.osF( ifcIDtYPEhANDLE_PROCESS ) ;
    /*S*/                   hProcessMe.osF( ifcIDtYPEhANDLE_PROCESS , thirdC::osOpenProcessIF() ) ;
    /*S*/                   handleC hProcessMe( tin0P , TAG( TAGiDnULL ) , ifcIDtYPEhANDLE_PROCESS ) ;
    /*S*/
    /*S*/                   if( !processGlobal2I._grabC_pgw[ ogw ].bDirty    ) { BLAMMO ; }
    /*S*/                   if(  processGlobal2I._grabC_pgw[ ogw ].idGrabber ) { BLAMMO ; }
    /*S*/                   if(  processGlobal2I._grabC_pgw[ ogw ].idGrab    ) { BLAMMO ; }
                            _IO_
    /*S*/               {
    /*S*/               if( !setIfZeAM( processGlobal2I._grabC_pgw[ ogw ].osTid , osTidMe ) ) //ASSUME: IF !osTid THEN THE SLOT IS FREE (I.E. osTid IS THE LATH TO BE ZEED)
                        _IO_
    /*S*/           {
    /*S*/           if( F(flags) & flGRABc_ISsIGN || !( F(((tin9S&)tin0P).pag1->_thirdC_.flagsModeAdam1) & flADAMmODE1_LOGdEADLOCKS ) ) for( ogw = 0 ; ogw < processGlobal2I._grabC_cgw ; ogw ++ )
    /*S*/           ZE( countT , ogw ) ;
    /*S*/           ZE( boolT , bRegistered ) ;
                    _IO_
    /*S*/       {
    /*S*/       else
                }
                    inc02AM( stat.cAcquisitions ) ;
                    else        osTid = osTidMe ;
                    if( osTid ) { BLAMMO ; }
                    if( cGrabbed == - 1 )            { BLAMMO ; }
                    inc02AM( cGrabbed ) ;
                    if( cGrabbed )                   { BLAMMO ; }
                    stat.cCollisionsNew = 0 ; //U:MIGHT OVERWRITE A FEW COLLISIONS THAT SHOULD BE COUNTED AS NEW (I.E. SINCE INCREMENTING idGrabberOk)
                    //CODE SYNCH: 17f0005 1700003
    
                    idDesireGrabber    = ((tin9S&)tin0P).idDesireSetBySelf ;
                    idiFileGrabberNote = 0/*U::*/ ;
                    idLineGrabberNote  = 0/*U::*/ ;
                    idiFileGrabber     = idiFileP ; //SINCE THESE VALUES ARE RETAINED WHEN NOT GRABBED, THE MONITOR CAN SEE WHICH GRAB LINES ARE CURRENTLY ACTIVE
                    idLineGrabber      = idLineP ; //THESE ARE INFORMATORY ONLY; THEY ARE NOT RESET; THEY ARE OVERWRITTEN HERE

                    if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / c") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
                    }
    /*S*/               thirdC::dosPriorityIF( tin0P , idDesireSave ) ;
                        _IO_
                    {
                    _IO_
    /*S*/       {
    /*S*/       if( idGrabberOk == idGrabberMe )
    /*S*/
    /*S*/       countT idGrabberMe = 1 + incv02AM( idGrabberHigh ) ;
    /*S*/
                }
    /*S*/           idDesireSave = thirdC::dosPriorityIF( tin0P , ifcTHREADpRIORITY_SPINLOCK ) ;
                    _IO_
                {
                ZE( countT , idDesireSave ) ;
                if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / d") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG

                // TRYING TO KISS ME WITH THE SPIN PREVENTING ME FROM REGISTERING MYSELF 
                // BUT IF I PUT IT THERE, THAT CREATES A RACE CONDITION: AFTER OBTAINING idGrabberMe BUT BEFORE REGISTERING MYSELF, A RUDE THREAD MIGHT YIELD SPIN
                //THIS IS ONLY NEEDED FOR THE REGISTRATION BLOCK, WHICH I USUALLY WON'T EXECUTE (SINCE USUALLY idGrabberOk == idGrabberMe) ;

                // DON'T DO THIS UNTIL KNOW THAT CHANGING THREAD PRIORITY IS TOO EXPENSIVE TO JUST ALWAYS DO IT OO TIMES HERE
                // THIS MIGHT BE DONE BY INSPECTING idGrabberHigh AND SETTING SPINLOCK IF IT LOOKS LIKE I WILL PROBABLY NEED IT
                //U:: EDIT THIS CODE SO THAT THE RACE IS AVOIDED WHILE ONLY CHANGING PRIORITY WHEN I NEED TO REGISTER

                if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / e") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
                registerBegunF( tin0P , idLineP , idiFileP ) ;
                if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / f") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
                _IO_
            {
            else
            }
                if( cGrabbed == - 1 ) { BLAMMO ; }
                inc02AM( cGrabbed ) ;
                if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / g") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
                registerBegunF( tin0P , idLineP , idiFileP , flBASEgRABcrEGISTERbEGUN_RECURSING ) ;
                if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / h") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
                _IO_
            {
            if( osTid == osTidMe && !( F(flags) & flGRABc_DISABLErECURSION ) )
        
            if( !osTidMe ) { BLAMMO ; }
            const countT osTidMe = ((tin9S&)tin0P).osTid ;
        
            if( F(((tin9S&)tin0P).pag1->_thirdC_.flagsModeAdam1) & flADAMmODE1_DISALLOWgRABoFiNTERPROCESSgRABs && F(flags) & flGRABc_INTERpROCESS ) { BLAMMO ; }
            if( F(((tin9S&)tin0P).flagsThreadMode2     ) &   flTHREADmODE2_DISALLOWgRABoFiNTERPROCESSgRABs && F(flags) & flGRABc_INTERpROCESS ) { BLAMMO ; }
            if( F(flags) & flGRABc_DISABLED ) { BLAMMO ; }
    
            _IO_
            if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / i") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
        {
        else
        }
            cGrabbed ++ ;

            if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / j") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
            registerBegunF( tin0P , idLineP , idiFileP ) ;
            if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / k") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
        {
        if( this == &((tin9S&)tin0P).grabPseudo )
        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / l") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
    {
    if( bGrabbed )

    }
        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / m") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
        }
            }
                }
                    break ;
                    bGrabbed = 0 ;
                {
                else if( vv == setIfEqualsAM( stat.cKissBank , vv - 1 , vv ) )
                if( !vv ) break ;
                countT vv = stat.cKissBank ;
            {
            for(;;)
        {
        else
        }
            }
                }
                    break ;
                    bGrabbed = 0 ;
                {
                else if( vv == setIfEqualsAM( stat.cKissBank , 0 , vv ) )
                if( !vv ) break ;
                countT vv = stat.cKissBank ;
            {
            for(;;)
        {
        if( F(flagsP) & flGRABcGRABf_CLEARkISSbANK )
        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / n") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
    {
    if( F(flagsP) & flGRABcGRABf_WITHDRAWkISSiF )
    boolT bGrabbed = 1 ;

    }
        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / o") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
        thirdC::dosPriorityIF( tin0P , idDesireSave ) ;
        ((tin9S&)tin0P).cYield = 0 ;
        while( osTidLock ) thirdC::osThreadYieldIF( tin0P , TAG( TAGiDnULL ) ) ;
        ((tin9S&)tin0P).cYield = 0 ;
        ZE( countT , idCycle ) ;

        const countT idDesireSave = thirdC::dosPriorityIF( tin0P , ifcTHREADpRIORITY_SPINLOCK ) ;
        if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / p") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
    {
    if( osTidLock && osTidLock != ((tin9S&)tin0P).osTid ) //NO OTHER THREAD GETS TO BEGIN THE GRAB RECIPE UNTIL THE LOCKER DOES HIS THANG (USUALLY GRABBING)

    //}
    //    CONoUTrAW( os ) ;
    //
    //    OStEXTAK(  os , "\r\n" ) ;
    //    }
    //        if( offi % 5 == 3 ) { OStEXTAK(  os , "]" ) ; }
    //        OStEXTC(   os , ((tin9S&)tin0P).pPanLifiRecurseGrabbedLevel[ offi ] , 0 ) ;
    //        else { OStEXTAK(  os , "," ) ; }
    //        }
    //            else { OStEXTAK(  os , " [" ) ; }
    //            }
    //                continue ;
    //                offi += 4 ;
    //            {
    //            if( !((tin9S&)tin0P).pPanLifiRecurseGrabbedLevel[ offi ] )
    //        {
    //        if( !( offi % 5 ) )
    //    {
    //    for( countT offi = 0 ; offi < sizeof ((tin9S&)tin0P).pPanLifiRecurseGrabbedLevel / sizeof ((tin9S&)tin0P).pPanLifiRecurseGrabbedLevel[ 0 ] ; offi ++ )
    //
    //    OStEXTAK( os , "} ++++" ) ;
    //    OStEXTC(  os , idiFileCt , 0 ) ;
    //    OStEXTAK( os , "," ) ;
    //    OStEXTC(  os , idLineCt , 0 ) ;
    //    OStEXTAK( os , "," ) ;
    //    OStEXTC(  os , this , 0 ) ;
    //    OStEXTAK( os , " | {" ) ;
    //    OStEXTA(  os , ((tin9S&)tin0P).postThreadName ) ;
    //    OStEXTAK( os , " " ) ;
    //    OStEXTC(  os , ((tin9S&)tin0P).monitor.idThread , 0 ) ;
    //    OStEXTAK( os , " | " ) ;
    //    OStEXTC9( os , ((tin9S&)tin0P).osTid ) ;
    //    OStEXTAK( os , " | " ) ;
    //    OStEXTC(  os , idInDebug , '0' ) ;
    //    OStEXT(   os , TUCK << 2 ) ;
    //
    //    idInDebug = 1 + incv02AM( idInDebugLath ) ;
    //    static countT idInDebugLath ;
    //{
    //if( ((tin9S&)tin0P).pag1->idAdam == 0x4010501 )
    //ZE( countT , idInDebug ) ;
    if( bDebugTrace ) ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / q") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG

    }
        //}
        //    //LOGrAWtID2( "batonC::grabF called by ... by " , idi1 ) ;
        //{
        //)
        //    idi0 == 0x4000a01
        //(
        //if
        //ALL OF THE idAdam CASE VALUES ARE OBSOLETED: 0xghij104 -> 0x401jihg -> 0x400jihg -> list.map -> 0x51000zzz
        countT idi3 = IDIfILEcALLER( 3 ) ;
        countT idi2 = IDIfILEcALLER( 2 ) ;
        countT idi1 = IDIfILEcALLER( 1 ) ;
        countT idi0 = IDIfILEcALLER( 0 ) ;
    {
    IFwHEREiSwATCHING
    //U::
    //if( F(((tin9S&)tin0P).flagsThreadMode3) & flTHREADmODE3_ADAMmAINtHREAD ) { CONoUTrAW3( "" , ((tin9S&)tin0P).pag1->idAdam , " G+\r\n" ) ; }
    //if( ((tin9S&)tin0P).pc Utility[ 0 ] ) { CONoUTrAW3( "\r\n" , this , " ++++++++\r\n" ) ; }

    SCOOP

    }
        ((tin9S&)tin0P).pEther->traceF( tin0P , T("U:: grabC::grabF / r") , flTRACE_HOMEeCHO | flTRACE_FORCEnOsILENCE , ifcIDtRACEdIVERT_3 ) ; //U:: TO FIND A BUG
        //((tin9S&)tin0P).pc Utility[ 0 ] = 0 ;  //U:: TO FIND A BUG
    {
    if( bDebugTrace )
    boolT bDebugTrace = 0/*((tin9S&)tin0P).pc Utility[ 0 ]*/ ;      //U:: TO FIND A BUG
{
/*1*/boolT grabC::grabF( tin0S& tin0P , const countT idLineP , const countT idiFileP , const byteT* const pbBitsP , const flagsT flagsP )/*1*/
/**/
*/
\<A HREF=\"5.17f0005.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$grabF.0.html\"\>instances\</A\>
     write my data
     remove myself from the wanter array
     suspend myself
    else   
    if i cannot register myself in the wanter array: sleep loop until i am the ok, and then insert my data
   else
   if i am the ok: write my data into fields
  else
  if i already have it then just increment cGrabbed
 else
 if kiss bank balance decrement kiss bank and return
 wait for tid lock to clear
pseudocode
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

