
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


}
    return idPortMe ;
    dec02AM( cFunctionsPending ) ;
    }
    
        }
            }
                pMapPortBind->idPortActual = idPortMe ;
                pMapPortBind = &pMap->pPort[ offp ] ;
            {
            if( offp < cSlots )
    
            }
                if( !setIfZeAM( pMap->pPort[ offp ].idPortSpecified , idPortP ) ) break ;
            {
            for( ; offp < cSlots ; offp ++ )
            ZE( countT , offp ) ;
            const countT cSlots = sizeof pMap->pPort / sizeof pMap->pPort[ 0 ] ;
        {
        if( pMap )
        bWrite.ungrabF( tin0P ) ;
        bRead.ungrabF( tin0P ) ;
        }
            pEther->traceF( tin0P , tSay ) ;
            //LOGrAW( tSay ) ;
            //CONoUTrAW( tSay ) ;
            TN( tSay , "" ) ; tSay = TF2(((tin1S&)tin0P).pag1->idAdam,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("/bindF: bound to port ")+TF4(idPortMe,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES|flFORMAT_FOREIGN,0,0xa)+T(" rather than to ")+TF2(idPortP,flFORMAT_UNSIGNED|flFORMAT_NObIGITvALUES)+T("\r\n") ;
        {
        if( pMap )
        THREADmODE1rESTORE
        idPortMe = pEther->sockBindF( tin0P , handle , idPortRequest , nicNameP , cTriesP ) ;
        THREADmODE1oN( flTHREADmODE1_ALLOWsTOPwHILEgRABBING )
        countT idPortRequest = pMap ? idPortActual : idPortP ;
        if( bInUseOkP ) pEther->sockOptionReuseAddressF( tin0P , handle ) ;
        bRead.grabF( tin0P , TAG( TAGiDnULL ) ) ;
        bWrite.grabF( tin0P , TAG( TAGiDnULL ) ) ;
    
        }
            }
                cToDo -- ;
                pMap ++ ;
    
                }
                    break ;
    
                    }
                        }
                            break ;
                            idPortActual = pMap->pPort[ offp ].idPortActual ;
                        {
                        if( idPortP == pMap->pPort[ offp ].idPortSpecified )
                    {
                    for( countT offp = 0 ; offp < sizeof pMap->pPort / sizeof pMap->pPort[ 0 ] ; offp ++ )
    
                    }
                        break ;
                        pMap = 0 ;
                    {
                    if( F(pMap->flagsHome) & flIPmAPhOMEs_NOmAPPING || !pMap->nnHome )
                {
                if( pMap->idHome == etherC::ifc_idHomeIdisk_IF() )
            {
            while( cToDo )
            countT cToDo = CiPmAPhOME ;
            pMap = (ipMapHomeS*)(byteT*)processGlobal8I._socketC_napIpMapHome ;
        {
        if( idPortP )
        ZE( countT , idPortActual ) ;
        ZE( ipMapHomeS* , pMap ) ;
    
        _IO_
    
        }
            }
                return 0 ;
                dec02AM( cFunctionsPending ) ;
            {
            if( *pEther )
        {
        IFbEcAREFUL    
        SCOOPP
    {
    inc02AM( cFunctionsPending ) ;
{
/*1*/countT socketC::bindF( tin0S& tin0P , const countT idPortP , const nicNameC nicNameP , const countT cTriesP , const boolT bInUseOkP )/*1*/

/**/
*/
  if 0 then will retry forever until successful
  can be 0
 cTriesP
 nicNameP
 idPortP
arguments
see the sockBindF instruction for etherC objects
associates this socket with the specified port and host
  \<A HREF=\"5.7420104.1.1.0.html\"\>7420104:  WAKEsHOW( "example.simplest.func.1070005.socketC.bindF" )\</A\>
 simplest
examples
\<A HREF=\"5.1070005.1.0.html\"\>definition\</A\>
\<A HREF=\"6.$bindF.0.html\"\>instances\</A\>
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2025 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

