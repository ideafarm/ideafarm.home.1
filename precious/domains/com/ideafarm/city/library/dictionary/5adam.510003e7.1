
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
// Respecting the rights of other people is an important part of empowering one another.
//


REST

}
    DEL( ps ) ;
    }
        }
            }
                __1
                __( idTypeInfo ) ;
            {
            default:
            }
                break ;

                //U:HEX DUMP THIS BIT MAP; BETTER: INTERPRET IT AND LIST THE idPort VALUES FOR WHICH THE BIT IS SET
                //U: soul.shiftLeftF( tinBaseP , ifcIDtYPEsOULiTEM_byteTptr , pbData , rMiddle.cbData - 5 ) ;             // BIT MAP

                etThread.strokeF( tinBaseP , TF1(idProtocol)+te ) ;
                soul >> idProtocol ;
                ZE( countT , idProtocol ) ;

                etThread.strokeF( tinBaseP , T(idh)+tb ) ;
                soul >> idh ;
                nicNameC idh ;
                etThread.strokeF( tinBaseP , T("WKS")+tb ) ;
            {
            case ifcIDtYPEdNSqUERY_WKS :
            }
                break ;

                }
                    time2 = time1 = 0 ;
                    etThread.strokeF( tinBaseP , TT(time1,time2)+(cTries?tb:te) ) ;
                    soul >> (countT&)time2 ;
                    soul >> time1 ;
                {
                while( cTries -- )
                countT cTries = 4 ; // REFRESH RETRY EXPIRE MINIMUM
                ZE( sCountT , time2 ) ;
                ZE( countT  , time1 ) ;

                etThread.strokeF( tinBaseP , TF1(cSerial)+tb ) ;
                soul >> cSerial ;
                ZE( countT , cSerial ) ;

                etThread.delF( tinBaseP , psttw ) ;
                etThread.strokeF( tinBaseP , tq+T(psttw)+tq+tb ) ;
                soul >> psttw ;

                etThread.delF( tinBaseP , psttw ) ;
                etThread.strokeF( tinBaseP , tq+T(psttw)+tq+tb ) ;
                soul >> psttw ;
                ZE( strokeS* , psttw ) ;
                etThread.strokeF( tinBaseP , T("SOA")+tb ) ;
            {
            case ifcIDtYPEdNSqUERY_SOA :
            }
                break ;
                etThread.strokeF( tinBaseP , te ) ;
                //U:HEX DUMP THIS DATA
                //U:soul.shiftLeftF( tinBaseP , ifcIDtYPEsOULiTEM_byteTptr , pbData , rMiddle.cbData ) ;
                etThread.strokeF( tinBaseP , T("NULL")+tb ) ;
            {
            case ifcIDtYPEdNSqUERY_NULL :
            }
                break ;

                etThread.delF( tinBaseP , psttw ) ;
                etThread.strokeF( tinBaseP , tq+T(psttw)+tq+te ) ;
                soul >> psttw ;
                ZE( strokeS* , psttw ) ;

                etThread.strokeF( tinBaseP , TF1(cRank)+tb ) ;
                soul >> cRank ;
                ZE( countT , cRank ) ;
                etThread.strokeF( tinBaseP , T("MX")+tb ) ;
            {
            case ifcIDtYPEdNSqUERY_MX :
            }
                break ;

                }
                    etThread.delF( tinBaseP , psttw ) ;
                    etThread.strokeF( tinBaseP , tq+T(psttw)+tq+(cText?tb:te) ) ;
                    soul >> psttw ;
                    ZE( strokeS* , psttw ) ;
                {
                while( cText -- )

                etThread.strokeF( tinBaseP , TF1(cText)+tb ) ;
                soul >> cText ;
                ZE( countT , cText ) ;
                etThread.strokeF( tinBaseP , T("")+tb ) ;
            {
            case ifcIDtYPEdNSqUERY_TXT :
            case ifcIDtYPEdNSqUERY_HINFO :
            }
                break ;
                etThread.delF( tinBaseP , psttw ) ;
                etThread.strokeF( tinBaseP , tq+T(psttw)+tq+te ) ;
                soul >> psttw ;
                ZE( strokeS* , psttw ) ;

                }
                    case ifcIDtYPEdNSqUERY_PTR   : { etThread.strokeF( tinBaseP , T("PTR")+tb ) ; break ; }
                    case ifcIDtYPEdNSqUERY_MR    : { etThread.strokeF( tinBaseP , T("MR")+tb ) ; break ; }
                    case ifcIDtYPEdNSqUERY_MG    : { etThread.strokeF( tinBaseP , T("MG")+tb ) ; break ; }
                    case ifcIDtYPEdNSqUERY_MB    : { etThread.strokeF( tinBaseP , T("MB")+tb ) ; break ; }
                    case ifcIDtYPEdNSqUERY_CNAME : { etThread.strokeF( tinBaseP , T("CNAME")+tb ) ; break ; }
                    case ifcIDtYPEdNSqUERY_NS    : { etThread.strokeF( tinBaseP , T("NS")+tb ) ; break ; }
                {
                switch( idTypeInfo )
            {
            case ifcIDtYPEdNSqUERY_PTR :
            case ifcIDtYPEdNSqUERY_MR :
            case ifcIDtYPEdNSqUERY_MG :
            case ifcIDtYPEdNSqUERY_MB :
            case ifcIDtYPEdNSqUERY_CNAME :
            case ifcIDtYPEdNSqUERY_NS :
            }
                etThread.delF( tinBaseP , psttw ) ; // INTENTIONAL FALLTHROUGH
                etThread.strokeF( tinBaseP , tq+T(psttw)+tq+tb ) ;
                soul >> psttw ;
                ZE( strokeS* , psttw ) ;
                etThread.strokeF( tinBaseP , T("MINFO")+tb ) ;
            {
            case ifcIDtYPEdNSqUERY_MINFO :
            }
                break ;
                etThread.strokeF( tinBaseP , T(idh)+te ) ;
                soul >> idh ;
                nicNameC idh ;
                etThread.strokeF( tinBaseP , T("A")+tb ) ;
            {
            case ifcIDtYPEdNSqUERY_A :
        {
        switch( idTypeInfo )

        }
            time2 = time1 = 0 ;
            etThread.strokeF( tinBaseP , TT(time1,time2)+tb ) ;
            soul >> (countT&)time2 ;
            soul >> time1 ;
            ZE( sCountT , time2 ) ;
            ZE( countT  , time1 ) ;
        {

        etThread.strokeF( tinBaseP , TF1(idClass)+tb ) ;
        soul >> idClass ;
        ZE( countT , idClass ) ;

        soul >> idTypeInfo ;
        ZE( countT , idTypeInfo ) ;

        }
            etThread.delF( tinBaseP , psttw ) ;
            etThread.strokeF( tinBaseP , tq+T(psttw)+tq+tb ) ;
            soul >> psttw ;
            ZE( strokeS* , psttw ) ;
        {

        }
            }
                __1
                __( idTypeAnswer ) ;
            {
            default:
            case ifcIDtYPEdNSrEPLY_NOTE      : { etThread.strokeF( tinBaseP , tNote+tb ) ; break ; }
            case ifcIDtYPEdNSrEPLY_AUTHORITY : { etThread.strokeF( tinBaseP , tAuth+tb ) ; break ; }
            case ifcIDtYPEdNSrEPLY_ANSWER    : { etThread.strokeF( tinBaseP , tAnsw+tb ) ; break ; }
        {
        switch( idTypeAnswer )
        soul >> idTypeAnswer ;
        ZE( countT , idTypeAnswer ) ;

        soulC& soul = *ps ;
    {
    if( ps )
    stSoul >> ps ;
    ZE( soulC* , ps ) ;
{
while( !etThread && stSoul )
TN( tq    , "\"" ) ;
TN( te    , "\r\n" ) ;
TN( tb    , " " ) ;
TN( tNote , "note" ) ;
TN( tAuth , "auth" ) ;
TN( tAnsw , "answ" ) ;

etThread.strokeF( tinBaseP , T("cRecords: ")+TF1((countT)stSoul)+T("\r\n") ) ;
etThread.dnsQueryF( tinBaseP , stSoul , tDomain , ifcIDtYPEdNSqUERY_ALL ) ;
stackC stSoul( tinBaseP , etThread , TAG( TAGiDnULL ) , flSTACKc_FIFO , ifcSTACKtYPE_PTR_soulC ) ;

}
    }
        break ;
        tDomain = T(psttc1) ;
        if( cSkip && cSkip -- ) continue ;
    {
    FORsTRINGSiN1( pstt1p )
    countT cSkip = 2 ;
    strokeS* pstt1p = etThread.ether_pstt1_processParametersI_F( tinBaseP ) ;
{
TN( tDomain , "ideafarm.com" ) ;

TODO

/*1*/WAKEhIDE( "example.other.func.103018b.etherC.dnsQueryF" )/*1*/
/**/
*/
/*

//
// Respecting the rights of other people is an important part of empowering one another.
// This proprietary software was crafted at great expense and with great hardship by one man.  It took 33 years.
//
// Copyright (c) 1992-2024 Wo Of Ideafarm.  All rights reserved.  See https://github.com/ideafarm/ideafarm.home.1 for permitted uses.
//

